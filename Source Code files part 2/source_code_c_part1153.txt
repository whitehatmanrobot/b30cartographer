GESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepLodsFrag8)

DEF_INSTR(OP_FsRepLods32,
              0, 0, REGEAX|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepLodsFrag32)
DEF_INSTR(OP_FsRepLods16,
              0, 0, REGAX|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepLodsFrag16)
DEF_INSTR(OP_FsRepLods8,
              0, 0, REGAL|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepLodsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Scas32,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasFrag32)
DEF_INSTR(OP_ScasNoFlags32,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_Scas16,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasFrag16)
DEF_INSTR(OP_ScasNoFlags16,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_Scas8,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasFrag8)
DEF_INSTR(OP_ScasNoFlags8,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_FsScas32,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasFrag32)
DEF_INSTR(OP_FsScasNoFlags32,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_FsScas16,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasFrag16)
DEF_INSTR(OP_FsScasNoFlags16,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_FsScas8,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasFrag8)
DEF_INSTR(OP_FsScasNoFlags8,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_RepnzScas32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasFrag32)
DEF_INSTR(OP_RepnzScasNoFlags32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_RepnzScas16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasFrag16)
DEF_INSTR(OP_RepnzScasNoFlags16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_RepnzScas8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasFrag8)
DEF_INSTR(OP_RepnzScasNoFlags8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_FsRepnzScas32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasFrag32)
DEF_INSTR(OP_FsRepnzScasNoFlags32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_FsRepnzScas16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasFrag16)
DEF_INSTR(OP_FsRepnzScasNoFlags16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_FsRepnzScas8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasFrag8)
DEF_INSTR(OP_FsRepnzScasNoFlags8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_RepzScas32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasFrag32)
DEF_INSTR(OP_RepzScasNoFlags32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_RepzScas16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasFrag16)
DEF_INSTR(OP_RepzScasNoFlags16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_RepzScas8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasFrag8)
DEF_INSTR(OP_RepzScasNoFlags8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_FsRepzScas32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasFrag32)
DEF_INSTR(OP_FsRepzScasNoFlags32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_FsRepzScas16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasFrag16)
DEF_INSTR(OP_FsRepzScasNoFlags16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_FsRepzScas8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasFrag8)
DEF_INSTR(OP_FsRepzScasNoFlags8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasNoFlagsFrag8)

DEF_INSTR(OP_Stos32,
              0, 0, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StosFrag32)
DEF_INSTR(OP_Stos16,
              0, 0, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StosFrag16)
DEF_INSTR(OP_Stos8,
              0, 0, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StosFrag8)

DEF_INSTR(OP_RepStos32,
              0, 0, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepStosFrag32)
DEF_INSTR(OP_RepStos16,
              0, 0, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepStosFrag16)
DEF_INSTR(OP_RepStos8,
              0, 0, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepStosFrag8)

DEF_INSTR(OP_Movs32,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MovsFrag32)
DEF_INSTR(OP_Movs16,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MovsFrag16)
DEF_INSTR(OP_Movs8,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MovsFrag8)

DEF_INSTR(OP_FsMovs32,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsMovsFrag32)
DEF_INSTR(OP_FsMovs16,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsMovsFrag16)
DEF_INSTR(OP_FsMovs8,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsMovsFrag8)

DEF_INSTR(OP_RepMovs32,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepMovsFrag32)
DEF_INSTR(OP_RepMovs16,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepMovsFrag16)
DEF_INSTR(OP_RepMovs8,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepMovsFrag8)

DEF_INSTR(OP_FsRepMovs32,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepMovsFrag32)
DEF_INSTR(OP_FsRepMovs16,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepMovsFrag16)
DEF_INSTR(OP_FsRepMovs8,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepMovsFrag8)

DEF_INSTR(OP_Cmps32,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpsFrag32)
DEF_INSTR(OP_Cmps16,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpsFrag16)
DEF_INSTR(OP_Cmps8,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpsFrag8)

DEF_INSTR(OP_RepzCmps32,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzCmpsFrag32)
DEF_INSTR(OP_RepzCmps16,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzCmpsFrag16)
DEF_INSTR(OP_RepzCmps8,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzCmpsFrag8)

DEF_INSTR(OP_FsRepzCmps32,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzCmpsFrag32)
DEF_INSTR(OP_FsRepzCmps16,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzCmpsFrag16)
DEF_INSTR(OP_FsRepzCmps8,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzCmpsFrag8)

DEF_INSTR(OP_FsCmps32,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsCmpsFrag32)
DEF_INSTR(OP_FsCmps16,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsCmpsFrag16)
DEF_INSTR(OP_FsCmps8,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsCmpsFrag8)

DEF_INSTR(OP_RepnzCmps32,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzCmpsFrag32)
DEF_INSTR(OP_RepnzCmps16,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzCmpsFrag16)
DEF_INSTR(OP_RepnzCmps8,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzCmpsFrag8)

DEF_INSTR(OP_FsRepnzCmps32,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzCmpsFrag32)
DEF_INSTR(OP_FsRepnzCmps16,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzCmpsFrag16)
DEF_INSTR(OP_FsRepnzCmps8,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzCmpsFrag8)

DEF_INSTR(OP_PushA32,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushAFrag32)
DEF_INSTR(OP_PushA16,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushAFrag16)

DEF_INSTR(OP_PopA32,
              0, 0, ALLREGS,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopAFrag32)
DEF_INSTR(OP_PopA16,
              0, 0, ALLREGS,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopAFrag16)

DEF_INSTR(OP_Push32,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushFrag32)
DEF_INSTR(OP_Push16,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushFrag16)

// Next 2 must be consecutive
DEF_INSTR(OP_Pop32,
              0, 0, REGESP,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFrag32)
DEF_INSTR(OP_Pop32A,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Pop16,
              0, 0, REGESP,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFrag16)
DEF_INSTR(OP_Pop16A,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFrag16A)

DEF_INSTR(OP_Cbw32,
              0, 0, REGEAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CbwFrag32)
DEF_INSTR(OP_Cbw16,
              0, 0, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CbwFrag16)

DEF_INSTR(OP_Cwd32,
              0, 0, REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CwdFrag32)
DEF_INSTR(OP_Cwd16,
              0, 0, REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CwdFrag16)

DEF_INSTR(OP_Bound32,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              BoundFrag32)
DEF_INSTR(OP_Bound16,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              BoundFrag16)

DEF_INSTR(OP_Enter32,
              0, 0, REGESP|REGEBP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              EnterFrag32)
DEF_INSTR(OP_Enter16,
              0, 0, REGESP|REGEBP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              EnterFrag16)

DEF_INSTR(OP_Leave32,
              0, 0, REGESP|REGEBP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LeaveFrag32)
DEF_INSTR(OP_Leave16,
              0, 0, REGESP|REGEBP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LeaveFrag16)

DEF_INSTR(OP_Les32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LesFrag32)
DEF_INSTR(OP_Les16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LesFrag16)

DEF_INSTR(OP_Lds32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LdsFrag32)
DEF_INSTR(OP_Lds16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LdsFrag16)

DEF_INSTR(OP_Lss32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LssFrag32)
DEF_INSTR(OP_Lss16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LssFrag16)

DEF_INSTR(OP_Lfs32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LfsFrag32)
DEF_INSTR(OP_Lfs16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LfsFrag16)

DEF_INSTR(OP_Lgs32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LgsFrag32)
DEF_INSTR(OP_Lgs16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LgsFrag16)

DEF_INSTR(OP_BtReg32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtRegFrag32)
DEF_INSTR(OP_BtReg32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtRegFrag32A)
DEF_INSTR(OP_BtReg16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtRegFrag16)
DEF_INSTR(OP_BtReg16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtRegFrag16)

DEF_INSTR(OP_BtsReg32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsRegFrag32)
DEF_INSTR(OP_BtsReg32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsRegFrag32A)
DEF_INSTR(OP_BtsReg16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsRegFrag16)
DEF_INSTR(OP_BtsReg16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsRegFrag16A)

DEF_INSTR(OP_BtcReg32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcRegFrag32)
DEF_INSTR(OP_BtcReg32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcRegFrag32A)
DEF_INSTR(OP_BtcReg16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcRegFrag16)
DEF_INSTR(OP_BtcReg16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcRegFrag16A)

DEF_INSTR(OP_BtrReg32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrRegFrag32)
DEF_INSTR(OP_BtrReg32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrRegFrag32A)
DEF_INSTR(OP_BtrReg16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrRegFrag16)
DEF_INSTR(OP_BtrReg16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrRegFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_BtMem32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtMemFrag32)
DEF_INSTR(OP_BtMem32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtMemFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_BtMem16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtMemFrag16)
DEF_INSTR(OP_BtMem16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtMemFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_BtsMem32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsMemFrag32)
DEF_INSTR(OP_BtsMem32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsMemFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_BtsMem16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsMemFrag16)
DEF_INSTR(OP_BtsMem16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsMemFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_BtcMem32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcMemFrag32)
DEF_INSTR(OP_BtcMem32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcMemFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_BtcMem16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcMemFrag16)
DEF_INSTR(OP_BtcMem16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcMemFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_BtrMem32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrMemFrag32)
DEF_INSTR(OP_BtrMem32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrMemFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_BtrMem16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrMemFrag16)
DEF_INSTR(OP_BtrMem16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrMemFrag16A)

DEF_INSTR(OP_Pushf32,
              ALLFLAGS, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushfFrag32)
DEF_INSTR(OP_Pushf16,
              ALLFLAGS, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushfFrag16)

DEF_INSTR(OP_Popf32,
              0, ALLFLAGS, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopfFrag32)
DEF_INSTR(OP_Popf16,
              0, ALLFLAGS, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopfFrag16)

// Next 4 must be consecutive
DEF_INSTR(OP_Shld32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShldFrag32)
DEF_INSTR(OP_Shld32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShldFrag32A)
DEF_INSTR(OP_ShldNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShldNoFlagsFrag32)
DEF_INSTR(OP_ShldNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShldNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shld16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShldFrag16)
DEF_INSTR(OP_Shld16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShldFrag16A)
DEF_INSTR(OP_ShldNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShldNoFlagsFrag16)
DEF_INSTR(OP_ShldNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShldNoFlagsFrag16A)

// Next 4 must be consecutive
DEF_INSTR(OP_Shrd32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrdFrag32)
DEF_INSTR(OP_Shrd32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrdFrag32A)
DEF_INSTR(OP_ShrdNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrdNoFlagsFrag32)
DEF_INSTR(OP_ShrdNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrdNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shrd16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrdFrag16)
DEF_INSTR(OP_Shrd16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrdFrag16A)
DEF_INSTR(OP_ShrdNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrdNoFlagsFrag16)
DEF_INSTR(OP_ShrdNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrdNoFlagsFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_Bsr32,
              0, FLAG_ZF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsrFrag32)
DEF_INSTR(OP_Bsr32A,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsrFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Bsr16,
              0, FLAG_ZF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsrFrag16)
DEF_INSTR(OP_Bsr16A,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsrFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_Bsf32,
              0, FLAG_ZF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsfFrag32)
DEF_INSTR(OP_Bsf32A,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsfFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Bsf16,
              0, FLAG_ZF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsfFrag16)
DEF_INSTR(OP_Bsf16A,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsfFrag16A)

// Next 4 must be consecutive
DEF_INSTR(OP_Xadd32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag32)
DEF_INSTR(OP_Xadd32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag32A)
DEF_INSTR(OP_XaddNoFlags32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag32)
DEF_INSTR(OP_XaddNoFlags32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Xadd16,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag16)
DEF_INSTR(OP_Xadd16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag16A)
DEF_INSTR(OP_XaddNoFlags16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag16)
DEF_INSTR(OP_XaddNoFlags16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Xadd8,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag8)
DEF_INSTR(OP_XaddNoFlags8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_CmpXchg32,
              0, ALLFLAGS, REGEAX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpXchgFrag32)
DEF_INSTR(OP_CmpXchg32A,
              0, ALLFLAGS, REGEAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpXchgFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_CmpXchg16,
              0, ALLFLAGS, REGAX,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpXchgFrag16)
DEF_INSTR(OP_CmpXchg16A,
              0, ALLFLAGS, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpXchgFrag16A)
DEF_INSTR(OP_CmpXchg8,
              0, ALLFLAGS, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
	      CmpXchgFrag8)
DEF_INSTR(OP_CMPXCHG8B,
	      0, FLAG_ZF, REGEAX|REGEDX,
	      0,
	      FN_GenCallCFrag, FN_GenCallCFragSlow,
	      CmpXchg8bFrag32)
DEF_INSTR(OP_SynchLockCMPXCHG8B,
	      0, FLAG_ZF, REGEAX|REGEDX,
	      0,
	      FN_GenCallCFrag, FN_GenCallCFragSlow,
	      SynchLockCmpXchg8bFrag32)

DEF_INSTR(OP_Lar32,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LarFrag32)
DEF_INSTR(OP_Lar16,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LarFrag16)

DEF_INSTR(OP_Lsl32,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LslFrag32)
DEF_INSTR(OP_Lsl16,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LslFrag16)

DEF_INSTR(OP_BOP,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              0,
              FN_GenCallCFragLoadEipNoCpu, FN_GenCallCFragLoadEipNoCpuSlow,
              BOPFrag)

DEF_INSTR(OP_BOP_STOP_DECODE,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEipNoCpu, FN_GenCallCFragLoadEipNoCpuSlow,
              BOPFrag)

DEF_INSTR(OP_PushEs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushEsFrag)

DEF_INSTR(OP_PopEs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopEsFrag)

DEF_INSTR(OP_PushFs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushFsFrag)

DEF_INSTR(OP_PopFs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFsFrag)

DEF_INSTR(OP_PushGs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushGsFrag)

DEF_INSTR(OP_PopGs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopGsFrag)

DEF_INSTR(OP_PushCs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushCsFrag)

DEF_INSTR(OP_PushSs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushSsFrag)

DEF_INSTR(OP_PopSs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopSsFrag)

DEF_INSTR(OP_PushDs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushDsFrag)

DEF_INSTR(OP_PopDs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopDsFrag)

DEF_INSTR(OP_Aas,
              FLAG_AUX, FLAG_CF|FLAG_AUX, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AasFrag)

DEF_INSTR(OP_Daa,
              FLAG_AUX|FLAG_CF, FLAG_SF|FLAG_ZF|FLAG_CF|FLAG_AUX|FLAG_PF, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DaaFrag)

DEF_INSTR(OP_Das,
              FLAG_AUX|FLAG_CF, FLAG_SF|FLAG_ZF|FLAG_AUX|FLAG_CF|FLAG_PF, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DasFrag)

DEF_INSTR(OP_Aaa,
              FLAG_AUX, FLAG_AUX|FLAG_CF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AaaFrag)

DEF_INSTR(OP_Aad,
              0, FLAG_PF|FLAG_ZF|FLAG_SF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AadFrag)

DEF_INSTR(OP_Aam,
              0, FLAG_SF|FLAG_PF|FLAG_ZF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AamFrag)

// Next 4 must be consecutive
DEF_INSTR(OP_Imul32,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulFrag32)
DEF_INSTR(OP_Imul32A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulFrag32A)
DEF_INSTR(OP_ImulNoFlags32,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulNoFlagsFrag32)
DEF_INSTR(OP_ImulNoFlags32A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Imul16,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulFrag16)
DEF_INSTR(OP_Imul16A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulFrag16A)
DEF_INSTR(OP_ImulNoFlags16,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulNoFlagsFrag16)
DEF_INSTR(OP_ImulNoFlags16A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulNoFlagsFrag16A)

// Next 4 must be consecutive
DEF_INSTR(OP_Imul3Arg32,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgFrag32)
DEF_INSTR(OP_Imul3Arg32A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgFrag32A)
DEF_INSTR(OP_Imul3ArgNoFlags32,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgNoFlagsFrag32)
DEF_INSTR(OP_Imul3ArgNoFlags32A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Imul3Arg16,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgFrag16)
DEF_INSTR(OP_Imul3Arg16A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgFrag16A)
DEF_INSTR(OP_Imul3ArgNoFlags16,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgNoFlagsFrag16)
DEF_INSTR(OP_Imul3ArgNoFlags16A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgNoFlagsFrag16A)

DEF_INSTR(OP_Sahf,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SahfFrag)

DEF_INSTR(OP_Lahf,
              ALLFLAGS, 0, REGAH,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LahfFrag)

DEF_INSTR(OP_Xlat,
              0, 0, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XlatFrag)

DEF_INSTR(OP_Cmc,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmcFrag)

DEF_INSTR(OP_Clc,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ClcFrag)

DEF_INSTR(OP_Stc,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StcFrag)

DEF_INSTR(OP_Cld,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CldFrag)

DEF_INSTR(OP_Std,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StdFrag)

DEF_INSTR(OP_Seto,
              0, FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetoFrag)

DEF_INSTR(OP_Setno,
              0, FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetnoFrag)

DEF_INSTR(OP_Setb,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetbFrag)

DEF_INSTR(OP_Setae,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetaeFrag)

DEF_INSTR(OP_Sete,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SeteFrag)

DEF_INSTR(OP_Setne,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetneFrag)

DEF_INSTR(OP_Setbe,
              0, FLAG_CF|FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetbeFrag)

DEF_INSTR(OP_Seta,
              0, FLAG_CF|FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetaFrag)

DEF_INSTR(OP_Sets,
              0, FLAG_SF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetsFrag)

DEF_INSTR(OP_Setns,
              0, FLAG_SF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetnsFrag)

DEF_INSTR(OP_Setp,
              0, FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetpFrag)

DEF_INSTR(OP_Setnp,
              0, FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetnpFrag)

DEF_INSTR(OP_Setl,
              0, FLAG_SF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetlFrag)

DEF_INSTR(OP_Setge,
              0, FLAG_SF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetgeFrag)

DEF_INSTR(OP_Setle,
              0, FLAG_SF|FLAG_ZF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetleFrag)

DEF_INSTR(OP_Setg,
              0, FLAG_SF|FLAG_ZF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetgFrag)

DEF_INSTR(OP_Nop,
              0, 0, 0,
              0,
              FN_PlaceNop, FN_GenCallCFragNoCpuSlow,
              NopFrag)

DEF_INSTR(OP_Movsx8To32,
              0, 0, 0,
              0,
              FN_GenMovsx8To32,
              FN_GenMovsx8To32Slow,
              NULL)

DEF_INSTR(OP_Movsx8To16,
              0, 0, 0,
              0,
              FN_GenMovsx8To16,
              FN_GenMovsx8To16Slow,
              NULL)

DEF_INSTR(OP_Movsx16To32,
              0, 0, 0,
              0,
              FN_GenMovsx16To32,
              FN_GenMovsx16To32Slow,
              NULL)

DEF_INSTR(OP_Movzx8To32,
              0, 0, 0,
              0,
              FN_GenMovzx8To32,
              FN_GenMovzx8To32Slow,
              NULL)

DEF_INSTR(OP_Movzx8To16,
              0, 0, 0,
              0,
              FN_GenMovzx8To16,
              FN_GenMovzx8To16Slow,
              NULL)

DEF_INSTR(OP_Movzx16To32,
              0, 0, 0,
              0,
              FN_GenMovzx16To32,
              FN_GenMovzx16To32Slow,
              NULL)

DEF_INSTR(OP_Wait,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              WaitFrag)

DEF_INSTR(OP_Bswap32,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              BswapFrag32)

DEF_INSTR(OP_Arpl,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ArplFrag)

DEF_INSTR(OP_Verr,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              VerrFrag)

DEF_INSTR(OP_Verw,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              VerwFrag)

DEF_INSTR(OP_Smsw,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SmswFrag)

DEF_INSTR(OP_FP_FADD32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADD32)

DEF_INSTR(OP_FP_FMUL32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMUL32)

DEF_INSTR(OP_FP_FCOM32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOM32)

DEF_INSTR(OP_FP_FCOMP32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOMP32)

DEF_INSTR(OP_FP_FSUB32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUB32)

DEF_INSTR(OP_FP_FDIV32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIV32)

DEF_INSTR(OP_FP_FDIVR32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVR32)

DEF_INSTR(OP_FP_FADD_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADD_ST_STi)

DEF_INSTR(OP_FP_FMUL_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMUL_ST_STi)

DEF_INSTR(OP_FP_FCOM_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOM_STi)

DEF_INSTR(OP_FP_FCOMP_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOMP_STi)

DEF_INSTR(OP_FP_FSUB_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUB_ST_STi)

DEF_INSTR(OP_FP_FSUBR_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBR_ST_STi)

DEF_INSTR(OP_FP_FDIV_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIV_ST_STi)

DEF_INSTR(OP_FP_FDIVR_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVR_ST_STi)

DEF_INSTR(OP_FP_FCHS,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCHS)

DEF_INSTR(OP_FP_FABS,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FABS)

DEF_INSTR(OP_FP_FTST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FTST)

DEF_INSTR(OP_FP_FXAM,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FXAM)

DEF_INSTR(OP_FP_FLD1,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD1)

DEF_INSTR(OP_FP_FLDL2T,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDL2T)

DEF_INSTR(OP_FP_FLDL2E,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDL2E)

DEF_INSTR(OP_FP_FLDPI,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDPI)

DEF_INSTR(OP_FP_FLDLG2,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDLG2)

DEF_INSTR(OP_FP_FLDLN2,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDLN2)

DEF_INSTR(OP_FP_FLDZ,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDZ)

DEF_INSTR(OP_FP_F2XM1,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              F2XM1)

DEF_INSTR(OP_FP_FYL2X,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FYL2X)

DEF_INSTR(OP_FP_FPTAN,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FPTAN)

DEF_INSTR(OP_FP_FPATAN,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FPATAN)

DEF_INSTR(OP_FP_FXTRACT,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FXTRACT)

DEF_INSTR(OP_FP_FPREM1,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FPREM1)

DEF_INSTR(OP_FP_FDECSTP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDECSTP)

DEF_INSTR(OP_FP_FINCSTP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FINCSTP)

DEF_INSTR(OP_FP_FPREM,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FPREM)

DEF_INSTR(OP_FP_FYL2XP1,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FYL2XP1)

DEF_INSTR(OP_FP_FSQRT,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSQRT)

DEF_INSTR(OP_FP_FSINCOS,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSINCOS)

DEF_INSTR(OP_FP_FRNDINT,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FRNDINT)

DEF_INSTR(OP_FP_FSCALE,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSCALE)

DEF_INSTR(OP_FP_FSIN,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSIN)

DEF_INSTR(OP_FP_FCOS,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOS)

DEF_INSTR(OP_FP_FLD32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD32)

DEF_INSTR(OP_FP_FST32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FST32)

DEF_INSTR(OP_FP_FSTP32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSTP32)

DEF_INSTR(OP_FP_FLDENV,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FLDENV)

DEF_INSTR(OP_FP_FLDCW,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FLDCW)

DEF_INSTR(OP_FP_FNSTENV,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNSTENV)

DEF_INSTR(OP_FP_FNSTCW,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNSTCW)

DEF_INSTR(OP_FP_FIADD32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIADD32)

DEF_INSTR(OP_FP_FIMUL32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIMUL32)

DEF_INSTR(OP_FP_FICOM32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FICOM32)

DEF_INSTR(OP_FP_FICOMP32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FICOMP32)

DEF_INSTR(OP_FP_FISUBR32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISUBR32)

DEF_INSTR(OP_FP_FISUBR16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISUBR16)

DEF_INSTR(OP_FP_FIDIV32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIDIV32)

DEF_INSTR(OP_FP_FIDIVR32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIDIVR32)

DEF_INSTR(OP_FP_FADD64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADD64)

DEF_INSTR(OP_FP_FMUL64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMUL64)

DEF_INSTR(OP_FP_FCOM64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOM64)

DEF_INSTR(OP_FP_FSUB64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUB64)

DEF_INSTR(OP_FP_FSUBR64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBR64)

DEF_INSTR(OP_FP_FDIV64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIV64)

DEF_INSTR(OP_FP_FDIVR64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVR64)

DEF_INSTR(OP_FP_FADD_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADD_STi_ST)

DEF_INSTR(OP_FP_FMUL_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMUL_STi_ST)

DEF_INSTR(OP_FP_FSUBR_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBR_STi_ST)

DEF_INSTR(OP_FP_FSUB_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUB_STi_ST)

DEF_INSTR(OP_FP_FDIVR_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVR_STi_ST)

DEF_INSTR(OP_FP_FDIV_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIV_STi_ST)

DEF_INSTR(OP_FP_FFREE,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FFREE)

DEF_INSTR(OP_FP_FXCH_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FXCH_STi)

DEF_INSTR(OP_FP_FST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FST_STi)

DEF_INSTR(OP_FP_FSTP_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSTP_STi)

DEF_INSTR(OP_FP_FUCOM,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FUCOM)

DEF_INSTR(OP_FP_FUCOMP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FUCOMP)

DEF_INSTR(OP_FP_FIADD16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIADD16)

DEF_INSTR(OP_FP_FIMUL16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIMUL16)

DEF_INSTR(OP_FP_FICOM16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FICOM16)

DEF_INSTR(OP_FP_FICOMP16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FICOMP16)

DEF_INSTR(OP_FP_FISUB16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISUB16)

DEF_INSTR(OP_FP_FIDIV16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIDIV16)

DEF_INSTR(OP_FP_FIDIVR16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIDIVR16)

DEF_INSTR(OP_FP_FADDP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADDP_STi_ST)

DEF_INSTR(OP_FP_FMULP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMULP_STi_ST)

DEF_INSTR(OP_FP_FCOMPP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOMPP)

DEF_INSTR(OP_FP_FSUBP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBP_STi_ST)

DEF_INSTR(OP_FP_FSUBRP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBRP_STi_ST)

DEF_INSTR(OP_FP_FDIVRP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVRP_STi_ST)

DEF_INSTR(OP_FP_FILD16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FILD16)

DEF_INSTR(OP_FP_FIST16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIST16)

DEF_INSTR(OP_FP_FBLD,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FBLD)

DEF_INSTR(OP_FP_FILD64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FILD64)

DEF_INSTR(OP_FP_FBSTP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FBSTP)

DEF_INSTR(OP_FP_FLD80,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD80)

DEF_INSTR(OP_FP_FSTP80,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSTP80)

DEF_INSTR(OP_FP_FISUB32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISUB32)

DEF_INSTR(OP_FP_FCOMP64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOMP64)

DEF_INSTR(OP_FP_FLD64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD64)

DEF_INSTR(OP_FP_FST64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FST64)

DEF_INSTR(OP_FP_FSTP64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSTP64)

DEF_INSTR(OP_FP_FRSTOR,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FRSTOR)

DEF_INSTR(OP_FP_FNSAVE,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FNSAVE)

DEF_INSTR(OP_FP_FDIVP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVP_STi_ST)

DEF_INSTR(OP_FP_FISTP16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISTP16)

DEF_INSTR(OP_FP_FISTP64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISTP64)

DEF_INSTR(OP_FP_FLD_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD_STi)

DEF_INSTR(OP_FP_FUCOMPP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FUCOMPP)

DEF_INSTR(OP_FP_FILD32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FILD32)

DEF_INSTR(OP_FP_FIST32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIST32)

DEF_INSTR(OP_FP_FISTP32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISTP32)

DEF_INSTR(OP_FP_FNCLEX,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNCLEX)

DEF_INSTR(OP_FP_FNINIT,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNINIT)

DEF_INSTR(OP_FP_FNSTSW,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNSTSW)

DEF_INSTR(OP_FP_FSUBR32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBR32)

DEF_INSTR(OP_FP_FNOP,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNOP)

DEF_INSTR(OP_CPUID,
              0, 0, GP_EAX|GP_EBX|GP_ECX|GP_EDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CPUID)

DEF_INSTR(OP_SynchLockAdd32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAddFrag32)
DEF_INSTR(OP_SynchLockAdd16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAddFrag16)
DEF_INSTR(OP_SynchLockAdd8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAddFrag8)

DEF_INSTR(OP_SynchLockSub32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSubFrag32)
DEF_INSTR(OP_SynchLockSub16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSubFrag16)
DEF_INSTR(OP_SynchLockSub8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSubFrag8)

DEF_INSTR(OP_SynchLockNeg32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNegFrag32)
DEF_INSTR(OP_SynchLockNeg16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNegFrag16)
DEF_INSTR(OP_SynchLockNeg8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNegFrag8)

DEF_INSTR(OP_SynchLockInc32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockIncFrag32)
DEF_INSTR(OP_SynchLockInc16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockIncFrag16)
DEF_INSTR(OP_SynchLockInc8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockIncFrag8)

DEF_INSTR(OP_SynchLockDec32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockDecFrag32)
DEF_INSTR(OP_SynchLockDec16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockDecFrag16)
DEF_INSTR(OP_SynchLockDec8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockDecFrag8)

DEF_INSTR(OP_SynchLockAdc32,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAdcFrag32)
DEF_INSTR(OP_SynchLockAdc16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAdcFrag16)
DEF_INSTR(OP_SynchLockAdc8,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAdcFrag8)

DEF_INSTR(OP_SynchLockSbb32,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSbbFrag32)
DEF_INSTR(OP_SynchLockSbb16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSbbFrag16)
DEF_INSTR(OP_SynchLockSbb8,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSbbFrag8)

DEF_INSTR(OP_SynchLockOr32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockOrFrag32)
DEF_INSTR(OP_SynchLockOr16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockOrFrag16)
DEF_INSTR(OP_SynchLockOr8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockOrFrag8)

DEF_INSTR(OP_SynchLockAnd32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAndFrag32)
DEF_INSTR(OP_SynchLockAnd16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAndFrag16)
DEF_INSTR(OP_SynchLockAnd8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAndFrag8)

DEF_INSTR(OP_SynchLockXor32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXorFrag32)
DEF_INSTR(OP_SynchLockXor16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXorFrag16)
DEF_INSTR(OP_SynchLockXor8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXorFrag8)

DEF_INSTR(OP_SynchLockNot32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNotFrag32)
DEF_INSTR(OP_SynchLockNot16,
              0, 0, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNotFrag16)
DEF_INSTR(OP_SynchLockNot8,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNotFrag8)

DEF_INSTR(OP_SynchLockBtsMem32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtsMemFrag32)
DEF_INSTR(OP_SynchLockBtsMem16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtsMemFrag16)

DEF_INSTR(OP_SynchLockBtrMem32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtrMemFrag32)
DEF_INSTR(OP_SynchLockBtrMem16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtrMemFrag16)

DEF_INSTR(OP_SynchLockBtcMem32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtcMemFrag32)
DEF_INSTR(OP_SynchLockBtcMem16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtcMemFrag16)

DEF_INSTR(OP_SynchLockBtsReg32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtsRegFrag32)
DEF_INSTR(OP_SynchLockBtsReg16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtsRegFrag16)

DEF_INSTR(OP_SynchLockBtrReg32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtrRegFrag32)
DEF_INSTR(OP_SynchLockBtrReg16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtrRegFrag16)

DEF_INSTR(OP_SynchLockBtcReg32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtcRegFrag32)
DEF_INSTR(OP_SynchLockBtcReg16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtcRegFrag16)

DEF_INSTR(OP_SynchLockXchg32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXchgFrag32)
DEF_INSTR(OP_SynchLockXchg16,
              0, 0, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXchgFrag16)
DEF_INSTR(OP_SynchLockXchg8,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXchgFrag8)

DEF_INSTR(OP_SynchLockXadd32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXaddFrag32)
DEF_INSTR(OP_SynchLockXadd16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXaddFrag16)
DEF_INSTR(OP_SynchLockXadd8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXaddFrag8)

DEF_INSTR(OP_SynchLockCmpXchg32,
              0, ALLFLAGS, REGEAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockCmpXchgFrag32)
DEF_INSTR(OP_SynchLockCmpXchg16,
              0, ALLFLAGS, REGAX,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockCmpXchgFrag16)
DEF_INSTR(OP_SynchLockCmpXchg8,
              0, ALLFLAGS, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockCmpXchgFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_SetupStack,
              0, ALLFLAGS, REGEBP|REGESP,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_SetupStackFrag)
DEF_INSTR(OP_OPT_SetupStackNoFlags,
              0, ALLFLAGS, REGEBP|REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_SetupStackNoFlagsFrag)

DEF_INSTR(OP_OPT_PushEbxEsiEdi,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_PushEbxEsiEdiFrag)

DEF_INSTR(OP_OPT_PopEdiEsiEbx,
              0, 0, REGESP|REGEBX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_PopEdiEsiEbxFrag)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_ZERO32,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_ZEROFrag32)
DEF_INSTR(OP_OPT_ZERONoFlags32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OPT_ZERONoFlagsFrag32)

DEF_INSTR(OP_OPT_FastTest32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_FastTestFrag32)
DEF_INSTR(OP_OPT_FastTest16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_FastTestFrag16)
DEF_INSTR(OP_OPT_FastTest8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_FastTestFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_CmpSbb32,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CmpSbbFrag32)
DEF_INSTR(OP_OPT_CmpSbbNoFlags32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OPT_CmpSbbNoFlagsFrag32)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_CmpSbbNeg32,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CmpSbbNegFrag32)
DEF_INSTR(OP_OPT_CmpSbbNegNoFlags32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OPT_CmpSbbNegNoFlagsFrag32)

DEF_INSTR(OP_OPT_Push232,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_Push2Frag32)

DEF_INSTR(OP_OPT_Pop232,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_Pop2Frag32)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_CwdIdiv32,
              0, 0, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CwdIdivFrag32)
DEF_INSTR(OP_OPT_CwdIdiv32A,
              0, 0, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CwdIdivFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_OPT_CwdIdiv16,
              0, 0, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CwdIdivFrag16)
DEF_INSTR(OP_OPT_CwdIdiv16A,
              0, 0, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CwdIdivFrag16A)

DEF_INSTR(OP_OPT_FNSTSWAxSahf,
              0, FLAG_CF|FLAG_PF|FLAG_AUX|FLAG_ZF|FLAG_SF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_FNSTSWAxSahf)

DEF_INSTR(OP_OPT_FSTP_ST0,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              OPT_FSTP_ST0)

DEF_INSTR(OP_Rdtsc,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rdtsc)




// Undefine DEF_INSTR so this file can be included multiple times
#undef DEF_INSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\mrsw.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mrsw.h

Abstract:

    This is the include file for the multiple reader single writer
    syncronization.

Author:

    Dave Hastings (daveh) creation-date 26-Jul-1995

Revision History:


--*/

#ifndef _MRSW_H_
#define _MRSW_H_

typedef union {
    DWORD Counters;
    struct {
        DWORD WriterCount : 16;
        DWORD ReaderCount : 16;
    };
} MRSWCOUNTERS, *PMRSWCOUNTERS;

typedef struct _MrswObject {
    MRSWCOUNTERS Counters;
    HANDLE WriterEvent;
    HANDLE ReaderEvent;
#if DBG
    DWORD  WriterThreadId;
#endif
} MRSWOBJECT, *PMRSWOBJECT;

BOOL
MrswInitializeObject(
    PMRSWOBJECT Mrsw
    );

VOID
MrswWriterEnter(
    PMRSWOBJECT Mrsw
    );

VOID
MrswWriterExit(
    PMRSWOBJECT Mrsw
    );
    
VOID
MrswReaderEnter(
    PMRSWOBJECT Mrsw
    );

VOID
MrswReaderExit(
    PMRSWOBJECT Mrsw
    );

extern MRSWOBJECT MrswEP; // Entrypoint MRSW synchronization object
extern MRSWOBJECT MrswTC; // Translation cache MRSW synchronization object
extern MRSWOBJECT MrswIndirTable; // Indirect Control Transfer Table synchronization object

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\frag.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    frag.h

Abstract:

    This module contains public structures and interfaces for the fragment
    library.

Author:

    Dave Hastings (daveh) creation-date 24-Jun-1995

Revision History:


--*/

#ifndef _FRAG_H_
#define _FRAG_H_

//
// function declaration for the function to patch Operand fragments
// CodeLocation specifies the location of the beginning of the copy
// of the fragment in memory.  Reference indicates if it is a value
// or reference operand.  Argument number refers to which argument it
// is for the c call to the operation fragment (zero based)
//
typedef INT (*PPLACEOPERANDFN)(
    IN PULONG CodeLocation,
    IN POPERAND Operand,
    IN ULONG OperandNumber
    );

//
// function declaration for the function to patch operation fragments
// CodeLocation specifies the location of the beginning of the copy
// of the fragment in memory
//
typedef ULONG (*PPLACEOPERATIONFN)(PULONG CodeLocation,
#if _ALPHA_
                                   ULONG CurrentECU,
#endif
                                   PINSTRUCTION Instruction);

//
// Structure to describe and locate the code for a fragment
//
typedef struct _FragDescr {
    BYTE FastPlaceFn;       // index into PlaceFn[] when in fast mode
    BYTE SlowPlaceFn;       // index into PlaceFn[] when in slow mode
    USHORT Flags;           // OPFL_ flags
    DWORD RegsSet;          // registers set by this instr
    USHORT FlagsNeeded;     // bits from flags register required for this instr
    USHORT FlagsSet;        // bits from flags register modified by this instr
} FRAGDESC;
typedef CONST FRAGDESC *PFRAGDESCR;

//
// Bit definitions for FRAGDESC.Flags field
//
#define OPFL_ALIGN          1
#define OPFL_HASNOFLAGS     2
#define OPFL_STOP_COMPILE   4
#define OPFL_END_NEXT_EP    8
#define OPFL_CTRLTRNS       16
#define OPFL_ADDR16         32
#define OPFL_INLINEARITH    64

// Bit values for FRAGDESC.RegsSet field
#define REGAL         1
#define REGAH         2
#define REGAX         3
#define REGEAX        7
#define REGCL         (1<<3)
#define REGCH         (2<<3)
#define REGCX         (3<<3)
#define REGECX        (7<<3)
#define REGDL         (1<<6)
#define REGDH         (2<<6)
#define REGDX         (3<<6)
#define REGEDX        (7<<6)
#define REGBL         (1<<9)
#define REGBH         (2<<9)
#define REGBX         (3<<9)
#define REGEBX        (7<<9)
#define REGSP         (3<<12)
#define REGESP        (7<<12)
#define REGBP         (3<<15)
#define REGEBP        (7<<15)
#define REGSI         (3<<18)
#define REGESI        (7<<18)
#define REGDI         (3<<21)
#define REGEDI        (7<<21)
#define ALLREGS       (REGEAX|REGEBX|REGECX|REGEDX|REGESP|REGEBP|REGESI|REGEDI)

//
// Constants to help break apart bitfields of REG... constants.  Register
// caching code uses a single DWORD to hold caching information for the 8
// x86 general-purpose registers (REGEAX through REGEDI), using 3 bits of
// data for each.
//
#define REGMASK       7
#define REGCOUNT      8
#define REGSHIFT      3

//
// Declare fragment description array
//
extern CONST FRAGDESC Fragments[OP_MAX];
extern CONST PPLACEOPERATIONFN PlaceFn[FN_MAX];



VOID
FlushCallstack(
    PTHREADSTATE cpu
    );

//
// The following three functions are used by the indirect control transfer code
//

ULONG
getUniqueIndex(
    VOID
    );

VOID
FlushIndirControlTransferTable(
    VOID
    );

ULONG
IndirectControlTransfer(
    IN ULONG tableEntry,
    IN ULONG intelAddr,
    IN PTHREADSTATE cpu
    );

ULONG
IndirectControlTransferFar(
    IN PTHREADSTATE cpu,
    IN PUSHORT pintelAddr,
    IN ULONG tableEntry
    );

ULONG PlaceInstructions(
    PCHAR CodeLocation,
    DWORD cEntryPoints
    );

//
// Function for initializing the fragment library
//
BOOL
FragLibInit(
    PCPUCONTEXT cpu,
    DWORD StackBase
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\ppcreg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ppcreg.h

Abstract:

    This file establishes the mapping between the traditional NT register
    names and the PPC register names.  This really should have been in
    kxppc.h.  

Author:

    Dave Hastings (daveh) creation-date 13-Sep-1995

Revision History:


--*/

#define sp   r1                         // stack pointer
#define a0   r3                         // argument registers
#define a1   r4                         //
#define a2   r5                         //
#define a3   r6                         //
#define a4   r7                         //
#define a5   r8                         //
#define a6   r9                         //
#define a7   r10                        //
#define v0   r3                         // function return value
#define TebReg r13                        // Callee saved registers
#define s0   r14                        // 
#define s1   r15                        // 
#define s2   r16                        // 
#define s3   r17                        // 
#define s4   r18                        // 
#define s5   r19                        // 
#define s6   r20                        // 
#define s7   r21                        // 
#define s8   r22                        // 
#define s9   r23                        // 
#define s10  r24                        // 
#define s11  r25                        // 
#define s12  r26                        // 
#define s13  r27                        // 
#define s14  r28                        // 
#define s15  r29                        // 
#define s16  r30                        // 
#define s18  r31                        //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\instr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    instr.h

Abstract:

    This module contains structures, enums and constants used to define the
    Intel instruction stream.

Author:

    Dave Hastings (daveh) creation-date 23-Jun-1995

Revision History:


--*/

#ifndef _INSTR_H_
#define _INSTR_H_

// We need the definitions of Entry Points for the instruction structure
#include "entrypt.h"

//
// This enumeration defines all of the possible operations.
//  N.B.  It is also used to find the fragment corresponding to the
//        operation.
//
typedef enum _Operation {
    #define DEF_INSTR(OpName, FlagsNeeded, FlagsSet, RegsSet, Opfl, FastPlaceFn, SlowPlaceFn, FragName)   OpName,
    #include "idata.h"
    OP_MAX      
} OPERATION, *POPERATION;

typedef enum _PlaceFn {
    #define DEF_PLACEFN(Name) FN_ ## Name,
    #include "fndata.h"
    FN_MAX
} PLACEFN;


typedef struct _Operand {
    enum {
        OPND_NONE = 0,
        OPND_NOCODEGEN,
        OPND_REGREF,
        OPND_REGVALUE,
        OPND_ADDRREF,
        OPND_ADDRVALUE32,
        OPND_ADDRVALUE16,
        OPND_ADDRVALUE8,
        OPND_IMM,
        OPND_MOVTOREG,
        OPND_MOVREGTOREG,
        OPND_MOVTOMEM,
    } Type;
    ULONG Immed;
    ULONG Reg;
    ULONG Scale;
    ULONG IndexReg;
    ULONG Alignment;
} OPERAND, *POPERAND;

typedef struct _Instruction {
    OPERATION Operation;
    OPERAND Operand1;
    OPERAND Operand2;
    OPERAND Operand3;
    ULONG FsOverride;
    ULONG Size;
    PCHAR NativeStart;
    ULONG IntelAddress;
    DWORD RegsSet;
    DWORD RegsNeeded;
    DWORD RegsToCache;
    BOOL EbpAligned;
    PENTRYPOINT EntryPoint;

} INSTRUCTION, *PINSTRUCTION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\threadst.h ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation

Module Name:

    threadst.h

Abstract:

    This module defines the structures and constant for describing a
    thread's state.
    

Author:

    Dave Hastings (daveh) creation-date 20-May-1995

Revision History:


--*/

#ifndef _THREADST_H_
#define _THREADST_H_

#define EIPLOGSIZE  32    // keep track of the last N instructions run

#define CSSIZE  512       // Size of call stack (512*8 = 2048 bytes = 1 page)

typedef union _REG32 {    // definition of a 32-bit x86 register
    struct {
	BYTE i1;
	BYTE hb;
    };
    USHORT i2;
    ULONG  i4;
} REG32;

#if defined(_ALPHA_)
typedef DWORD FPTAG;        // bytes are too slow on AXP
#else
typedef BYTE  FPTAG;
#endif

typedef struct _FPREG {     // definition of an x86 floating-point register
    union {
        double  r64;
        DWORD   rdw[2];
        BYTE    rb[8];
    };
    FPTAG   Tag;
    FPTAG   TagSpecial;
} FPREG, *PFPREG;

//
// CALLSTACK is an optimization for CALL/RET pairs, so that an expensive
// NativeAddressFromEip() call can be avoided when determining the RISC
// address of an x86 return address.
//
typedef struct _callStack {
    ULONG intelAddr;
    ULONG nativeAddr;
} CALLSTACK, *PCALLSTACK;

// Indices into CPUSTATE.Regs[].  get_reg32() depends on EAX through
// EDI being contiguous and ordered the same as they are in the mod/rm and
// reg instruction encodings (ie. EAX=0,ECX=1,EDX=2,EBX=3,ESP=4,EBP=5,ESI=6,
// EDI=7)
#define GP_EAX  0x00
#define GP_ECX  0x01
#define GP_EDX  0x02
#define GP_EBX  0x03
#define GP_ESP  0x04
#define GP_EBP  0x05
#define GP_ESI  0x06
#define GP_EDI  0x07

// Segment registers.  get_segreg() depends on the order.
#define REG_ES  0x08
#define REG_CS  0x09
#define REG_SS  0x0a
#define REG_DS  0x0b
#define REG_FS  0x0c
#define REG_GS  0x0d


// Identifiers for components of registers.  get_reg16() depends on the order.
#define GP_AX   0x0e
#define GP_CX   0x0f
#define GP_DX   0x10
#define GP_BX   0x11
#define GP_SP   0x12
#define GP_BP   0x13
#define GP_SI   0x14
#define GP_DI   0x15

// PlaceOperandFragments() depends on GP_AH and beyond, and that no registers
// are past GP_BH.
#define GP_AL   0x16
#define GP_CL   0x17
#define GP_DL   0x18
#define GP_BL   0x19
#define GP_AH   0x1a
#define GP_CH   0x1b
#define GP_DH   0x1c
#define GP_BH   0x1d

#define NO_REG  0xffffffff

typedef struct _CPU_SUSPEND_MSG
{
    // Owned by local thread 
    HANDLE StartSuspendCallEvent;
    HANDLE EndSuspendCallEvent;

} CPU_SUSPEND_MSG, *PCPU_SUSPEND_MSG;

// all information related to a particular thread of the CPU belongs here
typedef struct _ThreadState {

    //
    // General-purpose and segment registers
    // accessible as an array of REG32 or by Register Name
    // NOTE: the name orders must match the GP_XXX defines for registers
    //
    union {
        REG32 GpRegs[14];
        struct _RegisterByName {
            REG32 Eax;
            REG32 Ecx;
            REG32 Edx;
            REG32 Ebx;
            REG32 Esp;
            REG32 Ebp;
            REG32 Esi;
            REG32 Edi;
            REG32 Es;
            REG32 Cs;
            REG32 Ss;
            REG32 Ds;
            REG32 Fs;
            REG32 Gs;
            };
        };

    REG32 eipReg;       // Pointer to start of current instruction (never
			//  points into the middle of an instruction)

    DWORD   flag_cf;    // 0 = carry
    DWORD   flag_pf;    // 2 = parity
    DWORD   flag_aux;   // 4 = aux carry
    DWORD   flag_zf;    // 6 = zero
    DWORD   flag_sf;    // 7 = sign
    DWORD   flag_tf;    // 8 = trap
    DWORD   flag_if;    // 9 = interrupt enable
    DWORD   flag_df;    // 10 = direction   (1 = clear, -1 = set)
    DWORD   flag_of;    // 11 = overflow
    DWORD   flag_nt;    // 14 = nested task
    DWORD   flag_rf;    // 16 = resume flag
    DWORD   flag_vm;    // 17 = virtual mode
    DWORD   flag_ac;    // 18 = alignment check

    // Floating-point registers
    FPREG  FpStack[8];
    PFPREG FpST0;
    INT    FpTop;
    INT    FpStatusC3;
    INT    FpStatusC2;
    INT    FpStatusC1;
    INT    FpStatusC0;
    INT    FpStatusSF;
    INT    FpStatusES;      // Error Summary Status
    INT    FpControlInfinity;
    INT    FpControlRounding;
    INT    FpControlPrecision;
    DWORD  FpStatusExceptions;
    DWORD  FpControlMask;
    DWORD  FpEip;           // EIP for the current FP instruction
    PVOID  FpData;          // Effective address for current FP instruction
    PVOID  FpAddTable;      // ptr to table of function pointers for FADD
    PVOID  FpSubTable;      // ptr to table of function pointers for FSUB
    PVOID  FpMulTable;      // ptr to table of function pointers for FMUL
    PVOID  FpDivTable;      // ptr to table of function pointers for FDIV

    ULONG CpuNotify;

    PVOID TraceAddress; // Used by debugger extensions

    DWORD  fTCUnlocked;     // FALSE means TC must be unlocked after exception

    // SuspendThread/ResumeThread support
    PCPU_SUSPEND_MSG SuspendMsg;

    int   eipLogIndex;  // Index of next entry to write into in the log
    DWORD eipLog[EIPLOGSIZE]; // log of last EIPLOGSIZE instructions run

    ULONG CSIndex;    // Index into the stack (offset of current location)
    DWORD CSTimestamp;// Value of TranslationCacheTimestamp corresponding to the callstack cache
    CALLSTACK callStack[CSSIZE];    // callstack optimization

    int ErrnoVal;           // CRT errno value

    DWORD   flag_id;    // 21 = ID (CPUID present if this can be toggled)

}  THREADSTATE, *PTHREADSTATE, CPUCONTEXT, *PCPUCONTEXT;

// Bit offsets in cpu->FpControlMask.  Same as the x86 bit positions
#define FPCONTROL_IM    1       // Invalid operation
#define FPCONTROL_DM    2       // Denormalized operation
#define FPCONTROL_ZM    4       // Zero divide
#define FPCONTROL_OM    8       // Overflow
#define FPCONTROL_UM    16      // Underflow
#define FPCONTROL_PM    32      // Precision

// This macro allows one to access the cpu state via the local variable cpu
#define DECLARE_CPU                                         \
    PCPUCONTEXT cpu=(PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED);

//
// The following macros allow one to push and pop values from the
// call stack
//

#define ISTOPOF_CALLSTACK(iAddr)                            \
    (cpu->callStack[(cpu->CSIndex)].intelAddr == iAddr)

#define PUSH_CALLSTACK(iAddr,nAddr)                         \
{                                                           \
    PCALLSTACK pCallStack;                                  \
                                                            \
    cpu->CSIndex = (cpu->CSIndex+1) % CSSIZE;               \
    pCallStack = &cpu->callStack[cpu->CSIndex];             \
    pCallStack->intelAddr = iAddr;                          \
    pCallStack->nativeAddr = nAddr;                         \
}

#define POP_CALLSTACK(iAddr,nAddr)                          \
{                                                           \
    PCALLSTACK pCallStack;                                  \
    extern ULONG TranslationCacheTimestamp;                 \
                                                            \
    CPUASSERTMSG(                                           \
        (cpu->CSTimestamp == TranslationCacheTimestamp),    \
        "POP_CALLSTACK: About to return and invalid value\n"\
        );                                                  \
                                                            \
    pCallStack = &cpu->callStack[cpu->CSIndex];             \
    if (iAddr == pCallStack->intelAddr) {                   \
        nAddr = pCallStack->nativeAddr;                     \
    } else {                                                \
        nAddr = 0;                                          \
    }                                                       \
    cpu->CSIndex = (cpu->CSIndex-1) % CSSIZE;               \
}

PCPUCONTEXT GetCpuContext ();  //has been implemented in wowproxy

NTSTATUS
CpupSuspendCurrentThread(
    VOID);


#endif  //_THREADST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\ldexp.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    ldexp.c

Abstract:
    
    multiply by a power of two
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/
 
#include <math.h>
#include <float.h>
#include <trans.h>
#include <limits.h>
  
/***
*double ldexp(double x, int exp)
*
*Purpose:
*   Compute x * 2^exp
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I  U  O  P
*
*******************************************************************************/
double ldexp(double x, int exp)
{
    unsigned int savedcw;
    int oldexp;
    long newexp; /* for checking out of bounds exponents */
    double result, mant;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    switch (_sptype(x)) {
    case T_PINF:
    case T_NINF:
        RETURN(savedcw,x);
    case T_QNAN:
        return _handle_qnan2(OP_LDEXP, x, (double)exp, savedcw);
    default: //T_SNAN
        return _except2(FP_I,OP_LDEXP,x,(double)exp,_s2qnan(x),savedcw);
    }
    }


    if (x == 0.0) {
    RETURN(savedcw,x);
    }

    mant = _decomp(x, &oldexp);

    if (ABS(exp) > INT_MAX)
    newexp = exp; // avoid possible integer overflow
    else
    newexp = oldexp + exp;


    /* out of bounds cases */
    if (newexp > MAXEXP + IEEE_ADJUST) {
    return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,_copysign(D_INF,mant),savedcw);
    }
    if (newexp > MAXEXP) {
    result = _set_exp(mant, newexp-IEEE_ADJUST);
    return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }
    if (newexp < MINEXP - IEEE_ADJUST) {
    return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,mant*0.0,savedcw);
    }
    if (newexp < MINEXP) {
    result = _set_exp(mant, newexp+IEEE_ADJUST);
    return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }

    result = _set_exp(mant, (int)newexp);

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\wx86.h ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    wx86.h

Abstract:

    Public exports, defines for wx86.dll

Author:

    10-Jan-1995 Jonle,Created

Revision History:

    24-Aug-1999 [askhalid] isolated some definition from wow64 
                and define some proxy and wrapper functions.

--*/

#include <wow64.h>

#if !defined(_WX86CPUAPI_)
#define WX86CPUAPI DECLSPEC_IMPORT
#else
#define WX86CPUAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif

typedef struct _ConfigVariable {
   LIST_ENTRY ConfigEntry;
   DWORD      Data;
   UNICODE_STRING Name;
   WCHAR      Buffer[1];
} CONFIGVAR, *PCONFIGVAR;

PCONFIGVAR
Wx86FetchConfigVar(
   PWSTR VariableName
   );

VOID
Wx86RaiseStatus(
    NTSTATUS Status
    );

void
Wx86RaiseInterrupt(
    ULONG IntNum,
    ULONG EipVal,
    ULONG EspVal,
    BOOL  bParameter,
    ULONG Parameter
    );

VOID
Wx86FreeConfigVar(
   PCONFIGVAR ConfigVar
   );


#define BOPFL_ENDCODE  0x01
typedef struct _BopInstr {
    BYTE    Instr1;         // 0xc4c4 - the x86 BOP instruction
    BYTE    Instr2;
    BYTE    BopNum;
    BYTE    Flags;
    USHORT  ApiNum;
    BYTE    RetSize;
    BYTE    ArgSize;
} BOPINSTR;
typedef UNALIGNED BOPINSTR * PBOPINSTR;


void
Wx86DispatchBop(
    PBOPINSTR Bop
    );

/////////////////////////////////

#define ProxyGetCurrentThreadId()       \
            HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)

#define ProxyDebugBreak()               \
            DbgBreakPoint()

BOOL ProxyIsProcessorFeaturePresent (DWORD feature);

VOID ProxyRaiseException(
    IN DWORD dwExceptionCode,
    IN DWORD dwExceptionFlags,
    IN DWORD nNumberOfArguments,
    IN CONST ULONG_PTR *lpArguments
    );

WX86CPUAPI DWORD GetEdi(PVOID CpuContext);
WX86CPUAPI VOID SetEdx(PVOID CpuContext, DWORD val);
WX86CPUAPI VOID SetEdi(PVOID CpuContext, DWORD val);
WX86CPUAPI DWORD GetEfl(PVOID CpuContext);
WX86CPUAPI VOID SetEfl(PVOID CpuContext, DWORD val);
WX86CPUAPI DWORD GetEsp(PVOID CpuContext);
WX86CPUAPI VOID SetEip(PVOID CpuContext, DWORD val);
WX86CPUAPI VOID SetEsp(PVOID CpuContext, DWORD val);
WX86CPUAPI DWORD GetEip(PVOID CpuContext);
DWORD ProxyWowDispatchBop( 
    ULONG ServiceNumber,
    PVOID Context32,
    PULONG ArgBase
    );

double Proxylog10( double x );
double Proxyatan2( double y, double x );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\atan.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    atan.c

Abstract:
    
    This module implements arithmatic tan function used in wow.
    
Author:


Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/

#include <math.h>
#include <trans.h>

static double _atanhlp(double x);

static double const a[4] = {
    0.0,
    0.52359877559829887308,   /* pi/6 */
    1.57079632679489661923,   /* pi/2 */
    1.04719755119659774615    /* pi/3 */
};

/* constants */
static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const PI_OVER_TWO = 1.57079632679489661923;
static double const PI      = 3.14159265358979323846;
static double const TWO_M_SQRT3 = 0.26794919243112270647;
static double const SQRT3_M_ONE = 0.73205080756887729353;
static double const SQRT3   = 1.73205080756887729353;

/* chose MAX_ARG s.t. 1/MAX_ARG does not underflow */
static double const MAX_ARG = 4.494232837155790e+307;

/* constants for rational approximation */
static double const p0 = -0.13688768894191926929e+2;
static double const p1 = -0.20505855195861651981e+2;
static double const p2 = -0.84946240351320683534e+1;
static double const p3 = -0.83758299368150059274e+0;
static double const q0 =  0.41066306682575781263e+2;
static double const q1 =  0.86157349597130242515e+2;
static double const q2 =  0.59578436142597344465e+2;
static double const q3 =  0.15024001160028576121e+2;
static double const q4 =  0.10000000000000000000e+1;


#define Q(g)  (((((g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define R(g)  ((((p3 * (g) + p2) * (g) + p1) * (g) + p0) * (g)) / Q(g)


/***
*double atan(double x) - arctangent
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
\*******************************************************************************/
double Proxyatan(double x)
{
    unsigned int savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    switch(_sptype(x)) {
    case T_PINF:
        result = PI_OVER_TWO;
        break;
    case T_NINF:
        result = -PI_OVER_TWO;
        break;
    case T_QNAN:
        return _handle_qnan1(OP_ATAN,x,savedcw);
    default: //T_SNAN
        return _except1(FP_I,OP_ATAN,x,_s2qnan(x),savedcw);
    }
    }

    if (x == 0.0)
    RETURN(savedcw,x);

    result = _atanhlp(x);
    RETURN_INEXACT1(OP_ATAN,x,result,savedcw);
}

/***
*double atan2(double x, double y) - arctangent (x/y)
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*    NAN or both args 0: DOMAIN error
*******************************************************************************/
double Proxyatan2(double v, double u)
{
    unsigned int savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(v) || IS_D_SPECIAL(u)){
    if (IS_D_SNAN(v) || IS_D_SNAN(u)){
        return _except2(FP_I,OP_ATAN2,v,u,_d_snan2(v,u),savedcw);
    }
    if (IS_D_QNAN(v) || IS_D_QNAN(u)){
        return _handle_qnan2(OP_ATAN2,v,u,savedcw);
    }
    if ((IS_D_INF(v) || IS_D_MINF(v)) &&
        (IS_D_INF(u) || IS_D_MINF(u))){
        return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
    }
    /* the other combinations of infinities will be handled
     * later by the division v/u
     */
    }


    if (u == 0) {
    if (v == 0) {
        return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
    }
    else {
        result = PI_OVER_TWO;
    }
    }
    else if (INTEXP(v) - INTEXP(u) > MAXEXP - 3) {
    /* v/u overflow */
    result = PI_OVER_TWO;
    }
    else {
    double arg = v/u;


    if (ABS(arg) < D_MIN) {

        if (v == 0.0 || IS_D_INF(u) || IS_D_MINF(u)) {
        result = (u < 0) ? PI : 0;
        if (v < 0) {
            result = -result;
        }
        if (result == 0) {
             RETURN(savedcw,  result);
        }
        else {
             RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
        }
        }
        else {

        double v1, u1;
        int vexp, uexp;
        int exc_flags;

        //
        // in this case an underflow has occurred
        // re-compute the result in order to raise
        // an IEEE underflow exception
        //

        if (u < 0) {
            result = v < 0 ? -PI: PI;
            RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
        }

        v1 = _decomp(v, &vexp);
        u1 = _decomp(u, &uexp);
        result = _add_exp(v1/u1, vexp-uexp+IEEE_ADJUST);
        result = ABS(result);

        if (v < 0) {
            result = -result;
        }

        // this is not a perfect solution. In the future
        // we may want to have a way to let the division
        // generate an exception and propagate the IEEE result
        // to the user's handler

        exc_flags = FP_U;
        if (_statfp() & ISW_INEXACT) {
            exc_flags  |= FP_P;
        }
        return _except2(exc_flags,OP_ATAN2,v,u,result,savedcw);

        }
    }

    else {
       result = _atanhlp( ABS(arg) );
    }

    }

    /* set sign of the result */
    if (u < 0) {
    result = PI - result;
    }
    if (v < 0) {
    result = -result;
    }


    RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
}





/***
*double _atanhlp(double x) - arctangent helper
*
*Purpose:
*   Compute arctangent of x, assuming x is a valid, non infinite
*   number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
static double _atanhlp(double x)
{
    double f,g,result;
    int n;


    f = ABS(x);
    if (f > MAX_ARG) {
    // if this step is ommited, 1.0/f might underflow in the
    // following block
    return x > 0.0 ? PI_OVER_TWO : -PI_OVER_TWO;
    }
    if (f > 1.0) {
    f = 1.0/f;
    n = 2;
    }
    else {
    n = 0;
    }

    if (f > TWO_M_SQRT3) {
    f = (((SQRT3_M_ONE * f - .5) - .5) + f) / (SQRT3 + f);
    n++;
    }  

    if (ABS(f) < EPS) {
    result = f;
    }
    else {
    g = f*f;
    result = f + f * R(g);
    }

    if (n > 1)
    result = -result;

    result += a[n];

    if (x < 0.0)
    result = -result;


    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\inc\wx86cpu.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wx86cpu.h

Abstract:

    Defines the functions exported from the CPU DLL.

Author:

    22-Aug-1995 BarryBo, Created

Revision History:

--*/

#ifndef _WX86CPU_
#define _WX86CPU_

#if !defined(_WX86CPUAPI_)
#define WX86CPUAPI DECLSPEC_IMPORT
#else
#define WX86CPUAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif



#define WX86CPU_UNSIMULATE             STATUS_WX86_UNSIMULATE
#define WX86CPU_CONTINUE               STATUS_WX86_CONTINUE
#define WX86CPU_SINGLE_STEP            STATUS_WX86_SINGLE_STEP
#define WX86CPU_BREAKPOINT             STATUS_WX86_BREAKPOINT


//
// Values used by the wx86e debugger extension to determine the CPU type
//
typedef enum _Wx86CpuType {
   Wx86CpuUnknown,
   Wx86CpuCcpu386,
   Wx86CpuCcpu,
   Wx86CpuCpu,
   Wx86CpuFx32,
   Wx86CpuOther
} WX86_CPUTYPE, *PWX86_CPUTYPE;

typedef struct Wx86CpuHint {
    DWORD Hint;
    DWORD_PTR Hint2;
} WX86_CPUHINT, *PWX86_CPUHINT;

#if !defined(__WOW64_WRAPPER__)
//
// Initialization and Termination routines
//


WX86CPUAPI BOOL CpuProcessTerm(BOOL OFlyInit);

//
// Cache manipulation functions
//
WX86CPUAPI VOID CpuFlushInstructionCache(PVOID BaseAddress, DWORD Length);
//WX86CPUAPI BOOLEAN CpuMapNotify(PVOID DllBase, BOOLEAN Mapped); moved down
WX86CPUAPI VOID CpuEnterIdle(BOOL fOFly);

//
// CPU feature set information
//
WX86CPUAPI BOOL CpuIsProcessorFeaturePresent(DWORD ProcessorFeature);

//
// Public Functions to get and set individual registers
// are defined in Wx86.h
//


//
// Functions for exception handling
//


WX86CPUAPI VOID MsCpuResetToConsistentState(PEXCEPTION_POINTERS pExecptionPointers);
WX86CPUAPI VOID CpuPrepareToContinue(PEXCEPTION_POINTERS pExecptionPointers);

//
// Functions for process/thread manipulation
//
WX86CPUAPI VOID  CpuStallExecutionInThisProcess(VOID);
WX86CPUAPI VOID  CpuResumeExecutionInThisProcess(VOID);
WX86CPUAPI DWORD CpuGetThreadContext(HANDLE hThread, PVOID CpuContext, PCONTEXT_WX86 Context);
WX86CPUAPI DWORD CpuSetThreadContext(HANDLE hThread, PVOID CpuContext, PCONTEXT_WX86 Context);

#endif //__WOW64_WRAPPER__
WX86CPUAPI BOOLEAN CpuMapNotify(PVOID DllBase, BOOLEAN Mapped);
WX86CPUAPI NTSTATUS MsCpuProcessInit(VOID);
WX86CPUAPI BOOL MsCpuThreadInit(VOID);
WX86CPUAPI VOID MsCpuSimulate(PWX86_CPUHINT);

WX86CPUAPI
NTSTATUS
MsCpuSetContext(
    PCONTEXT_WX86 Context);

NTSTATUS
MsCpuSetContextThread(
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT_WX86 Context);

WX86CPUAPI 
NTSTATUS 
MsCpuGetContext(
    IN OUT PCONTEXT_WX86 Context);

WX86CPUAPI 
NTSTATUS
MsCpuGetContextThread(
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT_WX86 Context);



#ifdef __cplusplus
} // extern "C"
#endif

#endif  //_WX86CPU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\log.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    log.c

Abstract:
    
    logarithmic functions
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/


#include <math.h>
#include <trans.h>

static double _log_hlp( double x, int flag);

/* constants */
static double const c0 =  0.70710678118654752440;   /* sqrt(0.5) */
static double const c1 =  0.69335937500000000000;
static double const c2 = -2.121944400546905827679e-4;
static double const c3 =  0.43429448190325182765;

/* coefficients for rational approximation */
static double const a0 = -0.64124943423745581147e2 ;
static double const a1 =  0.16383943563021534222e2 ;
static double const a2 = -0.78956112887491257267e0 ;
static double const b0 = -0.76949932108494879777e3 ;
static double const b1 =  0.31203222091924532844e3 ;
static double const b2 = -0.35667977739034646171e2 ;
/* b3=1.0  is not used -avoid multiplication by 1.0 */

#define A(w) (((w) * a2 + a1) * (w) + a0)
#define B(w) ((((w) + b2) * (w) + b1) * (w) + b0)


/***
*double log(double x) -  natural logarithm
*double log10(double x) - base-10 logarithm
*
*Purpose:
*   Compute the natural and base-10 logarithm of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P Z
*******************************************************************************/

double Proxylog10(double x)
{
    return(_log_hlp(x,OP_LOG10));
}

double Proxylog(double x)
{
    return(_log_hlp(x,OP_LOG));
}

static double _log_hlp(double x, int opcode)
{
    unsigned int savedcw;
    int n;
    double f,result;
    double z,w,znum,zden;
    double rz,rzsq;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    switch (_sptype(x)) {
    case T_PINF:
        RETURN(savedcw, x);
    case T_QNAN:
        return _handle_qnan1(opcode, x, savedcw);
    case T_SNAN:
        return _except1(FP_I, opcode, x, _s2qnan(x), savedcw);
    }
    /* NINF will be handled in the x<0 case */
    }

    if (x <= 0.0) {
    double qnan;
    if (x == 0.0) {
        return _except1(FP_Z,opcode,x,-D_INF,savedcw);
    }
    qnan = (opcode == OP_LOG ? QNAN_LOG : QNAN_LOG10);
    return _except1(FP_I,opcode,x,qnan,savedcw);
    }

    if (x == 1.0) {
    // no precision ecxeption
    RETURN(savedcw, 0.0);
    }

    f = _decomp(x, &n);

    if (f > c0) {
    znum = (f - 0.5) - 0.5;
    zden = f * 0.5 + 0.5;
    }
    else {
    n--;
    znum = f - 0.5;
    zden = znum * 0.5 + 0.5;
    }
    z = znum / zden;
    w = z * z; 

    rzsq = w * A(w)/B(w) ;
    rz = z + z*rzsq;

    result = (n * c2 + rz) + n * c1;
    if (opcode == OP_LOG10) {
    result *= c3;
    }

    RETURN_INEXACT1(opcode,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\ieeemisc.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    ieeemisc.c 

Abstract:
    
    IEEE miscellaneous recommended functions
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/

 

#include <trans.h>
#include <math.h>
#include <float.h>


/***
* _copysign - copy sign
*
*Purpose:
*   copysign(x,y) returns x with the sign of y. Hence, abs(x) := copysign
*   even if x is NaN [IEEE std 854-1987 Appendix]
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if one of the arguments is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _copysign (double x, double y)
{
    double retval;
    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1<<31) |
            *D_HI(y) &  (1<<31) ;

    return retval;
}



/***
* _chgsign - change sign
*
*Purpose:
*  x is copied with its sign reversed, not 0-x; the distinction is germane
*  when x is +0, -0, or NaN
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if x is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _chgsign (double x)
{
    double retval;

    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1 << 31)  |
            ~*D_HI(x) & (1<<31);

    return retval;
}


/***
* _scalb - scale by power of 2
*
*Purpose:
*   _scalb(x,n) returns x * 2^n for integral values of n without
*   computing 2^n
*   Special case:
*      If x is infinity or zero, _scaleb returns x
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Overflow, Underflow
*
*******************************************************************************/

double _scalb(double x, long n)
{
    //
    // It turns out that our implementation of ldexp matces the IEEE
    // description of _scalb. The only problem with calling ldexp
    // is that if an exception occurs, the operation code reported
    // to the handler will be the one that corresponds to ldexp
    // (i.e., we do not define a new operation code for _scalb
    //

    return ldexp(x,n);
}




/***
* _logb - extract exponent
*
*Purpose:
*   _logb(x) returns the unbiased exponent of x, a signed integer in the
*   format of x, except that logb(NaN) is a NaN, logb(+INF) is +INF,and
*   logb(0) is is -INF and signals the division by zero exception.
*   For x positive and finite, 1<= abs(scalb(x, -logb(x))) < 2
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Division by zero
*
*******************************************************************************/
double _logb(double x)
{
    unsigned int savedcw;
    int exp;
    double retval;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    switch (_sptype(x)) {
    case T_PINF:
    case T_NINF:
        RETURN(savedcw, x);
    case T_QNAN:
        return _handle_qnan1(OP_LOGB, x, savedcw);
    default: //T_SNAN
        return _except1(FP_I, OP_LOGB, x, _s2qnan(x), savedcw);
    }
    }

    if (x == 0) {
     return _except1(FP_Z, OP_LOGB, x, -D_INF, savedcw);
    }

    (void) _decomp(x, &exp);

    //
    // x == man * 2^exp, where .5 <= man < 1. According to the spec
    // of this function, we should compute the exponent so that
    // 1<=man<2, i.e., we should decrement the computed exp by one
    //

    retval = (double) (exp - 1);

    RETURN(savedcw, retval);

}





/***
* _nextafter - next representable neighbor
*
*Purpose:
*  _nextafter(x,y) returns the next representable neighbor of x in
*  the direction toward y. The following special cases arise: if
*  x=y, then the result is x without any exception being signaled;
*  otherwise, if either x or y is a quiet NaN, then the result is
*  one or the other of the input NaNs. Overflow is sibnaled when x
*  is finite but nextafter(x,y) is infinite; underflow is signaled
*  when nextafter(x,y) lies strictly between -2^Emin, 2^Emin; in
*  both cases, inexact is signaled.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   O, U, I, P
*
*******************************************************************************/

double _nextafter(double x, double y)
{
    unsigned int savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)){
    if (IS_D_SNAN(x) || IS_D_SNAN(y)){
        return _except2(FP_I,OP_NEXTAFTER,x,y,_d_snan2(x,y),savedcw);
    }
    if (IS_D_QNAN(x) || IS_D_QNAN(y)){
        return _handle_qnan2(OP_NEXTAFTER,x,y,savedcw);
    }

    //
    // infinite arguments are not treated as special cases
    //
    }

    if (y == x) {

    //
    // no exceptions are raised in this case
    //

    RETURN(savedcw, x);
    }

    if (x == 0) {

    *D_LO(result) = 1;

    if (y > x) {
        *D_HI(result) = 0;
    }

    else {

        //
        // result should be negative
        //

        *D_HI(result) = (unsigned long)(1<<31);
    }

    }


    //
    // At this point x!=y, and x!=0. x can be treated as a 64bit
    // integer in sign/magnitude representation. To get the next
    // representable neighbor we add or subtract one from this
    // integer. (Note that for boundary cases like x==INF, need to
    // add one will never occur --this would mean that y should
    // be greater than INF, which is impossible)
    //

    if (x > 0 && y < x ||
    x < 0 && y > x) {

    //
    // decrease value by one
    //

    *D_LO(result) = *D_LO(x) - 1;
    *D_HI(result) = *D_HI(x);

    if (*D_LO(x) == 0) {

        //
        // a borrow should propagate to the high order dword
        //

        (*D_HI(result)) --;
    }
    }

    else if (x > 0 && y > x ||
         x < 0 && y < x) {

    //
    // increase value by one
    //

    *D_LO(result) = *D_LO(x) + 1;
    *D_HI(result) = *D_HI(x);

    if (*D_LO(result) == 0) {

        //
        // a carry should propagate to the high order dword
        //

        (*D_HI(result)) ++;
    }
    }


    //
    // check if an exception should be raised
    //


    if ( IS_D_DENORM(result) ) {

    //
    // should signal underflow and inexact
    // and provide a properly scaled value
    //

    double mant;
    int exp;

    mant = _decomp(result, &exp);
    result = _set_exp(mant, exp+IEEE_ADJUST);

    return _except2(FP_U|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }



    if ( IS_D_INF(result) || IS_D_MINF(result) ) {

    //
    // should signal overflow and inexact
    // and provide a properly scaled value
    //

    double mant;
    int exp;

    mant = _decomp(result, &exp);
    result = _set_exp(mant, exp-IEEE_ADJUST);

    return _except2(FP_O|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }


    RETURN(savedcw, result);
}




/***
* _finite -
*
*Purpose:
*   finite(x) returns the value TRUE if -INF < x < +INF and returns
*   false otherwise [IEEE std]
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _finite(double x)
{
    if (IS_D_SPECIAL(x)) {

    //
    // x is INF or NaN
    //

    return 0;
    }
    return 1;
}





/***
* _isnan -
*
*Purpose:
*   isnan(x) returns the value TRUE if x is a NaN, and returns FALSE
*   otherwise.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _isnan(double x)
{
    if (IS_D_SNAN(x) || IS_D_QNAN(x)) {
    return 1;
    }
    return 0;
}




/***
*double _fpclass(double x) - floating point class
*
*Purpose:
*   Compute the floating point class of a number, according
*   to the recommendations of the IEEE std. 754
*
*Entry:
*
*Exit:
*
*Exceptions:
*   This function is never exceptional, even when the argument is SNAN
*
*******************************************************************************/

int _fpclass(double x)
{
    int sign;

    if (IS_D_SPECIAL(x)){
    switch (_sptype(x)) {
    case T_PINF:
        return _FPCLASS_PINF;
    case T_NINF:
        return _FPCLASS_NINF;
    case T_QNAN:
        return _FPCLASS_QNAN;
    default: //T_SNAN
        return _FPCLASS_SNAN;
    }
    }
    sign = (*D_EXP(x)) & 0x8000;

    if (IS_D_DENORM(x))
    return sign? _FPCLASS_ND : _FPCLASS_PD;

    if (x == 0.0)
    return sign? _FPCLASS_NZ : _FPCLASS_PZ;

    return sign? _FPCLASS_NN : _FPCLASS_PN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\fpexcept.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    fpexcept.c

Abstract:
    
    This module handle boundary conditions while doing math operation. 
    Need to reimplement or remove if not required.
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/



#if defined(_NTSUBSET_) || defined (_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _KERNEL32_          // Don't Export RaiseException
#endif  // _NTSUBSET_

#define DEFINE_EXTERN_HERE
#include <trans.h>
#undef DEFINE_EXTERN_HERE
#include <errno.h>
#include <math.h>
#include <windows.h>

VOID ProxyRaiseException(
    IN DWORD dwExceptionCode,
    IN DWORD dwExceptionFlags,
    IN DWORD nNumberOfArguments,
    IN CONST ULONG_PTR *lpArguments
    );

//
// copy a double without generating floating point instructions
// (avoid invalid operation on x87)
//

#define COPY_DOUBLE(pdest, psrc) \
      ( *(unsigned int *)pdest = *(unsigned int *)psrc,   \
        *((unsigned int *)pdest+1) = *((unsigned int *)psrc+1) )



//
// _matherr_flag is a communal variable. It is equal to zero
// if the user has redefined matherr(). Otherwise it has a
// non zero value. The default matherr routine does nothing
// and returns 0.
//

int _matherr_flag;

//
// a routine for artificially setting the fp status bits in order
// to signal a software generated masked fp exception.
//

extern void _set_statfp(unsigned int);


void _raise_exc(_FPIEEE_RECORD *prec,unsigned int *pcw,
    int flags, int opcode, double *parg1, double *presult);

double _umatherr(int type, unsigned int opcode,
                 double arg1, double arg2, double presult,
                 unsigned int cw);

static char *_get_fname(unsigned int opcode);

/***
* _handle_qnan1, _handle_qnan2 - handle quiet NaNs as function arguments
*
*Purpose:
*   Do all necessary work for handling the case where the argument
*   or one of the arguments of a floating point function is a quiet NaN
*
*Entry:
*   unsigned int opcode: The operation code of the fp function
*   double x: the fp function argument
*   double y: the fp function second argument (_handle_qnan2 only)
*   unsigned int savedcw: the user's control word
*
*Exit:
*   restore the user's control word,  and
*   return the suggested return value for the fp function
*
*Exceptions:
*
*******************************************************************************/

double _handle_qnan1(unsigned int opcode,
                     double x,
                     unsigned int savedcw)
{
    if (! _matherr_flag) {

        //
        // QNaN arguments are treated as domain errors
        // invoke the user's matherr routine
        // _umatherr will take care of restoring the
        // user's control word
        //

        return _umatherr(_DOMAIN,opcode,x,0.0,x,savedcw);
    }
    else {
        SetMathError ( EDOM );
        _rstorfp(savedcw);
        return x;
    }
}


double _handle_qnan2(unsigned int opcode,
                     double x,
                     double y,
                     unsigned int savedcw)
{
    double result;

    //
    // NaN propagation should be handled by the underlying fp h/w
    //

    result = x+y;

    if (! _matherr_flag) {
        return _umatherr(_DOMAIN,opcode,x,y,result,savedcw);
    }
    else {
        SetMathError ( EDOM );
        _rstorfp(savedcw);
        return result;
    }
}



/***
* _except1 - exception handling shell for fp functions with one argument
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg: the argument of the fp function
*   double result: default result
*   unsigned int cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except1(int flags,
                int opcode,
                double arg,
                double result,
                unsigned int cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // At this point _handle_exception has failed to deal
        // with the error
        // An IEEE exception should be raised
        //

        _FPIEEE_RECORD rec;

        // The rec structure will be filled in by _raise_exc,
        // except for the Operand2 information

        rec.Operand2.OperandValid = 0;
        _raise_exc(&rec, &cw, flags, opcode, &arg, &result);
    }


    //
    // At this point we have either the masked response of the
    // exception, or a value supplied by the user's IEEE exception
    // handler. The _matherr mechanism is supported for backward
    // compatibility.
    //

    type = _errcode(flags);

    // Inexact result fp exception does not have a matherr counterpart;
    // in that case type is 0.

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg, 0.0, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _except2 - exception handling shell for fp functions with two arguments
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg1: the first argument of the fp function
*   double arg2: the second argument of the fp function
*   double result: default result
*   unsigned int cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except2(int flags,
                int opcode,
                double arg1,
                double arg2,
                double result,
                unsigned int cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // trap should be taken
        //

        _FPIEEE_RECORD rec;

        //
        // fill in operand2 info. The rest of rec will be
        // filled in by _raise_exc
        //

        rec.Operand2.OperandValid = 1;
        rec.Operand2.Format = _FpFormatFp64;
        rec.Operand2.Value.Fp64Value = arg2;

        _raise_exc(&rec, &cw, flags, opcode, &arg1, &result);

    }

    type = _errcode(flags);

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg1, arg2, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _raise_exc - raise fp IEEE exception
*
*Purpose:
*   fill in an fp IEEE record struct and raise a fp exception
*
*
*Entry / Exit:
*   IN _FPIEEE_RECORD prec   pointer to an IEEE record
*   IN OUT unsigned int *pcw     pointer to user's fp control word
*   IN int flags,       exception flags
*   IN int opcode,      fp operation code
*   IN double *parg1,        pointer to first argument
*   IN double *presult)      pointer to result
*
*Exceptions:
*
*******************************************************************************/

void _raise_exc( _FPIEEE_RECORD *prec,
                 unsigned int *pcw,
                 int flags,
                 int opcode,
                 double *parg1,
                 double *presult)
{
    DWORD exc_code;
    unsigned int sw;

    //
    // reset all control bits
    //

    *(int *)&(prec->Cause) = 0;
    *(int *)&(prec->Enable) = 0;
    *(int *)&(prec->Status) = 0;

    //
    // Precision exception may only coincide with overflow
    // or underflow. If this is the case, overflow (or
    // underflow) take priority over precision exception.
    // The order of checks is from the least important
    // to the most important exception
    //

    if (flags & FP_P) {
        exc_code = (DWORD) STATUS_FLOAT_INEXACT_RESULT;
        prec->Cause.Inexact = 1;
    }
    if (flags & FP_U) {
        exc_code = (DWORD) STATUS_FLOAT_UNDERFLOW;
        prec->Cause.Underflow = 1;
    }
    if (flags & FP_O) {
        exc_code = (DWORD) STATUS_FLOAT_OVERFLOW;
        prec->Cause.Overflow = 1;
    }
    if (flags & FP_Z) {
        exc_code = (DWORD) STATUS_FLOAT_DIVIDE_BY_ZERO;
        prec->Cause.ZeroDivide = 1;
    }
    if (flags & FP_I) {
        exc_code = (DWORD) STATUS_FLOAT_INVALID_OPERATION;
        prec->Cause.InvalidOperation = 1;
    }


    //
    // Set exception enable bits
    //

    prec->Enable.InvalidOperation = (*pcw & IEM_INVALID) ? 0 : 1;
    prec->Enable.ZeroDivide = (*pcw & IEM_ZERODIVIDE) ? 0 : 1;
    prec->Enable.Overflow = (*pcw & IEM_OVERFLOW) ? 0 : 1;
    prec->Enable.Underflow = (*pcw & IEM_UNDERFLOW) ? 0 : 1;
    prec->Enable.Inexact = (*pcw & IEM_INEXACT) ? 0 : 1;


    //
    // Set status bits
    //

    sw = _statfp();


    if (sw & ISW_INVALID) {
        prec->Status.InvalidOperation = 1;
    }
    if (sw & ISW_ZERODIVIDE) {
        prec->Status.ZeroDivide = 1;
    }
    if (sw & ISW_OVERFLOW) {
        prec->Status.Overflow = 1;
    }
    if (sw & ISW_UNDERFLOW) {
        prec->Status.Underflow = 1;
    }
    if (sw & ISW_INEXACT) {
        prec->Status.Inexact = 1;
    }


    switch (*pcw & IMCW_RC) {
    case IRC_CHOP:
        prec->RoundingMode = _FpRoundChopped;
        break;
    case IRC_UP:
        prec->RoundingMode = _FpRoundPlusInfinity;
        break;
    case IRC_DOWN:
        prec->RoundingMode = _FpRoundMinusInfinity;
        break;
    case IRC_NEAR:
        prec->RoundingMode = _FpRoundNearest;
        break;
    }

#ifdef _M_IX86

    switch (*pcw & IMCW_PC) {
    case IPC_64:
        prec->Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        prec->Precision = _FpPrecision53;
        break;
    case IPC_24:
        prec->Precision = _FpPrecision24;
        break;
    }

#endif


#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
    prec->Precision = _FpPrecision53;
#endif

    prec->Operation = opcode;

    prec->Operand1.OperandValid = 1;
    prec->Operand1.Format = _FpFormatFp64;
    prec->Operand1.Value.Fp64Value = *parg1;

    prec->Result.OperandValid = 1;
    prec->Result.Format = _FpFormatFp64;
    prec->Result.Value.Fp64Value = *presult;

    //
    // By convention software exceptions use the first exception
    // parameter in order to pass a pointer to the _FPIEEE_RECORD
    // structure.
    //

    _clrfp();

    
    ProxyRaiseException(exc_code,0,1,(CONST ULONG_PTR *)&prec);


    //
    // user's trap handler may have changed either the fp environment
    // or the result
    //

    //
    // Update exception mask
    //

    if (prec->Enable.InvalidOperation)
        (*pcw) &= ~IEM_INVALID;
    if (prec->Enable.ZeroDivide)
        (*pcw) &= ~IEM_ZERODIVIDE;
    if (prec->Enable.Overflow)
        (*pcw) &= ~IEM_OVERFLOW;
    if (prec->Enable.Underflow)
        (*pcw) &= ~IEM_UNDERFLOW;
    if (prec->Enable.Inexact)
        (*pcw) &= ~IEM_INEXACT;

    //
    // Update Rounding mode
    //

    switch (prec->RoundingMode) {
    case _FpRoundChopped:
         *pcw = *pcw & ~IMCW_RC | IRC_CHOP;
         break;
    case _FpRoundPlusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_UP;
         break;
    case _FpRoundMinusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_DOWN;
         break;
    case _FpRoundNearest:
         *pcw = *pcw & ~IMCW_RC | IRC_NEAR;
         break;
    }


#ifdef _M_IX86

    //
    // Update Precision Control
    //

    switch (prec->Precision) {
    case _FpPrecisionFull:
         *pcw = *pcw & ~IMCW_RC | IPC_64;
         break;
    case _FpPrecision53:
         *pcw = *pcw & ~IMCW_RC | IPC_53;
         break;
    case _FpPrecision24:
         *pcw = *pcw & ~IMCW_RC | IPC_24;
         break;
    }

#endif

    //
    // Update result
    //

    *presult = prec->Result.Value.Fp64Value;
}



/***
* _handle_exc - produce masked response for IEEE fp exception
*
*Purpose:
*
*Entry:
*   unsigned int flags      the exception flags
*   double *presult         the default result
*   unsigned int cw         user's fp control word
*
*Exit:
*   returns 1 on successful handling, 0 on failure
*   On success, *presult becomes the masked response
*
*Exceptions:
*
*******************************************************************************/

int _handle_exc(unsigned int flags, double * presult, unsigned int cw)
{
    //
    // flags_p is useful for deciding whether there are still unhandled
    // exceptions in case multiple exceptions have occurred
    //

    int flags_p = flags & (FP_I | FP_Z | FP_O | FP_U | FP_P);

    if (flags & FP_I && cw & IEM_INVALID) {

        //
        // Masked response for invalid operation
        //

        _set_statfp(ISW_INVALID);
        flags_p &= ~FP_I;
    }

    else if (flags & FP_Z && cw & IEM_ZERODIVIDE) {

        //
        // Masked response for Division by zero
        // result should already have the proper value
        //

        _set_statfp( ISW_ZERODIVIDE);
        flags_p &= ~FP_Z;
    }

    else if (flags & FP_O && cw & IEM_OVERFLOW) {

        //
        // Masked response for Overflow
        //

        _set_statfp(ISW_OVERFLOW);
        switch (cw & IMCW_RC) {
        case IRC_NEAR:
            *presult = *presult > 0.0 ? D_INF : -D_INF;
            break;
        case IRC_UP:
            *presult = *presult > 0.0 ? D_INF : -D_MAX;
            break;
        case IRC_DOWN:
            *presult = *presult > 0.0 ? D_MAX : -D_INF;
            break;
        case IRC_CHOP:
            *presult = *presult > 0.0 ? D_MAX : -D_MAX;
            break;
        }

        flags_p &= ~FP_O;
    }

    else if (flags & FP_U && cw & IEM_UNDERFLOW) {

        //
        // Masked response for Underflow:
        // According to the IEEE standard, when the underflow trap is not
        // enabled, underflow shall be signaled only when both tininess
        // and loss of accuracy have been detected
        //

        int aloss=0;    // loss of accuracy flag

        if (flags & FP_P) {
            aloss = 1;
        }

        //
        // a zero value in the result denotes
        // that even after ieee scaling, the exponent
        // was too small.
        // in this case the masked response is also
        // zero (sign is preserved)
        //

        if (*presult != 0.0) {
            double result;
            int expn, newexp;

            result = _decomp(*presult, &expn);
            newexp = expn - IEEE_ADJUST;

            if (newexp < MINEXP - 53) {
                result *= 0.0;          // produce a signed zero
                aloss = 1;
            }
            else {
                int neg = result < 0;       // save sign

                //
                // denormalize result
                //

                (*D_EXP(result)) &= 0x000f; /* clear exponent field */
                (*D_EXP(result)) |= 0x0010; /* set hidden bit */

                for (;newexp<MINEXP;newexp++) {
                    if (*D_LO(result) & 0x1 && !aloss) {
                        aloss = 1;
                    }

                    /* shift mantissa to the right */
                    (*D_LO(result)) >>= 1;
                    if (*D_HI(result) & 0x1) {
                        (*D_LO(result)) |= 0x80000000;
                    }
                    (*D_HI(result)) >>= 1;
                }
                if (neg) {
                    result = -result;       // restore sign
                }
            }

            *presult = result;
        }
        else {
            aloss = 1;
        }

        if (aloss) {
            _set_statfp(ISW_UNDERFLOW);
        }

        flags_p &= ~FP_U;
    }


    //
    // Separate check for precision exception
    // (may coexist with overflow or underflow)
    //

    if (flags & FP_P && cw & IEM_INEXACT) {

        //
        // Masked response for inexact result
        //

        _set_statfp(ISW_INEXACT);
        flags_p &= ~FP_P;
    }

    return flags_p ? 0: 1;
}



/***
* _umatherr - call user's matherr routine
*
*Purpose:
*   call user's matherr routine and set errno if appropriate
*
*
*Entry:
*     int type              type of excpetion
*     unsigned int opcode   fp function that caused the exception
*     double arg1           first argument of the fp function
*     double arg2           second argument of the fp function
*     double retval         return value of the fp function
*     unsigned int cw       user's fp control word
*
*Exit:
*     fp control word       becomes the user's fp cw
*     errno                 modified if user's matherr returns 0
*     return value          the retval entered by the user in
*                           the _exception matherr struct
*
*Exceptions:
*
*******************************************************************************/

double _umatherr(
              int type,
              unsigned int opcode,
              double arg1,
              double arg2,
              double retval,
              unsigned int cw
              )
{
    struct _exception exc;

    //
    // call matherr only if the name of the function
    // is registered in the table, i.e., only if exc.name is valid
    //

    if (exc.name = _get_fname(opcode)) {
        exc.type = type;

        COPY_DOUBLE(&exc.arg1,&arg1);
        COPY_DOUBLE(&exc.arg2,&arg2);
        COPY_DOUBLE(&exc.retval,&retval);

        _rstorfp(cw);

        
        //if (_matherr(&exc) == 0) {
            _set_errno(type);
        //}
        return  exc.retval;
    }
    else {

        //
        // treat this case as if matherr returned 0
        //

        _rstorfp(cw);
        _set_errno(type);
        return retval;
    }

}



/***
* _set_errno - set errno
*
*Purpose:
*   set correct error value for errno
*
*Entry:
*   int matherrtype:    the type of math error
*
*Exit:
*   modifies errno
*
*Exceptions:
*
*******************************************************************************/

void _set_errno(int matherrtype)
{
    switch(matherrtype) {
    case _DOMAIN:
        SetMathError ( EDOM );
        break;
    case _OVERFLOW:
    case _SING:
        SetMathError ( ERANGE );
        break;
    }
}



/***
* _get_fname -  get function name
*
*Purpose:
*  returns the _matherr function name that corresponds to a
*  floating point opcode
*
*Entry:
*  _FP_OPERATION_CODE opcode
*
*Exit:
*   returns a pointer to a string
*
*Exceptions:
*
*******************************************************************************/
#define OP_NUM  27   /* number of fp operations */

static char *_get_fname(unsigned int opcode)
{

    static struct {
        unsigned int opcode;
        char *name;
    } _names[OP_NUM] = {
        { OP_EXP,   "exp" },
        { OP_POW,   "pow" },
        { OP_LOG,   "log" },
        { OP_LOG10, "log10"},
        { OP_SINH,  "sinh"},
        { OP_COSH,  "cosh"},
        { OP_TANH,  "tanh"},
        { OP_ASIN,  "asin"},
        { OP_ACOS,  "acos"},
        { OP_ATAN,  "atan"},
        { OP_ATAN2, "atan2"},
        { OP_SQRT,  "sqrt"},
        { OP_SIN,   "sin"},
        { OP_COS,   "cos"},
        { OP_TAN,   "tan"},
        { OP_CEIL,  "ceil"},
        { OP_FLOOR, "floor"},
        { OP_ABS,   "fabs"},
        { OP_MODF,  "modf"},
        { OP_LDEXP, "ldexp"},
        { OP_CABS,  "_cabs"},
        { OP_HYPOT, "_hypot"},
        { OP_FMOD,  "fmod"},
        { OP_FREXP, "frexp"},
        { OP_Y0,    "_y0"},
        { OP_Y1,    "_y1"},
        { OP_YN,    "_yn"}
    };

    int i;
    for (i=0;i<OP_NUM;i++) {
        if (_names[i].opcode == opcode)
            return _names[i].name;
    }
    return (char *)0;
}



/***
* _errcode - get _matherr error code
*
*Purpose:
*   returns matherr type that corresponds to exception flags
*
*Entry:
*   flags: exception flags
*
*Exit:
*   returns matherr type
*
*Exceptions:
*
*******************************************************************************/

int _errcode(unsigned int flags)
{
    unsigned int errcode;

    if (flags & FP_TLOSS) {
        errcode = _TLOSS;
    }
    else if (flags & FP_I) {
        errcode = _DOMAIN;
    }
    else if (flags & FP_Z) {
        errcode = _SING;
    }
    else if (flags & FP_O) {
        errcode = _OVERFLOW;
    }
    else if (flags & FP_U) {
        errcode = _UNDERFLOW;
    }
    else {

        // FP_P

        errcode = 0;
    }
    return errcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\modf.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

   modf.c 

Abstract:
    
   modf()  function
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/

#include <math.h>
#include <trans.h>
#include <float.h> 

extern double _frnd(double);
extern double _copysign (double x, double y);

/***
*double modf(double x, double *intptr)
*
*Purpose:
*   Split x into fractional and integer part
*   The signed fractional portion is returned
*   The integer portion is stored as a floating point value at intptr
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I
*******************************************************************************/
static  unsigned int newcw = (ICW & ~IMCW_RC) | (IRC_CHOP & IMCW_RC);

double modf(double x, double *intptr)
{
    unsigned int savedcw;
    double result,intpart;

    /* save user fp control word */
    savedcw = _ctrlfp(0, 0);     /* get old control word */
    _ctrlfp(newcw,IMCW);    /* round towards 0 */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    *intptr = QNAN_MODF;
    switch (_sptype(x)) {
    case T_PINF:
    case T_NINF:
        *intptr = x;
        result = _copysign(0, x);
        RETURN(savedcw,result);
    case T_QNAN:
        *intptr = x;
        return _handle_qnan1(OP_MODF, x, savedcw);
    default: //T_SNAN
        result = _s2qnan(x);
        *intptr = result;
        return _except1(FP_I, OP_MODF, x, result, savedcw);
    }
    }

    if (x == 0.0) {
    *intptr = x;
    result = x;
    }

    else {
    intpart = _frnd(x); //fix needed: this may set the P exception flag
            //and pollute the fp status word

    *intptr = intpart;
    result = x - intpart;
    }

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\axp64\fpctrl.s ===
//      TITLE("Floating Point Control")
//++
//
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    fpctrl.s
//
// Abstract:
//
//    This module implements routines that control floating point
//    operations.
//
// Author:
//
//    Thomas Van Baak (tvb) 31-Aug-1992
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "ksalpha.h"

//
// Define call frame used to exchange a floating point and integer register.
//

        .struct 0
FpCr:   .space  8                       // fpcr value
        .space  8                       // ensure 16-byte stack alignment
FpFrameLength:                          // length of stack frame

        SBTTL("Get Hardware Floating Point Control Register")
//++
//
// ULONGLONG
// _get_fpcr (
//    VOID
//    )
//
// Routine Description:
//
//    This function obtains the current FPCR value.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    The current value of the FPCR is returned as the function value.
//
//--

        NESTED_ENTRY(_get_fpcr, FpFrameLength, ra)

        lda     sp, -FpFrameLength(sp)  // allocate stack frame

        PROLOGUE_END

        excb                            // wait for all pending traps
        mf_fpcr f0, f0, f0              // get current fpcr
        excb                            // block against new traps
        stt     f0, FpCr(sp)            // store floating register in order to
        ldq     v0, FpCr(sp)            //   load integer register with fpcr

        lda     sp, FpFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

        .end    _get_fpcr

        SBTTL("Set Hardware Floating Point Control Register")
//++
//
// VOID
// _set_fpcr (
//    ULONGLONG FpcrValue
//    )
//
// Routine Description:
//
//    This function sets a new value in the FPCR.
//
// Arguments:
//
//    FpcrValue (a0) - Supplies the new value for the FPCR.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(_set_fpcr, FpFrameLength, ra)

        lda     sp, -FpFrameLength(sp)  // allocate stack frame

        PROLOGUE_END

        stq     a0, FpCr(sp)            // store integer register in order to
        ldt     f0, FpCr(sp)            //   load floating register with fpcr
        excb                            // wait for all pending traps
        mt_fpcr f0, f0, f0              // set new fpcr
        excb                            // block against new traps

        lda     sp, FpFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

        .end    _set_fpcr

        SBTTL("Get Software Floating Point Control and Status Register")
//++
//
// ULONG
// _get_softfpcr (
//    VOID
//    )
//
// Routine Description:
//
//    This function obtains the current software FPCR value.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    The current value of the software FPCR is returned as the function value.
//
//--

        LEAF_ENTRY(_get_softfpcr)

        GET_THREAD_ENVIRONMENT_BLOCK    // get Teb address in v0
        ldl     v0, TeSoftFpcr(v0)      // get current software fpcr value
        ret     zero, (ra)              // return

        .end    _get_softfpcr

        SBTTL("Set Software Floating Point Control and Status Register")
//++
//
// VOID
// _set_softfpcr (
//    ULONG SoftFpcrValue
//    )
//
// Routine Description:
//
//    This function sets a new value in the software FPCR.
//
// Arguments:
//
//    SoftFpcrValue (a0) - Supplies the new value for the software FPCR.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(_set_softfpcr)

        GET_THREAD_ENVIRONMENT_BLOCK    // get Teb address in v0
        stl     a0, TeSoftFpcr(v0)      // store new software fpcr value
        ret     zero, (ra)              // return

        .end    _set_softfpcr

        SBTTL("Set New Floating Control Register Value")
//++
//
// ULONG
// _ctrlfp (
//    IN ULONG newctrl,
//    IN ULONG mask
//    )
//
// Routine Description:
//
//    For Alpha AXP this function sets nothing. It returns the current
//    rounding mode and the current IEEE exception disable mask in the
//    fp32 internal control word format.
//
// Arguments:
//
//    newctrl (a0) - Supplies the new control bits to be set.
//
//    mask (a1) - Supplies the mask of bits to be set.
//
// Return Value:
//
//    oldctrl (v0) - Returns the old value of the control bits.
//
//
//--

        NESTED_ENTRY(_ctrlfp, FpFrameLength, ra)

        lda     sp, -FpFrameLength(sp)  // allocate stack frame

        PROLOGUE_END

//
// Get the dynamic rounding mode from the FPCR.
//

        excb                            // wait for all pending traps
        mf_fpcr f0, f0, f0              // get current fpcr
        excb                            // block against new traps
        stt     f0, FpCr(sp)            // store floating register in order to
        ldq     t0, FpCr(sp)            //   load integer register with fpcr

        srl     t0, 58, t0              // shift rounding mode to low end
        and     t0, 0x3, t0             // isolate rounding mode bits
        sll     t0, 58 - 32, t0         // shift to internal cw format

//
// Get the IEEE exception mask bits and status bits from the software FPCR.
//

        GET_THREAD_ENVIRONMENT_BLOCK    // get Teb address in v0
        ldl     v0, TeSoftFpcr(v0)      // get current software fpcr value
        xor     v0, 0x3e, v0            // convert enable bits to disable bits
        or      v0, t0, v0              // merge with current rounding mode

        lda     sp, FpFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

        .end    _ctrlfp

        SBTTL("Get IEEE Sticky Status Bits")
//++
//
// ULONG
// _statfp (
//    VOID
//    )
//
// Routine Description:
//
//    This function gets the IEEE sticky status bits from the software FPCR.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    The current value of the status word is returned as the function value.
//
//--

        LEAF_ENTRY(_statfp)

        GET_THREAD_ENVIRONMENT_BLOCK    // get Teb address in v0
        ldl     v0, TeSoftFpcr(v0)      // get current software fpcr value
        ret     zero, (ra)              // return

        .end    _statfp

        SBTTL("Clear IEEE Sticky Status Bits")
//++
//
// ULONG
// _clrfp (
//    VOID
//    )
//
// Routine Description:
//
//    This function clears the IEEE sticky status bits in the software FPCR.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    The previous value of the status word is returned as the function value.
//
//--

        LEAF_ENTRY(_clrfp)

        GET_THREAD_ENVIRONMENT_BLOCK    // get Teb address in v0
        ldl     t0, TeSoftFpcr(v0)      // get current software fpcr value
        bic     t0, 0x3e0000, t1        // clear status bits
        stl     t1, TeSoftFpcr(v0)      // store new software fpcr value
        mov     t0, v0                  // get previous value
        ret     zero, (ra)              // return

        .end    _clrfp

        SBTTL("Set IEEE Sticky Status Bits")
//++
//
// VOID
// _set_statfp (
//    IN ULONG sw
//    )
//
// Routine Description:
//
//    This function sets a IEEE sticky status bit in the software FPCR.
//
// Arguments:
//
//    sw (a0) - Supplies the status bits to be set.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(_set_statfp)

        GET_THREAD_ENVIRONMENT_BLOCK    // get Teb address in v0
        ldl     t0, TeSoftFpcr(v0)      // get current software fpcr value
        or      t0, a0, t0              // set status bit(s)
        stl     t0, TeSoftFpcr(v0)      // store new software fpcr value
        ret     zero, (ra)              // return

        .end    _set_statfp

        SBTTL("Convert Signal NaN to Quiet NaN")
//++
//
// double
// _nan2qnan (
//    IN double x
//    )
//
// Routine Description:
//
//    This function converts a signaling NaN to a quiet NaN without causing
//    a hardware trap.
//
// Arguments:
//
//    x (f16) - Supplies the signal NaN value to be converted.
//
// Return Value:
//
//    The quiet NaN value is returned as the function value.
//
//--
        NESTED_ENTRY(_nan2qnan, FpFrameLength, ra)

        lda     sp, -FpFrameLength(sp)  // allocate stack frame

        PROLOGUE_END

        stt     f16, FpCr(sp)           // store floating register in order to
        ldq     t0, FpCr(sp)            //   load integer register
        ldiq    t1, (1 << 51)           // get NaN bit
        or      t0, t1, t0              // convert NaN to QNaN
        stq     t0, FpCr(sp)            // store integer register in order to
        ldt     f0, FpCr(sp)            //   load floating register

        lda     sp, FpFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

        .end    _nan2qnan
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\util.c ===
/***
*util.c - utilities for fp transcendentals
*
*	Copyright (c) 1991-1991, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   _set_exp and _add_exp are as those defined in Cody & Waite
*
*Revision History:
*   08-15-91	GDP	written
*   10-20-91	GDP	removed _rint, unsafe_intrnd
*   02-05-92	GDP	added _fpclass
*   03-27-92	GDP	added _d_min
*   06-23-92	GDP	added _d_mzero
*
*******************************************************************************/
#include "trans.h"

/* define special values */

_dbl _d_inf = {SET_DBL (0x7ff00000, 0x0) };	  //positive infinity
_dbl _d_ind = {SET_DBL (D_IND_HI, D_IND_LO)};	  //real indefinite
_dbl _d_max = {SET_DBL (0x7fefffff, 0xffffffff)}; //max double
_dbl _d_min = {SET_DBL (0x00100000, 0x00000000)}; //min normalized double
_dbl _d_mzero = {SET_DBL (0x80000000, 0x00000000)}; //negative zero



double _set_exp(double x, int exp)
/* does not check validity of exp */
{
    double retval;
    int biased_exp;
    retval = x;
    biased_exp = exp + D_BIASM1;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (biased_exp << 4));
    return retval;
}


int _get_exp(double x)
{
    signed short exp;
    exp = (signed short)((*D_EXP(x) & 0x7ff0) >> 4);
    exp -= D_BIASM1; //unbias
    return (int) exp;
}


double _add_exp(double x, int exp)
{
    return _set_exp(x, INTEXP(x)+exp);
}


double _set_bexp(double x, int bexp)
/* does not check validity of bexp */
{
    double retval;
    retval = x;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (bexp << 4));
    return retval;
}


int _sptype(double x)
{
    if (IS_D_INF(x))
	return T_PINF;
    if (IS_D_MINF(x))
	return T_NINF;
    if (IS_D_QNAN(x))
	return T_QNAN;
    if (IS_D_SNAN(x))
	return T_SNAN;
    return 0;
}



/***
*double _decomp(double x, double *expptr)
*
*Purpose:
*   decompose a number to a normalized mantisa and exponent
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

double _decomp(double x, int *pexp)
{
    int exp;
    double man;

    if (x == 0) {
	man = 0;
	exp = 0;
    }
    else if (IS_D_DENORM(x)) {
	int neg;

	exp = 1-D_BIASM1;
	neg = x < 0.0;
	while((*D_EXP(x) & 0x0010) == 0) {
	    /* shift mantissa to the left until bit 52 is 1 */
	    (*D_HI(x)) <<= 1;
	    if (*D_LO(x) & 0x80000000)
		(*D_HI(x)) |= 0x1;
	    (*D_LO(x)) <<= 1;
	    exp--;
	}
	(*D_EXP(x)) &= 0xffef; /* clear bit 52 */
	if (neg) {
	    (*D_EXP(x)) |= 0x8000; /* set sign bit */
	}
	man = _set_exp(x,0);
    }
    else {
	man = _set_exp(x,0);
	exp = INTEXP(x);
    }

    *pexp = exp;
    return man;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\trans.h ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    trans.h

Abstract:
    
    Header file for math functions.
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/


#ifndef _INC_TRANS

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* MIPS ONLY: Protect from assembler */

//#include <cruntime.h>

void
SetMathError ( 
              int Code 
              );

#define OP_UNSPEC    0
#define OP_ADD       1
#define OP_SUB       2
#define OP_MUL       3
#define OP_DIV       4
#define OP_SQRT      5
#define OP_REM       6
#define OP_COMP      7
#define OP_CVT       8
#define OP_RND       9
#define OP_TRUNC     10
#define OP_FLOOR     11
#define OP_CEIL      12
#define OP_ACOS      13
#define OP_ASIN      14
#define OP_ATAN      15
#define OP_ATAN2     16
#define OP_CABS      17
#define OP_COS       18
#define OP_COSH      19
#define OP_EXP       20
#define OP_ABS       21         /* same as OP_FABS */
#define OP_FABS      21         /* same as OP_ABS  */
#define OP_FMOD      22
#define OP_FREXP     23
#define OP_HYPOT     24
#define OP_LDEXP     25
#define OP_LOG       26
#define OP_LOG10     27
#define OP_MODF      28
#define OP_POW       29
#define OP_SIN       30
#define OP_SINH      31
#define OP_TAN       32
#define OP_TANH      33
#define OP_Y0        34
#define OP_Y1        35
#define OP_YN        36
#define OP_LOGB       37
#define OP_NEXTAFTER  38
#define OP_NEG       39

/* Define __cdecl for non-Microsoft compilers */

#if ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <fpieee.h>

#define D_BIASM1 0x3fe /* off by one to compensate for the implied bit */

#ifdef B_END
/* big endian */
#define D_EXP(x) ((unsigned short *)&(x))
#define D_HI(x) ((unsigned long *)&(x))
#define D_LO(x) ((unsigned long *)&(x)+1)
#else
#define D_EXP(x) ((unsigned short *)&(x)+3)
#define D_HI(x) ((unsigned long *)&(x)+1)
#define D_LO(x) ((unsigned long *)&(x))
#endif

/* return the int representation of the exponent
 * if x = .f * 2^n, 0.5<=f<1, return n (unbiased)
 * e.g. INTEXP(3.0) == 2
 */
#define INTEXP(x) ((signed short)((*D_EXP(x) & 0x7ff0) >> 4) - D_BIASM1)


/* check for infinity, NAN */
#define D_ISINF(x) ((*D_HI(x) & 0x7fffffff) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_SPECIAL(x) ((*D_EXP(x) & 0x7ff0) == 0x7ff0)
#define IS_D_NAN(x) (IS_D_SPECIAL(x) && !D_ISINF(x))

#ifdef  _M_MRX000

#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
             (*D_HI(x) << 13 || *D_LO(x)))
#else

#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
             (*D_HI(x) << 13 || *D_LO(x)))
#endif

#define IS_D_DENORM(x)  ((*D_EXP(x) & 0x7ff0) == 0  && \
             (*D_HI(x) << 12 || *D_LO(x)))


#define IS_D_INF(x)  (*D_HI(x) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_MINF(x) (*D_HI(x) == 0xfff00000 && *D_LO(x) == 0)


#ifdef  _M_MRX000
#define D_IND_HI 0x7ff7ffff
#define D_IND_LO 0xffffffff
#else
#define D_IND_HI 0xfff80000
#define D_IND_LO 0x0
#endif


typedef union   {
    long lng[2];
    double dbl;
    } _dbl;


#ifndef DEFINE_EXTERN_HERE
extern _dbl _d_inf;
extern _dbl _d_ind;
extern _dbl _d_max;
extern _dbl _d_min;
extern _dbl _d_mzero;
#else
_dbl _d_inf;
_dbl _d_ind;
_dbl _d_max;
_dbl _d_min;
_dbl _d_mzero;
#endif

#define D_INF  (_d_inf.dbl)
#define D_IND  (_d_ind.dbl)
#define D_MAX  (_d_max.dbl)
#define D_MIN  (_d_min.dbl)
#define D_MZERO (_d_mzero.dbl)       /* minus zero */

/* min and max exponents for normalized numbers in the
 * form: 0.xxxxx... * 2^exp (NOT 1.xxxx * 2^exp !)
 */
#define MAXEXP 1024
#define MINEXP -1021

#endif  /* #ifndef __assembler */


#if defined(_M_IX86)

/* Control word for computation of transcendentals */
#define ICW    0x133f

#define IMCW       0xffff

#define IMCW_EM     0x003f      /* interrupt Exception Masks */
#define IEM_INVALID 0x0001      /*   invalid */
#define IEM_DENORMAL    0x0002      /*   denormal */
#define IEM_ZERODIVIDE  0x0004      /*   zero divide */
#define IEM_OVERFLOW    0x0008      /*   overflow */
#define IEM_UNDERFLOW   0x0010      /*   underflow */
#define IEM_INEXACT 0x0020      /*   inexact (precision) */


#define IMCW_RC 0x0c00          /* Rounding Control */
#define IRC_CHOP    0x0c00      /*   chop */
#define IRC_UP      0x0800      /*   up */
#define IRC_DOWN    0x0400      /*   down */
#define IRC_NEAR    0x0000      /*   near */

#define ISW_INVALID 0x0001      /* invalid */
#define ISW_DENORMAL    0x0002      /* denormal */
#define ISW_ZERODIVIDE  0x0004      /* zero divide */
#define ISW_OVERFLOW    0x0008      /* overflow */
#define ISW_UNDERFLOW   0x0010      /* underflow */
#define ISW_INEXACT 0x0020      /* inexact (precision) */

#define IMCW_PC     0x0300      /* Precision Control */
#define IPC_24      0x0000      /*    24 bits */
#define IPC_53      0x0200      /*    53 bits */
#define IPC_64      0x0300      /*    64 bits */

#define IMCW_IC     0x1000      /* Infinity Control */
#define IIC_AFFINE  0x1000      /*   affine */
#define IIC_PROJECTIVE  0x0000      /*   projective */


#elif defined(_M_MRX000)


#define ICW     0x00000f80      /* Internal CW for transcendentals */
#define IMCW        0xffffff83      /* Internal CW Mask */

#define IMCW_EM     0x00000f80      /* interrupt Exception Masks */
#define IEM_INVALID 0x00000800      /*   invalid */
#define IEM_ZERODIVIDE  0x00000400      /*   zero divide */
#define IEM_OVERFLOW    0x00000200      /*   overflow */
#define IEM_UNDERFLOW   0x00000100      /*   underflow */
#define IEM_INEXACT 0x00000080      /*   inexact (precision) */


#define IMCW_RC     0x00000003      /* Rounding Control */
#define IRC_CHOP    0x00000001      /*   chop */
#define IRC_UP      0x00000002      /*   up */
#define IRC_DOWN    0x00000003      /*   down */
#define IRC_NEAR    0x00000000      /*   near */


#define ISW_INVALID (1<<6)  /* invalid */
#define ISW_ZERODIVIDE  (1<<5)  /* zero divide */
#define ISW_OVERFLOW    (1<<4)  /* overflow */
#define ISW_UNDERFLOW   (1<<3)  /* underflow */
#define ISW_INEXACT (1<<2)  /* inexact (precision) */


#elif defined(_M_ALPHA)

//
// ICW is the Internal Control Word for transcendentals: all five exceptions
// are masked and round to nearest mode is set. IMCW is the mask: all bits
// are set, except for the ISW bits.
//

#define ICW (IEM_INEXACT | IEM_UNDERFLOW | IEM_OVERFLOW | IEM_ZERODIVIDE | IEM_INVALID | IRC_NEAR)
#define ISW (ISW_INEXACT | ISW_UNDERFLOW | ISW_OVERFLOW | ISW_ZERODIVIDE | ISW_INVALID)
#define IMCW (0xffffffff ^ ISW)

//
// The defines for the internal control word match the format of the Alpha
// AXP software FPCR except for the rounding mode which is obtained from the
// Alpha AXP hardware FPCR and shifted right 32 bits.
//

//
// Internal Exception Mask bits.
// Each bit _disables_ an exception (they are not _enable_ bits).
//

#define IMCW_EM     0x0000003e  /* interrupt Exception Masks */

#define IEM_INEXACT 0x00000020  /*   inexact (precision) */
#define IEM_UNDERFLOW   0x00000010  /*   underflow */
#define IEM_OVERFLOW    0x00000008  /*   overflow */
#define IEM_ZERODIVIDE  0x00000004  /*   zero divide */
#define IEM_INVALID 0x00000002  /*   invalid */

//
// Internal Rounding Control values.
//

#define IMCW_RC     (0x3 << 26) /* Rounding Control */

#define IRC_CHOP    (0x0 << 26) /*   chop */
#define IRC_DOWN    (0x1 << 26) /*   down */
#define IRC_NEAR    (0x2 << 26) /*   near */
#define IRC_UP      (0x3 << 26) /*   up */

//
// Internal Status Word bits.
//

#define ISW_INEXACT 0x00200000  /* inexact (precision) */
#define ISW_UNDERFLOW   0x00100000  /* underflow */
#define ISW_OVERFLOW    0x00080000  /* overflow */
#define ISW_ZERODIVIDE  0x00040000  /* zero divide */
#define ISW_INVALID 0x00020000  /* invalid */


#elif defined(_M_PPC)

#define IMCW_EM         0x000000f8  /* Exception Enable Mask    */

#define IEM_INVALID     0x00000080  /*   invalid                */
#define IEM_OVERFLOW    0x00000040  /*   overflow               */
#define IEM_UNDERFLOW   0x00000020  /*   underflow              */
#define IEM_ZERODIVIDE  0x00000010      /*   zero divide            */
#define IEM_INEXACT     0x00000008  /*   inexact (precision)    */


#define IMCW_RC         0x00000003      /* Rounding Control Mask    */

#define IRC_NEAR        0x00000000      /*   near                   */
#define IRC_CHOP        0x00000001      /*   chop                   */
#define IRC_UP          0x00000002      /*   up                     */
#define IRC_DOWN        0x00000003      /*   down                   */


#define IMCW_SW     0x3E000000  /* Status Mask              */

#define ISW_INVALID     0x20000000      /*   invalid summary        */
#define ISW_OVERFLOW    0x10000000      /*   overflow               */
#define ISW_UNDERFLOW   0x08000000      /*   underflow              */
#define ISW_ZERODIVIDE  0x04000000      /*   zero divide            */
#define ISW_INEXACT     0x02000000      /*   inexact (precision)    */


#define IMCW_VX         0x01F80700      /* Invalid Cause Mask       */

#define IVX_SNAN        0x01000000      /*   SNaN                   */
#define IVX_ISI         0x00800000      /*   infinity - infinity    */
#define IVX_IDI         0x00400000      /*   infinity / infinity    */
#define IVX_ZDZ         0x00200000      /*   zero / zero            */
#define IVX_IMZ         0x00100000      /*   infinity * zero        */
#define IVX_VC          0x00080000      /*   inv flpt compare       */
#define IVX_SOFT        0x00000400      /*   software request       */
#define IVX_SQRT        0x00000200      /*   sqrt of negative       */
#define IVX_CVI         0x00000100      /*   inv integer convert    */


/* Internal CW for transcendentals */

#define ICW             (IMCW_EM)

/* Internal CW Mask (non-status bits) */

#define IMCW           (0xffffffff & (~(IMCW_SW|IMCW_VX)))


#elif defined(_M_M68K)

#include "mac\m68k\trans.a"


/* LATER -- we don't handle exception until Mac OS has better support on it */

#define _except1(flags, op, arg1, res, cw) _errcode(flags), _rstorfp(cw), \
                        _set_statfp(cw),(res)

#define _except2(flags, op, arg1, arg2, res, cw) _errcode(flags), _rstorfp(cw), \
                          _set_statfp(cw),(res)

#define _handle_qnan1(opcode, x, savedcw) _set_errno(_DOMAIN), _rstorfp(savedcw), (x);
#define _handle_qnan2(opcode, x, y, savedcw) _set_errno(_DOMAIN), _rstorfp(savedcw), (x+y);


#elif defined(_M_MPPC)

/* Mac control information - included as part of trans.h
   It is broken out to allow use with ASM68 files*/

/* Control word for computation of transcendentals */



#define ICW        (IPC_64 + IRC_NEAR + IMCW_EM)

#define IMCW      IMCW_RC +  IMCW_PC


#define IMCW_EM         0x000000f8  /* interrupt Exception Masks */
#define IEM_INVALID     0x00000080  /*   invalid */
#define IEM_ZERODIVIDE  0x00000010  /*   zero divide */
#define IEM_OVERFLOW    0x00000040  /*   overflow */
#define IEM_UNDERFLOW   0x00000020  /*   underflow */
#define IEM_INEXACT     0x00000008  /*   inexact (precision) */


#define IMCW_RC 0x00000003          /* Rounding Control */
#define IRC_CHOP        0x00000001  /*   chop */
#define IRC_UP          0x00000002  /*   up */
#define IRC_DOWN        0x00000003  /*   down */
#define IRC_NEAR        0x00000000  /*   near */

#define IMSW            0xffffff00  /* status bits mask */
#define ISW_INVALID     0x20000000  /* invalid */
#define ISW_ZERODIVIDE  0x04000000  /* zero divide */
#define ISW_OVERFLOW    0x10000000  /* overflow */
#define ISW_UNDERFLOW   0x08000000  /* underflow */
#define ISW_INEXACT     0x02000000  /* inexact (precision) */

#define IMCW_PC         0x0000  /* Precision Control */
#define IPC_24          0x0000  /*    24 bits */
#define IPC_53          0x0000  /*    53 bits */
#define IPC_64          0x0000  /*    64 bits */


/* LATER -- we don't handle exception until Mac OS has better support on it */

#define _except1(flags, op, arg1, res, cw) _errcode(flags), \
                        _set_statfp(cw),(res)

#define _except2(flags, op, arg1, arg2, res, cw) _errcode(flags), \
                          _set_statfp(cw),(res)

#define _handle_qnan1(opcode, x, savedcw) _set_errno(_DOMAIN), _rstorfp(savedcw), (x);
#define _handle_qnan2(opcode, x, y, savedcw) _set_errno(_DOMAIN), _rstorfp(savedcw), (x+y);

#endif

#ifndef __assembler /* MIPS ONLY: Protect from assembler */

#define RETURN(fpcw,result) return _rstorfp(fpcw),(result)

#define RETURN_INEXACT1(op,arg1,res,cw)         \
    if (cw & IEM_INEXACT) {             \
        _rstorfp(cw);               \
        return res;                 \
    }                       \
    else {                      \
        return _except1(FP_P, op, arg1, res, cw);   \
    }


#define RETURN_INEXACT2(op,arg1,arg2,res,cw)        \
    if (cw & IEM_INEXACT) {             \
        _rstorfp(cw);               \
        return res;                 \
    }                       \
    else {                      \
        return _except2(FP_P, op, arg1, arg2, res, cw); \
    }


#ifdef _M_ALPHA

//
// Since fp32 is not compiled in IEEE exception mode perform Alpha NaN
// propagation in software to avoid hardware/kernel trap involvement.
//

extern double _nan2qnan(double);

#define _d_snan2(x,y)   _nan2qnan(y)
#define _s2qnan(x)  _nan2qnan(x)

#else
//handle NaN propagation
#define _d_snan2(x,y)   ((x)+(y))
#define _s2qnan(x)  ((x)+1.0)
#endif


#define _maskfp() _ctrlfp(ICW, IMCW)
#ifdef  _M_ALPHA
#define _rstorfp(cw) 0
#else
#define _rstorfp(cw) _ctrlfp(cw, IMCW)
#endif


#define ABS(x) ((x)<0 ? -(x) : (x) )


int _d_inttype(double);

#endif  /* #ifndef __assembler */

#define _D_NOINT 0
#define _D_ODD 1
#define _D_EVEN 2


// IEEE exceptions
#define FP_O         0x01
#define FP_U         0x02
#define FP_Z         0x04
#define FP_I         0x08
#define FP_P         0x10

// An extra flag for matherr support
// Set together with FP_I from trig functions when the argument is too large
#define FP_TLOSS     0x20


#ifndef __assembler /* MIPS ONLY: Protect from assembler */
#ifdef B_END
#define SET_DBL(msw, lsw)     msw, lsw
#else
#define SET_DBL(msw, lsw)     lsw, msw
#endif
#endif  /* #ifndef __assembler */


// special types
#define T_PINF  1
#define T_NINF  2
#define T_QNAN  3
#define T_SNAN  4


// exponent adjustment for IEEE overflow/underflow exceptions
// used before passing the result to the trap handler

#define IEEE_ADJUST 1536

// QNAN values

#define INT_NAN     (~0)

#define QNAN_SQRT   D_IND
#define QNAN_LOG    D_IND
#define QNAN_LOG10  D_IND
#define QNAN_POW    D_IND
#define QNAN_SINH   D_IND
#define QNAN_COSH   D_IND
#define QNAN_TANH   D_IND
#define QNAN_SIN1   D_IND
#define QNAN_SIN2   D_IND
#define QNAN_COS1   D_IND
#define QNAN_COS2   D_IND
#define QNAN_TAN1   D_IND
#define QNAN_TAN2   D_IND
#define QNAN_ACOS   D_IND
#define QNAN_ASIN   D_IND
#define QNAN_ATAN2  D_IND
#define QNAN_CEIL   D_IND
#define QNAN_FLOOR  D_IND
#define QNAN_MODF   D_IND
#define QNAN_LDEXP  D_IND
#define QNAN_FMOD   D_IND
#define QNAN_FREXP  D_IND


/*
 * Function prototypes
 */

#ifndef __assembler /* MIPS ONLY: Protect from assembler */

double _set_exp(double x, int exp);
double _set_bexp(double x, int exp);
double _add_exp(double x, int exp);
double _frnd(double);
double _fsqrt(double);
#if !defined(_M_M68K) && !defined(_M_MPPC)
double _except1(int flags, int opcode, double arg, double res, unsigned int cw);
double _except2(int flags, int opcode, double arg1, double arg2, double res, unsigned int cw);
#endif
int _sptype(double);
int _get_exp(double);
double _decomp(double, int *);
int _powhlp(double x, double y, double * result);
extern unsigned int _fpstatus;
double _frnd(double);
double _exphlp(double, int *);
#if !defined(_M_M68K) && !defined(_M_MPPC)
double _handle_qnan1(unsigned int op, double arg, unsigned int cw);
double _handle_qnan2(unsigned int op,double arg1,double arg2,unsigned int cw);
#endif
unsigned int _clhwfp(void);
unsigned int _setfpcw(unsigned int);
int _errcode(unsigned int flags);
void _set_errno(int matherrtype);
int _handle_exc(unsigned int flags, double * presult, unsigned int cw);
unsigned int _clrfp(void);
unsigned int _ctrlfp(unsigned int,unsigned int);
unsigned int _statfp(void);
void _set_statfp(unsigned int);

#endif  /* #ifndef __assembler */

#ifdef __cplusplus
}
#endif

#define _INC_TRANS
#endif  /* _INC_TRANS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\tan.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    tan.c

Abstract:
    
    This module implement tan function used in the wow64 mscpu.
    
Author:


Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/

#include <math.h>
#include <trans.h>

/* constants */
static double const TWO_OVER_PI = 0.63661977236758134308;
static double const EPS  = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const YMAX = 2.98156826864790199324e8; /* 2^(53/2)*PI/2 */

//
// The sum of C1 and C2 is a representation of PI/2 with 66 bits in the
// significand (same as x87). (PI/2 = 2 * 0.c90fdaa2 2168c234 c h)
//

static _dbl _C1  = {SET_DBL (0x3ff921fb, 0x54400000)};
static _dbl _C2  = {SET_DBL (0x3dd0b461, 0x1a600000)};
#define C1  (_C1.dbl)
#define C2  (_C2.dbl)

/* constants for the rational approximation */
/* p0 = 1.0  is not used (avoid mult by 1) */
static double const p1 = -0.13338350006421960681e+0;
static double const p2 =  0.34248878235890589960e-2;
static double const p3 = -0.17861707342254426711e-4;
static double const q0 =  0.10000000000000000000e+1;
static double const q1 = -0.46671683339755294240e+0;
static double const q2 =  0.25663832289440112864e-1;
static double const q3 = -0.31181531907010027307e-3;
static double const q4 =  0.49819433993786512270e-6;


#define Q(g)   ((((q4 * (g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define P(g,f)  (((p3 * (g) + p2) * (g) + p1) * (g) * (f) + (f))

#define ISODD(i) ((i)&0x1)


/***
*double tan(double x) - tangent
*
*Purpose:
*   Compute the tangent of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I, U
*   if x is denormal: raise underflow
*******************************************************************************/
double Proxytan(double x)
{
    unsigned int savedcw;
    unsigned long n;
    double xn,xnum,xden;
    double f,g,result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
    switch(_sptype(x)) {
    case T_PINF:
    case T_NINF:
        return _except1(FP_I,OP_TAN,x,QNAN_TAN1,savedcw);
    case T_QNAN:
        return _handle_qnan1(OP_TAN, x, savedcw);
    default: //T_SNAN
        return _except1(FP_I,OP_TAN,x,_s2qnan(x),savedcw);
    }
    }

    if (x == 0.0)
    RETURN(savedcw, x);

    if (ABS(x) > YMAX) {

    // The argument is too large to produce a meaningful result,
    // so this is treated as an invalid operation.
    // We also set the (extra) FP_TLOSS flag for matherr
    // support

    return _except1(FP_TLOSS | FP_I,OP_TAN,x,QNAN_TAN2,savedcw);
    }

    xn = _frnd(x * TWO_OVER_PI);
    n = (unsigned long) fabs(xn);


    /* assume there is a guard digit for addition */
    f = (x - xn * C1) - xn * C2;
    if (ABS(f) < EPS) {
    xnum = f;
    xden = 1;
    if (IS_D_DENORM(f)) {
        return _except1(FP_U | FP_P,OP_TAN,x,_add_exp(f, IEEE_ADJUST),savedcw);
    }
    }
    else {
    g = f*f;
    xnum = P(g,f);
    xden = Q(g);
    }

    if (ISODD(n)) {
    xnum = -xnum;
    result = xden/xnum;
    }
    else
    result = xnum/xden;

    RETURN_INEXACT1(OP_TAN,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\mscpu\math\axp64\frnd.s ===
//      TITLE("Floating Point Round")
//++
//
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    frnd.s
//
// Abstract:
//
//    This module implements the floating round to integer function.
//
// Author:
//
//    Thomas Van Baak (tvb) 07-Sep-1992
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Floating Round to Integer")
//++
//
// DOUBLE
// _frnd (
//    IN DOUBLE x
//    )
//
// Routine Description:
//
//    This function rounds the given finite floating point argument to
//    an integer using nearest rounding.
//
// Arguments:
//
//    x (f16) - Supplies the floating point value to be rounded.
//
// Return Value:
//
//    The integer rounded floating point value is returned in f0.
//
// Implementation Notes:
//
//--

        LEAF_ENTRY(_frnd)

//
// If the absolute value of the argument is greater than or equal to 2^52,
// then the argument is already an integer and it can be returned as the
// function value. Note that 2^52 - 1 is the largest integer representable
// by T-format (double) floating point because the mantissa (without the
// hidden bit) is 52 bits wide.
//

        fbeq    f16, 10f                // return if argument is 0.0
        ldt     f10, Two52              // get 2^52 magic constant
        fabs    f16, f11                // get absolute value of argument
        cmptlt  f10, f11, f12           // is 2^52 < arg?
        fbeq    f12, 20f                // if eq[false], then do rounding

10:     cpys    f16, f16, f0            // argument is return value
        ret     zero, (ra)              // return

20:     cpys    f16, f10, f10           // if argument < 0, use -2^52 instead
        addt    f16, f10, f0            // add [+-]2^52 (nearest rounding)
        subt    f0, f10, f0             // subtract [+-]2^52 (nearest rounding)
        ret     zero, (ra)              // return

        .end    _frnd

//
// Define floating point constants.
//
// (avoid ldit with floating point literal due to bug in acc/as that
//  creates writable .rdata sections - tvb)
//

        .align  3
        .rdata
Two52:
        .double 4503599627370496.0      // 2^52
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\ntvdm64\ntvdm64.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ntvdm64.c

Abstract:

    Support for 16-bit process thunking on NT64

Author:

    12-Jan-1999 PeterHal

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wow64t.h>
#include <shlobj.h>
#include <stdio.h>


#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))

#if DBG
#define DEBUG_PRINT(args) DbgPrint args
#else
#define DEBUG_PRINT(args)
#endif

typedef struct {
    LPCWSTR Name;
    LPCWSTR Version;
    LPCWSTR ProdName;
    LPCWSTR CmdLine;
    LPCWSTR MappedExe;
} NTVDM64_ENTRY;
typedef CONST NTVDM64_ENTRY *PNTVDM64_ENTRY;

CONST NTVDM64_ENTRY NtVdm64Entries[] = {
    {L"ACMSETUP301", L"3.01", L"Microsoft Setup for Windows", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP30",  L"3.0",  L"Microsoft Setup for Windows", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP26",  L"2.6",  L"Microsoft Setup for Windows", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP12",  L"1.2",  L"Microsoft Setup for Windows", L"-m \"%m\" %c", L"setup16.exe"},
    {L"INSTALLSHIELD5", L"5*", L"InstallShield*", L"-isw64\"%m\" %c", L"InstallShield\\setup.exe"}
};

#if !_WIN64
CONST int CsidlList[] = {
    CSIDL_COMMON_STARTMENU,
    CSIDL_COMMON_PROGRAMS,
    CSIDL_COMMON_STARTUP,
    CSIDL_COMMON_DESKTOPDIRECTORY,
    CSIDL_COMMON_APPDATA,
    CSIDL_COMMON_TEMPLATES,
    CSIDL_COMMON_DOCUMENTS,
    CSIDL_COMMON_ADMINTOOLS,
    CSIDL_COMMON_FAVORITES
};
#endif

LONG
CreateNtvdm64Entry(
    HKEY hKeyVdm,
    PNTVDM64_ENTRY Entry
    )
/*++

Routine Description:

    Write a registry entry for a single entry in the table

Arguments:

    hKeyVdm     - key to write the entry to
    Entry       - the entry to write

Return Value:

    LONG - a return code from a Registry API, 0 for success

--*/
{
    LONG l;
    HKEY h;
    WCHAR Path[MAX_PATH];

    if (!GetSystemWindowsDirectoryW(Path, sizeof(Path)/sizeof(Path[0]))) {
            return 1;
    }

    if ((lstrlenW(Path) + (sizeof (L"\\" WOW64_SYSTEM_DIRECTORY_U L"\\") / sizeof(WCHAR))) >= (sizeof(Path)/sizeof(Path[0]))) {
        return 1;
    }

    wcscat(Path, L"\\" WOW64_SYSTEM_DIRECTORY_U L"\\");

    if ((lstrlenW(Path) + lstrlenW(Entry->MappedExe)) >= (sizeof(Path)/sizeof(Path[0]))) {
        return 1;
    }

    wcscat(Path, Entry->MappedExe);

    l = RegCreateKeyW(hKeyVdm, Entry->Name, &h);
    if (l) {
        return l;
    }

    l = RegSetValueExW(h, L"CommandLine", 0, REG_SZ, (BYTE *)Entry->CmdLine, (wcslen(Entry->CmdLine)+1)*sizeof(WCHAR));
    if (l) {
        return l;
    }
    l = RegSetValueExW(h, L"ProductName", 0, REG_SZ, (BYTE *)Entry->ProdName, (wcslen(Entry->ProdName)+1)*sizeof(WCHAR));
    if (l) {
        return l;
    }
    l = RegSetValueExW(h, L"ProductVersion", 0, REG_SZ, (BYTE *)Entry->Version, (wcslen(Entry->Version)+1)*sizeof(WCHAR));
    if (l) {
        return l;
    }
    l = RegSetValueExW(h, L"MappedExeName", 0, REG_SZ, (BYTE *)Path, (wcslen(Path)+1)*sizeof(WCHAR));
    return l;
}

STDAPI
DllInstall(
    BOOL bInstall,
    LPCWSTR pszCmdLine
    )
/*++

Routine Description:

    Routine called during guimode setup to register ntvdm64.dll

Arguments:

    bInstall    - TRUE if registering, FALSE if unregistering
    pszCmdLine  - command-line

Return Value:

    HRESULT

--*/
{
    HKEY hKeyVdm;
    LONG l;
    SIZE_T i;
    WCHAR Path[MAX_PATH];
    BOOL bResult;

    UNREFERENCED_PARAMETER(pszCmdLine);

    if (!bInstall) {
        // There is no uninstall for ntvdm64
        return NOERROR;
    }

    l = RegCreateKeyW(HKEY_LOCAL_MACHINE,
                      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\NtVdm64",
                      &hKeyVdm);
    if (l) {
        return E_FAIL;
    }
    for (i=0; i<ARRAYSIZE(NtVdm64Entries); ++i) {
        l = CreateNtvdm64Entry(hKeyVdm, &NtVdm64Entries[i]);
        if (l) {
            break;
        }
    }
    RegCloseKey(hKeyVdm);
    if (l) {
        return E_FAIL;
    }

#if !_WIN64
    //
    // Call shell32, asking for some common CSIDL_ values.  This forces
    // shell32 to create values under HKLM\Software\Microsoft\Windows\
    // Explorere\Shell Folders.  Some apps (VB, VC, MSDN) expect these
    // values to be present in the registry, but they are created on-demand
    // as a side-effect of calling the shell APIs to query for them.  On x86
    // NT, guimode setup itself calls shell32 several times, while creating
    // the Start Menu, etc. so several values are always present when apps
    // run for the first time.
    //
    for (i=0; i<sizeof(CsidlList)/sizeof(CsidlList[0]); ++i) {
        bResult = SHGetSpecialFolderPathW(NULL, Path, CsidlList[i], TRUE);
        if (!bResult) {
            return E_FAIL;
        }
    }
#endif

    return NOERROR;
}



//-----------------------------------------------------------------------
// This section is ripped off from mvdm\wow32\wkman.c

//
// MyVerQueryValue checks several popular code page values for the given
// string.  This may need to be extended ala WinFile's wfdlgs2.c to search
// the translation table.  For now we only need a few.
//

BOOL
MyVerQueryValue(
    const LPVOID pBlock,
    LPWSTR lpName,
    LPVOID * lplpBuffer,
    PUINT puLen
    )
{
    DWORD dwDefaultLanguage[] = {0x04E40409, 0x00000409};
    WCHAR szSubBlock[128];
    PDWORD pdwTranslation;
    DWORD uLen;
    BOOL fRet;
    int i;


    if(!VerQueryValue(pBlock, "\\VarFileInfo\\Translation", (PVOID*)&pdwTranslation, &uLen)) {

        pdwTranslation = dwDefaultLanguage;
        uLen = sizeof (dwDefaultLanguage);
    }

    fRet = FALSE;
    while ((uLen > 0) && !fRet) {

        swprintf(szSubBlock, L"\\StringFileInfo\\%04X%04X\\%ws",
                 LOWORD(*pdwTranslation),
                 HIWORD(*pdwTranslation),
                 lpName);

        fRet = VerQueryValueW(pBlock, szSubBlock, lplpBuffer, puLen);


        pdwTranslation++;
        uLen -= sizeof (DWORD);
    }

    if (!fRet) {
        DEBUG_PRINT(("NtVdm64: Failed to get resource %ws.\n", lpName));
    }

    return fRet;
}


//
// Utility routine to fetch the Product Name and Product Version strings
// from a given EXE.
//

BOOL
WowGetProductNameVersion(
    LPCWSTR pszExePath,
    LPWSTR pszProductName,
    DWORD cbProductName,
    LPWSTR pszProductVersion,
    DWORD cbProductVersion
    )
{
    DWORD dwZeroMePlease;
    DWORD cbVerInfo;
    LPVOID lpVerInfo = NULL;
    LPWSTR pName;
    DWORD cbName;
    LPWSTR pVersion;
    DWORD cbVersion;

    *pszProductName = 0;
    *pszProductVersion = 0;

    cbVerInfo = GetFileVersionInfoSizeW((LPWSTR)pszExePath, &dwZeroMePlease);
    if (!cbVerInfo) {
        return TRUE;
    }

    lpVerInfo = RtlAllocateHeap( RtlProcessHeap(), 0, (cbVerInfo));
    if (!lpVerInfo) {
        DEBUG_PRINT(("NtVdm64: Failed to allocate version info.\n"));
        return FALSE;
    }

    if (!GetFileVersionInfoW((LPWSTR)pszExePath, 0, cbVerInfo, lpVerInfo)) {
        DEBUG_PRINT(("NtVdm64: Failed to get version info. GLE %x\n", GetLastError()));
        return FALSE;
    }

    if (MyVerQueryValue(lpVerInfo, L"ProductName", &pName, &cbName)) {
        if (cbName <= cbProductName) {
            wcscpy(pszProductName, pName);
        } else {
            DEBUG_PRINT(("NtVdm64: ProductName resource too large %ws. Size %x\n", pName, cbName));
        }
    }

    if (MyVerQueryValue(lpVerInfo, L"ProductVersion", &pVersion, &cbVersion)) {
        if (cbVersion <= cbProductVersion) {
            wcscpy(pszProductVersion, pVersion);
        } else {
            DEBUG_PRINT(("NtVdm64: ProductVersion resource too large %ws. Size %x\n", pVersion, cbVersion));
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, lpVerInfo);

    return TRUE;
}

//-----------------------------------------------------------------------

BOOL
MapCommandLine(
    HKEY hkeyMapping,
    LPCWSTR lpWin16ApplicationName,
    LPCWSTR lpMappedApplicationName,
    BOOL    fPrefixMappedApplicationName,
    LPCWSTR lpCommandLine,
    LPWSTR *lplpMappedCommandLine
    )
/*++

Routine Description:

    Maps the command line for a Win16 application.

Arguments:

    hkeyMapping - open registry keyfor the mapping entry
    lpWin16ApplicationName - Win16 file name (with path)
    lpMappedApplicationName - the ported version
               of lpWin16ApplicationName
    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpAPplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpCommandLine - see comment for fPrefixMappedApplicationName.
    lplpMappedCommandLine - returns the mapped command line
               caller must free the returned pointer using RtlFreeHeap

Return Value:

    TRUE if the mapping was successful

--*/
{
    WCHAR achBuffer[MAX_PATH+1];
    DWORD dwBufferLength;
    DWORD dwType;
    LPWSTR lpsz;
    LPWSTR lpMappedCommandLine;
    DWORD dwRequiredBufferLength;
    LONG result;
    LPCWSTR lpOriginalCommandLine;

    // set default command line to empty string
    if (NULL == lpCommandLine) {
        lpCommandLine = L"";
    }
    lpOriginalCommandLine = lpCommandLine;

    // get the command line map from the registry
    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"CommandLine", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result || dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: CommandLine failed to get REG_SZ value. Result %x Type %x\n", result, dwType));
        return FALSE;
    }

    // calculate mapped buffer size and allocate it
    dwRequiredBufferLength = 1;
    if (fPrefixMappedApplicationName) {
        dwRequiredBufferLength += wcslen(lpMappedApplicationName) + 1;
    } else {
        while (*lpCommandLine && *lpCommandLine != L' ') {
            dwRequiredBufferLength++;
            lpCommandLine++;
        }
        // consume any extra spaces
        while (*lpCommandLine == L' ') {
            lpCommandLine++;
        }
        // account for one space in the output buffer
        dwRequiredBufferLength++;
    }
    lpsz = achBuffer;
    while (*lpsz) {
        if (*lpsz == L'%') {
            lpsz += 1;
            switch (*lpsz) {

            // %c : Insert Original Command Line
            case L'c':
            case L'C':
                lpsz += 1;
                dwRequiredBufferLength += wcslen(lpCommandLine);
                break;

            // %m : Insert Original Module Name
            case L'm':
            case L'M':
                lpsz += 1;
                dwRequiredBufferLength += wcslen(lpWin16ApplicationName);
                break;

            // %% : Insert a real %
            case L'%':
                lpsz += 1;
                dwRequiredBufferLength += 1;
                break;

            // %\0 : eat terminating %\0
            case 0:
                DEBUG_PRINT(("NtVdm64: ignoring trailing %% in CommandLine.\n"));
                break;

            // %x : undefined macro expands to nothing
            default:
                DEBUG_PRINT(("NtVdm64: ignoring unknown macro %%%wc in CommandLine.\n", *lpsz));
                lpsz += 1;
                break;
            }
        } else {
            lpsz += 1;
            dwRequiredBufferLength += 1;
        }
    }
    *lplpMappedCommandLine = RtlAllocateHeap(RtlProcessHeap(), 0, dwRequiredBufferLength * sizeof (WCHAR));
    if (!*lplpMappedCommandLine) {
        DEBUG_PRINT(("NtVdm64: failed to allocate CommandLine. GLE %x.\n", GetLastError()));
        return FALSE;
    }

    // map the buffer
    lpCommandLine = lpOriginalCommandLine;
    lpsz = achBuffer;
    lpMappedCommandLine = *lplpMappedCommandLine;
    if (fPrefixMappedApplicationName) {
        wcscpy(lpMappedCommandLine, lpMappedApplicationName);
        lpMappedCommandLine += wcslen(lpMappedApplicationName);
        *lpMappedCommandLine = L' ';
        lpMappedCommandLine += 1;
    } else {
        // copy in the first whitespace-delimited part of the old
        // command-line as it is the name of the app.
        while (*lpCommandLine && *lpCommandLine != L' ') {
            *lpMappedCommandLine = *lpCommandLine;
            lpMappedCommandLine++;
            lpCommandLine++;
        }
        // add in a space of padding and skip over any spaces in the
        // original command line
        *lpMappedCommandLine++ = L' ';
        while (*lpCommandLine == L' ') {
            lpCommandLine++;
        }
    }
    while (*lpsz) {
        if (*lpsz == L'%') {
            lpsz += 1;
            switch (*lpsz) {

            // %c : Insert Original Command Line
            case L'c':
            case L'C':
                lpsz += 1;
                wcscpy(lpMappedCommandLine, lpCommandLine);
                lpMappedCommandLine += wcslen(lpCommandLine);
                break;

            // %m : Insert Original Module Name
            case L'm':
            case L'M':
                lpsz += 1;
                wcscpy(lpMappedCommandLine, lpWin16ApplicationName);
                lpMappedCommandLine += wcslen(lpWin16ApplicationName);
                break;

            // %% : Insert a real %
            case L'%':
                lpsz += 1;
                *lpMappedCommandLine = L'%';
                lpMappedCommandLine += 1;
                break;

            // %\0 : eat terminating %\0
            case 0:
                break;

            // %x : undefined macro expands to nothing
            default:
                lpsz += 1;
                break;
            }
        } else {
            *lpMappedCommandLine = *lpsz;
            lpMappedCommandLine += 1;
            lpsz += 1;
        }
    }
    *lpMappedCommandLine = L'\0';

    return TRUE;
}

int
CompareStrings(
    LPWSTR  lpRegString,
    LPCWSTR lpExeString
    )
/*++

Routine Description:

    Compares strings using a minimal wildcard support in addition
    to just a stock wcscmp.  The RegString can have an optional '*'
    which is used as a wildcard that matches any characters upto the
    end of the string.

Arguments:

    lpRegString - string loaded from the registry
    lpExeString - string loaded from the app's resource section

Return Value:

    same as wcscmp: 0 for equal, nonzero non-equal

--*/
{
    LPCWSTR pRegStar;

    if (wcscmp(lpRegString, lpExeString) == 0) {
        // an exact match
        return 0;
    }
    // not an exact match - see if the registry key contains a wildcard
    pRegStar = wcschr(lpRegString, L'*');
    if (!pRegStar) {
        // No wildcard in the registry key, so no match
        return -1;
    }
    if (pRegStar == lpRegString) {
        // Wildcard is the first character - match everything
        return 0;
    }
    // Compare only upto the character before the '*'
    return wcsncmp(lpRegString, lpExeString,
                   pRegStar - lpRegString);
}

BOOL
CheckMapArguments(
    HKEY hkeyMapping,
    LPCWSTR lpApplicationName,
    LPCWSTR lpProductName,
    LPCWSTR lpProductVersion,
    LPWSTR  lpMappedApplicationName,
    DWORD   dwMappedApplicationNameSize,
    BOOL    fPrefixMappedApplicationName,
    LPCWSTR lpCommandLine,
    LPWSTR *lplpMappedCommandLine
    )
/*++

Routine Description:

    Attempts to map a Win16 application and command line to their ported version
    using a single entry in the NtVdm64 mapping in the registry.

Arguments:

    hkeyMapping - open registry keyfor the mapping entry
    lpApplicationName - Win16 file name (with path)
    lpExeName - Win16 file name wihtout path
    lpProductName - value of ProductName Version resource of lpApplicationName
    lpProductVersion - value of ProductVersion version resource of lpApplicationName
    lpMappedApplicationName - returns the name of the ported version
               of lpApplicationName
    dwMappedApplicationNameSize - size of lpMappedApplicationName buffer
    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpAPplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpCommandLine - see comment for fPrefixMappedApplicationName.
    lplpMappedCommandLine - returns the mapped command line
               caller must free the returned pointer using RtlFreeHeap

Return Value:

    TRUE if the mapping was successful

--*/
{
    WCHAR achBuffer[MAX_PATH+1];
    DWORD dwBufferLength;
    DWORD dwType;
    LONG result;

    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"ProductName", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result || dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: Failed to open ProductName REG_SZ key. Result %x. Type %x\n", result, dwType));
        return FALSE;
    }
    if (CompareStrings(achBuffer, lpProductName)) {
        DEBUG_PRINT(("NtVdm64: ProductName mismatch %ws vs %ws\n", achBuffer, lpProductName));
        return FALSE;
    }

    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"ProductVersion", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result || dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: Failed to open ProductVersion REG_SZ key. Result %x. Type %x\n", result, dwType));
        return FALSE;
    }
    if (CompareStrings(achBuffer, lpProductVersion)) {
        DEBUG_PRINT(("NtVdm64: ProductVersion mismatch %ws vs %ws\n", achBuffer, lpProductVersion));
        return FALSE;
    }

    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"MappedExeName", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result) {
        DEBUG_PRINT(("NtVdm64: Failed to open MappedExeName REG_SZ key. Result %x.\n", result));
        return FALSE;
    }

    if (dwType == REG_EXPAND_SZ) {
        WCHAR achBuffer2[MAX_PATH+1];
        wcscpy(achBuffer2, achBuffer);
        dwBufferLength = ExpandEnvironmentStringsW(achBuffer2, achBuffer, ARRAYSIZE(achBuffer));
        if (dwBufferLength == 0 || dwBufferLength > ARRAYSIZE(achBuffer)) {
            DEBUG_PRINT(("NtVdm64: MappedExeName failed to expand environment strings in %ws. Length %x\n", achBuffer, dwBufferLength));
            return FALSE;
        }
    } else if (dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: MappedExeName value doesn't have string type. Type %x\n", dwType));
        return FALSE;
    }

    if (dwBufferLength > dwMappedApplicationNameSize) {
        DEBUG_PRINT(("NtVdm64: MappedExeName too long. Length %x\n", dwBufferLength));
        return FALSE;
    }
    wcscpy(lpMappedApplicationName, achBuffer);

    if (!MapCommandLine(hkeyMapping, lpApplicationName, lpMappedApplicationName, fPrefixMappedApplicationName, lpCommandLine, lplpMappedCommandLine)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
MapArguments(
    LPCWSTR lpApplicationName,
    LPWSTR lpMappedApplicationName,
    DWORD dwMappedApplicationNameSize,
    BOOL fPrefixMappedApplicationName,
    LPCWSTR lpCommandLine,
    LPWSTR *lplpMappedCommandLine
    )
/*++

Routine Description:

    Maps a Win16 application and command line to their ported version
    using the NtVdm64 mapping in the registry.

Arguments:

    lpApplicationName - Win16 file name not optional
    lpMappedApplicationName - returns the name of the ported version
               of lpApplicationName
    dwMappedApplicationNameSize - size of lpMappedApplicationName buffer
    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpAPplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpCommandLine - see comment for fPrefixMappedApplicationName.
    lplpMappedCommandLine - returns the mapped command line
               caller must free the returned pointer using RtlFreeHeap

Return Value:

    TRUE if the mapping was successful

--*/
{
    HKEY hkeyMappingRoot;
    LONG result;
    DWORD dwIndex;
    WCHAR achSubKeyName[MAX_PATH+1];
    DWORD dwSubKeyNameLength;
    BOOL mapped;
    WCHAR achExeNameBuffer[MAX_PATH+1];
    LPWSTR lpExeName;
    WCHAR achProductName[MAX_PATH+1];
    WCHAR achProductVersion[MAX_PATH+1];

    //
    // get the .exe name without the preceding path
    //
    if (0 == SearchPathW(
                        NULL,
                        lpApplicationName,
                        (PWSTR)L".exe",
                        MAX_PATH,
                        achExeNameBuffer,
                        &lpExeName
                        )) {
        DEBUG_PRINT(("NtVdm64: SearchPathW failed: %ws\n", lpApplicationName));
        return FALSE;
    }


    if (!WowGetProductNameVersion(lpApplicationName,
                                  achProductName,
                                  ARRAYSIZE(achProductName),
                                  achProductVersion,
                                  ARRAYSIZE(achProductVersion))) {
        return FALSE;
    }

    mapped = FALSE;
    result = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NtVdm64",
                         &hkeyMappingRoot
                         );
    if (ERROR_SUCCESS != result) {
        DEBUG_PRINT(("NtVdm64: Failed to Open NtVdm64 Registry Key : %x\n", result));
        return FALSE;
    }
    dwIndex = 0;

    dwSubKeyNameLength = ARRAYSIZE(achSubKeyName);
    while (!mapped && ERROR_SUCCESS == (result = RegEnumKeyW(hkeyMappingRoot, dwIndex, achSubKeyName, dwSubKeyNameLength))) {

        HKEY hkeyMapping;

        result = RegOpenKeyW(hkeyMappingRoot, achSubKeyName, &hkeyMapping);
        if (ERROR_SUCCESS == result) {
            mapped = CheckMapArguments(hkeyMapping,
                                       lpApplicationName,
                                       achProductName,
                                       achProductVersion,
                                       lpMappedApplicationName,
                                       dwMappedApplicationNameSize,
                                       fPrefixMappedApplicationName,
                                       lpCommandLine,
                                       lplpMappedCommandLine);
            RegCloseKey(hkeyMapping);
        }

        dwSubKeyNameLength = ARRAYSIZE(achSubKeyName);
        dwIndex += 1;
    }

    RegCloseKey(hkeyMappingRoot);

    if ( !mapped )
       DEBUG_PRINT(("NtVdm64: Unknown 16bit app or given parameters are wrong\n"));


    return mapped;
}

extern
BOOL STDAPICALLTYPE ApphelpCheckExe(
    LPCWSTR lpApplicationName,
    BOOL    bApphelp,
    BOOL    bShim,
    BOOL    bUseModuleName);

BOOL
CheckAppCompat(
    LPCWSTR lpApplicationName
    )
/*++
    Check application compatibility database for blocked application,
    possibly show UI advising user of a problem
--*/
{


    return ApphelpCheckExe(lpApplicationName,
                           TRUE,
                           FALSE,
                           FALSE);
}

BOOL
WINAPI
NtVdm64CreateProcess(
    BOOL fPrefixMappedApplicationName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
/*++

Routine Description:

    Checks if there is a ported version of the Win16 lpApplicationName and
    if so creates a process with the ported version.

Arguments:

    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpAPplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpApplicationName - Win16 file name not optional
    lpCommandLine - see comment for fPrefixMappedApplicationName.

    other arguments are identical to CreateProcessW.

Return Value:

    Same as CreateProcessW

--*/
{
    WCHAR achMappedApplicationName[MAX_PATH+1];
    LPWSTR lpMappedCommandLine;
    BOOL Result;

    ASSERT(lpApplicationName);

    //
    // check appcompat
    //
    if (!CheckAppCompat(lpApplicationName)) {
        SetLastError(ERROR_CANCELLED);
        return FALSE;
    }


    if (lpCommandLine == NULL) {
        lpCommandLine = L"";
    }

    lpMappedCommandLine = NULL;
    Result = MapArguments(lpApplicationName,
                          achMappedApplicationName,
                          ARRAYSIZE(achMappedApplicationName),
                          fPrefixMappedApplicationName,
                          lpCommandLine,
                          &lpMappedCommandLine);

    if (Result) {
        Result = CreateProcessW((fPrefixMappedApplicationName ?
                                    NULL :
                                    achMappedApplicationName),
                                lpMappedCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
        if (lpMappedCommandLine) {
            RtlFreeHeap(RtlProcessHeap(), 0, lpMappedCommandLine);
        }
    } else {
        SetLastError(ERROR_BAD_EXE_FORMAT);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\regmisc.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    regmisc.c

Abstract:

    This module implement some function used in the registry redirector.

Author:

    ATM Shafiqul Khalid (askhalid) 29-Oct-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>

#include "regremap.h"
#include "wow64reg.h"
#include "wow64reg\reflectr.h"


#ifdef _WOW64DLLAPI_
#include "wow64.h"
#else
#define ERRORLOG 1  //this one is completely dummy
#define LOGPRINT(x)
#define WOWASSERT(p)
#endif //_WOW64DLLAPI_


#include "regremap.h"
#include "wow64reg.h"

ASSERTNAME;

//#define LOG_REGISTRY
const WCHAR IsnNodeListPath[]={WOW64_REGISTRY_SETUP_KEY_NAME};

#define KEY_NAME(x) {x,((sizeof (x) / sizeof (WCHAR))-1)}

typedef struct _REGKEY_LIST {
    WCHAR KeyPath[256];
    DWORD Len;
} REGKEY_LIST;


//
// Table that will have the list of ISN node. Need to allocate runtime.
//

#define WOW64_ISN_NODE_MAX_NUM 12  // this is internal to wow64 setup might use different size of table
NODETYPE IsnNode[WOW64_ISN_NODE_MAX_NUM]={
    {L"\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES"},
    {L"\\REGISTRY\\MACHINE\\SOFTWARE"},
    {L"\\REGISTRY\\USER\\*\\SOFTWARE\\CLASSES"},  // ISN node table is always upcase.
    {L"\\REGISTRY\\USER\\*_CLASSES"},
    {L"\\REGISTRY\\MACHINE\\SYSTEM\\TEST"},
    {L""}
    };

//
// 64bit IE load mail client dll inproc breaking interop functionality.
// The are some Dll get loaded Inproc {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Clients\\mail"}, //Email Client Key 
//
// Must keep 32-bit and 64-bit uninstall keys separate to ensure the correct environment
// variables are used for REG_EXPAND_SZ and to make sure we run the correct bitness of rundll32.exe.
// {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UnInstall"},    // UnInstall Key
//

REGKEY_LIST ExemptRedirectedKey[]={
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\SystemCertificates"),    // Certificate Key
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Services"),    // Cryptography Service
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\HCP"),    // HelpCenter Key
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\EnterpriseCertificates"),    // Enterprise Service
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\MSMQ"),    //  MSMQ registry 
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),    //  Profiles
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"), // Performance counters
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Print"), // Spooler Printers
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Ports"), // Spooler Ports
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Policies"),       // policie keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies"), //Policy Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager"), //OC Manager Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Software\\Microsoft\\Shared Tools\\MSInfo"), //share MSinfo Key
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"), //Share setup Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\CTF\\TIP"), //CTF\TIP Key
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\CTF\\SystemShared"),
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"), //Share fonts
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\RAS"),    //  RAS keys need to be shared
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Driver Signing"),    //  Share Driver signing Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Non-Driver Signing"),    //  Share Driver signing Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Calais\\Current"), // SmartCard subsytem pipe name
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers"), // SmartCard installed readers
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"), // Share time zone key
    KEY_NAME(L""), // Two additional NULL String for additional space. 
    KEY_NAME(L"")
    };
//
// A note about PerfLib... in ntos\config, the init code creates a special
// key called PerfLib\009 and if you call NtOpenKey on that path, it returns
// back HKEY_PERFORMANCE_DATA, not a regular kernel registry handle to
// \\REGISTRY\\MACHINE\\stuff.  Instead, HKEY_PERFORMANCE_DATA is intercepted
// in usermode by advapi32.dll.  The Counters and Help REG_MULTI_SZ values
// don't really exist - they are synthesized by advapi32 based on the
// contents of the perf*.dat files in system32.  This works OK for 32-bit
// advapi32 on WOW64 as advapi opens the *.dat files using NtOpenFile
// with an OBJECT_ATTRIBUTES containing "\SystemRoot\System32\..." which
// doesn't get intercepted by the system32 remapper.
//

PWCHAR
wcsistr(
    PWCHAR string1,
    PWCHAR string2
    )
{
    PWCHAR p1;
    PWCHAR p2;

    if ((NULL == string2) || (NULL == string1))
    {
        // do whatever wcsstr would do
        return wcsstr(string1, string2);
    }

    

    while (*string1)
    {
        for (p1 = string1, p2 = string2;
             *p1 && *p2 && towlower(*p1) == towlower(*p2);
             ++p1, ++p2)
        {
            // nothing
        }

        if (!*p2) 
        {
            // we found a match!
            return (PWCHAR)string1;   // cast away const!
        }

        ++string1;
    }

    return NULL;
}

PWCHAR
wcsstrWow6432Node (
    PWCHAR pSrc
    )
{
    
    return  wcsistr (pSrc, NODE_NAME_32BIT);
    
}

PWCHAR
wcsstrWithWildCard (
    PWCHAR srcStr,
    PWCHAR destIsnNode
    )
/*++

Routine Description:

    a customised version of wcsstr with wild card support. For example the
    substring might have '*' character which can be matched with any key name.

Arguments:

    srcStr - The string where the substring need to be searched for.
    destIsnNode - the string to search.

Return Value:

    TRUE if the operation succeed, FALSE otherwise.
--*/


{
    //multiple wildcard isn't allowed?

    PWCHAR src = srcStr;
    PWCHAR dest = destIsnNode;

    PWCHAR p, t;
    DWORD count;

    for (;;) {

        if (*dest == UNICODE_NULL)
            return ( *src == UNICODE_NULL)? src : src+1;  //source might point to SLASH

        if (*src == UNICODE_NULL)
            return NULL;

        count = wcslen (dest);
        if ( ( p = wcschr( dest,'*') ) == NULL ) {
            if ( _wcsnicmp (src, dest, count) == 0 ){

                //
                // xx\Test shouldn't show xx\test345 as an ISN node.
                //
                if ( src [ count ] != UNICODE_NULL && src [ count ] != L'\\' ) //terminator need tobe NULL or slash
                    return NULL;

                return  (*(src+count) != UNICODE_NULL ) ? src+count+1: src+count; // xx\test return pointer at test if dest is xx.
            }
            else
                return NULL;
        }

        count = (DWORD) (p-dest);
       // LOGPRINT( (ERRORLOG, "\nFinding [%S] withing %S, p=%S Val%d",dest, src, p, count ));


        if (_wcsnicmp (src, dest, count) !=0)  // checking the initial state
            return NULL;

        //
        // need to check *_Classes type ISN Node
        //
        p++;  //skip the wild card
        t=src+count;
        while ( *t != L'\\' && *t != UNICODE_NULL )
            t++;

        if ( *p != UNICODE_NULL || *p != L'\\') { //*_Classes form
            for ( count=0;*p != L'\\' && *p != UNICODE_NULL; p++, count++)
                ;
            if (_wcsnicmp (p-count, t-count, count) != 0)
                return NULL;
        }

      //  LOGPRINT( (ERRORLOG, "\nFinding 2nd[%S] withing %S, p=%S",dest, src, p ));
        src = t;
        dest = p;
    }

    return NULL;
}

HKEY
OpenNode (
    PWCHAR NodeName
    )
/*++

Routine Description:

    Open a given key for generic access.

Arguments:

    NodeName - name of the key to check.

Return Value:

    NULL in case of failure.
    Valid handle otherwise.
--*/

{
    NTSTATUS st;
    HKEY  hKey;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;


    RtlInitUnicodeString (&KeyName, NodeName);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    st = NtOpenKey (&hKey, KEY_ALL_ACCESS, &Obja);

    if (!NT_SUCCESS(st))
        return NULL;

    return hKey;
}

VOID
CloseNode (
HANDLE Key
)
{
    NtClose (Key);
}

NTSTATUS
IsNodeExist (
    PWCHAR NodeName
    )
/*++

Routine Description:

    Check if the given key exist if not create the key.

Arguments:

    NodeName - name of the key to check.

Return Value:

    TRUE if the operation succeed, FALSE otherwise.
--*/

{

    NTSTATUS st;
    HANDLE  hKey;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;


    RtlInitUnicodeString (&KeyName, NodeName);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    st = NtOpenKey (&hKey, KEY_READ, &Obja);

    if (!NT_SUCCESS(st))
        return st;

    NtClose (hKey);
    //LOGPRINT( (ERRORLOG, "\nValid IsnNode [%S]",NodeName ));
    return st;

}

BOOL
CreateNode (
    PWCHAR Path
    )
/*++

Routine Description:

    Create all the node along the path if missing. Called by background
    thread working on the setup.

Arguments:

    Path - name of path to the key.

Return Value:

    TRUE if the operation succeed, FALSE otherwise.
--*/

{
    //
    // isolate individual nodes and backtrack
    //
    NTSTATUS st;
    HANDLE  hKey;
    HANDLE  hKeyCreate;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    PWCHAR pTrace;
    PWCHAR p;


    pTrace = Path+wcslen (Path); //pTrace point at the end of path
    p=pTrace;

    for (;;) {
        RtlInitUnicodeString (&KeyName, Path);
        InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

        st = NtOpenKey (&hKey, KEY_WRITE | KEY_READ, &Obja);

        if ( st == STATUS_OBJECT_NAME_NOT_FOUND ) {
            //backtrack until you hit the line
            while ( *p != L'\\' && p!= Path)
                p--;

            //LOGPRINT( (ERRORLOG, "\nTest Code[%S]",p ));
            if ( p == Path ) break;
            *p = UNICODE_NULL;
            continue;
        }

        break;
    }

    if (!NT_SUCCESS(st)) {
        //fixup the string and return
        for ( ;p != pTrace;p++ )
            if ( *p == UNICODE_NULL) *p=L'\\';

        return FALSE;
    }

    //
    // now create key from point p until p hit pTrace
    //

    while ( p != pTrace ) {

        *p = L'\\'; //added the char back
        p++; //p will point a non NULL string

        RtlInitUnicodeString (&KeyName, p);
        InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, hKey, NULL );

        st = NtCreateKey(
                        &hKeyCreate,
                        KEY_WRITE | KEY_READ,
                        &Obja,
                        0,
                        NULL ,
                        REG_OPTION_NON_VOLATILE,
                        NULL
                        );

        if (!NT_SUCCESS(st))  {
            LOGPRINT( (ERRORLOG, "\nCouldn't create Key named[%S]",p ));
            break;
        }

        NtClose (hKey);
        hKey = hKeyCreate;

        while ( *p != UNICODE_NULL ) p++;
    }

    NtClose (hKey);

    if (!NT_SUCCESS(st)) {
        for ( ;p != pTrace;p++ )
            if ( *p == UNICODE_NULL) *p=L'\\';
        return FALSE;
    }
    return TRUE;
}

BOOL
CheckAndCreateNode (
    IN PWCHAR Name
    )
/*++

Routine Description:

    Check if the given key exist if not create the key. called by background
    thread working on the setup.

Arguments:

    Name - name of the key to check.

Return Value:

    TRUE if the operation succeed, FALSE otherwise.
--*/
{
    ISN_NODE_TYPE Node;
    PWCHAR p;
    //
    // if parent doesn't exist you shouldn't create the child
    //

    if (!NT_SUCCESS(IsNodeExist (Name)) ) {

        p  = wcsstrWow6432Node (Name);
        if ( p != NULL ) {
            wcsncpy (Node.NodeValue, Name, p-Name-1);
            Node.NodeValue[p-Name-1] = UNICODE_NULL;
        }
        else
            return FALSE;

        if (NT_SUCCESS(IsNodeExist (Node.NodeValue)) )
            return CreateNode (Name);
    }
    return TRUE;

}


//
//  Opaque field might contain some information about the key on the 32bit side.
//

BOOL
IsIsnNode (
   PWCHAR wStr,
   PWCHAR *pwStrIsn
   )
/*++

Routine Description:

    Will determine if the given path has any ISN node.

Arguments:

    wStr - string to that might contain some ISN node.
    pwStrDest - point to the node after ISN node.

Return Value:

    TRUE if the string has any ISN node, FALSE otherwise
--*/
{
    int Index=0;



    //
    // Check if the provided string is already on the 32 bit tree, if so we can
    //   just ignore that
    //

    //
    // check if input string has any known symbolic link like \registry\user\sid_Classes that need to remap to a different location
    //


    for (;;) {

        if ( IsnNode [Index][0]==UNICODE_NULL ) break;

        if ( (*pwStrIsn = wcsstrWithWildCard (wStr, IsnNode[Index] ) ) != NULL )
            return TRUE;

        Index++;
    };


    *pwStrIsn = NULL;
    return FALSE;
}

NTSTATUS 
ObjectAttributesToKeyName (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PWCHAR AbsPath,
    DWORD  AbsPathLenIn,
    BOOL *bPatched,
    DWORD *ParentLen
    )
/*++

Routine Description:

    Determine the text equivalent for key handle

Arguments:

    ObjectAttributes define the object attribute Keyname need to be constracted.
    AbsPath Unicode string to receive the Name of the key.
    bPatched - TRUE if the Name has been compressed/expanded that
               the original object can't refer. Caller need to construct
               a new obj attribute.
               unchanged otherwise.
    ParentLen - Length of the parent name.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    ULONG Length;
    ULONG AbsPathLen = 0;
    BYTE *pAbsPath = (PBYTE)AbsPath;

    POBJECT_NAME_INFORMATION ObjectName = (POBJECT_NAME_INFORMATION)AbsPath;  //Smartly use user buffer

    
    if (ParentLen)
        *ParentLen = 0;

    if (ObjectAttributes->RootDirectory) {

        Status = NtQueryObject(ObjectAttributes->RootDirectory,
                           ObjectNameInformation,
                           ObjectName,
                           AbsPathLenIn,
                           &Length
                           );

        if ( !NT_SUCCESS(Status) )
             return Status;
    } else {

        AbsPathLen = ObjectAttributes->ObjectName->Length;

        if (AbsPathLenIn <= AbsPathLen)
            return STATUS_BUFFER_OVERFLOW;

        memcpy ( pAbsPath, (PBYTE)ObjectAttributes->ObjectName->Buffer, AbsPathLen );
        *(WCHAR *)(pAbsPath+AbsPathLen) = UNICODE_NULL;
    
        if (ParentLen)
            *ParentLen = AbsPathLen; // length of the parent handle
        return STATUS_SUCCESS;
    }

    //
    //  copy the root and sub path
    //
    AbsPathLen = ObjectName->Name.Length;
    memcpy ( pAbsPath, (PBYTE)ObjectName->Name.Buffer, AbsPathLen);

    if ( ObjectAttributes->ObjectName->Length > 1 ) { // Valid object name need to be greater

        *(WCHAR *)(pAbsPath+AbsPathLen) = L'\\';
        AbsPathLen += sizeof ( L'\\');


        if (AbsPathLenIn <= (AbsPathLen+ObjectAttributes->ObjectName->Length))
            return STATUS_BUFFER_OVERFLOW;

        memcpy (
            pAbsPath+AbsPathLen,
            ObjectAttributes->ObjectName->Buffer,
            ObjectAttributes->ObjectName->Length
            );

        AbsPathLen += ObjectAttributes->ObjectName->Length;
    }

    *(WCHAR *)(pAbsPath+AbsPathLen) = UNICODE_NULL;
    //
    // Compress the path in case multiple wow6432node exist
    //
    for (;;) {
        PWCHAR p, t;

        if ( (p=wcsstrWow6432Node (AbsPath)) != NULL ) {

            if ( (t=wcsstrWow6432Node(p+1)) != NULL) {

                wcscpy (p,t);
                *bPatched = TRUE;
            }
            else break;

        } else break;
    }

    return STATUS_SUCCESS;
}

BOOL
HandleToKeyName (
    HANDLE Key,
    PWCHAR KeyName,
    DWORD * dwLen
    )
/*++

Routine Description:

    Determine the text equivalent for key handle

Arguments:

    Key - is key handle for which to obtain its text
    KeyName - Unicode string to receive the Name of the key.
    dwLen   - Length of the buffer pointed by KeyName. (Number of unicode char)

Return Value:

    TRUE if the handle text is fetched OK.  FALSE if not (ie. error or
    Key is an illegal handle, etc.)

--*/
{
    NTSTATUS Status;
    ULONG Length;

    DWORD NameLen;

    POBJECT_NAME_INFORMATION ObjectName;

    ObjectName = (POBJECT_NAME_INFORMATION)KeyName;  //use the user buffer to make the call to save space on stack.

    KeyName[0]= UNICODE_NULL;
    if (Key == NULL) {
        KeyName[0]= UNICODE_NULL;
        return FALSE;
    }

    Status = NtQueryObject(Key,
                       ObjectNameInformation,
                       ObjectName,
                       *dwLen-8,
                       &Length
                       );
    NameLen = ObjectName->Name.Length/sizeof(WCHAR);

    if (!NT_SUCCESS(Status) || !Length || Length >= (*dwLen-8)) {
        DbgPrint ("\nHandleToKeyName: NtQuery Object failed St:%x, Handle: %x", Status, Key);
        KeyName[0]= UNICODE_NULL;
        return FALSE;
    }

    //
    //  buffer overflow condition check
    //

    if (*dwLen < ( NameLen + 8+ 2) ) {

        *dwLen = 2 + NameLen + 8;
        DbgPrint ("\nHandleToKeyName: Buffer over flow.");
        KeyName[0]= UNICODE_NULL;
        return FALSE;  //buffer overflow
    }

    wcsncpy(KeyName, ObjectName->Name.Buffer, NameLen);
    KeyName[NameLen]=UNICODE_NULL;
    return TRUE;
}


BOOL
Map32bitTo64bitKeyName (
    IN  PWCHAR Name32Key,
    OUT PWCHAR Name64Key
    )
/*++

Routine Description:

    Return a key name valid in the 64-bit registry side. It's the caller responsibility
    to give enough space in the output buffer. Its internal routine and no boundary
    checking is done here.

Arguments:

    Name32Key - Input 32bit/64 bit Key name.
    Name64Key - Receiving Buffer that will hold the equivalent 64bit Key.

Return Value:

    TRUE if the remapping become successful.
    FALSE otherwise.

--*/
{

    //
    //  just remove 32bit related patch from the name if anything like that exist.
    //  If the key is already on the 64bit side don't bother return the whole copy.
    //

    PWCHAR NodeName32Bit;
    DWORD Count;

    try {
        if ( ( NodeName32Bit = wcsstrWow6432Node (Name32Key)) == NULL) {  // nothing to remap

            wcscpy (Name64Key, Name32Key);
            return TRUE;
        }

        Count = (DWORD)(NodeName32Bit - Name32Key);
        wcsncpy (Name64Key, Name32Key, Count-1);
        Name64Key[Count-1]=UNICODE_NULL;

        if (NodeName32Bit[NODE_NAME_32BIT_LEN] == L'\\')
        wcscpy (
            Name64Key + Count-1,
            NodeName32Bit + NODE_NAME_32BIT_LEN); //One if to skip the char'/'

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        return FALSE;
    }

    return TRUE; //any complete path can have only one instance of NODE_NAME_32BIT
}

BOOL
IsExemptRedirectedKey (
    IN  PWCHAR SrcKey,
    OUT PWCHAR DestKey
    )
/*++

Routine Description:

    Check if the the source key point to the list of exempt key from redirection. 
    If so DestKey will have the right value.

Arguments:

    Name64Key - Input 32bit/64 bit Key name.
    Name32Key - Receiving Buffer that will hold the equivalent 32bit Key.

Return Value:

    TRUE if the Key is on the list of exempt key from redirection.
    FALSE otherwise.

--*/
{
    //
    // Make 64bit only path
    //
    PWCHAR NodeName32Bit;
    DWORD dwIndex =0;

    wcscpy (DestKey, SrcKey);
    if ( ( NodeName32Bit = wcsstrWow6432Node (DestKey)) != NULL) {  // nothing to remap patch is already there

            NodeName32Bit--;
            wcscpy (NodeName32Bit, NodeName32Bit+sizeof (NODE_NAME_32BIT)/sizeof (WCHAR));
        }
    
    for ( dwIndex = 0; ExemptRedirectedKey[dwIndex].KeyPath[0] != UNICODE_NULL; dwIndex++ ) 
        if (_wcsnicmp (DestKey, ExemptRedirectedKey[dwIndex].KeyPath, ExemptRedirectedKey[dwIndex].Len ) == 0)
            return TRUE;
        
    return FALSE;
}

BOOL
Map64bitTo32bitKeyName (
    IN  PWCHAR Name64Key,
    OUT PWCHAR Name32Key
    )
/*++

Routine Description:

    Return a key name valid in the 32-bit registry side. It's the caller responsibility
    to give enough space in the output buffer. Its internal routine and no boundary
    checking is done here.

Arguments:

    Name64Key - Input 32bit/64 bit Key name.
    Name32Key - Receiving Buffer that will hold the equivalent 32bit Key.

Return Value:

    TRUE if the remapping become successful.
    FALSE otherwise.

--*/
{

    //
    //  just add 32bit related patch from the name if anything like that exist.
    //  or fall under the ISN nodes.
    //



    PWCHAR NodeName32Bit;
    DWORD Count;

    try { 

        if (IsExemptRedirectedKey (Name64Key, Name32Key) )
            return TRUE;

        if ( ( NodeName32Bit = wcsstrWow6432Node (Name64Key)) != NULL) {  // nothing to remap patch is already there

            wcscpy (Name32Key, Name64Key);
            return TRUE;
        }

        if (!IsIsnNode ( Name64Key, &NodeName32Bit))  {

            wcscpy (Name32Key, Name64Key);
            return TRUE;
        }


        Count = (DWORD)(NodeName32Bit - Name64Key); // Displacement offset where the patch shoud go.

        //
        //  consider the case when 32bit apps need to create/open the real ISN node which doesn't exist
        //

        wcsncpy (Name32Key,Name64Key, Count);

        if   (Name32Key[Count-1] != L'\\') {
            Name32Key[Count] = L'\\';
            Count++;
        }

        wcscpy (Name32Key+Count, NODE_NAME_32BIT);


        if ( *NodeName32Bit != UNICODE_NULL ) {
            wcscat (Name32Key, L"\\");
            wcscat (Name32Key, NodeName32Bit);

        }

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        return FALSE;
    }

    return TRUE; //any complete path can have only one instance of NODE_NAME_32BIT
}

NTSTATUS
OpenIsnNodeByObjectAttributes  (
    POBJECT_ATTRIBUTES ObjectAttributes,
    ACCESS_MASK DesiredAccess,
    PHANDLE phPatchedHandle
    )
/*++

Routine Description:
    If this Keyhandle is an open handle to an ISN node then this function
    return a handle to the node on the 32 bit tree. If not then we create the whole
    path and see if any ISN node is there. If so we Get the path on the 32bit tree and
    return Open that key.

    Scenario:
    1. Absolute path made from Directory root and relative path don't contain any ISN node.
       -Open that normally.
    2. Directory Handle point to the immediate parent of ISN node and the relative path is
       just an ISN node.
       -if 32 bit equivalent of ISN node exist open that and return that. If the 32 bit node
       doesn't exist create one and return that. [Problem open Directory Handle might not
       have  create access.
    3  Directory Handle point to an ISN node and relative path is just an immediate chield.
       - This can never happen. If we follow the algorithm, directory handly can't point on
       to an ISN node but on 32 bit equivalent node.
    4. Same as 2 but relative path might be grand child or far bellow.
       - If 32 bit equivalent node isn't there just create that and open the rest.

    How 32 bit Apps can open an ISN node:
    <TBD> the proposal is a s follows:
    1. Redirector will maintain a list of exempt handle that were created to access ISN node.
    2. Any open call relative to those handle will also be on the exemped list.
    3. NtClose thunk will remove


Arguments:

    KeyHandle - Handle to the node on the 64 bit tree.
    phPatchedHandle - receive the appropriate handle if this function succeed.


Return Value:

    NTSTATUS;

--*/
{
    UNICODE_STRING Parent;
    NTSTATUS st;
    OBJECT_ATTRIBUTES Obja;
    WCHAR PatchedIsnNode[WOW64_MAX_PATH+256];
    WCHAR AbsPath[WOW64_MAX_PATH+256];
    BOOL bPatched;

    DWORD ParentLen;

    //
    //  Make the complete path in a AbsPath
    //

    



    *phPatchedHandle=NULL;

    st = ObjectAttributesToKeyName ( 
                                    ObjectAttributes, 
                                    AbsPath,
                                    sizeof (AbsPath),
                                    &bPatched, 
                                    &ParentLen );

    if (!NT_SUCCESS(st)) {
        LOGPRINT( (ERRORLOG, "\nWow64:Extremely Bad!!!!!!!!!!!!!!! Couldn't retrieve object name"));
        return st;
    }


    if (DesiredAccess & KEY_WOW64_64KEY) {

        if (!Map32bitTo64bitKeyName ( AbsPath, PatchedIsnNode ))
            return -1;  //severe problem shouldn't happen
    } else {

        PWCHAR p;

        if (!Map64bitTo32bitKeyName ( AbsPath, PatchedIsnNode ))
            return -1;  //severe problem shouldn't happen

        //
        //  If parent root immediately point just before or anywhere after the patch don't patch
        //
        /*if (!(DesiredAccess & KEY_WOW64_32KEY ) ) {
                    p = wcsstr (PatchedIsnNode, NODE_NAME_32BIT);
                    if (p) {
                        DWORD Len;

                        p--; //back one step to ignore slash before Wow6432Node
                        Len = (DWORD) (p-PatchedIsnNode);
                        Len *= sizeof (WCHAR);  //get byte
                        if (Len >= ParentLen ) {

                            Wow64RegDbgPrint (( "\nRemapNtOpenKeyEx OUT: Will not patch %S", PatchedIsnNode));
                            return STATUS_SUCCESS;
                        }
                    }
        } */
    }


    DesiredAccess = DesiredAccess & (~KEY_WOW64_RES);
    //
    // Handle the hardlink we have HKLM\Software\wow6432node\classes ==>HKCR\Classes
    //

    /*if (_wcsnicmp (PatchedIsnNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes", 19+27) == 0) {
        wcsncpy (PatchedIsnNode+27, L"Classes\\Wow6432Node", 19); //sizeof (L"Wow6432Node\\Classes")/2);
        bPatched = TRUE;
    }*/
        

    //
    //  no change can be optimize by returning different value from Map64bitTo32bitKeyName
    //  Caller need to handle this
    //

    if ( !bPatched)
    if ( !wcscmp (AbsPath, PatchedIsnNode ))
        return STATUS_SUCCESS; 


    RtlInitUnicodeString (&Parent, PatchedIsnNode);
    InitializeObjectAttributes (&Obja, &Parent, ObjectAttributes->Attributes, NULL, ObjectAttributes->SecurityDescriptor ); //you have to use caller's context

    st = NtOpenKey (phPatchedHandle, DesiredAccess, &Obja);

#ifdef WOW64_LOG_REGISTRY
    if (!NT_SUCCESS (st))
        Wow64RegDbgPrint (( "\nRemapNtOpenKeyEx OUT: couldn't open %S", PatchedIsnNode));
#endif

    return st;
}

NTSTATUS
RemapNtCreateKey(
    OUT PHANDLE phPatchedHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    KeyHandle - Receives a Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory is
        specified, the name is relative to the root.  The name of the
        object must be within the name space allocated to the Registry,
        that is, all names beginning "\Registry".  RootHandle, if
        present, must be a handle to "\", or "\Registry", or a key
        under "\Registry".

        RootHandle must have been opened for KEY_CREATE_SUB_KEY access
        if a new node is to be created.

        NOTE:   Object manager will capture and probe this argument.

    TitleIndex - Specifies the index of the localized alias for
        the name of the key.  The title index specifies the index of
        the localized alias for the name.  Ignored if the key
        already exists.

    Class - Specifies the object class of the key.  (To the registry
        this is just a string.)  Ignored if NULL.

    CreateOptions - Optional control values:

        REG_OPTION_VOLATILE - Object is not to be stored across boots.

    Disposition - This optional parameter is a pointer to a variable
        that will receive a value indicating whether a new Registry
        key was created or an existing one opened:

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    UNICODE_STRING Parent;
    NTSTATUS st;
    OBJECT_ATTRIBUTES Obja;
    WCHAR PatchedIsnNode[WOW64_MAX_PATH];
    WCHAR AbsPath[WOW64_MAX_PATH];

    BOOL bPatched=FALSE;
    DWORD ParentLen;


    //
    //  Make the complete path in a AbsPath
    //

 
    if (ARGUMENT_PRESENT(phPatchedHandle)){
        *phPatchedHandle=NULL;
    }

    st = ObjectAttributesToKeyName (
                                    ObjectAttributes,
                                    AbsPath,
                                    sizeof (AbsPath),
                                    &bPatched,
                                    &ParentLen);
    if (!NT_SUCCESS(st)) {
        WOWASSERT(FALSE );
        return st; 
    }

    if (DesiredAccess & KEY_WOW64_64KEY) {

        if (!Map32bitTo64bitKeyName ( AbsPath, PatchedIsnNode )) {
            WOWASSERT(FALSE );
            return STATUS_SUCCESS;  //severe problem shouldn't happen
        }
    } else {

        PWCHAR p;

        if (!Map64bitTo32bitKeyName ( AbsPath, PatchedIsnNode )){
            WOWASSERT(FALSE );
            return STATUS_SUCCESS;  //severe problem shouldn't happen
        }

        //
        //  If parent root immediately point just before or anywhere after the patch don't patch
        //
        /*
        if (!(DesiredAccess & KEY_WOW64_32KEY ) ) {  //implied 32bit access
                p = wcsstr (PatchedIsnNode, NODE_NAME_32BIT);
                if (p) {
                    DWORD Len;

                    p--; //back one step to ignore slash before Wow6432Node
                    Len = (DWORD) (p-PatchedIsnNode);
                    Len *= sizeof (WCHAR);  //get byte
                    if (Len >= ParentLen ) {

                        Wow64RegDbgPrint (( "\nRemapNtOpenKeyEx OUT: Will not patch %S", PatchedIsnNode));
                        return STATUS_SUCCESS;
                    }
                }
        }*/
    }

    DesiredAccess = DesiredAccess & (~KEY_WOW64_RES);
    //
    // Handle the hardlink we have HKLM\Software\wow6432node\classes ==>HKCR\Classes
    //

    /*if (_wcsnicmp (PatchedIsnNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes", 19+27) == 0) {
        bPatched = TRUE;
        wcsncpy (PatchedIsnNode+27, L"Classes\\Wow6432Node", 19); //sizeof (L"Wow6432Node\\Classes")/2);
    }*/


    if (!bPatched)   // the abspath hasn't been patched
    if ( !wcscmp (AbsPath, PatchedIsnNode ))
        return STATUS_SUCCESS; // no change can be optimize by returning different value from Map64bitTo32bitKeyName


    RtlInitUnicodeString (&Parent, PatchedIsnNode);
    InitializeObjectAttributes (&Obja,
                                &Parent,
                                ObjectAttributes->Attributes,
                                NULL,
                                ObjectAttributes->SecurityDescriptor
                                ); //you have to use caller's context

    st = NtCreateKey(
                    phPatchedHandle,
                    DesiredAccess,
                    &Obja,
                    TitleIndex,
                    Class ,
                    CreateOptions,
                    Disposition
                    );
    return st;

}

NTSTATUS
Wow64NtPreUnloadKeyNotify(
    IN POBJECT_ATTRIBUTES TargetKey
    )
/*++

Routine Description:

    This call will notify Wow64 service that wow64 need to release any open handle
    to the hive that is going to be unloaded.

    Drop a subtree (hive) out of the registry.

    Will fail if applied to anything other than the root of a hive.

    Cannot be applied to core system hives (HARDWARE, SYSTEM, etc.)

    Can be applied to user hives loaded via NtRestoreKey or NtLoadKey.

    If there are handles open to the hive being dropped, this call
    will fail.  Terminate relevent processes so that handles are
    closed.

    This call will flush the hive being dropped.

    Caller must have SeRestorePrivilege privilege.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS - values TBS.

--*/

{
    //todo
    return 0;
}


NTSTATUS
Wow64NtPostLoadKeyNotify(
    IN POBJECT_ATTRIBUTES TargetKey
    )

/*++

Routine Description:

    If  Load operation succeed, it will notify wow64 service that it
    can listen to the registry operation on the given hive.

    This function can be invoked from NtLoadKey and NtLoadKey2 APIs.

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"


Return Value:

    NTSTATUS - values TBS.

--*/
{
    //todo
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\regsetup\main.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module will do the necessary things to setup initial registry for the redirection
    purpose.

//
//  Test case scenario
//      1. Open a ISN node and list content
//      2. Create a ISN node do 1.
//      3. Open a non ISN node and list
//      4. Create a non ISN node and list content
//

  Outstanding issue:
    reflector: If Key has been created on one side, we can reflect that on the other side.
               Deletion: Without any additional attribute it's impossible to track.

Author:

    ATM Shafiqul Khalid (askhalid) 18-Nov-1999

Revision History:

--*/


#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include "wow64reg.h"
#include <assert.h>
#include "..\wow64reg\reflectr.h"
#include <shlwapi.h>


VOID
CleanupWow64NodeKey ()

/*++

Routine Description

    Remove the entry for wow64.

Arguments:

    None.


Return Value:

    None.

--*/

{
    DWORD Ret;
    HKEY Key;

    Ret = RegOpenKey (  HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft", &Key);

    if ( Ret == ERROR_SUCCESS ) {

        Ret = SHDeleteKey ( Key, L"WOW64");
        if ( Ret != ERROR_SUCCESS )
                Wow64RegDbgPrint ( ("\n sorry! couldn't delete the key...SOFTWARE\\Microsoft\\WOW64"));
        RegCloseKey (Key);
    } else
        Wow64RegDbgPrint ( ("\nSOFTWARE\\Microsoft\\WOW64 node is missing setup will creat that.") );

}

LPTSTR NextParam (
    LPTSTR lpStr
    )
/*++

Routine Description

    Point to the next parameter in the commandline.

Arguments:

    lpStr - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/
{
	WCHAR ch = L' ';
		

    if (lpStr == NULL )
        return NULL;

    if ( *lpStr == 0 )
        return lpStr;

    while (  ( *lpStr != 0 ) && ( lpStr[0] != ch )) {

		if ( ( lpStr [0] == L'\"')  || ( lpStr [0] == L'\'') )
			ch = lpStr [0];

        lpStr++;
	}

	if ( ch !=L' ' ) lpStr++;

    while ( ( *lpStr != 0 ) && (lpStr[0] == L' ') )
        lpStr++;

    return lpStr;
}

DWORD CopyParam (
    LPTSTR lpDestParam,
    LPTSTR lpCommandParam
    )
/*++

Routine Description

    Copy the current parameter to lpDestParam.

Arguments:

    lpDestParam - that receive current parameter
    lpCommandParam - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{
	DWORD dwLen = 0;
	WCHAR ch = L' ';

	*lpDestParam = 0;
	
	if ( ( lpCommandParam [0] == L'\"')  || ( lpCommandParam [0] == L'\'') ) {
		ch = lpCommandParam [0];
		lpCommandParam++;
	};


    while ( ( lpCommandParam [0] ) != ch && ( lpCommandParam [0] !=0 ) ) {
        *lpDestParam++ = *lpCommandParam++;
		dwLen++;

		if ( dwLen>255 ) return FALSE;
	}

	if ( ch != L' ' && ch != lpCommandParam [0] )
		return FALSE;
	else lpCommandParam++;

    *lpDestParam = 0;

	return TRUE;

}

///////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////

BOOL
ParseCommand ()


/*++

Routine Description

    Parse command line parameters. Get different options from
    command line parameters.

Arguments:

    None.


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{

    LPTSTR lptCmdLine1 = GetCommandLine ();


    LPTSTR lptCmdLine = NextParam ( lptCmdLine1 );


    if ( lptCmdLine== NULL || lptCmdLine[0] == 0 )
        return FALSE;

    printf ("\nRunning Wow64 registry setup program.....\n");

    while (  ( lptCmdLine != NULL ) && ( lptCmdLine[0] != 0 )  ) {

        if ( lptCmdLine[0] != '-' )
            return FALSE;

        switch ( lptCmdLine[1] ) {

        case L'c':
                  printf ("\nCopying from 32bit to 64bit isn't implemented yet");
                  break;
        case L'C':          //  CopyRegistryKey
                  SetInitialCopy ();
                  PopulateReflectorTable ();
                  CreateIsnNode();
                  break;

        case L'd':
            printf ("\nRemove all the Keys from 32bit side that were copied from 64bit side");
            CleanpRegistry ( );
            break;

        case L'D':
            printf ("\nRemove all the Keys from 32bit side that were copied from 64bit side");
            CleanpRegistry ();
            break;

       case L'p':
       case L'P':  // populate registry
            CleanupWow64NodeKey ();
            PopulateReflectorTable ();
            break;

       case 't':
           {

               InitializeIsnTableReflector ();
                CreateIsnNodeSingle( 4 );
                CreateIsnNodeSingle( 5 );
           }
            break;

        case L'r':
        case L'R':
            //
            //  run the reflector codes;
            //

            InitReflector ();
            if ( !RegisterReflector () ) {
                    printf ("\nSorry! reflector couldn't be register");
                    UnRegisterReflector ();
                    return FALSE;
            }

            printf ("\nSleeping for 100 min to test reflector codes ...........\n");
            Sleep (1000*60*100);

            UnRegisterReflector ();
            break;

        default:
            return FALSE;
            break;
        }

        lptCmdLine = NextParam ( lptCmdLine );
    }

    return TRUE;
}

int __cdecl
main()
{


    if (!ParseCommand ()) {

        printf ( "\nUsages: w64setup [-c] [-C] [-d] [-D] [-r]\n");
        printf ( "\n        -c Copy from 32bit to 64bit side of the registry");
        printf ( "\n        -C Copy from 64bit to 32bit side of the registry");
        printf ( "\n");
        printf ( "\n        -d Remove all the Keys from 32bit side that were copied from 64bit side");
        printf ( "\n        -D Remove all the Keys from 64bit side that were copied from 32bit side");

        printf ( "\n");
        printf ( "\n        -r Run reflector thread");

        printf ("\n");
        return 0;

    }



    printf ("\nDone.");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\regsetup\setup.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    setup.h

Abstract:

    This file define function used only in the setup/reflector thread

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#ifndef __SETUP_H__
#define __SETUP_H__

 

#define TEST_NODE_NAME L"TEST"
#define VALUE_KEY_UPDATE_TIME_DIFF 10  // minimum difference in sec to Keyupdate and reflector thread scan

 

 

#endif //__SETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\test\main.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module
//  Test case scenario
//      1. Open implement some test case scenario for regremap module.

//a ISN node and list content
//      2. Create a ISN node do 1.
//      3. Open a non ISN node and list
//      4. Create a non ISN node and list content
//

Author:

    ATM Shafiqul Khalid (askhalid) 10-Nov-1999

Revision History:

--*/

#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include "wow64reg.h"
#include "..\wow64reg\reflectr.h"

#define TEST_NODE_NAME L"TEST"
#define GUID_STR L"{00000000-E877-11CE-9F68-00AA00574A40}"

typedef struct _TEST_NODE_TYPE {
    HKEY hKey;
    WCHAR Name[256];
    WCHAR SubKey[256];
}TEST_NODE_TYPE;

TEST_NODE_TYPE TestNodeList [] = {
    {HKEY_CLASSES_ROOT, L"test1002", UNICODE_NULL},
    {HKEY_CURRENT_USER, L"software\\classes\\test1002", UNICODE_NULL},
    {HKEY_LOCAL_MACHINE, L"software\\classes\\test1002", UNICODE_NULL},
    //{HKEY_USERS,""""""}
    };

#define TEST_NODE_NUM (sizeof (TestNodeList)/sizeof (TEST_NODE_TYPE) )

//should move into right header file
BOOL
NonMergeableValueCLSID (
    HKEY SrcKey,
    HKEY DestKey
    );
BOOL
GetKeyTime (
    HKEY SrcKey,
    ULONGLONG *Time
    );

BOOL
MergeKeySrcDest(
    PWCHAR Src,
    PWCHAR Dest
    );

BOOL
GetWow6432ValueKey (
    HKEY hKey,
    WOW6432_VALUEKEY *pValue
    );

BOOL
MergeK1K2Value (
    HKEY SrcKey,
    HKEY DestKey,
    DWORD dwFlag
    );

LONG
Wow64RegCreateKeyEx(
  HKEY hKey,                // handle to an open key
  LPCTSTR lpSubKey,         // address of subkey name
  DWORD Reserved,           // reserved
  LPTSTR lpClass,           // address of class string
  DWORD dwOptions,          // special options flag
  REGSAM samDesired,        // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                            // address of key security structure
  PHKEY phkResult,          // address of buffer for opened handle
  LPDWORD lpdwDisposition   // address of disposition value buffer
);

BOOL
AnalyzeNode (
    PWCHAR pKeyName,
    BOOL bSync
    )
{
    WCHAR Name[256];
    WCHAR Mirror[256];
    DWORD AccessFlag;
    DWORD Ret;
    ULONGLONG Time1, Time2;
    WCHAR *GUIDName;
    
    
    WOW6432_VALUEKEY WowValue1;
    WOW6432_VALUEKEY WowValue2;

    DWORD dwLen = sizeof (Mirror)/sizeof(Mirror[0]);

    HKEY Key1;
    HKEY Key2;

    if (pKeyName == NULL )
        return FALSE;

    if (pKeyName[0] == UNICODE_NULL )
        return FALSE;


    wcscpy (Name, L"\\REGISTRY\\MACHINE\\SOFTWARE\\");
    if (_wcsnicmp (pKeyName, L"\\REGISTRY", 9 ) !=0 ) {
        wcscat (Name, pKeyName);
    } else wcscpy (Name, pKeyName);

    printf ("\nAnalyzing key [%S]\n", Name );

    //print the time stamp, value on the both side etc

    Key1 = OpenNode (Name);
    if (Key1 == NULL) {
        printf ("\nSorry! couldn't open the Key %S", Name );
        return FALSE;
    }

    //BUGBUG following operation should succeed but don't work for classes\wow6432node\.doc input
    //Possible bug in the WOW64RegOpenKeyEx
    /*Ret = RegOpenKeyEx(
                Key1,
                NULL,//NULL,
                0,//OpenOption,
                KEY_ALL_ACCESS | ( AccessFlag = Is64bitNode (Name)? KEY_WOW64_32KEY : KEY_WOW64_64KEY ),
                &Key2
                );

    if ( ERROR_SUCCESS != Ret ){
        printf ("\nSorry! couldn't open mirror of the Key %S", Name );
        return FALSE;
    }
    HandleToKeyName ( Key2, Mirror, &dwLen );
    */

    //Need to be removed this section
    
    GetMirrorName (Name, Mirror);
    Key2 = OpenNode (Mirror);
    if (Key2 == NULL) {
        printf ("\nSorry! couldn't open the mirror Key %S", Name );
        return FALSE;
    }

    printf ("\nOpened Mirror Key at %S", Mirror);

    //now print all the timing information

    printf ("\nExtension Test....");
    if ( NonMergeableValueCLSID (Key1, Key2 ))
        printf ("\nValue of those keys can't be merged...reasons: 1. not an extension 2. Handler don't exist");
    else
        printf ("\nValue of those keys will be merged by reflector");

    GUIDName = wcsstr (Name, L"\\CLSID\\{");
    if ( GUIDName != NULL ) {
        HKEY KeyGuid;

        DWORD SubkeyNumber=1;

        GUIDName +=7;
        printf ("\nGUID Test......%S", GUIDName);
        *(GUIDName -1) = UNICODE_NULL;
        KeyGuid = OpenNode (Name);
        *(GUIDName -1) = L'\\';

        MarkNonMergeableKey (GUIDName, KeyGuid, &SubkeyNumber);

        if ( SubkeyNumber>0)
            printf ("\nThe guid will be merged....");
        else
            printf ("\nthe guid isn't going to be merged");
    }



    GetKeyTime (Key1, &Time1);
    GetKeyTime (Key2, &Time2);
    printf ("\nOriginal TimeStamp on Keys Src:%p, Dest:%p", Time1, Time2);

    GetWow6432ValueKey ( Key1, &WowValue1);
    GetWow6432ValueKey ( Key2, &WowValue2);

    printf ("\nWowAttribute associated with Keys Src Value type:%d, Timestamp %p", WowValue1.ValueType, WowValue1.TimeStamp);
    printf ("\nWowAttribute associated with Keys Des Value type:%d, Timestamp %p", WowValue2.ValueType, WowValue2.TimeStamp);
    printf ("\nValueType 1=>Copy, 2=>Reflected, 3=>NonReflectable..\n(Timestamp,Value)=>0 wow attrib isn't there");

    if ( bSync ) {
        printf ("\n Merging Value/Keys.....");
        //MergeK1K2Value (Key1, Key2, 0);
        MergeKeySrcDest(Name, Mirror);
    }
    
    /*if ( bSync ) {
        printf ("\n Merging Value/Keys.....");
        //MergeK1K2Value (Key1, Key2, 0);
        MergeKeySrcDest(Name, Mirror);
    }

    if ( bSync ) {
        printf ("\n Merging Value/Keys.....");
        //MergeK1K2Value (Key1, Key2, 0);
        MergeKeySrcDest(Name, Mirror);
    }

    Sleep (1000*10);
    */
    return TRUE;
}

BOOL
DeleteNode (
    HKEY hKey,
    PWCHAR Name
    )
{
    return FALSE;
}

LONG
Wow64CreateOpenNode(
    HKEY hKey,
    PWCHAR Name,
    HKEY *phKey,
    DWORD dwOption,
    WCHAR Mode
    )
{
        WCHAR Buff [MAX_PATH + 1];
        DWORD dwBuffLen = MAX_PATH + 1;
        DWORD Ret;
        *phKey=NULL;

        Ret = Wow64RegCreateKeyEx(
                            hKey,        // handle to an open key
                            Name,                  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS | dwOption,           // desired security access
                            NULL,                     // address of key security structure
                            phKey,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );


        Buff[0]=UNICODE_NULL;
        if (*phKey == NULL) {
                HandleToKeyName ( hKey, Buff, &dwBuffLen );
                printf ("\nRegCreateEx failed....error: Flag:%d Ret:%d %S<\\>%S", dwOption, Ret, Buff, Name);
        }
            else if (Mode==L'V'){
                HandleToKeyName ( *phKey, Buff, &dwBuffLen );
                printf ("\nWow64RegCreateEx succeeded with ....[%S]", Buff);
            }

            return Ret;
}

LONG
CreateOpenNode(
    HKEY hKey,
    PWCHAR Name,
    HKEY *phKey,
    DWORD dwOption,
    WCHAR Mode
    )
{
        WCHAR Buff [MAX_PATH + 1];
        DWORD dwBuffLen = MAX_PATH + 1;
        DWORD Ret;
        *phKey=NULL;

        Ret = RegCreateKeyEx(
                            hKey,        // handle to an open key
                            Name,                  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS | dwOption,           // desired security access
                            NULL,                     // address of key security structure
                            phKey,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );


        Buff[0]=UNICODE_NULL;
        if (*phKey == NULL) {
                HandleToKeyName ( hKey, Buff, &dwBuffLen );
                printf ("\nRegCreateEx failed....error: Flag:%d Ret:%d %S<\\>%S", dwOption, Ret, Buff, Name);
        }
            else if (Mode==L'V'){
                HandleToKeyName ( *phKey, Buff, &dwBuffLen );
                printf ("\nRegCreateEx succeeded with ....[%S]", Buff);
            }


    if ( (( dwOption & KEY_WOW64_64KEY )&& ( wcsstr(Buff, L"Wow6432Node") != NULL ) ) ||  
        ( dwOption & KEY_WOW64_32KEY ) && ( wcsstr(Buff, L"Wow6432Node") == NULL ))
        printf ("\nSorry! key was created at wrong location..");

     return Ret;
}

OpenKey (
    HKEY hKey,
    PWCHAR Name,
    HKEY *phKey,
    DWORD dwOption,
    WCHAR Mode
    )
{
        WCHAR Buff [MAX_PATH + 1];
        DWORD dwBuffLen = MAX_PATH + 1;
        DWORD Ret;
        *phKey=NULL;

        Ret = RegOpenKeyEx(
                            hKey,
                            Name,
                            0,//OpenOption,
                            KEY_ALL_ACCESS | dwOption ,
                            phKey
                            );

        Buff[0]=UNICODE_NULL;

        if (*phKey == NULL) {

                HandleToKeyName ( hKey, Buff, &dwBuffLen );
                printf ("\nRegOpenEx failed....error: Flag:%d Ret:%d %S<\\>%S", dwOption, Ret, Buff, Name);

        }   else if (Mode==L'V'){

                HandleToKeyName ( *phKey, Buff, &dwBuffLen );
                printf ("\nRegOpenEx succeeded with ....[%S]", Buff);
            }

            return Ret;
}


BOOL
VerifyNode (
    HKEY hKey,
    PWCHAR OpenName,
    PWCHAR RealName
    )
{

    return FALSE;
}


HKEY
OpenListNode (
    HKEY OpenNode,
    WCHAR *NodeName,
    DWORD OpenOption
    )
{
    HKEY Key=NULL;
    LONG Ret, lCount =0;
    WCHAR Name [MAX_PATH + 1];

    DWORD dwBuffLen = MAX_PATH + 1;

    if ( NodeName == NULL )
        return NULL;
/*
#ifndef _WIN64
    //
    // just to test the library in the 32bit environment
    //
    if (OpenOption)
        Ret = Wow64RegOpenKeyEx(
                            OpenNode,
                            NodeName,
                            0,//OpenOption,
                            KEY_ALL_ACCESS | OpenOption ,
                            &Key
                            );
    else

#endif
*/
        Ret = RegOpenKeyEx(
                            OpenNode,
                            NodeName,
                            0,//OpenOption,
                            KEY_ALL_ACCESS | OpenOption ,
                            &Key
                            );

    if ( Key!= NULL )
        printf ( "\nOpen Operation successful [%S]", NodeName);
    else  {
        printf ( "\nOpen Operation Failed [%S] %X", NodeName, Ret);
        return NULL;
    }

    //
    // Now enumerate some value or key's to see what is there
    //

    lCount = 0;

    for(;;) {
        Ret =  RegEnumKey( Key, lCount, Name, MAX_PATH);
        if ( Ret != ERROR_SUCCESS ) break;

        printf ("\nKeyName: [%S]", Name);
        lCount++;
    }

    //
    //  Print the real name of the Key
    //
    HandleToKeyName ( Key, Name, &dwBuffLen );
    printf ("\nThe Real Name of the Key was [%S]", Name);

    return Key;
}


void BasicRegReMapTest()
{
    HKEY hSystem;
    HKEY Key;
    HKEY Key1;

    RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM",
                0,//OpenOption,
                KEY_ALL_ACCESS,
                &hSystem
                );

    printf ("\nHello! Im in the regremap piece this will print different view of a tree\n");

    printf ("\nOpening Native tree");
    Key = OpenListNode (hSystem, TEST_NODE_NAME, 0);
    RegCloseKey(Key);

    printf ("\n\nOpening Explicitly 32-bit tree");
    Key = OpenListNode (hSystem, TEST_NODE_NAME, KEY_WOW64_32KEY);

    {
        printf ("\nReopening 64bit key using handle to 32bit Key");
        Key1 = OpenListNode (Key, L"64bit Key1", KEY_WOW64_64KEY);
        RegCloseKey(Key1);
    }

    RegCloseKey(Key);

    printf ("\n\nOpening Explicitly 64-bit Tree");
    Key = OpenListNode (hSystem, TEST_NODE_NAME, KEY_WOW64_64KEY);

    {
        printf ("\nReopening 32bit key using handle to 64bit Key");
        Key1 = OpenListNode (Key, L"32bit Key1", KEY_WOW64_32KEY);
        RegCloseKey(Key1);
    }

    RegCloseKey(Key);
    RegCloseKey(hSystem);

    printf ("\nDone.");
}

void TestCreateHKCR ()
{
    HKEY hCR=NULL;
    HKEY Key=NULL;

    DWORD Ret;

    WCHAR Name [MAX_PATH + 1];

    DWORD dwBuffLen = MAX_PATH + 1;

    Ret = RegCreateKeyEx(
                            HKEY_CLASSES_ROOT,        // handle to an open key
                            L".001",                  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,        // desired security access
                            NULL,                     // address of key security structure
                            &hCR,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );


    if (Ret == ERROR_SUCCESS ) {
        printf ("\nHello! checking key creation at classes root");
        HandleToKeyName ( hCR, Name, &dwBuffLen );
        printf ("\nThe Real Name of the Key was [%S]", Name);
        RegCloseKey(hCR);
    }
    else printf ("\nCouldn't create key .001 at HKEY_CLASSES_ROOT %d", Ret );
}

void TestOpenHKCR (DWORD x, DWORD y)
{
    //
    //  Need to make it work for true 64bit
    //

    HKEY hCR=NULL;
    HKEY Key=NULL;

    DWORD Ret;

    WCHAR Name [MAX_PATH + 1];

    DWORD dwBuffLen = MAX_PATH + 1;

    printf ("\n...Hello....");
    Ret = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                L"Software",//NULL,
                0,//OpenOption,
                KEY_ALL_ACCESS | KEY_WOW64_32KEY,
                &hCR
                );

    if (Ret == ERROR_SUCCESS ) {
        printf ("\nHello! checking key open at classes root");
        HandleToKeyName ( hCR, Name, &dwBuffLen );
        printf ("\nThe Real Name of the Key was [%S] %p %p", Name, hCR, HKEY_CLASSES_ROOT);
        //RegCloseKey(hCR);
        //Name[wcslen(Name)-12]=UNICODE_NULL;
        //hCR = OpenNode (Name);
    }
    else printf ("\nCouldn't open HKEY_CLASSES_ROOT" );


    Ret = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                L"software\\classes\\software\\classes\\abcdef\\xyzw.XYZW.1\\ShellNew",
                0,//OpenOption,
                KEY_READ | KEY_WOW64_32KEY,
                &Key
                );

    if (Ret == ERROR_SUCCESS ) {
        printf ("\n\nHello! checking key open at subkey under HKEY_CLASSES_ROOT");
        HandleToKeyName ( Key, Name, &dwBuffLen );
        printf ("\nThe Real Name of the Key was [%S]", Name);
        RegCloseKey(Key);
    }
    else printf ("\nCouldn't open subkey under HKEY_CLASSES_ROOT error%d", Ret);
}

void TestPredefinedHandle ()
{
    WCHAR Name [MAX_PATH];
    DWORD Ret;
    DWORD dwBuffLen = MAX_PATH + 1;
    HKEY Key1;

    Ret = OpenKey( HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_64KEY, L'N');
    dwBuffLen = MAX_PATH + 1;
    HandleToKeyName ( Key1, Name, &dwBuffLen );
    RegCloseKey (Key1);
    if (!Is64bitNode (Name))
        printf ("\nCouldn't get 64bit HKCR using KEY_WOW64_64KEY: %S", Name);

    Ret = OpenKey( HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_32KEY, L'N');
    dwBuffLen = MAX_PATH + 1;
    HandleToKeyName ( Key1, Name, &dwBuffLen );
    RegCloseKey (Key1);
    if (Is64bitNode (Name))
        printf ("\nCouldn't get 32bit HKCR using KEY_WOW64_32KEY: %S", Name);

    Ret = OpenKey( HKEY_CURRENT_USER, L"Software\\Classes", &Key1, KEY_WOW64_64KEY, L'N');
    dwBuffLen = MAX_PATH + 1;
    HandleToKeyName ( Key1, Name, &dwBuffLen );
    RegCloseKey (Key1);
    if (!Is64bitNode (Name))
        printf ("\nCouldn't get 64bit HKCU Software\\Classes using KEY_WOW64_64KEY: %S", Name);

    Ret = OpenKey( HKEY_CURRENT_USER, L"Software\\Classes", &Key1, KEY_WOW64_32KEY, L'N');
    dwBuffLen = MAX_PATH + 1;
    HandleToKeyName ( Key1, Name, &dwBuffLen );
    RegCloseKey (Key1);
    if (Is64bitNode (Name))
        printf ("\nCouldn't get 32bit HKCU Software\\Classes using KEY_WOW64_32KEY: %S %d", Name, Ret);

}

InProcLocalServerTest ()
{
    //
    // Create a server on the 64bit side with Inproc, and check on the 32bit if its get reflected.
    //

    HKEY Key1;
    HKEY Key2;
    WCHAR KeyName[256];
    DWORD Ret=0;

    wcscpy (KeyName, L"CLSID\\");
    wcscat (KeyName, GUID_STR);
    
   

    printf  ("\nTesting of GUID\\{Inproc Server, Local Server}...");

    Ret += CreateOpenNode (HKEY_CLASSES_ROOT, KeyName, &Key1, 0, L'N');
    Ret += CreateOpenNode (Key1, L"InprocServer32", &Key2, 0, L'N');
    RegCloseKey (Key1);
    RegCloseKey (Key2);
    //
    // Try to open on the 32bit side
    //

    if (OpenKey (HKEY_CLASSES_ROOT, KeyName, &Key1, KEY_WOW64_32KEY, L'V') == 0) {
        RegCloseKey (Key1);  //Key Shouldn'e be on the 32bit side
        Ret += -1;
    }

    //
    // You Need to add for test of local server...
    //

    if (Ret ==0)
        printf ("\nGUID Test Succeed......");
    else printf ("\nGUID test with Inprocserver failed..");
    


    //Delete the Key
    
}
void
OpenCreateKeyTest ()
{

    DWORD Ret=0;
    DWORD xx;

    HKEY Key1;
    HKEY Key2;

    InProcLocalServerTest ();

    TestPredefinedHandle ();

#define TEST_NODE1 L".0xxxxxx"

    printf ("\n//_______________Test 32bit side____________________//");

    Ret = 0;

    // create 64==>TestNode
    Ret += CreateOpenNode( HKEY_CLASSES_ROOT, TEST_NODE1, &Key1, KEY_WOW64_64KEY, L'V');
    //create 32==>TestNode\GUIDSTR
    Ret += CreateOpenNode(Key1, GUID_STR, &Key2, KEY_WOW64_32KEY, L'V');

    RegCloseKey (Key2);

    //open 32==>TestNode
    Ret += OpenKey( HKEY_CLASSES_ROOT, TEST_NODE1, &Key2, KEY_WOW64_32KEY, L'V' );

    //Delete 32\TestNode==>GUID
    if ((xx=RegDeleteKey (Key2, GUID_STR ))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key %S Err:%d", GUID_STR, xx);
    Ret +=xx;

    RegCloseKey(Key2);
    RegCloseKey(Key1);

    //delete 32==>TestNode
    Ret +=OpenKey (HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_32KEY, L'V');
    if ( (xx=RegDeleteKey (Key1, TEST_NODE1))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key from 32bit tree=>%S Err:%d", TEST_NODE1, xx);
    Ret +=xx;
    RegCloseKey (Key1);

    //delete 64==>TestNode
    Ret +=OpenKey (HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_64KEY, L'V');
    if ((xx= RegDeleteKey (Key1, TEST_NODE1))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key from 64bit tree=>%S Err:%d", TEST_NODE1, xx);
    Ret +=xx;
    RegCloseKey (Key1);


    if (Ret != ERROR_SUCCESS )
        printf ("\nTest failed....");
    else
        printf ("\nTest succeed...");




    printf ("\n//_______________Test 64bit side____________________//");

    Ret = 0;
#define TEST_NODE2 L".0000######"
    // create 32==>TestNode
    Ret += CreateOpenNode( HKEY_CLASSES_ROOT, TEST_NODE2, &Key1, KEY_WOW64_32KEY, L'V');
    //create 64==>TestNode\GUIDSTR
    Ret += CreateOpenNode(Key1, GUID_STR, &Key2, KEY_WOW64_64KEY, L'V');

    RegCloseKey (Key2);

    //Open 64==>TestNode
    Ret += OpenKey( HKEY_CLASSES_ROOT, TEST_NODE2, &Key2, KEY_WOW64_64KEY, L'V' );

    //Delete 64\TestNode==>GUID
    if ((xx=RegDeleteKey (Key2, GUID_STR ))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key %S Err:%d", GUID_STR, xx);
    Ret +=xx;

    RegCloseKey(Key2);
    RegCloseKey(Key1);


    //Delete 64==>TestNode
    Ret +=OpenKey (HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_64KEY, L'V');
    if ((xx= RegDeleteKey (Key1, TEST_NODE2))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key from 64bit tree=>%S  Err:%d", TEST_NODE2, xx);
    Ret +=xx;
    RegCloseKey (Key1);

    //Delete 32==>TestNode
    Ret +=OpenKey (HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_32KEY, L'V');
    if ( (xx=RegDeleteKey (Key1, TEST_NODE2))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key from 32bit tree=>%S Err:%d", TEST_NODE2, xx);
    Ret +=xx;
    RegCloseKey (Key1);

    if (Ret != ERROR_SUCCESS )
        printf ("\nTest failed....");
    else
        printf ("\nTest succeed...");

}

TestCreateOpenNode ()
{
    DWORD Count;
    DWORD i;
    HKEY hKey=NULL;
    DWORD Ret;

    Count =  TEST_NODE_NUM;

    for ( i=0; i<Count;i++) {
        Ret = CreateOpenNode (
                TestNodeList[i].hKey,
                TestNodeList[i].Name,
                &hKey,
                0,
                L'V'
                );
        if (hKey == NULL ) {
            printf ("\n Couldn't create/open Key %S",TestNodeList[i]);
            continue;
        }
    }

}

VOID
TestSharedResources ()
{

    //#define TEST_USER_CLASSES_ROOT L"\\REGISTRY\\MACHINE\\SYSTEM\\TEST345"
    #define TEST_USER_CLASSES_ROOT L"\\REGISTRY\\USER\\S-1-5-21-397955417-626881126-188441444-2721867_Classes"
    HANDLE hEvent;
    WCHAR Name[256];

    wcscpy (Name, TEST_USER_CLASSES_ROOT);

    if (!CreateNode (Name))
        printf ("\nSorry! Couldn't create key.. %S", TEST_USER_CLASSES_ROOT );

    Wow64RegNotifyLoadHive ( Name);

    //Wow64RegNotifyUnloadHive ( Name );

}

VOID 
TestTypeLib ()
{
  HKEY SrcKey;
  HKEY DestKey;
  printf ("\nTesting Typelib copy info...");

  SrcKey = OpenNode (L"\\REGISTRY\\MACHINE\\Software\\classes\\TypeLib");
  RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            L"SOFTWARE\\Classes\\Wow6432Node\\TypeLib",  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &DestKey,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

  printf ("\n OpenHandle  %p %p", SrcKey, DestKey);
  ProcessTypeLib ( SrcKey, DestKey, FALSE );
}

VOID
TestRegReflectKey ()
{

  HKEY SrcKey;
  printf ("\nTesting RegSyncKey copy info...");

  SrcKey = OpenNode (L"\\REGISTRY\\MACHINE\\Software");

  printf ("\nRegReflectKey returned with  %d", RegReflectKey (SrcKey, L"1\\2\\3", 0) );
  RegCloseKey (SrcKey);
}

VOID
Test4()
{
    LONG lRes = 0;
    HKEY hKey = NULL;
    HKEY hKey32 = NULL;

    lRes = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        L"Software",
                        0,
                        KEY_ALL_ACCESS | KEY_WOW64_32KEY,
                        &hKey
                        );
    if(lRes != ERROR_SUCCESS)
    {
        return;
    }

    lRes = RegCreateKeyEx(
                            hKey,
                            L"_Key",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS | KEY_WOW64_32KEY,
                            NULL,
                            &hKey32,
                            NULL
                            );
    if(lRes != 0)
    {
        printf("key not created\n");
        return;
    }
    RegCloseKey(hKey32);
}
void TestRegistry()
{
    HKEY hKey = NULL;
    HKEY Key1;
    HKEY Key2;

    //Test4();

    //RegOpenKeyEx ( HKEY_LOCAL_MACHINE, L"Software", 0, KEY_ALL_ACCESS, &hKey );
    //hKey = OpenNode (L"\\REGISTRY\\MACHINE");
    //CreateOpenNode(hKey, L"Software", &Key1, KEY_WOW64_32KEY, L'V');
    //CreateOpenNode(Key1, L"YYYzzz", &Key2, KEY_WOW64_32KEY, L'V');




    //TestRegReflectKey ();


    //TestSharedResources ();

    //TestTypeLib ();
    //BasicRegReMapTest();
    //TestOpenHKCR(1,2);
    printf ("\n\n2nd test.....OpenCreateKeyTest ()");
    OpenCreateKeyTest ();
    //TestCreateHKCR ();

}

LPTSTR NextParam (
    LPTSTR lpStr
    )
/*++

Routine Description

    Point to the next parameter in the commandline.

Arguments:

    lpStr - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/
{
	WCHAR ch = L' ';
		

    if (lpStr == NULL )
        return NULL;

    if ( *lpStr == 0 )
        return lpStr;

    while (  ( *lpStr != 0 ) && ( lpStr[0] != ch )) {

		if ( ( lpStr [0] == L'\"')  || ( lpStr [0] == L'\'') )
			ch = lpStr [0];

        lpStr++;
	}

	if ( ch !=L' ' ) lpStr++;

    while ( ( *lpStr != 0 ) && (lpStr[0] == L' ') )
        lpStr++;

    return lpStr;
}

DWORD CopyParam (
    LPTSTR lpDestParam,
    LPTSTR lpCommandParam
    )
/*++

Routine Description

    Copy the current parameter to lpDestParam.

Arguments:

    lpDestParam - that receive current parameter
    lpCommandParam - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{
	DWORD dwLen = 0;
	WCHAR ch = L' ';

	*lpDestParam = 0;
	
	if ( ( lpCommandParam [0] == L'\"')  || ( lpCommandParam [0] == L'\'') ) {
		ch = lpCommandParam [0];
		lpCommandParam++;
	};


    while ( ( lpCommandParam [0] ) != ch && ( lpCommandParam [0] !=0 ) ) {
        *lpDestParam++ = *lpCommandParam++;
		dwLen++;

		if ( dwLen>255 ) return FALSE;
	}

	if ( ch != L' ' && ch != lpCommandParam [0] )
		return FALSE;
	else lpCommandParam++;

    *lpDestParam = 0;

	return TRUE;

}

///////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////

BOOL
ParseCommand ()


/*++

Routine Description

    Parse command line parameters. Get different options from
    command line parameters.

Arguments:

    None.


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{

    BOOL bSync = FALSE;

    LPTSTR lptCmdLine1 = GetCommandLine ();


    LPTSTR lptCmdLine = NextParam ( lptCmdLine1 );

    if ( lptCmdLine[0] == 0 )
        return FALSE;

    printf ("\nRunning Wow64 registry testing tool\n");

    while (  ( lptCmdLine != NULL ) && ( lptCmdLine[0] != 0 )  ) {

        if ( lptCmdLine[0] != '-' )
            return FALSE;

        switch ( lptCmdLine[1] ) {

        case L'C':  //sync ClsID
        case L'c':
            Wow64SyncCLSID ();
            break;

        case L'd':
            printf ("\n<TBD>Remove all the Keys from 32bit side that were copied from 64bit side");
            //CleanpRegistry ( );
            break;

        case L'D':
            printf ("\n<TBD>Remove all the Keys from 32bit side that were copied from 64bit side");
            //CleanpRegistry ();
            break;

       case L'p':
       case L'P':  // populate registry
            //CleanupWow64NodeKey ();
            PopulateReflectorTable ();
            break;

       case 't':
       case 'T':
            TestRegistry ();
            break;

        case L'r':
        case L'R':
            //
            //  run the reflector codes;
            //

            InitReflector ();
            if ( !RegisterReflector () ) {
                    printf ("\nSorry! reflector couldn't be register");
                    UnRegisterReflector ();
                    return FALSE;
            }

            printf ("\nSleeping for 100 min to test reflector codes ...........\n");
            Sleep (1000*60*100);

            UnRegisterReflector ();
            break;

        case L's':
        case L'S':
            bSync = TRUE;
            break;

        case L'a':
        case L'A':
            //
            // Analyze a key
            //
            AnalyzeNode (&lptCmdLine[2], bSync);
            break;


        default:
            return FALSE;
            break;
        }

        lptCmdLine = NextParam ( lptCmdLine );
    }

    return TRUE;
}

int __cdecl
main()
{
   
    if (!ParseCommand ()) {

        printf ( "\nUsages: w64setup [-c] [-C] [-d] [-D] [-r]\n");
        printf ( "\n        -c Copy from 32bit to 64bit side of the registry");
        printf ( "\n        -C Copy from 64bit to 32bit side of the registry");
        printf ( "\n");
        printf ( "\n        -d Remove all the Keys from 32bit side that were copied from 64bit side");
        printf ( "\n        -D Remove all the Keys from 64bit side that were copied from 32bit side");

        printf ( "\n");
        printf ( "\n        -r Run reflector thread");
        printf ( "\n        -A Analyze a key if that going to be reflected");

        printf ("\n");
        return 0;

    }

    printf ("\nDone.");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\wow64reg\refhlpr.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module will do the necessary things to setup initial registry for the redirection
    purpose.

//
//  Test case scenario
//      1. Open a ISN node and list content
//      2. Create a ISN node do 1.
//      3. Open a non ISN node and list
//      4. Create a non ISN node and list content
//

  Outstanding issue:
    reflector: If Key has been created on one side, we can reflect that on the other side.
               Deletion: Without any additional attribute it's impossible to track.

Author:

    ATM Shafiqul Khalid (askhalid) 18-Nov-1999

Revision History:

--*/


#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include "wow64reg.h"
#include <assert.h>
#include "reflectr.h"

VOID
DbgPrint(
    PCHAR FormatString,
    ...
    );

#define REFLECTOR_ENABLE_KEY L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64\\Reflector Setup"

ISN_NODE_TYPE ReflectorTableStatic[ISN_NODE_MAX_NUM]={
    { { L"REFLECT1"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes"},0 },    // alias to the classes root on the user hives
    //{ { L"REFLECT2"}, {L"\\REGISTRY\\USER\\*\\Software\\Classes"},0 },    // the first '*' is the user's SID
    { { L"REFLECT3"}, {L"\\REGISTRY\\USER\\*_Classes"},0 },    // alias to the classes root on the user hives
    { { L"REFLECT4"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run"},0 },    // Runonce Key
    { { L"REFLECT5"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce"},0 },    // Runonce Key
    { { L"REFLECT6"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx"},0 },    // Runonce Key
    { { L"REFLECT7"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\COM3"},0 },    // COM+ Key
    { { L"REFLECT8"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\COM3"},0 },    // COM+ Key
    { { L"REFLECT9"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Ole"},0 },    // OLE Key
    { { L"REFLECT10"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Ole"},0 },    // OLE Key
    { { L"REFLECT11"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\EventSystem"},0 },    // EventSystem
    { { L"REFLECT12"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\EventSystem"},0 },    // EventSystem
    { { L"REFLECT13"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\RPC"},0 },    // RPC
    { { L"REFLECT14"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\RPC"},0 },    // RPC
    { { L"REFLECT15"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\UnInstall"},0 },    // UnInstall Key
    { { L"REFLECT16"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UnInstall"},0 },    // UnInstall Key
    //{ { L"REFLECT15"},  {L"\\REGISTRY\\MACHINE\\SYSTEM\\TEST"},0 },
    { {L""}, {L""} }
    };

ISN_NODE_TYPE RedirectorTableStatic[ISN_NODE_MAX_NUM]={
    //{ { L"REDIRECT1"},  {L"\\REGISTRY\\MACHINE\\SYSTEM\\TEST"},0 },
    { { L"REDIRECT2"}, {L"\\REGISTRY\\USER\\*\\Software\\Classes"},0 },    // the first '*' is the user's SID
    { { L"REDIRECT3"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes"},0 },    // CLS ROOT
    { { L"REDIRECT4"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE"},0 },    // CLS ROOT
    { { L"REDIRECT5"}, {L"\\REGISTRY\\USER\\*_Classes"},0 },    // alias to the classes root on the user hives
    { {L""}, {L""} }
    };

ISN_NODE_TYPE *ReflectorTable = &ReflectorTableStatic[0]; // dynamically we can allocate later on.
ISN_NODE_TYPE *RedirectorTable = &RedirectorTableStatic[0];       // dynamically we can allocate later on.

ISN_NODE_TYPE TempIsnNode;

BOOL bInitialCopy  = FALSE;

VOID
SetInitialCopy ()
{
    bInitialCopy  = TRUE;
}

BOOL
ReflectSecurity (
    HKEY SrcKey,
    HKEY DestKey
    )
/*++

Routine Description:

  Copy security attribute from SrcKey to DestKey.

Arguments:

  SrcKey - Handle to a key..
  DestKey - handle to the destination key.

Return Value:

  TRUE if operation succeeded.
  FALSE otherwise. 

--*/
{

    PSECURITY_DESCRIPTOR SD;
    BYTE Buffer[2048]; // reflector only manages general purpose keys and will have smaller ACL
    

    LONG Ret, Len;
    LONG BufferLen = sizeof (Buffer);
    DWORD Count = 0;

    SD = (PSECURITY_DESCRIPTOR)Buffer;

    Len = BufferLen;
    Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
    if (Ret == ERROR_INSUFFICIENT_BUFFER ) {

        SD = VirtualAlloc( NULL, Len, MEM_COMMIT, PAGE_READWRITE );
        if (SD != NULL) {

            BufferLen = Len;
            Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
        } else SD = (PSECURITY_DESCRIPTOR)Buffer;
            
    }
    if (ERROR_SUCCESS == Ret )
        Ret = RegSetKeySecurity ( DestKey, DACL_SECURITY_INFORMATION, SD );
    Count +=Ret;
    

    Len = BufferLen;
    Ret = RegGetKeySecurity( SrcKey, GROUP_SECURITY_INFORMATION, SD, &Len);
    if (Ret == ERROR_INSUFFICIENT_BUFFER ) {

        if (SD != Buffer)
            VirtualFree (SD, 0,MEM_RELEASE);

        SD = VirtualAlloc( NULL, Len, MEM_COMMIT, PAGE_READWRITE );
        if (SD != NULL) {

            BufferLen = Len;
            Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
        } else SD = (PSECURITY_DESCRIPTOR)Buffer;
            
    }
    if (ERROR_SUCCESS == Ret )
        Ret = RegSetKeySecurity ( DestKey, GROUP_SECURITY_INFORMATION, SD );
    Count +=Ret;
    


    Len = BufferLen;
    Ret = RegGetKeySecurity( SrcKey, OWNER_SECURITY_INFORMATION, SD, &Len);
    if (Ret == ERROR_INSUFFICIENT_BUFFER ) {

        if (SD != Buffer)
            VirtualFree (SD, 0,MEM_RELEASE);

        SD = VirtualAlloc( NULL, Len, MEM_COMMIT, PAGE_READWRITE );
        if (SD != NULL) {

            BufferLen = Len;
            Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
        } else SD = (PSECURITY_DESCRIPTOR)Buffer;
            
    }
    if (ERROR_SUCCESS == Ret )
        Ret = RegSetKeySecurity ( DestKey, OWNER_SECURITY_INFORMATION, SD );
    Count +=Ret;
    

    Len = BufferLen;
    Ret = RegGetKeySecurity( SrcKey, SACL_SECURITY_INFORMATION, SD, &Len);
    if (Ret == ERROR_INSUFFICIENT_BUFFER ) {

        if (SD != Buffer)
            VirtualFree (SD, 0,MEM_RELEASE);

        SD = VirtualAlloc( NULL, Len, MEM_COMMIT, PAGE_READWRITE );
        if (SD != NULL) {

            BufferLen = Len;
            Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
        } else SD = (PSECURITY_DESCRIPTOR)Buffer;
            
    }
    if (ERROR_SUCCESS == Ret )
        Ret = RegSetKeySecurity ( DestKey, SACL_SECURITY_INFORMATION, SD );
    Count +=Ret;
    
    if (SD != Buffer)
            VirtualFree (SD, 0,MEM_RELEASE);

    if (Count != 0) {
        return FALSE;
    }
    return TRUE;
}

BOOL
GetDefaultValue (
    HKEY  SrcKey,
    WCHAR *pBuff,
    DWORD *Len
    )
/*++

Routine Description:

  retrieve the default value.

Arguments:

  SrcKey - Handle to a key default value need to be retrieved.
  pBuff - receiving the default value.
  Len - size of the buffer.

Return Value:

  TRUE if it can retrieve the value, 
  FALSE otherwise.

--*/
{
    DWORD Ret;

    Ret = RegQueryValueEx(
                        SrcKey,            // handle to key to query
                        NULL,
                        NULL,
                        NULL,
                        (PBYTE) &pBuff[0],
                        Len);

    if (Ret != ERROR_SUCCESS )
        return FALSE;
    return TRUE;
}

BOOL
NonMergeableValueCLSID (
    HKEY SrcKey,
    HKEY DestKey
    )
/*++

Routine Description:

  determine if a key related to an association should be merged.
  Rule: if the association refer to a CLSID that has InprocServer don't merge that.
  .doc default attrib will have another key x, and x's default attribute might have 
  CLSID. Now that clsID need to have either LocalServer or need to be present on the 
  other side.

Arguments:

  SrcKey - Handle to a key that need to be checked.
  DestKey - handle to the destination key that will receive the update.

Return Value:

  TRUE if we shouldn't merge value.
  FALSE otherwise. //catter will merge value.

--*/
{
    WCHAR Name[_MAX_PATH];
    WCHAR Buff[_MAX_PATH];
    WCHAR *pStr;
    DWORD dwBuffLen = 256;

    HKEY hClsID;
    DWORD dwCount;
    DWORD Ret;
    DWORD dwFlag = 0;

    BOOL bCLSIDPresent = TRUE;

    //
    //  get name to the key.
    //  get default value
    //     open the key under SrcKey
    //     try CLSID if exist
    //                  open the CLSID and check for localserver
    //                  Merge the key
    //     try classid on dest.
    //


    dwBuffLen = sizeof (Name ) / sizeof (Name[0]);
    if (!HandleToKeyName ( SrcKey, Name, &dwBuffLen ))
        return TRUE;  // ignore merging at this point, fardown the association.

    pStr = wcsstr (Name, L"\\.");  // consider only association like .doc

    //
    //  don't fall in the association category
    //
    if (pStr == NULL)
        return FALSE;  // value key should be merged
    if (wcschr (pStr+1, L'\\') !=NULL )
        return FALSE;  // value key should be merged

    //
    //  get the default string
    //

    
    if ( !GetDefaultValue (SrcKey, Buff, &dwBuffLen) )
        return TRUE;  // failed don't merge, check for insufficient buffer.

    wcscat (Buff, L"\\CLSID");


    //
    // Check which side you are checking, if src is 32bit you need to pass 32bit flag
    //
    dwBuffLen = sizeof (Name ) / sizeof (Name[0]);
    if (!HandleToKeyName ( SrcKey, Name, &dwBuffLen )) //get the name
        return TRUE;

    if (!Is64bitNode (Name) )
        dwFlag = KEY_WOW64_32KEY;

    Ret = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        Buff,
                        0,//OpenOption,
                        KEY_ALL_ACCESS | dwFlag,
                        &hClsID
                        );

    if ( Ret != ERROR_SUCCESS ) {
        if (Ret == ERROR_FILE_NOT_FOUND )
            return FALSE; // key doesn't exist 
        //
        // Try to find out if this assumption is true.
        // no CLSID you can merge because it doesn't associate any CLSID
        //
        return TRUE; //key might be bad or access denied.
    }

        dwBuffLen = sizeof (Buff ) / sizeof (Buff[0]);
        if ( !GetDefaultValue (hClsID, Buff, &dwBuffLen ) ) {

            RegCloseKey (hClsID);
            return TRUE;  // failed don't merge, couldn't get the CLSID
        }

        RegCloseKey (hClsID);
        //
        //  check if the CLSID has localserver
        //
        wcscpy (Name, L"CLSID\\");
        wcscat (Name, Buff );

        Ret = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        Name,
                        0,//OpenOption,
                        KEY_ALL_ACCESS | dwFlag,
                        &hClsID
                        );

        if ( Ret != ERROR_SUCCESS )
            bCLSIDPresent = FALSE; //clsid on source doesn't exist and hence no local server, i.e., no handler
        else  {
            dwBuffLen = sizeof (Name ) / sizeof (Name[0]);
            if (!HandleToKeyName ( hClsID, Name, &dwBuffLen )) //get the name
               return TRUE;
        }

        if ( bCLSIDPresent ) {
            dwCount =0;
            MarkNonMergeableKey ( Buff, hClsID, &dwCount );
            RegCloseKey (hClsID);

            if (dwCount != 0)
                return FALSE;

            bCLSIDPresent = FALSE; // must be an InProc
        }

        //
        // Now chek of local server, there might be some case where 
        // on the source there is one local server that don't exist on the dest, 
        // but in the future, that will get copied over.
        // 
        //
        

        //
        // Get mirror Name
        //
        GetMirrorName (Name, Buff);

        if ( (hClsID = OpenNode (Buff)) != NULL ) {
            RegCloseKey (hClsID);
            return FALSE; // mirror side has the handler CLSID
        }

        return TRUE; // no don't merge value associated with the src key.

}

BOOL
GetKeyTime (
    HKEY SrcKey,
    ULONGLONG *Time
    )
/*++

Routine Description:

  Get last update time associated with a key.


Arguments:

  SrcKey - handle to the key.

Return Value:

  TRUE if function succeed, FALSE otherwise.

--*/
{

    DWORD Ret;
    FILETIME ftLastWriteTime;


    Ret  = RegQueryInfoKey(
                        SrcKey, // handle to key to query
                        NULL,   // address of buffer for class string
                        NULL,   // address of size of class string buffer
                        NULL,   // reserved
                        NULL,   // address of buffer for number of
                                // subkeys
                        NULL,   // address of buffer for longest subkey
                                                 // name length
                        NULL,   // address of buffer for longest class
                                // string length
                        NULL,   // address of buffer for number of value
                                // entries
                        NULL,   // address of buffer for longest
                                // value name length
                        NULL,   // address of buffer for longest value
                                // data length
                        NULL,
                                // address of buffer for security
                                // descriptor length
                        &ftLastWriteTime  // address of buffer for last write
                                // time
                        );

    if ( Ret == ERROR_SUCCESS ) {
        *Time = *(ULONGLONG *)&ftLastWriteTime;  //copy the value
        return TRUE;
    }

    return FALSE;
}



VOID
UpdateTable (
     ISN_NODE_TYPE *Table,
     ISN_NODE_TYPE *TempIsnNode
     )
{
    DWORD dwCount=0;
    BOOL Found = FALSE;

    if ( !wcslen (TempIsnNode->NodeName) || !wcslen (TempIsnNode->NodeValue) )
        return;

    for ( dwCount=0;wcslen (Table[dwCount].NodeValue);dwCount++) {
        if (wcscmp (Table[dwCount].NodeValue, TempIsnNode->NodeValue) == 0 ) {
            Table[dwCount].Flag=1;  //already in the registry
            Found = TRUE;
        }
    }

    if (!Found) {
            //update the table with the node
            if ( dwCount >= ISN_NODE_MAX_NUM ) {
                Wow64RegDbgPrint ( ("\nSorry! The table is full returning..............."));
                return;
            }

            Table[dwCount].Flag=1;
            wcscpy (Table[dwCount].NodeName, TempIsnNode->NodeName);
            wcscpy (Table[dwCount].NodeValue, TempIsnNode->NodeValue);

            Table[dwCount+1].NodeName[0] = UNICODE_NULL;
            Table[dwCount+1].NodeValue[0] = UNICODE_NULL;
    }
}

BOOL
IsGUIDStrUnderCLSID (
    LPCWSTR Key
    )
/*++

Routine Description:

  pIsGuid examines the string specified by Key and determines if it
  is the correct length and has dashes at the correct locations.

Arguments:

  Key - The string that may or may not be a GUID

Return Value:

  TRUE if Key is a GUID (and only a GUID), or FALSE if not.

--*/

{
    int i;
    PWCHAR p;

    if ( (wcslen (Key) != 38) || (*Key != L'{' )) {
        return FALSE;
    }

    for (i = 0, p = (PWCHAR)(Key+1) ; i<36 ; p++, i++) {
        if (*p == L'-') {
            if (i != 8 && i != 13 && i != 18 && i != 23) {
                return FALSE;
            }
        } else if (i == 8 || i == 13 || i == 18 || i == 23) {
            return FALSE;
        } else if (!iswxdigit( *p )) //ifnot alphaneumeric
            return FALSE;
    }

    if ( *p != L'}')
        return FALSE;

    return TRUE;
}

BOOL
CreateWow6432ValueKey (
    HKEY DestKey,
    WOW6432_VALUEKEY_TYPE ValueType
    )
/*++

Routine Description:

    Create a Wow6432ValueKey under the node.

Arguments:

    DestKey - Handle to the dest Key.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    WOW6432_VALUEKEY Value;
    ULONGLONG temp;
    SYSTEMTIME sSystemTime;
    FILETIME sFileTime;

    Value.ValueType = ValueType;
    Value.Reserve = 0;



    GetSystemTime (&sSystemTime);
    if ( SystemTimeToFileTime( &sSystemTime, &sFileTime) ==0 )
        return FALSE;

    Value.TimeStamp = *(ULONGLONG *)&sFileTime;
    Value.TimeStamp += (1000*10000*VALUE_KEY_UPDATE_TIME_DIFF); //100 nano sec interval


    if ( RegSetValueEx(
                            DestKey,
                            (LPCWSTR )WOW6432_VALUE_KEY_NAME,
                            0,
                            REG_BINARY,
                            (const PBYTE)&Value,
                            sizeof (WOW6432_VALUEKEY)
                            ) != ERROR_SUCCESS ) {

                            Wow64RegDbgPrint ( ("\nSorry! couldn't create wow6432valueKey "));
                            return FALSE;
    }

    if (! GetKeyTime (DestKey, &temp))
        return FALSE;

    if (Value.TimeStamp < temp || Value.TimeStamp > (temp+(1000*10000*VALUE_KEY_UPDATE_TIME_DIFF)) )
        Wow64RegDbgPrint ( ("\nError in the time Stamp!!!!"));

    return TRUE;

}

BOOL
GetWow6432ValueKey (
    HKEY hKey,
    WOW6432_VALUEKEY *pValue
    )
/*++

Routine Description:

    If the specified Key have the Wow6432Value key return the structure.

Arguments:

    hKey - Handle to the Key to search the value key.
    pValue - Receive the structure.

Return Value:

    TRUE if the value can be quaried and exist.
    FALSE otherwise.

--*/
{




    DWORD Type;
    DWORD Len = sizeof (WOW6432_VALUEKEY);
    DWORD Ret;

    memset ( pValue, 0, sizeof (WOW6432_VALUEKEY)); // zeroing buffer

    if ( (Ret=RegQueryValueEx(
                        hKey,                               // handle to key to query
                        (LPCWSTR )WOW6432_VALUE_KEY_NAME,   // address of name of value to query
                        0,                                  // reserved
                        &Type,                              // address of buffer for value type
                        (PBYTE)pValue,                             // address of data buffer
                        &Len                                // address of data buffer size
                        )) == ERROR_SUCCESS )
                        return TRUE;
    return FALSE;
}


BOOL
MarkSingleNonMergeableKey (
    HKEY hParent,
    LPCWSTR KeyName
    )
/*++

Routine Description:

    Mark a key non mergeable.

Arguments:

    KeyName -  Name of the key to mark.
    hParent -  Handle to the parent.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    HKEY hKey;
    DWORD Ret;

    WOW6432_VALUEKEY Value;

    if ( RegOpenKey (hParent, KeyName, &hKey ) != ERROR_SUCCESS )
        return FALSE;


    GetWow6432ValueKey ( hKey, &Value ); //todo check return value

    if ( Value.ValueType != None ) {

        RegCloseKey (hKey );
        return FALSE; // already marked with some other type
    }

    Ret = CreateWow6432ValueKey ( hKey, NonMergeable);
    RegCloseKey (hKey );
    return Ret;
}

BOOL
MarkNonMergeableKey (
    LPCWSTR KeyName,
    HKEY hKey,
    DWORD *pMergeableSubkey
    )
/*++

Routine Description:

    Check all the key under hKey if they qualify to be non mergeable. 
    If so mark them non mergeable.

Arguments:

    KeyName -  Name of the Key. Normally all following rules is for guid type parent.
                 If parent qualify, complete path name can be extracted to compare againest grammer.
    hKey       - Handle to a open Key.
    pMergeableSubkey - caller receive total number of mergeable subkey.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

    // pMergeableSubkey==0 and return TRUE means there is nothing to reflect.

--*/
{

    //
    // 1. Inproc server is always non mergeable
    // 2. If there is no local server everything is nonmergeable
    // 3. If there is both LocalServer32 and InprocServer32 skip Inprocserver
    // 4. InprocHandler32 ??
    // 5. Typelib  check if the GUID point to a right content that can be copied.
    //

    //
    // check if the name is guid
    //

    DWORD LocalServer = 0;
    DWORD InprocServer32 = 0;

    ISN_NODE_TYPE Node;
    DWORD dwIndex;
    DWORD Ret;
    WCHAR FullKeyName[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;

    //
    // Check if the Key Fall under Classes\CLSID or \\Classes\\Wow6432Node\\CLSID
    //

    if ( !IsGUIDStrUnderCLSID ( KeyName ) )
        return TRUE; //No action is required

    if ( !HandleToKeyName ( hKey, FullKeyName, &dwLen )) {
        *pMergeableSubkey = 0;
        return TRUE; // FALSE
    }

    dwLen = wcslen (FullKeyName);
    if (dwLen <=39)
        return TRUE;
    dwLen-=39;  //skip the GUID because the handle point to guid

    if (!(_wcsnicmp ( FullKeyName+dwLen-14, L"\\Classes\\CLSID", 14) ==0 ||
        _wcsnicmp ( FullKeyName+dwLen-26, L"\\Classes\\Wow6432Node\\CLSID", 26) ==0 ||
        _wcsnicmp ( FullKeyName+dwLen-6, L"\\CLSID", 6) ==0)
        )
        return  TRUE;
    
    //don't reflect Key with name InProcServer32 or inprochandler
    if ( _wcsicmp (KeyName, (LPCWSTR)L"InprocServer32")==0 || _wcsicmp (KeyName, (LPCWSTR) L"InprocHandler32")==0) {

        *pMergeableSubkey = 0;
        return TRUE;
    }

    

    //Mark the inprocserver
    //Mark InprocHandler

    //if no localserver mark all

    //Enumerate all the Keys

    *pMergeableSubkey = 0;
    dwIndex = 0;
    LocalServer =0;

    for (;;) {

        DWORD Len = sizeof (Node.NodeValue)/sizeof (WCHAR);
        Ret = RegEnumKey(
                          hKey,
                          dwIndex,
                          Node.NodeValue,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;
        if ( !wcscmp  (Node.NodeValue, (LPCWSTR )NODE_NAME_32BIT) )
            continue;

        if ( !_wcsicmp (Node.NodeValue, (LPCWSTR)L"InprocServer32") || !_wcsicmp (Node.NodeValue, (LPCWSTR) L"InprocHandler32")) {
            MarkSingleNonMergeableKey ( hKey, Node.NodeValue );
            InprocServer32 = 1;
        } else if ( !_wcsicmp ((LPCWSTR)Node.NodeValue, (LPCWSTR)L"LocalServer32")) {
                    LocalServer=1;
                    (*pMergeableSubkey)++;
        }
        else (*pMergeableSubkey)++;

    }
    // if Ret != NomoreKey then you are in trouble

    //
    //  you might try 2nd pass to evaluate rest of the key
    //

    if ( LocalServer == 0 )
        *pMergeableSubkey = 0;  //there might be some copy key to merge

    return TRUE;
}

BOOL
ChangedInValueKey(
    HKEY DestKey,
    PWCHAR pValueName,
    PBYTE pBuff,
    DWORD BuffLen
    )
/*++

Routine Description:

    This routine check for a particular value key and return if that
    need to be copied into the destination key.

Arguments:

    DestKey - Handle to the dest Key.
    pValueName - Name of the value key need to be checked into DestKey
    pBuff - buffer that contain the value.
    BuffLen - length of the buffer

Return Value:

    TRUE if destination need to be updated.
    FALSE otherwise.

--*/
{
    BYTE TempBuff[256];
    DWORD Ret;
    DWORD Type;
    DWORD TempBuffLen = 256;

    Ret =RegQueryValueEx(
                        DestKey,
                        pValueName,
                        0,
                        &Type,
                        TempBuff,
                        &TempBuffLen
                        );
    if ( (Ret != ERROR_SUCCESS ) || (BuffLen != TempBuffLen ) )
        return TRUE;

    if (memcmp (TempBuff, pBuff, BuffLen) != 0)
        return TRUE;

    return FALSE;
}

BOOL
MergeK1K2Value (
    HKEY SrcKey,
    HKEY DestKey,
    DWORD dwFlag
    )
/*++

Routine Description:

    Copy value key from the node pointed by SrcKey to the DestKey skipping the special wow6432 node.

Arguments:

    SrcKey - Source Key Node.
    DestKey - Handle to the dest Key.
    dwFlag - option flag to merge value key.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    ISN_NODE_TYPE Node;
    DWORD dwIndex =0;
    DWORD Ret;

    WOW6432_VALUEKEY ValueSrc;
    WOW6432_VALUEKEY ValueDest;
    ULONGLONG TimeSrc;
    ULONGLONG TimeDest;

    DWORD CreateWowValueKey = FALSE;


    //
    // CopyValue
    //

    //
    // find the wow6432valuekey and interpret the case if value keys need to be copied.
    // Compare the same wow6432node from both Key.
    //

    GetWow6432ValueKey ( SrcKey, &ValueSrc);
    GetWow6432ValueKey ( DestKey, &ValueDest);


    if ( !GetKeyTime ( SrcKey, &TimeSrc)  || ! GetKeyTime ( DestKey, &TimeDest) ) {

        Wow64RegDbgPrint ( ("\nSorry! Couldn't get time stamp"));
        return FALSE;
    }


    if (!( dwFlag & DESTINATION_NEWLY_CREATED )) { //timestamp is always higher for newly created key by reflector

        //
        // check which one is new
        //
        if ( ValueDest.TimeStamp ==0 || ValueSrc.TimeStamp ==0 ) {

            //check only Key time stamp
            if ( TimeSrc < TimeDest ) return TRUE;

        } else if ( ValueSrc.TimeStamp > TimeSrc ||   //nothing has been changed on src
            ( TimeDest > TimeSrc ) //dest has newer valid stamp
            )
            return TRUE;  //nothing has been changed since last scan
    }

    if ( NonMergeableValueCLSID ( SrcKey, DestKey))
        return TRUE;

    //
    // Reflect security attributes
    //
    ReflectSecurity (SrcKey, DestKey);

    for (;;) {
        DWORD Type;
        DWORD Len1 =  sizeof(Node.NodeName);
        DWORD Len2 =  sizeof(Node.NodeValue);

                Ret = RegEnumValue(
                              SrcKey,
                              dwIndex,
                              Node.NodeName,
                              &Len1,
                              0,
                              &Type,
                              (PBYTE)&Node.NodeValue[0],
                              &Len2
                              );

                if ( Ret != ERROR_SUCCESS)
                    break;
                dwIndex++;

                //
                // skip the value if its wow6432 value key. Advapi will filter the key in the long run
                //

                if ( !wcscmp  (Node.NodeName, (LPCWSTR )WOW6432_VALUE_KEY_NAME) )
                    continue;
                //
                // check first if any changes in the value key
                //
                if (!ChangedInValueKey(
                            DestKey,
                            Node.NodeName,
                            (PBYTE)&Node.NodeValue[0],
                            Len2
                    ) )
                    continue;

                if  (dwFlag & PATCH_PATHNAME )
                    PatchPathName ( Node.NodeValue );

                Ret = RegSetValueEx(
                            DestKey,
                            Node.NodeName,
                            0,
                            Type,
                            (PBYTE)&Node.NodeValue[0],
                            Len2
                            );
             if ( Ret != ERROR_SUCCESS ) {

                 Wow64RegDbgPrint ( ("\nSorry! couldn't set Key value"));
             } else {

                 CreateWowValueKey = TRUE; //need to update the wow64keys.
                 if  (dwFlag & DELETE_VALUEKEY ) {

                     //delete the value key from the sources
                    RegDeleteValue (SrcKey, Node.NodeName);
                    dwIndex = 0; // start the loop again
                 }
             }
    }

    if ( dwIndex == 0 )   // for an empty key you need to write the value
        CreateWowValueKey = TRUE;

    if ( ( CreateWowValueKey) && (!(NOT_MARK_DESTINATION & dwFlag ) ) ) {

                    if ( !CreateWow6432ValueKey ( DestKey, Copy) )
                        Wow64RegDbgPrint ( ("\nSorry! Couldn't create wow6432ValueKey..."));
                }

    //
    // set attribute on the parent side that key has been reflected
    //
    if  ( CreateWowValueKey && !(NOT_MARK_SOURCE & dwFlag) )
    if ( !CreateWow6432ValueKey ( SrcKey, Reflected ) ) {
        Wow64RegDbgPrint ( ("\nSorry! couldn't create wow6432ValueKey on the source."));
        return FALSE;
    }

    return TRUE;
}


BOOL 
SpecialReflectableKey (
    HKEY SrcKey,
    HKEY DestKey
    ) 
/*++

Routine Description:

    This will determine if a certain key shouldn't be scanned for possible reflection.

Arguments:

    SrcKey - Source Key Node.
    DestKey - Handle to destination key.

Return Value:

    TRUE if the key shouldn't be scanned.
    FALSE otherwise.

--*/

{
    WCHAR Node[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
   

    if ( !HandleToKeyName ( SrcKey, Node, &dwLen ))
        return TRUE; // on error betrter skip the key

    //
    // Check if its a TypeLib
    //
    //
    // Hard coded no reflection for \Installer Key.
    //
    if (_wcsnicmp (Node, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\Installer", sizeof (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\Installer")/sizeof (WCHAR) )==0)
        return TRUE;

    if (_wcsnicmp (Node, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Installer", sizeof (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\Installer")/sizeof (WCHAR) )==0)
        return TRUE;


    if (_wcsicmp (Node, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\TypeLib")==0) {
        //ProcessTypeLib (SrcKey, DestKey, TRUE);
        return TRUE;
    }

    
    if (_wcsicmp (Node, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\TypeLib")==0) {
        //ProcessTypeLib (SrcKey, DestKey, FALSE);
        return TRUE;
    }


    

    return FALSE;
}

void
MergeK1K2 (
    HKEY SrcKey,
    HKEY DestKey,
    DWORD OptionFlag
    )
/*++

Routine Description:

    Copy contect from the node pointed by SrcKey to the DestKey skipping the special wow6432 node.

    Cases:
    1. Reflect everything from K1 to K2: done
    2. Reflect everything from K2 to K1: <TBD>
    3. Delete  everything from K1 which was a copy from K1 and doesn't exist over there <TBD>
    4. Delete  everything from K2 which was a copy from K2 and doesn't exist over there <TBD>

Arguments:

    SrcKey - Source Key Node.
    DestKey - Handle to the dest Key.
    OptionFlag - determine behavior of the reflection

Return Value:

    None.

--*/

{

    WCHAR Node[_MAX_PATH];
    DWORD dwIndex =0;
    DWORD Ret;
    DWORD dwNewOptionFlag = 0;

    HKEY Key11;
    HKEY Key21;


    //
    // Copy Values first
    //

    if ( SpecialReflectableKey (SrcKey, DestKey) )
        return;

    if ( GetReflectorThreadStatus () == PrepareToStop )
        return; // thread going to stop soon

    if  ( ! (OptionFlag & DELETE_FLAG ) )
        MergeK1K2Value ( SrcKey,DestKey, OptionFlag );

    //
    //  Copy subKeys
    //


    dwIndex = 0;
    for (;;) {

        DWORD ToMergeSubKey =1;
        BOOL MirrorKeyExist = FALSE;
        WOW6432_VALUEKEY ValueSrc;  

        DWORD Len = sizeof (Node)/sizeof (Node[0]);
        Ret = RegEnumKey(
                          SrcKey,
                          dwIndex,
                          Node,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;
        if ( !wcscmp  (Node, (LPCWSTR )NODE_NAME_32BIT) )
            continue;


        Ret = RegOpenKeyEx(SrcKey, Node, 0, KEY_ALL_ACCESS, &Key11);
        if (Ret != ERROR_SUCCESS) {
            continue;
        }

        if (!MarkNonMergeableKey (Node, Key11, &ToMergeSubKey ) ) {
            RegCloseKey (Key11);
            continue;
        }

        if ( ToMergeSubKey == 0 ){
            RegCloseKey (Key11);
            continue;
        } // no subkey to merge
       

        GetWow6432ValueKey ( Key11, &ValueSrc);
        if ( ValueSrc.ValueType == NonMergeable ) {
            RegCloseKey (Key11);
            continue;
        }

        //
        // Tryto open first if fail then create
        //
        if ((Ret = RegOpenKeyEx(DestKey, Node, 0, KEY_ALL_ACCESS, &Key21))
            == ERROR_SUCCESS)
            MirrorKeyExist = TRUE;

        //
        // Check if the mirror key is a original Key
        //
        if ( MirrorKeyExist )  {
            WOW6432_VALUEKEY ValueDest;
            GetWow6432ValueKey ( Key21, &ValueDest);
            if ( ( ValueDest.ValueType == None && ValueDest.TimeStamp!=0 ) ||
                ( ValueDest.ValueType == NonMergeable ) )
            {  //doesn't make any sense to merge down.
                printf ("\nClosing here...");
                RegCloseKey (Key11);
                RegCloseKey (Key21);
                continue;
            }

        }

        //
        // check the deletion case: if the dest isn't empty
        //

        if (!MirrorKeyExist) {  //The key doesn't exist on the other side

            //
            // See if the src key is a copy
            //
            

            //
            //  if its a copy you shouldn't try to create the key
            //  Rather you might delete the Key
            //
            if ( ValueSrc.ValueType == Copy || ValueSrc.ValueType == Reflected ) {

                RegCloseKey (Key11);
                //
                //  Delete the subKey
                //
                if ( DeleteKey( SrcKey, Node, 1) == ERROR_SUCCESS) {
                    dwIndex--; //you needn't to increase index otherwise skip
                    //Wow64RegDbgPrint ( ("\nDeleting copied Key: %S",Node.NodeValue));
                } else
                    Wow64RegDbgPrint ( ("\nCouldn't delete Key: %S, Error:%d",Node, Ret));

                continue;

            } else {

                //
                // if it has already been reflected do you need to create
                // Mark the Key as copied Key
                //
                if ( ValueSrc.ValueType == None ||  ValueSrc.ValueType == Reflected) {  //todo make sure reflected key should be there
                   if ( (Ret = RegCreateKey(DestKey, Node, &Key21) ) != ERROR_SUCCESS)
                       Wow64RegDbgPrint ( ("\nCouldn't create Key: %S, Error:%d",Node, Ret));
                   else {
                       MirrorKeyExist = TRUE; //just created the mirror key
                       dwNewOptionFlag = DESTINATION_NEWLY_CREATED;
                   }
                }
            }
        }

        if (!MirrorKeyExist) {
            RegCloseKey (Key11);
            continue;
        }

        MergeK1K2 ( Key11, Key21, OptionFlag |  dwNewOptionFlag );
        RegCloseKey (Key11);
        RegCloseKey (Key21);

    }
}

BOOL
MergeKeySrcDest(
    PWCHAR Src,
    PWCHAR Dest
    )
/*++

Routine Description:

    Copy contect from the src node to the dest  node.

Arguments:

    Src - Name of the src Node.
    Dest - Name of the dest Node.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    BOOL Ret = TRUE;
    HKEY Key1;
    HKEY Key2;

    Key1 = OpenNode (Src);
    if (Key1==NULL )
        return FALSE;

    Key2 = OpenNode (Dest );
    if (Key2==NULL ) {
        RegCloseKey (Key1);
        return FALSE;
    }

    MergeK1K2 (Key1, Key2, 0);  //you need to return right value

    RegCloseKey (Key1);
    RegCloseKey (Key2);

    //
    // if its a delete and Key2 is empty should you delete that?
    //

    return Ret;

}

BOOL
SyncNode (
    PWCHAR NodeName
    )
/*++

Routine Description:

    Sync registry from a given point.

Arguments:

    NodeName - Name of the registry from where the node need to be synced.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    WCHAR DestNode[_MAX_PATH];
    BOOL b64bitSide=TRUE;
    BOOL Ret = TRUE;

    DestNode[0] = UNICODE_NULL;

    //
    // must check the value if that exist
    //

    if ( Is64bitNode ( NodeName )) {

        Map64bitTo32bitKeyName ( NodeName, DestNode );
    } else {

        b64bitSide = FALSE;
        Map32bitTo64bitKeyName ( NodeName, DestNode );
    }

    //
    // if both name are same you can return immediately.
    //

    Wow64RegDbgPrint ( ("\nvalidating nodes in  SyncNode :%S==>\n\t\t\t%S", NodeName, DestNode));
    if (!wcscmp ( NodeName, DestNode ) )
        return TRUE; // nothing to do same thing

    Ret = MergeKeySrcDest( NodeName, DestNode );  //merge both way??
    return Ret & MergeKeySrcDest( DestNode, NodeName  );
    
}

BOOL
MergeContent (
    PWCHAR Chield,
    DWORD FlagDelete,
    DWORD dwMergeMode
    )
/*++

Routine Description:

    Copy contect from the parent node to chield node. Parent node would be just immediate
    parent. 

Arguments:

    Clield - Name of the chield with complete path to copy.
    FlagDelete - if this flag is set the its delete operation for all those reflected Keys.
    dwMergeMode - 0 means the destination node would be 32bit side
                  1 means the destination node would be 64bit side

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    ISN_NODE_TYPE Parent;
    PWCHAR p;

    HKEY Key1;
    HKEY Key2;

    p  = wcsstr (Chield, (LPCWSTR)NODE_NAME_32BIT);
    if ( p != NULL ) {
        wcsncpy (Parent.NodeValue, Chield, p-Chield-1);
        Parent.NodeValue[p-Chield-1] = UNICODE_NULL;

    } else return FALSE;



    Key1 = OpenNode (Parent.NodeValue);
    if (Key1==NULL )
        return FALSE;

    Key2 = OpenNode (Chield );
    if (Key2==NULL ) {
        RegCloseKey (Key1);
        return FALSE;
    }

    if ( dwMergeMode == 0 )      // 64bit side to 32bit side
        MergeK1K2 (Key1, Key2, 0 );
    else if ( dwMergeMode == 1)  // 32bit to 64bit side
        MergeK1K2 (Key2, Key1, 0 );

    RegCloseKey (Key1);
    RegCloseKey (Key2);

    return TRUE;

}

BOOL
ValidateNode (
    PWCHAR Parent,
    PWCHAR SubNodeName,
    DWORD Mode, //one means validate all node under parent and using subnode
    DWORD FlagDelete,
    DWORD dwMergeMode
    )
/*++

Routine Description:

    Validate node. if node exist skip if doesn't then create the node and then return.

Arguments:

    Parent - Name of the parent.
    SubNodeName - Name of the node under parent that need to be validated.
    Mode - 0 means Subnode is under the parent.
           1 means there were wild card and the subnode is under all key under parent.
    FlagDelete - if this flag is set then the content need to be deleted.
    dwMergeMode - 0 means the destination node would be 32bit side
                  1 means the destination node would be 64bit side


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/

{
    PWCHAR SplitLoc;
    DWORD Ret;
    WCHAR  KeyName[256]; //this is just single node name
    WCHAR  TempIsnNode2[MAX_PATH];

    if (SubNodeName == NULL) {
        //then its only with the parent
        CheckAndCreateNode (Parent);

        //
        // you can try to copy here
        //

        return MergeContent ( Parent, FlagDelete, dwMergeMode);

    }

    if (SubNodeName[0] == UNICODE_NULL)
        return TRUE;

    if ( Mode == 1) {

        HKEY Key = OpenNode (Parent);
        //
        //  loop through all the subkey under parent
        //

        DWORD dwIndex =0;
        for (;;) {

            DWORD Len = sizeof ( KeyName)/sizeof (WCHAR);
            Ret = RegEnumKey(
                              Key,
                              dwIndex,
                              KeyName,
                              Len
                              );
            if (Ret != ERROR_SUCCESS)
                break;

            if (Parent[0] != UNICODE_NULL) {

                wcscpy ( TempIsnNode2, Parent);
                wcscat (TempIsnNode2, (LPCWSTR )L"\\");
                wcscat (TempIsnNode2, KeyName);

            } else   wcscpy (TempIsnNode2, KeyName);

            ValidateNode (TempIsnNode2, SubNodeName, 0, FlagDelete, dwMergeMode);

            dwIndex++;
        }
        
        if (ERROR_NO_MORE_ITEMS != Ret)
            return FALSE;

        RegCloseKey (Key);
        return TRUE;
    }
    //
    // No wild card here
    //
    if ( ( SplitLoc = wcschr (SubNodeName, L'*') ) == NULL ) {
        if (Parent[0] != UNICODE_NULL) {

            wcscpy ( TempIsnNode2, Parent);
            wcscat (TempIsnNode2, (LPCWSTR )L"\\");
            wcscat (TempIsnNode2, SubNodeName);

        } else
            wcscpy (TempIsnNode2, SubNodeName);

        return ValidateNode (TempIsnNode2, NULL, 0, FlagDelete, dwMergeMode);

    }

    assert ( *(SplitLoc-1) == L'\\');
    *(SplitLoc-1) = UNICODE_NULL;
    SplitLoc++;
    if (*SplitLoc == L'\\')
        SplitLoc++;

    if (Parent[0] != UNICODE_NULL) {
        wcscat (Parent, (LPCWSTR )L"\\");
        wcscat (Parent, SubNodeName);
    } else
        wcscpy (Parent, SubNodeName);

    return ValidateNode (Parent, SplitLoc, 1, FlagDelete, dwMergeMode); //mode 1 means loop within all

    //for any wildcard split the string

}

BOOL
Is64bitNode (
    WCHAR *pName
    )
/*++

Routine Description:

    Check if the given name is 64bit.

Arguments:

    pName - Name of the Key.


Return Value:

    TRUE if the name is 64bit.
    FALSE otherwise.

--*/
{
    PWCHAR pTemp;
    WCHAR  Buff[_MAX_PATH];
    WCHAR  WowNodeName[1+sizeof (NODE_NAME_32BIT)];

    wcscpy (WowNodeName, NODE_NAME_32BIT);
    _wcsupr (WowNodeName);
    wcscpy (Buff, pName );
    _wcsupr (Buff);


    if ( ( pTemp = wcsstr (Buff, WowNodeName) ) == NULL )
        return TRUE;

    if ( *(pTemp-1) != L'\\' ) // check that wow64 is not in the middle of name
        return TRUE;

    return FALSE;
}

BOOL
GetMirrorName (
    PWCHAR Name,
    PWCHAR MirrorName
    )
/*++

Routine Description:

    Return the Mirror name of the Key, ie., if the input is 64 bit it 
    will try to get 32bit name and vice versa.

Arguments:

    Name - name of the key.
    MirrorName - receive the mirror key name.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.  

--*/
{
     

    if ( Is64bitNode ( Name) )
        Map64bitTo32bitKeyName ( Name, MirrorName );
    else
        Map32bitTo64bitKeyName ( Name, MirrorName );
    return TRUE;
}

BOOL
CreateIsnNodeSingle(
    DWORD dwIndex
    )
/*++

Routine Description:

    This function basically start merging from the root of a given key.

Arguments:

    dwIndex - index to the reflector table.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.  

--*/
{
        ISN_NODE_TYPE IsnNode;
        BOOL b64bitSide=TRUE;

        Wow64RegDbgPrint ( ("\nvalidating nodes %S", ReflectorTable[dwIndex].NodeValue));
        //DbgPrint  ("\nvalidating nodes %S", ReflectorTable[dwIndex].NodeValue);

            if (_wcsnicmp (
                ReflectorTable[dwIndex].NodeValue,
                (LPCWSTR )WOW64_RUNONCE_SUBSTR,
                wcslen ((LPCWSTR )WOW64_RUNONCE_SUBSTR) ) == 0 ) {
                return HandleRunonce ( ReflectorTable[dwIndex].NodeValue );
            }


            if ( !wcschr (ReflectorTable[dwIndex].NodeValue, L'*') ) // no wildcard
                return SyncNode ( ReflectorTable[dwIndex].NodeValue );

            //
            // Check for runonce Key
            //

            wcscpy (TempIsnNode.NodeValue, ReflectorTable[dwIndex].NodeValue);
            wcscat (TempIsnNode.NodeValue, (LPCWSTR )L"\\");

            wcscat (TempIsnNode.NodeValue, (LPCWSTR )NODE_NAME_32BIT);

            Wow64RegDbgPrint ( ("\nCopying Key %S==>%S", IsnNode.NodeValue, TempIsnNode.NodeValue));
            ValidateNode (
                IsnNode.NodeValue,
                TempIsnNode.NodeValue,
                0,
                0, // last 0 means creation
                0  // Merge 64bit side to 32bit side
                );

            ValidateNode (
                IsnNode.NodeValue,
                TempIsnNode.NodeValue,
                0,
                0, // last 0 means creation
                1
                );
    return TRUE;

}

BOOL
CreateIsnNode()
/*++

Routine Description:

    This function basically start merging using all entry in the reflector table.

Arguments:

    None.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.  

--*/
{
    ISN_NODE_TYPE IsnNode;
    DWORD dwIndex;

    for ( dwIndex=0;wcslen (RedirectorTable[dwIndex].NodeValue);dwIndex++) {

            IsnNode.NodeValue[0] = UNICODE_NULL;
            wcscpy (TempIsnNode.NodeValue, RedirectorTable[dwIndex].NodeValue);
            wcscat (TempIsnNode.NodeValue, (LPCWSTR )L"\\");

            wcscat (TempIsnNode.NodeValue, (LPCWSTR )NODE_NAME_32BIT);
            Wow64RegDbgPrint ( ("\nCopying Key %S==>%S", IsnNode.NodeValue, TempIsnNode.NodeValue));
            ValidateNode (
                IsnNode.NodeValue,
                TempIsnNode.NodeValue,
                0,
                0, // last 0 means creation
                0  // Merge 64bit side to 32bit side
                );

            ValidateNode (
                IsnNode.NodeValue,
                TempIsnNode.NodeValue,
                0,
                0, // last 0 means creation
                1  // Merge 32bit side to 64bit side
                );
    }
    return TRUE;
}

BOOL
AllocateTable (
    HKEY Key,
    ISN_NODE_TYPE **Table
    )
/*++

Routine Description:

    This function will dynamically allocate memory for the reflector thread.
    Currently its implemented as a static table with around 30 entry.

Arguments:

    Key - entry in the registry that will have the initial table information.
    Table - Table that will point at the new location.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.  

--*/
{

    //
    // determine the number of subkey and that would determine the size
    //
    return TRUE;
}

BOOL
InitializeIsnTable ()
/*++

Routine Description:

    Initialize the NodeTable. It merge the value from the registry as well as
    hardcoded value

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    HKEY Key;
    HKEY Key1;
    LONG Ret;
    DWORD dwIndex=0;

    Ret = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        (LPCWSTR ) WOW64_REGISTRY_SETUP_KEY_NAME_REL,
                        0,
                        KEY_ALL_ACCESS,
                        &Key
                        );

    if (Ret != ERROR_SUCCESS) {
        Ret = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        (LPCWSTR )L"SOFTWARE\\Microsoft",
                        0,
                        KEY_ALL_ACCESS,
                        &Key
                        );
        if (Ret != ERROR_SUCCESS )
            return FALSE;

        if ((Ret = RegOpenKeyEx (Key, (LPCWSTR )L"WOW64\\ISN Nodes", 0, KEY_ALL_ACCESS, &Key1)) != ERROR_SUCCESS )
            if ((Ret = RegCreateKey (Key, (LPCWSTR )L"WOW64\\ISN Nodes", &Key1)) != ERROR_SUCCESS) {
                RegCloseKey (Key);
                return FALSE;
            }

         RegCloseKey (Key);
         Key=Key1;
    }

    //if (!AllocateTable (Key, &RedirectorTable ) )
      //  return FALSE;

    //
    // Now Key point to the right location
    //

    RedirectorTable[0].NodeName[0]=UNICODE_NULL; //initialize the table with empty
    RedirectorTable[0].NodeValue[0]=UNICODE_NULL;

    for (;;) {
        DWORD Type, Len1 = sizeof ( TempIsnNode.NodeName );
        DWORD Len2 =  sizeof ( TempIsnNode.NodeValue );
                Ret = RegEnumValue(
                              Key,
                              dwIndex,
                              TempIsnNode.NodeName,
                              &Len1,
                              0,
                              &Type,
                              (PBYTE)&TempIsnNode.NodeValue[0],
                              &Len2
                              );
                //see if its in the table
                if ( Ret != ERROR_SUCCESS)
                    break;

                dwIndex++;
                if (Type != REG_SZ )
                    continue;

                UpdateTable (RedirectorTable, &TempIsnNode);
    }

    RegCloseKey (Key);
    return TRUE;
}


BOOL
InitializeIsnTableReflector ()
/*++

Routine Description:

    Initialize the NodeTable for the reflector. It merge the value from the registry as
    well as hardcoded value

Arguments:

    Mode - Operation mode
           0 - default, it update the table and rewrite the table in the registry.
           1 - means only update the table, don't overwrite in the registry.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    HKEY Key;
    HKEY Key1;
    LONG Ret;
    DWORD dwIndex=0;


    Ret = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        (LPCWSTR ) WOW64_REGISTRY_SETUP_REFLECTOR_KEY,
                        0,
                        KEY_ALL_ACCESS,
                        &Key
                        );

    if (Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry!! couldn't open key list at %S", WOW64_REGISTRY_SETUP_REFLECTOR_KEY));
        return FALSE;
    }


    //
    // Now Key point to the right location
    //


    //if (!AllocateTable (Key, &ReflectorTable ) )
      //  return FALSE;

    ReflectorTable[0].NodeName[0]=UNICODE_NULL; //initialize the table with empty
    ReflectorTable[0].NodeValue[0]=UNICODE_NULL;

    for (;;) {
        DWORD Type, Len1 = sizeof ( TempIsnNode.NodeName );
        DWORD Len2 =  sizeof ( TempIsnNode.NodeValue );
                Ret = RegEnumValue(
                              Key,
                              dwIndex,
                              TempIsnNode.NodeName,
                              &Len1,
                              0,
                              &Type,
                              (PBYTE)&TempIsnNode.NodeValue[0],
                              &Len2
                              );
                //see if its in the table
                if ( Ret != ERROR_SUCCESS)
                    break;

                dwIndex++;
                if (Type != REG_SZ )
                    continue;

                UpdateTable (ReflectorTable, &TempIsnNode);

    }


    return TRUE;
}

BOOL
StartReflector ()
/*++

Routine Description:

    Start the reflector thread.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    HKEY hWowSetupKey;
    WCHAR RefEnableKey[256]; // only a defined key

    if ((hWowSetupKey = OpenNode (REFLECTOR_ENABLE_KEY))!=NULL) {
        RegCloseKey ( hWowSetupKey );
        return FALSE; //reflector couldn't be register because it's disabled now, because of reflection code in advapi.
    }

    //
    // Sync all CLDids
    //

    Wow64SyncCLSID();

    //
    // Now disable the reflector forcefully
    //
    wcscpy (RefEnableKey, REFLECTOR_ENABLE_KEY);
    if (CreateNode (RefEnableKey)) 
        return FALSE; //reflector couldn't be register because it's disabled now, because of reflection code in advapi.

    //
    // This will be called at the end of GUI mode setup and runonce key can be processed here.
    //

    //return FALSE; // eventully reflector service will go away.
    return RegisterReflector ();

}

BOOL
StopReflector ()
/*++

Routine Description:

    Stop the reflector thread.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    return UnRegisterReflector ();

}

BOOL
PatchPathName (
    PWCHAR pName
    )
/*++

Routine Description:

    Patch pathname so that it point to the right location.
    The value might have multiple system32.

Arguments:

    pName - name to the path.

Return Value:

    TRUE if the function already patched the name.
    FALSE otherwise.

--*/

{
    WCHAR  pBuff[512+20];
    WCHAR  pBackup[512+20];
    PWCHAR pLoc;
    BOOL bRet = FALSE;

    DWORD Len;

    //if there is any system32 replace that with WOW64_SYSTEM_DIRECTORY_NAME
    PWCHAR pTemp;

    Len = wcslen ( pName );
    if (  Len > 512 || Len==0 )
        return FALSE; //too long or too small to patch

    wcscpy (pBackup, pName ); // backup the name to keep case as it was
    wcscpy (pBuff, pName );
    _wcsupr (pBuff);

    pLoc = pBuff;

    for (;;) {

        pTemp = wcsstr (pLoc, L"SYSTEM32");  //todo check if this should be case incensative
        if (pTemp == NULL )
            return bRet; //nothing to patch

        //
        // sanity check
        //
        Len = wcslen (L"SYSTEM32");
        if ( pTemp[Len] != UNICODE_NULL ) {
            if ( pTemp[Len] != L'\\' ) {
                pLoc++;
                continue; //only patch system32 or system32\?*
            }
        }

        wcscpy (pName + (pTemp-pBuff), WOW64_SYSTEM_DIRECTORY_NAME );
        wcscat (pName,  pBackup + (pTemp-pBuff)+wcslen (L"SYSTEM32")) ;
        pLoc++;
        bRet = TRUE;
    }

    return TRUE;
}

BOOL
HandleRunonce(
    PWCHAR pKeyName
    )
/*++

Routine Description:

    Its a special case handling runonce key in the registry. Like 32bit apps can register
    something that need to be reflected on the 64bit side so that right things happen.

Arguments:

    pKeyName - name of the key, there might be multiple one like run, runonce, runonceex

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    WCHAR pName64[256];
    HKEY Key1;
    HKEY Key2;

    Map32bitTo64bitKeyName ( pKeyName, pName64 );

    if ( (Key1 = OpenNode ( pKeyName ) ) == NULL )
        return FALSE;

    if ( (Key2 = OpenNode ( pName64 ) ) == NULL ) {
        RegCloseKey (Key1);
        return FALSE;
    }

    Wow64RegDbgPrint ( ("\nCopying runonce Key %S", pKeyName));

    //
    // make source taking 64bit name
    // Read check the timestamp on the source and the dest.
    // If src is the newer copy content otherwise ignore it.
    // PatchContent
    //


    MergeK1K2Value ( Key1, Key2, PATCH_PATHNAME | DELETE_VALUEKEY | NOT_MARK_SOURCE | NOT_MARK_DESTINATION );
    

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\regremap.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    regredir.c

Abstract:

    This module contains the APis to redirect 32bit registry calls. All 32bit wow process must
    use following set of wowregistry APIs to manipulate registry so that 32-bit and 64-bit registry
    can co exist in the same system registry.

    Some functionality hasn't been optimized yet. After successful implementation those need to
    be optimized.

Author:

    ATM Shafiqul Khalid (askhalid) 15-Oct-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>
#include <stdlib.h>

#include "regremap.h"
#include "wow64reg.h"
#include "wow64reg\reflectr.h"

//#include "wow64.h"

PVOID
Wow64AllocateTemp(
    SIZE_T Size
    );

#ifdef WOW64_LOG_REGISTRY
    WCHAR TempBuff[MAX_PATH];
    DWORD TempLen = MAX_PATH;

NTSTATUS   //should move to the regremap.h header
ObjectAttributesToKeyName (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PWCHAR AbsPath,
    BOOL *bPatched,
    DWORD *ParentLen
    );

#endif 

#ifdef LOG_REGISTRY

void
LogMsgKeyHandle (
    char *str,
    HANDLE hKey,
    DWORD res
    )
{
    WCHAR AbsPath[MAX_PATH];
    DWORD Len = MAX_PATH;

    HandleToKeyName (hKey, AbsPath, &Len);
    LOGPRINT( (ERRORLOG, "\nDEBUG: requested Node:%S Status:%x, Msg:%s", AbsPath, res, str));


};
#endif

//
//  Need to move in the header file
//
NTSTATUS
RemapNtCreateKey(
    OUT PHANDLE phPatchedHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
Wow64NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    KeyHandle - Receives a Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory is
        specified, the name is relative to the root.  The name of the
        object must be within the name space allocated to the Registry,
        that is, all names beginning "\Registry".  RootHandle, if
        present, must be a handle to "\", or "\Registry", or a key
        under "\Registry".

        RootHandle must have been opened for KEY_CREATE_SUB_KEY access
        if a new node is to be created.

        NOTE:   Object manager will capture and probe this argument.

    TitleIndex - Specifies the index of the localized alias for
        the name of the key.  The title index specifies the index of
        the localized alias for the name.  Ignored if the key
        already exists.

    Class - Specifies the object class of the key.  (To the registry
        this is just a string.)  Ignored if NULL.

    CreateOptions - Optional control values:

        REG_OPTION_VOLATILE - Object is not to be stored across boots.

    Disposition - This optional parameter is a pointer to a variable
        that will receive a value indicating whether a new Registry
        key was created or an existing one opened:

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    NTSTATUS St;
    BOOL bRet = FALSE;
    ULONG Disposition_Temp;

    try {

    if ( Disposition == NULL )
        Disposition = &Disposition_Temp; 


    St = RemapNtCreateKey  (
                            KeyHandle,
                            DesiredAccess,
                            ObjectAttributes,
                            TitleIndex,
                            Class ,
                            CreateOptions,
                            Disposition
                            );

    if (!NT_SUCCESS(St))
        bRet = TRUE;

    if (!bRet)
    if ( *KeyHandle != NULL)
        bRet = TRUE;
 

    //
    // if total failure for thunked key, try if you can pull that key from 64bit hive.
    // May be reflector should be running 
    //

    if (!bRet ) {

        //
        // 2nd try only if no patch is required.
        // i.e., success with NULL handle returned
        //

        St = NtCreateKey(
                                KeyHandle,
                                (~KEY_WOW64_RES) & DesiredAccess,
                                ObjectAttributes,
                                TitleIndex,
                                Class ,
                                CreateOptions,
                                Disposition
                                );
    }

#ifdef WOW64_LOG_REGISTRY
    TempLen = MAX_PATH;
    ObjectAttributesToKeyName (
                            ObjectAttributes,
                            TempBuff,
                            &bRet,
                            NULL);
    Wow64RegDbgPrint (( "\nNtCreateKeyEx IN:[%S]", TempBuff));

    HandleToKeyName (*KeyHandle, TempBuff, &TempLen);
    Wow64RegDbgPrint (( "\nNtCreateKeyEx OUT:[%S] Status:%x F:%x", TempBuff, DesiredAccess));


#endif    

    if (NT_SUCCESS(St)) 
        Wow64RegSetKeyDirty (*KeyHandle ); // Need some clean/sync up on exit

    if ( *Disposition == REG_CREATED_NEW_KEY )
            UpdateKeyTag ( *KeyHandle,TAG_KEY_ATTRIBUTE_32BIT_WRITE );

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        St =  GetExceptionCode ();
    }
    return St;
}

NTSTATUS
Wow64NtDeleteKey(
    IN HANDLE KeyHandle
    )
/*++

Routine Description:

    A registry key may be marked for delete, causing it to be removed
    from the system.  It will remain in the name space until the last
    handle to it is closed.

Arguments:

    KeyHandle - Specifies the handle of the Key to delete, must have
        been opened for DELETE access.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    NTSTATUS St;    
    
    HKEY hRemap = Wow64OpenRemappedKeyOnReflection (KeyHandle);


    St = NtDeleteKey(
                        KeyHandle
                        );
    if (NT_SUCCESS (St) && ( hRemap != NULL ) )
        Wow64RegDeleteKey (hRemap, NULL);

    if ( hRemap != NULL )
        NtClose ( hRemap );

    return St;
}

NTSTATUS
Wow64NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    )
/*++

Routine Description:

    One of the value entries of a registry key may be removed with this
    call.  To remove the entire key, call NtDeleteKey.

    The value entry with ValueName matching ValueName is removed from the key.
    If no such entry exists, an error is returned.

Arguments:

    KeyHandle - Specifies the handle of the key containing the value
        entry of interest.  Must have been opend for KEY_SET_VALUE access.

    ValueName - The name of the value to be deleted.  NULL is a legal name.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    NTSTATUS St;

    St = NtDeleteValueKey(
                            KeyHandle,
                            ValueName
                            );

    if (NT_SUCCESS(St)) 
        Wow64RegSetKeyDirty (KeyHandle ); // Need some clean/sync up on exit

    return St;
}


NTSTATUS
Wow64NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The sub keys of an open key may be enumerated with NtEnumerateKey.

    NtEnumerateKey returns the name of the Index'th sub key of the open
    key specified by KeyHandle.  The value STATUS_NO_MORE_ENTRIES will be
    returned if value of Index is larger than the number of sub keys.

    Note that Index is simply a way to select among child keys.  Two calls
    to NtEnumerateKey with the same Index are NOT guaranteed to return
    the same results.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose sub keys are to be enumerated.  Must
        be open for KEY_ENUMERATE_SUB_KEY access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/

{

    //
    // if the handle is to ISN node then time to enumerate the right one
    //

    BOOL bRealigned=FALSE;
    PVOID pTempKeyInfo;

    NTSTATUS RetVal;

    try {

    if ( (SIZE_T)(KeyInformation) & (0x07) ) {
        // allocate a buffer with correct alignment, to pass to the Win64 API
        pTempKeyInfo = KeyInformation;
    	KeyInformation = Wow64AllocateTemp(Length);
        RtlCopyMemory(KeyInformation, pTempKeyInfo, Length);
        bRealigned = TRUE;
    }

    RetVal = NtEnumerateKey(
                            KeyHandle,
                            Index,
                            KeyInformationClass,
                            KeyInformation,
                            Length,
                            ResultLength
                            );

	if (!NT_ERROR(RetVal) && bRealigned) {
		RtlCopyMemory((PVOID)pTempKeyInfo, KeyInformation, Length);
	}

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        RetVal =  GetExceptionCode ();
    }

    return RetVal;
}


NTSTATUS
Wow64NtEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The value entries of an open key may be enumerated
    with NtEnumerateValueKey.

    NtEnumerateValueKey returns the name of the Index'th value
    entry of the open key specified by KeyHandle.  The value
    STATUS_NO_MORE_ENTRIES will be returned if value of Index is
    larger than the number of sub keys.

    Note that Index is simply a way to select among value
    entries.  Two calls to NtEnumerateValueKey with the same Index
    are NOT guaranteed to return the same results.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose value entries are to be enumerated.
        Must have been opened with KEY_QUERY_VALUE access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyValueInformationClass - Specifies the type of information returned
    in Buffer. One of the following types:

        KeyValueBasicInformation - return time of last write,
            title index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write,
            title index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/

{


    return NtEnumerateValueKey(
                             KeyHandle,
                             Index,
                             KeyValueInformationClass,
                             KeyValueInformation,
                             Length,
                             ResultLength
                             );


}


NTSTATUS
Wow64NtFlushKey(
    IN HANDLE KeyHandle
    )
/*++

Routine Description:

    Changes made by NtCreateKey or NtSetKey may be flushed to disk with
    NtFlushKey.

    NtFlushKey will not return to its caller until any changed data
    associated with KeyHandle has been written to permanent store.

    WARNING: NtFlushKey will flush the entire registry tree, and thus will
    burn cycles and I/O.

Arguments:

    KeyHandle - Handle of open key to be flushed.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/

{
    return   NtFlushKey(
                        KeyHandle
                        );
}


NTSTATUS
Wow64NtInitializeRegistry(
    IN USHORT BootCondition
    )
/*++

Routine Description:

    This routine is called in 2 situations:

    1) It is called from SM after autocheck (chkdsk) has
    run and the paging files have been opened.  It's function is
    to bind in memory hives to their files, and to open any other
    files yet to be used.

    2) It is called from SC after the current boot has been accepted
    and the control set used for the boot process should be saved
    as the LKG control set.

    After this routine accomplishes the work of situation #1 and
      #2, further requests for such work will not be carried out.

Arguments:

    BootCondition -

         REG_INIT_BOOT_SM -     The routine has been called from SM
                                in situation #1.

         REG_INIT_BOOT_SETUP -  The routine has been called to perform
                                situation #1 work but has been called
                                from setup and needs to do some special
                                work.

        REG_INIT_BOOT_ACCEPTED_BASE + Num
                        (where 0 < Num < 1000) - The routine has been called
                                                 in situation #2. "Num" is the
                                                 number of the control set
                                                 to which the boot control set
                                                 should be saved.

Return Value:

    NTSTATUS - Result code from call, among the following:

        STATUS_SUCCESS - it worked
        STATUS_ACCESS_DENIED - the routine has already done the work
                               requested and will not do it again.

--*/
{
    return NtInitializeRegistry(
                                BootCondition
                                );

}

NTSTATUS
Wow64NtNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Notification of key creation, deletion, and modification may be
    obtained by calling NtNotifyChangeKey.

    NtNotifyChangeKey monitors changes to a key - if the key or
    subtree specified by KeyHandle are modified, the service notifies
    its caller.  It also returns the name(s) of the key(s) that changed.
    All names are specified relative to the key that the handle represents
    (therefore a NULL name represents that key).  The service completes
    once the key or subtree has been modified based on the supplied
    CompletionFilter.  The service is a "single shot" and therefore
    needs to be reinvoked to watch the key for further changes.

    The operation of this service begins by opening a key for KEY_NOTIFY
    access.  Once the handle is returned, the NtNotifyChangeKey service
    may be invoked to begin watching the values and subkeys of the
    specified key for changes.  The first time the service is invoked,
    the BufferSize parameter supplies not only the size of the user's
    Buffer, but also the size of the buffer that will be used by the
    Registry to store names of keys that have changed.  Likewise, the
    CompletionFilter and WatchTree parameters on the first call indicate
    how notification should operate for all calls using the supplied
    KeyHandle.   These two parameters are ignored on subsequent calls
    to the API with the same instance of KeyHandle.

    Once a modification is made that should be reported, the Registry will
    complete the service.  The names of the files that have changed since
    the last time the service was called will be placed into the caller's
    output Buffer.  The Information field of IoStatusBlock will contain
    the number of bytes placed in Buffer, or zero if too many keys have
    changed since the last time the service was called, in which case
    the application must Query and Enumerate the key and sub keys to
    discover changes.  The Status field of IoStatusBlock will contain
    the actual status of the call.

    If Asynchronous is TRUE, then Event, if specified, will be set to
    the Signaled state.  If no Event parameter was specified, then
    KeyHandle will be set to the Signaled state.  If an ApcRoutine
    was specified, it is invoked with the ApcContext and the address of the
    IoStatusBlock as its arguments.  If Asynchronous is FALSE, Event,
    ApcRoutine, and ApcContext are ignored.

    This service requires KEY_NOTIFY access to the key that was
    actually modified

    The notify "session" is terminated by closing KeyHandle.

Arguments:

    KeyHandle-- Supplies a handle to an open key.  This handle is
        effectively the notify handle, because only one set of
        notify parameters may be set against it.

    Event - An optional handle to an event to be set to the
        Signaled state when the operation completes.

    ApcRoutine - An optional procedure to be invoked once the
        operation completes.  For more information about this
        parameter see the NtReadFile system service description.

        If PreviousMode == Kernel, this parameter is an optional
        pointer to a WORK_QUEUE_ITEM to be queued when the notify
        is signaled.

    ApcContext - A pointer to pass as an argument to the ApcRoutine,
        if one was specified, when the operation completes.  This
        argument is required if an ApcRoutine was specified.

        If PreviousMode == Kernel, this parameter is an optional
        WORK_QUEUE_TYPE describing the queue to be used. This argument
        is required if an ApcRoutine was specified.

    IoStatusBlock - A variable to receive the final completion status.
        For more information about this parameter see the NtCreateFile
        system service description.

    CompletionFilter -- Specifies a set of flags that indicate the
        types of operations on the key or its value that cause the
        call to complete.  The following are valid flags for this parameter:

        REG_NOTIFY_CHANGE_NAME -- Specifies that the call should be
            completed if a subkey is added or deleted.

        REG_NOTIFY_CHANGE_ATTRIBUTES -- Specifies that the call should
            be completed if the attributes (e.g.: ACL) of the key or
            any subkey are changed.

        REG_NOTIFY_CHANGE_LAST_SET -- Specifies that the call should be
            completed if the lastWriteTime of the key or any of its
            subkeys is changed.  (Ie. if the value of the key or any
            subkey is changed).

        REG_NOTIFY_CHANGE_SECURITY -- Specifies that the call should be
            completed if the security information (e.g. ACL) on the key
            or any subkey is changed.

    WatchTree -- A BOOLEAN value that, if TRUE, specifies that all
        changes in the subtree of this key should also be reported.
        If FALSE, only changes to this key, its value, and its immediate
        subkeys (but not their values nor their subkeys) are reported.

    Buffer -- A variable to receive the name(s) of the key(s) that
        changed.  See REG_NOTIFY_INFORMATION.

    BufferSize -- Specifies the length of Buffer.

    Asynchronous  -- If FALSE, call will not return until
        complete (synchronous) if TRUE, call may return STATUS_PENDING.

Obs:
    Since NtNotifyChangeMultipleKeys, this routine is kept only for bacwards compatibility

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    return NtNotifyChangeKey(
                            KeyHandle,
                            Event ,
                            ApcRoutine ,
                            ApcContext ,
                            IoStatusBlock,
                            CompletionFilter,
                            WatchTree,
                            Buffer,
                            BufferSize,
                            Asynchronous
                            );
}


NTSTATUS
Wow64NtNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,
    IN ULONG Count,
    IN OBJECT_ATTRIBUTES SlaveObjects[],
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Notificaion of creation, deletion and modification on multiple keys
    may be obtained with NtNotifyChangeMultipleKeys.

    NtNotifyMultipleKeys monitors changes to any of the MasterKeyHandle
    or one of SlaveObjects and/or their subtrees, whichever occurs first.
    When an event on these keys is triggered, the notification is considered
    fulfilled, and has to be "armed" again, in order to watch for further
    changes.

    The mechanism is similar to the one described in NtNotifyChangeKey.

    The MasterKeyHandle key, give the caller control over the lifetime
    of the notification. The notification will live as long as the caller
    keeps the MasterKeyHandle open, or an event is triggered.

    The caller doesn't have to open the SlaveKeys. He will provide the
    routine with an array of OBJECT_ATTRIBUTES, describing the slave objects.
    The routine will open the objects, and ensure keep a reference on them
    untill the back-end side will close them.

    The notify "session" is terminated by closing MasterKeyHandle.

Obs:
    For the time being, the routine supports only one slave object. When more
    than one slave object is provided, the routine will signal an error of
    STATUS_INVALID_PARAMETER.
    However, the interface is designed for future enhancements (taking an
    array of slave objects), that may be provided with future versions(w2001).

    When no slave object is supplied (i.e. Count == 0) we have the identical
    behavior as for NtNotifyChangeKey.

Arguments:

    MasterKeyHandle - Supplies a handle to an open key.  This handle is
        the "master handle". It has control overthe lifetime of the
        notification.

    Count - Number of slave objects. For the time being, this should be 1

    SlaveObjects - Array of slave objects. Only the attributes of the
        objects are provided, so the caller doesn't have to take care
        of them.

    Event,ApcRoutine,ApcContext,IoStatusBlock,CompletionFilter,WatchTree,
    Buffer,BufferSize,Asynchronous - same as for NtNotifyChangeKey

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/

{
    return NtNotifyChangeMultipleKeys(
                                        MasterKeyHandle,
                                        Count,
                                        SlaveObjects,
                                        Event,
                                        ApcRoutine,
                                        ApcContext,
                                        IoStatusBlock,
                                        CompletionFilter,
                                        WatchTree,
                                        Buffer,
                                        BufferSize,
                                        Asynchronous
                                        );

}

NTSTATUS
Wow64NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    A registry key which already exists may be opened with NtOpenKey.

    Share access is computed from desired access.

Arguments:

    KeyHandle - Receives a  Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory
        is specified, the name is relative to the root.  The name of
        the object must be within the name space allocated to the
        Registry, that is, all names beginning "\Registry".  RootHandle,
        if present, must be a handle to "\", or "\Registry", or a
        key under "\Registry".  If the specified key does not exist, or
        access requested is not allowed, the operation will fail.

        NOTE:   Object manager will capture and probe this argument.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS St;
    BOOL bRet = FALSE;
    
    try {

    St = OpenIsnNodeByObjectAttributes  (
                                ObjectAttributes,
                                DesiredAccess,
                                KeyHandle );

    if (!NT_SUCCESS(St)) 
        bRet = TRUE;

    if ( !bRet )
    if ( *KeyHandle != NULL)
        bRet = TRUE;

    if ( !bRet ) {

        St = NtOpenKey(
                            KeyHandle,
                            (~KEY_WOW64_RES) & DesiredAccess,
                            ObjectAttributes
                            );
    }

#ifdef WOW64_LOG_REGISTRY
    TempLen = MAX_PATH;
    ObjectAttributesToKeyName (
                            ObjectAttributes,
                            TempBuff,
                            &bRet,
                            NULL
                            );
    Wow64RegDbgPrint (( "\nNtOpenKeyEx IN:[%S]", TempBuff));

    HandleToKeyName (*KeyHandle, TempBuff, &TempLen);
    Wow64RegDbgPrint (( "\nNtOpenKeyEx OUT:[%S] Status:%x F:%x", TempBuff, St, DesiredAccess));


#endif 

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        St =  GetExceptionCode ();
    }

    return St;

}

NTSTATUS
Wow64NtQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    Data about the class of a key, and the numbers and sizes of its
    children and value entries may be queried with NtQueryKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

    NOTE: The returned lengths are guaranteed to be at least as
          long as the described values, but may be longer in
          some circumstances.

Arguments:

    KeyHandle - Handle of the key to query data for.  Must have been
        opened for KEY_QUERY_KEY access.

    KeyInformationClass - Specifies the type of information
        returned in Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (See KEY_BASIC_INFORMATION)

        KeyNodeInformation - return last write time, title index, name, class.
            (See KEY_NODE_INFORMATION)

        KeyFullInformation - return all data except for name and security.
            (See KEY_FULL_INFORMATION)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
	BOOL bRealigned=FALSE;
    PVOID pTempKeyInfo;

    NTSTATUS RetVal;

    try {

    if ( (SIZE_T)(KeyInformation) & (0x07) ) {
        // allocate a buffer with correct alignment, to pass to the Win64 API
        pTempKeyInfo = KeyInformation;
    	KeyInformation = Wow64AllocateTemp(Length);
        RtlCopyMemory(KeyInformation, pTempKeyInfo, Length);
        bRealigned = TRUE;
    }

    RetVal = NtQueryKey(
                        KeyHandle,
                        KeyInformationClass,
                        KeyInformation,
                        Length,
                        ResultLength
                        );

	if (!NT_ERROR(RetVal) && bRealigned) {
		RtlCopyMemory((PVOID)pTempKeyInfo, KeyInformation, Length);
	}

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        RetVal =  GetExceptionCode ();
    }

    return RetVal;
}


NTSTATUS
Wow64NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The ValueName, TitleIndex, Type, and Data for any one of a key's
    value entries may be queried with NtQueryValueKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose value entries are to be
        enumerated.  Must be open for KEY_QUERY_VALUE access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    ValueName  - The name of the value entry to return data for.

    KeyValueInformationClass - Specifies the type of information
        returned in KeyValueInformation.  One of the following types:

        KeyValueBasicInformation - return time of last write, title
            index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write, title
            index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

    TMP: The IopQueryRegsitryValues() routine in the IO system assumes
         STATUS_OBJECT_NAME_NOT_FOUND is returned if the value being queried
         for does not exist.

--*/
{
    BOOL bRealigned=FALSE;
    PVOID pTempKeyInfo;

    NTSTATUS RetVal;

    try {

        if ( (SIZE_T)(KeyValueInformation) & (0x07) ) {
            // allocate a buffer with correct alignment, to pass to the Win64 API
            pTempKeyInfo = KeyValueInformation;
    	    KeyValueInformation = Wow64AllocateTemp(Length);
            RtlCopyMemory(KeyValueInformation, pTempKeyInfo, Length);
            bRealigned = TRUE;
        }

        RetVal =  NtQueryValueKey(
                                    KeyHandle,
                                    ValueName,
                                    KeyValueInformationClass,
                                    KeyValueInformation,
                                    Length,
                                    ResultLength
                                    );

	    if (!NT_ERROR(RetVal) && bRealigned) {
		    RtlCopyMemory((PVOID)pTempKeyInfo, KeyValueInformation, Length);
	    }

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        RetVal =  GetExceptionCode ();
    }

    return RetVal;
}



NTSTATUS
Wow64NtRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG Flags
    )
/*++

Routine Description:

    A file in the format created by NtSaveKey may be loaded into
    the system's active registry with NtRestoreKey.  An entire subtree
    is created in the active registry as a result.  All of the
    data for the new sub-tree, including such things as security
    descriptors, will be read from the source file.  The data will
    not be interpreted in any way.

    This call (unlike NtLoadKey, see below) copies the data.  The
    system will NOT be using the source file after the call returns.

    If the flag REG_WHOLE_HIVE_VOLATILE is specified, a new hive
    can be created.  It will be a memory only copy.  The restore
    must be done to the root of a hive (e.g. \registry\user\<name>)

    If the flag is NOT set, then the target of the restore must
    be an existing hive.  The restore can be done to an arbitrary
    location within an existing hive.

    Caller must have SeRestorePrivilege privilege.

    If the flag REG_REFRESH_HIVE is set (must be only flag) then the
    the Hive will be restored to its state as of the last flush.

    The hive must be marked NOLAZY_FLUSH, and the caller must have
    TCB privilege, and the handle must point to the root of the hive.
    If the refresh fails, the hive will be corrupt, and the system
    will bugcheck.  Notifies are flushed.  The hive file will be resized,
    the log will not.  If there is any volatile space in the hive
    being refreshed, STATUS_UNSUCCESSFUL will be returned.  (It's much
    too obscure a failure to warrant a new error code.)

    If the flag REG_FORCE_RESTORE is set, the restore operation is done
    even if the KeyHandle has open subkeys by other applications

Arguments:

    KeyHandle - refers to the Key in the registry which is to be the
                root of the new tree read from the disk.  This key
                will be replaced.

    FileHandle - refers to file to restore from, must have read access.

    Flags   - If REG_WHOLE_HIVE_VOLATILE is set, then the copy will
              exist only in memory, and disappear when the machine
              is rebooted.  No hive file will be created on disk.

              Normally, a hive file will be created on disk.

Return Value:

    NTSTATUS - values TBS.


--*/
{
    return NtRestoreKey(
                        KeyHandle,
                        FileHandle,
                        Flags
                        );
}



NTSTATUS
Wow64NtSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    )
/*++

Routine Description:

    A subtree of the active registry may be written to a file in a
    format suitable for use with NtRestoreKey.  All of the data in the
    subtree, including such things as security descriptors will be written
    out.

    Caller must have SeBackupPrivilege privilege.

Arguments:

    KeyHandle - refers to the Key in the registry which is the
                root of the tree to be written to disk.  The specified
                node will be included in the data written out.

    FileHandle - a file handle with write access to the target file
                 of interest.

Return Value:

    NTSTATUS - values TBS

--*/
{
    return NtSaveKey(
                    KeyHandle,
                    FileHandle
                    );
}


NTSTATUS
Wow64NtSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    )
/*++

Routine Description:

    Two subtrees of the registry can be merged. The resulting subtree may
    be written to a file in a format suitable for use with NtRestoreKey.
    All of the data in the subtree, including such things as security
    descriptors will be written out.

    Caller must have SeBackupPrivilege privilege.

Arguments:

    HighPrecedenceKeyHandle - refers to the key in the registry which is the
                root of the HighPrecedence tree. I.e., when a key is present in
                both trees headded by the two keys, the key underneath HighPrecedence
                tree will always prevail. The specified
                node will be included in the data written out.

    LowPrecedenceKeyHandle - referrs to the key in the registry which is the
                root of the "second choice" tree. Keys from this trees get saved
                when there is no equivalent key in the tree headded by HighPrecedenceKey

    FileHandle - a file handle with write access to the target file
                 of interest.

Return Value:

    NTSTATUS - values TBS

--*/
{
    return NtSaveMergedKeys(
                                HighPrecedenceKeyHandle,
                                LowPrecedenceKeyHandle,
                                FileHandle
                                );
}


NTSTATUS
Wow64NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
/*++

Routine Description:

    A value entry may be created or replaced with NtSetValueKey.

    If a value entry with a Value ID (i.e. name) matching the
    one specified by ValueName exists, it is deleted and replaced
    with the one specified.  If no such value entry exists, a new
    one is created.  NULL is a legal Value ID.  While Value IDs must
    be unique within any given key, the same Value ID may appear
    in many different keys.

Arguments:

    KeyHandle - Handle of the key whose for which a value entry is
        to be set.  Must be opened for KEY_SET_VALUE access.

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    TitleIndex - Supplies the title index for ValueName.  The title
        index specifies the index of the localized alias for the ValueName.

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.


Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    WCHAR ThunkData[_MAX_PATH];
    PWCHAR pCorrectData = (PWCHAR)Data;
    ULONG CorrectDataSize = DataSize;
    NTSTATUS St = STATUS_SUCCESS;


    //
    // thunk  %ProgramFiles%  ==> %ProgramFiles(x86)% 
    //        %commonprogramfiles% ==> %commonprogramfiles(x86)%
    //


    try {
        
        if ((DataSize > 0) &&
            (DataSize < ( _MAX_PATH*sizeof (WCHAR) - 10) && 
            ((Type == REG_SZ) || (Type == REG_EXPAND_SZ) )) )  { //(x86)==>10 byte

            PWCHAR p;
            PWCHAR t;

            //
            // do the thunking here.
            //


            memcpy ( (PBYTE ) &ThunkData[0], (PBYTE)Data, DataSize);
            ThunkData [DataSize/sizeof (WCHAR) ] = UNICODE_NULL; // make sure NULL terminated
        
            if ( (p = wcsstr (ThunkData, L"%ProgramFiles%" )) != NULL ){

                p +=13; //skip at the end of %ProgramFiles

            } else if ( (p = wcsstr (ThunkData, L"%commonprogramfiles%")) != NULL ){

                p +=19; //skip at the end of %commonprogramfiles
            
            }

            if (p) {

                t = pCorrectData + (p - ThunkData);
                wcscpy(p, L"(x86)"); //(x86)
                wcscat(p, t);        //copy rest of the string

                pCorrectData = ThunkData;
                CorrectDataSize += sizeof (L"(x86)");

            } else if ( (p=wcsistr (Data, L"\\System32\\")) != NULL) {
                
                if (IsOnReflectionByHandle ( KeyHandle ) ) {
                    wcsncpy (p, L"\\SysWow64\\",10);
                }
            }    

        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

          St = GetExceptionCode ();
    }

    //
    // Check if the operation should proceed. The key might be on access denied list.
    //

    if (NT_SUCCESS (St)) {
        
        St = NtSetValueKey(
            KeyHandle,
            ValueName,
            TitleIndex  ,
            Type,
            (PVOID)pCorrectData,
            CorrectDataSize
            );
    
        if (NT_SUCCESS(St)) {
            Wow64RegSetKeyDirty (KeyHandle ); // Need some clean/sync up on exit
        }
    }

    return St;
}


NTSTATUS
Wow64NtLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

Return Value:

    NTSTATUS - values TBS.

--*/

{
    return NtLoadKey(TargetKey, SourceFile);
}


NTSTATUS
Wow64NtLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

    Flags - specifies any flags that should be used for the load operation.
            The only valid flag is REG_NO_LAZY_FLUSH.


Return Value:

    NTSTATUS - values TBS.

--*/

{

    return NtLoadKey2(
                        TargetKey,
                        SourceFile,
                        Flags
                        );

}


NTSTATUS
Wow64NtUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    )
/*++

Routine Description:

    Drop a subtree (hive) out of the registry.

    Will fail if applied to anything other than the root of a hive.

    Cannot be applied to core system hives (HARDWARE, SYSTEM, etc.)

    Can be applied to user hives loaded via NtRestoreKey or NtLoadKey.

    If there are handles open to the hive being dropped, this call
    will fail.  Terminate relevent processes so that handles are
    closed.

    This call will flush the hive being dropped.

    Caller must have SeRestorePrivilege privilege.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS - values TBS.

--*/

{
    return NtUnloadKey(
     TargetKey
    );
}


NTSTATUS
Wow64NtSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    )

{
    return NtSetInformationKey(
                                KeyHandle,
                                KeySetInformationClass,
                                KeySetInformation,
                                KeySetInformationLength
                                );
}


NTSTATUS
Wow64NtReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    )
/*++

Routine Description:

    A hive file may be "replaced" under a running system, such
    that the new file will be the one actually used at next
    boot, with this call.

    This routine will:

        Open newfile, and verify that it is a valid Hive file.

        Rename the Hive file backing TargetHandle to OldFile.
        All handles will remain open, and the system will continue
        to use the file until rebooted.

        Rename newfile to match the name of the hive file
        backing TargetHandle.

    .log and .alt files are ignored

    The system must be rebooted for any useful effect to be seen.

    Caller must have SeRestorePrivilege.

Arguments:

    NewFile - specifies the new file to use.  must not be just
              a handle, since NtReplaceKey will insist on
              opening the file for exclusive access (which it
              will hold until the system is rebooted.)

    TargetHandle - handle to a registry hive root

    OldFile - name of file to apply to current hive, which will
              become old hive

Return Value:

    NTSTATUS - values TBS.

--*/
{
    return NtReplaceKey(
                            NewFile,
                            TargetHandle,
                            OldFile
                            );
}



NTSTATUS
Wow64NtQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    )
/*++

Routine Description:

    Multiple values of any key may be queried atomically with
    this api.

Arguments:

    KeyHandle - Supplies the key to be queried.

    ValueNames - Supplies an array of value names to be queried

    ValueEntries - Returns an array of KEY_VALUE_ENTRY structures, one for each value.

    EntryCount - Supplies the number of entries in the ValueNames and ValueEntries arrays

    ValueBuffer - Returns the value data for each value.

    BufferLength - Supplies the length of the ValueBuffer array in bytes.
                   Returns the length of the ValueBuffer array that was filled in.

    RequiredBufferLength - if present, Returns the length in bytes of the ValueBuffer
                    array required to return all the values of this key.

Return Value:

    NTSTATUS

--*/
{
  return NtQueryMultipleValueKey(  KeyHandle,
                                   ValueEntries,
                                   EntryCount,
                                   ValueBuffer,
                                   BufferLength,
                                   RequiredBufferLength
                                  );
}


NTSTATUS
Wow64NtQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    )
/*++

Routine Description:

    Dumps all the subkeys of the target key that are kept open by some other
    process; Returns the number of open subkeys


Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS - values TBS.

--*/
{
 return NtQueryOpenSubKeys( TargetKey, HandleCount );
}

NTSTATUS
Wow64NtSetSecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine is used to invoke an object's security routine.  It
    is used to set the object's security state.

Arguments:

    Handle - Supplies the handle for the object being modified

    SecurityInformation - Indicates the type of information we are
        interested in setting. e.g., owner, group, dacl, or sacl.

    SecurityDescriptor - Supplies the security descriptor for the
        object being modified.

Return Value:

    An appropriate NTSTATUS value

--*/
{
    //
    // Check if the handle points to a particular key, then if the API succeed 
    // Reflect that.
    //

    NTSTATUS St;
    NTSTATUS Status;
    POBJECT_TYPE_INFORMATION pTypeInfo;

    
    CHAR Buffer[1024];
    pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;

    Status = NtQueryObject(Handle,
                           ObjectTypeInformation,
                           pTypeInfo,
                           sizeof (Buffer),
                           NULL
                           );

    St =  NtSetSecurityObject (
                                Handle,
                                SecurityInformation,
                                SecurityDescriptor
                                );

    //
    // If NT_SUCCESS (St) && the handle point on to a registry Key set the handle for reflection.
    //

    if (NT_SUCCESS (St) && NT_SUCCESS (Status)){


        if ( _wcsnicmp ( pTypeInfo->TypeName.Buffer, L"Key", 3) == 0)
            Wow64RegSetKeyDirty (Handle); // Need some clean/sync up on exit     
    }

    return St;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\wowhndl.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    regmisc.c

Abstract:

    This module implement Handle redirection for registry redirection.

Author:

    ATM Shafiqul Khalid (askhalid) 16-June-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>

#define _WOW64REFLECTOR_

#include "regremap.h"
#include "wow64reg.h"
#include "wow64reg\reflectr.h"


#ifdef _WOW64DLLAPI_
#include "wow64.h"
#else
#define ERRORLOG 1  //this one is completely dummy
#define LOGPRINT(x)
#define WOWASSERT(p)
#endif //_WOW64DLLAPI_


#define REFLECTOR_ENABLE_KEY L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64\\Reflector Setup"
#define REFLECTOR_DISABLE_KEY L"\\Registry\\Machine\\System\\Setup"
#define REFLECTOR_DISABLE_KEY_WOW64 L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64"


BOOL
HandleRunOnce (
    WCHAR *SrcNode
    );

BOOL 
ReflectClassGuid (
    PWCHAR SrcName,
    DWORD dwDirection
    );

VOID
InitRegistry ();

BOOL 
SyncGuidKey (
    HANDLE hSrc, 
    HANDLE hDest,
    DWORD dwDirection,
    DWORD __bNewlyCreated
    );

BOOL
Wow64ReflectSecurity (
    HKEY SrcKey,
    HKEY DestKey
    );

//
//IsOnReflectionList: has hardcoded  \\registry\\user\\<sid>_Classes.
//
DWORD  ReflectListLen[18] ={0};
WCHAR  ReflectList[18][128]={
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes"},    // alias to the classes root on the user hives
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes"},    // alias to the classes root on the user hives
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node"},    // alias to the classes root on the user hives
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run"},    // Runonce Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce"},    // Runonce Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx"},    // Runonce Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\COM3"},    // COM+ Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\COM3"},    // COM+ Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Ole"},    // OLE Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Ole"},    // OLE Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\EventSystem"},    // EventSystem
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\EventSystem"},    // EventSystem
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\RPC"},    // RPC
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\RPC"},    // RPC
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\TEST"},    // Test Node
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\TEST"},    // Test Node
    { L""}
    };


typedef struct {

    HANDLE hBase;   // handle to the original object
    HANDLE hRemap;  // handle to the remapped object
    DWORD  Status;  // will have different attribute set.
    DWORD  dwCount; // Handle count- according to dragos, we can ignore because multiple open get different handle.
    DWORD  Attribute; //attribute to hold Key attribute
} WOW64_HANDLE;

#define TABLE_SEGMENT_MAX 500
#define SEGMENT_SIZE      256
#define DIRECTION_32_TO_64 10
#define DIRECTION_64_TO_32 11

//
// Flag while copying value Key.
//
#define DEFAULT_FLAG                    0x00000000
#define DELETE_SRC_VALUEKEY             0x00000010
#define DONT_DELETE_DEST_VALUEKEY       0x00000020
#define PATCH_VALUE_KEY_NAME            0x00000040
#define SYNC_VALUE_IF_REFLECTED_KEYS    0x00000080
#define DONT_SYNC_IF_DLL_SURROGATE      0x00000100

#define WOW64_HANDLE_DIRTY   0x00000001  // some update operation was done using this handle
#define WOW64_HANDLE_INUSE   0x00000002  // Tag this handle block not free
#define HashValue (x) ((((x)>>24) + ((x)>>16) + (x)>>8 + (x)) % SEGMENT_SIZE )

#define MyNtClose(hRemap) if (hRemap != NULL) { NtClose (hRemap); hRemap = NULL;}

RTL_CRITICAL_SECTION HandleTable;
//
// BUGBUG: This module implement simplifiled version of handle redirection using linear list. 
//   This must have to be implemented by a hash table if possible.
//


PVOID List[TABLE_SEGMENT_MAX];
WOW64_HANDLE HandleList[SEGMENT_SIZE];  //hopefully this will be good enough for open key handle. It can always allocate dynamically.

BOOL bTableInitialized=FALSE;
BOOL bReflectorStatusOn = FALSE;

LogMsg (
    HANDLE hKey,
    PWCHAR Msg
    )
{
    WCHAR Name[WOW64_MAX_PATH];
    DWORD Len = WOW64_MAX_PATH;

    HandleToKeyName (hKey, Name, &Len);
    DbgPrint ("\nMsg:%S Key:%S",Msg, Name );
}

PVOID
RegRemapAlloc (
    DWORD dwSize
    )
/*++

Routine Description:

    Allocate memory.

Arguments:

    dwSize - size of memory to allocate.

Return Value:

    return appropriate buffer.

--*/
{
    PVOID pBuffer;

    //
    //  For performance reason you might allocate big chunk and then reuse.
    //

    pBuffer = RtlAllocateHeap (
                RtlProcessHeap(),
                0,
                dwSize);

    return pBuffer;
}

VOID
RegRemapFree (
    PVOID pBuffer
    )
/*++

Routine Description:

    Free allocated mery.

Arguments:

    dwSize - size of memory to allocate.

Return Value:

    None.

--*/
{

    //
    //  For performance reason you might allocate big chunk and then reuse.
    //

    if ( pBuffer == NULL)
        return;

    RtlFreeHeap (
                RtlProcessHeap(),
                0,
                pBuffer
                );

    return;
}

BOOL
InitHandleTable ( )
/*++

Routine Description:

    Initialize the table with appropriate allocation and value if its not initialized yet.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

    <TBD> this might allocate more memory and free up later.
--*/
{
    HKEY hWowSetupKey;
    
    HKEY  hKey;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    NTSTATUS Status;

    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = NULL;
    BYTE Buff[sizeof (KEY_VALUE_PARTIAL_INFORMATION)+10];

    if ( bTableInitialized == TRUE )
        return TRUE; // already initialized

    memset (List, 0, sizeof (List));
    memset (HandleList, 0, sizeof (HandleList));

    List [0]= HandleList;
    bTableInitialized  = TRUE;


    RtlInitUnicodeString (&KeyName, REFLECTOR_DISABLE_KEY);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = NtOpenKey (&hKey, KEY_READ, &Obja);

    if (NT_SUCCESS(Status)) {
        
        DWORD Res;
        DWORD Len = sizeof (Buff);  

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buff;
        RtlInitUnicodeString (&ValueName, L"SystemSetupInProgress");
        Status = NtQueryValueKey(
                                hKey,
                                &ValueName,
                                KeyValuePartialInformation,
                                KeyValueInformation,
                                Len,
                                &Len
                                );
        NtClose (hKey);  // reflection should be disable because setup is on its way.

        if (NT_SUCCESS(Status)) {
            if ( *(LONG *)KeyValueInformation->Data != 0) 
                return FALSE;  //system setup is in progress no reflection

        } else  return FALSE;
    } else return FALSE;

    bReflectorStatusOn = TRUE;  //Now reflector is on.

#ifdef  DBG
    //
    // Check if the systemwide flag is turned off.
    //

    RtlInitUnicodeString (&KeyName, REFLECTOR_DISABLE_KEY_WOW64);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = NtOpenKey (&hKey, KEY_READ, &Obja);

    if (NT_SUCCESS(Status)) {

        DWORD Res;
        DWORD Len = sizeof (Buff);  

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buff;
        RtlInitUnicodeString (&ValueName, L"DisableReflector");
        Status = NtQueryValueKey(
                                hKey,
                                &ValueName,
                                KeyValuePartialInformation,
                                KeyValueInformation,
                                Len,
                                &Len
                                );
        NtClose (hKey);  // reflection should be disable because setup is on its way.

        if (NT_SUCCESS(Status)) {
            if ( *(LONG *)KeyValueInformation->Data != 0) 
                bReflectorStatusOn = FALSE;  //Now reflector is on.

        } 
    } 

    if (!bReflectorStatusOn)
        return FALSE;

#endif //DBG

    //
    // Initialize Internal ISN node table to remap keys.
    //


    Status = RtlInitializeCriticalSection( &HandleTable );
    if (!NT_SUCCESS (Status))
        return FALSE;

    return TRUE;
}

WOW64_HANDLE *
GetFreeHandleBlock (
    HANDLE hKey
    )
/*++

Routine Description:

    Return a free block from the handle table.

Arguments:

    hKey - Handle to the key that will be inserted into the table.

Return Value:

    Return a free block on the table.

    
--*/
{
    WOW64_HANDLE *pList;

    DWORD i,k;

    RtlEnterCriticalSection(&HandleTable);

    for (i=0;i<TABLE_SEGMENT_MAX && List[i] != NULL;i++) {

        pList = (WOW64_HANDLE *)List[i];
        for (k=0;k<SEGMENT_SIZE;k++)

            if (pList[k].hBase == NULL && (!(WOW64_HANDLE_INUSE & pList[k].Status )) ) {

                //
                // Mark the entry in use
                //
                pList[k].Status = WOW64_HANDLE_INUSE;
                RtlLeaveCriticalSection(&HandleTable);
                return &pList[k];
            }
    }

    RtlLeaveCriticalSection(&HandleTable);
    return NULL;
}

WOW64_HANDLE *
GetHandleBlock (
    HANDLE hKey
    )
/*++

Routine Description:

    Return a the block having information associated with the given handle.

Arguments:

    hKey - Handle to the key that need to be investigated.

Return Value:

    Return a the block that has the handle.

    
--*/
{
    WOW64_HANDLE *pList;
    DWORD i,k;

    for (i=0;i<TABLE_SEGMENT_MAX, List[i] != NULL;i++) {

        pList = (WOW64_HANDLE *)List[i];
        for (k=0;k<SEGMENT_SIZE;k++)

            if (pList[k].hBase == hKey)
                return &pList[k];
    }

    return NULL;
}

HANDLE
GetWow64Handle (
    HANDLE hKey
    )
/*++

Routine Description:

    Return a handle to the remapped key if any.

Arguments:

    hKey - Handle to the key that need ramapped information.

Return Value:

    Handle to the remapped key.
    NULL if no remapped key is there.

    
--*/
{
    WOW64_HANDLE *pHandleBlock = GetHandleBlock (hKey);

    if (  pHandleBlock == NULL )
        return NULL;
    
    return pHandleBlock->hRemap;
}

BOOL
IsWow64Handle (
    HANDLE hKey
    )
/*++

Routine Description:

    Check if the handle has been tagged to watch while closing.

Arguments:

    hKey - Handle to the key that need to be checked.

Return Value:

    TRUE if the handle is on the TABLE.
    FALSE otherwise.
    
--*/
{
    return GetHandleBlock (hKey) != NULL;
}

WOW64_HANDLE * 
InsertWow64Handle (
    HANDLE  hKeyBase,
    HANDLE  hKeyRemap
    )
/*++

Routine Description:

    Allocate some resources so that some manipulation can be done in case of 
    Key changes.

Arguments:

    hKey - Handle to the base key that need to be marked.

Return Value:

    Valid block that refer to the handle.
--*/

{
    
    WCHAR SrcNode[WOW64_MAX_PATH];
    DWORD dwLen = WOW64_MAX_PATH;


    WOW64_HANDLE *pHandleBlock = NULL;

    pHandleBlock = GetHandleBlock (hKeyBase);

    if (hKeyBase == NULL || hKeyRemap == NULL)
        return NULL;

    if (  pHandleBlock == NULL ) { // new handle
        //
        // Get the path name and if the key is on the reflection list add it.
        //
        if (!HandleToKeyName ( hKeyBase, SrcNode, &dwLen ))
            return NULL;

        //
        // Make sure The name is on the List otherwise forget.
        //
        if ( !IsOnReflectionList (SrcNode))
            return NULL;

        pHandleBlock = GetFreeHandleBlock (hKeyBase);
    }
    

    if ( pHandleBlock == NULL)
        return NULL;

    pHandleBlock->hRemap = hKeyRemap;
    pHandleBlock->hBase = hKeyBase;

    return pHandleBlock;
}

BOOL
Wow64RegSetKeyDirty (
    HANDLE hKey
    )
/*++

Routine Description:

    Mark the handle dirty, i.e., some value has been changed associated to this Key.

Arguments:

    hKey - Handle to the base key that need to be marked.

Return Value:

    TRUE if the key is on the list of reflection.
    FALSE otherwise.
--*/

{

    
    WOW64_HANDLE *pHandleBlock;
    
    hKey = (HANDLE)((SIZE_T)hKey & ~3);  //ignore the last 2 bits

    InitHandleTable (); //initialize if its already not initialized.

    if (!bReflectorStatusOn)
        return TRUE;  //reflector isn't enable yet.

    if (( pHandleBlock = InsertWow64Handle (hKey, hKey)) == NULL)
        return FALSE;
    
    pHandleBlock->Status |= WOW64_HANDLE_DIRTY;
    return TRUE;
}

VOID
CloseWow64Handle (
    WOW64_HANDLE *pHandleBlock
    )
{
    RtlEnterCriticalSection(&HandleTable);
    pHandleBlock->hBase = NULL;
    pHandleBlock->hRemap = NULL;
    pHandleBlock->Status = 0;
    pHandleBlock->Attribute = 0;
    RtlLeaveCriticalSection(&HandleTable);
}

BOOL
Wow64RegCloseKey (
    HANDLE hKey
    )
/*++

Routine Description:

    Remove entry associated with the handle.

Arguments:

    hKey - Handle to the key that is being closed.

Return Value:

    TRUE if function succeed.
    FALSE otherwise.
--*/
{

    WOW64_HANDLE *pHandleBlock;
    hKey = (HANDLE)((SIZE_T)hKey & ~3);  //ignore the last 2 bits

    if (!bReflectorStatusOn)
        return TRUE;  //reflector isn't enable yet.

    if ((pHandleBlock = GetHandleBlock (hKey)) == NULL )
        return FALSE;
    
    

    if (pHandleBlock->Status & WOW64_HANDLE_DIRTY)  // if the handle is dirty sync the node
        NtSyncNode ( hKey, NULL, FALSE ); //BUGBUG

    if ( pHandleBlock->hRemap!= hKey )
        MyNtClose ( pHandleBlock->hRemap ); // if Same then just allocating block

    CloseWow64Handle ( pHandleBlock );


    //
    // Call sync APi. to synchronize the registry reflection
    //


    return TRUE;

}

void
CleanupReflector (
    DWORD dwFlag
    )
/*++

Routine Description:

  This routine is called while apps is shutting down. This will give reflector a chance to
  reflect any leftover handle than need reflection.

  This can be called from multiple places, like NtTerminateProcess, Advapi32 dll 
  detach or shutdown routine.

  

Arguments:

  dwFlag - for future use to track from where this call came from.

Return Value:

  None.
--*/
{
        WOW64_HANDLE *pList;
    DWORD i,k;

    for (i=0;i<TABLE_SEGMENT_MAX, List[i] != NULL;i++) {

        pList = (WOW64_HANDLE *)List[i];
        for (k=0;k<SEGMENT_SIZE;k++)

            if ((pList[k].hBase != NULL) && (pList[k].Status & WOW64_HANDLE_DIRTY) )
                Wow64RegCloseKey(pList[k].hBase);
    }
}


NTSTATUS 
Wow64NtClose(
    IN HANDLE Handle
    )
/*++

Routine Description:

    Intercept NtClose Call.

Arguments:

    Handle - Handle to the object that is being closed.

Return Value:

    return valid NTSTATUS
--*/
{
      
    Wow64RegCloseKey ( Handle );
    return NtClose ( Handle );
}

BOOL
IsOnReflectionList (
    PWCHAR Path
    )
/*++

Routine Description:

    Check if the given path is on the list of reflection.

Arguments:

    Path - Path to the key that need to be chacked for reflection.

Return Value:

    TRUE if the key is on the list of reflection.
    FALSE otherwise.
--*/
{
    DWORD i =0;

    //
    // Check exception to the list, non reflectable like uninstaller/TypeLib etc
    //

    //
    // _Classes \Registry\user\sid_Classes is reflected by default.
    //

    
    //if ( wcslen (Path) >= 69) //sizeof \Registry\user\sid_Classes
    //if ( wcsncmp (Path+61, L"_Classes", 8) == 0 ) //69 is the size of user classes sid and 61 is for sanity check
    if ( wcsistr (Path, L"_Classes"))
        return TRUE;

    if (ReflectListLen[0]==0) {
        i=0;
        while (ReflectList[i][0] != UNICODE_NULL ) {
            ReflectListLen[i] = wcslen (ReflectList[i]);
            i++;
        }

    }

    i=0;
    while (ReflectList[i][0] != UNICODE_NULL ) {
        if ( _wcsnicmp (ReflectList[i], Path, ReflectListLen[i]) == 0)
            return TRUE;
        i++;
    }

    return FALSE;
}

BOOL
UpdateKeyTag (
    HKEY hBase,
    DWORD dwAttribute
    )
/*++

Routine Description:

    Update a particular Key tag, like written by 32bit apps or its a copy by reflector.

Arguments:

    hBase - handle to a key to operate.
    dwAttribute - tag value its can be
                   0x01 written by 32bit apps.
                   0x02 created by reflector.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{

    //
    // the flag can't be >0x0f i.e., last 4 bits
    //

    
    KEY_USER_FLAGS_INFORMATION sFlag;
    NTSTATUS st;

    sFlag.UserFlags = dwAttribute;
    


    st = NtSetInformationKey(
        hBase,
        KeyUserFlagsInformation,
        &sFlag,
        sizeof( KEY_USER_FLAGS_INFORMATION)
        );

    if (!NT_SUCCESS (st))
        return FALSE;
    return TRUE;

}

BOOL
QueryKeyTag (
    HKEY hBase,
    DWORD *dwAttribute
    )
/*++

Routine Description:

    Read Key tag, like written by 32bit apps or its a copy by reflector.

Arguments:

    hBase - handle to a key to operate.
    dwAttribute - receive the TAG
                   0x01 written by 32bit apps.
                   0x02 created by reflector.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    DWORD ResLen;
    KEY_USER_FLAGS_INFORMATION sFlag;
    NTSTATUS st;

    if ( dwAttribute == NULL )
        return FALSE;

    if ( hBase == NULL ) 
        return FALSE;

    *dwAttribute  =0;

    st = NtQueryKey(
        hBase,
        KeyFlagsInformation,
        (PVOID)&sFlag,
        sizeof(KEY_FLAGS_INFORMATION),
        &ResLen);

    if (!NT_SUCCESS (st))
        return FALSE;

    *dwAttribute = sFlag.UserFlags;
    return TRUE;

}

BOOL
SyncValue (
    HANDLE hBase, 
    HANDLE hRemap,
    DWORD  dwDirection,
    DWORD  dwFlag
    )
/*++

Routine Description:

    Synchronize a two node with value Key. Delete from the RemapKey, and copy from Base

Arguments:

    hBase - Handle to the src key.
    hRemap - Handle to the remap key.
    dwDirection - SyncDitection
            DIRECTION_32_TO_64 - 32bit is the source of information
            DIRECTION_64_TO_32 - 32bit is the source of information

    dwFlag - determine the behavior of the operation.
            DELETE_SRC_VALUEKEY delete source value key after coping on the dest.
            DONT_DELETE_DEST_VALUEKEY don't delete dest before copying from src.
            DEFAULT_FLAG - this means the default operation.
            SYNC_VALUE_IF_REFLECTED_KEYS - if either one is reflected key then sync.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    HANDLE hTimeStampKey;
    NTSTATUS st= STATUS_SUCCESS;
    DWORD Index=0;

    DWORD ResultLength;
    DWORD LastKnownSize = 0;
    UNICODE_STRING      UnicodeValueName;

    PKEY_VALUE_FULL_INFORMATION KeyValueInformation = NULL;
    BYTE Buff [sizeof(KEY_VALUE_FULL_INFORMATION) + 2048];
    WCHAR TmpChar;
    ULONG Length = sizeof(KEY_VALUE_FULL_INFORMATION) + 2048; 

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buff;
    

    if ( SYNC_VALUE_IF_REFLECTED_KEYS & dwFlag) {

        DWORD Attrib1 =0;
        DWORD Attrib2 =0;

        QueryKeyTag (hBase, &Attrib1);
        QueryKeyTag (hRemap, &Attrib2);

        //
        // if atleast one is a reflected Key then sync value
        //
        if (!( (Attrib1 & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ||
            (Attrib2 & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ) )   // reflector touched this Key
        return TRUE;
    }

    for (Index=0;;Index++) {

        st = NtEnumerateValueKey(
                                 hRemap,
                                 Index,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 Length,
                                 &ResultLength
                                 );

        if (!NT_SUCCESS(st))
            break;

        KeyValueInformation->Name[KeyValueInformation->NameLength/2] = UNICODE_NULL;
        RtlInitUnicodeString( &UnicodeValueName, KeyValueInformation->Name );

        if ( !(DONT_DELETE_DEST_VALUEKEY & dwFlag))
        if ( NtDeleteValueKey(
                        hRemap,
                        &UnicodeValueName
                        ) == STATUS_SUCCESS ) Index--;
    }

    //
    // Copy all key from the Base. For each copy patch value if applicable
    //

    for (Index=0, st= STATUS_SUCCESS;;Index++) {

        st = NtEnumerateValueKey(
                                 hBase,
                                 Index,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 Length,
                                 &ResultLength
                                 );

        if (st == STATUS_BUFFER_OVERFLOW ) {
            //Allocate more Buffer BUGBUG name shouldn't that big
            DbgPrint ("\nWow64: Will ignore any Key value larger than 2048 byte");
        }

        if (!NT_SUCCESS (st))
            break;

        TmpChar = KeyValueInformation->Name[KeyValueInformation->NameLength/2];
        KeyValueInformation->Name[KeyValueInformation->NameLength/2] = UNICODE_NULL;
        RtlInitUnicodeString( &UnicodeValueName, KeyValueInformation->Name );

        
        //
        // Check if you need to filter the Value DllSurrogate is such one.
        //
        if (dwFlag & DONT_SYNC_IF_DLL_SURROGATE) {
            if (_wcsnicmp (KeyValueInformation->Name, L"DllSurrogate",12 )==0 && KeyValueInformation->DataLength <=2) // size of UNICODE_NULL
            continue;
        }

        if ( (DELETE_SRC_VALUEKEY & dwFlag))  //delete from source in case of runonce
            if ( NtDeleteValueKey(
                    hBase,
                    &UnicodeValueName
                    ) == STATUS_SUCCESS ) Index--;

        if ( (PATCH_VALUE_KEY_NAME & dwFlag) && (DIRECTION_32_TO_64 == dwDirection)) {
            wcscat (KeyValueInformation->Name, L"_x86");
            RtlInitUnicodeString( &UnicodeValueName, KeyValueInformation->Name );
            
        }

        KeyValueInformation->Name[KeyValueInformation->NameLength/2] = TmpChar;

        NtSetValueKey(
                    hRemap,
                    &UnicodeValueName,
                    KeyValueInformation->TitleIndex,
                    KeyValueInformation->Type,
                    (PBYTE)(KeyValueInformation)+KeyValueInformation->DataOffset,
                    KeyValueInformation->DataLength
                    );

        

    }
   
    //
    // Now reflect the security attribute
    //
    Wow64ReflectSecurity (hBase, hRemap );
 
    return TRUE;
}

BOOL 
ReflectDllSurrogateKey (
    PWCHAR SrcNode
    )

    /*++

Routine Description:

    Determine if the DllSurrogateKey under AppID shoule be reflected.
    //By default this should always be reflected. Except when the key is empty.

Arguments:

    SrcNode - Name of the node to be synced.

Return Value:

    TRUE if the key Should be reflected.
    FALSE otherwise.
--*/
{

        

        
        BYTE KeyBuffer[512];
        DWORD KeyBufferSize = sizeof (KeyBuffer);
        DWORD ResultLength;
        UNICODE_STRING ValueName;
        NTSTATUS Status;
        PWCHAR pStr;
        HKEY hKey;

        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = NULL;
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyBuffer;
        RtlInitUnicodeString (&ValueName, L"");
    
        //
        // Apply special rule of empty AppID key for dll surrogate.
        //
     
        if ( ( pStr = wcsistr (SrcNode, L"\\DllSurrogate") ) == NULL) 
            return TRUE;

        if ( *(pStr+13) != UNICODE_NULL) {
            return TRUE;
        }
        //
        // Consider only value in that key
        //

        

        //
        // if value key isn't empty reflect, i.e., return FALSE.
        //


        hKey = OpenNode (SrcNode);
        *(LONG *)KeyValueInformation->Data = 0;

        Status = NtQueryValueKey(
                        hKey,
                        &ValueName,
                        KeyValuePartialInformation,
                        KeyValueInformation,
                        KeyBufferSize,
                        &ResultLength);
        if (NULL != hKey)    
            NtClose (hKey);  // reflection should be disable because setup is on its way.

        if ( *(LONG *)KeyValueInformation->Data == 0)
            return FALSE;

        return TRUE;

}

BOOL 
ReflectInprocHandler32KeyByHandle (
    HKEY hKey
    )

    /*++

Routine Description:

    Determine if the ReflectInprocHandler32Key under CLSID shoule be reflected.
    //By default this should always be reflected. Except when the key is empty.

Arguments:

    SrcNode - Name of the node to be synced.

Return Value:

    TRUE if the key Should be reflected.
    FALSE otherwise.
--*/
{

        

        
        BYTE KeyBuffer[512];
        DWORD KeyBufferSize = sizeof (KeyBuffer);
        DWORD ResultLength;
        UNICODE_STRING ValueName;
        NTSTATUS Status;
        PWCHAR pStr;
        

        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = NULL;
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyBuffer;
        RtlInitUnicodeString (&ValueName, L""); //default value Key
    
        
        //
        // if value key isn't empty reflect, i.e., return FALSE.
        //
        //return FALSE; //never reflect


        *(LONG *)KeyValueInformation->Data = 0;

        Status = NtQueryValueKey(
                        hKey,
                        &ValueName,
                        KeyValuePartialInformation,
                        KeyValueInformation,
                        KeyBufferSize,
                        &ResultLength
                        );
        

        pStr = (PWCHAR)KeyValueInformation->Data;

        if ( NT_SUCCESS(Status) && pStr != NULL) { //Need to check type

            if ( 0 == _wcsnicmp (pStr, L"ole32.dll", 9))
                return TRUE;

            if ( 0 == _wcsnicmp (pStr, L"oleaut32.dll", 12))
                return TRUE;
        }

        return FALSE;
}

BOOL 
ReflectInprocHandler32KeyByName (
    PWCHAR SrcNode
    )

    /*++

Routine Description:

    Determine if the ReflectInprocHandler32Key under CLSID shoule be reflected.
    //By default this should always be reflected. Except when the key is empty.

Arguments:

    SrcNode - Name of the node to be synced.

Return Value:

    TRUE if the key Should be reflected.
    FALSE otherwise.
--*/
{


        HKEY hKey;
        BOOL bRet = FALSE;

        hKey = OpenNode (SrcNode);

        if ( NULL != hKey ) {
            bRet = ReflectInprocHandler32KeyByHandle (hKey);
            NtClose (hKey);
        }

        return bRet;
}

BOOL
TaggedKeyForDelete (
    PWCHAR SrcNode
    )
/*++

Routine Description:

    Check if the Tagged deletion and noclobber rule should be applicable on this key.

Arguments:

    SrcNode - Name of the node to be checked.

Return Value:

    TRUE if the rule is applicable.
    FALSE otherwise.
--*/ 
{
        if ( wcsistr (SrcNode, L"Classes\\CLSID\\{") != NULL ) 
            return TRUE;

        if ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\CLSID\\{") != NULL ) 
            return TRUE;

        if ( ( wcsistr (SrcNode, L"Classes\\AppID\\{") != NULL ) ||
            ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\AppID\\{") != NULL ) ) 
            return TRUE;

    return FALSE;
}

BOOL
IsExemptReflection ( 
    PWCHAR SrcNode
    )
/*++

Routine Description:

    Check if the is is on the exempt list from reflection.

Arguments:

    SrcNode - Name of the node to be synced that need to be  checked.

Return Value:

    TRUE if the key is on the exempt list.
    FALSE otherwise.
--*/ 
{
    //
    // Use a static list. 
    //

        
        if ( wcsistr (SrcNode, L"Classes\\Installer") != NULL )
            return TRUE;

        if ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\Installer") != NULL )
            return TRUE;

    return FALSE;
}

BOOL
IsSpecialNode ( 
    PWCHAR SrcNode,
    BOOL *Flag,
    DWORD dwDirection,
    DWORD *pdwKeyType
    )
/*++

Routine Description:

    Check if the node need different treatment.

Arguments:

    SrcNode - Name of the node to be synced.
    Flag - If this fall in the special node category this flag is set TRUE.
    dwDirection - SyncDitection
            DIRECTION_32_TO_64 - 32bit is the source of information
            DIRECTION_64_TO_32 - 32bit is the source of information

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
        *Flag = FALSE;

        if ( wcsistr (SrcNode, L"Classes\\CLSID\\{") != NULL ) { //guid start with {
            *Flag = TRUE;
            ReflectClassGuid ( SrcNode, dwDirection);
        }

        if ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\CLSID\\{") != NULL ) {
            *Flag = TRUE;
            ReflectClassGuid ( SrcNode, dwDirection);
        }

        //
        // Always merge file association BUGBUG: See how bad it is.
        // Must handle special case runonce
        // 

        if ( _wcsnicmp (SrcNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run",75 ) == 0 ) { //75 is the size of the string
            *Flag = TRUE;
        //
        // HandleRunOnce (SrcNode);
        //
        }

        if ( wcsistr (SrcNode, L"Classes\\Installer") != NULL )
            *Flag = TRUE;

        if ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\Installer") != NULL )
            *Flag = TRUE;

        //if ( wcsistr (SrcNode, L"\\Classes\\Interface") != NULL )
          //  *Flag = TRUE;

        //if ( wcsistr (SrcNode, L"\\Classes\\Wow6432Node\\Interface") != NULL )
          //  *Flag = TRUE;

        //if (_wcsnicmp (SrcNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\TypeLib", sizeof (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\TypeLib")/2 -1)==0)
          //  *Flag = TRUE;
    
        //if (_wcsnicmp (SrcNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\TypeLib", sizeof (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\TypeLib")/2 -1)==0)
          //  *Flag = TRUE;

        if ( ( wcsistr (SrcNode, L"Classes\\AppID\\{") != NULL ) ||
            ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\AppID\\{") != NULL ) ) {

            *pdwKeyType = DONT_SYNC_IF_DLL_SURROGATE;

        }
            
    return *Flag;
}

BOOL
NtSyncNode (
    HANDLE hBase,
    PWCHAR AbsPath,
    BOOL bFlag
    )
/*++

Routine Description:

    Synchronize a tree based while closing a Key that was dirty.

Arguments:

    hBase - Handle to the open Key.
    AbsPath - The original path application has created a key.
    bFlag - specify the sync property.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    WCHAR DestNode[WOW64_MAX_PATH];
    WCHAR SrcNode[WOW64_MAX_PATH];
    BOOL bSpecialNode = FALSE;

    DWORD dwLen = WOW64_MAX_PATH;
    HKEY hRemap;
    HKEY hBaseNew;
    BOOL bRet;
    DWORD dwDirection;
    DWORD dwKeyType =0;
    
    //
    // If handle is null try to open the key on the otherside of the registry and pull that in.
    //

    if ( hBase != NULL ) {
       if (!HandleToKeyName ( hBase, SrcNode, &dwLen ))
            return FALSE;
    } else wcscpy (SrcNode, AbsPath);


    if (wcsistr (SrcNode, L"Wow6432Node") != NULL ) {

        dwDirection = DIRECTION_32_TO_64;
        Map32bitTo64bitKeyName ( SrcNode, DestNode );

    } else {
        dwDirection = DIRECTION_64_TO_32;
        Map64bitTo32bitKeyName ( SrcNode, DestNode );
    }

    //
    // check if both are the same
    //
    if (_wcsicmp ( SrcNode, DestNode ) == 0)
        return TRUE; //source and destination is the same

    //DbgPrint ("\nSyncing Node %S", SrcNode );

    if (! (bFlag & SKIP_SPECIAL_CASE ))
    if (IsSpecialNode ( SrcNode, &bSpecialNode, dwDirection, &dwKeyType  )) //special rule is applicable here.
        return TRUE;

    hRemap = OpenNode (DestNode);
    hBaseNew = OpenNode (SrcNode); // Open source in case user didn't open it with query priviledge.

    if ( hRemap == NULL && (!( bFlag & DONT_CREATE_DEST_KEY)) ) { //check if you should create this node
        //
        // Always create unless GUID or .abc, then you need to do some additional check.
        //
        if ( CreateNode (DestNode)) {
            hRemap = OpenNode (DestNode);
            UpdateKeyTag ( hRemap, TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE);
        }
    }

    

    
    //
    // SyncValue only, delete all the value from destination and recopy.
    // Generated Key will be reflected by create key.
    //

    if ( hBaseNew!= NULL && hRemap != NULL ) 
        bRet = SyncValue (hBaseNew, hRemap, dwDirection, DEFAULT_FLAG | dwKeyType );

    MyNtClose (hRemap); // Close the handle
    MyNtClose (hBaseNew); // Close the NewHandle
    return bRet;
    //
    // Check for existamce?
    //
 
}

LONGLONG
CmpKeyTimeStamp (
    HKEY hSrc,
    HKEY hDest
    )
/*++

Routine Description:

    Compare Key time stamp.

Arguments:

    hSrc - handle to the src Key.
    hDest - Handle to the dest Key.

Return Value:

    0 - if timestamp of hSrc == timestamp of hDest
    >0 - if timestamp of hSrc > timestamp of hDest
    <0 - if timestamp of hSrc < timestamp of hDest
    FALSE otherwise.
--*/
{
    NTSTATUS st= STATUS_SUCCESS;
    DWORD Index=0, ResultLength;

    LONGLONG TimeSrc=0;
    LONGLONG TimeDest=0;

    PKEY_BASIC_INFORMATION KeyInformation = NULL;
    BYTE Buff [sizeof(KEY_BASIC_INFORMATION) + 256];

    ULONG Length = sizeof(KEY_BASIC_INFORMATION) + 256;
    KeyInformation = (PKEY_BASIC_INFORMATION)Buff;

    

     st = NtQueryKey(
                        hSrc,
                        KeyBasicInformation,
                        KeyInformation,
                        Length,
                        &ResultLength
                        );
     if(NT_SUCCESS (st))
         TimeSrc = *(LONGLONG *)&KeyInformation->LastWriteTime;

     st = NtQueryKey(
                        hDest,
                        KeyBasicInformation,
                        KeyInformation,
                        Length,
                        &ResultLength
                        );
     if(NT_SUCCESS (st))
         TimeDest = *(LONGLONG *)&KeyInformation->LastWriteTime;

     if ( TimeDest == 0 || TimeSrc == 0)    
         return 0;

     return TimeSrc - TimeDest;
}

BOOL
IsPresentLocalServerAppID (
    PWCHAR KeyName, 
    PWCHAR pCLSID,
    PWCHAR DestNode
    ) 
/*++

Routine Description:

    Check if a GUID has localserver32 or AppID than should have been 
    reflected on the other side.

Arguments:

    KeyName - Name of the key.
    pCLDID  - pointer to the end of CLSID
    DestNode - Destination CLSID
            


Return Value:

    TRUE if LocalSrever or AppID is there.
    FALSE otherwise.
--*/
{
    HKEY hKeyTemp = NULL;
    DWORD Len = wcslen (DestNode);
    PWCHAR pDest = DestNode+Len;
    DWORD AttribSrc = 0;
    DWORD AttribDest = TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE; //if key doesn't exist
    HKEY hDest = NULL;


    BYTE KeyBuffer[512];
    DWORD KeyBufferSize = sizeof (KeyBuffer);
    DWORD ResultLength;
    UNICODE_STRING ValueName;
    NTSTATUS Status;
    HKEY hKey;

    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = NULL;
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyBuffer;
    RtlInitUnicodeString (&ValueName, L"APPID");







    wcscpy (pCLSID-1, L"\\LocalServer32");

    hKeyTemp = OpenNode (KeyName);
    if (hKeyTemp == NULL ) {

        wcscpy (pCLSID-1, L"\\AppID");

        hKeyTemp = OpenNode (KeyName);
        if (hKeyTemp == NULL ) {
            //
            // Check APPID value key associated with the GUID.
            //
            *(pCLSID-1)= UNICODE_NULL;
            hKeyTemp = OpenNode (KeyName);
            if (hKeyTemp != NULL ) { // query for APPID

                Status = NtQueryValueKey(
                        hKeyTemp,
                        &ValueName,
                        KeyValuePartialInformation,
                        KeyValueInformation,
                        KeyBufferSize,
                        &ResultLength);

                if (!NT_SUCCESS (Status)) {
                    MyNtClose(hKeyTemp);
                    return FALSE;
                }
                *pDest = UNICODE_NULL;
                hDest = OpenNode (DestNode);
            }
        }

        wcscpy (pDest, L"\\AppID");
        hDest = OpenNode (DestNode);
        *pDest = UNICODE_NULL;
      

    }else  {
        wcscpy (pDest, L"\\LocalServer32");
        hDest = OpenNode (DestNode);
        *pDest = UNICODE_NULL;
        
    }

    

    QueryKeyTag (hKeyTemp, &AttribSrc);
    QueryKeyTag (hDest, &AttribDest);
    MyNtClose (hDest);
    MyNtClose (hKeyTemp);

    //
    // if atleast one is a reflected Key then sync value
    //
    if ( (AttribSrc & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ||
        (AttribDest & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) )   // reflector touched this Key
        return TRUE;

    return FALSE;  //Yepp ID is present and the guid can be reflected

}

BOOL 
ReflectClassGuid (
    PWCHAR SrcName,
    DWORD dwDirection
    )
/*++

Routine Description:

    Synchronize a two node with value Key. Delete from the RemapKey, and copy from Base

Arguments:

    SrcName - Name of the key on CLSID path.
    dwDirection - SyncDitection
            DIRECTION_32_TO_64 - 32bit is the source of information
            DIRECTION_64_TO_32 - 32bit is the source of information


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/

{
    PWCHAR pCLSID;
    DWORD  dwLen;
    WCHAR  KeyName[256];  //You don't need this big Key for CLSID
    WCHAR  DestNode[256];
    
    HANDLE hKeyTemp;
    HANDLE hSrc;
    HANDLE hDest;
    BOOL bNewlyCreated = FALSE;
    //
    // If Localserver is present for that key, sync from the CLSID.
    //


    pCLSID = wcsistr (SrcName, L"\\CLSID\\{");
    if ( pCLSID == NULL )
        return TRUE;
    wcscpy (KeyName, SrcName );
    pCLSID = &KeyName[(DWORD)(pCLSID - SrcName)];
    pCLSID +=7; // point start of guid {

    // Sanity Check and will be good enough????
    if ( pCLSID[9] != L'-' || pCLSID[14] != L'-' ||  pCLSID[19] != L'-' ||
          pCLSID[24] != L'-' || pCLSID[37] != L'}' )
        return FALSE;


    //DbgPrint ("\nTrying to sync GUID %S", SrcName);


    //
    // Initially sync the Key first in case time stamp is same because of resolution.
    // Cey Creation will be done while syncing Key from GUID
    //
    pCLSID +=39;
    if ( *(pCLSID-1) != UNICODE_NULL ) {  //check if following is applicable.

        if ( _wcsnicmp (pCLSID, L"InprocServer32", 14) == 0 ) //Skip Inproc server
                return TRUE;

        if ( _wcsnicmp (pCLSID, L"InprocHandler32", 15) == 0 ) {//Check  InprocHandler 
            if (!ReflectInprocHandler32KeyByName (KeyName))
                return TRUE;
        }
    }

    
    //
    // Get other path.
    //
    *(pCLSID-1)= UNICODE_NULL; // Make path only to the GUID
    if ( dwDirection == DIRECTION_32_TO_64 )
        Map32bitTo64bitKeyName ( KeyName, DestNode );  //get 64bit side //BUGBUG: you can optimize this
    else if ( dwDirection == DIRECTION_64_TO_32 )
        Map64bitTo32bitKeyName ( KeyName, DestNode );  //get 32bit side

    //
    // If the other hive has InProcHandler ignore this reflection rule
    // After Beta1 or apply by Tag
    //

    if ( !IsPresentLocalServerAppID (KeyName, pCLSID, DestNode) )
        return TRUE;

    //
    // Now time to reflect everything except InprocServer32
    //

    pCLSID--;
    pCLSID[0]= UNICODE_NULL; // Make path only to the GUID


    hSrc = OpenNode (KeyName);
    if (hSrc == NULL )
        return TRUE;

    hDest = OpenNode (DestNode);
    if ( hDest == NULL ) {

        CreateNode (DestNode);
        hDest = OpenNode (DestNode);
        if (hDest != NULL) {

            UpdateKeyTag ( hDest, TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE);
            bNewlyCreated = TRUE;
            SyncValue ( hSrc, hDest, dwDirection, 0);
        }
    } 
        

    if (hDest != NULL && hSrc != NULL) {
        //
        // Sync Value on current Node
        //
        //if ( !bNewlyCreated ) {
            //
            // if destination is a copy then update this.
            //
            DWORD Attrib1=0;
            DWORD Attrib2=0;
            HKEY hSrcKey1;
            HKEY hDestKey1;

            

            if ( dwDirection == DIRECTION_32_TO_64 )
                Map32bitTo64bitKeyName ( SrcName, DestNode );  //get 64bit side //BUGBUG: you can optimize this
            else if ( dwDirection == DIRECTION_64_TO_32 )
                Map64bitTo32bitKeyName ( SrcName, DestNode );  //get 32bit side

            hSrcKey1 = OpenNode (SrcName);
            hDestKey1 = OpenNode (DestNode);

            if ( hSrcKey1 != NULL && hDestKey1 != NULL )  //if dest isn't reflected key should you merge?
                //
                // 64bit Local Server might get priority
                //
                SyncValue ( hSrcKey1, hDestKey1, dwDirection, SYNC_VALUE_IF_REFLECTED_KEYS);

            MyNtClose ( hSrcKey1 );
            MyNtClose ( hDestKey1 );
        //}

        SyncGuidKey (hSrc, hDest, dwDirection, FALSE );
    }

    MyNtClose (hDest);
    MyNtClose (hSrc);
    return TRUE;

}

BOOL 
SyncGuidKey (
    HANDLE hSrc, 
    HANDLE hDest,
    DWORD dwDirection,
    DWORD __bNewlyCreated
    )
/*++

Routine Description:

    Synchronize a two CLSID Node.

Arguments:

    hSrc - Handle to Source Class GUID.
    hDest - Handle to dest Class GUID.
    dwDirection - SyncDitection
            DIRECTION_32_TO_64 - 32bit is the source of information
            DIRECTION_64_TO_32 - 32bit is the source of information
    __bNewlyCreated - if the destination is just created.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    //
    // Enumerate every key under src and recursively copy that except InProcServer32
    //

    HANDLE hSrcNew;
    HANDLE hDestNew;
    OBJECT_ATTRIBUTES Obja;

    NTSTATUS st= STATUS_SUCCESS;
    DWORD Index=0;

    LONGLONG TimeDiff;
    BOOL bNewlyCreated = FALSE;

    DWORD ResultLength;
    UNICODE_STRING      UnicodeKeyName;

    PKEY_NODE_INFORMATION KeyInformation = NULL;
    BYTE Buff [sizeof(KEY_NODE_INFORMATION) + 256];
    DWORD Length = sizeof (Buff);

    KeyInformation = (PKEY_NODE_INFORMATION)Buff;
    


    //
    // Sync Value first.
    //
    //TimeDiff = CmpKeyTimeStamp ( hSrc, hDest );
    //if (TimeDiff > 0 || __bNewlyCreated ) { //for newnly created key always merge. 
    if (__bNewlyCreated ) { //for newnly created key always merge. 
        SyncValue ( hSrc, hDest, dwDirection, DEFAULT_FLAG);
        //LogMsg (hSrc, L"Copy Guid Keys..");
    }

    //
    // Enumerate all key from the hRemap and delete.
    //
    for (Index=0;;Index++) {

        st = NtEnumerateKey(
                            hSrc,
                            Index,
                            KeyNodeInformation,
                            KeyInformation,
                            Length,
                            &ResultLength
                            );

        if (!NT_SUCCESS(st))
            break;

        KeyInformation->Name[KeyInformation->NameLength/2] = UNICODE_NULL;
        RtlInitUnicodeString( &UnicodeKeyName, KeyInformation->Name );

        if (_wcsnicmp (KeyInformation->Name, L"InprocServer32", 14) == 0 ) //Skip Inproc server
            continue;

        InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hSrc, NULL );

        //
        //  Open source key on the Source Side;
        //
        st = NtOpenKey (&hSrcNew, KEY_ALL_ACCESS, &Obja);
        if (!NT_SUCCESS(st))
            continue;

        if (_wcsnicmp (KeyInformation->Name, L"InprocHandler32", 15) == 0 ) {//Check  InprocHandler 
            if (!ReflectInprocHandler32KeyByHandle (hSrcNew)) {
                NtClose (hSrcNew);
                continue;
            }
        }
        
        //
        // Create or open the key on the dest side.
        //
        InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hDest, NULL );
        bNewlyCreated = FALSE;

        st = NtOpenKey (&hDestNew, KEY_ALL_ACCESS, &Obja);
        if (!NT_SUCCESS(st))  {

            //
            // Try to create the key here
            //
            st = NtCreateKey(
                        &hDestNew,
                        KEY_ALL_ACCESS,
                        &Obja,
                        0,
                        NULL ,
                        REG_OPTION_NON_VOLATILE,
                        NULL
                        );
            if (!NT_SUCCESS(st)) {
                NtClose (hSrcNew);
                continue;
            }
            bNewlyCreated = TRUE;
            UpdateKeyTag ( hDestNew, TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE );
        }
        //
        // Sync only when Key is created.
        //
        SyncGuidKey ( hSrcNew, hDestNew, dwDirection, bNewlyCreated );
        
        NtClose (hSrcNew);
        NtClose (hDestNew);
    }

    return TRUE;
}

BOOL 
SyncKeysOnBoot ( )
/*++

Routine Description:

  Sync Certain Keys on Boot.
  We don't have any particular list or way to figure it out what need to be synced but this 
  can be extended as request comes.

Arguments:

  None.

Return Value:

  TRUE on success.
  FALSE otherwise.
--*/

{
    //
    // Sync some setup information here. 
    //

    HKEY hSrc;
    HKEY hDest;
    BOOL bRet = FALSE;

    if ( (hSrc = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")) == NULL)
        return FALSE;

    if ( (hDest = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion")) == NULL) {
        NtClose (hSrc);
        return FALSE;
    }


    
    bRet = SyncValue ( hSrc, hDest, DIRECTION_64_TO_32, DONT_DELETE_DEST_VALUEKEY );
            
            

    NtClose (hSrc);
    NtClose (hDest);
    return bRet;

}


BOOL 
Wow64SyncCLSID ()
/*++

Routine Description:

    Synchronize CLSID on the machine hive.
    Algorithm:
        1. Enumerate all guid on 64bit side, if the guid has the local 
            server and the other side don't have the guid, sync this.
        2. Apply the same rule for 32bit side as well.
        3. This is only applicable for machine hives only.
        4. This function will run at the end of setup once to sync some guid.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    //
    // Enumerate every key under src and recursively copy that except InProcServer32
    //

    HANDLE hSrc;
    HANDLE hSrcTemp;

    HANDLE hSrcNew;
    HANDLE hDestNew;

    OBJECT_ATTRIBUTES Obja;
    WCHAR Path [256];

    NTSTATUS st= STATUS_SUCCESS;
    DWORD Index=0;

    DWORD ResultLength;
    UNICODE_STRING      UnicodeKeyName;

    PKEY_NODE_INFORMATION KeyInformation = NULL;
    BYTE Buff [sizeof(KEY_NODE_INFORMATION) + 256];
    DWORD Length = sizeof (Buff);

    DWORD dwDirection = DIRECTION_64_TO_32;

    KeyInformation = (PKEY_NODE_INFORMATION)Buff;

    for (;;) {

        if ( dwDirection == DIRECTION_64_TO_32 )
            hSrc = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\CLSID");
        else hSrc = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\CLSID");

        //
        // Enumerate all key from the hRemap and delete.
        //
        for (Index=0;;Index++) {

            st = NtEnumerateKey(
                                hSrc,
                                Index,
                                KeyNodeInformation,
                                KeyInformation,
                                Length,
                                &ResultLength
                                );

            if (!NT_SUCCESS(st))
                break;

            KeyInformation->Name[KeyInformation->NameLength/2] = UNICODE_NULL;
            wcscpy (Path, KeyInformation->Name);

            wcscat ( Path,L"\\LocalServer32");
            RtlInitUnicodeString( &UnicodeKeyName, Path );

            InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hSrc, NULL );

            //
            //  Open source key on the Source Side;
            //
            st = NtOpenKey (&hSrcTemp, KEY_READ, &Obja);
            if (!NT_SUCCESS(st)) { // Local Server Key doesn't exist

                wcscpy (Path, KeyInformation->Name);
                wcscat ( Path,L"\\AppID");

                RtlInitUnicodeString( &UnicodeKeyName, Path );
                InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hSrc, NULL );

                st = NtOpenKey (&hSrcTemp, KEY_READ, &Obja);
                if (!NT_SUCCESS(st)) // AppID Key doesn't exist
                    continue;  
                else NtClose (hSrcTemp);

            } else NtClose (hSrcTemp);

            //
            // Check if the guid exists on the other side, if so continue.
            //
            if ( dwDirection == DIRECTION_64_TO_32 )
                wcscpy (Path,L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\CLSID\\");
            else
                wcscpy (Path,L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\CLSID\\");

            wcscat (Path,KeyInformation->Name );
            hSrcTemp = OpenNode (Path);

            if (hSrcTemp != NULL ) {

                NtClose (hSrcTemp );
                continue;
            }

            //
            // Create or open the key on the dest side.
            //
            if ( !CreateNode (Path))
                continue;
        
            if ( (hDestNew = OpenNode (Path))==NULL)
                continue;

            UpdateKeyTag ( hDestNew, TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE ); //Mark the key as reflected.
        
            RtlInitUnicodeString( &UnicodeKeyName, KeyInformation->Name );
            InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hSrc, NULL );

            st = NtOpenKey (&hSrcNew, KEY_ALL_ACCESS, &Obja);
            if (!NT_SUCCESS(st)) {
                NtClose (hDestNew);
                continue;  
            }

            SyncGuidKey ( hSrcNew, hDestNew, dwDirection, 1);
            NtClose (hSrcNew);
            NtClose (hDestNew);
        } //for-loop enumeration all guids

        NtClose ( hSrc );
      
        if (DIRECTION_32_TO_64 == dwDirection)
            break;

        if (dwDirection == DIRECTION_64_TO_32 )
            dwDirection = DIRECTION_32_TO_64;
        
    } //for loop for direction

    SyncKeysOnBoot (); //sync some special value keys

    return TRUE;
}


VOID 
PatchPathOnValueKey (
    ULONG DataSize,
    ULONG Type,
    WCHAR *Data,
    WCHAR *RetDataBuff,
    ULONG *pCorrectDataSize
    )
/*++

Routine Description:

    Patch the value key while writing on the 32bit side.

Arguments:

    DataSize - Size of data in byte in the buffer.
    Type - registry value type.
    Data - data buffer.
    RetDataBuffer - will contain the patched value.
    pCorrectDataSide - Will have the updated size.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    WCHAR ThunkData[256];
    PWCHAR pCorrectData = (PWCHAR)Data;

    *pCorrectDataSize = DataSize;


    //
    // thunk  %ProgramFiles%  ==> %ProgramFiles(x86)% 
    //        %commonprogramfiles% ==> %commonprogramfiles(x86)%
    //

   

    if (DataSize < ( sizeof (ThunkData) - 10) && (Type == REG_SZ || Type == REG_EXPAND_SZ ) )  { //(x86)==>10 byte

        //
        // do the thunking here.
        //

        PWCHAR p;
        PWCHAR t;

        memcpy ( (PBYTE ) &ThunkData[0], (PBYTE)Data, DataSize);
        ThunkData [DataSize/sizeof (WCHAR) ] = UNICODE_NULL; // make sure NULL terminated
        
        if ( (p = wcsistr (ThunkData, L"%ProgramFiles%" )) != NULL ){

            p +=13; //skip at the end of %ProgramFiles
            

        } else if ( (p = wcsistr (ThunkData, L"%commonprogramfiles%")) != NULL ){

            p +=19; //skip at the end of %commonprogramfiles
            
        }

        if (p) {

            t = pCorrectData + (p - ThunkData);
            wcscpy(p, L"(x86)"); //(x86)
            wcscat(p, t);        //copy rest of the string

            pCorrectData = ThunkData;
            *pCorrectDataSize += sizeof (L"(x86)");
        }

    } //if if (DataSize < ( _MAX_PATH

    if ( pCorrectData == ThunkData )
        memcpy ( RetDataBuff, pCorrectData, *pCorrectDataSize );
}


BOOL
Wow64RegDeleteKey (
    HKEY hBase,
    WCHAR  *SubKey
    )
/*++

Routine Description:

    Delete mirror Key.

Arguments:

    hBase - handle to the base key.
    SubKey - Name of the subkey to be deleted.


Return Value:

    TRUE if the key is on the list of reflection.
    FALSE otherwise.
--*/
{
    //
    // 1. Get the complete path to base.
    // 2. Get Check if the key exist on the reflection list.
    // 3. Delete the mirror.
    //

    WCHAR SrcNode[WOW64_MAX_PATH];
    WCHAR KeyName[WOW64_MAX_PATH];
    PWCHAR pCLSID;
    
    BOOL bSpecialNode = FALSE;

    DWORD dwLen = WOW64_MAX_PATH;
    HKEY hRemap;
    DWORD dwDirection;
    NTSTATUS St;

    
    DWORD AttributeMirrorKey;

    InitHandleTable (); //initialize if its already not initialized.
    if (!bReflectorStatusOn)
        return TRUE;  //reflector isn't enable yet.
    
    if ( hBase == NULL)
        wcscpy ( SrcNode, SubKey);

    else  if (!HandleToKeyName ( hBase, SrcNode, &dwLen ))
        return FALSE;

    if (SubKey != NULL && hBase != NULL) {   // wow64 will call with null subkey

        if (*SubKey != L'\\')
            wcscat (SrcNode, L"\\");
        wcscat (SrcNode, SubKey );
    }
    
    
    //
    // If it's guid then dest mustnot have InprocServer.
    //

    /*
    pCLSID = wcsistr (SrcNode, L"\\CLSID\\{");
    if ( pCLSID != NULL ) {

        HKEY hKeyTemp;
     
        wcscpy (KeyName, SrcNode );
        pCLSID = &KeyName[(DWORD)(pCLSID - SrcNode)];
        pCLSID +=7; // point start of guid {

        // Sanity Check and will be good enough????
        if (!( pCLSID[9] != L'-' || pCLSID[14] != L'-' ||  pCLSID[19] != L'-' ||
            pCLSID[24] != L'-' || pCLSID[37] != L'}' ) ) {
            

            //DbgPrint ("\nTrying to sync GUID %S", SrcName);

            pCLSID +=38;
            wcscpy (pCLSID, L"\\InprocServer32");

            hKeyTemp = OpenNode (KeyName);
            if (hKeyTemp != NULL ) {

                MyNtClose (hKeyTemp);
                return TRUE; // Shouldn't detele InprocSrver32
            }

            wcscpy (pCLSID, L"\\InprocHandler32");

            hKeyTemp = OpenNode (KeyName);
            if (hKeyTemp != NULL ) {  

                MyNtClose (hKeyTemp);
                return TRUE; // Shouldn't delete InprocHandler
            }
        } // if initial guid check succeed
    }  //  if \CLSID\{ is there
    */

    
    
    //
    // The other Key has already been deleted. You can delete this or wait.
    //

    if ( TaggedKeyForDelete (SrcNode) ) {

        DWORD Attrib1 = 0;
      
        QueryKeyTag (hBase, &Attrib1);
        

        //*** finetune the rule remove key only with reflected tag.
        //if (!( (Attrib1 & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ||
        //    (AttributeMirrorKey & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ))   // reflector touched this Key
        //        return TRUE; // One key must have reflected tag to be deleted.

        if (!(Attrib1 & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE))
            return TRUE; // the isn't tagged as reflected.

    }
    

    //
    //  Delete the key here
    //

    St = NtDeleteKey( hBase );

    return TRUE;
    //
    // Check for existamce?
    //
 
}

BOOL
Wow64ReflectSecurity (
    HKEY SrcKey,
    HKEY DestKey
    )
/*++

Routine Description:

  Copy security attribute from SrcKey to DestKey.

Arguments:

  SrcKey - Handle to a key..
  DestKey - handle to the destination key.

Return Value:

  TRUE if operation succeeded.
  FALSE otherwise. 

--*/
{

    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SD;
    BYTE Buffer[2048]; // reflector only manages general purpose keys and will have smaller ACL
    

    LONG Ret, Len;
    LONG BufferLen = sizeof (Buffer);
    DWORD Count = 0;

    SD = (PSECURITY_DESCRIPTOR)Buffer;

    Len = BufferLen;

    Status = NtQuerySecurityObject(
                     SrcKey,
                     DACL_SECURITY_INFORMATION,
                     SD,
                     Len,
                     &Len
                     );

    if ( NT_SUCCESS (Status )) 
        Status = NtSetSecurityObject(
                        DestKey,
                        DACL_SECURITY_INFORMATION,
                        SD
                        );
    

    Len = BufferLen;

    Status = NtQuerySecurityObject(
                     SrcKey,
                     GROUP_SECURITY_INFORMATION,
                     SD,
                     Len,
                     &Len
                     );

    if ( NT_SUCCESS (Status )) 
        Status = NtSetSecurityObject(
                        DestKey,
                        GROUP_SECURITY_INFORMATION,
                        SD
                        );
    


    Len = BufferLen;
    Status = NtQuerySecurityObject(
                     SrcKey,
                     OWNER_SECURITY_INFORMATION,
                     SD,
                     Len,
                     &Len
                     );

    if ( NT_SUCCESS (Status )) 
        Status = NtSetSecurityObject(
                        DestKey,
                        OWNER_SECURITY_INFORMATION,
                        SD
                        );
    

    


    Len = BufferLen;
    Status = NtQuerySecurityObject(
                     SrcKey,
                     SACL_SECURITY_INFORMATION,
                     SD,
                     Len,
                     &Len
                     );

    if ( NT_SUCCESS (Status )) 
        Status = NtSetSecurityObject(
                        DestKey,
                        SACL_SECURITY_INFORMATION,
                        SD
                        );

    return TRUE;
}

BOOL
IsOnReflectionByHandle ( 
    HKEY KeyHandle 
    )
/*++

Routine Description:

  Check if the key specified by a handle sit on the list of keys of reflection.

Arguments:

  KeyHandle - Handle to a key..

Return Value:

  TRUE if the key sit on the the list of reflection.
  FALSE otherwise.

--*/
{
    WCHAR SrcNode[WOW64_MAX_PATH];
    DWORD dwLen = WOW64_MAX_PATH;
    
    InitHandleTable (); //initialize if its already not initialized.
    if (!bReflectorStatusOn)
        return FALSE;  //reflector isn't enable yet.

    
    if ( KeyHandle == NULL)
        return FALSE;

    else  if (!HandleToKeyName ( KeyHandle, SrcNode, &dwLen ))
        return FALSE;

    return IsOnReflectionList (SrcNode);

}

HKEY
Wow64OpenRemappedKeyOnReflection (
    HKEY SrcKey
    )
/*++

Routine Description:

  Called from advapi to get an handle to remapped key that is on reflection list.

Arguments:

  SrcKey - Handle to a key..

Return Value:

  Valid handle to the reflected key.
  NULL if the function fails.

--*/
{
    PWCHAR DestNode;
    PWCHAR SrcNode;
    BOOL bSpecialNode = FALSE;

    DWORD dwLen = WOW64_MAX_PATH;
    HKEY hRemap;
    NTSTATUS St;

    DestNode = RegRemapAlloc (WOW64_MAX_PATH);
    SrcNode  = RegRemapAlloc (WOW64_MAX_PATH);

    if ( NULL == DestNode || NULL == SrcNode ) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }


    InitHandleTable (); //initialize if its already not initialized.
    if (!bReflectorStatusOn) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;  //reflector isn't enable yet.
    }
    

    
    if ( SrcKey == NULL) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }

    else  if (!HandleToKeyName ( SrcKey, SrcNode, &dwLen )) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }

    if ( !IsOnReflectionList (SrcNode)) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }

    if (wcsistr (SrcNode, L"Wow6432Node") != NULL ) {

        Map32bitTo64bitKeyName ( SrcNode, DestNode );

    } else {
        Map64bitTo32bitKeyName ( SrcNode, DestNode );
    }

    //
    // check if both are the same
    //
    if (_wcsicmp ( SrcNode, DestNode ) == 0) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL; //source and destination is the same
    }

    //
    // Must check the special case, Like Installer/file association....
    //

    if ( IsExemptReflection ( SrcNode )) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }



    if ( (hRemap = OpenNode (DestNode) ) == NULL ){

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }
    

    RegRemapFree ( DestNode );
    RegRemapFree ( SrcNode );

    return hRemap;
}



void
InitializeWow64OnBoot(
    DWORD dwFlag
    )
/*++

Routine Description:

  Called from advapi to get an handle to remapped key that is on reflection list.

Arguments:

  dwFlag - define the point where this function were invoked.
    1- means were invoked from csr service
    2- means this were invoked by setup.

Return Value:

  None.
--*/
{
    DWORD Ret;
    HKEY Key;
    NTSTATUS st;
    
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;

    RtlInitUnicodeString (&KeyName, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes");
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );
    
    st = NtOpenKey (&Key, KEY_ALL_ACCESS, &Obja);
    if (NT_SUCCESS(st)) {
        st = NtDeleteKey (Key);
        NtClose (Key);
    }

    RtlInitUnicodeString (&KeyName, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes");
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    st = NtCreateKey(
                    &Key,
                    KEY_ALL_ACCESS | KEY_CREATE_LINK,
                    &Obja,
                    0,
                    NULL ,
                    REG_OPTION_NON_VOLATILE | REG_OPTION_OPEN_LINK | REG_OPTION_CREATE_LINK,  // special options flag
                    NULL
                    );
    
    if (NT_SUCCESS(st)) {

        RtlInitUnicodeString (&KeyName, L"SymbolicLinkValue");
        st = NtSetValueKey(
                                Key,
                                &KeyName,
                                0  ,
                                REG_LINK,
                                (PBYTE)WOW64_32BIT_MACHINE_CLASSES_ROOT,
                                (DWORD ) (wcslen (WOW64_32BIT_MACHINE_CLASSES_ROOT) * sizeof (WCHAR))
                                );

        
        NtClose(Key);
        if ( !NT_SUCCESS(st) ) {
#if DBG
            DbgPrint ( "Wow64-InitializeWow64OnBoot: Couldn't create symbolic link%S\n", WOW64_32BIT_MACHINE_CLASSES_ROOT);
#endif
            return;
        }
    }
    return;
}

#ifdef _ADVAPI32_
WINADVAPI
LONG
APIENTRY
Wow64Win32ApiEntry (
    DWORD dwFuncNumber,
    DWORD dwFlag,
    DWORD dwRes
    )
/*++

Routine Description:

  This is a generic API exported through adavpi32.dll. Just changing the function number 
  More functionality can be added in the future if needed.

Arguments:

  dwFuncNumber - desired function number. 1 means enable/disable reflection.
  dwFlag - set properties of the function entry. if Function number is 1 flag might be one of them.
    WOW64_REFLECTOR_ENABLE - enable reflection.
    WOW64_REFLECTOR_ENABLE - Disable reflection.
  dwRes - for future uses. set to 0.

Return Value:

  None.
--*/
{
    if (dwFuncNumber == 1) {
        if (dwFlag & WOW64_REFLECTOR_ENABLE )
            bReflectorStatusOn = TRUE;
        else if (dwFlag & WOW64_REFLECTOR_DISABLE )
            bReflectorStatusOn = FALSE;

    }

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\wow64reg\cleanup.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module will cleanup registry with copied entry.

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include "wow64reg.h"
#include <assert.h>
#include "reflectr.h"

DWORD
DeleteValueFromSrc (
    HKEY SrcKey
    )
/*++

Routine Description:

    Delete Wow6432Value key from the node.

Arguments:

    SrcKey - Handle to the src Key.

Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

--*/

{

    DWORD dwIndex =0;
    DWORD Ret;

    HKEY hKey;


    WCHAR Node[_MAX_PATH];

    //Delete wow6432Value Key
    if (RegDeleteValue( SrcKey, (LPCWSTR )WOW6432_VALUE_KEY_NAME) != ERROR_SUCCESS) {
        //Wow64RegDbgPrint (("\nSorry! couldn't remove wow6432 value key or it doesn't exist"))
    }



    for (;;) {

        DWORD Len = sizeof (Node)/sizeof (WCHAR);
        Ret = RegEnumKey(
                          SrcKey,
                          dwIndex,
                          Node,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;

        Ret = RegOpenKeyEx(SrcKey, Node , 0, KEY_ALL_ACCESS, &hKey);
        if (Ret != ERROR_SUCCESS) {
            continue;
        }

        DeleteValueFromSrc (hKey);
        RegCloseKey (hKey);

    }
    return TRUE;
}

DWORD
DeleteKey (
    HKEY DestKey,
    WCHAR *pKeyName,
    DWORD mode
    )
/*++

Routine Description:

    Delete key from the destination node if that was a copy from src node.

Arguments:

    DestKey - Handle to the dest Key.
    pKeyName - Key to delete
    mode   -  deletion mode.
            ==> 0 default remove only copy key.
            ==> 1 remove all key disregarding copy attribute.

Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

--*/

{

    DWORD dwIndex =0;
    DWORD Ret;

    HKEY hKey;


    WCHAR Node[_MAX_PATH];


    BOOL bDeleteNode = FALSE;
    BOOL bEmptyNode = TRUE; // hope that it can delete everything

    WOW6432_VALUEKEY ValueDest;

    Ret = RegOpenKeyEx(DestKey, pKeyName , 0, KEY_ALL_ACCESS, &hKey);
        if (Ret != ERROR_SUCCESS) {
            return Ret;
        }

    GetWow6432ValueKey ( hKey, &ValueDest);


    if ( ValueDest.ValueType == Copy || mode == 1 ) {
        //delete all the values
        bDeleteNode = TRUE; //don't delete this node
    }

    // delete all the subkeys enumerate and delete

    for (;;) {

        DWORD Len = sizeof (Node)/sizeof (Node[0]);
        Ret = RegEnumKey(
                          hKey,
                          dwIndex,
                          Node,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;
        if ( !wcscmp  (Node, (LPCWSTR )NODE_NAME_32BIT) )
            continue;

        if (!DeleteKey (hKey, Node, mode )) {
            bEmptyNode = FALSE; // sorry couldn't delete everything
            dwIndex--; //skip the node
        }

    }
    RegCloseKey (hKey);

    //now delete the dest key.
    if (bDeleteNode) {
        if ( RegDeleteKey ( DestKey, pKeyName) == ERROR_SUCCESS)
        return ERROR_SUCCESS;
    }

    return -1; //unpredictable error
}

BOOL
DeleteAll (
    PWCHAR Parent,
    PWCHAR SubNodeName,
    DWORD Mode,
    DWORD option //one means delete discarding wow6432valuekey
    )
/*++

Routine Description:

    Validate node. if node exist skip if doesn't then create the node and then return.

Arguments:

    Parent - Name of the parent.
    SubNodeName - Name of the node under parent that need to be deleted.

    Mode - 0 means Subnode is under the parent.
           1 means there were wild card and the subnode is under all key under parent.

    option - 0 means check wow6432valuekey for copy
           1 means delete discarding wow6432valuekey


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/

{
    PWCHAR SplitLoc;
    DWORD Ret;
    WCHAR TempIsnNode1[_MAX_PATH];
    WCHAR TempIsnNode2[_MAX_PATH];

    if (SubNodeName == NULL) {

        WCHAR *p ;
        HKEY hKey;

        wcscpy (TempIsnNode1, Parent);

        p = &TempIsnNode1[wcslen(TempIsnNode1)];

        Wow64RegDbgPrint ( ("\nDeleting Key %S......", TempIsnNode1) );

        while ( p != TempIsnNode1 && *p !=L'\\') p--;

        if ( p != TempIsnNode1 ) {
            *p=UNICODE_NULL;

            hKey = OpenNode (TempIsnNode1);
                if ( hKey == NULL ){
                    Wow64RegDbgPrint ( ("\nSorry! Couldn't open the key [%S]",TempIsnNode1));
                    return FALSE;
                }

                DeleteKey (hKey, p+1, 1);
                DeleteValueFromSrc (hKey);
                RegCloseKey (hKey);

        }

        return TRUE; //empty node under parent
    }

    if (SubNodeName[0] == UNICODE_NULL)
        return TRUE;

    if ( Mode == 1) {

        HKEY Key = OpenNode (Parent);
        //
        //  loop through all the subkey under parent
        //

        DWORD dwIndex =0;
        for (;;) {

            DWORD Len = sizeof ( TempIsnNode1 )/sizeof (WCHAR);

            TempIsnNode1 [0]=UNICODE_NULL;
            Ret = RegEnumKey(
                              Key,
                              dwIndex,
                              TempIsnNode1,
                              Len
                              );
            if (Ret != ERROR_SUCCESS)
                break;

            if (Parent[0] != UNICODE_NULL) {

                wcscpy ( TempIsnNode2, Parent);
                wcscat (TempIsnNode2, (LPCWSTR )L"\\");
                wcscat (TempIsnNode2, TempIsnNode1);

            } else   wcscpy (TempIsnNode2, TempIsnNode1);

            DeleteAll  (TempIsnNode2, SubNodeName, 0, option);

            dwIndex++;
        }
        RegCloseKey (Key);
        return TRUE;
    }
    //
    // No wild card here
    //
    if ( ( SplitLoc = wcschr (SubNodeName, L'*') ) == NULL ) {
        if (Parent[0] != UNICODE_NULL) {

            wcscpy ( TempIsnNode2, Parent);
            wcscat (TempIsnNode2, (LPCWSTR )L"\\");
            wcscat (TempIsnNode2, SubNodeName);

        } else
            wcscpy (TempIsnNode2, SubNodeName);

        DeleteAll  (TempIsnNode2, NULL, 0, option);
        return TRUE;
    }

    assert ( *(SplitLoc-1) == L'\\');
    *(SplitLoc-1) = UNICODE_NULL;
    SplitLoc++;
    if (*SplitLoc == L'\\')
        SplitLoc++;

    if (Parent[0] != UNICODE_NULL) {
        wcscat (Parent, (LPCWSTR )L"\\");
        wcscat (Parent, SubNodeName);
    } else
        wcscpy (Parent, SubNodeName);

    DeleteAll  (Parent, SplitLoc, 1, option); //mode 1 means loop within all

    return TRUE;
    //for any wildcard split the string

}

//Cleanup program

BOOL
CleanupTable ()
/*++

Routine Description:

    Cleanup  main table containing ISN node list.

Arguments:

    None.

Return Value:

    TRUE if the table has been removed successfully.
    FALSE otherwise.

--*/
{
    HKEY hKey;
    DWORD Ret;

    //
    //  take action to remove registry entry
    //

    Ret = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        (LPCWSTR ) WOW64_REGISTRY_SETUP_KEY_NAME_REL_PARENT,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey
                        );

    if (Ret == ERROR_SUCCESS ) {

        Ret = RegDeleteKey (hKey, (LPCWSTR)WOW64_REGISTRY_ISN_NODE_NAME );

        if ( Ret == ERROR_SUCCESS) {
            Wow64RegDbgPrint ( ("\nSuccessfully removed ISN Table entry "));
        }

        RegCloseKey (hKey);
    }

    return TRUE;

}



BOOL
CleanpRegistry ()
/*++

Routine Description:

    Cleanup Registry.

Arguments:

    None.

Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

--*/
{



    extern ISN_NODE_TYPE *RedirectorTable;

    DWORD dwIndex;
    HKEY hKey;

    WCHAR TempIsnNode[256];
    WCHAR IsnNode[256];

    //
    // Initialize the table first then delete the table
    //

    InitializeIsnTable ();


    for ( dwIndex=0;dwIndex<wcslen (RedirectorTable[dwIndex].NodeValue);dwIndex++) {


            IsnNode[0] = UNICODE_NULL;
            wcscpy (TempIsnNode , RedirectorTable[dwIndex].NodeValue);
            wcscat (TempIsnNode , (LPCWSTR )L"\\");

            wcscat (TempIsnNode, (LPCWSTR )NODE_NAME_32BIT);
            Wow64RegDbgPrint ( ("\nDeleting Key %S==>%S", IsnNode, TempIsnNode));

            if (wcschr(TempIsnNode, L'*') != NULL ) { //wildcard exist
                DeleteAll ( IsnNode,
                            TempIsnNode,
                            0,
                            1
                            );
            } else {

                hKey = OpenNode (RedirectorTable[dwIndex].NodeValue);
                if ( hKey == NULL ){
                    Wow64RegDbgPrint ( ("\nSorry! Couldn't open the key [%S]",RedirectorTable[dwIndex].NodeValue));
                    continue;
                }

                DeleteKey (hKey, NODE_NAME_32BIT, 1);
                DeleteValueFromSrc (hKey);
                RegCloseKey (hKey);
            }
    }
    CleanupTable ();
    return TRUE;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\wow64reg\typelib.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    typelib.cpp

Abstract:

    This module will apply special rules reflecting typelib and other.

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <shlwapi.h>
#include "wow64reg.h"
#include "reflectr.h"

BOOL 
ExistCLSID (
    PWCHAR Name,
    BOOL Mode
    )
/*++

Routine Description:

    This will do return if the given classID exist on 
    the destination, or even on the mirror side that can 
    happen after reflection

Arguments:

    Name - Name of the GUID including whole path.
    Mode - TURE check on the 64bit side
            FALSE check on the 32bit side.

Return Value:

    TRUE if the guid exist or might be copied after reflection.
    FALSE otherwise.

--*/
{
    WCHAR Buff[256];
    HKEY hClsID;

    DWORD dwBuffLen;
    DWORD dwCount =0;
    DWORD Ret;

        wcscpy (Buff, L"CLSID\\");
        wcscat (Buff, Name );
       
        Ret = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        Buff,
                        0,//OpenOption,
                        KEY_ALL_ACCESS | ( (~Mode) & KEY_WOW64_32KEY),
                        &hClsID
                        );

        if ( Ret == ERROR_SUCCESS) {
            RegCloseKey (hClsID);
            return TRUE;  //ID is there
        }

        //open the other side of the registry
        Ret = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        Buff,
                        0,//OpenOption,
                        KEY_ALL_ACCESS | ( (Mode) & KEY_WOW64_32KEY),
                        &hClsID
                        );
        

        if ( Ret != ERROR_SUCCESS) 
            return FALSE;
        
        dwBuffLen = sizeof (Buff ) / sizeof (Buff[0]);
        if (!HandleToKeyName ( hClsID, Buff, &dwBuffLen )) //get the name
            return FALSE;

        dwCount =0;
        MarkNonMergeableKey ( Buff, hClsID, &dwCount );
        RegCloseKey (hClsID);

        if (dwCount != 0)
            return TRUE;  //yepp you got it
        return FALSE;

        
}

BOOL
ReflectTypeLibVersion (
    HKEY KeyVersion,
    BOOL Mode
    )
/*++

Routine Description:

    This will do special treatment for typelib interfaces.

Arguments:

    KeyVersion - Source Key Node.
    Mode - TRUE - reflection from 64->32
           FALSE - reflection from 32->64
    

Return Value:

    TRUE if the typelib GUID version should be reflected.
    FALSE otherwise.

    Note: the inner loop executed 10,000 times on typical installation.

--*/
{
    WCHAR LocalID[256];
    WCHAR TypeLibPath [_MAX_PATH];
    DWORD dwLocalIdIndex=0;

    HKEY LocalIdKey;
    BOOL bReflectVersion = FALSE;
    DWORD Ret;

    for (;;) {

        DWORD Len = sizeof (LocalID)/sizeof (LocalID[0]);
        BOOL bReflectLocalId = FALSE;

        LocalID[0]=UNICODE_NULL;

        Ret = RegEnumKey(
                          KeyVersion,
                          dwLocalIdIndex,
                          LocalID,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwLocalIdIndex++;
        //
        // Check if this ID has any special mark.
        //

        if (wcslen (LocalID) < (Len - 7) )
            wcscat ( LocalID, L"\\win32");
        else continue;

        Ret = RegOpenKeyEx(KeyVersion, LocalID, 0, KEY_ALL_ACCESS, &LocalIdKey);
        if (Ret != ERROR_SUCCESS) {
            continue;
        }

        {
             
            DWORD Type;
            HRESULT hr;
            ITypeLib *pTypeLib = NULL;

            Len = sizeof (TypeLibPath)/sizeof (TypeLibPath[0]);

            Ret =RegQueryValueEx(
                                LocalIdKey,
                                NULL,
                                0,
                                &Type,
                                (LPBYTE)&TypeLibPath[0],
                                &Len
                                );
            if ( Ret != ERROR_SUCCESS )
                break;
        //
        //  under the "win32" key you'll find a path name. Call oleaut32's LoadTypeLibEx() passing REGKIND_NONE, to get back an ITypeLib* corresponding to that file. 
        //

            
		    hr =  LoadTypeLibEx(TypeLibPath, REGKIND_NONE, &pTypeLib);	
		    
            if (SUCCEEDED(hr)) {

                DWORD Count, i;
                ITypeInfo *pTInfo = NULL;

                //
                //  call ITypeInfo::GetTypeInfoCount, and start calling ITypeLib::GetTypeInfo(), to enumerate all of the ITypeInfos inside the typelib 
                //
                Count = pTypeLib->GetTypeInfoCount ();

                //
                //  For each ITypeInfo, call ITypeInfo::GetTypeAttr() to get back a TYPEATTR struct. 
                //
                for (i=0; i<Count; i++ ) {
                    GUID guidClsid;
                    WCHAR buff[50];
                    //
                    //  In the TYPEATTR you'll find a GUID - that GUID is the one that oleaut32.dll will call OLE's CoCreateInstance on if an app loads the typelib and asks OLEAUT for an interface pointer based on a typeinfo. That GUID will be in HKLM\Software\Classes\CLSID, so we'll know if that interface is reflectable or not.
                    //
                    hr = pTypeLib->GetTypeInfo (i, &pTInfo);
                    if ( !(SUCCEEDED(hr)))
                        break;
                    else {

                        TYPEATTR *TypeAttr;

                        

                        hr = pTInfo->GetTypeAttr ( &TypeAttr);
                        if (SUCCEEDED ( hr )) {
                            guidClsid = TypeAttr->guid;

                            //if guid exis then reflect the whole guid

                             swprintf(buff,L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                                    guidClsid.Data1, 
                                    guidClsid.Data2, 
                                    guidClsid.Data3,
                                   guidClsid.Data4[0], guidClsid.Data4[1],
                                   guidClsid.Data4[2], guidClsid.Data4[3],
                                   guidClsid.Data4[4], guidClsid.Data4[5],
                                   guidClsid.Data4[6], guidClsid.Data4[7]);
                             //printf ("\nCurrent string is ..%S [%d %d %d]", buff,dwIndex, dwVersionIndex,  dwLocalIdIndex);
                             

                             if (ExistCLSID ( buff, !Mode ))
                                 bReflectLocalId = TRUE;
                        }

                        pTInfo->Release();
                        pTInfo = NULL;
                    }

                    if ( bReflectLocalId )
                        break;
                } //for-enum all type info    
			    
		    }//if- loadTypeLib
		   
		    if(pTypeLib)
			    pTypeLib->Release();
            pTypeLib = NULL;
        } //block-

        //
        //Check if you need to reflect this Key;
        //
        if ( bReflectLocalId )
            bReflectVersion = TRUE;

        RegCloseKey (LocalIdKey);
        
    } //for enum ID

    return bReflectVersion;
}

BOOL 
ProcessTypeLib (
    HKEY SrcKey,
    HKEY DestKey,
    BOOL Mode
    )
/*++

Routine Description:

    This will do special treatment for typelib interfaces.

Arguments:

    SrcKey - Source Key Node.
    DestKey - Handle Destination  key
    Mode - TRUE - reflection from 64->32
           FALSE - reflection from 32->64

Return Value:

    TRUE if the key shouldn't be scanned.
    FALSE otherwise.

    Note: the inner loop executed 10,000 times on typical installation.

--*/

{
   

    
    WCHAR GuidName[256];  // This one going to be GUID so not _MAX_PATH
    WCHAR VersionName[256];

    DWORD dwIndex =0;
    DWORD dwVersionIndex=0;

    DWORD Ret;

    HKEY KeyGuidInterface;
    HKEY KeyVersion;

    

    //
    // enumeate all of the GUIDs under HKLM\Software\Classes\Typelib 
    //
    
    dwIndex = 0;
    for (;;) {

        DWORD Len = sizeof (GuidName)/sizeof (GuidName[0]);
        Ret = RegEnumKey(
                          SrcKey,
                          dwIndex,
                          GuidName,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;
        
        Ret = RegOpenKeyEx(SrcKey, GuidName, 0, KEY_ALL_ACCESS, &KeyGuidInterface);
        if (Ret != ERROR_SUCCESS) {
            continue;
        }
        //
        // if not GUID continue
        //
        //
        // Check if there is any special stamp on that key.
        //

        //
        //  enumerate all of the version numbers under each GUID 
        //
        dwVersionIndex = 0;
        for (;;) {

            DWORD Len = sizeof (VersionName)/sizeof (VersionName[0]);
            Ret = RegEnumKey(
                              KeyGuidInterface,
                              dwVersionIndex,
                              VersionName,
                              Len
                              );
            if (Ret != ERROR_SUCCESS)
                break;

            dwVersionIndex++;
        
            Ret = RegOpenKeyEx(KeyGuidInterface, VersionName, 0, KEY_ALL_ACCESS, &KeyVersion);
            if (Ret != ERROR_SUCCESS) {
                continue;
            }
            //
            //  under each version number, enumerate all of the locale IDs. In the case of Proj2000, it's version 4.3, locale id 0. 
            //
            //  Any optimization based on one way reflection?
            //

            if ( ReflectTypeLibVersion ( KeyVersion, Mode ) ){
                HKEY MirrorKeyVersion;
                //
                // Open or create destination
                // Call the API
                //
                
                wcscat (GuidName, L"\\");
                wcscat (GuidName, VersionName);
                
                Ret = RegCreateKeyEx(
                            DestKey,        // handle to an open key
                            GuidName,  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &MirrorKeyVersion,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );
                if ( ERROR_SUCCESS == Ret ) {
                    MergeK1K2 (KeyVersion, MirrorKeyVersion, FALSE );
                    RegCloseKey (MirrorKeyVersion);
                    //printf ("\n #### key has been reflected ... %S",GuidName );
                }

            } else
                //printf ("\n %%%%%%%%%%%%%%%%%%%%%%%% not reflected %S", GuidName);
            RegCloseKey (KeyVersion);


        } //for enum version
        RegCloseKey (KeyGuidInterface);

    }//for - enum GUID

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\wow64reg\wow64reg.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wow64reg.c

Abstract:

    This module implement some APIs for client who need to access registry in a mix way. 
    The client need to link againest wow64reg.lib files. The available APIs has been defined
    in the wow64reg.h files.

    The possible scenario is

    1. 32 bit Apps need to access 64 bit registry key.
    2. 64 bit Apps need to access 32-bit registry key.
    3. The actual redirected path from a given path.

Author:

    ATM Shafiqul Khalid (askhalid) 10-Nov-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>  
#include <nturtl.h>  
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>
#include <stdlib.h>

#include "regremap.h"
#include "wow64reg.h"
#include "reflectr.h"

VOID
GetPatchedName (
    PWCHAR Dest,
    LPCTSTR Source,
    DWORD  Count
    )
/*++

Routine Description:

    This function patches 32bit equivalent name from a given name and location to patch from.
    XX\ ==>> XX\Wow6432Node count==3
    XX  ==>> XX\Wow6432Node count==2
    XX\PP ==>> XX\Wow6432Node count ==3


Arguments:

    Dest - receive the result.
    Source - Name to patch
    Count - where to patch the string.

Return Value:

    None.

--*/

{
    BOOL  PerfectIsnNode = FALSE;

    if (Count) {

        wcsncpy ( Dest, Source, Count );
        if (Dest[Count-1] != L'\\' ) {

            Dest[Count] = L'\\';   // at the end case
            Count++;
            PerfectIsnNode = TRUE;
        }
    }

    wcscpy ( Dest+Count, NODE_NAME_32BIT );

    if ( !PerfectIsnNode ) {

        wcscat ( Dest, L"\\");
        wcscat ( Dest, Source + Count );
    }
    //
    //  Make sure that the patched key are not on the exempt list.
    //
}



LONG 
Wow64RegOpenKeyEx(
  HKEY hKey,         
  LPCTSTR lpSubKey,  
  DWORD ulOptions,   
  REGSAM samDesired, 
  PHKEY phkResult    
)
/*++

Routine Description:

    This is the equivalent of RegOpenExW to access reggistry in the mix mode. This code will be 
    compiled only for 64bit environment. In the 32bit environment WOW64 will take care of everything.
    We are nor worried much about performance hit due to opening key twice or retranslating path.
    Because only few people will access the registry in the mix mode.


Arguments:

    hKey -  handle to open key
    lpSubKey - address of name of subkey to open
    ulOptions - typically 0.
    samDesired - security access mask might have WOW64_RES flag
        KEY_WOW64_32KEY - this will open 32bit equivalent key disregarding 
                                   the process.
        KEY_WOW64_64KEY - this will open 64bit equivalent key disregarding the process.

    phkResult -address of handle to open key

Return Value:

    WIN32 Error code.

--*/
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Parent;

    WCHAR ParentName[WOW64_MAX_PATH];
    WCHAR TempName[WOW64_MAX_PATH];
    DWORD dwBuffLen = WOW64_MAX_PATH;

    WCHAR NullString;
    
    
    PWCHAR p32bitNode;
    PWCHAR pPatchLoc;
    PWCHAR pDivider;

    NTSTATUS st;
    BOOL bHandle64 = TRUE; // assume all the handle passed in is 64bit.

    if( lpSubKey == NULL ) {
        NullString = UNICODE_NULL;
        lpSubKey = &NullString;
    }

    //
    // check if the WOW64 reserve bit set. If none of them is set we can't proceede.
    //

    if (!(samDesired & KEY_WOW64_RES) ) {
        //
        //  return ERROR_INVALID_PARAMETER; try to be optimistic
        //

        return    RegOpenKeyEx (
                                hKey,         
                                lpSubKey, 
                                ulOptions,  
                                samDesired,
                                phkResult   
                               );
    }
    
    if( hKey == NULL ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  makesure that subkey doesn't have the special wow string
    //
    
    if ( ( p32bitNode = wcsistr ((PWCHAR)lpSubKey, NODE_NAME_32BIT)) != NULL ) {
        //
        // if access 64bit hive compress the subkey, if 32bit hive just pass as it is.
        //
        if ( samDesired & KEY_WOW64_64KEY ) {
            wcscpy (ParentName, lpSubKey);
            p32bitNode = ParentName + ( p32bitNode- lpSubKey);
            wcscpy ( p32bitNode, p32bitNode + NODE_NAME_32BIT_LEN );
        }

        return    RegOpenKeyEx (
                                hKey,         
                                ParentName, 
                                ulOptions,  
                                samDesired & (~KEY_WOW64_RES),
                                phkResult   
                               );
    }

    //
    //  Check predefined handle like HKEY_CLASSES_ROOT if so you only need to patch subkey
    //
    //
    //  Client must pass meaningful handle to this function.
    //

    if ( hKey == HKEY_CLASSES_ROOT ) {
        wcscpy ( ParentName, MACHINE_CLASSES_ROOT);

    } else if ( !HandleToKeyName ( hKey, ParentName, &dwBuffLen ) ) { 
        //
        // should we recoved from buffer overflow. We are not going to support all possible combination.
        //
        return ERROR_INVALID_HANDLE;
    }
      
    //
    //  If parent has already been patched just call the RegOpenKeyEx for 32bit open
    //

    if ((p32bitNode = wcsistr (ParentName, NODE_NAME_32BIT)) != NULL ) {
        
        //
        //  [todo] do you need to make sure that the substring mustbe the subkey 
        //  for an ISN node on 64bit registry to satisfy this condition.
        //  if we assume that noy key will have this name then the checking is 
        //  good enough.
        //

        bHandle64 = FALSE;  // it's not handle to 64 bit Key        
    }

    //
    // Get complete qualified path to do sanity check.
    //

    pDivider = ParentName + wcslen(ParentName)+1; //point to the divider location
    *(pDivider-1)= L'\\';
    wcscpy (pDivider, (PWCHAR)lpSubKey);
    if (IsExemptRedirectedKey(ParentName, TempName)) {
        //
        // If the path is on the exempt list we access 64bit hive
        //
        samDesired = (samDesired & (~KEY_WOW64_RES)) | KEY_WOW64_64KEY; //make sure access 64bit hive
    }

    if ( ( bHandle64 && (samDesired  & KEY_WOW64_64KEY ) )    // if totally 64
        || ( !bHandle64 && (samDesired  & KEY_WOW64_32KEY ) ) // if totally 32 
        || !IsIsnNode (ParentName, &pPatchLoc) ) {            // if not a ISN node don't care

        return    RegOpenKeyEx (
                                hKey,        
                                lpSubKey, 
                                ulOptions,  
                                samDesired & (~KEY_WOW64_RES),
                                phkResult   
                               );
    }

    //
    //  Now it might be mix mode access
    //
    if ( pPatchLoc >= pDivider ) {

        //
        //  patching only the subkey will be good enough
        //

        if ( samDesired  & KEY_WOW64_64KEY ) {  // want to access 64bit just disregard

            wcscpy ( ParentName, lpSubKey );
        } else  {

             
            GetPatchedName (ParentName,lpSubKey, (DWORD)(pPatchLoc-pDivider) );
        }

        return   RegOpenKeyEx (
                                hKey,        
                                ParentName, 
                                ulOptions,  
                                samDesired & (~KEY_WOW64_RES),
                                phkResult   
                               );
    } else {

        if ( samDesired  & KEY_WOW64_64KEY ) {  // want to access 64bit just disregard

            if (p32bitNode != NULL)   //compress
                wcscpy ( p32bitNode, p32bitNode + NODE_NAME_32BIT_LEN );
            RtlInitUnicodeString (&Parent, ParentName );
        } else  {

            GetPatchedName (TempName,ParentName, (DWORD)(pPatchLoc-ParentName));
            RtlInitUnicodeString (&Parent, TempName );
        }

        
        InitializeObjectAttributes (&Obja, 
                                    &Parent, 
                                    OBJ_CASE_INSENSITIVE, 
                                    NULL, 
                                    NULL
                                    );

        samDesired &= (~KEY_WOW64_RES);
        st = NtOpenKey (phkResult, samDesired, &Obja);

        if ( !NT_SUCCESS(st))
                    return RtlNtStatusToDosError (st);
        return 0;
    }
    
}

LONG 
Wow64RegCreateKeyEx(
  HKEY hKey,                // handle to an open key
  LPCWSTR lpSubKey,         // address of subkey name
  DWORD Reserved,           // reserved
  LPWSTR lpClass,           // address of class string
  DWORD dwOptions,          // special options flag
  REGSAM samDesired,        // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                            // address of key security structure
  PHKEY phkResult,          // address of buffer for opened handle
  LPDWORD lpdwDisposition   // address of disposition value buffer
)
 
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    hKey - Handle to a currently open key or one of the following predefined reserved 
    handle values: 
                HKEY_CLASSES_ROOT
                HKEY_CURRENT_CONFIG
                HKEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

    The key opened or created by the RegCreateKeyEx function is a subkey of the key 
    identified by the hKey parameter. 

    lpSubKey  - Pointer to a null-terminated string specifying the name of a subkey 
    that this function opens or creates. The subkey specified must be a subkey of the 
    key identified by the hKey parameter. This subkey must not begin with the backslash 
    character ('\'). This parameter cannot be NULL. 

    Reserved -Reserved; must be zero. 
    
    lpClass - Pointer to a null-terminated string that specifies the class (object type) 
    of this key. This parameter is ignored if the key already exists. No classes are 
    currently defined; applications should pass a null string. 

    dwOptions  - Specifies special options for the key. This parameter can be one of the 
    following values. 
        REG_OPTION_NON_VOLATILE This key is not volatile. This is the default. The 
            information is stored in a file and is preserved when the system is restarted. 
        REG_OPTION_VOLATILE     
        REG_OPTION_BACKUP_RESTORE  Windows NT/2000: If this flag is set, the function 
            ignores  the samDesired parameter and attempts to open the key with the access 
            required to backup or restore the key. If the calling thread has the 
            SE_BACKUP_NAME privilege enabled, the key is opened with 
            ACCESS_SYSTEM_SECURITY and KEY_READ access. If the calling thread 
            has the SE_RESTORE_NAME privilege enabled, the key is opened with 
            ACCESS_SYSTEM_SECURITY and KEY_WRITE access. 
            If both privileges are enabled, the key has the combined accesses 
            for both privileges.  

    samDesired  - Specifies an access mask that specifies the desired security access 
    for the new key. This parameter can be a combination of the following values:
        KEY_ALL_ACCESS      Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, 
                            KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, 
                            and KEY_SET_VALUE access. 
        KEY_CREATE_LINK     Permission to create a symbolic link. 
        KEY_CREATE_SUB_KEY  Permission to create subkeys. 
        KEY_ENUMERATE_SUB_KEYS Permission to enumerate subkeys. 
        KEY_EXECUTE         Permission for read access. 
        KEY_NOTIFY          Permission for change notification. 
        KEY_QUERY_VALUE     Permission to query subkey data. 
        KEY_READ            Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access. 
        KEY_SET_VALUE       Permission to set subkey data. 
        KEY_WRITE           Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access. 
                            
        Security access mask might also have WOW64_RES flag
        KEY_WOW64_32KEY     this will open 32bit equivalent key disregarding 
                                   the process.
        KEY_WOW64_64KEY     this will open 64bit equivalent key disregarding the process.


    lpSecurityAttributes  -  Pointer to a SECURITY_ATTRIBUTES structure that determines 
    whether the returned handle can be inherited by child processes. If 
    lpSecurityAttributes is NULL, the handle cannot be inherited. 


    phkResult  - Pointer to a variable that receives a handle to the opened or 
    created key. When you no longer need the returned handle, call the RegCloseKey 
    function to close it. 

    lpdwDisposition - Pointer to a variable that receives one of the following 
    disposition values: Value Meaning  REG_CREATED_NEW_KEY The key did not exist 
    and was created. REG_OPENED_EXISTING_KEY The key existed and was simply 
    opened without being changed. If lpdwDisposition is NULL, no disposition 
    information is returned. 

Return Values:
    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is a nonzero error code defined in WINERROR.H. 



--*/
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Parent;

    WCHAR ParentName[WOW64_MAX_PATH];
    WCHAR TempName[WOW64_MAX_PATH];
    DWORD dwBuffLen = WOW64_MAX_PATH;
    
    
    PWCHAR p32bitNode;
    PWCHAR pPatchLoc;
    PWCHAR pDivider;

    NTSTATUS st;
    BOOL bHandle64 = TRUE; // assume all the handle passed in is 64bit.

    //
    // check if the WOW64 reserve bit set. If none of them is set we can't proceede.
    //

    if (!(samDesired & KEY_WOW64_RES) ) {
        //
        //  return ERROR_INVALID_PARAMETER; try to be optimistic
        //

        return    RegCreateKeyEx (
                                  hKey,                // handle to an open key
                                  lpSubKey,            // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired,          // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );

    }
    
    if( hKey == NULL ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  makesure that subkey doesn't have the special wow string
    //
    if ( ( p32bitNode = wcsistr ((PWCHAR)lpSubKey, NODE_NAME_32BIT)) != NULL ) {
        //
        // if access 64bit hive compress the subkey, if 32bit hive just pass as it is.
        //
        if ( samDesired & KEY_WOW64_64KEY ) {
            wcscpy (ParentName, lpSubKey);
            p32bitNode = ParentName + ( p32bitNode- lpSubKey);
            wcscpy ( p32bitNode, p32bitNode + NODE_NAME_32BIT_LEN );
        }

        return    RegCreateKeyEx (
                                  hKey,                // handle to an open key
                                  lpSubKey,            // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired & (~KEY_WOW64_RES),          // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );
    }

    //
    //  Check predefined handle like HKEY_CLASSES_ROOT if so you only need to patch subkey
    //
    //
    //  Client must pass meaningful handle to this function.
    //

    if ( hKey == HKEY_CLASSES_ROOT ) {
        wcscpy ( ParentName, MACHINE_CLASSES_ROOT);

    } else if ( !HandleToKeyName ( hKey, ParentName, &dwBuffLen ) ) { 
        //
        // should we recoved from buffer overflow. We are not going to support all possible combination.
        //
        return ERROR_INVALID_HANDLE;
    }
      
    //
    //  If parent has already been patched just call the RegOpenKeyEx for 32bit open
    //

    if ((p32bitNode = wcsistr (ParentName, NODE_NAME_32BIT)) != NULL ) {
        
        //
        //  [todo] do you need to make sure that the substring mustbe the subkey 
        //  for an ISN node on 64bit registry to satisfy this condition.
        //  if we assume that noy key will have this name then the checking is 
        //  good enough.
        //

        bHandle64 = FALSE;  // it's not handle to 64 bit Key        
    }

    //
    // Get complete qualified path to do sanity check.
    //

    pDivider = ParentName + wcslen(ParentName)+1; //point to the divider location
    *(pDivider-1)= L'\\';
    wcscpy (pDivider, (PWCHAR)lpSubKey);
    if (IsExemptRedirectedKey(ParentName, TempName)) {
        //
        // If the path is on the exempt list we access 64bit hive
        //
        samDesired = (samDesired & (~KEY_WOW64_RES)) | KEY_WOW64_64KEY; //make sure access 64bit hive
    }

    if ( ( bHandle64 && (samDesired  & KEY_WOW64_64KEY ) )    // if totally 64
        || ( !bHandle64 && (samDesired  & KEY_WOW64_32KEY ) ) // if totally 32 
        || !IsIsnNode (ParentName, &pPatchLoc) ) {            // if not a ISN node don't care

        return    RegCreateKeyExW (
                                  hKey,                // handle to an open key
                                  lpSubKey,            // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired & (~KEY_WOW64_RES), // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );
    }

    //
    //  Now it might be mix mode access
    //
    if ( pPatchLoc >= pDivider ) {

        //
        //  patching only the subkey will be good enough
        //

        if ( samDesired  & KEY_WOW64_64KEY ) {  // want to access 64bit just disregard

            wcscpy ( ParentName, lpSubKey );
        } else  {

             
            GetPatchedName (ParentName,lpSubKey, (DWORD)(pPatchLoc-pDivider) );
        }

        return RegCreateKeyExW (
                                  hKey,                // handle to an open key
                                  ParentName,            // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired & (~KEY_WOW64_RES), // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );

    } else {

        HKEY hNewParent = NULL; 
        LONG Ret;
        PWCHAR pSubKey;

        // 
        // get new handle on the parent and then create the child
        //


        if ( samDesired  & KEY_WOW64_64KEY ) {  // want to access 64bit just disregard

            if (p32bitNode != NULL)  {//compress 

                *(p32bitNode-1) = UNICODE_NULL;
                wcscpy ( p32bitNode, p32bitNode + NODE_NAME_32BIT_LEN + 
                    (p32bitNode[NODE_NAME_32BIT_LEN]==L'\\'? 1:0));
            }

            pSubKey = p32bitNode;
            RtlInitUnicodeString (&Parent, ParentName );

        } else  {

            
            pSubKey = pPatchLoc;     

            GetPatchedName (TempName,ParentName, (DWORD)(pPatchLoc-ParentName));
            TempName[pPatchLoc-ParentName+NODE_NAME_32BIT_LEN]=UNICODE_NULL; //repatch

            RtlInitUnicodeString (&Parent, TempName );
        }

        
        InitializeObjectAttributes (&Obja, 
                                    &Parent, 
                                    OBJ_CASE_INSENSITIVE, 
                                    NULL, 
                                    NULL
                                    );

        samDesired &= (~KEY_WOW64_RES);

        //
        //  if key doesn't exist try to create
        //  Try to avoid using NtOpenKey rather use RegOpenKey
        //

        st = NtOpenKey (&hNewParent, 
                        MAXIMUM_ALLOWED, 
                        &Obja); 

        if ( !NT_SUCCESS(st))
                    return RtlNtStatusToDosError (st); 

        return   RegCreateKeyExW (
                                  hNewParent,          // handle to an open key
                                  pSubKey,             // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired & (~KEY_WOW64_RES), // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );
        NtClose (hNewParent);


        return 0;
        
    }
    
}

BOOL
Wow64RegNotifyLoadHive (
    PWCHAR Name
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive has been loaded in the 
    system. Wow64 should respond if it care to handle this.

Arguments:

    Name - Absolute path of the registry that has been loaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    DWORD Ret;
    HANDLE hEvent;

    if (!CreateSharedMemory ( OPEN_EXISTING_SHARED_RESOURCES )) {

        Wow64RegDbgPrint ( ("\nSorry! Couldn't open shared memory Ret:%d", GetLastError ()) );
        return FALSE;
    }


    if (!Wow64CreateEvent ( OPEN_EXISTING_SHARED_RESOURCES, &hEvent) ) {

      CloseSharedMemory ();
      Wow64RegDbgPrint ( ("\nSorry! couldn't open event to ping reflector..") );
      return FALSE;

    }

    Ret = EnQueueObject ( Name, HIVE_LOADING);
    
    CloseSharedMemory ();
    Wow64CloseEvent ();

    return Ret;

}

BOOL
Wow64RegNotifyUnloadHive (
    PWCHAR Name
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive going to be unloaded 
    in the system. Wow64 should respond if it care to handle this. Normally Wow64 will 
    close any open handle to that hive.

Arguments:

    Name - Absolute path of the registry that going to unloaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    DWORD Ret;
    HANDLE hEvent;

    if (!CreateSharedMemory ( OPEN_EXISTING_SHARED_RESOURCES )) {

        Wow64RegDbgPrint ( ("\nSorry! Couldn't open shared memory Ret:%d", GetLastError ()));
        return FALSE;
    }


    if (!Wow64CreateEvent ( OPEN_EXISTING_SHARED_RESOURCES, &hEvent) ) {

      CloseSharedMemory ();
      Wow64RegDbgPrint ( ("\nSorry! couldn't open event to ping reflector..") );
      return FALSE;

    }

    Ret = EnQueueObject ( Name, HIVE_UNLOADING);
    
    CloseSharedMemory ();
    Wow64CloseEvent ();

    return Ret;

}

BOOL
Wow64RegNotifyLoadHiveByHandle (
    HKEY hKey
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive has been loaded in the 
    system. Wow64 should respond if it care to handle this.

Arguments:

    hKey - handle to the key that has been loaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    WCHAR Name [256];
    DWORD Len = 256;

    if (!HandleToKeyName ( hKey, Name, &Len ))
        return FALSE;
    
    return  Wow64RegNotifyLoadHive( Name );

}

BOOL
Wow64RegNotifyUnloadHiveByHandle (
    HKEY hKey
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive going to be unloaded 
    in the system. Wow64 should respond if it care to handle this. Normally Wow64 will 
    close any open handle to that hive.

Arguments:

    hKey - handle to the key that going to unloaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    WCHAR Name [256];
    DWORD Len = 256;

    if (!HandleToKeyName ( hKey, Name, &Len ))
        return FALSE;
    
    return  Wow64RegNotifyUnloadHive( Name );

}

BOOL
Wow64RegNotifyLoadHiveUserSid (
    PWCHAR lpwUserSid
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive has been loaded in the 
    system. Wow64 should respond if it care to handle this.

Arguments:

    hKey - handle to the key that has been loaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    WCHAR Name [256];
    HKEY hUserRoot;
    
    wcscpy (Name, L"\\REGISTRY\\USER\\");
    wcscat (Name, lpwUserSid );

    if (wcsistr (Name, L"_Classes")) {
        wcscat (Name, L"\\Wow6432Node");

        hUserRoot = OpenNode (Name);

        //
        // DbgPrint ("\nWow64:Creating Hive %S",Name);
        //
        // Create the 32bit user hive if applicable
        //
        if ( hUserRoot == NULL ) {        
            CreateNode (Name);
        } else
            NtClose (hUserRoot);
    }

    return TRUE;

    
    //return  Wow64RegNotifyLoadHive( Name );

}

BOOL
Wow64RegNotifyUnloadHiveUserSid (
    PWCHAR lpwUserSid
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive going to be unloaded 
    in the system. Wow64 should respond if it care to handle this. Normally Wow64 will 
    close any open handle to that hive.

Arguments:

    hKey - handle to the key that going to unloaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    WCHAR Name [256];

    wcscpy (Name, L"\\REGISTRY\\USER\\");
    wcscat (Name, lpwUserSid );
    

    //
    //return  Wow64RegNotifyUnloadHive( Name );
    //
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\wow64reg\reflectr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    reflectr.h

Abstract:

    This file define function used only in the setup/reflector thread

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#ifndef __REFLECTR_H__
#define __REFLECTR_H__

//
// must not define this for the checin code its only for the debugging code
//
//#define ENABLE_REGISTRY_LOG
//#define WOW64_LOG_REGISTRY  // will log information 

#define WAIT_INTERVAL INFINITE  //Infinite

#define VALUE_KEY_UPDATE_TIME_DIFF 10  // minimum difference in sec to Keyupdate and reflector thread scan

#define WOW64_REGISTRY_SETUP_REFLECTOR_KEY L"SOFTWARE\\Microsoft\\WOW64\\Reflector Nodes"

//
//  following flag used in the merge value key & Keys
//
#define PATCH_PATHNAME              0x00000001 // patch pathname from value
#define DELETE_VALUEKEY             0x00000002 // delete the value after copy like runonce key
#define NOT_MARK_SOURCE             0x00000004 // don't mark source 
#define NOT_MARK_DESTINATION        0x00000008 // don't mark destination
#define DESTINATION_NEWLY_CREATED   0x00000010 // destination is newly created don't check timestamp

#define DELETE_FLAG                 0x10000000 // destination is newly created don't check timestamp


#define CONSOLE_OUTPUT printf

#ifndef THUNK
#ifdef ENABLE_REGISTRY_LOG
#define Wow64RegDbgPrint(x) RegLogPrint x
#else
#define Wow64RegDbgPrint(x)   //NULL Statement
#endif
#endif

//
// over write for thunk
//
#if defined THUNK
#undef CONSOLE_OUTPUT
#define CONSOLE_OUTPUT DbgPrint
#undef Wow64RegDbgPrint
#define Wow64RegDbgPrint(x) CONSOLE_OUTPUT x
#endif



typedef struct __REFLECTOR_EVENT {
    HANDLE  hRegistryEvent;
    HKEY  hKey;
    DWORD   dwIndex;  //index to the ISN node table
    BOOL  bDirty;
} REFLECTOR_EVENT;


typedef enum {
    Dead=0,             // no thread 
    Stopped,            // events has been initialised
    Running,            // running the thread
    PrepareToStop,      // going to stop soon
    Abnormal            // abnormal state need to clean up in some way
} REFLECTR_STATUS;

#define HIVE_LOADING L'L'
#define HIVE_UNLOADING L'U'
#define LIST_NAME_LEN 257    //256 +1 for the last entry

#define OPEN_EXISTING_SHARED_RESOURCES 0x12
#define CREATE_SHARED_MEMORY 0x13

typedef WCHAR LISTNAME[LIST_NAME_LEN];

#pragma warning( disable : 4200 )    //todisable zero length array which will be allocated later
typedef struct _LIST_OBJECT {
    DWORD Count;
    DWORD MaxCount;
    LISTNAME Name[]; //the 256th position will hold the value like loading/unloading
} LIST_OBJECT;
#pragma warning( default : 4200 )

#ifdef __cplusplus
extern "C" {
#endif


BOOL 
ExistCLSID (
    PWCHAR Name,
    BOOL Mode
    );

BOOL
MarkNonMergeableKey (
    LPCWSTR KeyName,
    HKEY hKey,
    DWORD *pMergeableSubkey
    );

BOOL
SyncNode (
    PWCHAR NodeName
    );

BOOL 
ProcessTypeLib (
    HKEY SrcKey,
    HKEY DestKey,
    BOOL Mode
    );

void
MergeK1K2 (
    HKEY SrcKey,
    HKEY DestKey,
    DWORD FlagDelete 
    );

BOOL
CreateIsnNode();

BOOL
CreateIsnNodeSingle(
    DWORD dwIndex
    );

BOOL 
GetWow6432ValueKey (
    HKEY hKey,
    WOW6432_VALUEKEY *pValue
    );

DWORD
DeleteKey (
    HKEY DestKey,
    WCHAR *pKeyName,
    DWORD mode
    );

BOOL
CleanpRegistry ( );

BOOL
InitializeIsnTable ();

BOOL
UnRegisterReflector();

BOOL
RegisterReflector();

ULONG
ReflectorFn (
    PVOID *pTemp
    );

BOOL
InitReflector ();

BOOL
InitializeIsnTableReflector ();

BOOL 
PopulateReflectorTable ();

BOOL 
Is64bitNode ( 
    WCHAR *pName
    );


BOOL 
HandleRunonce(
    PWCHAR pKeyName
    );

BOOL
PatchPathName (
    PWCHAR pName
    );

BOOL
GetMirrorName (
    PWCHAR Name, 
    PWCHAR TempName
    );

VOID SetInitialCopy ();

////////////////shared memory service/////////////////////////////

BOOL 
CreateSharedMemory (
    DWORD dwOption
    );

VOID
CloseSharedMemory ();

BOOL
Wow64CreateLock (
    DWORD dwOption
    );

VOID
Wow64CloseLock ();

BOOL
Wow64CreateEvent (
    DWORD dwOption,
    HANDLE *hEnent
    );

VOID
Wow64CloseEvent ();

BOOL
SignalWow64Svc ();

BOOL
EnQueueObject (
    PWCHAR pObjName,
    WCHAR  Type
    );
BOOL
DeQueueObject (
    PWCHAR pObjName,
    PWCHAR  Type
    );

REFLECTR_STATUS
GetReflectorThreadStatus ();

BOOL
GetMirrorName (
    PWCHAR Name,
    PWCHAR MirrorName
    );

BOOL
PopulateReflectorTable ();

BOOL
GetDefaultValue (
    HKEY  SrcKey,
    WCHAR *pBuff,
    DWORD *Len
    );

BOOL
WriteRegLog (
    PWCHAR Msg
    );

VOID 
CloseRegLog ();

BOOL
InitRegLog ();

BOOL
RegLogPrint ( 
    CHAR *p, 
    ... 
    );

#ifdef __cplusplus
    }
#endif
#endif //__REFLECTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\wow64reg\reflectr.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    reflectr.c

Abstract:

    This module will register reflector thread and do necessary action while awake up.

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <string.h>
#include "wow64reg.h"
#include <assert.h>
#include <shlwapi.h>
#include "reflectr.h"


REFLECTOR_EVENT eReflector[ISN_NODE_MAX_NUM];

REFLECTR_STATUS ReflectrStatus = Stopped;
HANDLE hRegistryEvent[ISN_NODE_MAX_NUM];


HANDLE hReflector;
DWORD  TotalEventCount = 0;

VOID
DbgPrint(
    PCHAR FormatString,
    ...
    );

REFLECTR_STATUS
GetReflectorThreadStatus ()
/*++

Routine Description:

    Return current thread status;

Arguments:

    None.

Return Value:

    REFLECTR_STATUS

--*/

{
    return ReflectrStatus;

}

BOOL
NotifyKeyChange (
    HKEY hKey,
    HANDLE hEvent
    )
/*
Routine Description:

    Register an event to be fired when something get changed on a key.

Arguments:

    hKey - handle to a key that need to be watched.
    hEvent event that need to be triggered.

Return Value:

    TRUE if the event registration succeed,
    FALSE otherwise.

--*/
{
    DWORD Ret;
    ResetEvent (hEvent);
    Ret = RegNotifyChangeKeyValue(
                                hKey,      // need to change to the ISN node
                                TRUE,                   // Watch the whole sub-tree
                                REG_NOTIFY_CHANGE_NAME |
                                        REG_NOTIFY_CHANGE_LAST_SET, // Don't watch for anything
                                hEvent,         // Event Handle
                                TRUE                    // Async
                                );
    if ( ERROR_SUCCESS != Ret)
        DbgPrint ("\nWow64.exe:Error!! Couldn't register events:%x on handle %x",hEvent, hKey);  

    return Ret == ERROR_SUCCESS;
                               
}

VOID
RefreshWaitEventTable ()
/*++

Routine Description:

    Just copy all event object and we can wail for new event to trigger.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD k;
    for (k=0;k<TotalEventCount;k++)
        hRegistryEvent[k] = eReflector[k].hRegistryEvent;
}

BOOL
CreateInsertEvent (
    PWCHAR Name,
    DWORD dwIndex
    )
/*++

Routine Description:

    Create an event for the key.

Arguments:

    Name - Name of the key an event will be created to watch any changes.
    dwIndex - is the index to the reflector table. when event is fired up we need to tack the key.

Return Value:

    TRUE on success,
    FALSE Otherwise

--*/
{

    if ( Name == UNICODE_NULL)
        return FALSE;

    if (wcsstr( Name, (LPCWSTR)L"\\REGISTRY\\USER\\*\\")) {

                if (RegOpenKey ( HKEY_CURRENT_USER,
                      Name+sizeof ( L"\\REGISTRY\\USER\\*")/sizeof(WCHAR),
                      &eReflector[TotalEventCount].hKey) != ERROR_SUCCESS) {

                      Wow64RegDbgPrint (("\nSorry! couldn't open Key [%S]",
                          Name+sizeof ( L"\\REGISTRY\\USER\\*")/sizeof(WCHAR) ) );

                      return FALSE;
                }
    } else {

                eReflector[TotalEventCount].hKey = OpenNode (Name);

                if ( eReflector[TotalEventCount].hKey == NULL ) {

                    Wow64RegDbgPrint (("\nSorry! couldn't open Key [%S] Len%d %d %d", Name, wcslen (Name), Name[0], UNICODE_NULL ));
                    return FALSE;
                }
    }



    //
    // DO make sure that 32bit version exist on the hive...
    //

 
    {
        WCHAR TempName[256];

        GetMirrorName (Name, TempName);
        if ( wcscmp(Name,TempName ) )
             CreateNode ( TempName );
        
        // get all kind of name
    }

        eReflector[TotalEventCount].hRegistryEvent = CreateEvent(
                    NULL,   // Security Attributes
                    TRUE,  // Manual Reset
                    FALSE,  // Initial State
                    NULL    // Unnamed
                    ) ;

        if ( !eReflector[TotalEventCount].hRegistryEvent) {

            Wow64RegDbgPrint (("\nUnable to create event"));
            RegCloseKey (eReflector[TotalEventCount].hKey);
            return FALSE;
        }

        eReflector[TotalEventCount].dwIndex = dwIndex;
        ResetEvent (eReflector[TotalEventCount].hRegistryEvent);

        if (!NotifyKeyChange (eReflector[TotalEventCount].hKey,
            eReflector[TotalEventCount].hRegistryEvent
            )) {
                    Wow64RegDbgPrint ( ("\nSevere Error!!!! Couldn't hook to registry notify index:%d", TotalEventCount) );
                    RegCloseKey (eReflector[TotalEventCount].hKey);
                    CloseHandle (eReflector[TotalEventCount].hRegistryEvent);
                    return FALSE;  //set thread state
          }

        TotalEventCount++;

        return TRUE;
}


DWORD
TotalRelflectorKey()
/*++

Routine Description:

    Return the total number of the key in the reflector Table.

Arguments:

    None.

Return Value:

    Number of entry in the reflector table.

--*/
{
    extern ISN_NODE_TYPE *ReflectorTable;
    DWORD i;
    for (i=0;;i++)
        if ( ReflectorTable[i].NodeValue[0] == UNICODE_NULL )
            return i;
}

VOID
PrintTable ()
/*++

Routine Description:

    Dump the current content of the table, just for debugging purpose.

Arguments:

    None.

Return Value:

    None.

--*/
{
    extern ISN_NODE_TYPE *ReflectorTable;
    DWORD Size = TotalRelflectorKey();
    DWORD i;

    for ( i=0;i<Size;i++)
        Wow64RegDbgPrint ( ("\nTableElem [%d], %S", i, ReflectorTable[i].NodeValue));

}

BOOL
RemoveKeyToWatch (
    PWCHAR Name
    )
/*++

Routine Description:

    Remove an entry in from the table to reflector thread need to watch.

Arguments:

    Name - Name of the key to remove from the table.

Return Value:

    TRUE on success,
    FALSE Otherwise

--*/
{
    DWORD i;
    DWORD k;
    extern ISN_NODE_TYPE *ReflectorTable;
    DWORD Size;


    for (i=1; i<TotalEventCount;i++)
        if (!_wcsicmp (Name, ReflectorTable[eReflector[i].dwIndex].NodeValue)) {//found match

            // move reflector table entry
            // fixup pointer in the ereflectortable

            Size = TotalRelflectorKey ();
            wcscpy (  ReflectorTable[eReflector[i].dwIndex].NodeValue,
                      ReflectorTable[Size-1].NodeValue
                    );
            Size--;
            ReflectorTable[Size].NodeValue[0]=UNICODE_NULL; //invalidate the place
            for (k=1; k<TotalEventCount;k++)
                if ( eReflector[k].dwIndex == Size ) {
                    eReflector[k].dwIndex = eReflector[i].dwIndex; //new location
                        break;
                }


            // fixup the table with the new entry

            {
                REFLECTOR_EVENT Temp = eReflector[i];
                eReflector[i]        = eReflector[TotalEventCount-1];
                eReflector[TotalEventCount-1] = Temp;;
            }
            TotalEventCount--;
            CloseHandle (eReflector[TotalEventCount].hRegistryEvent );
            RegCloseKey ( eReflector[TotalEventCount].hKey);
            eReflector[TotalEventCount].dwIndex = -1;

            //Now remove from the original table

            PrintTable();
            return TRUE;
        }

    return FALSE;
}

BOOL
AddKeyToWatch (
    PWCHAR Name
    )
/*++

Routine Description:

    Add an entry in the table to reflector thread need to watch.

Arguments:
 
    Name - Name of the key to watch.

Return Value:

    TRUE on success,
    FALSE Otherwise

--*/
{

    //
    // Check for duplicate entry
    //


    DWORD i;
    DWORD k;
    extern ISN_NODE_TYPE *ReflectorTable;
    DWORD Size;


    for (i=1; i<TotalEventCount;i++)
        if (!_wcsicmp (Name, ReflectorTable[eReflector[i].dwIndex].NodeValue)) {//found match
            return FALSE; //already there
        }



    Size = TotalRelflectorKey ();
    wcscpy (  ReflectorTable[Size].NodeValue, Name );
    ReflectorTable[Size+1].NodeValue[0]=UNICODE_NULL; //invalidate the place

    if (!CreateInsertEvent ( Name, Size ))
        ReflectorTable[Size].NodeValue[0]=UNICODE_NULL; //no point of keeping the bad entry

    return TRUE;
}

BOOL
ValidateOpenHandleEventTable (
    DWORD dwIndex
    )
/*++

Routine Description:

    Validate a given node and if something wrong kick out the entry from the
    event table.

Arguments:

    dwIndex - entry that need to be checked

Return Value:

    TRUE if function succeed.
    FALSE otherwise.

--*/
{
    extern ISN_NODE_TYPE *ReflectorTable;

    //
    //  current implementation will just remove the entry from the table
    //

    return RemoveKeyToWatch (ReflectorTable[eReflector[dwIndex].dwIndex].NodeValue);
}

VOID
PeocessHiveLoadUnload ()
/*++

Routine Description:

    Take necessary action when a hive has been unloaded.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DWORD i;

    WCHAR Name[257];
    WCHAR Type;

    for (;;) {
        if (!DeQueueObject ( Name, &Type ))
            break;

        if ( Type == HIVE_UNLOADING ) { //Closing hive

            RemoveKeyToWatch (Name);
        } else if ( Type == HIVE_LOADING) { //opening hive

            AddKeyToWatch (Name);
        }

        Wow64RegDbgPrint ( ("\nFired up from shared memory write.....Value..%S  [%C]", Name, Type) );
    }
}
 
ULONG
ReflectorFn (
    PVOID *pTemp
    )
/*++

Routine Description:

    Main reflector thread.

Arguments:

    pTemp -

Return Value:

    return exit code.

--*/
{
    DWORD Ret, k;
    DWORD LocalWaitTime;

    pTemp=NULL;

    for (k=0;k<TotalEventCount;k++)
          hRegistryEvent[k] = eReflector[k].hRegistryEvent;

    for (k=0;k<TotalEventCount;k++) {  //reset everything and wait for a fresh event
        if (eReflector[k].hRegistryEvent)
          NotifyKeyChange (  eReflector[k].hKey, eReflector[k].hRegistryEvent);
      }

    for (;;) {

        if ( ReflectrStatus == PrepareToStop ) {
            Wow64RegDbgPrint ( ("\nGoing to stop"));
            ReflectrStatus = Stopped;
            break;  // the thread should stop
        }

        Wow64RegDbgPrint ( ("\nReflector thread has been started and will wait for event\n.......") );

        Sleep (1000*10); //wait 10 sec before reregistering events

        LocalWaitTime = WAIT_INTERVAL; //wait infinite
        for (;;) {

            //DbgPrint ("\nwow64.exe Waiting to liten...");
            Ret = WaitForMultipleObjects(TotalEventCount, hRegistryEvent, FALSE, LocalWaitTime );

            if (ReflectrStatus == PrepareToStop) {

                ReflectrStatus = Stopped;
                Wow64RegDbgPrint ( ("\nGoing to stop"));
                break;  // the thread should stop
            }
         
            if ( Ret == WAIT_TIMEOUT )
                break; // break the loop and process all dirty hives.

            if ( ( Ret-WAIT_OBJECT_0) > TotalEventCount ) { //right index
                Wow64RegDbgPrint ( ("\nWaitMultiple object failed!!.. %d LastError:%d", Ret, GetLastError ()) );
                Sleep (1000*10); //wait 10 sec before reregistering events
                continue;
                //break;
            }

            //
            // Checkspecial case like shared memory write
            //
            if ( (Ret-WAIT_OBJECT_0) == 0){

                PeocessHiveLoadUnload ();
                ResetEvent (eReflector[0].hRegistryEvent);  // reset the  event that triggered this
                RefreshWaitEventTable ();

                continue;
            }

            //
            // set timeout to 10 second, Mark the hive dirty, reset event, and back to sleep
            //
            LocalWaitTime = 5*1000;  // poll the event every 5 second.
            Sleep (1000* 3);// Sleep 3 second to reregister the event.
            eReflector[Ret-WAIT_OBJECT_0].bDirty = TRUE;
            ResetEvent (eReflector[Ret-WAIT_OBJECT_0].hRegistryEvent);

            //
            // watch for the event again
            //

            if (!NotifyKeyChange (  eReflector[Ret-WAIT_OBJECT_0].hKey, 
                                    eReflector[Ret-WAIT_OBJECT_0].hRegistryEvent)){
                    //
                    // if the node get deleted you need to unload the events and everything
                    //
                    ValidateOpenHandleEventTable (Ret-WAIT_OBJECT_0);
                    RefreshWaitEventTable ();
                    //ReflectrStatus = Abnormal;
                    //break; //set thread state
            }
            
        }

        if (ReflectrStatus == PrepareToStop) 
            break;


        //
        // Now process all dirty hive.
        //

        for (k=0;k<TotalEventCount;k++)
            if ( eReflector[k].bDirty ) {

                CreateIsnNodeSingle( eReflector[k].dwIndex);  // reflect changes
                eReflector[k].bDirty = FALSE;
                //ResetEvent (eReflector[k].hRegistryEvent);
            }

    } //for loop

    Wow64RegDbgPrint ( ("\nReflector thread terminated...."));
    return TRUE;
}


BOOL
RegisterReflector()
/*++

Routine Description:

    Register the reflector thread after doing necessary initialization.

Arguments:

    None.

Return Value:

    TRUE if it can launch the reflector thread properly.
    FALSE otherwise.

--*/
{
    DWORD i;
    DWORD Size;


    extern ISN_NODE_TYPE *ReflectorTable;


    if ( ReflectrStatus == Running )
        return TRUE; // already running

    if ( ReflectrStatus != Dead )
        return FALSE; // last state was invalid I can do nothing

    InitializeIsnTableReflector (); //initialize the table with the more list in the registry.

    hReflector = NULL;

    if (!TotalEventCount)
        Wow64RegDbgPrint (("\nSorry! total event count for reflector is zero %d", TotalEventCount));

    //
    // Now time to create event and sync object for the shared resources
    //

    for (i=0;i<ISN_NODE_MAX_NUM;i++) {
        eReflector[i].hRegistryEvent = NULL;
        eReflector[i].hKey = NULL;
        eReflector[i].dwIndex = -1;
        eReflector[i].bDirty = FALSE; // not dirty so that we need to refresh.
    }

    if (!CreateSharedMemory ( 0 ))
        Wow64RegDbgPrint (("\nSorry Couldn't create/open shared memory Ret:%x", GetLastError ())); //default creation

    if (!Wow64CreateEvent ( 0, &eReflector[TotalEventCount].hRegistryEvent ))
        Wow64RegDbgPrint ( ("\nSorry Couldn't create events, reflector can listen to others"));
    else {
        eReflector[TotalEventCount].dwIndex = -1;
        TotalEventCount++;
    }

    Size = TotalRelflectorKey ();
    for ( i=0;i<Size;i++) {

            //
            // Open The Key
            //
            //
            // special case current user
            //

        CreateInsertEvent ( ReflectorTable[i].NodeValue, i );

    }


    //
    // Now Create a thread to watch the event.
    //

    hReflector = CreateThread(
                        NULL,           // pointer to security attributes
                        0,              // initial thread stack size
                        ReflectorFn,    // pointer to thread function
                        0,              // argument for new thread
                        0,              // creation flags
                        NULL            // pointer to receive thread ID

                        );
    if  ( !hReflector ) {

        Wow64RegDbgPrint ( ("\nCouldn't create reflector thread"));
        return FALSE;
    }

    ReflectrStatus = Running;
            return TRUE;
}

BOOL
UnRegisterReflector()
/*++

Routine Description:

    Unregister reflector thread and cleanup resources used by the reflector thread.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    DWORD i;
    DWORD k;

    ReflectrStatus = PrepareToStop;

    //
    //  try to signal event in case the thread is wating
    //
    for (k=0;k<TotalEventCount;k++) {  //reset everything and wait for a fresh event
        if (eReflector[k].hRegistryEvent)
          SetEvent (eReflector[k].hRegistryEvent);
      }


    //
    // Allow reflector thread little bit time to stop.
    //
    i=0;
    while ( ReflectrStatus != Stopped ) {

        Sleep(1000);
        if ( ReflectrStatus != Running )
            break; // why you should wait idle thread or that might be in a abnormal state.

        i++;
        if (i>60*5)
            break;  // 5min timeout going to stop anyway.
    }

    for (i=1;i<TotalEventCount;i++) {  // skip the initial event for shared memory

        CloseHandle (eReflector[i].hRegistryEvent);
        eReflector[i].hRegistryEvent = NULL;

        RegCloseKey ( eReflector[i].hKey );
        eReflector[i].hKey = NULL;
    }

    if ( hReflector ) {
        CloseHandle (hReflector);  //make sure abnormal thread termination doesn't cause any corruption
        hReflector = NULL;
    }

    ReflectrStatus = Dead;

    //
    // release shared resources
    //

    CloseSharedMemory ();
    Wow64CloseEvent ();

    return TRUE;
}

BOOL
InitReflector ()
/*++

Routine Description:

    Initialize resources associated with a reflector thread.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    DWORD k;

    ReflectrStatus = Dead;

    hReflector = NULL;

    for (k=0;k<ISN_NODE_MAX_NUM;k++) {  //reset everything and wait for a fresh event

        eReflector[k].hRegistryEvent = NULL;
        eReflector[k].hKey = NULL;
        eReflector[k].bDirty = FALSE; // not dirty so that we need to refresh.

      }

    return TRUE;

}

LONG
RegReflectKey (
  HKEY hKey,         // handle to open key
  LPCTSTR lpSubKey,   // subkey name
  DWORD   dwOption   // option flag
)
/*++

Routine Description:

    Synchronize registry hive from a given point.

Arguments:

    hKey - handle to an open key. Can be predefined handle or NULL to sync all.
    lpSubKey - Name of the subkey. This can be NULL.
    dwOption - set to zero. for future uses.

Return Value:

    ERROR_SUCCESS on success,
    WIN32 error otherwise.

--*/
{
    HKEY hDest;

    WCHAR Path[_MAX_PATH];
    DWORD Len  = _MAX_PATH;

    WCHAR DestNode[_MAX_PATH];
    BOOL b64bitSide=TRUE;
    BOOL Ret = TRUE;

    DestNode[0] = UNICODE_NULL;

    //
    // present implementation will start from the very top level
    //

    //
    // should interact with the running service, stop the thread, run the reflector and then try again.
    //

    if (hKey != NULL || dwOption!=0 ) {
        Wow64RegDbgPrint (("\nCurrent implementation only take all zero parameters. "));
    }

    if (!InitializeIsnTable ())
        return -1;

    if (!InitializeIsnTableReflector ())
        return -1;

    if (!HandleToKeyName ( hKey, Path, &Len ))
        return -1;

    //
    // Make the complete path
    //

    if ( lpSubKey != NULL )
        if (lpSubKey[0] != UNICODE_NULL ) {
            wcscat (Path, L"\\");
            wcscat (Path, lpSubKey );
        }

    //
    // MakeSure destination exists
    //
    //
    // must check the value if that exist
    //

    if ( Is64bitNode ( Path )) {

        Map64bitTo32bitKeyName ( Path, DestNode );
    } else {

        b64bitSide = FALSE;
        Map32bitTo64bitKeyName ( Path, DestNode );
    }

    hDest = OpenNode (DestNode);
    if (hDest != NULL)
        RegCloseKey ( hDest);
    else {
        if ( !CreateNode (DestNode))
            return -1;
    }

    SyncNode (Path);

    return ERROR_SUCCESS;
}

BOOL
SetWow64InitialRegistryLayout ()
/*++

Routine Description:

    This routine does some initial setup for the registry for wow64.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/

{
    DWORD Ret;
    HKEY Key;
    //HKEY Key1;
    //
    //  Create symbolic link {HKLM\software\Wow6432Node\Classes to HKLM\software\classes\wow6432Node}
    //

    InitializeWow64OnBoot (1);
    return TRUE;

    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            L"SOFTWARE\\Classes\\Wow6432Node",  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if ( Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry! I couldn't create the key SOFTWARE\\Classes\\Wow6432Node") );
        return FALSE;
    }
    RegCloseKey ( Key );

    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            L"SOFTWARE\\Wow6432Node", // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE ,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if  (Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry! couldn't create/open SOFTWARE\\Wow6432Node") );
        return FALSE;
    } else  {

        //
        // Delete the Key if exist
        //
        Ret = RegDeleteKey ( Key, L"Classes");
        RegCloseKey (Key);

    }
    if  (Ret == ERROR_SUCCESS )
    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            L"SOFTWARE\\Wow6432Node\\Classes",  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE | REG_OPTION_OPEN_LINK | REG_OPTION_CREATE_LINK,  // special options flag
                            KEY_ALL_ACCESS | KEY_CREATE_LINK,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if(Ret == ERROR_SUCCESS) {
        Ret = RegSetValueEx(
                            Key,
                            L"SymbolicLinkValue",
                            0,
                            REG_LINK,
                            (PBYTE)WOW64_32BIT_MACHINE_CLASSES_ROOT,
                            (DWORD ) (wcslen (WOW64_32BIT_MACHINE_CLASSES_ROOT) * sizeof (WCHAR))
                            );
        RegCloseKey(Key);
        if ( Ret != ERROR_SUCCESS ) {
            Wow64RegDbgPrint ( ("\nSorry! I couldn't create symbolic link to %S", WOW64_32BIT_MACHINE_CLASSES_ROOT));
            return FALSE;
        }
    }else {
        Wow64RegDbgPrint ( ("\nWarning!! SOFTWARE\\Wow6432Node\\Classes might be already there\n") );
        return FALSE;
    }

    return TRUE;
}


BOOL
PopulateReflectorTable ()
/*++

Routine Description:

    Populate the initial redirector table

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/

{

    extern ISN_NODE_TYPE *ReflectorTable;
    extern ISN_NODE_TYPE *RedirectorTable;

    HKEY Key;
    LONG Ret;
    DWORD dwIndex=0;

    //
    // delete the entry first
    //

    SetWow64InitialRegistryLayout ();

    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            (LPCWSTR ) WOW64_REGISTRY_SETUP_KEY_NAME_REL,  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if (Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry!! couldn't open/create key list at %S", WOW64_REGISTRY_SETUP_REFLECTOR_KEY) );
        return FALSE;
    }


    //
    // Now Key point to the right location
    //

    for ( dwIndex=0;wcslen (RedirectorTable[dwIndex].NodeValue);dwIndex++) {
        if (RedirectorTable[dwIndex].Flag==0) { // write the node in the registry
             Ret = RegSetValueEx(
                            Key,
                            RedirectorTable[dwIndex].NodeName,
                            0,
                            REG_SZ,
                            (PBYTE)&RedirectorTable[dwIndex].NodeValue[0],
                            (ULONG)(wcslen (RedirectorTable[dwIndex].NodeValue)+sizeof(UNICODE_NULL))*sizeof(WCHAR)
                            );
             if ( Ret != ERROR_SUCCESS ) {
                 Wow64RegDbgPrint ( ("\nSorry! couldn't write the key"));
                 RegCloseKey (Key);
                 return FALSE;
             }

        }
    }

    RegCloseKey (Key);



    //
    //  populate list for reflector
    //

    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            (LPCWSTR ) WOW64_REGISTRY_SETUP_REFLECTOR_KEY,  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if (Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry!! couldn't open/create key list at %S", WOW64_REGISTRY_SETUP_REFLECTOR_KEY));
        return FALSE;
    }


    //
    // Now Key point to the right location
    //

    for ( dwIndex=0;wcslen (ReflectorTable[dwIndex].NodeValue);dwIndex++) {
        if (ReflectorTable[dwIndex].Flag==0) { // write the node in the registry
             Ret = RegSetValueEx(
                            Key,
                            ReflectorTable[dwIndex].NodeName,
                            0,
                            REG_SZ,
                            (PBYTE)&ReflectorTable[dwIndex].NodeValue[0],
                            (ULONG)(wcslen (ReflectorTable[dwIndex].NodeValue)+sizeof(UNICODE_NULL))*sizeof(WCHAR)
                            );
             if ( Ret != ERROR_SUCCESS ) {
                 Wow64RegDbgPrint ( ("\nSorry! couldn't write the key"));
                 RegCloseKey (Key);
                 return FALSE;
             }

        }
    }

    RegCloseKey (Key);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\regremap\wow64reg\wow64ipc.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    wow64ipc.c

Abstract:

    This module will do the communication machanism among different processes that need
    to interact with the wow64 services, like winlogon will notify wow64svc.

Author:

    ATM Shafiqul Khalid (askhalid) 22-Mar-2000

Revision History:

--*/


#include <windows.h> 
#include <memory.h> 
#include <wow64reg.h>
#include <stdio.h>
#include "reflectr.h"
 
#define SHMEMSIZE 4096 
 
LPVOID lpvMem = NULL; // pointer to shared memory
HANDLE hMapObject = NULL;

HANDLE hWow64Event = NULL;
HANDLE hWow64Mutex = NULL;

LIST_OBJECT *pList = NULL;

//SECURITY_DESCRIPTOR sdWow64SharedMemory;
//SECURITY_ATTRIBUTES saWow64SharedMemory;

BOOL
Wow64CreateLock (
    DWORD dwOption
    )
/*++

Routine Description:

    Create or open Event wow64 service need to check.

Arguments:

    dwOption - 
        OPEN_EXISTING_SHARED_MEMORY  -- shouldn't be the first process to create this.

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/

{
    hWow64Mutex =  CreateMutex(
                                NULL, // SD
                                FALSE,// initial owner
                                WOW64_SVC_REFLECTOR_MUTEX_NAME // object name
                                );
    if ( hWow64Mutex == NULL )
        return FALSE;

    if ( GetLastError() != ERROR_ALREADY_EXISTS && dwOption == OPEN_EXISTING_SHARED_RESOURCES) {

        Wow64CloseLock ();
        return FALSE;
    }

    return TRUE;

}

VOID
Wow64CloseLock ()

/*++

Routine Description:

    Close wow64 service event.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( NULL != hWow64Mutex )
        CloseHandle ( hWow64Mutex );
    hWow64Mutex = NULL;
}
 
Wow64CreateEvent (
    DWORD dwOption,
    HANDLE *hEvent
    )
/*++

Routine Description:

    Create or open Event wow64 service need to check.

Arguments:

    dwOption - 
        OPEN_EXISTING_SHARED_MEMORY  -- shouldn't be the first process to create this.

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/

{
    *hEvent = NULL;

    hWow64Event =  CreateEvent(
                                NULL, // SD
                                TRUE, // reset type
                                FALSE,// initial state
                                WOW64_SVC_REFLECTOR_EVENT_NAME // object name
                                );
    if ( hWow64Event == NULL )
        return FALSE;

    if ( GetLastError() != ERROR_ALREADY_EXISTS && dwOption == OPEN_EXISTING_SHARED_RESOURCES) {

        Wow64CloseEvent ();
        return FALSE;
    }

    *hEvent = hWow64Event;
    return TRUE;

}

VOID
Wow64CloseEvent ()

/*++

Routine Description:

    Close wow64 service event.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( NULL != hWow64Event )
        CloseHandle ( hWow64Event );
    hWow64Event = NULL;
}

BOOL
LockSharedMemory ()
{
    DWORD Ret;
    Ret = WaitForSingleObject( hWow64Mutex, 1000*5*60); // 5 min is good enough
    
    //
    //  now you can access shared memory
    //
    //Log information if error occur

    if ( Ret == WAIT_OBJECT_0 || Ret == WAIT_ABANDONED ) 
        return TRUE;

    //
    // check for abandaned case
    //

    return FALSE;

}

BOOL
UnLockSharedMemory ()
{
    if ( ReleaseMutex ( hWow64Mutex ) ) 
        return TRUE;

    return FALSE;
}

BOOL 
CreateSharedMemory (
    DWORD dwOption
    )
/*++

Routine Description:

    Create or open shared memory, used by different process.

Arguments:

    dwOption - 
        OPEN_EXISTING_SHARED_MEMORY  -- shouldn't be the first process to create this.

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/

{ 
    BOOL fInit;

    
    //if (!InitializeSecurityDescriptor( &sdWow64SharedMemory, SECURITY_DESCRIPTOR_REVISION ))
      //  return FALSE;

    // saWow64SharedMemory.nLength = sizeof ( SECURITY_ATTRIBUTES );
    // saWow64SharedMemory.bInheritHandle =  TRUE; 
    // saWow64SharedMemory.lpSecurityDescriptor = &sdWow64SharedMemory; 
  





            // Create a named file mapping object.
 
            hMapObject = CreateFileMapping( 
                INVALID_HANDLE_VALUE, // use paging file
                NULL, //&saWow64SharedMemory,                 // no security attributes
                PAGE_READWRITE,       // read/write access
                0,                    // size: high 32-bits
                SHMEMSIZE,            // size: low 32-bits
                SHRED_MEMORY_NAME );     // name of map object

            if (hMapObject == NULL) 
                return FALSE; 
 
            // The first process to attach initializes memory.
 
            fInit = (GetLastError() != ERROR_ALREADY_EXISTS); 

            if (fInit && dwOption == OPEN_EXISTING_SHARED_RESOURCES ) {

                CloseSharedMemory ();
                return FALSE; // no shared memory exist
            }
 
            // Get a pointer to the file-mapped shared memory.
 
            pList = (LIST_OBJECT *) MapViewOfFile( 
                hMapObject,     // object to map view of
                FILE_MAP_WRITE, // read/write access
                0,              // high offset:  map from
                0,              // low offset:   beginning
                0);             // default: map entire file
            if (pList == NULL) 
                return FALSE; 
 
            // Initialize memory if this is the first process.
 
            if (fInit) {
                memset( ( PBYTE )pList, '\0', SHMEMSIZE); 
                pList->MaxCount = ( SHMEMSIZE - sizeof ( LIST_OBJECT ) ) / (LIST_NAME_LEN*sizeof (WCHAR)); 
            
            }

            //
            //  Also initialize all the locking and synchronization object
            //

            if ( !Wow64CreateLock ( dwOption ) ) {
                CloseSharedMemory ();
                return FALSE;
            }
 
            return TRUE;
}

VOID
CloseSharedMemory ()
{ 

            if (pList != NULL )
                UnmapViewOfFile(pList); 
            pList = NULL;
 
            // Close the process's handle to the file-mapping object.
 
            if ( hMapObject!= NULL ) 
                CloseHandle(hMapObject); 
            hMapObject = NULL;

            Wow64CloseLock ();
            
} 

// initially try to transfer only one object

BOOL
EnQueueObject (
    PWCHAR pObjName,
    WCHAR  Type
    )
/*++

Routine Description:

    Put an object name in the queue.

Arguments:

    pObjName - Name of the object to put in the quque.
    Type - L: Loading hive
           U: Unloading Hive

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/
{
    // lpvMem check if this value is NULL
    // wait to get the lock on shared memory

    DWORD Len;
    DWORD i;

    if ( pList == NULL )
        return FALSE;

    Len = wcslen (pObjName);
    if (Len == 0 || Len > 256 )
        return FALSE;

    if (!LockSharedMemory ())
        return FALSE;

    if ( pList->Count == pList->MaxCount ) {
        UnLockSharedMemory ();
        return FALSE;
    }

    for ( i=0; i<pList->MaxCount; i++) {
        if (pList->Name[i][0] == UNICODE_NULL ) break;
    }

    if ( i == pList->MaxCount ) {
        UnLockSharedMemory ();
        return FALSE;
    }


    wcscpy ( pList->Name[i], pObjName);
    pList->Count++;
    pList->Name[i][LIST_NAME_LEN-1] = Type;

    UnLockSharedMemory ();
    SignalWow64Svc ();

    // write data

    // release data
    return TRUE;
}

BOOL
DeQueueObject (
    PWCHAR pObjName,
    PWCHAR  Type
    )
/*++

Routine Description:

    Get a name of object from the queue.

Arguments:

    pObjName - Name of the object that receive the name.
    Type - L: Loading hive
           U: Unloading Hive

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/
{
    // lpvMem check if this value is NULL
    // wait to get the lock on shared memory

    DWORD Len;
    DWORD i;

    if ( pList == NULL )
        return FALSE;


    if (!LockSharedMemory ())
        return FALSE;

    if ( pList->Count == 0 ) {
        UnLockSharedMemory ();
        return FALSE;
    }

    for ( i=0; i < pList->MaxCount; i++) {
        if (pList->Name[i][0] != UNICODE_NULL ) break;
    }

    if ( i == pList->MaxCount ) {
        UnLockSharedMemory ();
        return FALSE;
    }

    wcscpy ( pObjName, pList->Name[i]);
    pList->Name[i][0] = UNICODE_NULL;

    pList->Count--;
    *Type = pList->Name[i][LIST_NAME_LEN-1];

    UnLockSharedMemory ();
    //SignalWow64Svc (); 

    // write data

    // release data
    return TRUE;
}
 
//signal wowservice to receive the data.

BOOL
SignalWow64Svc ()
{
   //this might be a simple event trigger or set event

    if ( SetEvent ( hWow64Event ) )
        return TRUE;

    return FALSE;

}

BOOL 
CheckAdminPriviledge ()
/*++

Routine Description:

    Check if the running thread has admin priviledge.

Arguments:

    None.

Return Value:

    TRUE if the calling thread has admin proviledge.
    FALSE otherwise.

--*/
{
 
    BOOL bRetCode = FALSE;
/*
    HANDLE TokenHandle;
    BOOL b;
    DWORD ReturnLength;

    PTOKEN_USER TokenInfo;

    //
    // If we're impersonating, use the thread token, otherwise
    // use the process token.
    //

    PTOKEN_USER Result = NULL;

    b = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &TokenHandle
            );

    if (!b) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            //
            // We're not impersonating, try the process token
            //

            b = OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_QUERY,
                    &TokenHandle
                    );

            if (!b) {

                return FALSE;
            }

        } else {

            //
            // We failed for some unexpected reason, return NULL and
            // let the caller figure it out if he so chooses.
            //

            return FALSE;
        }
    }

    ReturnLength = GetSidLengthRequired( SID_MAX_SUB_AUTHORITIES ) + sizeof( TOKEN_USER );

    TokenInfo = (PTOKEN_USER)malloc( ReturnLength );

    if (TokenInfo != NULL) {

        b = GetTokenInformation (
               TokenHandle,
               TokenGroups,
               TokenInfo,
               ReturnLength,
               &ReturnLength
               );

        if (b) {

            Result = TokenInfo;

        } else {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

                //
                // Reallocate TokenInfo
                //

                free( TokenInfo );

                TokenInfo = (PTOKEN_USER)malloc( ReturnLength );

                if (TokenInfo != NULL) {

                    b = GetTokenInformation (
                           TokenHandle,
                           TokenGroups,
                           TokenInfo,
                           ReturnLength,
                           &ReturnLength
                           );

                    if (b) {

                        Result = TokenInfo;
                    }

                } else {

                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
					return FALSE;
                }
            }
        }

    } else {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
		return FALSE;
    }


	DWORD dwSidSize = 0;
	SID_NAME_USE SidType;
	DWORD strSize = 80;
	WCHAR  str [80];
	SID_NAME_USE sidType;
	BOOL bProceede = TRUE;

	DWORD dwRet = LookupAccountName ( 
									NULL, 
									L"Administrators", 
									NULL, 
									&dwSidSize, 
									str, 
									&strSize, 
									&sidType );

	if ( dwSidSize == 0)
	if ( !dwRet  ) {
		cBase.PrintErrorWin32 ( GetLastError () );
		bProceede = FALSE;

	}

	PSID psid = NULL;

	if ( bProceede )
	if ( dwSidSize ) {
		psid = (PSID) GlobalAlloc ( GPTR, dwSidSize );

		if ( psid == NULL )
			bProceede = FALSE;
		else {
			strSize = 80;
			dwRet = LookupAccountName ( 
										NULL, 
										L"Administrators", 
										psid,                                                                                                                                                                                                                                                                                                  
										&dwSidSize, 
										str, 
										&strSize, 
										&sidType );
			if ( ! dwRet )
				bProceede = FALSE;
		}
	}

	//now check
	

	if ( Result == NULL ) 
		bProceede = FALSE;


	TOKEN_GROUPS *pGroups = ( TOKEN_GROUPS *)Result;
	
	
	if ( bProceede )
	for ( int i=0; i < pGroups->GroupCount; i++ ) {
		if ( EqualSid ( pGroups->Groups [i].Sid, psid ) ){
			bRetCode = TRUE;
			break;
		}
	};

	if ( psid != NULL )
		GlobalFree ( psid );

	if ( Result != NULL )
		free ( Result );

*/
    return bRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\boot\driveex.h ===
/* Return values of GetDriveTypeEx(). */
#define EX_DRIVE_INVALID    0
#define EX_DRIVE_REMOVABLE  1
#define EX_DRIVE_FIXED      2
#define EX_DRIVE_REMOTE     3
#define EX_DRIVE_CDROM      4
#define EX_DRIVE_FLOPPY     5
#define EX_DRIVE_RAMDISK    6


UINT GetDriveTypeEx (int nDrive);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\boot\dmnd2.c ===
/***************************************************************************
**
**	File:			dmnd2.c
**	Purpose:		CallBack functions to be passed to the Diamond
**					FDI (File Decompression Interface) module.
**	Notes:
**
****************************************************************************/

#define DMND2_C

#include <windows.h>
#include <stdlib.h>		/* malloc */
#include <malloc.h>		/* malloc, _halloc */
#include <stdio.h>		/* _tempnam */
#include <fcntl.h>
#include <io.h>			/* _open, _read, _write, _write, _lseek, _mktemp */
#include <sys\stat.h>	/* _S_IWRITE, _S_IREAD */

#include "stdtypes.h"
#include "setup.h"

#include <fdi.h>


typedef struct _fud		/* Fdi User Data block used in FDICopy */
	{
	char * szDstDir;
	char * szSrcs;
	char * szDsts;
	char * szSrcBuf;
	char * szDstBuf;
	BOOL * rgfSrcFilesCopied;
	int    cFilesCopied;
	int    cSrcFiles;
	int    cCabNum;		/* Current cabinet number (starts at 1) */
	HWND   hWnd;		/* Window handle used to display dialogs */
	HFDI   hfdi;
	ERF    erf;
	BRC    brc;
	char   rgchSpillFileName[cchFullPathMax];
	int    hfSpillFile;
	}  FUD;

typedef FUD *   PFUD;   /* Ptr to Fdi User Data block */

#define pfudNull	((PFUD)NULL)
#define hfdiNull	((HFDI)NULL)

#define szSpillFilePrefix		"sf"
#define szSpillFileTemplate		"sfXXXXXX"

/* FDI Callback Routines
*/
FNFDINOTIFY  ( FnFdiNotifyCB );
FNALLOC      ( FnFdiAllocCB );
FNFREE       ( FnFdiFreeCB );
INT_PTR  FAR DIAMONDAPI FnFdiOpenCB  ( char FAR *szFile, int oflag, int pmode );
UINT FAR DIAMONDAPI FnFdiReadCB  ( INT_PTR hf, void FAR *pv, UINT cb );
UINT FAR DIAMONDAPI FnFdiWriteCB ( INT_PTR hf, void FAR *pv, UINT cb );
int  FAR DIAMONDAPI FnFdiCloseCB ( INT_PTR hf );
long FAR DIAMONDAPI FnFdiSeekCB  ( INT_PTR hf, long dist, int seektype );


/* Private Functions
*/
static int  FhHandleCopyFileMsgInNotify ( PFUD pfud, char * szFName );
static BOOL FHandleCloseFileMsgInNotify ( PFUD pfud, INT_PTR hf );
static BOOL FHandleNextCabMsgInNotify ( PFUD pfud, char * szCabFName,
				char * szDiskLabel, char * szSrcDir, FDIERROR fdie );
static BOOL FModifyCabinetName(char * szSrcDir, int cCabNum);
static BOOL FEnsureCabinetFileIsPresent(HWND hWnd, char * szSrcDir,
											char * szCabinet, int cCabNum);
static int  HfOpenSpillFile ( PFDISPILLFILE pfdisf, int oflag, int pmode );
static VOID InitFud (PFUD pfud, char * szDstDir, char * szSrcs,
				char * szDsts, char * szSrcBuf, char * szDstBuf,
				BOOL * rgfSrcFilesCopied, int cSrcFiles, HWND hWnd );

/* KLUDGE - so pfud->brc can be found in callbacks */
static PFUD pfudG = pfudNull;


#ifndef DEBUG_TEST	/* Turn on for create/skip file messages. */
  #define DebugMsgSz(sz1, sz2)
#else  /* DEBUG */
static VOID DebugMsgSz ( char * szPattern, char * szArgument );

/*
************************************************************************/
static VOID DebugMsgSz ( char * szPattern, char * szArgument )
{
	char rgch[128];

	wsprintf(rgch, szPattern, szArgument);
	DebugMsg(rgch);
}
#endif /* DEBUG */


/*
**	Purpose:
**		This function is passed as a callback to the FDI library.
**	Arguments:
**		fdint - type of notification
**		pfdin - data for notification
**	Returns:
**		varies with fdint
**
*************************************************************************/
FNFDINOTIFY ( FnFdiNotifyCB )
{
	switch (fdint)
		{
	default:
		DebugMsg("Unexpected message passed to FnFdiNotifyCB().");
		((PFUD)(pfdin->pv))->brc = brcGen;
		return (0);

	case fdintCABINET_INFO:
		/* do nothing */
		return (0);

	case fdintCOPY_FILE:
		return (FhHandleCopyFileMsgInNotify(pfdin->pv, pfdin->psz1));

	case fdintCLOSE_FILE_INFO:
		return (FHandleCloseFileMsgInNotify(pfdin->pv, pfdin->hf) ? TRUE
					: -1);

	case fdintPARTIAL_FILE:
		/* do nothing */
		return (0);

	case fdintNEXT_CABINET:
		return (FHandleNextCabMsgInNotify(pfdin->pv, pfdin->psz1,
					pfdin->psz2, pfdin->psz3, pfdin->fdie) ? 0 : -1);
		}
}


/*
**	returns:
**		 0 == skip this file
**		-1 == abort FDICopy()
**		else a legitimate DOS file handle
*************************************************************************/
static int FhHandleCopyFileMsgInNotify ( PFUD pfud, char * szFName )
{
	SZ  szSrcs = pfud->szSrcs;
	SZ  szDsts = pfud->szDsts;
	int iFile;
	struct _stat stat;

	for (iFile = 0; *szSrcs; iFile++)
		{
		if (*szSrcs == '@' && !lstrcmpi(szSrcs+1, szFName))
			{
			int  hfRet;

			lstrcpy(pfud->szDstBuf, pfud->szDstDir);
			lstrcat(pfud->szDstBuf, "\\");
			lstrcat(pfud->szDstBuf, szDsts);
			DebugMsgSz("Creating Dest File: %s", pfud->szDstBuf);

			/* If file exists, try to remove it.
			*/
			if (_stat(pfud->szDstBuf, &stat) != -1)
				{
				/* NOTE: Ignore error return values here since
				*	 _open should catch any errors anyway.
				*/
				if (!(stat.st_mode & _S_IWRITE))
					_chmod(pfud->szDstBuf, _S_IREAD | _S_IWRITE);
				_unlink(pfudG->szDstBuf);
				}

			hfRet = _open(pfud->szDstBuf,
							_O_BINARY | _O_CREAT | _O_RDWR | _O_TRUNC,
							_S_IREAD | _S_IWRITE);
			if (hfRet == -1)
				pfud->brc = brcMemDS;

			if (iFile < pfud->cSrcFiles)
				(pfud->rgfSrcFilesCopied)[iFile] = TRUE;

			// We will have copied one more file
			pfud->cFilesCopied++;

			return (hfRet);
			}

		szSrcs += lstrlen(szSrcs) + 1;
		szDsts += lstrlen(szDsts) + 1;
		}

	DebugMsgSz("Skipping a cabinet file: %s", szFName);

	return (0);
}


/*
*************************************************************************/
static BOOL FHandleCloseFileMsgInNotify ( PFUD pfud, INT_PTR hf )
{
	if (FnFdiCloseCB(hf) != -1)
		{
		_chmod(pfud->szDstBuf, S_IREAD);
		return (TRUE);
		}

	return (FALSE);
}


/*
*************************************************************************/
static BOOL FHandleNextCabMsgInNotify ( PFUD pfud, char * szCabFName,
				char * szDiskLabel, char * szSrcDir, FDIERROR fdie )
{
	Unused(szDiskLabel);

	/* Check if diamond is calling us again because the cabinet
	*	we specified was bad.
	*/
	if (fdie == FDIERROR_WRONG_CABINET)
		{
		DebugMsg("Cabinet files are out of sequence or corrupted.");
		return FALSE;
		}

	lstrcpy(pfud->szSrcBuf, szSrcDir);
	lstrcat(pfud->szSrcBuf, szCabFName);

	if (!FEnsureCabinetFileIsPresent(pfud->hWnd, szSrcDir, szCabFName,
										pfud->cCabNum+1))
		{
		pfud->brc = brcFile;
		
		return FALSE;
		}
		
	return TRUE;
}


/*
*************************************************************************/
static int CFilesInSrcsInitRgf ( char * szSrcs, BOOL * rgfSrcFilesCopied )
{
	int iFile, cFiles;

	for (iFile = 0; iFile < 128; iFile++)
		rgfSrcFilesCopied[iFile] = TRUE;

	cFiles = 0;
	while (*szSrcs)
		{
		if (*szSrcs == '@')
			rgfSrcFilesCopied[cFiles] = FALSE;

		cFiles++;
		szSrcs += lstrlen(szSrcs) + 1;
		}

	if (cFiles > 128)
		{
		DebugMsg("More than 128 source files in .LST file "
						"- will not check that all exist.");
		cFiles = 128;
		}

	return (cFiles);
}


/*
**	Purpose:
**		Copies all cabinet files in the specified copy list, ignoring
**		any non-cabinet files in the list.
**	Arguments:
**		szCabinet:  cabinet filename (oem).
**		szSrcDir:   src path with trailing backslash (ANSI).
**		szDstDir:   dst path with trailing backslash (oem).
**		szSrcs:     NULL separated list of src filenames (oem).
**		szDsts:     NULL separated list of dst filenames (oem).
**		szSrcBuf:   buffer to hold src path for error msgs.
**		szDstBuf:   buffer to hold dst path for error msgs.
**	Returns:
**		brcOkay if completed without error, brcXX otherwise.
**
*************************************************************************/
extern  BRC  BrcHandleCabinetFiles ( HWND hWnd, char * szCabinet,
					int cFirstCabinetNum, int cLastCabinetNum, char *szSrcDir,
					char * szDstDir, char * szSrcs, char * szDsts,
					char * szSrcBuf, char * szDstBuf )
{
	FUD  fud;
	BRC  brcRet    = brcOkay;
	BOOL rgfSrcFilesCopied[128];
	int  cSrcFiles = CFilesInSrcsInitRgf(szSrcs, rgfSrcFilesCopied);
	int  cpuType   = cpuUNKNOWN;

	InitFud(&fud, szDstDir, szSrcs, szDsts, szSrcBuf, szDstBuf,
				rgfSrcFilesCopied, cSrcFiles, hWnd);
	pfudG = &fud;

#if 0
	/*	NOTE: Get CPU type ourselves, since FDI's CPU detection may
	*	not work correctly for 16-bit Windows applications.
	*/
	cpuType = (GetWinFlags() & WF_CPU286) ? cpu80286 : cpu80386;
#endif

    if ((fud.hfdi = FDICreate(FnFdiAllocCB, FnFdiFreeCB, FnFdiOpenCB,
								FnFdiReadCB, FnFdiWriteCB, FnFdiCloseCB,
								FnFdiSeekCB, cpuType,
								&(fud.erf) )) == hfdiNull)
		{
        return (brcMem);
        }

	/*
	 * Process cabinets as long as we have more files to copy.
	 * i is the current cabinet number (starting at 1).
	 */
	for (fud.cCabNum=cFirstCabinetNum;
			fud.cFilesCopied < fud.cSrcFiles && fud.cCabNum<=cLastCabinetNum;
			fud.cCabNum++)
		{
		/* Modify the cabinet name depending on the current cabinet number */
		if (!FModifyCabinetName(szCabinet, fud.cCabNum))
			{
			brcRet = brcFile;
			break;
			}

		lstrcpy(szSrcBuf, szSrcDir);
		lstrcat(szSrcBuf, szCabinet);

		if (!FEnsureCabinetFileIsPresent(fud.hWnd, szSrcDir, szCabinet,
											fud.cCabNum))
			{
			brcRet = brcFile;
			break;
			}

		if (!FDICopy(fud.hfdi, szCabinet, szSrcDir, 0, FnFdiNotifyCB, NULL,
				&fud))
			{
			brcRet = (fud.brc == brcOkay) ? brcGen : fud.brc;
			break;
			}
		}

	if (brcRet == brcOkay)
		{
		int iFile;

		/* Check if we got all the files we want */
		for (iFile = 0; iFile < cSrcFiles; iFile++)
			{
			if (!(rgfSrcFilesCopied[iFile]))
				{
				lstrcat(szSrcBuf, " : ");
				lstrcat(szSrcBuf, szSrcs + 1);
				brcRet = brcFile;
				}
			szSrcs += lstrlen(szSrcs) + 1;
			}
		}

	FDIDestroy(fud.hfdi);

	/* Ensure that the spill file is deleted.
	*/
	Assert(pfudG != pfudNull);
	if (pfudG->hfSpillFile != -1)
		FnFdiCloseCB(pfudG->hfSpillFile);

	return (brcRet);
}


/*
*************************************************************************/
static VOID InitFud (PFUD pfud, char * szDstDir, char * szSrcs,
				char * szDsts, char * szSrcBuf, char * szDstBuf,
				BOOL * rgfSrcFilesCopied, int cSrcFiles, HWND hWnd )
{
	pfud->erf.fError   = fFalse;
	pfud->szDstDir     = szDstDir;
	pfud->szSrcs       = szSrcs;
	pfud->szDsts       = szDsts;
	pfud->szSrcBuf     = szSrcBuf;
	pfud->szDstBuf     = szDstBuf;
	pfud->rgfSrcFilesCopied = rgfSrcFilesCopied;
	pfud->cSrcFiles    = cSrcFiles;
	pfud->cFilesCopied = 0;
	pfud->hWnd         = hWnd;
	pfud->brc          = brcOkay;
	*(pfud->rgchSpillFileName) = chEos;
	pfud->hfSpillFile  = -1;
}


static BOOL FModifyCabinetName(char * szSrcDir, int cCabNum)
{
	char *pch = szSrcDir + lstrlen(szSrcDir);
	
	if (cCabNum < 1 || cCabNum > 9)
		return FALSE;
	
	/* Leave the name unchabged for the first cabinet */
	if (cCabNum == 1)
		return TRUE;
	
	/* Look for the dot, starting backward */
	for (; *pch != '.'; pch--)
		{
		/* Error if we can't find a dot before we find a slash */
		if (pch<=szSrcDir+1 || *pch == '\\')
			return FALSE;
		}
	
	/* Point to the character before the dot */
	pch--;
	
	/* Replace the last character before the dot by the cabinet number */
	*pch = (char)(cCabNum + '0');
	
	return TRUE;
}

static BOOL FEnsureCabinetFileIsPresent(HWND hWnd, char * szSrcDir,
											char * szCabinet, int cCabNum)
{
	char rgchFileName[cchFullPathMax], rgchCabNum[32];
	OFSTRUCT ofs;
	HFILE hFile;
	BOOL fFirst = TRUE;

	Unused(hWnd);
	
	lstrcpy(rgchFileName, szSrcDir);
	lstrcat(rgchFileName, szCabinet);
	
	for (;;)
		{
		hFile = OpenFile(rgchFileName, &ofs, OF_EXIST);
		if (hFile != HFILE_ERROR)
			break;
		
		_itoa(cCabNum, rgchCabNum, 10);
		
		if (fFirst)
			{
			if (DispErrBrc(brcInsDisk, FALSE, MB_ICONEXCLAMATION|MB_OKCANCEL,
					rgchCabNum, NULL, NULL) != IDOK)
				{
				return FALSE;
				}
			fFirst = FALSE;
			}
		else
			{
			if (DispErrBrc(brcInsDisk2, FALSE, MB_ICONEXCLAMATION|MB_OKCANCEL,
					rgchFileName, rgchCabNum, NULL) != IDOK)
				{
				return FALSE;
				}
			}

		}
	
	return TRUE;
}


/*
**	Purpose:
**		Memory allocator for FDI.
**	Arguments:
**		cb - size of block to allocate
**	Returns:
**		Non-NULL pointer to block of size at least cb,
**		or NULL for failure.
**
*************************************************************************/
FNALLOC ( FnFdiAllocCB )
{
#ifdef _WIN32
	void HUGE * pvRet = malloc(cb);
#else
	void HUGE * pvRet = _halloc(cb,1);
#endif

	if (pvRet == NULL && pfudG->brc == brcOkay)
		pfudG->brc = brcMem;

	return (pvRet);
}


/*
**	Purpose:
**		Memory free function for FDI.
**	Arguments:
**		pv - memory allocated by FnFdiAllocCB to be freed
**	Returns:
**		None.
**
*************************************************************************/
FNFREE ( FnFdiFreeCB )
{
#ifdef _WIN32
    free(pv);
#else
    _hfree(pv);
#endif
}


/*
*************************************************************************/
INT_PTR FAR DIAMONDAPI FnFdiOpenCB ( char FAR *szFile, int oflag, int pmode )
{
	INT_PTR hfRet;
	
	if (*szFile == '*')
		return (HfOpenSpillFile((PFDISPILLFILE)szFile, oflag, pmode));
	
	hfRet = _open(szFile, oflag, pmode);

	if (hfRet == -1 && pfudG->brc == brcOkay)
		pfudG->brc = brcFile;

	return (hfRet);
}


/*
*************************************************************************/
static int HfOpenSpillFile ( PFDISPILLFILE pfdisf, int oflag, int pmode )
{
	SZ   szTmp;
	CHAR rgchSize[20];
	BOOL fTryAgain = fTrue;

	Assert(pfdisf != (PFDISPILLFILE)NULL);
	Assert(*(pfdisf->ach) == '*');
	Assert(pfudG != pfudNull);
	Assert(pfudG->hfSpillFile == -1);	/* Only one at a time */
	Assert(*(pfudG->rgchSpillFileName) == chEos);

	if ((szTmp = _tempnam("", szSpillFilePrefix)) == szNull)
		{
		DebugMsg("Unable to get spill file name.");
		goto LNoSpillFile;
		}
	Assert(lstrlen(szTmp) < sizeof(pfudG->rgchSpillFileName));
	lstrcpy(pfudG->rgchSpillFileName, szTmp);
	free(szTmp);

LOpenSpillFile:
	oflag = _O_CREAT | _O_BINARY | _O_RDWR;		/* Force open mode */
	if ((pfudG->hfSpillFile = _open(pfudG->rgchSpillFileName, oflag, pmode))
			== -1)
		{
		DebugMsg("Unable to open spill file.");
		goto LNoSpillFile;
		}

	if (pfdisf->cbFile > 0)
		{
		/* Size file by writing one byte at size - 1.
		*/
		if (FnFdiSeekCB(pfudG->hfSpillFile, pfdisf->cbFile - 1, SEEK_SET) == -1
				|| FnFdiWriteCB(pfudG->hfSpillFile, "b", 1) != 1)
			{
			DebugMsg("Unable to set spill file size.");
			goto LNoSpillFile;
			}
		}

	return (pfudG->hfSpillFile);

LNoSpillFile:
	if (pfudG->hfSpillFile != -1)
		FnFdiCloseCB(pfudG->hfSpillFile);

	if (fTryAgain)
		{
		/* Try again with bootstrap temp dir.
		*
		*	(REVIEW: We could do another search here, checking for size.)
		*/
		fTryAgain = fFalse;
		Assert(lstrlen(pfudG->szDstBuf) + lstrlen(szSpillFileTemplate) <
				sizeof(pfudG->rgchSpillFileName));
		lstrcpy(pfudG->rgchSpillFileName, pfudG->szDstDir);
		lstrcat(pfudG->rgchSpillFileName, szDirSep);
		lstrcat(pfudG->rgchSpillFileName, szSpillFileTemplate);
		if (_mktemp(pfudG->rgchSpillFileName) != NULL)
			goto LOpenSpillFile;
		}

	_ltoa((pfdisf->cbFile + 1023) / 1024, rgchSize, 10);
	DispErrBrc(brcNoSpill, fTrue, MB_OK | MB_ICONSTOP, rgchSize, szNull, szNull);

	*(pfudG->rgchSpillFileName) = chEos;
	pfudG->brc = brcNoSpill;

	return (-1);
}


/*
*************************************************************************/
UINT FAR DIAMONDAPI FnFdiReadCB ( INT_PTR hf, void FAR *pv, UINT cb )
{
	UINT cbRet = _read((int)hf, pv, cb);

	if (cbRet != cb && pfudG->brc == brcOkay)
		pfudG->brc = brcMemDS;

	return (cbRet);
}


/*
*************************************************************************/
UINT FAR DIAMONDAPI FnFdiWriteCB ( INT_PTR hf, void FAR *pv, UINT cb )
{
	UINT cbRet = _write((int)hf, pv, cb);

	FYield();

	if (cbRet != cb && pfudG->brc == brcOkay)
		pfudG->brc = brcDS;

	return (cbRet);
}


/*
*************************************************************************/
int FAR DIAMONDAPI FnFdiCloseCB ( INT_PTR hf )
{
	int iRet = _close((int)hf);

	if (iRet == -1 && pfudG->brc == brcOkay)
		pfudG->brc = brcDS;

	/* If we're closing the spill file, delete it.
	*/
	if (hf == pfudG->hfSpillFile)
		{
		_unlink(pfudG->rgchSpillFileName);		/* Delete spill file */
		*(pfudG->rgchSpillFileName) = chEos;	/* Empty path */
		pfudG->hfSpillFile = -1;				/* Mark as closed */
		}

	return (iRet);
}


/*
*************************************************************************/
long FAR DIAMONDAPI FnFdiSeekCB ( INT_PTR hf, long dist, int seektype )
{
	long lRet = _lseek((int)hf, dist, seektype);

	if (lRet == -1L && pfudG->brc == brcOkay)
		{
		DebugMsg("Seek Operation failed in Cabinet");
		pfudG->brc = brcGen;
		}

	return (lRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\boot\driveex.c ===
#include <windows.h>
#include <string.h>
#include "driveex.h"

#if 0
  /* // See the "MS-DOS Programmer's Reference" for further information
   // about this structure. */
typedef struct tagDEVICEPARAMS
   {
   BYTE  bSpecFunc;        /* Special functions */
   BYTE  bDevType;         /* Device type */
   WORD  wDevAttr;         /* Device attributes */
   WORD  wCylinders;       /* Number of cylinders */
   BYTE  bMediaType;       /* Media type */
                        /* Beginning of BIOS parameter block (BPB) */
   WORD  wBytesPerSec;     /* Bytes per sector */
   BYTE  bSecPerClust;     /* Sectors per cluster */
   WORD  wResSectors;      /* Number of reserved sectors */
   BYTE  bFATs;            /* Number of FATs */
   WORD  wRootDirEnts;     /* Number of root-directory entries */
   WORD  wSectors;         /* Total number of sectors */
   BYTE  bMedia;           /* Media descriptor */
   WORD  wFATsecs;         /* Number of sectors per FAT */
   WORD  wSecPerTrack;     /* Number of sectors per track */
   WORD  wHeads;           /* Number of heads */
   DWORD dwHiddenSecs;     /* Number of hidden sectors */
   DWORD dwHugeSectors;    /* Number of sectors if wSectors == 0 */
                        /* End of BIOS parameter block (BPB) */
   } DEVICEPARAMS, FAR * LPDEVICEPARAMS;
   /* Function prototypes */
BOOL GetDeviceParameters (int nDrive, LPDEVICEPARAMS dp);
BOOL IsCDRomDrive (int nDrive);
/*----------------------------------------------------------------- */
/* GetDeviceParameters() */
/* */
/* Fills a DEVICEPARAMS struct with info about the given drive. */
/* Calls DOS IOCTL Get Device Parameters (440Dh, 60h) function. */
/* */
/* Parameters */
/*   nDrive   Drive number  0 = A, 1 = B, 2 = C, and so on. */
/*   dp       Pointer to a structure that will contain the drive's */
/*            parameters. */
/* */
/* Returns TRUE if it succeeded, FALSE if it failed. */
/*----------------------------------------------------------------- */
#pragma warning(disable:4704)	/* in-line asm precludes global optimizations  */
BOOL GetDeviceParameters (int nDrive, LPDEVICEPARAMS dp)
   {
   BOOL bResult = TRUE;      /* Assume success */
   __asm {
         push ds
         mov  bx, nDrive
         inc  bx           /* Convert 0-based #'s to 1-based #s */
         mov  ch, 08h      /* Device category--must be 08h */
         mov  cl, 60h      /* MS-DOS IOCTL Get Device Parameters */
         lds  dx, dp
         mov  ax, 440Dh
         int  21h
         jnc  gdp_done     /* CF SET if error */
         mov  bResult, FALSE
      gdp_done:
         pop  ds
         }
   return (bResult);
   }
#pragma warning(default:4704)	/* in-line asm precludes global optimizations  */

/*----------------------------------------------------------------- */
/* IsCDRomDrive() */
/* */
/* Determines if a drive is a CD-ROM. Calls MSCDEX and checks */
/* that MSCDEX is loaded, and that MSCDEX reports the drive is a */
/* CD-ROM. */
/* */
/* Parameters */
/*    nDrive    Drive number  0 = A, 1 = B, 2 = C, and so forth. */
/* */
/* Returns TRUE if nDrive is a CD-ROM drive, FALSE if it isn't. */
/*----------------------------------------------------------------- */
#pragma warning(disable:4704)	/* in-line asm precludes global optimizations  */
BOOL IsCDRomDrive (int nDrive)
   {
   BOOL bResult = FALSE;      /* Assume not a CD-ROM drive */
   __asm {
         mov  ax, 150Bh       /* MSCDEX CD-ROM Drive Check */
         xor  bx, bx
         mov  cx, nDrive
         int  2Fh
         cmp  bx, 0ADADh      /* Check MSCDEX signature */
         jne  not_cd_drive
         or   ax, ax          /* Check the drive type */
         jz   not_cd_drive    /* 0 (zero) means not CD-ROM */
         mov  bResult, TRUE
      not_cd_drive:
         }
   return (bResult);
   }
#pragma warning(default:4704)	/* in-line asm precludes global optimizations  */
#endif

/*----------------------------------------------------------------- */
/* GetDriveTypeEx() */
/* */
/* Determines the type of a drive. Calls Windows's GetDriveType */
/* to determine if a drive is valid, fixed, remote, or removeable, */
/* then breaks down these categories further to specific device */
/* types. */
/* */
/* Parameters */
/*    nDrive    Drive number  0 = A, 1 = B, 2 = C, etc. */
/* */
/* Returns one of: */
/*    EX_DRIVE_INVALID         -- Drive not detected */
/*    EX_DRIVE_REMOVABLE       -- Unknown removable-media type drive */
/*    EX_DRIVE_FIXED           -- Hard disk drive */
/*    EX_DRIVE_REMOTE          -- Remote drive on a network */
/*    EX_DRIVE_CDROM           -- CD-ROM drive */
/*    EX_DRIVE_FLOPPY          -- Floppy disk drive */
/*    EX_DRIVE_RAMDISK         -- RAM disk */
/*----------------------------------------------------------------- */
UINT GetDriveTypeEx (int nDrive)
   {
#if 0
   DEVICEPARAMS dp;
   UINT uType;
   _fmemset (&dp, 0, sizeof(dp));    /* Init device params struct */
   uType = GetDriveType (nDrive);
   switch (uType)
      {
      case DRIVE_REMOTE:
            /* GetDriveType() reports CD-ROMs as Remote drives. Need */
            /* to see if the drive is a CD-ROM or a network drive. */
         if (IsCDRomDrive (nDrive))
            return (EX_DRIVE_CDROM);
         else
            return (EX_DRIVE_REMOTE);
         break;
      case DRIVE_REMOVABLE:
            /* Check for a floppy disk drive. If it isn't, then we */
            /* don't know what kind of removable media it is. */
            /* For example, could be a Bernoulli box or something new... */
         if (GetDeviceParameters (nDrive, &dp))
            switch (dp.bDevType)
               {
                  /* Floppy disk drive types */
               case 0x0: case 0x1: case 0x2: case 0x3:
               case 0x4: case 0x7: case 0x8:
                  return (EX_DRIVE_FLOPPY);
               }
         return (EX_DRIVE_REMOVABLE);  /* Unknown removable media type */
         break;
      case DRIVE_FIXED:
            /* GetDeviceParameters returns a device type of 0x05 for */
            /* hard disks. Because hard disks and RAM disks are the two */
            /* types of fixed-media drives, we assume that any fixed- */
            /* media drive that isn't a hard disk is a RAM disk. */
         if (GetDeviceParameters (nDrive, &dp) && dp.bDevType == 0x05)
            return (EX_DRIVE_FIXED);
         else
            return (EX_DRIVE_RAMDISK);
         break;
#endif
   UINT uType;
   CHAR achRoot[4];

   achRoot[0] = 'A'+nDrive;
   achRoot[1] = ':';
   achRoot[2] = '\\';
   achRoot[3] = 0;
   uType = GetDriveTypeA (achRoot);
   switch (uType)
      {
      case DRIVE_REMOVABLE:
         return (EX_DRIVE_REMOVABLE);  /* Unknown removable media type */
      case DRIVE_FIXED:
         return (EX_DRIVE_FIXED);
      case DRIVE_REMOTE:
         return (EX_DRIVE_REMOTE);
      case DRIVE_CDROM:
         return (EX_DRIVE_CDROM);
      case DRIVE_RAMDISK:
         return (EX_DRIVE_RAMDISK);
      }
   return (EX_DRIVE_INVALID);   /* Drive is invalid if we get here. */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\boot\virwinn.c ===
#include <windows.h>
#include "stdtypes.h"
/*
**  VIRWINN.C
**
**  This is an attempt at virus detection.  The routine FVirCheck
**  should be called sometime during the boot process, and takes
**  one argument, a handle to the application instance.  The
**  ComplainAndQuit() call should be replaced with code appropriate
**  to your application.  It is recommended that this bring up
**  a dialog with an error message, and give the user the option of
**  continuing (defaults to terminating).  If the user chooses to
**  terminate (or if the option is not given), ComplainAndQuit()
**  should clean up anything that has been done so far, and exit.
*/
/*  WARNING!! Do not change WHashGood at all!!
**  WARNING!! WHashGood must be a near procedure, compiled native.
*/

/*
**  EXE header format definitions.  Lifted from linker.
*/

#define EMAGIC      0x5A4D  /* Old magic number */
#define ERES2WDS    0x000A  /* No. of reserved words in e_res2 */

struct exe_hdr  /* DOS 1, 2, 3 .EXE header */
    {
    unsigned short e_magic; /* Magic number */
    unsigned short e_cblp;  /* Bytes on last page of file */
    unsigned short e_cp;    /* Pages in file */
    unsigned short e_crlc;  /* Relocations */
    unsigned short e_cparhdr;   /* Size of header in paragraphs */
    unsigned short e_minalloc;  /* Minimum extra paragraphs needed */
    unsigned short e_maxalloc;  /* Maximum extra paragraphs needed */
    unsigned short e_ss;    /* Initial (relative) SS value */
    unsigned short e_sp;    /* Initial SP value */
    unsigned short e_csum;  /* Checksum */
    unsigned short e_ip;    /* Initial IP value */
    unsigned short e_cs;    /* Initial (relative) CS value */
    unsigned short e_lfarlc;    /* File address of relocation table */
    unsigned short e_ovno;  /* Overlay number */
    unsigned long e_sym_tab;    /* offset of symbol table file */
    unsigned short e_flags; /* old exe header flags  */
    unsigned short e_res;   /* Reserved words */
    unsigned short e_oemid; /* OEM identifier (for e_oeminfo) */
    unsigned short e_oeminfo;   /* OEM information; e_oemid specific */
    unsigned short e_res2[ERES2WDS];    /* Reserved words */
    long e_lfanew;  /* File address of new exe header */
    };

/*
** NEW EXE format definitions.  Lifted from linker
*/

#define NEMAGIC 0x454E  /* New magic number */
#define NERESBYTES  8   /* Eight bytes reserved (now) */
#define NECRC       8   /* Offset into new header of NE_CRC */

struct new_exe  /* New .EXE header */
    {
    unsigned short  ne_magic;   /* Magic number NE_MAGIC */
    unsigned char   ne_ver; /* Version number */
    unsigned char   ne_rev; /* Revision number */
    unsigned short  ne_enttab;  /* Offset of Entry Table */
    unsigned short  ne_cbenttab;    /* Number of bytes in Entry Table */
    long        ne_crc; /* Checksum of whole file */
    unsigned short  ne_flags;   /* Flag word */
    unsigned short  ne_autodata;    /* Automatic data segment number */
    unsigned short  ne_heap;    /* Initial heap allocation */
    unsigned short  ne_stack;   /* Initial stack allocation */
    long        ne_csip;    /* Initial CS:IP setting */
    long        ne_sssp;    /* Initial SS:SP setting */
    unsigned short  ne_cseg;    /* Count of file segments */
    unsigned short  ne_cmod;    /* Entries in Module Reference Table */
    unsigned short  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short  ne_segtab;  /* Offset of Segment Table */
    unsigned short  ne_rsrctab; /* Offset of Resource Table */
    unsigned short  ne_restab;  /* Offset of resident name table */
    unsigned short  ne_modtab;  /* Offset of Module Reference Table */
    unsigned short  ne_imptab;  /* Offset of Imported Names Table */
    long        ne_nrestab; /* Offset of Non-resident Names Table */
    unsigned short  ne_cmovent; /* Count of movable entries */
    unsigned short  ne_align;   /* Segment alignment shift count */
    unsigned short  ne_cres;    /* Count of resource entries */
    unsigned char   ne_exetyp;  /* Target operating system */
    unsigned char   ne_flagsothers; /* Other .EXE flags */
    char        ne_res[NERESBYTES];
    /* Pad structure to 64 bytes */
    };

/*
**  WHashGood()
**
**  This returns the correct hash value.
**
**  WARNING!! This routine must not be altered in ANY way.  It gets
**  patched and/or rewritten by VIRPATCH!!
*/

unsigned near WHashGood ( void );
unsigned near WHashGood ()
{
    return (0x1234);
}

/*
**  WHash(wHash, rgb, cb)
**
**  Update hash value to account for cb new bytes pointed to by rgb.
**  Old hash value is wHash; returns new hash value.
**
**  We do the hash on a word basis; the hash function is a simple
**  rotate and add.
*/

unsigned WHash ( unsigned wHash, BYTE rgb[], int cb );
unsigned WHash ( unsigned wHash, BYTE rgb[], int cb )
{
    while (cb > 1)
        {
#pragma warning(disable:4213)   /* nonstandard extension : cast on l-value */
        wHash = (wHash << 3) + (wHash >> 13) + *((int *)rgb)++;
#pragma warning(default:4213)
        cb -= 2;
        }
    if (cb != 0)
        wHash = (wHash << 3) + (wHash >> 13) + *rgb;
    return (wHash);
}

/*
**  FVirCheck(hinst)
**
**  This is the main virus detection routine.  It should be called
**  during boot, with a handle to the application instance.
**  The detection method used is to hash the EXE headers; this
**  hash value will change if the number or type of segments change,
**  or if their length changes.
*/

BOOL FVirCheck ( HANDLE hinst );
BOOL FVirCheck ( HANDLE hinst )
{
    int fh;
    unsigned wHash;
    unsigned cb, cbT;
    long lPos;
    char sz[256];
    BYTE rgb[512];
#define pehdr ((struct exe_hdr *)rgb)
#define pnex ((struct new_exe *)rgb)

    /* First we have to get a handle to the executable file.
       Unfortunately, although Windows already has this file open,
       there's no way to use its handle.  Instead we have to reopen
       the file. */

    if (GetModuleFileName(hinst, (char far *)sz, 256) == 0)
        return TRUE; //This shouldn't happen but still continue loading

    if ((fh = OpenFile((LPSTR)sz, (LPOFSTRUCT)rgb, OF_READ)) == -1)
        {
        /* We can't open the file.  This should never happen; if
           it does, it means we're in a weird state, and probably
           did something wrong in this code.  We'll just say
           everything is OK, and continue the boot. */
        return TRUE;
        }
    /* Read old header */
    if (_lread(fh, (LPSTR)rgb, sizeof (struct exe_hdr)) != sizeof (struct
        exe_hdr) ||
        pehdr->e_magic != EMAGIC)
        goto Corrupted;
    /* Hash old header */
    wHash = WHash(0, rgb, sizeof (struct exe_hdr));
    lPos = pehdr->e_lfanew;
    /* Read new header (and some more) */
    if (lPos == 0 || _llseek(fh, lPos, 0) != lPos ||
        _lread(fh, (LPSTR)rgb, 512) != 512 || pnex->ne_magic != NEMAGIC)
        goto Corrupted;
    /* Figure out size of total header; nonresident table is last part
       of header. */
    cb = (unsigned)(pnex->ne_nrestab - lPos) + pnex->ne_cbnrestab;
    /* Do hash on buffer basis */
    while (cb > 512)
        {
        /* Hash this buffer */
        wHash = WHash(wHash, rgb, 512);
        cb -= 512;
        cbT = (cb > 512 ? 512 : cb);
        /* and read in next */
        if (_lread(fh, (LPSTR)rgb, cbT) != cbT)
            goto Corrupted;
        }
    /* Update hash for final partial buffer, and compare with good value. */
    if (WHash(wHash, rgb, cb) != WHashGood())
        {
Corrupted:
        /* We've got an error reading the file or, more likely,
           a hash mismatch.  Close the file, give an error, and
           quit. */
        _lclose(fh);
        /* CHANGE THE FOLLOWING LINE TO CODE APPROPRIATE TO YOUR
        ** APPLICATION!!
        ** This should be replaced with code giving an error message (such as
        ** "Application file is corrupted").  It is recommended that this
        ** bring up
        ** a dialog with an error message, and give the user the option of
        ** continuing (defaults to terminating).  If the user chooses to
        ** terminate (or if the option is not given), ComplainAndQuit()
        ** should clean up anything that has been done so far, and exit.
        */

        /*  MessageBox(NULL, "Executable File Corrupted", 
        *                   "WARNING", MB_ICONSTOP | MB_OK);
        */

        /* ComplainAndQuit();
        */
        /* END OF CHANGE */
        return FALSE;
        }
    /* Everything's OK. Just close the file, and continue. */
    _lclose(fh);
    return TRUE;
#undef pehdr
#undef pnex
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\boot\genthk.h ===
/***************************************************************************
**
**	File:		genthk.h
**	Purpose:	Prototypes for Generic Thunk API's.
**	Notes:
**		These API's (exported from the NT Kernel) allow 16-bit
**		apps to call 32-bit DLL's when running under Windows NT WOW
**		(Windows on Windows).  This interface is called 'Generic
**		Thunking,' not to be confused with Win32s Universal Thunks,
**		which provides this functionality under Window 3.1.
**
****************************************************************************/

#ifndef GENTHK_H
#define GENTHK_H


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif


DWORD FAR PASCAL LoadLibraryEx32W ( LPCSTR, DWORD, DWORD );
DWORD FAR PASCAL GetProcAddress32W ( DWORD, LPCSTR );
DWORD FAR PASCAL GetVDMPointer32W ( LPVOID, UINT );
BOOL  FAR PASCAL FreeLibrary32W ( DWORD );

/* NOTE: CallProc32W can take a variable number of
*	parameters.  The prototype below is for calling
*	a Win32 API which takes no arguments.
*/
DWORD FAR PASCAL CallProc32W ( LPVOID, DWORD, DWORD );


typedef DWORD (FAR PASCAL * PFNGETVERSION32) ();
#define CallGetVersion32(hProc)	\
	((*((PFNGETVERSION32) hProc)) ())
	

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif

#endif  /* GENTHK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\boot\setup.h ===
typedef USHORT         BRC;   /* Bootstrapper Return Code */

/* order is important:
*/
#define brcGen       0
#define brcVir       1
#define brcInst      2
#define brcFile      3
#define brcMemDS     4
#define brcLst       5
#define brcMem       6
#define brcDS        7
#define brcMemDSHlp  8	/* Note: second half of brcMemDS message. */
#define brcInsDisk	 9
#define brcInsDisk2	 10
#define brcNoCpuSect 11
#define brcNoSpill   12
#define brcRegDb     13
#define brcOkay      14
#define brcInsCDRom2 15
#define brcUserQuit  16
#define brcString	 17
#define brcConnectToSource	18
#define brcConnectHlp	19
#define brcNoStf     20
#define brcMax       21

#define IDS_InsufMem	(brcMax + 1)	/* NOTE: brc's are also string id's! */
#define IDS_InitErr		(brcMax + 2)
#define IDS_Setup		(brcMax + 3)


/* REVIEW: What is the "right" size for full path?
**	(GetWindowsDirectory() says it needs 144 bytes).
*/
#define cchFullPathMax  160

extern int DispErrBrc ( BRC brc, BOOL fError, UINT fuStyle,
					const char *sz1, const char *sz2,
					const char *sz3 );

extern  BRC  BrcHandleCabinetFiles ( HWND hWnd, char * szCabinet,
					int cFirstCabinetNum, int cNumOfCabinets, char * szSrcDir,
					char * szDstDir, char * szSrcs, char * szDsts,
					char * szSrcBuf, char * szDstBuf );

extern void FYield ( VOID );

extern HANDLE hinstBoot;

#ifdef DEBUG
  #define DebugMsg(sz)  MessageBox(NULL, (sz), "Bootstrapper Debug Msg", MB_OK)
#else
  #define DebugMsg(sz)
#endif

#ifdef DEBUG
#ifdef DMND2_C
/* For Assertion and Debug error message display */
char szDebugMsg[24] = "Debug Setup Message";
char szDebugBuf[512];
#else
extern char szDebugMsg[24];
extern char szDebugBuf[512];
#endif /* DMND2_C */
#define Assert(exp)\
		{\
		if (!(exp))\
			{\
			wsprintf(szDebugBuf, "File %s, Line %d",\
					(LPSTR)__FILE__, __LINE__);\
			MessageBox(NULL, szDebugBuf, "Assertion Error",\
					MB_OK | MB_ICONSTOP);\
			}\
		}
#else	/* !DEBUG */
#define Assert(exp)
#endif  /* !DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\boot\setup.c ===
#include <windows.h>
#if 0
#include <stdtypes.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <direct.h>
#include <dos.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <ctype.h>      /* isspace */
#include <io.h>
#include <limits.h>     /* UINT_MAX */
#include <memory.h>     /* _fmemcpy, _fmemccpy */
#include <lzexpand.h>
#include <shellapi.h>   /* HKEY, HKEY_CLASSES_ROOT, ERROR_SUCCESS */
#include "setup.h"
#include "genthk.h"     /* thunks for calls to get 32-bit version */
#include "driveex.h"
#include <stdtypes.h>

/* Messages for optional background task.
*/
#define IDM_ACME_STARTING 261
#define IDM_ACME_COMPLETE 262
#define IDM_ACME_FAILURE  263

#ifdef APPCOMP
#include <decomp.h>
#endif /* APPCOMP */
#include <fdi.h>


/* List file extension */
char szLstExt[] = "LST";


/* List file section names */
char szDefaultParamsSect[] = "Params";
char szDefaultFilesSect[]  = "Files";

char szWin3xParamsSect[]   = "Win3.x Params";
char szWin3xFilesSect[]    = "Win3.x Files";

char szWin95ParamsSect[]   = "Windows 95 Params";
char szWin95FilesSect[]    = "Windows 95 Files";

char szNTAlphaParamsSect[] = "NT Alpha Params";
char szNTAlphaFilesSect[]  = "NT Alpha Files";

char szNTMipsParamsSect[]  = "NT Mips Params";
char szNTMipsFilesSect[]   = "NT Mips Files";

char szNTPpcParamsSect[]   = "NT PPC Params";
char szNTPpcFilesSect[]    = "NT PPC Files";

char szNTIntelParamsSect[] = "NT Intel Params";
char szNTIntelFilesSect[]  = "NT Intel Files";

char szNTVerIntelParamsSect[] = "NT3.51 Intel Params";
char szNTVerIntelFilesSect[]  = "NT3.51 Intel Files";

char * szParamsSect = szNull;
char * szFilesSect  = szNull;

typedef struct _PLATFORM_SPEC
{
    BYTE minMajorVersion;
    BYTE minMinorVersion;
    char *szParamsSect;
    char *szFilesSect;
} PLATFORM_SPEC, *PPLATFORM_SPEC;

PLATFORM_SPEC aIntelSpec[] =
{
    {3, 51, szNTVerIntelParamsSect, szNTVerIntelFilesSect},
    {0,  0, szNTIntelParamsSect,    szNTIntelFilesSect},
    {0,  0, NULL,           NULL}
};

PLATFORM_SPEC aAlphaSpec[] =
{
    {0,  0, szNTAlphaParamsSect,    szNTAlphaFilesSect},
    {3, 51, szNTVerIntelParamsSect, szNTVerIntelFilesSect},
    {0,  0, szNTIntelParamsSect,    szNTIntelFilesSect},
    {0,  0, NULL,           NULL}
};

PLATFORM_SPEC aMipsSpec[] =
{
    {0,  0, szNTMipsParamsSect,     szNTMipsFilesSect},
    {0,  0, NULL,           NULL}
};

PLATFORM_SPEC aPpcSpec[] =
{
    {0,  0, szNTPpcParamsSect,      szNTPpcFilesSect},
    {0,  0, NULL,           NULL}
};


PLATFORM_SPEC aEmptySpec[] =
{
    {0,  0, NULL,           NULL}
};

// Note: this is indexed by PROCESSOR_ARCHITECTURE_xxx
//       definitions in ntexapi.h
//
// Note: may want to add extra sections for IA64 and AXP64
PPLATFORM_SPEC aaPlatformSpecs[] =
{
    aIntelSpec,     // PROCESSOR_ARCHITECTURE_INTEL 0
    aMipsSpec,      // PROCESSOR_ARCHITECTURE_MIPS  1
    aAlphaSpec,     // PROCESSOR_ARCHITECTURE_ALPHA 2
    aPpcSpec,       // PROCESSOR_ARCHITECTURE_PPC   3
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_SHX   4
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_ARM   5
    aIntelSpec,     // PROCESSOR_ARCHITECTURE_IA64  6
    aAlphaSpec,     // PROCESSOR_ARCHITECTURE_ALPHA64 7
};


/* CPU environment variable and values */
/*  (NOTE: These must be upper case)   */
char szCpuEnvVarName[]     = "PROCESSOR_ARCHITECTURE";
char szIntelEnvVarVal[]    = "X86";
char szIA64EnvVarVal[]     = "IA64";
char szAlphaEnvVarVal[]    = "ALPHA";
char szAXP64EnvVarVal[]    = "AXP64";
char szMipsEnvVarVal[]     = "MIPS";
char szPpcEnvVarVal[]      = "PPC";


/* Bootstrapper class name */
char szBootClass[]  = "STUFF-BOOT";

/* String buffer sizes */
#define cchLstLineMax       128
#define cchWinExecLineMax   (256 + cchFullPathMax)

/* No. of retries to attempt when removing files or dirs,
*   or when executing a chmod.
*/
#define cRetryMax   1200

/* SetErrorMode flags */
#define fNoErrMes 1
#define fErrMes   0

/* Quiet Mode -- Note: EEL must be kept in sync with acmsetup.h */
typedef UINT EEL;       /* Exit Error Level */
#define eelSuccess            ((EEL)0x0000)
#define eelBootstrapperFailed ((EEL)0x0009) /* Used only in Bootstrapper! */

EEL  eelExitErrorLevel = eelBootstrapperFailed;
BOOL fQuietMode        = fFalse;
BOOL fExeced           = fFalse;
BOOL fWin31            = fFalse;

/* Forward Declarations */
VOID    CleanUpTempDir ( char *, char * );
BRC     BrcInstallFiles ( char *, char *, char * );
BOOL    FCreateTempDir ( char *, char * );
BRC     BrcCopyFiles ( char *, char *, char * );
VOID    RemoveFiles ( char * );
BRC     BrcCopy ( char *, char * );
LONG    LcbFreeDrive ( int );
BOOL    FVirCheck ( HANDLE );
HWND    HwndInitBootWnd ( HANDLE );
LRESULT CALLBACK BootWndProc ( HWND, UINT, WPARAM, LPARAM );
BOOL    FGetFileSize ( char *, UINT * );
BRC     BrcBuildFileLists ( char *, UINT );
VOID    FreeFileLists ( VOID );
BOOL    FExecAndWait ( char *, HWND );
BOOL    FWriteBatFile ( OFSTRUCT, char *, char * );
BOOL    FLstSectionExists ( char * szLstFileName, char * szSect );
DWORD   GetCpuArchitecture();
BOOL    FNotifyAcme ( VOID );
BOOL    FGetAcmeErrorLevel ( EEL * peel );
BOOL    FCreateRegKey      ( CSZC cszcKey );
BOOL    FDoesRegKeyExist   ( CSZC cszcKey );
BOOL    FCreateRegKeyValue ( CSZC cszcKey, CSZC cszcValue );
BOOL    FGetRegKeyValue    ( CSZC cszcKey, SZ szBuf, CB cbBufMax );
VOID    DeleteRegKey       ( CSZC cszcKey );
BOOL    FFlushRegKey ( VOID );
BOOL    FWriteToRestartFile ( SZ szTmpDir );
BOOL    FCreateIniFileName ( SZ szIniFile, CB cbBufMax );
BOOL    FReadIniFile ( SZ szIniFile, HLOCAL * phlocal, PCB pcbBuf );
BOOL    FAllocNewBuf ( CB cbOld, SZ szTmpDir, SZ szSection, SZ szKey,
                        HLOCAL * phlocal, PCB pcbToBuf );
BOOL    FProcessFile ( HLOCAL hlocalFrom, HLOCAL hlocalTo, CB cbToBuf,
                        SZ szTmpDir, SZ szSection, SZ szKey );
VOID    CopyIniLine ( SZ szKey, SZ szTmpDir, SZ szFile, PSZ pszToBuf );
BOOL    FWriteIniFile ( SZ szIniFile, HLOCAL hlocalTo );
BRC     BrcInsertDisk(CHAR *pchStf, CHAR *pchSrcDrive);
BOOL    FRenameBadMaintStf ( SZ szStf );


/* Bootstrapper list file params */
char    rgchSetupDirName[cchLstLineMax];
#ifdef UNUSED   /* Replaced by DrvWinClass */
char    rgchDrvModName[cchLstLineMax];
#endif  /* UNUSED */
char    rgchDrvWinClass[cchLstLineMax];
char    rgchCmdLine[cchLstLineMax];
char    rgchBootTitle[cchLstLineMax];
char    rgchBootMess[cchLstLineMax];
char    rgchWin31Mess[cchLstLineMax];
char    rgchCabinetFName[cchLstLineMax];
char    rgchBackgroundFName[cchLstLineMax];
char    rgchBkgWinClass[cchLstLineMax];
char    rgchInsertCDMsg[cchLstLineMax];
char    rgchInsertDiskMsg[cchLstLineMax];
LONG    lcbDiskFreeMin;
int     cFirstCabinetNum;
int     cLastCabinetNum;
HANDLE  hSrcLst = NULL;
HANDLE  hDstLst = NULL;
char    rgchErrorFile[cchFullPathMax];
HANDLE  hinstBoot = NULL;
HWND    hwndBoot = NULL;


CHAR rgchInsufMem[cchSzMax] = "";
CHAR rgchInitErr[cchSzMax]  = "";
CHAR rgchSetup[cchSzMax]    = "";


/*
**  'Fixup' temp dir string by removing any subdirs and ensuring
**  extension is only one character.  (Note - Win3.0 has bug with
**  WinExec'ing some EXEs from a full 8.3 directory!)
**************************************************************************/
void FixupTempDirName( LPSTR szDir )
{
    LPSTR   szNext;
    int     cch = 0;

    if (*szDir == '\\'
        || *(AnsiNext(szDir)) == ':')
        {
        lstrcpy(szDir, "~msstfqf.t");
        return;
        }

    while (*szDir != '\\'
        && *szDir != '.'
        && *szDir != '\0'
        && *szDir != ':'
        && cch++ < 8)
        {
        szDir = AnsiNext(szDir);
        }

    szNext = AnsiNext(szDir);
    if (*szDir == '.'
        && *szNext != '.'
        && *szNext != '\\'
        && *szNext != '\0'
        && *szNext != ':')
        {
        *(AnsiNext(szNext)) = '\0';
        return;
        }

    *szDir = '\0';
    lstrcat(szDir, ".t");
}


/* Displays bootstrapper messages.
 * If fError is true, it's an error message, otherwise it's
 * just a message (e.g. insert disk 1).
**************************************************************************/
int DispErrBrc ( BRC brc, BOOL fError, UINT fuStyle,
                    const char *sz1, const char *sz2,
                    const char *sz3 )
{
    char rgchTitle[256];
    char rgchMessage[256];
    char szBuf[256 + cchFullPathMax + 256];

#ifndef DEBUG
    if (fQuietMode)
        {
        return (IDCANCEL);
        }
#endif

    if (LoadString(hinstBoot, brcGen, rgchTitle, 256) == 0
        || LoadString(hinstBoot, brc, rgchMessage, 256) == 0)
        {
        MessageBox(hwndBoot, rgchInsufMem, rgchInitErr, MB_OK | MB_ICONSTOP);
        return 0;
        }
    
    if (!fError)
        lstrcpy(rgchTitle, rgchSetup);

    if (sz1 == NULL) sz1 = "";
    if (sz2 == NULL) sz2 = "";
    if (sz3 == NULL) sz3 = "";

    if (brc == brcFile)
        wsprintf(szBuf, rgchMessage, (LPSTR)AnsiUpper(rgchErrorFile));
    else if (brc == brcDS || brc == brcMemDS)
        wsprintf(szBuf, rgchMessage, lcbDiskFreeMin / 1024L);
    else
        wsprintf(szBuf, rgchMessage, sz1, sz2, sz3);

    if ((brc == brcMemDS || brc == brcNoSpill)
        && LoadString(hinstBoot, brcMemDSHlp, rgchMessage, 256))
        {
        lstrcat(szBuf, rgchMessage);
        }
    else if (brc == brcConnectToSource
        && LoadString(hinstBoot, brcConnectHlp, rgchMessage, 256))
        {
        lstrcat(szBuf, rgchMessage);
        }

    return (MessageBox(hwndBoot, szBuf, rgchTitle, fuStyle));
}


/*
**  Purpose:
**      Installs Setup executable in a temporary directory on an
**      available hardrive, and launches Setup.  After Setup
**      completes, removes the temporary files and directory.
**  Arguments:
**      Standard Windows WinMain args.
**  Returns:
**      Returns eelExitErrorLevel.  0 == Success.
**************************************************************************/
int WINAPI WinMain ( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpszCmdParam, int nCmdShow )
{
    char    chDrive;
    char    rgchDstDir[cchFullPathMax] = " :\\";   // WARN: kept as OEM chars
    char    * szDstDirSlash = szNull;
    char    rgchModuleFileName[cchFullPathMax]; // WARN: kept as ANSI chars
    char    rgchLstFileName[cchFullPathMax];
    char    rgchTemp[cchFullPathMax];
    char    rgchSrcDir[cchFullPathMax];   
    UINT    cbLstSize;
    char    rgchWinExecLine[cchWinExecLineMax];
    UINT    uiRes;
    int     iModLen;
    BRC     brc;
    BOOL    fCleanupTemp = FALSE;
    LPSTR   sz;
    HWND    hWndBkg = 0;  /* window of background task */
    UINT    hMod;

    Unused(nCmdShow);
    hinstBoot = hInstance;

    rgchErrorFile[0] = '\0';
    
    if (LoadString(hinstBoot, IDS_InsufMem, rgchInsufMem,
            sizeof rgchInsufMem) == 0
        || LoadString(hinstBoot, IDS_InitErr, rgchInitErr,
            sizeof rgchInitErr) == 0
        || LoadString(hinstBoot, IDS_Setup, rgchSetup,
            sizeof rgchSetup) == 0)
        {
        /* REVIEW: If these LoadStrngs fail, the user will never know...
        *   But we can't hard-code strings in an .h file because INTL
        *   requires all localizable strings to be in resources!
        */
#ifdef DEBUG
        MessageBox(NULL, "Initial LoadString's failed; probably out of memory.",
                    szDebugMsg, MB_OK | MB_ICONEXCLAMATION);

#endif /* DEBUG */
        }
                                           
    for (sz = lpszCmdParam; *sz != '\0'; sz = AnsiNext(sz))
        {
        if ((*sz == '-' ||  *sz == '/')
                && toupper(*(sz+1)) == 'Q' && toupper(*(sz+2)) == 'T')
            {
            fQuietMode = fTrue;
            break;
            }
        }

/*
 * REVIEW: Check that this code is still functional before restoring it.
 */
#if VIRCHECK
    if (!FVirCheck(hInstance))
        {
        DispErrBrc(brcVir, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }
#endif

    if (hPrevInstance || FindWindow(szBootClass, NULL) != NULL)
        {
        DispErrBrc(brcInst, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }

    GetModuleFileName(hInstance, rgchModuleFileName, cchFullPathMax);

    /*
     * If the first switch on the command line is /M, then it specifies
     * the real module name to use.
     */
    if ((lpszCmdParam[0] == '-' || lpszCmdParam[0] == '/')
            && toupper(lpszCmdParam[1]) == 'M')
        {
        char *pCh, *pCh2;
        BOOL fQuotedFileName;
        
        /* Skip the spaces */
        for (pCh = lpszCmdParam+2; *pCh == ' '; pCh++);
        fQuotedFileName = (*pCh == '\"');
        if (fQuotedFileName)
            {
            pCh++;
            }
        
        /* Copy the file name, and add the EOS */
        lstrcpy(rgchModuleFileName, pCh);
        for (pCh2=rgchModuleFileName; 
            (*pCh2 != ' ' || fQuotedFileName) && 
            (*pCh2 != '\"' || !fQuotedFileName) && 
             *pCh2 != '\0'; 
            pCh2++);
        *pCh2 = '\0';
        
        /* Remove the /M param from the command line */
        lpszCmdParam = pCh + lstrlen(rgchModuleFileName);
        if (fQuotedFileName && *lpszCmdParam == '\"')
            {
            lpszCmdParam++;
            }

        /* Remove trailing whitespace from the command line */
        for (pCh = lpszCmdParam; *pCh == ' '; pCh++);
        lpszCmdParam = pCh;
        }


    OemToAnsi(rgchModuleFileName, rgchModuleFileName);

    // Windows 3.0 bug with UNC paths - prepends windows drive letter
    sz = (LPSTR)rgchModuleFileName;
    if (*sz != '\0'
        && *sz != '\\'
        && *(sz = AnsiNext(sz)) == ':'
        && *(sz = AnsiNext(sz)) == '\\'
        && *AnsiNext(sz) == '\\')
        {
        LPSTR szDst = (LPSTR)rgchModuleFileName;

        while ((*szDst++ = *sz++) != '\0')
            ;
        }

    iModLen = lstrlen(rgchModuleFileName);
    lstrcpy(rgchSrcDir, rgchModuleFileName);
    sz = (LPSTR)&rgchSrcDir[iModLen];
    while (sz > (LPSTR)rgchSrcDir && *sz != '\\')
        sz = AnsiPrev(rgchSrcDir, sz);
    Assert(sz > (LPSTR)rgchSrcDir);
    *(AnsiNext(sz)) = '\0';               

    /*
     * If the first switch on the command line is /L, then it specifies
     * the name of the .lst file to use.
     */
    rgchTemp[0] = '\0';
    if ((lpszCmdParam[0] == '-' || lpszCmdParam[0] == '/')
            && toupper(lpszCmdParam[1]) == 'L')
        {
        char *pCh, *pCh2;
        
        /* Skip the spaces */
        for (pCh = lpszCmdParam+2; *pCh == ' ' && *pCh != '\0'; pCh++);
        
        /* Copy the .lst file name, and add the newline */
        lstrcpy(rgchTemp, pCh);
        for (pCh2=rgchTemp; *pCh2 != ' ' && *pCh2!= '\0'; pCh2++);
        *pCh2 = '\0';
        
        /* Remove the /L param from the command line */
        lpszCmdParam = pCh + lstrlen(rgchTemp);
        for (pCh = lpszCmdParam; *pCh == ' ' && *pCh != '\0'; pCh++);
        lpszCmdParam = pCh;
        }


    /* If there is something on the command line, use it as the .lst file */
    if (*rgchTemp != '\0')
        {
        lstrcpy(rgchLstFileName, rgchSrcDir);
        lstrcat(rgchLstFileName, rgchTemp);
        }
    else
        {
        lstrcpy(rgchLstFileName, rgchModuleFileName);
        sz = (LPSTR)&rgchLstFileName[iModLen];
        while (sz > (LPSTR)rgchLstFileName && *sz != '.')
            sz = AnsiPrev(rgchLstFileName, sz);
        Assert(sz > (LPSTR)rgchLstFileName);
        *(AnsiNext(sz)) = '\0';
        lstrcat(rgchLstFileName, szLstExt);
        }

    if (!FGetFileSize(rgchLstFileName, &cbLstSize) || cbLstSize == 0)
        {
        lstrcpy(rgchErrorFile, rgchLstFileName);
        DispErrBrc(brcFile, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }

#ifndef WF_WINNT
#define WF_WINNT 0x4000
#endif

    /* Attempt to use appropriate platform.
    */
    szParamsSect = szNull;
    szFilesSect  = szNull;

    if (1)
        {
        DWORD dwVers = 0;
        DWORD dwCpuArchitecture;
        DWORD dwMajorVersion;
        DWORD dwMinorVersion;
        PPLATFORM_SPEC pPlatformSpec;

        dwCpuArchitecture = GetCpuArchitecture();

        dwVers = GetVersion();
        dwMajorVersion = LOBYTE(LOWORD(dwVers));
        dwMinorVersion = HIBYTE(LOWORD(dwVers));

        if (dwCpuArchitecture < (sizeof (aaPlatformSpecs) / sizeof(aaPlatformSpecs[0])))
            {
            pPlatformSpec = aaPlatformSpecs[dwCpuArchitecture];
            } 
        else 
            {
            pPlatformSpec = aEmptySpec;
            }

        for (; pPlatformSpec->szParamsSect != NULL; pPlatformSpec++)
            {
            if (((pPlatformSpec->minMajorVersion < dwMajorVersion) || 
                 (pPlatformSpec->minMajorVersion == dwMajorVersion && pPlatformSpec->minMinorVersion <= dwMinorVersion)) &&
                FLstSectionExists(rgchLstFileName, pPlatformSpec->szParamsSect))
                {
                szParamsSect = pPlatformSpec->szParamsSect;
                szFilesSect  = pPlatformSpec->szFilesSect;
                break;
                }
            }
        }
    else    /* non-WinNT */
        {
        if (FLstSectionExists(rgchLstFileName, szWin95ParamsSect)
            && (LOBYTE(LOWORD(GetVersion())) > 3
                || HIBYTE(LOWORD(GetVersion())) >= 95))
            {
            szParamsSect = szWin95ParamsSect;
            szFilesSect  = szWin95FilesSect;
            }
        else
            {
            fWin31 = fTrue;
            if (FLstSectionExists(rgchLstFileName, szWin3xParamsSect))
                {
                szParamsSect = szWin3xParamsSect;
                szFilesSect  = szWin3xFilesSect;
                }
            }
        }

    if (szParamsSect == szNull)
        {
        if (FLstSectionExists(rgchLstFileName, szDefaultParamsSect))
            {
            szParamsSect = szDefaultParamsSect;
            szFilesSect  = szDefaultFilesSect;
            }
        else
            {
            DispErrBrc(brcNoCpuSect, TRUE, MB_OK | MB_ICONSTOP, NULL,
                    NULL, NULL);
            goto LCleanupAndExit;
            }
        }

    if (GetPrivateProfileString(szParamsSect, "TmpDirName", "",
                rgchSetupDirName, cchLstLineMax, rgchLstFileName) <= 0
        || (lcbDiskFreeMin = GetPrivateProfileInt(szParamsSect,
                "TmpDirSize", 0, rgchLstFileName) * 1024L) <= 0
        || (cFirstCabinetNum = GetPrivateProfileInt(szParamsSect,
                "FirstCabNum", 1, rgchLstFileName)) <= 0
        || (cLastCabinetNum = GetPrivateProfileInt(szParamsSect,
                "LastCabNum", 1, rgchLstFileName)) <= 0
#ifdef UNUSED
        || GetPrivateProfileString(szParamsSect, "DrvModName", "",
                rgchDrvModName, cchLstLineMax, rgchLstFileName) <= 0
#endif  /* UNUSED */
        || GetPrivateProfileString(szParamsSect, "DrvWinClass", "",
                rgchDrvWinClass, cchLstLineMax, rgchLstFileName) <= 0
        || GetPrivateProfileString(szParamsSect, "CmdLine", "", rgchCmdLine,
                cchLstLineMax, rgchLstFileName) <= 0
	//|| GetPrivateProfileString(szParamsSect, "Require31", "",
	//	rgchWin31Mess, cchLstLineMax, rgchLstFileName) <= 0
        || GetPrivateProfileString(szParamsSect, "WndTitle", "",
                rgchBootTitle, cchLstLineMax, rgchLstFileName) <= 0
        || GetPrivateProfileString(szParamsSect, "WndMess", "",
                rgchBootMess, cchLstLineMax, rgchLstFileName) <= 0)
        {
        DispErrBrc(brcLst, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }

    if (FindWindow(rgchDrvWinClass, NULL) != NULL)
        {
        DispErrBrc(brcInst, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }

    GetPrivateProfileString(szParamsSect, "CabinetFile", "",
            rgchCabinetFName, cchLstLineMax, rgchLstFileName);

    GetPrivateProfileString(szParamsSect, "InsertCDMsg", "",
            rgchInsertCDMsg, cchLstLineMax, rgchLstFileName);

    GetPrivateProfileString(szParamsSect, "InsertDiskMsg", "",
            rgchInsertDiskMsg, cchLstLineMax, rgchLstFileName);

    if (rgchWin31Mess[0] != '\0'
        && LOBYTE(LOWORD((DWORD)GetVersion())) == 3
        && HIBYTE(LOWORD((DWORD)GetVersion())) < 10)
        {
        if (!fQuietMode)
            {
            char rgchTitle[256];
    
            if (LoadString(hinstBoot, brcGen, rgchTitle, 256) == 0)
                lstrcpy(rgchTitle, rgchSetup);
            MessageBox(hwndBoot, rgchWin31Mess, rgchTitle,
                        MB_OK | MB_ICONSTOP);
            }
        goto LCleanupAndExit;
        }

    FixupTempDirName(rgchSetupDirName);

    for (sz = rgchBootMess; *sz != '\0'; sz = AnsiNext(sz))
        if (*sz == '\\' && *(sz+1) == 'n')
            {
            *sz++ = '\r';
            *sz   = '\n';
            }

    /* If there is a /W then is specifies we are in add/remove mode with
       the setup app not installed. We need to read it off CD/Floppy/Network
      */
    if ((lpszCmdParam[0] == '-' || lpszCmdParam[0] == '/')
            && toupper(lpszCmdParam[1]) == 'W')
        {
        CHAR    rgchStf[_MAX_PATH];
        char *pCh, *pCh2, *pCh3;
        
        /* Skip the spaces */
        for (pCh = lpszCmdParam+2; *pCh == ' ' && *pCh != '\0'; pCh++);
        
        lstrcpy(rgchStf, rgchSrcDir);
        pCh3 = rgchStf + lstrlen(rgchStf);
        /* Copy the .stf file name, and add the newline */
        for (pCh2=pCh; *pCh2 != ' ' && *pCh2!= '\0'; pCh2++)
            *pCh3++ = *pCh2;
        *pCh3 = '\0';
    
        /* Remove the /W parameter */
        lpszCmdParam = pCh2;

        /* Get them to insert the correct disk */
        if ((brc = BrcInsertDisk(rgchStf, rgchSrcDir)) != brcOkay)
            {
            if (brc != brcMax)
                DispErrBrc(brc, TRUE, MB_OK | MB_ICONSTOP, rgchStf, NULL, NULL);
            goto LCleanupAndExit;
            }
        }

    GetPrivateProfileString(szParamsSect, "Background", "",
            rgchBackgroundFName, cchLstLineMax, rgchLstFileName);
    GetPrivateProfileString(szParamsSect, "BkgWinClass", "",
            rgchBkgWinClass, cchLstLineMax, rgchLstFileName);
    if (rgchBackgroundFName[0] != '\0')
        {
        lstrcpy(rgchTemp, rgchSrcDir);
        lstrcat(rgchTemp, rgchBackgroundFName);
        if (rgchBkgWinClass[0] != '\0')
            {
            lstrcat(rgchTemp, " /C");
            lstrcat(rgchTemp, rgchBkgWinClass);
            }
        lstrcat(rgchTemp, " /T");
        lstrcat(rgchTemp, rgchBootTitle);
        lstrcat(rgchTemp, " /M");
        lstrcat(rgchTemp, rgchBootMess);

        hMod = WinExec(rgchTemp, SW_SHOWNORMAL);  /* ignore if exec failed */
#ifdef DEBUG
        if (hMod < 32)
            {
            wsprintf(szDebugBuf, "%s: Background WinExec failed.",
                        rgchBackgroundFName);
            MessageBox(NULL, szDebugBuf, szDebugMsg, MB_OK | MB_ICONSTOP);
            }
#endif  /* DEBUG */

        hWndBkg = FindWindow(rgchBkgWinClass, rgchBootTitle);
        }
    if (!hWndBkg && (hwndBoot = HwndInitBootWnd(hInstance)) == NULL)
            {
            DispErrBrc(brcMem, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
            goto LCleanupAndExit;
            }

    if ((brc = BrcBuildFileLists(rgchLstFileName, cbLstSize)) != brcOkay)
        {
        DispErrBrc(brc, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }
    
    lstrcat(rgchDstDir, "~MSSETUP.T");
    szDstDirSlash = rgchDstDir + lstrlen(rgchDstDir);
    lstrcat(rgchDstDir, "\\");

    lstrcat(rgchDstDir, rgchSetupDirName);
    AnsiToOem(rgchDstDir, rgchDstDir);
    for (chDrive = 'Z'; chDrive >= 'A'; --chDrive)
        {
        UINT fModeSav;
        BOOL fDriveFixed;

        fModeSav = SetErrorMode(fNoErrMes);
        fDriveFixed = (GetDriveTypeEx(chDrive - 'A') == EX_DRIVE_FIXED);
        SetErrorMode(fModeSav);
        if (fDriveFixed)
            {
            *rgchDstDir = chDrive;
            brc = BrcInstallFiles(rgchSrcDir, rgchDstDir, szDstDirSlash);
            if (brc == brcOkay)
                break;
            if (brc == brcFile)
                {
                DispErrBrc(brc, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
                goto LCleanupAndExit;
                }
            else if (brc == brcNoSpill)
                {
                /* Message already handled in HfOpenSpillFile */
                goto LCleanupAndExit;
                }
            }
        }

    if (chDrive < 'A')
        {
        uiRes = GetWindowsDirectory(rgchDstDir, cchFullPathMax);
        Assert(uiRes > 0);
#if DBCS    // [J1] Fixed DBCS raid #46.
        AnsiUpper(rgchDstDir);
#endif
        /* BLOCK */
            {
            LPSTR sz = (LPSTR)&rgchDstDir[uiRes];

            sz = AnsiPrev(rgchDstDir, sz);
            if (*sz != '\\')
                lstrcat(rgchDstDir, "\\");
            }

        lstrcat(rgchDstDir, "~MSSETUP.T");
        szDstDirSlash = rgchDstDir + lstrlen(rgchDstDir);
        lstrcat(rgchDstDir, "\\");

        Assert(lstrlen(rgchDstDir) + lstrlen(rgchSetupDirName)
                < cchFullPathMax);
        lstrcat(rgchDstDir, rgchSetupDirName);
        AnsiToOem(rgchDstDir, rgchDstDir);
        brc = BrcInstallFiles(rgchSrcDir, rgchDstDir, szDstDirSlash);
        if (brc != brcOkay)
            {
            /* NoSpill message already handled in HfOpenSpillFile */
            if (brc != brcNoSpill)
                {
                DispErrBrc(brc, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
                }
            goto LCleanupAndExit;
            }
        }

    hSrcLst = LocalFree(hSrcLst);   /* don't need src list anymore */
    Assert(hSrcLst == NULL);

    /* Use full path to .exe; don't rely on cwd (fails under Win95).
    */
    /* block */
        {
        char rgchTmp[cchWinExecLineMax];

        wsprintf(rgchTmp, rgchCmdLine, (LPSTR)rgchSrcDir,
                lpszCmdParam);

        Assert(lstrlen(rgchTmp) + lstrlen(rgchDstDir) + 1 < cchWinExecLineMax);

        lstrcpy(rgchWinExecLine, rgchDstDir);
        lstrcat(rgchWinExecLine, "\\");
        lstrcat(rgchWinExecLine, rgchTmp);
        }
    GlobalCompact((DWORD)(64L * 1024L));
    fCleanupTemp = TRUE;

    if (!fWin31 && !FNotifyAcme())
        {
#if DEBUG
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONEXCLAMATION, NULL, NULL, NULL);
#endif /* DEBUG */
        /* Try running Acme anyway. */
        }
    if (!fWin31 && !FWriteToRestartFile(rgchDstDir))
        {
#ifdef DEBUG
        MessageBox(NULL, "Write to restart file failed. Setup can continue, "
                    "but some initialization files might not get removed "
                    "if Setup must restart Windows.",
                    szDebugMsg, MB_OK | MB_ICONEXCLAMATION);

#endif /* DEBUG */
        /*
         *  Any errors encountered will have been displayed where they occured.
         *  Try running Acme anyway.
         */
        }
    if (hWndBkg)
        SendMessage(hWndBkg, WM_COMMAND, IDM_ACME_STARTING, 0);

    if (!FExecAndWait(rgchWinExecLine, hwndBoot))
        {
        DispErrBrc(brcMem, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }
    fExeced = fTrue;

LCleanupAndExit:
    if (fCleanupTemp && szDstDirSlash != szNull)
        CleanUpTempDir(rgchDstDir, szDstDirSlash);
    FreeFileLists();
    eelExitErrorLevel = eelBootstrapperFailed;
    if (fExeced && !FGetAcmeErrorLevel(&eelExitErrorLevel))
        {
#ifdef UNUSED
        /* NOTE: Removed to avoid the message on WinNT.  On NT, Acme can
        *   exit and the bootstrapper can kick in before the restart
        *   actually happens, causing this message (since Acme has already
        *   removed the reg key as part of its reboot cleanup).  We'll
        *   leave the eelFailed value, though, since no one should be
        *   relying on it at reboot anyway, and it may help catch other
        *   problems down the road.
        */
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
#endif /* UNUSED */
        Assert(eelExitErrorLevel == eelBootstrapperFailed);
        }
    if (hwndBoot != NULL)
        DestroyWindow(hwndBoot);
    if (hWndBkg && IsWindow(hWndBkg))
        {
        SendMessage(hWndBkg, WM_COMMAND, eelExitErrorLevel == eelSuccess ?
                    IDM_ACME_COMPLETE : IDM_ACME_FAILURE, 0);
        if (IsWindow(hWndBkg))
            PostMessage(hWndBkg, WM_QUIT, 0, 0);
        }
    return (eelExitErrorLevel);
}


/*
**  Purpose:
**      Creates and temporary subdirectory at the given path,
**      appends it to the given path, and copies the Setup files
**      into it.
**  Arguments:
**      szModule: Full path to bootstrapper's directory (ANSI chars).
**      rgchDstDir: Full path to destination directory (OEM chars).
**  Returns:
**      One of the following Bootstrapper return codes:
**          brcMem    out of memory
**          brcDS     out of disk space
**          brcMemDS  out of memory or disk space
**          brcFile   expected source file missing
**          brcOkay   completed without error
**************************************************************************/
BRC BrcInstallFiles ( char * szModule, char * rgchDstDir,
                    char * szDstDirSlash )
{
    BRC brc;

    if (LcbFreeDrive(*rgchDstDir - 'A' + 1) < lcbDiskFreeMin)
        return (brcDS);
    if (!FCreateTempDir(rgchDstDir, szDstDirSlash))
        return (brcMemDS);
    if ((brc = BrcCopyFiles(szModule, rgchDstDir, szDstDirSlash)) != brcOkay)
        {
        CleanUpTempDir(rgchDstDir, szDstDirSlash);
        return (brc);
        }

    SetFileAttributes(rgchDstDir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);

    Assert(szDstDirSlash);
    Assert(*szDstDirSlash == '\\');
    *szDstDirSlash = '\0';
    SetFileAttributes(rgchDstDir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);
    *szDstDirSlash = '\\';

    return (brcOkay);
}


/*
**  Purpose:
**      Removes the temporary files and directory.
**  Arguments:
**      rgchDstDir: Full path to temp directory (OEM chars).
**  Returns:
**      None.
**************************************************************************/
VOID CleanUpTempDir ( char * rgchDstDir, char * szDstDirSlash )
{
    char rgchRoot[] = " :\\";
    int i;

    RemoveFiles(rgchDstDir);

    rgchRoot[0] = *rgchDstDir;
    _chdir(rgchRoot);

    SetFileAttributes(rgchDstDir, FILE_ATTRIBUTE_NORMAL);

    /* Try to remove the directory up to cRetryMax times.
    */
    for (i = 0; i < cRetryMax; i++)
        {
        if (_rmdir(rgchDstDir) == 0)
            break;
        }

    Assert(szDstDirSlash);
    Assert(*szDstDirSlash == '\\');
    *szDstDirSlash = '\0';
    SetFileAttributes(rgchDstDir, FILE_ATTRIBUTE_NORMAL);

    /* Try to remove the directory up to cRetryMax times.
    */
    for (i = 0; i < cRetryMax; i++)
        {
        if (_rmdir(rgchDstDir) == 0)
            break;
        }

    *szDstDirSlash = '\\';
}


/*
**  Purpose:
**      Creates a temporary subdirectory at the given path,
**      and appends it to the given path.
**  Arguments:
**      rgchDir: Full path to destination directory (OEM chars).
**  Returns:
**      TRUE if directory was successfully created,
**      FALSE if not.
**************************************************************************/
BOOL FCreateTempDir ( char * rgchDir, char * szDstDirSlash )
{
    char    rgchTmp[cchFullPathMax];
    FILE *  fp;
    char *  pch;
    int     fErr;
    int     i = 0;

    pch = (char *)(&rgchDir[lstrlen(rgchDir)]);
    Assert(*pch == '\0');
    _chdrive(*rgchDir - 'A' + 1);

    Assert(szDstDirSlash);
    Assert(*szDstDirSlash == '\\');
    *szDstDirSlash = '\0';
    _mkdir(rgchDir);
    *szDstDirSlash = '\\';

    while (!_access(rgchDir, 0))
        {
        if (!_chdir(rgchDir))
            {
            /* verify dir is write-able */
            lstrcpy(rgchTmp, rgchDir);
            lstrcat(rgchTmp, "\\tXXXXXX");
            Assert(lstrlen(rgchTmp) < cchFullPathMax);
            if (_mktemp(rgchTmp) != NULL
                && (fp = fopen(rgchTmp, "w")) != NULL)
                {
                fErr = fclose(fp);
                Assert(!fErr);

                fErr = remove(rgchTmp);
#ifdef DBCS     // [J2] Fixed DBCS raid #28.
                if (fErr)       // Keep the directory name
                    *pch = '\0';
#else
                *pch = '\0';
#endif
                return (!fErr);
                }
            }
        if (++i > 9)
            break;
        _itoa(i, pch, 10);
        Assert(lstrlen(rgchDir) < cchFullPathMax);
        }

    if (i <= 9 && !_mkdir(rgchDir))
        {
        fErr = _chdir(rgchDir);
        Assert(!fErr);
#ifdef DBCS     // [J2] Fixed DBCS raid #28.
//      Keep the directory name
#else
        *pch = '\0';
#endif
        return (TRUE);
        }

    *pch = '\0';

    return (FALSE);
}

/*
**  Purpose:
**      Reopens BAT file and writes DEL or RMDIR line.
**  Arguments:
**      of:    OFSTRUCT to REOPEN.
**      szCmd: Command (ANSI chars).  ["DEL" or "RMDIR"]
**      szArg: Fully qualified pathname for argument (OEM chars).
**  Returns:
**      TRUE or FALSE.
**************************************************************************/
BOOL FWriteBatFile ( OFSTRUCT of, char * szCmd, char * szArg )
{
    int     fhBat = -1;
    BOOL    fRet = TRUE;

    if ((fhBat = OpenFile("a", &of, OF_REOPEN | OF_WRITE)) == -1
        || _llseek(fhBat, 0L, 2) == -1L
        || _lwrite(fhBat, szCmd, lstrlen(szCmd)) != (UINT)lstrlen(szCmd)
        || _lwrite(fhBat, (LPSTR)" ", 1) != 1
        || _lwrite(fhBat, szArg, lstrlen(szArg)) != (UINT)lstrlen(szArg)
        || _lwrite(fhBat, (LPSTR)"\r\n", 2) != 2)
        {
        fRet = FALSE;
        }

    if (fhBat != -1)
        {
        int fErr = _lclose(fhBat);

        Assert(fErr != -1);
        }

    return (fRet);
}

#ifdef DEBUG
/*
**  Purpose:
**      Checks if destination filename is a valid 8.3 name with no path
*/
BOOL FValidFATFileName ( char* szName )
{
    int  iLen, ch;
    for (iLen = 0; (ch = *szName++) != '\0'; iLen++)
        {
        if (ch <= ' ' || ch == '\\' || ch == ':' || ch == ',')
            return fFalse;
        if (ch == '.')
            {
            if (iLen == 0 || iLen > 8)
                return fFalse;
            iLen = 9;
            }
        if (iLen == 8 || iLen == 13)
            return fFalse;
        }
    return (iLen > 0);
}
#endif  /* DEBUG */


/*
**  Purpose:
**      Copies the source files into the given destination dir.
**  Arguments:
**      szModule: Source path (ANSI chars).
**      szDstDir: Destination path (OEM chars).
**  Returns:
**      One of the following bootstrapper return codes:
**          brcMem    out of memory
**          brcDS     out of disk space
**          brcMemDS  out of memory or disk space
**          brcFile   expected source file missing
**          brcOkay   completed without error
**************************************************************************/
BRC BrcCopyFiles ( char * szModule, char * szDstDir, char * szDstDirSlash )
{
    char        rgchSrcFullPath[cchFullPathMax];
    char        rgchDstFullPath[cchFullPathMax];
    char        rgchTmpDirPath[cchFullPathMax];
    char *      szSrc;
    char *      szDst;
    int         cbSrc;
    BRC         brc = brcOkay;
    int         fhBat = -1;
    OFSTRUCT    ofBat;
    int         fErr;
    BOOL        fCabinetFiles = FALSE;

    lstrcpy(rgchDstFullPath, szDstDir);
    lstrcat(rgchDstFullPath, "\\_MSSETUP._Q_");
    Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);
    _chmod(rgchDstFullPath, S_IREAD | S_IWRITE);
    remove(rgchDstFullPath);

    OemToAnsi(rgchDstFullPath, rgchDstFullPath);
    fhBat = OpenFile(rgchDstFullPath, &ofBat, OF_CREATE | OF_WRITE);
    AnsiToOem(rgchDstFullPath, rgchDstFullPath);
    if (fhBat == -1)
        return (brcMemDS);

    fErr = _lclose(fhBat);
    Assert(!fErr);

    szSrc = (char *)LocalLock(hSrcLst);
    if (szSrc == NULL)
         return (brcMem);

    szDst = (char *)LocalLock(hDstLst);
    
    if (szDst == NULL) {
        LocalUnlock (hSrcLst);
        return (brcMem);
    }

    for (;
        (cbSrc = lstrlen(szSrc)) != 0;
        szSrc += cbSrc + 1, szDst += lstrlen(szDst) + 1)
        {
        
        //
        //  This code has been added so that we can detect a path
        //  in setup.lst for the right hand side of the equals sign.  This
        //  allows us flexiblity in specifying where files like setup.inf
        //  should be pulled from, otherwise we always use the files from
        //  the original source location.  If we detect "<anything>:\" or
        //  "\\" then we assume it is a path.
        //
        if( ((':' == szSrc[1]) && ('\\' == szSrc[2])) ||
            (('\\' == szSrc[0]) && ('\\' == szSrc[1])) )
        {
            rgchSrcFullPath[0] = '\0';
        }
        else
        {
            lstrcpy(rgchSrcFullPath, szModule);
        }

        lstrcat(rgchSrcFullPath, szSrc);
        lstrcpy(rgchDstFullPath, szDstDir);
        lstrcat(rgchDstFullPath, "\\");
        lstrcat(rgchDstFullPath, szDst);
#ifdef DEBUG
        if (!FValidFATFileName(szDst))
            {
            wsprintf(szDebugBuf, "Invalid destination file, must be 8.3: %s",
                        szDst);
            MessageBox(NULL, szDebugBuf, szDebugMsg, MB_OK | MB_ICONSTOP);
            continue;
            }
#endif  /* DEBUG */
        Assert(lstrlen(rgchSrcFullPath) < cchFullPathMax);
        Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);
        if (   !FWriteBatFile(ofBat, "ATTRIB -R", rgchDstFullPath)
            || !FWriteBatFile(ofBat, "DEL",       rgchDstFullPath))
            {
            brc = brcDS;
            break;
            }

        if (*szSrc == '@')  /* cabinet file */
            {
            if (*rgchCabinetFName == '\0')
                {
                brc = brcFile;
#ifdef DEBUG
                lstrcpy(rgchErrorFile, ". Missing CABINET= line");
#endif //DEBUG
                break;
                }
            fCabinetFiles = TRUE;
            continue;
            }

        if ((brc = BrcCopy(rgchSrcFullPath, rgchDstFullPath)) != brcOkay)
            break;
        _chmod(rgchDstFullPath, S_IREAD);
        }
    LocalUnlock(hSrcLst);
    LocalUnlock(hDstLst);

    lstrcpy(rgchDstFullPath, szDstDir);
    lstrcat(rgchDstFullPath, "\\_MSSETUP._Q_");
    Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);

    Assert(szDstDirSlash != szNull);
    Assert(*szDstDirSlash == chDirSep);
    *szDstDirSlash = chEos;
    lstrcpy(rgchTmpDirPath, szDstDir);
    *szDstDirSlash = chDirSep;

    if (brc == brcOkay
        && (!FWriteBatFile(ofBat, "DEL", rgchDstFullPath)
        || !FWriteBatFile(ofBat, "RMDIR", szDstDir)
        || !FWriteBatFile(ofBat, "RMDIR", rgchTmpDirPath)))
        {
        return (brcDS);
        }

    if (fCabinetFiles && brc == brcOkay)
        {
        szSrc = (char *)LocalLock(hSrcLst);
        if(szSrc == NULL)
            return (brcMem);

        szDst = (char *)LocalLock(hDstLst);
        if( szDst == NULL) {
            LocalUnlock (hSrcLst);
            return (brcMem);
        }
#ifdef DEBUG
        if (!FValidFATFileName(rgchCabinetFName))
            {
            wsprintf(szDebugBuf, "Invalid cabinet file, must be 8.3: %s",
                            rgchCabinetFName);
            MessageBox(NULL, szDebugBuf, szDebugMsg, MB_OK | MB_ICONSTOP);
            }
        else            
#endif  /* DEBUG */

        brc = BrcHandleCabinetFiles(hwndBoot, rgchCabinetFName,
                    cFirstCabinetNum, cLastCabinetNum, szModule, szDstDir,
                    szSrc, szDst, rgchErrorFile, rgchDstFullPath);

        LocalUnlock(hSrcLst);
        LocalUnlock(hDstLst);
        }

    return (brc);
}


/*
**  Purpose:
**      Removes the files previously copied to the temp dest dir.
**  Arguments:
**      szDstDir: full path to destination directory (OEM chars).
**  Returns:
**      None.
**************************************************************************/
VOID RemoveFiles ( char * szDstDir )
{
    char    rgchDstFullPath[cchFullPathMax];
    char *  szDst;
    int     cbDst;
    int     i;
    OFSTRUCT ofs;
    UINT    fModeSav;

    fModeSav = SetErrorMode(fNoErrMes);
    szDst = (char *)LocalLock(hDstLst);
    
    if (szDst == NULL)
        return;

    for (; (cbDst = lstrlen(szDst)) != 0; szDst += cbDst + 1)
        {
        lstrcpy(rgchDstFullPath, szDstDir);
        lstrcat(rgchDstFullPath, "\\");
        lstrcat(rgchDstFullPath, szDst);
        Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);
        
        /* Don't try to remove the file if it doesn't exist */
        if (OpenFile(rgchDstFullPath, &ofs, OF_EXIST) == HFILE_ERROR)
            continue;

        /* Try to _chmod the file up to cRetryMax times.
        */
        for (i = 0; i < cRetryMax; i++)
            {
            if (_chmod(rgchDstFullPath, S_IWRITE) == 0)
                break;
            FYield();
            }

        /* Try to remove the file up to cRetryMax times.
        */
        for (i = 0; i < cRetryMax; i++)
            {
            if (remove(rgchDstFullPath) == 0)
                break;
            FYield();
            }
        }

    LocalUnlock(hDstLst);
    SetErrorMode(fModeSav);

    lstrcpy(rgchDstFullPath, szDstDir);
    lstrcat(rgchDstFullPath, "\\_MSSETUP._Q_");
    Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);
    _chmod(rgchDstFullPath, S_IWRITE);
    remove(rgchDstFullPath);
}


/*
**  Purpose:
**      Copies the given source file to the given destination.
**  Arguments:
**      szFullPathSrc: full path name of source file (ANSI chars).
**      szFullPathDst: full path name of destination file (OEM chars).
**  Returns:
**      One of the following bootstrapper return codes:
**          brcMem    out of memory
**          brcDS     out of disk space
**          brcMemDS  out of memory or disk space
**          brcFile   expected source file missing
**          brcOkay   completed without error
**************************************************************************/
BRC BrcCopy ( char * szFullPathSrc, char * szFullPathDst )
{
    int         fhSrc = -1;
    int         fhDst = -1;
    OFSTRUCT    ofSrc, ofDst;
    BRC         brc = brcMemDS;
    int         fErr;

#ifdef APPCOMP
    if ((fhSrc = OpenFile(szFullPathSrc, &ofSrc, OF_READ)) == -1)
        {
        brc = brcFile;
        lstrcpy(rgchErrorFile, szFullPathSrc);
        goto CopyFailed;
        }
#endif /* APPCOMP */

    /* REVIEW: BUG: if szFullPathDst is an existing subdirectory
    ** instead of a file, we'll fail trying to open it, think we're
    ** out of disk space, and go back up to try another disk.
    ** This is acceptable for now.
    */
    _chmod(szFullPathDst, S_IREAD | S_IWRITE);
    OemToAnsi(szFullPathDst, szFullPathDst);
    fhDst = OpenFile(szFullPathDst, &ofDst, OF_CREATE | OF_WRITE);
    AnsiToOem(szFullPathDst, szFullPathDst);
    if (fhDst == -1)
        goto CopyFailed;

#ifdef APPCOMP
    if (WReadHeaderInfo(fhSrc) > 0)
        {
        LONG lRet;

        lRet = LcbDecompFile(fhSrc, fhDst, -1, 0, TRUE, NULL, 0L, NULL, 0,
                NULL);
        if (lRet < 0L)
            {
            if (lRet == (LONG)rcOutOfMemory)
                brc = brcMem;
            if (lRet == (LONG)rcWriteError)
                brc = brcDS;
            goto CopyFailed;
            }
        FFreeHeaderInfo();
        }
    else    /* copy the file using LZExpand */
#endif /* APPCOMP */
        {
        HFILE   hSrcLZ;
        DWORD   dwRet;

#ifdef APPCOMP
        fErr = _lclose(fhSrc);
        Assert(!fErr);
        fhSrc = -1;
#endif /* APPCOMP */

        if ((hSrcLZ = LZOpenFile(szFullPathSrc, &ofSrc, OF_READ)) == -1)
            {
            brc = brcFile;
            lstrcpy(rgchErrorFile, szFullPathSrc);
            goto CopyFailed;
            }

        /* We would like to yield more often, but LZCopy has no callbacks */
        FYield();
        
        dwRet = LZCopy(hSrcLZ, fhDst);
        LZClose(hSrcLZ);

        if (dwRet >= LZERROR_UNKNOWNALG)
            {
            if (dwRet == LZERROR_GLOBALLOC)
                brc = brcMem;
            if (dwRet == LZERROR_WRITE)
                brc = brcDS;
            goto CopyFailed;
            }
        }

    brc = brcOkay;

CopyFailed:
#ifdef APPCOMP
    if (fhSrc != -1)
        {
        fErr = _lclose(fhSrc);
        Assert(!fErr);
        }
#endif /* APPCOMP */
    if (fhDst != -1)
        {
        fErr = _lclose(fhDst);
        Assert(!fErr);
        }

    return (brc);
}


/*
**  Purpose:
**      Determine the storage space remaining on disk.
**  Arguments:
**      nDrive: drive number (1='A', 2='B', etc.)
**  Returns:
**      Number of bytes free on disk,
**      or 0 if not a valid drive.
+++
**  Implementation:
**      Calls DOS interrupt 21h, funct 36h.
**************************************************************************/
LONG LcbFreeDrive ( int nDrive )
{
    LONG        lcbRet;
        CHAR            achRoot[4];
        ULARGE_INTEGER  freeBytes;

        achRoot[0] = 'A'+nDrive-1;
        achRoot[1] = ':';
        achRoot[2] = '\\';
        achRoot[3] = 0;
        memset(&freeBytes, 0, sizeof(freeBytes));
        
        GetDiskFreeSpaceEx(achRoot, &freeBytes, 0, 0);
        lcbRet = freeBytes.LowPart;

    /* KLUDGE: Drives bigger than 2 GB can return zero total space!
    */
    if (lcbRet < 0L || lcbRet > (999999L * 1024L))
        {
        return (999999L * 1024L);
        }

    return (lcbRet);
}


/*
**  Purpose:
**      Creates and displays bootstrapper window.
**  Arguments:
**      hInstance: process instance handle
**  Returns:
**      Window handle to bootstrapper window, or
**      NULL if the window could not be created.
**************************************************************************/
HWND HwndInitBootWnd ( HANDLE hInstance )
{
    WNDCLASS    wc;
    HWND        hwnd;
    int         cx, cy;

    wc.style = 0;
    wc.lpfnWndProc = BootWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szBootClass;
    if (!RegisterClass(&wc))
        return (NULL);

    cx = GetSystemMetrics(SM_CXSCREEN) / 2;
    cy = GetSystemMetrics(SM_CYSCREEN) / 3;

    hwnd = CreateWindow(szBootClass, rgchBootTitle,
            WS_DLGFRAME, cx / 2, cy, cx, cy, NULL, NULL, hInstance, NULL);

    if (hwnd == NULL)
        return (NULL);

    if (!fQuietMode)
        {
        ShowWindow(hwnd, SW_SHOWNORMAL);
        UpdateWindow(hwnd);
        }

    return (hwnd);
}

// ripped off from mvdm\wow32\wgtext.c
ULONG GetTextExtent(HDC hdc, LPSTR lpstr, int cbString)
{
    ULONG ul = 0;
    SIZE size4;

    if ((GetTextExtentPoint(
                    hdc,
                    lpstr,
                    cbString,
                    &size4
                   )))
    {
        // check if either cx or cy are bigger than SHRT_MAX == 7fff
        // but do it in ONE SINGLE check

        if ((size4.cx | size4.cy) & ~SHRT_MAX)
        {
            if (size4.cx > SHRT_MAX)
               ul = SHRT_MAX;
            else
               ul = (ULONG)size4.cx;

            if (size4.cy > SHRT_MAX)
               ul |= (SHRT_MAX << 16);
            else
               ul |= (ULONG)(size4.cy << 16);
        }
        else
        {
            ul = (ULONG)(size4.cx | (size4.cy << 16));
        }

    }
    return (ul);
}

/*
**  Purpose:
**      WndProc for bootstrapper window.
**  Arguments:
**      Standard Windows WndProc arguments.
**  Returns:
**      Result of call DefWindowProc, or zero if WM_PAINT message.
**************************************************************************/
LRESULT CALLBACK BootWndProc ( HWND hwnd, UINT wMsgID, WPARAM wParam,
                            LPARAM lParam )
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rect;
    UINT        iMargin;

    switch (wMsgID)
        {
#ifdef DBCS     // [J3] Fixed KK raid #12.
        case WM_CREATE:
            {
            if (!fQuietMode)
                {
                int x, y, cx, cy;
                hdc = BeginPaint(hwnd, &ps);
                GetClientRect(hwnd, &rect);
                cx = (LOWORD(GetTextExtent(hdc, rgchBootMess, lstrlen(rgchBootMess))) + 13) / 14 * 16 + 2;
                if (cx > rect.right)
                    {
                    if (cx > GetSystemMetrics(SM_CXSCREEN))
                        cx = GetSystemMetrics(SM_CXSCREEN);
                    x = (GetSystemMetrics(SM_CXSCREEN) - cx) / 2;
                    y = cy = GetSystemMetrics(SM_CYSCREEN) / 3;
                    SetWindowPos(hwnd, NULL, x, y, cx, cy, SWP_NOZORDER);
                    }
                EndPaint(hwnd, &ps);
                }
            break;
            }
#endif
        case WM_PAINT:
            if (!fQuietMode)
                {
                hdc = BeginPaint(hwnd, &ps);
                GetClientRect(hwnd, &rect);
                iMargin = rect.right / 16;
                rect.top    = rect.bottom / 2 - GetSystemMetrics(SM_CYCAPTION);
                rect.left   = iMargin;
                rect.right -= iMargin;
                SetBkMode(hdc, TRANSPARENT);
                DrawText(hdc, rgchBootMess, -1, &rect,
                         DT_WORDBREAK | DT_CENTER | DT_NOPREFIX);
                EndPaint(hwnd, &ps);
                }
            break;
        default:
            return (DefWindowProc(hwnd, wMsgID, wParam, lParam));
        }

    return (0L);
}


/*
**  Purpose:
**      Get size of file.
**  Arguments:
**      szFile:  List file name (full path, ANSI).
**      pcbSize: Pointer to variable to receive file size.
**  Returns:
**      FALSE if file found and size >= 64K.
**      TRUE otherwise.
**************************************************************************/
BOOL FGetFileSize ( char * szFile, UINT * pcbSize )
{
    int     fh;
    int     fErr;
    LONG    lcb;

    *pcbSize = 0;
    if ((fh = _lopen(szFile, OF_READ)) == -1)
        {
        return (TRUE);
        }
    
    if ((lcb = _llseek(fh, 0L, 2)) > 65535)
        {
#pragma warning(disable:4127)   /* conditional expression is constant */
        Assert(FALSE);
#pragma warning(default:4127)
        _lclose(fh);
        return (FALSE);
        }
    *pcbSize = (UINT)lcb;
    fErr = _lclose(fh);
    Assert(!fErr);

    return (TRUE);
}


/*
**  Purpose:
**      Build file Src and Dst lists from LST file.
**  Arguments:
**      szFile: List file name (full path, ANSI).
**      cbFile: Size of list file
**  Note:
**      Sets globals: hSrcLst, hDstLst.
**  Returns:
**      One of the following Bootstrapper return codes:
**          brcMem    out of memory
**          brcLst    list file is corrupted
**          brcOkay   completed without error
**************************************************************************/
BRC BrcBuildFileLists ( char * szFile, UINT cbFile )
{
    char    rgchDst[cchLstLineMax];
    char *  szSrc;
    char *  szDst;
    char *  pchDstStart;
    int     cbSrc;
    UINT    i;

    /* Build Src List */

    if ((hSrcLst = LocalAlloc(LMEM_MOVEABLE, cbFile)) == NULL)
        return (brcMem);
    szSrc = (char *)LocalLock(hSrcLst);
    if(szSrc == (char *)NULL)
        return (brcMem);

    i = GetPrivateProfileString(szFilesSect, NULL, "", szSrc, cbFile, szFile);
    if (i <= 0)
        {
        LocalUnlock(hSrcLst);
        hSrcLst = LocalFree(hSrcLst);
        Assert(hSrcLst == NULL);
        return (brcLst);
        }
    Assert(i+1 < cbFile);
    szSrc[i++] = '\0';  /* force double zero at end */
    szSrc[i++] = '\0';
    LocalUnlock(hSrcLst);
    hSrcLst = LocalReAlloc(hSrcLst, i, LMEM_MOVEABLE);
    if(hSrcLst == NULL)
        return (brcMem);

    /* Build Dst List */
    if ((hDstLst = LocalAlloc(LMEM_MOVEABLE, cbFile)) == NULL)
        {
        hSrcLst = LocalFree(hSrcLst);
        Assert(hSrcLst == NULL);
        return (brcMem);
        }

    szSrc = (char *)LocalLock(hSrcLst);
    if (szSrc == (char *)NULL)
        return (brcMem);

    szDst = pchDstStart = (char *)LocalLock(hDstLst);
    if (szDst == (char *)NULL) {
        LocalUnlock (hDstLst);
        return (brcMem);
    }

    for (;
        (cbSrc = lstrlen(szSrc)) != 0;
        szSrc += cbSrc + 1, szDst += lstrlen(szDst) + 1)
        {
        if (GetPrivateProfileString(szFilesSect, szSrc, "", rgchDst,
                cchLstLineMax, szFile) <= 0)
            {
            LocalUnlock(hSrcLst);
            LocalUnlock(hDstLst);
            FreeFileLists();
            return (brcLst);
            }
        AnsiToOem(rgchDst, rgchDst);
        lstrcpy(szDst, rgchDst);
        }
    *szDst = '\0';  /* force double zero at end */
    LocalUnlock(hSrcLst);
    LocalUnlock(hDstLst);
    hDstLst = LocalReAlloc(hDstLst, (int)(szDst - pchDstStart) + 1,
            LMEM_MOVEABLE);
    if (hDstLst == NULL)
        return (brcMem);

    return (brcOkay);
}


/*
**  Purpose:
**      Frees file list buffers with non-NULL handles
**      and sets them to NULL.
**  Arguments:
**      none.
**  Returns:
**      none.
**************************************************************************/
VOID FreeFileLists ()
{
    if (hSrcLst != NULL)
        hSrcLst = LocalFree(hSrcLst);
    if (hDstLst != NULL)
        hDstLst = LocalFree(hDstLst);
    Assert(hSrcLst == NULL);
    Assert(hDstLst == NULL);
}



/*
**  Purpose:
**      Spawns off a process with WinExec and waits for it to complete.
**  Arguments:
**      szCmdLn: Line passed to WinExec (cannot have leading spaces).
**  Returns:
**      TRUE if successful, FALSE if not.
+++
**  Implementation:
**      GetModuleUsage will RIP under Win 3.0 Debug if module count is
**      zero (okay to ignore and continue), but the GetModuleHandle
**      check will catch all zero cases for single instances of the
**      driver, the usual case.  [Under Win 3.1 we will be able to
**      replace both checks with just an IsTask(hMod) check.]
**************************************************************************/
BOOL FExecAndWait ( char * szCmdLn, HWND hwndHide )
{
    UINT hMod;
    MSG msg;

    Assert(!isspace(*szCmdLn)); /* leading space kills WinExec */

    if ((hMod = WinExec(szCmdLn, SW_SHOWNORMAL)) > 32)
        {
        UINT i;
        UINT_PTR idTimer;
        
        /* KLUDGE: Give the app some time to create its main window.
        *
        *   On newer versions of NT, we were exiting the while loop
        *   (below) and cleaning up the temp dir before the app had
        *   even put up its window.
        *
        *   NOTE: In trials, we only had to retry once, so cRetryMax
        *   may be overkill, but it should be pretty rare that this
        *   would fail in shipping products anyway.
        */
        for (i = 0; i < cRetryMax; i++)
            {
            if(FindWindow(rgchDrvWinClass, NULL) != NULL)
                break;
            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                }
            }

        /* Set the timer to fire every 1/10 of a second. This is
            necessary because we might never return from GetMessage */
        idTimer = SetTimer(NULL, 0, 100, NULL);
        /*
        ** REVIEW - FindWindow() will wait until the LAST setup quits (not
        **  necessarily this setup.  If exec'ing a 16-bit app we could
        **  use the old code:
        **    while (GetModuleHandle(rgchDrvModName) && GetModuleUsage(hMod))
        **  but on NT this fails so for 32-bit apps we could attempt to
        **  remove one of the executable files (slow?).
        **
        ** REVIEW - This loop becomes a busy wait under NT, which is bad.
        **  However, it doesn't appear to affect ACME's performance
        **  noticeably.
        */
        while (FindWindow(rgchDrvWinClass, NULL) != NULL)
            {
            if (GetMessage(&msg, NULL, 0, 0))
                {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                }
            if (msg.message == WM_TIMER && hwndHide != (HWND)NULL)
                {
                ShowWindow(hwndHide, SW_HIDE);
                hwndHide = (HWND)NULL;
                }
            }
        if (idTimer != 0)
            KillTimer(0, idTimer);
        return (TRUE);
        }
#ifdef DEBUG
    wsprintf(szDebugBuf, "WinExec Error: %d", hMod);
    MessageBox(NULL, szDebugBuf, szDebugMsg, MB_OK | MB_ICONSTOP);
#endif  /* DEBUG */

    return (FALSE);
}


/*
**  Purpose: Processes messages that may be in the queue.
**  Arguments: none
**  Returns: none
**************************************************************************/
void PUBLIC FYield ( VOID )
{
    MSG  msg;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
}


/*
**************************************************************************/
BOOL FLstSectionExists ( char * szLstFileName, char * szSect )
{
    return (GetPrivateProfileString(szSect, "CmdLine", "", rgchCmdLine,
                cchLstLineMax, szLstFileName) > 0);
}



/*
**************************************************************************/
DWORD GetCpuArchitecture ()
{
    SYSTEM_INFO sysInfo;

    GetSystemInfo(&sysInfo);

    return sysInfo.wProcessorArchitecture;
}


static CSZC cszcBootstrapperKey = "MS Setup (ACME)\\Bootstrapper\\Exit Level";
static CSZC cszcEelRunning      = "Running";

/*
**  Purpose:
**      Lets Acme know the bootstrapper launched it.  So Acme will let
**      us know its exit error level.
**  Arguments:
**      none.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**  Notes:
**      REVIEW: Probably should use DDE instead of the Registration
**      Database.
**************************************************************************/
BOOL FNotifyAcme ( VOID )
{
    if (!FCreateRegKey(cszcBootstrapperKey))
        {
        return (fFalse);
        }
    if (!FCreateRegKeyValue(cszcBootstrapperKey, cszcEelRunning))
        {
        return (fFalse);
        }
    if (!FFlushRegKey())
        {
        return (fFalse);
        }
    return (fTrue);
}


/*
**  Purpose:
**      Get the exit error level set by Acme and clean up the Registration
**      Database.
**  Arguments:
**      peel: Exit error level (to be set).
**  Returns:
**      fTrue if successful, fFalse otherwise.
**************************************************************************/
BOOL FGetAcmeErrorLevel ( EEL * peel )
{
    CHAR rgchValue[cchSzMax];

    if (FGetRegKeyValue(cszcBootstrapperKey, rgchValue, sizeof rgchValue))
        {
#ifdef DEBUG
        /*
         *  Assert(isdigit(rgchValue[0]));
         *  Assert(isdigit(rgchValue[1]) || rgchValue[1] == chEos);
         */
        UINT i;
        BOOL fValidValue = fFalse;

        /*  Assumes valid values are 1 or 2 digit numbers. */
        for (i = 0; rgchValue[i] != chEos; i++)
            {
            fValidValue = fTrue;
            if (!isdigit(rgchValue[i]) || i > 1)
                {
                fValidValue = fFalse;
                break;
                }
            }
        if (!fValidValue)
            {
            char szBuf[cchSzMax];
    
            wsprintf(szBuf, "RegKeyValue (%s)", rgchValue);
            MessageBox(NULL, szBuf, "Debug Assertion in FGetAcmeErrorLevel",
                        MB_OK | MB_ICONSTOP);
            }
#endif  /* DEBUG */

        *peel = atoi(rgchValue);
        DeleteRegKey(cszcBootstrapperKey);
        return (fTrue);
        }
    else
        {
        if (fWin31)
            {
            *peel = eelSuccess;
            return fTrue;
            }
        return (fFalse);
        }
}


/*
**  Purpose:
**      Creates a Registration Database key that is a subkey of
**      cszcBootstrapperKey.
****************************************************************************/
BOOL FCreateRegKey ( CSZC cszcKey )
{
    HKEY hkey;

    if (RegCreateKey(HKEY_CLASSES_ROOT, cszcKey, &hkey) != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }

    if (RegCloseKey(hkey) != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }

    return (fTrue);
}


/*
**  Purpose:
**      API to check for the existence of the specified key in
**      the Registration Database.
****************************************************************************/
BOOL FDoesRegKeyExist ( CSZC cszcKey )
{
    HKEY hkey;

    if (RegOpenKey(HKEY_CLASSES_ROOT, cszcKey, &hkey) != ERROR_SUCCESS)
        return (fFalse);

    RegCloseKey(hkey);

    return (fTrue);
}


/*
**  Purpose:
**      Creates a Registration Database key that is a subkey of
**      HKEY_CLASSES_ROOT and associates a value with the key.
****************************************************************************/
BOOL FCreateRegKeyValue ( CSZC cszcKey, CSZC cszcValue )
{
    if (RegSetValue(HKEY_CLASSES_ROOT, cszcKey, REG_SZ, cszcValue,
                    lstrlen(cszcKey)) != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }

    return (fTrue);
}


/*
**  Purpose:
**      Determines the value associated with the specified Registration
**      Database key.
****************************************************************************/
BOOL FGetRegKeyValue ( CSZC cszcKey, SZ szBuf, CB cbBufMax )
{
    LONG lcb = cbBufMax;

    if (szBuf != szNull && cbBufMax != 0)
        *szBuf = chEos;

    if (!FDoesRegKeyExist(cszcKey))
        return (fFalse);

    if (RegQueryValue(HKEY_CLASSES_ROOT, cszcKey, szBuf, &lcb)
            != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }

    Assert(lcb < cbMaxConst);

    return (fTrue);
}


/*
**  Purpose:
**      API to remove the specified Registration Database key,
**      its associated values, and subkeys.
****************************************************************************/
VOID DeleteRegKey ( CSZC cszcKey )
{
    char rgchKey[cchSzMax], rgchBuffer[cchSzMax];
    char *pch;
    HKEY hKeyT = NULL;
        
    lstrcpy(rgchKey, cszcKey);
    RegDeleteKey(HKEY_CLASSES_ROOT, rgchKey);
    pch = rgchKey + 1;

    while(pch > rgchKey)
        {
        pch = rgchKey + lstrlen(rgchKey);
        while (pch > rgchKey)
            {
            if (*pch == '\\')
                break;
            pch--;
            }
        if (*pch != '\\')
            break;
        *pch = '\0';
        if (RegOpenKey(HKEY_CLASSES_ROOT, rgchKey, &hKeyT) != ERROR_SUCCESS)
            break;
        if (RegEnumKey(hKeyT, 0, rgchBuffer, sizeof(rgchBuffer)) == ERROR_SUCCESS)
            {
            break;
            }

        RegCloseKey(hKeyT);
        hKeyT = NULL;
        RegDeleteKey(HKEY_CLASSES_ROOT, rgchKey);
        }

    if (hKeyT != NULL)
        RegCloseKey(hKeyT);
    
}


/*
**  Purpose:
**      API to flush the specified Registration Database key.
****************************************************************************/
BOOL FFlushRegKey ( VOID )
{
    /* REVIEW: Does 16 bit code need to flush the RegDb?  RegFlushKey is
        32 bit.
    if (RegFlushKey(HKEY_CLASSES_ROOT)) != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }
    */

    return (fTrue);
}


/*
**  Purpose:
**      Write temporary files to restart ini file.  So that if Acme reboots,
**      the files in the temporary directory will be removed.  Win95 only.
**  Arguments:
**      szTmpDir: Full path to destination directory (OEM chars).
**  Returns:
**      fTrue if successful, fFalse otherwise.
**
**  REVIEW: The files are removed, but not the temp directories.
**      There may be a way to do that via the wininit.ini file.
**      This should be looked into.
**************************************************************************/
BOOL FWriteToRestartFile ( SZ szTmpDir )
{
    char   rgchIniFile[_MAX_PATH];
    CB     cbFrom;
    CB     cbTo;
    HLOCAL hlocalFrom = (HLOCAL)NULL;
    HLOCAL hlocalTo   = (HLOCAL)NULL;
    BOOL   fRet = fFalse;

    SZ szSection = "rename";
    SZ szKey     = "NUL";

    /* This code is not used under NT. */
    if (1)
        {
        return (fTrue);
        }

    if (!FCreateIniFileName(rgchIniFile, sizeof rgchIniFile))
        {
        goto LCleanupAndReturn;
        }
    if (!FGetFileSize(rgchIniFile, &cbFrom))
        {
        goto LCleanupAndReturn;
        }
    if (!FReadIniFile(rgchIniFile, &hlocalFrom, &cbFrom))
        {
        goto LCleanupAndReturn;
        }
    if (!FAllocNewBuf(cbFrom, szTmpDir, szSection, szKey, &hlocalTo, &cbTo))
        {
        goto LCleanupAndReturn;
        }
    if (!FProcessFile(hlocalFrom, hlocalTo, cbTo, szTmpDir, szSection, szKey))
        {
        goto LCleanupAndReturn;
        }
    if (!FWriteIniFile(rgchIniFile, hlocalTo))
        {
        goto LCleanupAndReturn;
        }
    fRet = fTrue;

LCleanupAndReturn:
    if (hlocalFrom != (HLOCAL)NULL)
        {
        hlocalFrom = LocalFree(hlocalFrom);
        Assert(hlocalFrom == (HLOCAL)NULL);
        }
    if (hlocalTo != (HLOCAL)NULL)
        {
        hlocalTo = LocalFree(hlocalTo);
        Assert(hlocalTo == (HLOCAL)NULL);
        }

    return (fRet);
}


/*
**  Purpose:
**      Create the restart file name.
**  Arguments:
**      szIniFile: Buffer to hold file name.
**      cbBufMax:  Size of buffer.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**************************************************************************/
BOOL FCreateIniFileName ( SZ szIniFile, CB cbBufMax )
{
    CB cbWinDir;

    cbWinDir = GetWindowsDirectory((LPSTR)szIniFile, cbBufMax);
    if (cbWinDir == 0)
        {
#pragma warning(disable:4127)   /* conditional expression is constant */
        Assert(fFalse); /*  Unusual if this happens. */
#pragma warning(default:4127)
        return (fFalse);
        }
    Assert(isalpha(*szIniFile));
    Assert(*(szIniFile + 1) == ':');

    if (*(AnsiPrev((LPSTR)szIniFile, (LPSTR)&szIniFile[cbWinDir])) != '\\')
        lstrcat((LPSTR)szIniFile, "\\");
    lstrcat((LPSTR)szIniFile, "wininit.ini");
    Assert((CB)lstrlen(szIniFile) < cbBufMax);

    return (fTrue);
}


/*
**  Purpose:
**      Read the data from the ini file
**  Arguments:
**      szIniFile: Ini file name
**      phlocal:   Pointer to memory handle.
**      pcbBuf:    Pointer to the number of bytes in the buffer.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**************************************************************************/
BOOL FReadIniFile ( SZ szIniFile, HLOCAL * phlocal, PCB pcbBuf )
{
    UINT   fModeSav;
    HLOCAL hlocal;
    SZ     szBuf;
    CB     cbBuf;
    BOOL   fRet = fFalse;

    Assert(szIniFile != szNull);
    Assert(phlocal != (HLOCAL *)NULL);
    Assert(pcbBuf  != pcbNull);

    fModeSav = SetErrorMode(fNoErrMes);
    hlocal = *phlocal;
    cbBuf  = *pcbBuf;

    Assert(hlocal == (HLOCAL)NULL);

    if (cbBuf == 0) /* Ini file does not exist or is empty. */
        {
        /*  Alloc room for CR, LF, EOS. */
        hlocal = LocalAlloc(LMEM_MOVEABLE, 3);
        if (hlocal == NULL)
            {
#ifdef DEBUG
            MessageBox(NULL, "Out of memory in FReadIniFile.", szDebugMsg,
                MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
            }
        else
            {
            szBuf = (SZ)LocalLock(hlocal);
            
            if(szBuf == szNull)
                return fFalse;

            *szBuf++ = chCR;
            *szBuf++ = chEol;
            *szBuf   = chEos;
            *pcbBuf = 2;
            fRet = fTrue;
            }
        }
    else
        {
        HFILE    hfile;
        OFSTRUCT ofs;
        CB       cbRead;

        /* Flush cache before calling OpenFile() */
        WritePrivateProfileString(szNull, szNull, szNull, szIniFile);
        hfile = OpenFile(szIniFile, &ofs, OF_READWRITE | OF_SHARE_EXCLUSIVE);
        if (hfile == HFILE_ERROR)
            {
#ifdef DEBUG
            wsprintf(szDebugBuf, "Can't open file: %s.", szIniFile);
            MessageBox(NULL, szDebugBuf, szDebugMsg,
                            MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
            goto LCleanupAndReturn;
            }
        hlocal = LocalAlloc(LMEM_MOVEABLE, cbBuf + 1);
        if (hlocal == NULL)
            {
#ifdef DEBUG
        MessageBox(NULL, "Out of memory in FReadIniFile.", szDebugMsg,
            MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
            }
        else
            {
            szBuf = (SZ)LocalLock(hlocal);
            if(szBuf == szNull)
                return fFalse;

            cbRead = (CB)_lread(hfile, szBuf, cbBuf + 1);
            if (cbRead == HFILE_ERROR)
                {
#ifdef DEBUG
                wsprintf(szDebugBuf, "Can't read file: %s.", szIniFile);
                MessageBox(NULL, szDebugBuf, szDebugMsg,
                                MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
                }
            else
                {
                Assert(cbRead == cbBuf);
                *(szBuf + cbBuf) = chEos;
                fRet = fTrue;
                }
            }
        hfile = _lclose(hfile);
        Assert(hfile != HFILE_ERROR);
        }

LCleanupAndReturn:
    if (hlocal != NULL)
        {
        LocalUnlock(hlocal);
        }
    *phlocal = hlocal;
    SetErrorMode(fModeSav);

    return (fRet);
}


/*
**  Purpose:
**      Allocate buffer for new file.
**  Arguments:
**      cbOld:     Size of existing file
**      szTmpDir:  Full path to destination directory (OEM chars).
**      szSection: Ini section name
**      szKey:     Ini key name
**      phlocal:   Pointer to memory handle.
**      pcbToBuf:  Pointer to total size of new buffer.
**  Returns:
**      fTrue if successful, fFalse if LocalAlloc failed.
**************************************************************************/
BOOL FAllocNewBuf ( CB cbOld, SZ szTmpDir, SZ szSection, SZ szKey,
                    HLOCAL * phlocal, PCB pcbToBuf )
{
    UINT fModeSav;
    SZ   szDst;
    CB   cbDst;
    CB   cbOverhead;
    CB   cbNew;
    BOOL fRet = fFalse;

    fModeSav = SetErrorMode(fNoErrMes);
    szDst = (SZ)LocalLock(hDstLst);
    if(szDst == szNull)
        return fFalse;
    /*
     *  Added to the old file will be one line per temporary file
     *  and (possibly) a section line.  cbNew is initialized with
     *  the size of the section line, plus enough for the file
     *  (_MSSETUP._Q_) which is not in the DstLst.
     *
     *  Each line will look like:
     *      <szKey>=<szTmpDir>\<szFile><CR><LF>
     */
    cbOverhead = lstrlen(szKey) + 1 + lstrlen(szTmpDir) + 1 + 2;
    cbNew = lstrlen(szSection) + 5 + _MAX_PATH;
    for (; (cbDst = lstrlen(szDst)) != 0; szDst += cbDst + 1)
        {
        cbNew += cbOverhead + cbDst;
        }

    LocalUnlock(hDstLst);

    *pcbToBuf = cbOld + cbNew;
    *phlocal = LocalAlloc(LMEM_MOVEABLE, *pcbToBuf);
    if (*phlocal == NULL)
        {
#ifdef DEBUG
        MessageBox(NULL, "Out of memory in FAllocNewBuf.", szDebugMsg,
            MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
        }
    else
        fRet = fTrue;
    SetErrorMode(fModeSav);

    return (fRet);
}


/*
**  Purpose:
**      Add the new lines to the ini file.
**  Arguments:
**      hlocalFrom: Handle to Src memory.
**      hlocalTo:   Handle to Dst memory.
**      cbToBuf:    Total size of Dst memory.
**      szTmpDir:   Full path to destination directory (OEM chars).
**      szSection:  Ini section name
**      szKey:      Ini key name
**  Returns:
**      fTrue if successful, fFalse otherwise.
**
**  REVIEW: DBCS writes out different order.  See DBCS J6 code and
**          comments in sysinicm.c.
**************************************************************************/
BOOL FProcessFile ( HLOCAL hlocalFrom, HLOCAL hlocalTo, CB cbToBuf,
                        SZ szTmpDir, SZ szSection, SZ szKey )
{
    UINT fModeSav;
    SZ   szFromBuf;
    SZ   szToBuf;
    SZ   szToStart;
    SZ   szCur;
    SZ   szDst;
    CB   cbSect;
    CB   cbDst;

    Unused(cbToBuf);    /* Used in debug only */

    fModeSav = SetErrorMode(fNoErrMes);

    szFromBuf = (SZ)LocalLock(hlocalFrom);
    if(szFromBuf == szNull)
        return fFalse;

    szToBuf = (SZ)LocalLock(hlocalTo);
    if(szToBuf != szNull) {
        LocalUnlock (hlocalFrom);
        return fFalse;
    }

    szToStart = szToBuf;

    cbSect = lstrlen(szSection);
    for (szCur = szFromBuf; *szCur != chEos; szCur = AnsiNext(szCur))
        {
        if (*szCur == '[' && *((szCur + cbSect + 1)) == ']'
                && _memicmp(szSection, AnsiNext(szCur), cbSect) == 0)
            {
            /*  Found section.  Copy up to section line. */
            CB cbCopy = (CB)(szCur - szFromBuf);

            memcpy(szToBuf, szFromBuf, cbCopy);
            szToBuf += cbCopy;
            break;
            }
        }

    /*  Copy section line. */
    *szToBuf++ = '[';
    memcpy(szToBuf, szSection, cbSect);
    szToBuf += cbSect;
    *szToBuf++ = ']';
    *szToBuf++ = chCR;
    *szToBuf++ = chEol;

    /*  Copy new lines. */
    szDst = (SZ)LocalLock(hDstLst);
    if (szDst == szNull) {

        LocalUnlock(hlocalFrom);
        LocalUnlock(hlocalTo);
        return fFalse;
    }

    for (; (cbDst = lstrlen(szDst)) != 0; szDst += cbDst + 1)
        {
        CopyIniLine(szKey, szTmpDir, szDst, &szToBuf);
        }
    LocalUnlock(hDstLst);
    CopyIniLine(szKey, szTmpDir, "_MSSETUP._Q_", &szToBuf);

    /*  Copy rest of file. */
    if (*szCur == '[')
        {
        /*
         *  Skip section line in From buffer.  Allow room for '[', section,
         *  ']', CR, LF.
         */
        szCur += cbSect + 4;
        }
    else
        {
        szCur = szFromBuf;
        }
    szToBuf = _memccpy(szToBuf, szCur, chEos, UINT_MAX);
    Assert(szToBuf != szNull);
    Assert((CB)lstrlen(szToStart) < cbToBuf);

    LocalUnlock(hlocalFrom);
    LocalUnlock(hlocalTo);
    SetErrorMode(fModeSav);

    return (fTrue);
}


/*
**  Purpose:
**      Constructs and copies an ini line to a buffer.
**  Arguments:
**      szKey:    Ini key name
**      szTmpDir: Full path to destination directory (OEM chars).
**      szFile:   Name of file in temporary directory.
**      pszToBuf: Pointer to new buffer.
**  Returns:
**      none
**************************************************************************/
VOID CopyIniLine ( SZ szKey, SZ szTmpDir, SZ szFile, PSZ pszToBuf )
{
    char rgchSysIniLine[256];
    CB   cbCopy;

    lstrcpy(rgchSysIniLine, szKey);
    lstrcat(rgchSysIniLine, "=");
    lstrcat(rgchSysIniLine, szTmpDir);
    lstrcat(rgchSysIniLine, "\\");
    lstrcat(rgchSysIniLine, szFile);
    Assert(lstrlen(rgchSysIniLine) < sizeof rgchSysIniLine);
    cbCopy = lstrlen(rgchSysIniLine);
    memcpy(*pszToBuf, rgchSysIniLine, cbCopy);
    (*pszToBuf) += cbCopy;
    *(*pszToBuf)++ = chCR;
    *(*pszToBuf)++ = chEol;
}


/*
**  Purpose:
**      Writes out the new ini file.
**  Arguments:
**      szIniFile: Buffer to hold file name.
**      hlocalTo:   Handle to Src memory.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**************************************************************************/
BOOL FWriteIniFile ( SZ szIniFile, HLOCAL hlocalTo )
{
    UINT     fModeSav;
    SZ       szToBuf;
    HFILE    hfile;
    OFSTRUCT ofs;
    CB       cbWrite;
    BOOL     fRet = fFalse;

    fModeSav = SetErrorMode(fNoErrMes);
    szToBuf = (SZ)LocalLock(hlocalTo);
    if(szToBuf == szNull)
        return fFalse;

    hfile = OpenFile(szIniFile, &ofs, OF_CREATE | OF_WRITE);
    if (hfile == HFILE_ERROR)
        {
#ifdef DEBUG
        wsprintf(szDebugBuf, "Can't open file: %s.", szIniFile);
        MessageBox(NULL, szDebugBuf, szDebugMsg,
                        MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
        goto LUnlockAndReturn;
        }

    cbWrite = _lwrite(hfile, szToBuf, lstrlen(szToBuf));
    if (cbWrite == HFILE_ERROR)
        {
#ifdef DEBUG
        wsprintf(szDebugBuf, "Can't write to file: %s.", szIniFile);
        MessageBox(NULL, szDebugBuf, szDebugMsg,
                        MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
        }
    else
        {
        fRet = fTrue;
        }

    hfile = _lclose(hfile);
    Assert(hfile != HFILE_ERROR);

LUnlockAndReturn:
    LocalUnlock(hlocalTo);
    SetErrorMode(fModeSav);

    return (fRet);
}

CHAR szcStfSrcDir[] = "Source Directory\t";
#define cchStfSrcDir (sizeof(szcStfSrcDir)-1)

/* Finds the source directory for the installation, asks the user
   to insert the disk. And returns */

BRC BrcInsertDisk(CHAR *pchStf, CHAR *pchSrcDrive)
{
    CHAR  rgbBuf[_MAX_PATH];
    BYTE  rgbFileBuf[32];
    UINT  iFileBuf = sizeof(rgbFileBuf), cFileBuf = sizeof(rgbFileBuf);
    CHAR *pchBuf = rgbBuf;
    CHAR *pchMsg;
    int iStf = 0;
    HFILE hFile;
    BRC brc = brcLst;
    char chDrv;
    BOOL fQuote = FALSE;
    int drvType;
    BOOL fFirst = TRUE;
    BOOL fOpen = FALSE;
    HFILE hFileT;
    BOOL fRenameStf = fFalse;

    if ((hFile = _lopen(pchStf, OF_READ)) == HFILE_ERROR)
        return brcNoStf;

    /* Find the path to the original setup. This is stored in the .stf file on the
       Source Directory line */
    while (pchBuf < rgbBuf + sizeof(rgbBuf))
        {
        BYTE ch;

        if (iFileBuf == cFileBuf)
            {
            if ((cFileBuf = _lread(hFile, rgbFileBuf, sizeof(rgbFileBuf))) == 0)
                goto LDone;
            iFileBuf = 0;
            }
        ch = rgbFileBuf[iFileBuf++];
        if (iStf < cchStfSrcDir)
            {
            if (ch == szcStfSrcDir[iStf])
                iStf++;
            else
                iStf = 0;
            continue;
            }
        if(fQuote)
            fQuote = FALSE;
        else if (ch == '"')
            {
            fQuote = TRUE;
            continue;
            }
        else if (ch == '\x0d' || ch == '\t')
            break;
        *pchBuf++ = (CHAR)ch;
        /* Case of having the last character be a DBCS character */
        if (IsDBCSLeadByte(ch))
            {
            if (iFileBuf == cFileBuf)
                {
                _lread(hFile, &ch, 1);
                *pchBuf++ = (CHAR) ch;
                }
            else
                *pchBuf++ = rgbFileBuf[iFileBuf++];
            }
        }

LDone:
    *pchBuf = 0;
    if (rgbBuf[0] == 0)
        {
        fRenameStf = fTrue;
        goto LClose;
        }
    chDrv = (char)toupper(rgbBuf[0]);
    if (rgbBuf[1] != ':' || chDrv < 'A' || chDrv > 'Z')
        {
        /* We know this is a network drive - UNC Name */
        drvType = EX_DRIVE_REMOTE;
        Assert(rgbBuf[0] == '\\' && rgbBuf[1] == '\\');
        }
    else
        {
        drvType = GetDriveTypeEx(chDrv - 'A');
        }

    lstrcpy(pchSrcDrive, rgbBuf);
    if (*AnsiPrev(rgbBuf, pchBuf) != '\\')
        {
        *pchBuf++ = '\\';
        *pchBuf = 0;
        }

    lstrcat(rgbBuf, "Setup.ini");

    while (!fOpen)
        {
        switch (drvType)
            {
        case EX_DRIVE_FIXED:
        case EX_DRIVE_REMOTE:
        case EX_DRIVE_RAMDISK:
        case EX_DRIVE_INVALID:
        default:
            if (!fFirst)
                {
                /* We've been here before */
                DispErrBrc(brcConnectToSource, TRUE, MB_OK | MB_ICONSTOP, pchSrcDrive, NULL, NULL);
                brc = brcMax;
                goto LClose;
                }
            /* The setup stuff should be available, change directories and go for it */
            break;
        case EX_DRIVE_FLOPPY:
        case EX_DRIVE_REMOVABLE:
            /* Ask to insert disk */
            pchMsg = rgchInsertDiskMsg;
            goto LAskUser;
            break;
        case EX_DRIVE_CDROM:
            /* Ask to insert their CD */
            pchMsg = rgchInsertCDMsg;
LAskUser:
            if (fFirst)
                {
                if (DispErrBrc(brcString, FALSE, MB_ICONEXCLAMATION|MB_OKCANCEL,
                        pchMsg, NULL, NULL) != IDOK)
                    {
                    brc = brcUserQuit;
                    goto LClose;
                    }
                }
            else
                {
                if (DispErrBrc(brcInsCDRom2, FALSE, MB_ICONEXCLAMATION|MB_OKCANCEL,
                        rgbBuf, pchMsg, NULL) != IDOK)
                    {
                    brc = brcUserQuit;
                    goto LClose;
                    }
                }
            break;
            }

        if ((hFileT = _lopen(rgbBuf, OF_READ)) != HFILE_ERROR)
            {
            _lclose(hFileT);
            fOpen = fTrue;
            }

        fFirst = FALSE;

        }

    brc = brcOkay;

LClose:
    _lclose(hFile);

    /* If we can't find the source path in the maintenance mode .STF,
    *   assume it's corrupted and rename it, so when the user runs again
    *   from the source image, we will just run in 'floppy' mode,
    *   avoiding the bad .STF file.
    *   (NOTE: Assumes /W is only used in maint mode!!)
    */
    if (fRenameStf)
        {
        FRenameBadMaintStf(pchStf);
        brc = brcNoStf;
        }

    return brc;

}


/*
****************************************************************************/
BOOL FRenameBadMaintStf ( SZ szStf )
{
    CHAR rgch[_MAX_FNAME];

    _splitpath(szStf, szNull, szNull, rgch, szNull);
    if (*rgch == '\0')
        lstrcpy(rgch, "stf");

    Assert(lstrlen(rgch) + 4 < sizeof rgch);
    lstrcat(rgch, ".000");

    rename(szStf, rgch);

    /* Remove the original .STF in case the rename failed
    *   (probably due to a previously renamed .STF file).
    */
    remove(szStf);

    return (fTrue);     /* Always returns true */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\ctl3d.h ===
/*-----------------------------------------------------------------------
|	CTL3D.DLL
|	
|	Adds 3d effects to Windows controls
|
|	See ctl3d.doc for info
|		
-----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {
#endif


BOOL WINAPI Ctl3dSubclassDlg(HWND, WORD);
BOOL WINAPI Ctl3dSubclassDlgEx(HWND, DWORD);
WORD WINAPI Ctl3dGetVer(void);
BOOL WINAPI Ctl3dEnabled(void);
HBRUSH WINAPI Ctl3dCtlColor(HDC, LONG);	// ARCHAIC, use Ctl3dCtlColorEx
HBRUSH WINAPI Ctl3dCtlColorEx(UINT wm, WPARAM wParam, LPARAM lParam);
BOOL WINAPI Ctl3dColorChange(void);
BOOL WINAPI Ctl3dSubclassCtl(HWND);
LONG WINAPI Ctl3dDlgFramePaint(HWND, UINT, WPARAM, LPARAM);

BOOL WINAPI Ctl3dAutoSubclass(HANDLE);

BOOL WINAPI Ctl3dRegister(HANDLE);
BOOL WINAPI Ctl3dUnregister(HANDLE);

/* Ctl3dSubclassDlg3d flags */
#define CTL3D_BUTTONS		0x0001
#define CTL3D_LISTBOXES		0x0002		
#define CTL3D_EDITS			0x0004	
#define CTL3D_COMBOS			0x0008		
#define CTL3D_STATICTEXTS	0x0010		
#define CTL3D_STATICFRAMES	0x0020

#define CTL3D_NODLGWINDOW       0x00010000
#define CTL3D_ALL				0xffff

#define WM_DLGBORDER (WM_USER+3567)
/* WM_DLGBORDER *(int FAR *)lParam return codes */
#define CTL3D_NOBORDER		0
#define CTL3D_BORDER			1

#define WM_DLGSUBCLASS (WM_USER+3568)
/* WM_DLGSUBCLASS *(int FAR *)lParam return codes */
#define CTL3D_NOSUBCLASS	0
#define CTL3D_SUBCLASS		1

/* Resource ID for 3dcheck.bmp (for .lib version of ctl3d) */
#define CTL3D_3DCHECK 26567


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\debugids.h ===
/***************************************************************************
**
**	File:		debugids.h
**	Purpose:	Debug message IDs
**	Notes:	IDs must be assigned within the ranges indicated below
**
****************************************************************************/

typedef struct _DMS  /* internal debug message table structure */
{
	UINT        iMsg;
	const CHAR* szMsg;
} DMS;

#define MID_DUMP_MESSAGES (8<<16) /* special ID to dump all messages to log */

/* DEBUG ERROR MESSAGES FROM MSSETUP.DLL - MUST BE IN RANGE 256 - 511 */

#define IDS_UnknownFailure       256
#define IDS_DEF_SystemError	   257
#define IDS_DEF_OutOfMemory	   258
#define IDS_DEF_OutOfDiskSpace	259

#define IDS_INFBadSectionLabel  272
#define IDS_INFHasNulls         273
#define IDS_INFBadFDLine        275
#define IDS_INFBadRSLine        276
#define IDS_INFInvalidFirstChar 277
#define IDS_FDDid              	278
#define IDS_FDSrcFile          	279
#define IDS_FDAppend           	280
#define IDS_FDBackup           	281
#define IDS_FDCopy             	282
#define IDS_FDDate             	283
#define IDS_FDDecompress       	284
#define IDS_FDLang             	285
#define IDS_FDOverwrite        	286
#define IDS_FDReadOnly         	287
#define IDS_FDRemove           	288
#define IDS_FDRename           	289
#define IDS_FDRenameSymbol     	290
#define IDS_FDRoot             	291
#define IDS_FDSetTime          	292
#define IDS_FDShared           	293
#define IDS_FDSize             	294
#define IDS_FDSystem           	295
#define IDS_FDTime             	296
#define IDS_FDUndo             	297
#define IDS_FDVersion          	298
#define IDS_FDVital            	299
#define IDS_FDAppendRenameRoot 	300
#define IDS_FDAppendBackup     	301
#define IDS_FDCopyRemove       	302

/* DEBUG ERROR MESSAGES FROM ACMSETUP.EXE - MUST BE IN RANGE 768 - 1023 */

#define IDS_DestDirNotInTree	768
#define IDS_NoGetTargetFileName	769
#define IDS_FrameBitmapParse	770
#define	IDS_TopLevelPlor		771
#define	IDS_BadObjDestDir		772
#define	IDS_AppSearchTopOnly	773
#define	IDS_AppSearchSearchOnly	774
#define	IDS_SearchOnlyAppSearch	775
#define	IDS_RefProofLines		776
#define	IDS_RefLexLines			777
#define	IDS_CantSearch			778

#define	IDS_ConfigDirYes		784
#define	IDS_BadNumVisualObjs	785
#define	IDS_NoLoadBmp			786
#define	IDS_MissBmpField		787
#define	IDS_MustBeTrigger		788
#define	IDS_MissDlgTitle		789
#define	IDS_DataNotEmpty		790

#define	IDS_BadDataValue		795
#define	IDS_ExtraDataValue		796
#define	IDS_BadDllValue			797
#define	IDS_BadIdValue			798
#define	IDS_BadProcValue		799

#define	IDS_BadIni1File			807
#define	IDS_BadIni1Sect			808
#define	IDS_BadIni1Key			809
#define	IDS_BadIni2File			810
#define	IDS_BadIni2Sect			811
#define	IDS_BadIni2Key			812
#define	IDS_BadEmptyFileName	814
#define	IDS_BadFileName			816
#define	IDS_BadVersionField		817
#define	IDS_BadIniFile			819
#define	IDS_BadIniSect			820
#define	IDS_BadIniKey			821
#define	IDS_BadIniVal			822
#define	IDS_BadIniIndex			823
#define	IDS_BadInfSection		824
#define	IDS_BadInfKey			825
#define	IDS_BadObjectList		827
#define	IDS_BadObjectRef		828
#define	IDS_BadResourceType		829
#define	IDS_BadResourceId		830
#define	IDS_BadHexData			834

#define	IDS_NoDictObjList		857
#define	IDS_BadCountryCode		862
#define	IDS_BadLexType			863
#define	IDS_BadLanguage			864
#define	IDS_BadRegDataField		879
#define	IDS_BadTriggerObj		881
#define	IDS_NoThenOrElse	    882
#define	IDS_BadThen				883
#define	IDS_BadElse				884
#define	IDS_MissingData			885
#define	IDS_MissingVisualData	890
#define	IDS_BadVisualData		891
#define	IDS_BadHiddenData		892
#define	IDS_MaxObjTooHigh		901
#define	IDS_COMP_CHECK_NOLIB	904
#define	IDS_COMP_CHECK_NOPROC	905
#define	IDS_STR_BADCKDIR_VAL	906
#define	IDS_STR_BADDSTDIR		907
#define	IDS_STR_ERR_OBJID		908
#define IDS_STR_BADADMINDIR     909

#define	IDS_STR_DUPOBJID		913
#define	IDS_STR_BAD_FIELD		914
#define	IDS_BadDefaultPath		915
#define	IDS_BadSubdirValue		918
#define	IDS_BadExtendedChars	919
#define	IDS_BadDialogIfDefault	920
#define	IDS_BadEnvirName		924

#define	IDS_BadRegistryKey		932
#define	IDS_BadRegIndexValue	933

#define	IDS_BadAppName			936
#define	IDS_BadAppVersion		937
#define	IDS_BadAdminRoot		938
#define	IDS_BadFloppyRoot		939
#define	IDS_BadNetworkRoot		940
#define	IDS_BadMaintRoot		941
#define	IDS_BadBatchRoot		942
#define	IDS_NoMaintSrcDir		943
#define IDS_BadMSAPPSDrive		944
#define	IDS_BadStfVersion		945
#define	IDS_UnknownTopLevel		946
#define	IDS_BadNetLogPath		947

#define	IDS_BadProcDataValue	959
#define	IDS_BadCostDataValue	960

#define IDS_BadAdminSubDir		965

#define IDS_BadShortcutPath		990
#define IDS_BadRegValue			991
#define IDS_BadItemName			992
#define IDS_BadTargetFileSpec	993
#define IDS_BadIconFileSpec		994
#define IDS_BadWorkingDirSpec	995
#define IDS_BadShortcutName		996
#define IDS_BadProgramGroupName	997
#define IDS_BadCommandLineSpec	998
#define IDS_SelfRegDLLNotFound	999
#define IDS_SelfRegDLLNotLoaded	1000
#define IDS_SelfRegEntryPointMissing	1001
#define IDS_CompanionNotInMMode	1002
#define IDS_BadInfModeTrigger	1003
#define IDS_InfModeNoCompDll	1004
#define IDS_SharedFnameIncompat	1005
#define IDS_VerCheckIncompat	1006

/* DEBUG LOG MESSAGES FROM MSSETUP.DLL - MUST BE IN RANGE 1280 - 1535 */

#define	IDS_LF_IgnoreMissingSrcFile		1281


/* DEBUG LOG MESSAGES FROM ACMSETUP.EXE - MUST BE IN RANGE 1792 - 2047 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\acmhook.h ===
#pragma warning(disable:4001)

////////////////////////////////////////////////////////////////////////////////
//	File:		ACMHOOK.H
//	Purpose:	Types, data structures, and function definitions for
//				hooking out the standard acme ui
//	Notes:		I - input
//				O - output
////////////////////////////////////////////////////////////////////////////////

#if defined(__cplusplus)
extern "C" {
#endif //__cplusplus

#define cbMaxSz 256						// maximum string buffer size
#define DECL __cdecl					// calling convention of hook procedures

typedef enum {							// Dialog Hook Return Code
	shrcOk,								// proceed with setup
	shrcCancel,							// cancel/quit button was pushed
	shrcIgnore,							// ignore button was pushed
	shrcOption,							// "change option" button was pushed
	shrcDirectory,						// "change directory" button was pushed
	shrcRefresh,						// activation change - refresh data
	shrcFail,							// error occurred - cancel setup
	shrcNone,							// don't remove any shared components
	shrcKeep,							// don't remove this shared component
	shrcRemoveAll,						// remove all app/shared components
	shrcRemove,							// remove this shared component
	shrcReinstall,						// re install components
	shrcFrameRegisterFail,				// error registering class
	shrcFrameCreateFail					// error creating frame window
	} SHRC;

typedef struct {						// Hook Data
	LONG cb;							// structure size (I)
	CHAR rgchHelpFile[cbMaxSz];			// help file (I)
	DWORD dwHelpContext;				// help context (I)
	} HD, *PHD;

typedef struct {						// Welcome Dialog Hook Data
	HD hd;								// common hook data
	BOOL fMaint;						// maintenace mode setup (I)
	} WDHD, *PWDHD;

typedef
	SHRC (DECL *LPFNSHRCWDH)(PWDHD);	// Welcome Dialog Hook

typedef struct {						// Modules in Use Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchModuleList[cbMaxSz];		// names of modules in use (I)
	} MUDHD, *PMUDHD;

typedef
	SHRC (DECL *LPFNSHRCMUDH)(PMUDHD);	// Modules in Use Dialog Hook

typedef enum {							// Copy Disincentive Dialog Hook Mode
	cddhmNameOrg,						// allow the name and org to be modified
	cddhmName,							// allow only the name to be modified
	cddhmOrg							// allow only the org to be modified
	} CDDHM;

typedef struct {						// Copy Disincentive Dialog Hook Data
	HD hd;								// common hook data
	CDDHM cddhm;						// CD mode (I)
	CHAR rgchName[cbMaxSz];				// name string (I/O)
	CHAR rgchOrg[cbMaxSz];				// organization string (I/O)
	} CDDHD, *PCDDHD;

typedef
	SHRC (DECL *LPFNSHRCCDDH)(PCDDHD);	// Copy Disincentive Dialog Hook

typedef enum {							// Serial Number Dialog Hook Mode
	sndhmNormal,						// the normal/default functionality
	sndhmCDKey,							// the cdkey functionality
	sndhmOEM							// the OEM functionality
	} SNDHM;

typedef struct {						// Serial Number Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchSerNum[cbMaxSz];			// serial number string (I/O)
	SNDHM sndhm;						// serial number dialog hook mode (I)
	} SNDHD, *PSNDHD;

typedef
	SHRC (DECL *LPFNSHRCSNDH)(PSNDHD);	// Serial Number Dialog Hook

typedef enum {							// Already Used Dialog Hook Mode
	audhmBad,							// setup.ini corrupted
	audhmOrg,							// organization used
	audhmName,							// name used
	audhmBoth							// both name and org used
	} AUDHM;

typedef struct {						// Already Used Dialog Hook Data
	HD hd;								// common hook data
	AUDHM audhm;						// mode (I)
	CHAR rgchName[cbMaxSz];				// name string (I)
	CHAR rgchOrg[cbMaxSz];				// organization string (I)
	} AUDHD, *PAUDHD;

typedef
	SHRC (DECL *LPFNSHRCAUDH)(PAUDHD);	// Already Used Dialog Hook

typedef struct {						// Disk Locked Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchDir[cbMaxSz];				// directory string (I)
	} DLDHD, *PDLDHD;

typedef
	SHRC (DECL *LPFNSHRCDLDH)(PDLDHD);	// Disk Locked Dialog Hook

typedef enum {							// Copy Disincentive Dialog Hook Mode
	cpdhmRemind,						// piracy reminder
	cpdhmWarn,							// piracy warning
	cpdhmWarn2							// nasty ;-) piracy warning
	} CPDHM;

typedef struct {						// CD Piracy Dialog Hook Data
	HD hd;								// common hook data
	CPDHM cpdhm;						// mode (I)
	} CPDHD, *PCPDHD;

typedef
	SHRC (DECL *LPFNSHRCCPDH)(PCPDHD);	// CD Piracy Dialog Hook

typedef enum {							// DiRectory Dialog Hook Mode
	drdhmNotExistDir,					// directory does not exist
	drdhmAppExistsOld,					// older version in directory
	drdhmAppExistsNew					// new version in directory
	} DRDHM;

typedef struct {						// DiRectory Dialog Hook Data
	HD hd;								// common hook data
	DRDHM drdhm;						// mode (I)
	CHAR rgchComponent[cbMaxSz];		// component name string (I)
	CHAR rgchPath[cbMaxSz];				// path (I)
	} DRDHD, *PDRDHD;

typedef
	SHRC (DECL *LPFNSHRCDRDH)(PDRDHD);	// DiRectory Dialog Hook

typedef struct {						// Get Path Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchFilename[cbMaxSz];			// filename string - may be "" (I)
	CHAR rgchVersion[cbMaxSz];			// version string - may be "" (I)
	CHAR rgchSrcDir[cbMaxSz];			// source distory string - may be "" (I)
	LONG cSubNodeMax;					// count of maximumum subnodes (I)
	BOOL fAllowExtendedChars;			// if extended characters allowed (I)
	CHAR rgchComponent[cbMaxSz];		// component name string - may be "" (I)
	BOOL fNeedNewEmptyDir;				// the directory should be empty (I)
	CHAR rgchPath[cbMaxSz];				// path to edit (I/O)
	} GPDHD, *PGPDHD;

typedef
	SHRC (DECL *LPFNSHRCGPDH)(PGPDHD);	// Get Path Dialog Hook

typedef struct {						// App Main BuTtoN
	CHAR rgchLabel[cbMaxSz];			// button label string (I)
	CHAR rgchText[cbMaxSz];				// description string (I)
	HBITMAP hbm;						// bitmap for button (I)
	} AMBTN, *PAMBTN;
	
typedef struct {						// App Main Dialog Hook Data
	HD hd;								// common hook data
	LONG iambtnSelected;				// which button selected (I/O)
	LONG cambtn;						// number of buttons (I)
	CHAR rgchPath[cbMaxSz];				// directory path (I)
	HGLOBAL hrgambtn;					// button data (I)
	} AMDHD, *PAMDHD;

typedef
	SHRC (DECL *LPFNSHRCAMDH)(PAMDHD);	// App Main Dialog Hook

typedef struct {						// ProgMan Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchGroup[cbMaxSz];			// suggested group name (I/O)
	LONG crgchExisting;					// number of existing groups (I)
	HGLOBAL hrgrgchExisting;			// existing group names (I)
										// [crgchExisting][cbMaxSz]
	} PMDHD, *PPMDHD;

typedef
	SHRC (DECL *LPFNSHRCPMDH)(PPMDHD);	// ProgMan Dialog Hook Data

typedef struct {						// ReBoot Dialog Hook Data
	HD hd;								// common hook data
	} RBDHD, *PRBDHD;

typedef
	SHRC (DECL *LPFNSHRCRBDH)(PRBDHD);	// ReBoot Dialog Hook

typedef struct {						// Reboot Failed Dialog Hook Data
	HD hd;								// common hook data
	} RFDHD, *PRFDHD;

typedef
	SHRC (DECL *LPFNSHRCRFDH)(PRFDHD);	// Reboot Failed Dialog Hook

typedef enum {							// eXiT Dialog Hook Mode
	xtdhmOk,							// installation was successful
	xtdhmError,							// installation failed
	xtdhmQuit							// installation was cancelled
	} XTDHM;

typedef struct {						// eXiT Dialog Hook  Data
	HD hd;								// common hook data
	XTDHM xtdhm;						// mode (I)
	} XTDHD, *PXTDHD;

typedef
	SHRC (DECL *LPFNSHRCXTDH)(PXTDHD);	// eXiT Dialog Hook 

typedef struct {						// Disk Space iTeMs
	CHAR rgchDesc[cbMaxSz];				// description string (I)
	CHAR rgchSize[cbMaxSz];				// size (I)
	} DSTM, *PDSTM;

typedef struct {						// Disk Space iTeMs
	LONG cbReq;							// bytes required on current drive (I)
	LONG cbNeed;						// bytes needed on current drive (I)
	} DSDRV, *PDSDRV;

typedef struct {						// Disk Space Dialog Hook Data
	HD hd;								// common hook data
	BOOL fAdmin;						// whether in admin mode or not (I)
	LONG idsdrvCur;						// the selected drive (I/O)
	LONG cdstm;							// number of items (I)
	HGLOBAL hrgdstm;					// the items
	LONG cdsdrv;						// number of drives (I)
	HGLOBAL hrgdsdrv;					// the drives
	} DSDHD, *PDSDHD;

typedef
	SHRC (DECL *LPFNSHRCDSDH)(PDSDHD);	// Disk Space Dialog Hook

typedef struct {						// OPtions Dialog iTeMs
	CHAR rgchTitle[cbMaxSz];			// title string (for listbox) (I)
	CHAR rgchDesc[cbMaxSz];				// description string (I)
	CHAR rgchDir[cbMaxSz];				// the directory string (I)
	LONG cb;							// number of bytes item requires (I)
	BOOL fChecked;						// if the item is chosen (I/O)
	BOOL fChangeOption;					// enable the "change option" button
	BOOL fChangeDirectory;				// enable the "change directory" button
	BOOL fVital;						// the item is vital
	} OPTM, *POPTM;

typedef struct {						// OPtions Dialog Hook Data
	HD hd;								// common hook data
	BOOL fMaint;						// maintenace mode setup (I)
	BOOL fTop;							// if top level dialog (I)
	LONG coptm;							// number of option items (I)
	LONG ioptmCur;						// currently selected item (I/O)
	CHAR rgchDrvCur[cbMaxSz];			// drive of currently selected item (I)
	LONG cbDrvCurReq;					// bytes needed on current drive (I)
	LONG cbDrvCurAvail;					// bytes available on current drive (I)
	LONG cToAdd;						// number of items to add (I)
	LONG cToRemove;						// number of items to remove (I)
	HGLOBAL hrgoptm;					// the option items (I)
	} OPDHD, *POPDHD;

typedef
	SHRC (DECL *LPFNSHRCOPDH)(POPDHD);	// OPtions Dialog Hook

typedef struct {						// Admin Warn Hook Data
	HD hd;								// common hook data
	} AWDHD, *PAWDHD;

typedef
	SHRC (DECL *LPFNSHRCAWDH)(PAWDHD);	// Admin Warn Hook

typedef struct {						// MsApps directory Hook Data
	HD hd;								// common hook data
	CHAR rgchPath[cbMaxSz];				// directory path (I)
	} MADHD, *PMADHD;

typedef
	SHRC (DECL *LPFNSHRCMADH)(PMADHD);	// MsApps directory Hook

typedef enum {							// Confirm Server Dialog Hook Mode'
	csdhmName,							// use server name
	csdhmLetter							// use drive letter
	} CSDHM;

typedef struct {						// Confirm Server Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchName[cbMaxSz];				// component name (I)
	CHAR rgchPath[cbMaxSz];				// directory path (I)
	CHAR rgchNetPath[cbMaxSz];			// network path (I/O)
	CHAR rgchServer[cbMaxSz];			// network server (I/O)
	CHAR chDrive;						// drive letter (I/O)
	CSDHM csdhm;						// use name or drive letter (O)
	} CSDHD, *PCSDHD;

typedef
	SHRC (DECL *LPFNSHRCCSDH)(PCSDHD);	// Confirm Server Dialog Hook

typedef enum {							// Shared Files Dialog Hook Mode
	sfdhmServer,						// put shared files on server;
	sfdhmLocal,							// put shared files on local hard drive
	sfdhmChoice							// user can choose in network mode
	} SFDHM;

typedef struct {						// Shared Files Dialog Hook Data
	HD hd;								// common hook data
	BOOL fAdmin;						// whether in admin mode or not (I)
	SFDHM sfdhm;						// shared files mode (O)
	} SFDHD, *PSFDHD;

typedef 
	SHRC (DECL *LPFNSHRCSFDH)(PSFDHD);	// Shared Files Dialog Hook

typedef struct {						// Remove Shared Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchComponent[cbMaxSz];		// component name (I)
	} RSDHD, *PRSDHD;

typedef
	SHRC (DECL *LPFNSHRCRSDH)(PRSDHD);	// Remove Shared Dialog Hook

typedef struct {						// Ask Quit Dialog Hook Data
	HD hd;								// common hook data
	} AQDHD, *PAQDHD;

typedef
	SHRC (DECL *LPFNSHRCAQDH)(PAQDHD);	// Ask Quit Dialog Hook

typedef struct {						// Invalid Net Path Dialog Hook Data
	HD hd;								// common hook data
	} INDHD, *PINDHD;

typedef
	SHRC (DECL *LPFNSHRCINDH)(PINDHD);	// Invalid Net Path Dialog Hook

typedef struct {						// No Connection Dialog Hook Data
	HD hd;								// common hook data
	} NCDHD, *PNCDHD;

typedef
	SHRC (DECL *LPFNSHRCNCDH)(PNCDHD);	// No Connection Dialog Hook

typedef enum {							// Start Modeless Dialog Hook Mode
	smdhmSearching,						// searching for components
	smdhmCheckingDisk,					// checking disk space
	smdhmModifyingSys					// modifying system
	} SMDHM;

typedef struct {						// Start Modeless Dialog Hook
	HD hd;								// common hook data
	SMDHM smdhm;						// modeless dialog type (I)
	HWND hwndParent;					// parent for modeless dialog (I)
	DWORD dwHook;						// value for End Modeless (O)
	} SMDHD, *PSMDHD;

typedef
	SHRC (DECL *LPFNSHRCSMDH)(PSMDHD);	// Start Modeless Dialog Hook

typedef struct {						// End Modeless Dialog Hook
	HD hd;								// common hook data
	DWORD dwHook;						// value from Start Modeless (I)
	} EMDHD, *PEMDHD;

typedef
	SHRC (DECL *LPFNSHRCEMDH)(PEMDHD);	// End Modeless Dialog Hook

typedef struct {						// Create Frame Hook Data
	LONG cbCFHD;						// structure size (I)
	WNDCLASS wc;						// default RegisterClass data (I)
	CREATESTRUCT cs;					// default CreateWindow data (I)
	HWND hwndFrame;						// new frame window handle (O)
	int nCmdShow;						// default parm for ShowWindow (I)
	} CFHD, *PCFHD;

typedef
	SHRC (DECL *LPFNSHRCCFH)(PCFHD);	// Create Frame Hook

typedef struct {						// Message Box Hook Data
	LONG cbMBHD;						// structure size (I)
	HWND hwndOwner;						// handle of owner window (I)
	LPCSTR lpszText;					// text in message box (I)
	LPCSTR lpszTitle;					// title of message box (I)
	UINT uStyle;						// style of message box (I)
	int idRet;							// return value of message box (O)
	} MBHD, *PMBHD;

typedef
	SHRC (DECL *LPFNSHRCMBH)(PMBHD);	// Message Box Hook

typedef struct {						// Gauge Init Hook Data
	LONG cbGIHD;						// structure size (I)
	} GIHD, *PGIHD;

typedef
	SHRC (DECL *LPFNSHRCGIH)(PGIHD);	// Gauge Init Hook

typedef struct {						// Gauge Open Hook Data
	LONG cbGOHD;						// structure size (I)
	HWND hwndParent;					// handle of parent (frame) window (I)
	BOOL *pfAbort;						// flag to set when cancel pushed
	} GOHD, *PGOHD;

typedef
	SHRC (DECL *LPFNSHRCGOH)(PGOHD);	// Gauge Open Hook

typedef struct {						// Gauge Close Hook Data
	LONG cbGCHD;						// structure size (I)
	} GCHD, *PGCHD;

typedef
	SHRC (DECL *LPFNSHRCGCH)(PGCHD);	// Gauge Close Hook

typedef struct {						// Gauge Title Hook Data
	LONG cbGTHD;						// structure size (I)
	CHAR rgchTitle[cbMaxSz];			// new title string (I)
	} GTHD, *PGTHD;

typedef
	SHRC (DECL *LPFNSHRCGTH)(PGTHD);	// Gauge Title Hook

typedef struct {						// Gauge teXt Hook Data
	LONG cbGXHD;						// structure size (I)
	CHAR rgchSrc[cbMaxSz];				// new source string (I)
	CHAR rgchDst[cbMaxSz];				// new destination string (I)
	} GXHD, *PGXHD;

typedef
	SHRC (DECL *LPFNSHRCGXH)(PGXHD);	// Gauge teXt Hook

typedef struct {						// Gauge Range Hook Data
	LONG cbGRHD;						// structure size (I)
	LONG iLim;							// new range limit (I)
	} GRHD, *PGRHD;

typedef
	SHRC (DECL *LPFNSHRCGRH)(PGRHD);	// Gauge Range Hook

typedef struct {						// Gauge Position Hook Data
	LONG cbGPHD;						// structure size (I)
	LONG iCur;							// new current position (I)
	} GPHD, *PGPHD;

typedef
	SHRC (DECL *LPFNSHRCGPH)(PGPHD);	// Gauge Position Hook

typedef struct {						// Gauge Delta Hook Data
	LONG cbGDHD;						// structure size (I)
	LONG dCur;							// delta to current position (I)
	} GDHD, *PGDHD;

typedef
	SHRC (DECL *LPFNSHRCGDH)(PGDHD);	// Gauge Delta Hook

typedef struct {						// Gauge Yield Hook Data
	LONG cbGYHD;						// structure size (I)
	} GYHD, *PGYHD;

typedef
	SHRC (DECL *LPFNSHRCGYH)(PGYHD);	// Gauge Yield Hook

typedef struct {						// Filecopy Warning Hook Data
	LONG cbFWHD;						// structure size (I)
	CHAR rgchPath[cbMaxSz];					// path to file being copied
	} FWHD, *PFWHD;

typedef
	SHRC (DECL *LPFNSHRCFWH)(PFWHD);	// Filecopy Warning Hook

#if defined(__cplusplus)
}
#endif //__cplusplus

#pragma warning(default:4001)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\odbcexec.h ===
/***************************************************************************
**
**	File:			odbcexec.h
**	Purpose:		Contains defines used by both the 16 and 32 bit ends
**					of the ODBC communication channel.
**
**	Notes:			This header files contains code, so it cannot be
**					included in more than one compilation unit.  The
**					reason it contains code is that GetTransferFileName()
**					is used on both the 16 and 32 bit sides, and this is
**					simpler than creating a shared .cpp file just for it.
**
****************************************************************************/

#ifndef ODBCEXEC_H
#define ODBCEXEC_H

#include <string.h>

#define EXE_NAME "ODBCEXEC.EXE"
#define SZ_TRANSFER_FILE_NAME "SendODBC"

#define ODBC_BUFFER_SIZE 256

/*
 * Returns the name of the file used to pass information from the 32 bit
 * process to the 16 bit process.  This file is in the Windows dir,
 * and has name SZ_TRANSFER_FILE_NAME (defined in ODBCEXEC.H).
 */
char *GetTransferFileName()
{
	static char rgchImage[128];
	UINT cb=GetWindowsDirectory(rgchImage, sizeof rgchImage);

	// Add a slash unless it's the root
	if (cb > 3)
		{
		rgchImage[cb] = '\\';
		rgchImage[cb+1] = '\0';
		}

	strcat(rgchImage, SZ_TRANSFER_FILE_NAME);
	return rgchImage;
}

#endif /* ODBCEXEC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\setupapi.h ===
/***************************************************************************
**
**      File:                   SETUPAPI.H
**      Purpose:                Prototypes for the Setup API.
**      Notes:
**
****************************************************************************/

#ifndef SETUPAPI_H
#define SETUPAPI_H

#define ACME_LOGFILE    1
/* Plenty of macros to make the port to Win32 easier.
 * e.g. #define _fmemcmp memcmp
 */
#include <windowsx.h>

/* Ignore the following declarators */
#define _based(seg)
#define _loadds
#define __loadds
#define __export

/* Undef CopyFile, which WIN32 defines as CopyFileA, an API */
#undef CopyFile

/*
 * In Win32, all the Api's work directly with ANSI buffers, so we no longer
 * want to use conversions.
 */
#undef OemToAnsi
#undef AnsiToOem
#define OemToAnsi(o,a) lstrcpy(a,o)
#define AnsiToOem(a,o) lstrcpy(o,a)

#ifdef _DEBUG
#define DEBUG
#endif


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif

/* Private toolkit messages used by ACMSETUP and custom actions */

#define  STF_MESSAGE        (WM_USER + 0x8000)
#define  STF_REINITDIALOG   (STF_MESSAGE + 12)
#define  STF_ACTIVATEAPP    (STF_MESSAGE + 17)

/*
 *      Setup Error Codes.  These are the values passed to the user supplied
 *      error function.
 */
typedef unsigned int  SEC;              /* Setup Error Code */
typedef SEC *         PSEC;             /* Ptr to Setup Error Code */

#define secOk         ((SEC)   0)
#define secErr        ((SEC)1024)
#define secQuit       ((SEC)1025)
#define secRestart    ((SEC)1026)	/* Windows is being restarted */


/*
 *      Window Visibility Modes - InitSetupToolkit parameter
 */
typedef UINT WVM;       /* Window Visibility Mode */

#define wvmNormal     ((WVM)0)
#define wvmMaximized  ((WVM)1)
#define wvmMinimized  ((WVM)2)


/*
 *      CoMmand Option flags
 */
typedef UINT CMO;       /* CoMmand Option */

#define cmoVital      ((CMO)0x1)
#define cmoCopy       ((CMO)0x2)
#define cmoUndo       ((CMO)0x4)
#define cmoRoot       ((CMO)0x8)
#define cmoDecompress ((CMO)0x10)
#define cmoTimeStamp  ((CMO)0x20)
#define cmoReadOnly   ((CMO)0x40)
#define cmoBackup     ((CMO)0x80)
#define cmoForce      ((CMO)0x100)
#define cmoRemove     ((CMO)0x200)
#define cmoOverwrite  ((CMO)0x400)
#define cmoAppend     ((CMO)0x800)
#define cmoPrepend    ((CMO)0x1000)
#define cmoShared     ((CMO)0x2000)
#define cmoSystem     ((CMO)0x4000)
/* NOTE oefCabinet in COMSTF.H uses 0x8000 */
#define cmoNone       ((CMO)0x0)
#define cmoAll        ((CMO)0xffff)


/*
 *      File Exist Modes - DoesFileExist parameter
 *      (order is important)
 */
typedef UINT FEM;       /* File Exist Mode */

#define femExists     ((FEM)0)
#define femRead       ((FEM)1)
#define femWrite      ((FEM)2)
#define femReadWrite  ((FEM)3)
#define femMin        ((FEM)0)
#define femMax        ((FEM)4)


/*
 *      Size ChecK Modes - SetSizeCheckMode parameter
 */
typedef UINT SCKM;      /* Size ChecK Mode */

#define sckmOff       ((SCKM)0)
#define sckmOnIgnore  ((SCKM)1)
#define sckmOnFatal   ((SCKM)2)


/*
 *      Silent Mode - SetSilentMode parameter
 */
typedef UINT SM;        /* Silent Mode */

#define smNormal        ((SM)0x0000)
#define smNoDialogs     ((SM)0x0001)
#define smNoCopyGauge   ((SM)0x0002)
#define smTotallySilent ((SM) ~(0))


/*
 *      Current File Version - DoesSharedFileNeedCopying return type
 *
 *      NOTE - order is important - see FIBSECfv(cfv) macro below.
 */
typedef enum _CFV               /* Current File Version */
	{
	cfvNoFile,
	cfvLoVer,
	cfvDiffLang,
	cfvEqVer,
	cfvHiVer,
	cfvUnknown
	}  CFV;
typedef CFV * PCFV;             /* Ptr to Current File Version */
#define FIBSECfv(cfv)   (cfv > cfvEqVer)


typedef UINT WMD;               /* Windows MoDe */

#define wmdReal      0
#define wmdStandard  1
#define wmdEnhanced  2
#define wmdNT            3
#define wmdUnknown  10


typedef UINT CPU;               /* type of Central Processor Unit (or coprocessor) */

#define cpu8086          0
#define cpu80186         1
#define cpu80286         2
#define cpu80386         3
#define cpu80486         4
#define cpuR4000     5  /* for compatibility with CDrivers : Setup 2.0 */
						/* Ideally this should have been ifdef'd  to > 5 */
#define cpuMin           0
#define cpuMax           5
#define cpuUnknown  20


typedef VOID ( WINAPI *LPFNERROREXIT )( UINT );

#define SETUPAPI        WINAPI
#define SZ                      char *
#define CSZ                     char * const
#define SZC                     const char *
#define CSZC            const char * const

extern VOID SETUPAPI AddBlankToBillboardList ( LONG lTicks );
extern VOID SETUPAPI AddDos5Help ( SZ szProgName, SZ szProgHelp, CMO cmo );
extern VOID SETUPAPI AddLineToRestartFile ( SZ szLine );
extern VOID SETUPAPI AddListItem ( SZ szSymbol, SZ szItem );
extern VOID SETUPAPI AddSectionFilesToCopyList ( SZ szSect, SZ szSrcDir, SZ szDstDir );
extern VOID SETUPAPI AddSectionKeyFileToCopyList ( SZ szSect, SZ szKey, SZ szSrcDir, SZ szDstDir );
extern VOID SETUPAPI AddSpecialFileToCopyList ( SZ szSect, SZ szKey, SZ szSrcDir, SZ szDstPath );
extern VOID SETUPAPI AddSrcFileWithAttribsToCopyList ( SZ szSect, SZ szKey, SZ szSrcPath, SZ szDstPath );
extern VOID SETUPAPI AddShareToAutoexec ( SZ szSrc, SZ szDst, BOOL fConfig, BOOL fNeedsNewLine, SZ szDefPath, UINT wMinLock, UINT wMinBuf, UINT wMaxLock, UINT wMaxBuf, CMO cmo );
extern VOID SETUPAPI AddToBillboardList ( SZ szDll, UINT idDlg, SZ szProc, LONG lTicks );
extern VOID SETUPAPI BackupFile ( SZ szFullPath, SZ szBackup );
extern UINT SETUPAPI CbGetListItem ( SZ szSym, UINT uiItem, SZ szItem, UINT cbMax );
extern UINT SETUPAPI CbGetSymbolValue ( SZ szSymbol, SZ szValue, UINT cbMax );
extern VOID SETUPAPI ClearBillboardList ( VOID );
extern VOID SETUPAPI ClearCopyList ( VOID );
extern int  SETUPAPI CompareFileVersions ( SZ szVer1, SZ szVer2 );
extern VOID SETUPAPI CopyFile ( SZ szFullPathSrc, SZ szFullPathDst, CMO cmo, BOOL fAppend );
extern VOID SETUPAPI CopyFilesInCopyList ( BOOL fDeterrentEnabled );
extern VOID SETUPAPI CreateDir ( SZ szDir, CMO cmo );
extern VOID SETUPAPI CreateIniKeyValue ( CSZC cszcFile, CSZC cszcSect, CSZC cszcKey, CSZC cszcValue, CMO cmo );
extern VOID SETUPAPI CreateProgmanGroup ( SZ szGroup, SZ szPath, CMO cmo );
extern VOID SETUPAPI CreateProgmanItem ( SZ szGroup, SZ szItem, SZ szCmd, SZ szOther, CMO cmo );
extern VOID SETUPAPI CreateSysIniKeyValue ( SZ szFile, SZ szSect, SZ szKey, SZ szValue, CMO cmo );
extern VOID SETUPAPI DebugMessagesOn ( BOOL fMsgOn );
extern VOID SETUPAPI DeleteProgmanGroup ( SZ szGroup, CMO cmo );
extern VOID SETUPAPI DeleteProgmanItem ( SZ szGroup, SZ szItem, CMO cmo, BOOL fDelEmptyGroup );
extern BOOL SETUPAPI DeleteRegKeyValue32 ( HKEY hRootKey, CSZC cszcSubKey, CSZC cszcValueName );
extern int  SETUPAPI DoMsgBox ( CSZC cszcText, CSZC cszcCaption, UINT uiType );
extern int  SETUPAPI DoMsgBoxProc( CSZC cszcText, CSZC cszcCaption, UINT uiType );
extern BOOL SETUPAPI DoesDirExist ( SZ szDir );
extern BOOL SETUPAPI DoesFileExist ( SZ szFileName, FEM fem );
extern BOOL SETUPAPI DoesInfSectionExist ( SZ szSect );
extern BOOL SETUPAPI DoesInfSectionKeyExist ( SZ szSect, SZ szKey );
extern BOOL SETUPAPI DoesIniKeyExist ( SZ szFile, SZ szSect, SZ szKey );
extern BOOL SETUPAPI DoesIniSectionExist ( SZ szFile, SZ szSect );
extern CFV  SETUPAPI DoesSharedFileNeedCopying ( VOID );
extern BOOL SETUPAPI DoesSysIniKeyValueExist ( SZ szFile, SZ szSect, SZ szKey, SZ szValue );
extern VOID SETUPAPI DumpCopyList ( SZ szFile );
extern VOID SETUPAPI EndSetupToolkit ( VOID );
extern BOOL SETUPAPI ExitExecRestart ( VOID );
extern BOOL SETUPAPI FAddLineToRestartFile ( SZ szLine );
extern BOOL SETUPAPI FAddListItem ( SZ szSym, SZ szItem );
extern BOOL SETUPAPI FCloseHelp ( VOID );
extern BOOL SETUPAPI FGetShareParamsFromFile ( CSZC cszcFile, BOOL fConfig, UINT * puiLock, UINT * puiBuf, BOOL * pfAnyShare, SZ szPath, UINT cbBuf );
extern BOOL SETUPAPI FixupWinIniMsappsSection ( VOID );
extern BOOL SETUPAPI FLanguageMismatchInf ( SZ szSection, SZ szKey, SZ szDestPath );
extern BOOL SETUPAPI FLongFileNamesSuppressed ( VOID );
extern BOOL SETUPAPI FOpenLogFile ( CSZC cszcFile, BOOL fAppend );
extern BOOL SETUPAPI FRegCloseKey (HKEY hKey);
extern BOOL SETUPAPI FGetKeyInfo(HKEY hkey,LPDWORD lpcSubKeys,LPDWORD lpcValues);
extern BOOL SETUPAPI FRegCreateKey32(HKEY hRootKey, SZ szRegKey,HKEY* phKey);
extern BOOL SETUPAPI FWriteToLogFile ( CSZC cszc, BOOL fRequireLog );
extern BOOL SETUPAPI FCloseLogFile ( VOID );
extern BOOL SETUPAPI ForceNewDialog ( BOOL fForce );
extern BOOL SETUPAPI HandleOOM ( VOID );
extern UINT SETUPAPI HandleSharedFile ( SZ szInfSect, SZ szInfKey, CSZC cszcRegKey,
								CSZC cszcFullPath, HKEY hRegRootKey, SZ szRegDbKey,
								SZ szRegValueName, UINT uiRegDbField, SZ szWinIniSect,
								SZ szWinIniKey, UINT uiWinIniField, SZ szBuf, UINT cbBufMax);
extern BOOL SETUPAPI FRemoveSymbol ( SZ szSymbol );
extern BOOL SETUPAPI FReplaceListItem ( SZ szSym, UINT uiItem, SZ szItem );
extern BOOL SETUPAPI FSetSymbolValue ( SZ szSymbol, SZ szValue );
extern UINT SETUPAPI FindFileInTree ( SZ szFile, SZ szDir, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI FindFileUsingFileOpen ( SZ szFile, SZ szPath, UINT cbPathMax );
extern UINT SETUPAPI FindTargetOnEnvVar ( SZ szFile, SZ szEnvVar, SZ szBuf, UINT cbBufMax );
extern VOID SETUPAPI ForceRestartOn ( VOID );
extern VOID SETUPAPI ForceRestartOff ( VOID );
extern VOID SETUPAPI FreeMemInf ( VOID * pvMemInf );
extern char SETUPAPI GetConfigLastDrive ( VOID );
extern UINT SETUPAPI GetConfigNumBuffers ( VOID );
extern UINT SETUPAPI GetConfigNumFiles ( VOID );
extern UINT SETUPAPI GetConfigRamdriveSize ( VOID );
extern UINT SETUPAPI GetConfigSmartdrvSize ( VOID );
extern LONG SETUPAPI GetCopyListCost ( SZ szExtraList, SZ szCostList, SZ szNeedList );
extern UINT SETUPAPI GetDOSMajorVersion ( VOID );
extern UINT SETUPAPI GetDOSMinorVersion ( VOID );
extern UINT SETUPAPI GetDateOfFile ( SZ szFile, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetDayFromDate ( SZ szDate );
extern UINT SETUPAPI GetEnvVariableValue ( SZ szEnvVar, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetExistingFOTFileForTTF ( SZ szFile, SZ szBuf, UINT cbBufMax );
extern LONG SETUPAPI GetFreeSpaceForDrive ( SZ szDrive );
extern UINT SETUPAPI GetHourFromDate ( SZ szDate );
extern UINT SETUPAPI GetIniKeyString ( CSZC cszcFile, CSZC cszcSect, CSZC cszcKey, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetListItem ( SZ szListSymbol, UINT uiItem, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetListLength ( SZ szSymbol );
extern VOID SETUPAPI GetLocalHardDrivesList ( SZ szSymbol );
extern WORD SETUPAPI GetLocalLanguage ( VOID );
extern UINT SETUPAPI GetMinuteFromDate ( SZ szDate );
extern UINT SETUPAPI GetMonthFromDate ( SZ szDate );
extern VOID SETUPAPI GetNetworkDrivesList ( SZ szSymbol );
extern UINT SETUPAPI GetNthFieldFromIniString ( SZ szLine, UINT uiField, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetNumWinApps ( VOID );
extern VOID SETUPAPI GetParallelPortsList ( SZ szSymbol );
extern UINT SETUPAPI GetProcessorType ( VOID );
extern UINT SETUPAPI GetRegKeyValue32 ( HKEY hRootKey, CSZC cszcSubKey, CSZC cszcValueName, PDWORD pdwType, PBYTE pbData, UINT cbData );
extern VOID SETUPAPI GetRemovableDrivesList ( SZ szSymbol );
extern int  SETUPAPI GetScreenHeight ( VOID );
extern int  SETUPAPI GetScreenWidth ( VOID );
extern UINT SETUPAPI GetSecondFromDate ( SZ szDate );
extern UINT SETUPAPI GetSectionKeyDate ( SZ szSect, SZ szKey, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetSectionKeyFilename ( SZ szSect, SZ szKey, SZ szBuf, UINT cbBufMax );
extern LONG SETUPAPI GetSectionKeySize ( SZ szSect, SZ szKey );
extern UINT SETUPAPI GetSectionKeyVersion ( SZ szSect, SZ szKey, SZ szBuf, UINT cbBufMax );
extern VOID SETUPAPI GetSerialPortsList ( SZ szSymbol );
extern SM   SETUPAPI GetSilentMode ( VOID );
extern LONG SETUPAPI GetSizeOfFile ( SZ szFile );
extern UINT SETUPAPI GetSymbolValue ( SZ szSymbol, SZ szBuf, UINT cbBufMax );
extern LONG SETUPAPI GetTotalSpaceForDrive ( SZ szDrive );
extern UINT SETUPAPI GetTypeFaceNameFromTTF ( SZ szFile, SZ szBuf, UINT cbBufMax );
extern VOID SETUPAPI GetValidDrivesList ( SZ szSymbol );
extern LONG SETUPAPI GetVersionNthField ( SZ szVersion, UINT uiField );
extern UINT SETUPAPI GetVersionOfFile ( SZ szFile, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetWindowsDirPath ( SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetWindowsMajorVersion ( VOID );
extern UINT SETUPAPI GetWindowsMinorVersion ( VOID );
extern UINT SETUPAPI GetWindowsMode ( VOID );
extern UINT SETUPAPI GetWindowsSysDir ( SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetYearFromDate ( SZ szDate );
extern BOOL SETUPAPI Has87MathChip ( VOID );
extern BOOL SETUPAPI HasMonochromeDisplay ( VOID );
extern BOOL SETUPAPI HasMouseInstalled ( VOID );
extern HWND SETUPAPI HdlgShowHelp (UINT uiMsg, WPARAM wParam, LPARAM lParam);
extern HINSTANCE SETUPAPI HinstFrame ( VOID );
extern HWND SETUPAPI HwndFrame ( VOID );
extern VOID SETUPAPI InitLongFileNames ( VOID );
extern UINT SETUPAPI InitSetupToolkit ( SZ szCmdLine, WVM wvmVisibilityMode, BOOL fUseRegDb, LPFNERROREXIT lpfnErrorExit );
extern BOOL SETUPAPI IsCtl3dEnabled ( VOID );
extern BOOL SETUPAPI IsDirWritable ( SZ szDir );
extern BOOL SETUPAPI IsDriveLocalHard ( SZ szDrive );
extern BOOL SETUPAPI IsDriveNetwork ( SZ szDrive );
extern BOOL SETUPAPI IsDriveRemovable ( SZ szDrive );
extern BOOL SETUPAPI IsDriveValid ( SZ szDrive );
extern BOOL SETUPAPI IsDriverInConfig ( SZ szDrv );
extern BOOL SETUPAPI IsFileInUseBySystem ( SZ szFullPath );
extern BOOL SETUPAPI IsFileWritable ( SZ szFile );
extern BOOL SETUPAPI IsValidPath ( SZC szcPath );
extern BOOL SETUPAPI IsWindowsShared ( VOID );
extern VOID SETUPAPI MakeListFromProgmanGroups ( SZ szSymbol );
extern VOID SETUPAPI MakeListFromSectionDate ( SZ szSym, SZ szSect );
extern VOID SETUPAPI MakeListFromSectionFilename ( SZ szSym, SZ szSect );
extern VOID SETUPAPI MakeListFromSectionKeys ( SZ szSymbol, SZ szSect );
extern VOID SETUPAPI MakeListFromSectionSize ( SZ szSym, SZ szSect );
extern VOID SETUPAPI MakeListFromSectionVersion ( SZ szSym, SZ szSect );
extern VOID SETUPAPI PrependToPath ( SZ szSrc, SZ szDst, SZ szDir, CMO cmo );
extern VOID * SETUPAPI PVSaveMemInf ( VOID );
extern VOID SETUPAPI ReactivateSetupScript ( VOID );
extern VOID SETUPAPI ReadInfFile ( SZ szFile );
extern VOID SETUPAPI RemoveDir ( SZ szDir, CMO cmo );
extern VOID SETUPAPI RemoveFile ( SZ szFullPathSrc, CMO cmo );
extern VOID SETUPAPI RemoveIniKey ( CSZC cszcFile, CSZC cszcSect, CSZC cszcKey, CMO cmo );
extern VOID SETUPAPI RemoveIniSection ( CSZC cszcFile, CSZC cszcSect, CMO cmo );
extern VOID SETUPAPI RemoveSectionFilesToCopyList ( SZ szSect, SZ szDstDir );
extern VOID SETUPAPI RemoveSectionKeyFileToCopyList ( SZ szSect, SZ szKey, SZ szDstDir );
extern VOID SETUPAPI RemoveSpecialFileToCopyList ( SZ szSect, SZ szKey, SZ szDstPath );
extern VOID SETUPAPI RemoveSymbol ( SZ szSym );
extern VOID SETUPAPI RenameFile ( SZ szFullPath, SZ szBackup );
extern VOID SETUPAPI ReplaceListItem ( SZ szSymbol, UINT uiItem, SZ szItem );
extern BOOL SETUPAPI RestartListEmpty ( VOID );
extern VOID SETUPAPI RestoreCursor ( HCURSOR hcursorPrev );
extern VOID SETUPAPI RestoreMemInf ( VOID * pvMemInf );
extern VOID * SETUPAPI SaveMemInf ( VOID );
extern UINT SETUPAPI SearchForLocationForSharedFile ( HKEY hRegRootKey,
								SZ szRegDbKey, SZ szRegValueName, UINT uiRegDbField,
								SZ szWinIniSect, SZ szWinIniKey, UINT uiWinIniField,
								SZ szDefSharedPath, SZ szVersion, SZ szLangSrc,
								SZ szBuf, UINT cbBufMax );
extern VOID SETUPAPI SetAbout ( SZ szAbout1, SZ szAbout2 );
extern BOOL SETUPAPI SetBeepingMode ( BOOL fMode );
extern VOID SETUPAPI SetBitmap ( SZ szDll, UINT idBitmap );
extern VOID SETUPAPI SetCopyGaugePosition ( int x, int y );
extern BOOL SETUPAPI SetCopyMode ( BOOL fMode );
extern BOOL SETUPAPI SetDecompMode ( BOOL fMode );
extern BOOL SETUPAPI SetRegKeyValue32 ( HKEY hRootKey, CSZC cszcSubKey, CSZC cszcValueName, DWORD fdwType, CONST BYTE* lpbData, DWORD cbData );
extern BOOL SETUPAPI SetRegKeyValue32Ex (HKEY hKey,HKEY hRootKey, CSZC cszcRegKey, CSZC cszcValueName, DWORD fdwType,CONST BYTE* lpbData, DWORD cbData,BOOL fClose );
extern BOOL SETUPAPI GetRegKeyValue32Ex (HKEY hKey,CSZC cszcValueName, PDWORD pdwType,PBYTE pbData, UINT cbData, BOOL fClose );
extern VOID SETUPAPI SetRestartDir ( SZ szDir );
extern SM   SETUPAPI SetSilentMode ( SM smSilentMode );
extern UINT SETUPAPI SetSizeCheckMode ( SCKM sckmMode );
extern VOID SETUPAPI SetSymbolValue ( SZ szSymbol, SZ szValue );
extern BOOL SETUPAPI SetTimeValue ( UINT uiHours, UINT uiMinutes, UINT uiSeconds );
extern VOID SETUPAPI SetTitle ( SZ sz );
extern VOID SETUPAPI ShowProgmanGroup ( SZ szGroup, UINT Cmd, CMO cmo );
extern HCURSOR SETUPAPI ShowWaitCursor ( VOID );
extern VOID SETUPAPI StampResource ( SZ szFilePath, UINT uiResType, UINT uiResId, SZ szData, UINT cbData, BOOL fNotCopied );
extern VOID SETUPAPI SuppressLongFileNames ( VOID );
extern VOID SETUPAPI UIPop ( UINT cDlgs );
extern VOID SETUPAPI UIPopAll ( VOID );
extern UINT SETUPAPI UIStartDlg ( SZ szDll, UINT Dlg, SZ szDlgProc, UINT HelpDlg, SZ szHelpProc, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI UIStartExeDlg ( HINSTANCE hinstExe, UINT Dlg, FARPROC lpfnDlgProc, UINT HelpDlg, FARPROC lpfnHelpProc, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI UIStartExeDlgWinHelp ( HINSTANCE hinstExe, UINT Dlg, FARPROC lpfnDlgProc, SZ szFile, DWORD* rgdwHelpID, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI UsGetListLength ( SZ szSym );
extern VOID SETUPAPI WriteLogDivider ( VOID );
extern UINT SETUPAPI EnsurePathExists( SZ szFullPathDst );
extern BOOL SETUPAPI FRemoveOurDir ( SZ szFullPath, BOOL fStrip );
#if defined(UI_HOOK)
extern HMODULE SETUPAPI HmodUIHookDll(VOID);
#endif /* UI_HOOK */

#undef  SZ
#undef  CSZ
#undef  SZC
#undef  CSZC

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif

#endif  /* SETUPAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\mxdi.h ===
// mxdi.h: Memory Decryption Interface 
// 
//        To be used in combination with diamond's fdi.h 
//
// Copyright (c) 1994 Microsoft Corporation.  All rights reserved.
// Microsoft Confidential.
//
//

// Include <fdi.h> before this file

#ifndef _MXDI_H_
#define _MXDI_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef enum tagRCA
{
    rcaSuccess,
    rcaOOM,                         // Out of memory
    rcaNoKey,                       // No key for this product
    rcaBadKey,                      // Key does not match file being decrypted
    rcaWrongCd,                     // You bought this product from another CD
    rcaWrongBatch,                  // You bought this product from another 
                                    //     batch of the same CD
    rcaBadLkdbVersion,              //  
    rcaLkdbNotFound,                // Couldn't find lkdb or lkdb.dll
    rcaUnknownEncryptionMethod,     //
    rcaBadParam,                    // Invalid parameter given
    rcaLkdbFileError,               // Error reading, writing, or seeking 
                                    //     the LKDB
    rcaLkdbNotOnLocalDrive,         // LKDB data is on non-local drive
    // encryption only
    rcaReservedSpaceTooSmall = 100, //
} RCA;       // result code in Alakazam

///////////////////////////////////////////////////////////
// Backward compatibility bandaids. 
// These will be removed sooner than you'd hope.
///
typedef void FAR * HMDI;
#define FMDIAllocInit   FMXDIAllocInit
#define FMDIAssertInit  FMXDIAssertInit

#define MDICreate       MXDICreate
#define MDIDecrypt      MXDIDecrypt
#define MDIDestroy      MXDIDestroy
#define RcaFromHmdi     RcaFromHmxdi
///////////////////////////////////////////////////////////


typedef void FAR * HMXDI;

typedef void FAR * (*PFNCRYPTALLOC) (unsigned long); // memory allocation functions
typedef void       (*PFNCRYPTFREE)  (void FAR *);    // memory allocation functions
typedef void       (*PFNCRYPTASSERT) (LPCSTR szMsg, LPCSTR szFile, UINT iLine);


// These are the functions to be used in conjunction with Diamond
//
//      main (...)
//      {
//          if (!FMXDIAllocInit(...))
//              abort();
//          hmxdi = MXDICreate();
//          if (NULL == hmxdi)
//              abort();
//          hfdi = FDICreate(...);
//          For all cabinets
//              if (!FDICopy(..., MXDIDecrypt, &hmxdi))
//                  HandleErrors(..., RcaFromHmxdi(hmxdi));
//          FDIDestroy(hfdi);
//          MDIDestroy(hmxdi);
//      }    
//
//
//

BOOL FMXDIAllocInit(PFNCRYPTALLOC pfnAlloc, PFNCRYPTFREE pfnFree) ;
BOOL FMXDIAssertInit(PFNCRYPTASSERT pfnAssert);

HMXDI FAR CDECL MXDICreate(void);
int  FAR CDECL MXDIDecrypt(PFDIDECRYPT pfdid);
void FAR CDECL MXDIDestroy(HMXDI hmxdi);

RCA RcaFromHmxdi(HMXDI hmxdi);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // !_MXDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\version.h ===
#define rmj		3
#define rmm		1
#define rup		1918
#define szVerName	"3.01.0.1918"
#define szVerUser	"CONMAN"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\stdassrt.h ===
/****************************************************************************
**
**	File:			STDASSRT.H
**	Purpose:		Standard Assert macros and common error handling defines.
**	Notes:
**
****************************************************************************/

#ifndef STDASSRT_H
#define STDASSRT_H

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif

/* REVIEW: need to make this DEBUG only when RTChkArg is removed */
#define EnableAssertCode  static char THIS_FILE[] = __FILE__;


/*  Common Error Validation and Handling */

typedef enum {
	vrcFail  = 0,  /* if IDOK or IDIGNORE or IDNO or no message box */
	vrcValid = 1,  /* if no error condition */
	vrcRetry = 2,  /* if IDRETRY or IDYES */
	vrcQuit  = 3,  /* if IDABORT or IDCANCEL */
	vrcYes   = vrcRetry,
	vrcNo    = vrcFail,
	vrcIgnore= vrcFail,
	vrcCancel= vrcQuit,
	vrcAbort = vrcQuit,
	vrcOk    = vrcFail
} VRC;

#define ERROR_PARAM_MAX 4   /* parameters %1, %2, %3, %4 */

/* sets an error parameter from a temp string value, good until Validate() */
VOID PUBLIC SetErrorParam ( UINT iParam, SZC szValue );

/* sets an error parameter from a stable string value, can Validate() later */
VOID PUBLIC SetErrorParamConst ( UINT iParam, CSZC szValue );

/* sets an error message parameter from a string value, make a string copy */
VOID PUBLIC SetErrorParamCopy  ( UINT iParam, SZC  szValue );

/* sets an error message parameter from an integer value */
VOID PUBLIC SetErrorParamInt   ( UINT iParam, INT   iValue );

/* sets an error message parameter from an character value */
VOID PUBLIC SetErrorParamChar  ( UINT iParam, CHAR chValue );

/* tests a condition, handles error and clears error parameters if false */
VRC  PUBLIC Validate ( BOOL fCondition, UINT iStringId );

/* loads a string resource or debug string, calls ProcessMessage() */
VRC  PUBLIC ProcessMessageId ( UINT iStringId );

/* formats message template, optionally displays message box, write to log */
VRC  PUBLIC ProcessMessage ( SZC szMsg );

/* loads a debug or resource message and writes to the logfile if open */
VRC  PUBLIC LogMessageId ( UINT iResId );  /* return status of log write */

/* loads a message, sets status for %V & %v, writes to the logfile if open */
VRC  PUBLIC LogValidate ( BOOL fCondition, UINT iResId );/* return log status */

/* prototype for callback to obtain object or pass-specific information */
/* returns the number of characters copied to the buffer, or 0 if no info */
typedef INT (WINAPI *PFNErrorParam)( INT chParam, SZ rgchBuf );

/* entry for ACME only, to setup pass calback for error parameters */
VOID PUBLIC SetPassInfo(SZC szPassName, PFNErrorParam pfnCallback);

/* internal entry to process debug messages, called using DebugMessage(sz) */
VRC  PUBLIC ProcessDebugMessage ( SZC szMsg );

/* Sets and gets global last-error message */
VOID PUBLIC SetLastSetupErrMsg ( SZ szMsg );
SZ   PUBLIC SzGetLastSetupErrMsg ( VOID );

/* entry for ACME only, to setup pass calback for FED Font change - DBCS only*/
typedef BOOL (WINAPI *PFNFEFont)( HWND hdlg );

VOID PUBLIC SetFEFontProc(PFNFEFont pfnCallback);

/* Bit flag, combined with message IDS values to specify messages that
*	should be stored into the LastSetupErrMsg buffer in ProcessMessageId.
*	Also macros to test, clear and set the bit flag.
*
*	NOTE: 1 << 8 through 8 << 16 are reserved for ProcessMessageId
*	internal use.  (See setupdll\_assert.h)
*/
#define midErrMsg			(16 << 16)
#define	FIsErrMsg(id)		(id & midErrMsg)
#define IdClearErrMsg(id)	(id & (~midErrMsg))
#define IdErrMsg(id)		(id | midErrMsg)


#ifdef DEBUG
# define DebugErrorParam(p,v)	   SetErrorParam(p,v)
# define DebugErrorParamCopy(p,v)  SetErrorParamCopy(p,v)
# define DebugErrorParamConst(p,v) SetErrorParamConst(p,v)
# define DebugErrorParamInt(p,v)   SetErrorParamInt(p,v)
# define DebugErrorParamChar(p,v)  SetErrorParamChar(p,v)
# define DebugMessageId(i)         ProcessMessageId(i)
# define DebugMessage(s)           ProcessDebugMessage(s)
# define DebugLogMessageId(i)      LogMessageId(i)
#else
# define DebugErrorParam(p,v)
# define DebugErrorParamCopy(p,v)
# define DebugErrorParamConst(p,v)
# define DebugErrorParamInt(p,v)
# define DebugErrorParamChar(p,v)
# define DebugMessageId(i)
# define DebugMessage(s)
# define DebugLogMessageId(i)
#endif

#ifdef DEBUG
BOOL PUBLIC ResponseFile ( SZ szFile );
#endif

/* Must call as the first call (with hinstAcme) AND as the last
*	call (with hinstNull).
*/
BOOL PUBLIC SetAcmeInst(HINSTANCE hInst, LPSTR szCmdLine);

/*  RunTime Argument Checking  */
/*  REVIEW: this should be removed, all uses replaced by calls to Validate */
#define RTChkArg(f, retVal) \
	{ if (!(f)) { FailRTChkArg(THIS_FILE, __LINE__); return (retVal); } }

VRC  PUBLIC FailRTChkArg ( SZC szFile, UINT uiLine );

/*	Assert macros */

VOID PUBLIC FailAssert (SZC szFile, UINT uiLine );  /* also PreCond, BadParam */

#ifdef DEBUG

#define FailAssertObj(f, l, i) FailAssert(f, (UINT)(l + ((i)<<16)))
#define FailChkArg(f, l, i)    FailAssert(f, (UINT)(l + (1<<31) + ((i)<<16)))
#define FailPreCond(f, l)      FailAssert(f, (UINT)(l + (1<<31)))

#define Assert(f)      ((f) ? (VOID)0 : (VOID)FailAssert(THIS_FILE, __LINE__))
#define EvalAssert(f)  ((f) ? (VOID)0 : (VOID)FailAssert(THIS_FILE, __LINE__))

#define AssertRet(f, retVal) \
		{if (!(f)) {FailAssert( THIS_FILE, __LINE__); return (retVal);} }
#define EvalAssertRet(f, retVal) \
		{if (!(f)) {FailAssert( THIS_FILE, __LINE__); return (retVal);} }

#define PreCondition(f, retVal)	\
		{if (!(f)) {FailPreCond(THIS_FILE, __LINE__); return (retVal);} }
#define ChkArg(f, iArg, retVal)	\
		{if (!(f)) {FailChkArg(THIS_FILE, __LINE__, iArg); return (retVal);} }

#else

#define Assert(f)
#define EvalAssert(f)				((VOID)(f))
#define AssertRet(    f, retVal)
#define EvalAssertRet(f, retVal)	((VOID)(f))
#define PreCondition( f, retVal)	RTChkArg(f, retVal)
#define ChkArg( f, iArg, retVal)

#endif


/* REVIEW: These are obsolete, remove when files using them are updated */

#ifdef DEBUG
#define DisplayAssertMsg()    Assert(fFalse);
#define DebugLine(expr)       expr;
#define DisplayErrorMsg(sz)   ((VOID)FDisplaySystemMsg(sz))
#else
#define DisplayAssertMsg() /* in objodbc.cpp, copylist.c */
#define DebugLine(expr)    /* once in copylist.c */
#define DisplayErrorMsg(sz)
#endif
extern BOOL WINAPI FDisplaySystemMsg     ( SZ szErr );

#ifdef DEVELOPER
#define BadArgErr(nArg, szApi, szArgs) SetupApiErr(nArg+saeMax, szApi, szArgs)
#else
#define BadArgErr(nArg, szApi, szArgs)
#endif

/* REVIEW: end of obsolete */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif

#endif  /* STDASSRT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\setupkit.h ===
/***************************************************************************
**
**	File:			SetupKit.h
**	Purpose:		Toolkit types, defines, and prototypes.
**	Notes:
**
****************************************************************************/

#ifndef SETUPKIT_H
#define SETUPKIT_H

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif


/*
**	Purpose:
**		Calculates the number of bytes that a string occupies (not including
**		the terminating zero character).
**	Arguments:
**		sz: string whose length is to be calculated.
**	Returns:
**		0 if sz was NULL.
**		The number of bytes from the beginning of the string to its
**			terminating zero character.
*/
#define CbStrLen(sz)              ((CB)lstrlen(sz))


/*
**	Purpose:
**    Checks if the string is empty
**	Arguments:
**		sz:
**	Returns:
**		0 if sz was NULL.
**    1 otherwise
*/
#define FEmptySz(sz)              ((BOOL)((sz) == szNull || *(sz) == chEos))

#define FValidSz(sz)              (!FEmptySz(sz))


/*
 *	CHaracter Physical representation datatype
 */
typedef BYTE             CHP;		/* CHaracter Physical */
typedef CHP *            PCHP;		/* Ptr to CHaracter Physical */
typedef CB               CCHP;		/* Count of CHaracter Physical */
typedef CCHP *           PCCHP;		/* Ptr to Count of CHaracter Physical */

#define pchpNull         ((PCHP)NULL)
#define pcchpNull        ((PCCHP)NULL)
#define CbFromCchp(cchp) ((CB)(cchp))


/*
 *	CHaracter Logical representation datatype
 */
typedef CHP              CHL;		/* CHaracter Logical */
typedef CHL *            PCHL;		/* Ptr to CHaracter Logical */
typedef PCHL *           PPCHL;		/* Ptr to Ptr to CHaracter Logical */
typedef CB               CCHL;		/* Count of CHaracter Logical */

#define pchlNull         ((PCHL)NULL)
#define ppchlNull        ((PPCHL)NULL)

#define cchpFullPathMax  ((CCHP)(_MAX_PATH))

#define cchGrpNameMax  30  /* right for win31, WfW, WinNT */
#ifdef OLD
#define cchGrpNameMax  ((CB)(LOWORD(GetVersion()) == 0x0003 ? 24 : 29))
#endif /* OLD */

/*
 *	Maximum size block that can be allocated (bytes).
 */
#define cbAllocMax  ((CB)65520)


/*
 *	Path Verification Routines
 */

typedef UINT  FPV;		/* Flags for Path Validation */

#define fpvSub     0x0000  /* Must be subpath, cannot have Drive or UNC */
#define fpvUnc     0x0001  /* Validate UNC path, \\Node\share */
#define fpvDrive   0x0002  /* Validate Drive at start of path */
#define fpvFile    0x0004  /* Validate filename only, no subdirectories */
#define fpvDir     0x0010  /* Allow trailing directory separator */
#define fpvFat     0x0020  /* Restrict to only 8.3 FAT name, no LFNs */
#define fpvFull    (fpvDrive | fpvUnc) /* Full path, with Drive or UNC */
#define fpvModule  (fpvDrive | fpvUnc | fpvFile) /* Valid executable name */

/*
**	Purpose:
**		Checks the validity of a filepath or filename.
**		Allowable filepath components are controlled by bit flags.
**		Default behavior is to allow directories with filename.
**		Leading backslash is not permitted in directory name.
**	Arguments:
**		szcPath:      non-NULL string to validate
**		fpvFlags:     pathname options flags
**	Returns:
**		fTrue if szcPath is valid for requested type
**		fFalse if invalid path
***************************************************************************/

BOOL PUBLIC FValidFilePath ( SZC szcPath, FPV fpvFlags );

#define FValidDir(szcDir)          FValidFilePath(szcDir, fpvFull | fpvDir)
#define FValidPath(szcPath)        FValidFilePath(szcPath, fpvFull)
#define FValidSubDir(szc)          FValidFilePath(szc, fpvDir)
#define FValidSubPath(szc)         FValidFilePath(szc, fpvSub)
#define FValidFATSubPath(szc)      FValidFilePath(szc, fpvFat)
#define FValidFileName(szc)        FValidFilePath(szc, fpvFile)
#define FValidDllFileName(szc)     FValidFilePath(szc, fpvModule)
#define FValidDstDir(szcDir)       FValidFilePath(szcDir, fpvDrive | fpvDir)


#define FValidInfSect(cszcSect)												\
				(FValidSz(cszcSect) && !strchr(cszcSect, ']'))

#define FValidIniFile(szcFile)												\
				(FValidPath(szcFile)											\
				 || CrcStringCompareI(szcFile, "WIN.INI") == crcEqual)


/* String manipulation routines */

/*
**	Purpose:
**		Advances a string pointer to the beginning of the next valid
**		character.  This may include skipping a double-byte character.
**	Arguments:
**		sz: the string pointer to advance.  It can be NULL or empty, or else
**			it must point at the beginning of a valid character.
**	Returns:
**		NULL if sz was NULL.
**		sz unchanged if it was an empty string (*sz == '\0').
**		sz advanced past the current character and to the beginning of the
**			next valid character.
*/
#define SzNextChar(sz)            AnsiNext(sz)


/*
**	Purpose:
**		Retreats a string pointer to the beginning of the previous valid
**		character.  This may include skipping a double-byte character.
**	Arguments:
**		szStart: string pointer to the beginning of a valid character that
**			equals or preceeds the character szCur.
**		szCur:   string pointer to retreat.  It can be NULL or empty, or
**			can point to any byte in a valid character.
**	Returns:
**		NULL if szCur was NULL.
**		sz unchanged if szStart was NULL or if szCur equaled szStart.
**		sz retreated past the current character and to the beginning of the
**			previous valid character.
*/
#define SzPrevChar(szStart, szCur) AnsiPrev(szStart, szCur)


/*
**	Purpose:
**		Copies a string from one buffer to another.
**	Arguments:
**		szDst: string pointer to destination buffer.  This can be NULL or
**			else it must contain enough storage to copy szSrc with its
**			terminating zero character.
**		szSrc: string pointer to source buffer.  This can be NULL or else
**			must point to a zero terminated string (can be empty).
**	Returns:
**		NULL if either szDst or szSrc is NULL.
**		szDst signifying the operation succeeded.
*/
#define SzStrCopy(szDst, szSrc)   lstrcpy(szDst, szSrc)


/*
**	Purpose:
**		Appends a string from one buffer to another.
**	Arguments:
**		szDst: string pointer to destination buffer.  This can be NULL or
**			else it must contain a zero terminated string (can be empty)
**			and enough storage to append szSrc with its terminating zero
**			character.
**		szSrc: string pointer to source buffer.  This can be NULL or else
**			must point to a zero terminated string (can be empty).
**	Returns:
**		NULL if either szDst or szSrc is NULL.
**		szDst signifying the operation succeeded.
*/
#define SzStrCat(szDst, szSrc)    lstrcat(szDst, szSrc)


/*
**	Purpose:
**		Converts a zero-terminated string to upper case.
**	Arguments:
**		sz: the string to convert to upper case.  sz must be non-NULL though
**			it can be empty.
**	Returns:
**		A pointer to the converted string.
*/
/* REVIEW: define SzStrUpper(sz)            (sz) */


/*
**	Purpose:
**		Converts a zero-terminated string to lower case.
**	Arguments:
**		sz: the string to convert to lower case.  sz must be non-NULL though
**			it can be empty.
**	Returns:
**		A pointer to the converted string.
*/
#define SzStrLower(sz)            AnsiLower(sz)


/* Memory Handling routines */
extern PB    WINAPI PbAlloc ( CB cb );
extern BOOL  WINAPI FFree ( PB pb, CB cb );
extern PB    WINAPI PbRealloc ( PB pb, CB cbNew, CB cbOld );

#define FHandleOOM()              HandleOOM()

/*
**	Purpose:
**		Frees the memory used by an sz.  This assumes the terminating
**		zero occupies the final byte of the allocated buffer.
**	Arguments:
**		sz: the buffer to free.  this must be non-NULL though it can point
**			at an empty string.
**	Returns:
**		fTrue if the Free() operation succeeds.
**		fFalse if the Free() operation fails.
*/
#define FFreeSz(sz)               FFree((PB)(sz), CbStrLen(sz)+1)


/*
**	Purpose:
**		Shrinks a buffer to exactly fit a string.
**	Arguments:
**		sz: the string for which the buffer should shrink to.  sz must be
**			non-NULL though it can be empty.
**		cb: the size in bytes for the buffer that was originally allocated.
**			cb must be greater than or equal to CbStrLen(sz) + 1.
**	Returns:
**		A pointer to the original string if the Realloc() operation succeeds.
**		NULL if the Realloc() operation fails.
*/
#define SzReallocSz(sz, cb)   (SZ)(PbRealloc((PB)(sz), (CbStrLen(sz)+1), cb))


/*
 *	File Handle structure
 *	Fields:
 *		hFile:   Win32 file handle.
 *		iDosfh:  Only used to avoid changing old source code, same as hFile
 *		szPath:  Full path used when the file was opened.
 */
typedef union _fh		/* File Handle structure */
	{
	INT     iDosfh;  /* temp until code converted */
	HANDLE  hFile;
	} FH;

/*
 *	File Handle datatype
 */
typedef FH *    PFH;		/* Ptr to File Handle structure */
typedef PFH *   PPFH;		/* Ptr to Ptr to File Handle structure */

#define pfhNull   ((PFH)NULL)
#define ppfhNull  ((PPFH)NULL)


/*
 *	Open File Mode datatype
 */
typedef UINT  OFM;		/* Open File Mode */

#define ofmExist          ((OFM)OF_EXIST)
#define ofmRead           ((OFM)OF_READ      | OF_SHARE_DENY_WRITE)
#define ofmReadCompat     ((OFM)OF_READ      | OF_SHARE_COMPAT)
#define ofmWrite          ((OFM)OF_WRITE     | OF_SHARE_EXCLUSIVE)
#define ofmReadWrite      ((OFM)OF_READWRITE | OF_SHARE_EXCLUSIVE)
#define ofmCreate         ((OFM)OF_CREATE    | OF_SHARE_EXCLUSIVE)


/*
 *	Seek File Mode datatype
 */
typedef UINT  SFM;		/* Seek File Mode */

#define sfmSet   ((SFM)FILE_BEGIN)
#define sfmCur   ((SFM)FILE_CURRENT)
#define sfmEnd   ((SFM)FILE_END)


/*
 *	Long File Address datatype
 */
typedef unsigned long  LFA;		/* Long File Address */

#define lfaSeekError   ((LFA)HFILE_ERROR)


/*
 *	Expanded Error Return Code
 */
typedef unsigned int  EERC;		/* Expanded Error Return Code */

#define eercOkay    ((EERC)0)
#define eercAbort   ((EERC)1)
#define eercRetry   ((EERC)2)
#define eercIgnore  ((EERC)3)


/* File handling routines */
extern EERC  WINAPI EercOpenFile ( PPFH ppfh, CSZC cszcFile, OFM ofm,
								   BOOL fVital );
extern BOOL  WINAPI FFileExist ( CSZC cszcFile, OFM ofm );
extern BOOL  WINAPI FCloseFile ( PFH pfh );
extern CB    WINAPI CbReadFile ( PFH pfh, PB pbBuf, CB cbMax );
extern CB    WINAPI CbWriteFile ( PFH pfh, PB pbBuf, CB cbMax );
extern LFA   WINAPI LfaSeekFile ( PFH pfh, LONG l, SFM sfm );
extern BOOL  WINAPI FChmodFile ( CSZC cszcFileName, INT wFlags, BOOL fVital );
extern SZC WINAPI DriveNumToRootPath( INT iDrive );


typedef unsigned int IDDT;		/* Insert Disk Dialog Type */
#define iddtStandard	((IDDT)1)
#define iddtHddi		((IDDT)2)
#define iddtHddiMaint	((IDDT)3)


/* Media source file handling routines */
extern EERC WINAPI EercOpenSrcFile ( PPFH ppfh, UINT did, SZ szSrcDir,
									 SZ szFile, BOOL fWrite );
extern EERC WINAPI EercOpenSrcFileEx ( PPFH ppfh, UINT did, SZ szSrcDir,
							 SZ szFile, BOOL fWrite, BOOL fVital, IDDT iddt );
extern EERC WINAPI EercReadSrcFile ( PFH pfh, PB pbBuf, CB cbMax );

extern EERC WINAPI EercWriteSrcFile ( PFH pfh, PB pbBuf, CB cbMax );

extern BOOL WINAPI FCloseSrcFile( PFH pfh, BOOL fRdOnly );

extern EERC WINAPI EercFindHddiFloppy ( SZ szSrcDir, DWORD dwDrives,
										PCH pchDrive, BOOL fVital, IDDT iddt );

/*
 *	SetErrorMode type
 */
typedef unsigned int  SEM;		/* SetErrorMode type */


/*
 *	Comparison Return Code datatype
 */
typedef INT CRC;		/* Comparison Return Code */

#define crcError         ((CRC)(-2))
#define crcEqual         ((CRC)  0 )
#define crcFirstHigher   ((CRC)  1 )
#define crcSecondHigher  ((CRC)(-1))

extern SZ    PUBLIC SzDupl ( CSZC cszc );
extern CRC   WINAPI CrcStringCompare  ( CSZC cszc1, CSZC cszc2 );
extern CRC   WINAPI CrcStringCompareI ( CSZC cszc1, CSZC cszc2 );
extern SZ    WINAPI SzLastChar ( CSZC cszc );
extern CB    WINAPI CbStrCopyToBuffer ( PB pbBuf, CB cbMax, CSZC cszcSrc );


/*
 *	BindImage API, exported from MSSETUP.DLL, and/or IMAGEHLP.DLL
 */

#define IMAGEHELP_DLL  "imagehlp.dll"
#define BINDIMAGE_PROC "BindImage"
typedef BOOL (WINAPI *PFNBindImage)( SZ szImage, SZ szDllPath, SZ szSymPath);

extern BOOL WINAPI BindImage( SZ szImage, SZ szDllPath, SZ szSymPath);


/*
 *	API to set Admin mode in toolkit DLL
 */

VOID WINAPI SetAdminMode ( VOID );  /* called only by ACMSETUP.EXE */
BOOL WINAPI IsAdminMode ( VOID );


/* Like FStampResource, but only reads the data into the buffer.
*/
BOOL  WINAPI FReadResource ( SZ szFilePath, UINT uiResType, UINT uiResId,
												 SZ szData, CB cbData, BOOL fNotCopied );

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif

#endif  /* SETUPKIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\intl\usa\bldver.h ===
#include "version.h"


#ifdef RC_INVOKED

#include "verdef.h"

#define VER_FILEVERSION_STR      "3.01\0"
#define VER_FILEVERSION          rmj,rmm,0,rup

#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1991-1997\0"
#define VER_COMMENT_STR          "Windows Setup Toolkit (Throttle)\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0

#endif  /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\inc\stdtypes.h ===
/****************************************************************************
**
**	File:			STDTYPES.H
**	Purpose:		Standard project wide include file.
**	Notes:
**
****************************************************************************/

#ifndef STDTYPES_H
#define STDTYPES_H

#ifdef _WIN32
/* The windows.h for win32 used _WINDOWS_ instead of _INC_WINDOWS */
#ifdef _INC_WINDOWS
#undef _INC_WINDOWS
#endif
#define _INC_WINDOWS	_WINDOWS_
#endif /* _WIN32 */

/* MAX_PATH is the Win32 define, _MAX_PATH is the MSVC define, equate them */
#ifdef MAX_PATH
#undef _MAX_PATH
#define _MAX_PATH MAX_PATH
#else
#define MAX_PATH _MAX_PATH
#endif

/* CDECL is already defined in WIN32.  Undef it */
/*#undef CDECL*/

/* Rename PSZ, since it is defined in WIN32 as char*, and we want char** */
#define PSZ _PSZ


#ifdef DEBUG
#define DEVELOPER		/* REVIEW: This is temporary */
#endif

/*
 *	Constants
 */
#define fFalse				((BOOL)0)
#define fTrue				((BOOL)1)

#define Nil					0

#define chNil				'\0'
#define chEos				'\0'
#define chTab				'\t'
#define chEol				'\n'
#define chCR				'\r'
#define chCtrlZ				'\x1A'

#define chSpace				' '
#define chBang				'!'
#define chDblQuote			'\"'
#define chDollar			'$'
#define chPercent			'%'
#define chSngQuote			'\''
#define chStar				'*'
#define chPlus				'+'
#define chComma				','
#define chMinus				'-'
#define chPeriod			'.'
#define chSlash				'/'
#define chColon				':'
#define chSemiColon			';'
#define chLftAngle			'<'
#define chEquals			'='
#define chRgtAngle			'>'
#define chQuestionMark		'?'
#define chAtSign			'@'
#define chLftSqBracket		'['
#define chBackSlash			'\\'
#define chRgtSqBracket		']'
#define chUnderscore		'_'
#define chLftBrace			'{'
#define chVertical			'|'
#define chRgtBrace			'}'

#define chDirSep			chBackSlash

#define szDirSep            "\\"
#define szTab               "\t"

#define cchIntMax			 17		/*  Maximum number of digits (_itoa) */
#define cchLongMax			 33		/*  Maximum number of digits (_ltoa) */
#define cchSzMax	     MAX_PATH	/*  Includes chEos */

/*
 *	In a windows program windows.h must be included before this file.
 *	If a DOS program includes ver.h, it must do so before including this
 *	file.
 */
#ifndef _INC_WINDOWS	/* Don't declare if already declared in windows.h */
#ifndef WINAPI			/* Don't declare if already declared in ver.h */

typedef int					BOOL;
typedef unsigned char		BYTE;
typedef unsigned int		UINT;

#ifdef STRICT
typedef signed long			LONG;
#else
#define LONG				long
#endif

#ifndef NULL
#define NULL				0
#endif

#endif  /* WINAPI */

#define VOID				void
#define CDECL				_cdecl
typedef void *				LPVOID;

#endif  /* _INC_WINDOWS */

/*
 *	Common definitions.  See windef.h and winnt.h for these defines:
 *
 *		VOID, NULL, CDECL, WINAPI, CALLBACK
 */
#define STATIC_FN			static
#define STATIC_VAR			static
#define PRIVATE				WINAPI
#define PUBLIC				WINAPI

#define HUGE

/*
 *	Standard types.  See windef.h and winnt.h for these types:
 *
 *		CHAR, UCHAR, BYTE, BOOL, USHORT, INT, UINT, WPARAM,
 *      LONG, ULONG, LPARAM, LRESULT
 *
 *	Types defined in _WIN32 windef.h and winnt.h, but not WIN16 windows.h.
 *
 *		CHAR, USHORT, ULONG
 */
#ifndef _WIN32
typedef char				CHAR;
typedef unsigned short		USHORT;
typedef unsigned long		ULONG;
#endif /* !_WIN32 */
typedef signed char			SBYTE;
typedef UINT			CB;
typedef unsigned long		LCB;

typedef UINT				IDT;	/* ID of dialog Template */
typedef UINT				IDC;	/* ID of dialog Control  */
typedef UINT				IDR;	/* ID of Resource        */

/*
 *	Standard pointer types.  See windef.h and winnt.h for these types:
 *
 *      PUSHORT, PINT, PUINT, PBOOL, PLONG, PULONG
 *
 *	Types defined in _WIN32 windef.h and winnt.h, but not WIN16 windows.h.
 *
 *		PBOOL, PUINT, PUSHORT, PULONG
*/
#ifndef _WIN32
typedef BOOL *				PBOOL;
typedef UINT *				PUINT;
typedef USHORT *			PUSHORT;
typedef ULONG *				PULONG;
#endif /* !_WIN32 */
typedef VOID *				PV;
typedef PV *				PPV;
typedef PPV *				PPPV;
typedef CHAR *				SZ;		/* ptr to char                   */
typedef CHAR * const		CSZ;	/* constant ptr to char          */
typedef const CHAR *		SZC;	/* ptr to constant char          */
typedef const CHAR * const	CSZC;	/* constant ptr to constant char */
typedef SZ *				RGSZ;
typedef SZ *				PSZ;
typedef PSZ *				PPSZ;
typedef BYTE *				PB;
typedef PB *				PPB;
typedef PPB *				PPPB;
typedef SBYTE *				PSB;
typedef PSB *				PPSB;
typedef PPSB *				PPPSB;
typedef PBOOL *				PPBOOL;
typedef PPBOOL *			PPPBOOL;
typedef BOOL *				RGBOOL;
typedef RGBOOL *			PRGBOOL;
typedef PRGBOOL *			PPRGBOOL;
typedef PINT *				PPINT;
typedef PPINT *				PPPINT;
typedef PUINT *				PPUINT;
typedef PPUINT *			PPPUINT;
typedef UINT *				RGUINT;
typedef RGUINT *			PRGUINT;
typedef PRGUINT *			PPRGUINT;
typedef PUSHORT *			PPUSHORT;
typedef PPUSHORT *			PPPUSHORT;
typedef PLONG * 	 	 	PPLONG;
typedef PPLONG *			PPPLONG;
typedef PULONG *			PPULONG;
typedef PPULONG *			PPPULONG;
typedef CB *				PCB;
typedef PCB *				PPCB;
typedef PPCB *				PPPCB;
typedef LCB *				PLCB;
typedef PLCB *				PPLCB;
typedef PPLCB *				PPPLCB;
typedef IDT *               PIDT;
typedef PIDT *              PPIDT;
typedef PPIDT *             PPPIDT;
typedef IDC *               PIDC;
typedef PIDC *              PPIDC;
typedef PPIDC *             PPPIDC;
typedef IDR *               PIDR;
typedef PIDR *              PPIDR;
typedef PPIDR *             PPPIDR;

#ifdef _INC_WINDOWS

/*
 *	Pointers to various Windows types.
 */
typedef FARPROC *			PLPFN;
typedef DLGPROC *			PDLGPROC;
typedef HACCEL *			PHACCEL;
typedef HBITMAP *			PHBM;
typedef HBRUSH *			PHBR;
typedef HCURSOR *			PHCURSOR;
typedef HDC *				PHDC;
typedef HDWP *				PHDWP;
typedef HFONT *				PHFONT;
typedef HGDIOBJ *			PHGDIOBJ;
typedef HGLOBAL *			PHGLOBAL;
typedef HHOOK *				PHHOOK;
typedef HICON *				PHICON;
typedef HINSTANCE *			PHINST;
typedef HMENU *				PHMENU;
typedef HMETAFILE *			PHMF;
typedef HMODULE *			PHMOD;
typedef HPALETTE *			PHPAL;
typedef HPEN *				PHPEN;
typedef HRSRC *				PHRSRC;
typedef HTASK *				PHTASK;

typedef HWND *				PHWND;
typedef HRGN *				PHRGN;
typedef PRECT *				PPRECT;

#endif  /* _INC_WINDOWS */

/*
 *	More constants
 */
#define szNil				( (SZ) Nil )
#define pszNil				( (PSZ)Nil )
#define pbNil				( (PB) Nil )
#define pvNil				( (PV) Nil )
#define cbNil				( (CB) Nil )
#define idtNil				( (IDT)Nil )
#define idcNil				( (IDC)Nil )
#define idrNil				( (IDR)Nil )

#define cbMaxConst			( (CB) 0xffff )
#define cbError				( (CB) HFILE_ERROR )

#ifdef __cplusplus
#define pvNull				0
#define lpvoidNull			0
#define szNull				0
#define pszNull				0
#define rgszNull			0
#define cszcNull			0
#define pbNull				0
#define pcbNull				0
#define puintNull			0
#define rguintNull          0
#define prguintNull         0
#define pulongNull			0
#define lpfnNull			0
#define pfNull              0
#define rgfNull             0
#define prgfNull            0
#define pidtNull            0
#define pidcNull            0
#define pidrNull            0
#else
#define pvNull				( (PV)     NULL )
#define lpvoidNull			( (LPVOID) NULL )
#define szNull				( (SZ)     NULL )
#define pszNull				( (PSZ)    NULL )
#define rgszNull			( (RGSZ)   NULL )
#define cszcNull			( (CSZC)   NULL )
#define pbNull				( (PB)     NULL )
#define pcbNull				( (PCB)    NULL )
#define puintNull			( (PUINT)  NULL )
#define rguintNull          ( (RGUINT) NULL )
#define prguintNull         ( (PRGUINT)NULL )
#define pulongNull			( (PULONG) NULL )
#define lpfnNull			(          NULL )
#define pfNull              ( (PBOOL)  NULL )
#define rgfNull             ( (RGBOOL) NULL )
#define prgfNull            ( (PRGBOOL)NULL )
#define pidtNull            ( (PIDT)   NULL )
#define pidcNull            ( (PIDC)   NULL )
#define pidrNull            ( (PIDR)   NULL )
#endif  /* __cplusplus */

#ifdef _INC_WINDOWS

/*
 *	Null constants for various Windows types.
 */
#ifdef __cplusplus
#define dlgprocNull			0
#define haccellNull			0
#define hbmNull				0
#define hbrNull				0
#define hcursorNull			0
#define hdcNull				0
#define hdrvrNull			0
#define hdwpNull			0
#define hfontNull			0
#define hgdiobjNull			0
#define hglobalNull			0
#define hhookNull			0
#define hiconNull			0
#define hinstNull			0
#define hmenuNull			0
#define hmfNull				0
#define hmodNull			0
#define hpalNull			0
#define hpenNull			0
#define hrsrcNull			0
#define htaskNull			0
#define hwndNull			0
#define rgnNull				0
#define prectNull			0

#define plpfnNull			0
#define pdlgprocNull		0
#define phaccellNull		0
#define phbmNull			0
#define phbrNull			0
#define phcursorNull		0
#define phdcNull			0
#define phdrvrNull			0
#define phdwpNull			0
#define phfontNull			0
#define phgdiobjNull		0
#define phglobalNull		0
#define phhookNull			0
#define phiconNull			0
#define phinstNull			0
#define phmenuNull			0
#define phmfNull			0
#define phmodNull			0
#define phpalNull			0
#define phpenNull			0
#define phrsrcNull			0
#define phtaskNull			0
#define phwndNull			0
#define prgnNull			0
#define pprectNull			0
#else
#define dlgprocNull			( (DLGPROC)  NULL )
#define haccellNull			( (HACCEL)   NULL )
#define hbmNull				( (HBITMAP)  NULL )
#define hbrNull				( (HBRUSH)   NULL )
#define hcursorNull			( (HCURSOR)  NULL )
#define hdcNull				( (HDC)      NULL )
#define hdrvrNull			( (HDRVR)    NULL )
#define hdwpNull			( (HDWP)     NULL )
#define hfontNull			( (HFONT)    NULL )
#define hgdiobjNull			( (HGDIOBJ)  NULL )
#define hglobalNull			( (HGLOBAL)  NULL )
#define hhookNull			( (HHOOK)    NULL )
#define hiconNull			( (HICON)    NULL )
#define hinstNull			( (HINSTANCE)NULL )
#define hmenuNull			( (HMENU)    NULL )
#define hmfNull				( (HMETAFILE)NULL )
#define hmodNull			( (HMODULE)  NULL )
#define hpalNull			( (HPALETTE) NULL )
#define hpenNull			( (HPEN)     NULL )
#define hrsrcNull			( (HRSRC)    NULL )
#define htaskNull			( (HTASK)    NULL )
#define hwndNull			( (HWND)     NULL )
#define rgnNull				( (HRGN)     NULL )
#define prectNull			( (PRECT)    NULL )

#define plpfnNull			( (PLPFN)    NULL )
#define pdlgprocNull		( (PDLGPROC) NULL )
#define phaccellNull		( (PHACCEL)  NULL )
#define phbmNull			( (PHBM)     NULL )
#define phbrNull			( (PHBR)     NULL )
#define phcursorNull		( (PHCURSOR) NULL )
#define phdcNull			( (PHDC)     NULL )
#define phdrvrNull			( (PHDRVR)   NULL )
#define phdwpNull			( (PHDWP)    NULL )
#define phfontNull			( (PHFONT)   NULL )
#define phgdiobjNull		( (PHGDIOBJ) NULL )
#define phglobalNull		( (PHGLOBAL) NULL )
#define phhookNull			( (PHHOOK)   NULL )
#define phiconNull			( (PHICON)   NULL )
#define phinstNull			( (PHINST)   NULL )
#define phmenuNull			( (PHMENU)   NULL )
#define phmfNull			( (PHMF)     NULL )
#define phmodNull			( (PHMOD)    NULL )
#define phpalNull			( (PHPAL)    NULL )
#define phpenNull			( (PHPEN)    NULL )
#define phrsrcNull			( (PHRSRC)   NULL )
#define phtaskNull			( (PHTASK)   NULL )
#define phwndNull			( (PHWND)    NULL )
#define prgnNull			( (PHRGN)    NULL )
#define pprectNull			( (PPRECT)   NULL )
#endif  /* __cplusplus */

#endif  /* _INC_WINDOWS */

#define cbSz				( (CB)sizeof( SZ    ) )
#define cbPsz				( (CB)sizeof( PSZ   ) )
#define cbByte				( (CB)sizeof( BYTE  ) )
#define cbPb				( (CB)sizeof( PB    ) )
#define cbBool				( (CB)sizeof( BOOL  ) )
#define cbPbool				( (CB)sizeof( PBOOL ) )
#define cbInt				( (CB)sizeof( INT   ) )
#define cbPint				( (CB)sizeof( PINT  ) )
#define cbLong				( (CB)sizeof( LONG  ) )
#define cbPlong				( (CB)sizeof( PLONG ) )
#define cbCb				( (CB)sizeof( CB    ) )
#define cbPcb				( (CB)sizeof( PCB   ) )
#define cbPv				( (CB)sizeof( PV    ) )

/*
 *	Useful self commenting constructs
 */
#define Unused(x)			(void)(x=x)

typedef enum _OFI			/* Okay/Fail/Ignore enum */
	{
	ofiOkay,
	ofiFail,
	ofiIgnore
	}  OFI;
typedef OFI *  POFI;  /* Ptr to Okay/Fail/Ignore enum */

#define cbMaxDriveSize	(999999L * 1024L)

#endif  /* STDTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\setup\intl\usa\verdef.h ===
/***************************************************************************
**
**	File:			verdef.h
**	Purpose:		Defines values used in the version data structure for
**					all files, and which do not change.
**	Notes:
**
****************************************************************************/

#ifndef VERSION_H
#define VERSION_H

#ifndef VS_FF_DEBUG
#ifdef _RC32
#include <winver.h>
#else
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h>
#endif /* _RC32 */
#endif 

/*--------------------------------------------------------------*/

/* default is official */
#ifdef PRIVATEBUILD
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is final */
#ifdef PRERELEASE
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK

#endif  /* VERSION_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tests\apc\apc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

VOID TimerCallback(PVOID pv, BOOLEAN b)
{
    DbgPrint("TimerCallback called!\n");
}

int main(int argc, char *argv[])
{
    NTSTATUS st;
    HANDLE Q;
    HANDLE T;
    LARGE_INTEGER li;

    DbgPrint("Creating timer queue...\n");
    RtlCreateTimerQueue(&Q);

    DbgPrint("In main... setting a timer...\n");

    st = RtlSetTimer(Q,
                     &T,
                     TimerCallback,
                     NULL,
                     500,
                     500,
                     0);


    DbgPrint("In main... sleeping...\n");
    li.QuadPart = -500*20*5000;
    NtDelayExecution(FALSE, &li);

    DbgPrint("In main... cancelling timer...\n");
    RtlCancelTimer(Q, T);

    DbgPrint("In main... deleting timer...\n");
    RtlDeleteTimerQueue(Q);


    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tests\bvt\wow64bvt.c ===
// define COBJMACROS so the IUnknown_Release() gets defined
#define COBJMACROS

// disable ddraw COM declarations.  Otherwise ddrawint.h defineds _NO_COM
// and includes ddraw.h.  That causes ddraw.h to define IUnknown as 'void *'
// which obliterates the struct IUnknown in objbase.h.  This all happens
// inside winddi.h
#define _NO_DDRAWINT_NO_COM

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <objbase.h>    
#include <mshtml.h> 
#include <winddi.h>
#include <io.h>

#define PAGE_4K   0x1000

// Assume an error happened.  This variable controls whether a pass or fail
// is logged in the test results.
BOOL g_bError = TRUE;

// Time the test started (only valid in the main process)
time_t TestStartTime;

FILE *fpLogFile;

void __cdecl PrintToLog(char *format, ...)
{
    va_list pArg;
    char buffer[4096];

    va_start(pArg, format);
    _vsnprintf(buffer, sizeof(buffer), format, pArg);
    buffer[sizeof(buffer)-1] = '\0';
    printf("%s", buffer);
    if (fpLogFile) {
        fprintf(fpLogFile, "%s", buffer);
    }
}

////////////  All this code runs in a worker thread in a child process //////
//// Prefix any output by "WOW64BVT1" so it can be identified as coming from
//// the child process.

// This routine is invoked when "childprocess" is passed on the command-line.
// The child runs synchronously with the parent to maximize the test coverage.
int BeAChildProcess(void)
{
    HRESULT hr;
    IUnknown *pUnk;
    CLSID clsid;
    HWND hwnd;

    PrintToLog("WOW64BVT1: Child process running\n");

    // Do some COM stuff here
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CoInitializeEx failed %x\n", hr);
        return 3;
    }

    // Load and call 32-bit mshtml inproc
    hr = CLSIDFromProgID(L"Shell.Explorer", &clsid);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CLSIDFromProgID for Shell.Explorer failed %x\n", hr);
        return 3;
    }
#if 0   // The cocreate fails on IA64 with 8007000e (E_OUTOFMEMORY)
    hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IUnknown, (PVOID *)&pUnk);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CoCreateInstance for Shell.Explorer failed %x\n", hr);
        return 3;
    }
    Sleep(1000);
    IUnknown_Release(pUnk);
    pUnk = NULL;
#endif

    // Load and call mplay32.exe out-of-proc
#if 0 // The clsidfromprogid fails on IA64 with 800401f3 (CO_E_CLASSSTRING)
    hr = CLSIDFromProgID(L"MediaPlayer.MediaPlayer.1", &clsid);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CLSIDFromProgID for MediaPlayer.MediaPlayer failed %x\n", hr);
        return 3;
    }
    hr = CoCreateInstance(&clsid, NULL, CLSCTX_LOCAL_SERVER, &IID_IUnknown, (PVOID *)&pUnk);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CoCreateInstance for MediaPlayer.MediaPlayer failed %x\n", hr);
        return 3;
    }
    Sleep(5000);
    IUnknown_Release(pUnk);
    pUnk = NULL;
#endif

    // Unfortunately, mplay32 has a refcounting problem and doesn't close
    // when we release it.  Post a quit message to make it close.
    hwnd = FindWindowW(NULL, L"Windows Media Player");
    if (hwnd) {
        PostMessage(hwnd, WM_QUIT, 0, 0);
    }

    // Wrap up COM now
    CoUninitialize();

    PrintToLog("WOW64BVT1: Child process done OK.\n");
    return 0;
}

////////////  All this code runs in a worker thread in the main process //////
//// Prefix any output by "WOW64BVT" so it can be identified as coming from
//// the parent process.

DWORD BeAThread(LPVOID lpParam)
{
    NTSTATUS st;
    LPWSTR lp;

    PrintToLog("WOW64BVT: Worker thread running\n");

    // Call an API close to the end of whnt32.c's dispatch table
    st = NtYieldExecution();
    if (FAILED(st)) {
        PrintToLog("ERROR: WOW64BVT: NtYieldExecution failed %x\n", st);
        exit(1);
    }

    // Call an API close to the end of whwin32.c's dispatch table.  Pass NULL,
    // so it is expected to fail.
    lp = EngGetPrinterDataFileName(NULL);    // calls NtGdiGetDhpdev()
    if (lp) {
        // It succeeded.... it shouldn't have since 
        PrintToLog("ERROR: WOW64BVT: EngGetPrinterDataFileName succeeeded when it should not have.\n");
        exit(1);
    }

    PrintToLog("WOW64BVT: Worker thread done OK.\n");
    return 0;
}

HANDLE CreateTheThread(void)
{
    HANDLE h;
    DWORD dwThreadId;

    PrintToLog("WOW64BVT: Creating child thread\n");
    h = CreateThread(NULL, 0, BeAThread, NULL, 0, &dwThreadId);
    if (h == INVALID_HANDLE_VALUE) {
        PrintToLog("ERROR: WOW64BVT: Error %d creating worker thread.\n", GetLastError());
        exit(2);
    }
    // Sleep a bit here, to try and let the child thread run a bit
    Sleep(10);
    return h;
}

BOOL AllocateStackAndTouch(
    INT Count)
{
    char temp[4096];

    memset(temp, 0, sizeof(temp));

    if (--Count) {
        AllocateStackAndTouch(Count);
    }

    return TRUE;
}

DWORD WINAPI TestGuardPagesThreadProc(
    PVOID lpParam)
{
    
    try {
        AllocateStackAndTouch(PtrToUlong(lpParam));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        PrintToLog("ERROR: WOW64BVT: Error allocating stack. Exception Code = %lx\n",
               GetExceptionCode());
        exit(1);
    }

    return 0;
}

int TestGuardPages(
    VOID)
{
    HANDLE h;
    DWORD dwExitCode, dwThreadId;
    BOOL b;
    ULONG NestedStackCount = 100;
    DWORD StackSize = 4096;
    
    
    PrintToLog("WOW64BVT: Creating worker threads to test guard pages\n");

    while (StackSize < (32768+1))
    {
        h = CreateThread(NULL, 
                         StackSize, 
                         TestGuardPagesThreadProc, 
                         UlongToPtr(NestedStackCount), 
                         0, 
                         &dwThreadId);
        if (h == INVALID_HANDLE_VALUE) {
            PrintToLog("ERROR: WOW64BVT:  Error %d creating worker thread for guard page tests.\n", GetLastError());
            exit(2);
        }
        StackSize += 4096;
        WaitForSingleObject(h, INFINITE);

        b = GetExitCodeThread(h, &dwExitCode);
        if (b) {
             if (dwExitCode) {
                 return (int)dwExitCode;
             }
        } else {
            PrintToLog("ERROR: GetExitCodeThread failed with LastError = %d\n", GetLastError());
            return 1;
        }
    }

    PrintToLog("WOW64BVT: Test guard pages done OK.\n");

    return 0;
}


int TestMemoryMappedFiles(
    VOID)
{
    HANDLE Handle;
    PWCHAR pwc;
    MEMORY_BASIC_INFORMATION mbi;
    BOOL ExceptionHappened = FALSE;
  
    
    PrintToLog("WOW64BVT: Testing memory mapped files\n");

    Handle = CreateFileMappingW(INVALID_HANDLE_VALUE,
                                NULL,
                                SEC_RESERVE | PAGE_READWRITE,
                                0,
                                32 * 1024,
                                L"HelloWorld");

    if (Handle == INVALID_HANDLE_VALUE) {
        PrintToLog("ERROR: WOW64BVT : Error %d creating file mapping\n", GetLastError());
        return 1;
    }

    pwc = (PWCHAR)MapViewOfFile(Handle,
                                FILE_MAP_WRITE,
                                0,
                                0,
                                0);

    if (!pwc) {
        PrintToLog("ERROR: WOW64BVT : Error %d mapping section object\n", GetLastError());
        return 1;
    }

    if (!VirtualQuery(pwc,
                      &mbi,
                      sizeof(mbi))) {
        PrintToLog("ERROR: WOW64BVT : Virtual query failed with last error = %d\n", GetLastError());
        return 1;
    }

    if (mbi.State != MEM_RESERVE) {
        PrintToLog("ERROR: WOW64BVT : Memory attributes have changed since mapped %lx\n", mbi.State);
        return 1;
    }

    try {
        *pwc = *(pwc+1);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExceptionHappened = TRUE;
    }

    if (ExceptionHappened == FALSE) {
        PrintToLog("ERROR: WOW64BVT : Memory has been committed while it should have ONLY been reserved.\n");
        return 1;
    }

    if (!VirtualQuery(pwc,
                      &mbi,
                      sizeof(mbi))) {
        PrintToLog("ERROR: WOW64BVT : Virtual query failed with last error = %d\n", GetLastError());
        return 1;
    }

    if (mbi.State != MEM_RESERVE) {
        PrintToLog("ERROR: WOW64BVT : Memory attributes have changed since mapped %lx\n", mbi.State);
        return 1;
    }

    UnmapViewOfFile(pwc);
    CloseHandle(Handle);

    PrintToLog("WOW64BVT: Testing memory mapped files done OK.\n");

    return 0;
}

BOOL ReleasePages(PVOID Address, 
                  DWORD DeAllocationType, 
                  SIZE_T ReleasedPages)
{

    PVOID p = Address;
    SIZE_T nPages = ReleasedPages;
    NTSTATUS NtStatus;

    NtStatus = NtFreeVirtualMemory(NtCurrentProcess(),
                                   &p,
                                   &nPages,
                                   DeAllocationType);

    return NT_SUCCESS(NtStatus);
}

BOOL VerifyPages(PVOID Address,
                 DWORD DeAllocationType,
                 SIZE_T ReleasedPages)
{
    DWORD PagesState;
    BOOL b;
    MEMORY_BASIC_INFORMATION mbi;

    if (DeAllocationType == MEM_DECOMMIT)
    {
        PagesState = MEM_RESERVE;
    }
    else if (DeAllocationType == MEM_RELEASE)
    {
        PagesState = MEM_FREE;
    }
    else
    {
        PagesState = DeAllocationType;
    }


    b = VirtualQuery(Address,
                     &mbi,
                     sizeof(mbi));

    if (b)
    {
        if (mbi.State != PagesState)
        {
            PrintToLog("ERROR: WOW64BVT: Incorrect page protection set at address %p. State = %lx - %lx, RegionSize = %lx - %lx\n",
                        Address, mbi.State, PagesState, mbi.RegionSize, ReleasedPages);
            b = FALSE;
        }
    }
    else
    {
        PrintToLog("ERROR: WOW64BVT: Failed to query virtual memory at address %p - %lx\n",
                    Address, GetLastError());
    }

    return b;
}


BOOL ReleaseVerifyPages(PVOID BaseAllocation,
                       PVOID *Address,
                       SIZE_T *AllocationSize,
                       DWORD AllocationType,
                       DWORD DeAllocationType,
                       DWORD ReleasedPages)
{
    BOOL b;

    if (ReleasedPages > *AllocationSize)
    {
        ReleasedPages = *AllocationSize;
    }
    
    b = ReleasePages(*Address, DeAllocationType, ReleasedPages);
    if (b == FALSE)
    {
        PrintToLog("ERROR: WOW64BVT: Failed to release a page - %lx\n", GetLastError());
        return b;
    }
    
    b = VerifyPages(*Address, 
                    DeAllocationType, 
                    ReleasedPages);

    *AllocationSize -= ReleasedPages;
    *Address  = (PVOID)((ULONG_PTR)*Address + ReleasedPages);

    if (b == FALSE)
    {
        PrintToLog("ERROR: WOW64BVT: Failed to verify pages at address %lx - %lx\n",
                    ((ULONG_PTR)Address + ReleasedPages), GetLastError());
    }

    return b;
}


BOOL TestVadSplitOnFreeHelper(DWORD AllocationType, 
                              DWORD DeAllocationType,
                              SIZE_T TotalAllocation)
{
    BOOL b;
    PVOID Address;
    PVOID BaseAllocation;
    SIZE_T BaseAllocationSize;
    INT n;

    Address = VirtualAlloc(NULL,
                           TotalAllocation,
                           AllocationType,
                           PAGE_READWRITE);

    if (Address == NULL)
    {
        PrintToLog("ERROR: WOW64BVT: Failed to allocate memory - %lx\n", GetLastError());
    }

    n = 1;
    BaseAllocation = Address;
    BaseAllocationSize = TotalAllocation;
    while (TotalAllocation != 0)
    {
        b = ReleaseVerifyPages(BaseAllocation,
                               &Address,
                               &TotalAllocation,
                               AllocationType,
                               DeAllocationType,
                               PAGE_4K * n);

        if (b == FALSE)
        {
            PrintToLog("ERROR: WOW64BVT: ReleaseVerifyPages failed - %lx. %lx-%lx-%lx", 
                        GetLastError(), BaseAllocation, Address, TotalAllocation);
            break;
        }
        b = VerifyPages(BaseAllocation,
                        DeAllocationType,
                        n * PAGE_4K);

        if (b == FALSE)
        {
            PrintToLog("ERROR: WOW64BVT: Verify released pages from address %p with length = %lx failed\n", BaseAllocation, (n * PAGE_4K));
            break;
        }

        if (TotalAllocation > 0)
        {
            b = VerifyPages(Address,
                            AllocationType,
                            TotalAllocation);

            if (b == FALSE)
            {
                PrintToLog("ERROR: WOW64BVT: Verify pages from address %p with length = %lx failed\n", BaseAllocation, TotalAllocation);
                break;
            }
        }

        n += 2;
    }

    return b;
}


int TestVadSplitOnFree()
{
    BOOL b;
    SIZE_T AllocationSize = (PAGE_4K * 10);


    PrintToLog("WOW64BVT: Testing VAD splitting...\n");

    b = TestVadSplitOnFreeHelper(MEM_COMMIT,
                                 MEM_DECOMMIT,
                                 AllocationSize);

    if (b)
    {
        b = TestVadSplitOnFreeHelper(MEM_COMMIT,
                                     MEM_RELEASE,
                                     AllocationSize);
    }

    if (b)
    {
        b = TestVadSplitOnFreeHelper(MEM_RESERVE,
                                     MEM_RELEASE,
                                     AllocationSize);
    }

    if (b != FALSE)
    {
        PrintToLog("WOW64BVT: Testing VAD splitting...OK\n");
    }
    else
    {
        PrintToLog("ERROR: WOW64BVT: Testing VAD splitting\n");
    }

    return (b == FALSE);
}


PVOID GetReadOnlyBuffer()
{
    PVOID pReadOnlyBuffer = NULL;

    if (!pReadOnlyBuffer)
    {
        SYSTEM_INFO SystemInfo;

        // Get system info so that we know the page size
        GetSystemInfo(&SystemInfo);

        // Allocate a whole page.  This is optimal.
        pReadOnlyBuffer = VirtualAlloc(NULL, SystemInfo.dwPageSize, MEM_COMMIT, PAGE_READWRITE);
        if (pReadOnlyBuffer)
        {
            // Fill it with know patern
            FillMemory(pReadOnlyBuffer, SystemInfo.dwPageSize, 0xA5);
            
            // Mark the page readonly
            pReadOnlyBuffer = VirtualAlloc(pReadOnlyBuffer, SystemInfo.dwPageSize, MEM_COMMIT, PAGE_READONLY);
        }
    }

    return pReadOnlyBuffer;
}

PVOID GetReadOnlyBuffer2()
{
    PVOID pReadOnlyBuffer = NULL;

    DWORD OldP;
    SYSTEM_INFO SystemInfo;

    // Get system info so that we know the page size
    GetSystemInfo(&SystemInfo);

    // Allocate a whole page.  This is optimal.
    pReadOnlyBuffer = VirtualAlloc(NULL, SystemInfo.dwPageSize, MEM_COMMIT, PAGE_READWRITE);

    if (pReadOnlyBuffer)
    {
        FillMemory(pReadOnlyBuffer, SystemInfo.dwPageSize, 0xA5);
        lstrcpy((PTSTR)pReadOnlyBuffer, TEXT("xxxxxxxxxxxxxxxxxxxx"));

        if (!VirtualProtect(pReadOnlyBuffer, SystemInfo.dwPageSize, PAGE_READONLY, &OldP))
        {
            PrintToLog("ERROR: WOW64BVT: VirtualProtect() failed inside GetReadOnlyBuffer2()\n");
            VirtualFree(pReadOnlyBuffer, 0, MEM_RELEASE);

            pReadOnlyBuffer = NULL;
        }

    }

    return pReadOnlyBuffer;

}

BOOL TestMmPageProtection()
{
    PTSTR String;
    BOOL AV = FALSE;


    PrintToLog("WOW64BVT: Testing MM Page Protection...\n");

    String = (PTSTR) GetReadOnlyBuffer();
    if (!String) {
        PrintToLog("ERROR: WOW64BVT: GetReadOnlyBuffer() failed\n");
        return TRUE;
    }

    try {
        *String = TEXT('S');
    } except(EXCEPTION_EXECUTE_HANDLER) {
        AV = TRUE;
    }

    VirtualFree(String, 0, MEM_RELEASE);

    if (AV == TRUE) {
        
        AV = FALSE;
        String = (PTSTR) GetReadOnlyBuffer2();

        if (!String) {
            PrintToLog("ERROR: WOW64BVT: GetReadOnlyBuffer2() failed\n");
            return TRUE;
        }

        try {
            *String = TEXT('A');
        } except(EXCEPTION_EXECUTE_HANDLER) {
            AV = TRUE;
        }

        VirtualFree(String, 0, MEM_RELEASE);
    } else {
        PrintToLog("ERROR: WOW64BVT: GetReadOnlyBuffer() failed to make 4K pages read only\n");
    }


    if (AV == TRUE) {
        PrintToLog("WOW64BVT: Testing MM Page Protection...OK\n");
    } else {
        PrintToLog("ERROR: WOW64BVT: Testing MM Page Protection\n");
    }

    return (AV == FALSE);
}

#define STACK_BUFFER  0x300
BOOL TestX86MisalignedLock()
{
    BOOL bError = FALSE;

    PrintToLog("WOW64BVT: Testing X86 Lock on misaligned addresses...\n");
    
    __try
    {
        __asm
        {
        pushad;
        pushfd;

        sub esp, STACK_BUFFER;

        ;;
        ;; make eax  unaliged with respect to an 8-byte cache line
        ;;

        mov eax, esp;
        add eax, 10h;
        mov ecx, 0xfffffff0;
        and eax, ecx;
        add eax, 7;
        mov ebx, eax;

        ;;
        ;; add
        ;;

        mov DWORD PTR [eax], 0x0300;
        lock add WORD PTR [eax], 0x0004;
        cmp DWORD PTR [eax], 0x0304;
        jnz $endwitherrornow;


        mov DWORD PTR [eax], 0x0300;
        lock add DWORD PTR [eax], 0x10000;
        cmp DWORD PTR [eax], 0x10300;
        jnz $endwitherrornow;

        mov ecx, DWORD PTR [eax+8];
        add ecx, 0x10;
        lock add DWORD PTR [eax+8], 0x10;
        cmp DWORD PTR [eax+8], ecx;
        jnz $endwitherrornow;
        
        mov ecx, DWORD PTR fs:[5];
        mov esi, 0x30000;
        lock add DWORD PTR fs:[5], esi;
        add esi, ecx;
        cmp DWORD PTR fs:[5], esi;
        mov DWORD PTR fs:[5], ecx;
        jnz $endwitherrornow;

        mov edi, 5;
        mov ecx, DWORD PTR fs:[edi];
        mov esi, 0x30000;
        lock add DWORD PTR fs:[edi], esi;
        add esi, ecx;
        cmp DWORD PTR fs:[edi], esi;
        mov DWORD PTR fs:[edi], ecx;
        jnz $endwitherrornow;

        mov esi, 0x40;
        mov WORD PTR [eax], 0x3000;
        lock add WORD PTR [eax], si;
        cmp WORD PTR [eax], 0x3040;
        jnz $endwitherrornow;

        mov edi, 0x40;
        mov DWORD PTR [eax], 0x3000;
        lock add DWORD PTR [eax], edi;
        cmp DWORD PTR [eax], 0x3040;
        jnz $endwitherrornow;

        ;;
        ;; adc
        ;;

        pushfd;
        pop ecx;
        or ecx, 1;
        push ecx;
        popfd;
        mov DWORD PTR [eax], 0x030000;
        lock adc DWORD PTR [eax], 0x40000;
        cmp DWORD PTR [eax], 0x70001;
        jnz $endwitherrornow;

        pushfd;
        pop ecx;
        and ecx, 0xfffffffe;
        push ecx;
        popfd;
        mov dx, 0x4000;
        mov WORD PTR [eax], 0x03000;
        lock adc WORD PTR [eax], dx;
        cmp WORD PTR [eax], 0x7000;
        jnz $endwitherrornow;

        pushfd;
        pop ecx;
        or ecx, 0x01;
        push ecx;
        popfd;
        mov WORD PTR [eax], 0x03000;
        lock adc WORD PTR [eax], 0x04000;
        cmp WORD PTR [eax], 0x7001;
        jnz $endwitherrornow;        


        ;;
        ;; and
        ;;

        mov DWORD PTR [eax], 0xffffffff;
        lock and DWORD PTR [eax], 0xffff;
        cmp DWORD PTR [eax], 0xffff;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xffffffff;
        lock and DWORD PTR [eax], 0xff00ff00;
        cmp DWORD PTR [eax], 0xff00ff00;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xffffffff;
        mov esi, 0x00ff00ff
        lock and DWORD PTR [eax], esi;
        cmp DWORD PTR [eax], esi;
        jnz $endwitherrornow;

        mov ecx, 4;
        mov DWORD PTR [eax+ecx*2], 0xffffffff;
        mov esi, 0xffff00ff
        lock and DWORD PTR [eax+ecx*2], esi;
        cmp DWORD PTR [eax+ecx*2], 0xffff00ff;
        jnz $endwitherrornow;

        mov WORD PTR [eax], 0xffff;
        mov si, 0xff
        lock and WORD PTR [eax], si;
        cmp WORD PTR [eax], si;
        jnz $endwitherrornow;

        mov edi, DWORD PTR fs:[5];
        mov DWORD PTR fs:[5], 0xffffffff;
        mov ebx, 5;
        lock and DWORD PTR fs:[ebx], 0xff00ff00;
        cmp DWORD PTR fs:[ebx], 0xff00ff00;
        mov DWORD PTR fs:[ebx], edi;
        jnz $endwitherrornow;

        ;;
        ;; or
        ;;

        mov DWORD PTR [eax], 0x00;
        lock or DWORD PTR [eax], 0xffff;
        cmp DWORD PTR [eax], 0xffff;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xff00ff00;
        lock or DWORD PTR [eax], 0xff00ff;
        cmp DWORD PTR [eax], 0xffffffff;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xff000000;
        mov esi, 0x00ff00ff
        lock or DWORD PTR [eax], esi;
        cmp DWORD PTR [eax], 0xffff00ff;
        jnz $endwitherrornow;

        mov ecx, 4;
        mov DWORD PTR [eax+ecx*2], 0xff000000;
        mov esi, 0x00ff00ff
        lock or DWORD PTR [eax+ecx*2], esi;
        cmp DWORD PTR [eax+ecx*2], 0xffff00ff;
        jnz $endwitherrornow;

        mov WORD PTR [eax], 0xf000;
        mov si, 0xff
        lock or WORD PTR [eax], si;
        cmp WORD PTR [eax], 0xf0ff;
        jnz $endwitherrornow;

        mov edi, DWORD PTR fs:[5];
        mov DWORD PTR fs:[5], 0x00;
        mov ebx, 5;
        lock or DWORD PTR fs:[ebx], 0xff00ff00;
        cmp DWORD PTR fs:[ebx], 0xff00ff00;
        mov DWORD PTR fs:[ebx], edi;
        jnz $endwitherrornow;

        ;;
        ;; xor
        ;;

        mov DWORD PTR [eax], 0x00ffffff;
        lock xor DWORD PTR [eax], 0xffff;
        cmp DWORD PTR [eax], 0x00ff0000;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xff00ff00;
        lock xor DWORD PTR [eax], 0xff00ff;
        cmp DWORD PTR [eax], 0xffffffff;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xff0000ff;
        mov esi, 0x00ff00ff
        lock xor DWORD PTR [eax], esi;
        cmp DWORD PTR [eax], 0xffff0000;
        jnz $endwitherrornow;

        mov ecx, 4;
        mov DWORD PTR [eax+ecx*2], 0xff000000;
        mov esi, 0xffff00ff
        lock xor DWORD PTR [eax+ecx*2], esi;
        cmp DWORD PTR [eax+ecx*2], 0x00ff00ff;
        jnz $endwitherrornow;

        mov WORD PTR [eax], 0xf000;
        mov si, 0xf0ff
        lock xor WORD PTR [eax], si;
        cmp WORD PTR [eax], 0x00ff;
        jnz $endwitherrornow;

        mov edi, DWORD PTR fs:[5];
        mov DWORD PTR fs:[5], 0x0f;
        mov ebx, 5;
        lock xor DWORD PTR fs:[ebx], 0xff00000f;
        cmp DWORD PTR fs:[ebx], 0xff000000;
        mov DWORD PTR fs:[ebx], edi;
        jnz $endwitherrornow;

        ;;
        ;; inc & dec
        ;;
        mov DWORD PTR [eax], 0xffff;
        lock inc DWORD PTR [eax];
        cmp DWORD PTR [eax], 0x10000;
        jnz $endwitherrornow;
        lock inc WORD PTR [eax];
        cmp WORD PTR [eax], 0x0001;
        lock dec WORD PTR [eax];
        jnz $endwitherrornow;
        cmp WORD PTR [eax], 0x00;
        jnz $endwitherrornow;
        mov DWORD PTR [eax], 0;
        lock dec DWORD PTR [eax];
        cmp DWORD PTR [eax], 0xffffffff;
        jnz $endwitherrornow;
        
        ;;
        ;; not
        ;;
        mov DWORD PTR [eax], 0x10101010;
        lock not DWORD PTR [eax];
        cmp DWORD PTR [eax], 0xefefefef;
        jnz $endwitherrornow;
        mov DWORD PTR [eax+8], 0xffff0000;
        lock not DWORD PTR [eax+8];
        cmp DWORD PTR [eax+8], 0x0000ffff;
        jnz $endwitherrornow;
        mov ecx, 2;
        mov DWORD PTR [eax+ecx*4], 0xffffffff;
        lock not DWORD PTR [eax+ecx*4];
        cmp DWORD PTR [eax+ecx*4], 0x00000000;
        jnz $endwitherrornow;

        ;;
        ;; neg
        ;;
        mov DWORD PTR [eax], 0;
        lock neg DWORD PTR [eax];
        jc $endwitherrornow;
        cmp DWORD PTR [eax], 0;
        jnz $endwitherrornow;
        mov DWORD PTR [eax], 0xffffffff;
        lock neg DWORD PTR [eax];
        jnc $endwitherrornow;
        cmp DWORD PTR [eax], 0x01;
        jnz $endwitherrornow;

        mov WORD PTR [eax], 0xff;
        lock neg WORD PTR [eax];
        jnc $endwitherrornow;
        cmp WORD PTR [eax], 0xff01;
        jnz $endwitherrornow;

        ;;
        ;; bts
        ;;

        mov DWORD PTR [eax], 0x7ffffffe;
        lock bts DWORD PTR [eax], 0;
        jc $endwitherrornow;
        cmp DWORD PTR [eax], 0x7fffffff;
        jnz $endwitherrornow;

        mov ecx, eax;
        sub ecx, 4;
        mov edx, 63;
        lock bts DWORD PTR [ecx], edx;
        jc $endwitherrornow;
        cmp DWORD PTR [eax], 0xffffffff
        jnz $endwitherrornow;

        ;;
        ;; xchg
        ;;
        
        mov DWORD PTR [eax], 0xf0f0f0f0;
        mov edx, 0x11112222;
        lock xchg DWORD PTR [eax], edx;
        cmp DWORD PTR [eax], 0x11112222;
        jnz $endwitherrornow;
        cmp edx, 0xf0f0f0f0;
        jnz $endwitherrornow;

        xchg WORD PTR [eax], dx;
        cmp WORD PTR [eax], 0xf0f0;
        jnz $endwitherrornow;
        cmp dx, 0x2222;
        jnz $endwitherrornow;

        ;;
        ;; cmpxchg
        ;;

        mov ebx, eax;
        mov DWORD PTR [ebx], 0xf0f0f0f0;
        mov eax, 0x10101010;
        mov edx, 0x22332233;
        lock cmpxchg DWORD PTR [ebx], edx;
        jz $endwitherrornow;
        cmp eax, 0xf0f0f0f0;
        jnz $endwitherrornow;

        mov DWORD PTR [ebx], 0xf0f0f0f0;
        mov eax, 0xf0f0f0f0;
        mov edx, 0x12341234;
        lock cmpxchg DWORD PTR [ebx], edx;
        jnz $endwitherrornow;
        cmp DWORD PTR [ebx], 0x12341234;
        jnz $endwitherrornow;

        ;;
        ;; cmpxchg8b
        ;;

        mov DWORD PTR [ebx], 0x11223344;
        mov DWORD PTR [ebx+4], 0x55667788;
        mov edx, 0x12341234;
        mov eax, 0xff00ff00;
        lock cmpxchg8b [ebx];
        jz $endwitherrornow;
        cmp edx, 0x55667788;
        jnz $endwitherrornow;
        cmp eax, 0x11223344;
        jnz $endwitherrornow;

        mov esi, ebx;
        mov DWORD PTR [esi], 0x11223344;
        mov DWORD PTR [esi+4], 0x55667788;
        mov edx, 0x55667788;
        mov eax, 0x11223344;
        mov ecx, 0x10101010;
        mov ebx, 0x20202020;
        lock cmpxchg8b [esi];
        jnz $endwitherrornow;
        cmp DWORD PTR [esi], 0x20202020;
        jnz $endwitherrornow;
        cmp DWORD PTR [esi+4], 0x10101010;
        jnz $endwitherrornow;
        
        mov eax, esi;
        mov ebx, eax;

        ;;
        ;; sub
        ;;

        mov DWORD PTR [eax], 0x0300;
        lock sub WORD PTR [eax], 0x0004;
        cmp DWORD PTR [eax], 0x2fc;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0x10000;
        lock sub DWORD PTR [eax], 0x0300;
        cmp DWORD PTR [eax], 0xfd00;
        jnz $endwitherrornow;

        mov ecx, DWORD PTR [eax+8];
        sub ecx, 0x10;
        lock sub DWORD PTR [eax+8], 0x10;
        cmp DWORD PTR [eax+8], ecx;
        jnz $endwitherrornow;
        
        mov ecx, DWORD PTR fs:[5];
        mov esi, 0x3000;
        lock sub DWORD PTR fs:[5], esi;
        mov edi, ecx;
        sub ecx, esi;
        cmp DWORD PTR fs:[5], ecx;
        mov DWORD PTR fs:[5], edi;
        jnz $endwitherrornow;

        mov edi, 5;
        mov ecx, DWORD PTR fs:[edi];
        mov esi, 0x30000;
        lock sub DWORD PTR fs:[edi], esi;
        mov edx, ecx;
        sub ecx, esi;
        cmp DWORD PTR fs:[edi], ecx;
        mov DWORD PTR fs:[edi], edx;
        jnz $endwitherrornow;

        mov si, 0x40;
        mov WORD PTR [eax], 0x3000;
        lock sub WORD PTR [eax], si;
        cmp WORD PTR [eax], 0x2fc0;
        jnz $endwitherrornow;

        mov edi, 0x40;
        mov DWORD PTR [eax], 0x3000;
        lock sub DWORD PTR [eax], edi;
        cmp DWORD PTR [eax], 0x2fc0;
        jnz $endwitherrornow;

        ;;
        ;; sbb
        ;;

        pushfd;
        pop ecx;
        or ecx, 1;
        push ecx;
        popfd;
        mov DWORD PTR [eax], 0x030000;
        lock sbb DWORD PTR [eax], 0x40000;
        cmp DWORD PTR [eax], 0xfffeffff;
        jnz $endwitherrornow;

        pushfd;
        pop ecx;
        and ecx, 0xfffffffe;
        push ecx;
        popfd;
        mov dx, 0x4000;
        mov WORD PTR [eax], 0x03000;
        lock sbb WORD PTR [eax], dx;
        cmp WORD PTR [eax], 0xf000;
        jnz $endwitherrornow;

        pushfd;
        pop ecx;
        or ecx, 0x01;
        push ecx;
        popfd;
        mov WORD PTR [eax], 0x03000;
        lock sbb WORD PTR [eax], 0x04000;
        cmp WORD PTR [eax], 0xefff;
        jnz $endwitherrornow;        

        ;;
        ;; xadd
        ;;

        mov DWORD PTR [eax], 0x12345678;
        mov ecx, 0x1234;
        lock xadd DWORD PTR [eax], ecx;
        cmp ecx, 0x12345678;
        jnz $endwitherrornow;        
        mov edx, 0x1234;
        add edx, 0x12345678;
        cmp DWORD PTR [eax], edx;
        jnz $endwitherrornow;        

        mov WORD PTR [eax], 0x5678;
        mov cx, 0x1234;
        lock xadd WORD PTR [eax], cx;
        cmp cx, 0x5678;
        jnz $endwitherrornow;        
        mov dx, 0x5678;
        add dx, 0x1234;
        cmp WORD PTR [eax], dx;
        jnz $endwitherrornow;        

        ;;
        ;; Update caller with status
        ;;
        mov bError, 0
        jmp $endnow;

$endwitherrornow:

        mov bError, 1
$endnow:
        add esp, STACK_BUFFER;
        popfd;
        popad;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        bError = TRUE;
        printf("ERROR: WOW64BVT: Exception %lx\n", GetExceptionCode());
    }

    if (bError == FALSE) {
        PrintToLog("WOW64BVT: Testing X86 Lock on misaligned addresses...OK\n");
    } else {
        PrintToLog("ERROR: WOW64BVT: Testing X86 Lock on misaligned addresses\n");
    }

    return bError;
}

////////////  All this code runs in the main test driver thread //////

HANDLE CreateTheChildProcess(char *ProcessName, char *LogFileName)
{
    char Buffer[512];
    HANDLE h;
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    BOOL b;

    PrintToLog("WOW64BVT: Creating child process\n");

    strcpy(Buffer, ProcessName);
    strcat(Buffer, " childprocess");
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    if (fpLogFile) {
        // If we're logging, then change the child process' stdout/stderr
        // to be the log file handle, so their output is captured to the file.
        HANDLE hLog = (HANDLE)_get_osfhandle(_fileno(fpLogFile));

        si.dwFlags = STARTF_USESTDHANDLES;
        si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
        si.hStdOutput = hLog;
        si.hStdError = hLog;
    }
    b = CreateProcessA(NULL, Buffer, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
    if (!b) {
        PrintToLog("ERROR: WOW64BVT:  Error %d creating child process.\n", GetLastError());
        exit(1);
    }
    CloseHandle(pi.hThread);
    return pi.hProcess;
}

// This is called from within exit() in the main test driver process
void __cdecl AtExitHandler(void)
{
    time_t EndTime;
    struct tm *newtime;
    OSVERSIONINFOW vi;
    BOOL b;
    int year, hour;

    memset(&vi, 0, sizeof(vi));
    vi.dwOSVersionInfoSize = sizeof(vi);
    b = GetVersionExW(&vi);
    if (!b) {
        PrintToLog("\tWARNING: GetVersionExW failed, LastError = %d\n", GetLastError());
        vi.dwBuildNumber = 0;
    }

    // Close the logging bucket.
    PrintToLog(("[/TEST LOGGING OUTPUT]\n"));

    // Print the required data:
    PrintToLog("\tTEST:         wow64bvt\n");
    PrintToLog("\tBUILD:        %d\n", vi.dwBuildNumber);
    PrintToLog("\tMACHINE:      \\\\%s\n", getenv("COMPUTERNAME"));
    PrintToLog("\tRESULT:       %s\n", (g_bError) ? "FAIL" : "PASS");
    PrintToLog("\tCONTACT:      samera\n");
    PrintToLog("\tMGR CONTACT:  samera\n");
    PrintToLog("\tDEV PRIME:    samera\n");
    PrintToLog("\tDEV ALT:      askhalid\n");
    PrintToLog("\tTEST PRIME:   terryla\n");
    PrintToLog("\tTEST ALT:     terryla\n");
    newtime = localtime(&TestStartTime);
    year = (newtime->tm_year >= 100) ? newtime->tm_year-100 : newtime->tm_year;
    if (newtime->tm_hour == 0) {
        hour = 12;
    } else if (newtime->tm_hour > 12) {
        hour = newtime->tm_hour-12;
    } else {
        hour = newtime->tm_hour;
    }
    PrintToLog("\tSTART TIME:   %d/%d/%2.2d %d:%2.2d:%2.2d %s\n", newtime->tm_mon+1,
                                                     newtime->tm_mday,
                                                     year,
                                                     hour,
                                                     newtime->tm_min,
                                                     newtime->tm_sec,
                                                     (newtime->tm_hour < 12) ? "AM" : "PM");

    time(&EndTime);
    newtime = localtime(&EndTime);
    year = (newtime->tm_year >= 100) ? newtime->tm_year-100 : newtime->tm_year;
    if (newtime->tm_hour == 0) {
        hour = 12;
    } else if (newtime->tm_hour > 12) {
        hour = newtime->tm_hour-12;
    } else {
        hour = newtime->tm_hour;
    }
    PrintToLog("\tEND TIME:     %d/%d/%2.2d %d:%2.2d:%2.2d %s\n", newtime->tm_mon+1,
                                                     newtime->tm_mday,
                                                     year,
                                                     hour,
                                                     newtime->tm_min,
                                                     newtime->tm_sec,
                                                     (newtime->tm_hour < 12) ? "AM" : "PM");
    PrintToLog("[/TESTRESULT]\n");
}

//
// This is just used to print out failing exception cases
//
void __cdecl ExceptionWoops(HRESULT want, HRESULT got)
{
	if (got == 0) {
		PrintToLog("==> Exception Skipped. Wanted: 0x%08x, Got: 0x%08x\n", want, got);
	}
	else {
		PrintToLog("==> Unexpected Exception. Wanted: 0x%08x, Got: 0x%08x\n", want, got);
	}
}

#define EXCEPTION_LOOP      10000

// Among other things, this does some divife by zero's (as a test)
// so don't have the compiler stop things just because we're causing an error
#pragma warning(disable:4756)
#pragma warning(disable:4723)

//
// Do some exception checks
//
int __cdecl ExceptionCheck(void)
{
    int failThis;
	int sawException;
    int i;
    char *p = NULL;
	HRESULT code;


    PrintToLog("WOW64BVT: Testing Exception Handling\n");

    // Assume success
    failThis = FALSE;

    // Test a privileged instruction
	sawException = FALSE;
	__try {
		__asm {
			hlt
		}
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_PRIVILEGED_INSTRUCTION) {
            // PrintToLog("Saw privileged instruction\n");
        }
        else {
                PrintToLog("ERROR: Cause a privileged instruction fault\n");
	        ExceptionWoops(STATUS_PRIVILEGED_INSTRUCTION, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
            PrintToLog("ERROR: Cause a privileged instruction fault\n");
        ExceptionWoops(STATUS_PRIVILEGED_INSTRUCTION, code);
        failThis = TRUE;
    }

    // Test an illegal instruction
	sawException = FALSE;
	__try {
		__asm {
			__asm _emit 0xff
			__asm _emit 0xff
			__asm _emit 0xff
			__asm _emit 0xff
		}
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
		if (code == STATUS_ILLEGAL_INSTRUCTION) {
			// PrintToLog("Saw illegal instruction\n");
        }
        else {
            PrintToLog("ERROR: Cause an illegal instruction fault\n");
	        ExceptionWoops(STATUS_ILLEGAL_INSTRUCTION, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an illegal instruction fault\n");
        ExceptionWoops(STATUS_ILLEGAL_INSTRUCTION, code);
        failThis = TRUE;
    }

//
// Testing for an int 3 can be a problem for systems that
// are running checked builds. So, don't bother with this
// test. Perhaps in the future, the code can test for a checked
// build and do appropriate.
//
#if 0
    // Test the result of an int 3
	sawException = FALSE;
	__try {
		_asm {
			int 3
		}
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_BREAKPOINT) {
			// PrintToLog("Saw debugger breakpoint\n");
        }
        else {
            PrintToLog("ERROR: Cause an int 3 debugger breakpoint\n");
	        ExceptionWoops(STATUS_BREAKPOINT, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an int 3 debugger breakpoint\n");
        ExceptionWoops(STATUS_BREAKPOINT, code);
        failThis = TRUE;
    }
#endif

    // Test the result of an illegal int XX instruction
	sawException = FALSE;
	__try {
		_asm {
			int 66
		}
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_ACCESS_VIOLATION) {
			// PrintToLog("Saw access violation\n");
        }
        else {
            PrintToLog("ERROR: Cause an int 66 unknown interrupt (Access violation)\n");
	        ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an int 66 unknown interrupt (Access violation)\n");
        ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
        failThis = TRUE;
    }

    // Test the result of an int divide by zero
	sawException = FALSE;
	__try {
		int i, j, k;

		i = 0;
		j = 4;

		k = j / i;
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_INTEGER_DIVIDE_BY_ZERO) {
			// PrintToLog("Saw int divide by zero\n");
        }
        else {
            PrintToLog("ERROR: Cause an integer divide by zero\n");
	        ExceptionWoops(STATUS_INTEGER_DIVIDE_BY_ZERO, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an integer divide by zero\n");
        ExceptionWoops(STATUS_INTEGER_DIVIDE_BY_ZERO, code);
        failThis = TRUE;
    }

    // Test the result of an fp divide by zero
	// PrintToLog("Before div0: Control is 0x%0.4x, Status is 0x%0.4x\n", _control87(0,0), _status87());
	sawException = FALSE;
	__try {
		double x, y;

		y = 0.0;

		x = 1.0 / y ;

		// PrintToLog("x is %lf\n", x);

		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
		// Don't actually get a divide by zero error, get
		// so we should never hit this exception!
        PrintToLog("Try a floating divide by zero\n");
		PrintToLog("Woops! Saw an exception when we shouldn't have!\n");
		sawException = TRUE;
            failThis = TRUE;
	}
	// So you would think you'd get a float divide by zero error... Nope,
	// you get X set to infinity...
	if (code != 0) {
        PrintToLog("ERROR: Try a floating divide by zero\n");
        ExceptionWoops(0, code);
        failThis = TRUE;
    }
	// PrintToLog("After div0: Control is 0x%0.4x, Status is 0x%0.4x\n", _control87(0,0), _status87());


    // Test an int overflow (which actually does not cause an exception)
	sawException = FALSE;
	__try {
		__asm {
			into
		}
		// PrintToLog("into doesn't fault\n");
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_INTEGER_OVERFLOW) {
			// PrintToLog("Saw integer overflow\n");
        }
        else {
            PrintToLog("ERROR: Try an into overflow fault\n");
	        ExceptionWoops(STATUS_INTEGER_OVERFLOW, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	// Looks like integer overflow is ok... Is this a CRT thing?
	if (code != 0) {
        PrintToLog("ERROR: Try an into overflow fault\n");
        ExceptionWoops(0, code);
        failThis = TRUE;
    }

    // Test an illegal access
	sawException = FALSE;
	__try {

		*p = 1;
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_ACCESS_VIOLATION) {
			// PrintToLog("Saw access violation\n");
        }
        else {
            PrintToLog("ERROR: Cause an access violation\n");
	        ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an access violation\n");
        ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
        failThis = TRUE;
    }

    //
    // Finally, try a lot of exceptions (a loop) and verify we don't overflow
    // the stack
    //
    for (i = 0; i < EXCEPTION_LOOP; i++) {
        
        // Test an illegal access
        sawException = FALSE;
        __try {
            *p = 1;
            code = 0;
        }
        __except((code = GetExceptionCode()), 1 ) {
            if (code == STATUS_ACCESS_VIOLATION) {
                // PrintToLog("Saw access violation\n");
            }
            else {
                PrintToLog("ERROR: Cause an access violation\n");
                ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
                failThis = TRUE;
                break;
            }
            sawException = TRUE;
        }
        if (!sawException) {
            PrintToLog("ERROR: Cause an access violation\n");
            ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
            failThis = TRUE;
            break;
        }
    }

	return failThis;
}

// Ok, go back to normal warnings...
#pragma warning(default:4756)
#pragma warning(default:4723)

#if defined(__BUILDMACHINE__)
#if defined(__BUILDDATE__)
#define B2(x, y) "" #x "." #y
#define B1(x, y) B2(x, y)
#define BUILD_MACHINE_TAG B1(__BUILDMACHINE__, __BUILDDATE__)
#else
#define B2(x) "" #x
#define B1(x) B2(x)
#define BUILD_MACHINE_TAG B1(__BUILDMACHINE__)
#endif
#else
#define BUILD_MACHINE_TAG ""
#endif

int __cdecl main(int argc, char *argv[])
{
    NTSTATUS st;
    HANDLE HandleList[2];
    BOOL b;
    DWORD dwExitCode;

    // Disable buffering of the standard output handle
    setvbuf(stdout, NULL, _IONBF, 0);

    // Do some minimal command-line checking
    if (argc < 2 || argc > 3) {
        PrintToLog("Usage:  wow64bvt log_file_name\n\n");
        return 1;
    } else if (strcmp(argv[1], "childprocess") == 0) {
        return BeAChildProcess();
    }
    // We're the main exe

    // Record the start time
    time(&TestStartTime);

    // Open the log file
    fpLogFile = fopen(argv[1], "w");
    if (!fpLogFile) {
        PrintToLog("wow64bvt: Error: unable to create the log file '%s'\n", argv[1]);
        return 1;
    }
    // Disable buffering of the log file handle
    setvbuf(fpLogFile, NULL, _IONBF, 0);

    // Print the initial banner
    PrintToLog("[TESTRESULT]\n");
    PrintToLog("[TEST LOGGING OUTPUT]\n");
    PrintToLog("%s built on %s at %s by %s\n", argv[0], __DATE__, __TIME__, BUILD_MACHINE_TAG);

    // Register the atexit handler - it closes the logging output section
    // and prints the success/fail information as the BVT test exits.
    atexit(AtExitHandler);

    ///////////////////////////// Test starts here //////////////////////////

    // 32-bit child process creation from 32-bit parent.  The parent instance
    // (running now) tested 32-bit child from 64-bit parent
    HandleList[0] = CreateTheChildProcess(argv[0], argv[1]);

    // Create a thread do so some more work
    HandleList[1] = CreateTheThread();

    // Wait for everything to finish
    WaitForMultipleObjects(sizeof(HandleList)/sizeof(HandleList[0]), HandleList, TRUE, INFINITE);

    // Get the return code from the child process
    b=GetExitCodeProcess(HandleList[0], &dwExitCode);
    if (b) {
        if (dwExitCode) {
            // The child failed.  We should fail too.
            return (int)dwExitCode;
        }
    } else {
        PrintToLog("ERROR: GetExitCodeProcess failed with LastError = %d\n", GetLastError());
        return 1;
    }

    // Get the return code from the thread
    b=GetExitCodeThread(HandleList[1], &dwExitCode);
    if (b) {
        if (dwExitCode) {
            // The child failed.  We should fail too.
            return (int)dwExitCode;
        }
    } else {
        PrintToLog("ERROR: GetExitCodeThread failed with LastError = %d\n", GetLastError());
        return 1;
    }

    b = ExceptionCheck();
    if (b) {
        PrintToLog("ERROR: Exception Handling test.\n");
        return 1;
    }

    b = TestGuardPages();
    if (b) {
        PrintToLog("ERROR: TestGuardPages().\n");
        return 1;
    }

    b = TestMemoryMappedFiles();
    if (b) {
        PrintToLog("ERROR: TestMemoryMappedFiles().\n");
        return 1;
    }

    b = TestVadSplitOnFree();
    if (b) {
        PrintToLog("ERROR: TestVadSplitOnFree()\n");
        return 1;
    }

    b = TestMmPageProtection();
    if (b) {
        PrintToLog("ERROR: TestMmPageProtection()\n");
        return 1;
    }

    b = TestX86MisalignedLock();
    if (b) {
        PrintToLog("ERROR: TestX86MisalignedLock()\n");
        return 1;
    }

    // Everything finished OK.  Clear the error flag and exit.  The atexit
    // callback function will finish filling out the log if this is the
    // main thread.
    g_bError = FALSE;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tests\crash\crash.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

long handler(PEXCEPTION_POINTERS p, BOOLEAN bThrow, BOOLEAN bContinueExecution)
{
    DbgPrint("In handler... record %x, context %x\n", p->ExceptionRecord, p->ContextRecord);  
    
    if(bThrow) {
       DbgPrint("In handler... throwing an exception...\n");
       try {
          RtlRaiseStatus(STATUS_INVALID_PARAMETER);
       }
       except(handler(GetExceptionInformation(), FALSE, FALSE)) {
          DbgPrint("In handler... executed handler\n");
       }
    }
  
    if (bContinueExecution) {
        DbgPrint("In handler... returning EXCEPTION_CONTINUE_EXECUTION...\n");
        return EXCEPTION_CONTINUE_EXECUTION;
    }

    DbgPrint("In handler... returning EXCEPTION_EXECUTE_HANDLER...\n");
    return EXCEPTION_EXECUTE_HANDLER;
}

int main(int argc, char *argv[])
{
    int *p;

    p = NULL;

    DbgPrint("In main... throwing an exception...\n");
    try {
         *p = 1;
    } except (handler(GetExceptionInformation(), FALSE, FALSE)) {
        DbgPrint("In main... executed handler\n");
    }
    DbgPrint("In main... back from exception...\n");

    DbgPrint("In main... throwing an exception with RtlRaiseStatus...\n");
    try {
         RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    } except (handler(GetExceptionInformation(), FALSE, FALSE)) {
        DbgPrint("In main... executed handler\n");
    }
    DbgPrint("In main... back from exception...\n");
    
    DbgPrint("In main... throwing an exception with an exception in exception handler...\n");
    try {
         RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    } except (handler(GetExceptionInformation(), TRUE, FALSE)) {
        DbgPrint("In main... executed handler\n");
    }
    DbgPrint("In main... back from exception...\n");

    DbgPrint("In main... trowing an exception structure that is continueable...\n");
    try {
         EXCEPTION_RECORD Record;
         RtlZeroMemory(&Record, sizeof(EXCEPTION_RECORD));
         Record.ExceptionCode = STATUS_INVALID_PARAMETER;
         Record.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
         Record.NumberParameters = 0;
         Record.ExceptionFlags = 0;
         RtlRaiseException(&Record);
         
         DbgPrint("In main... Execution was continued!\n");

    } except (handler(GetExceptionInformation(), FALSE, TRUE)) {
        DbgPrint("In main... executed handler\n");
    }
    DbgPrint("In main... back from exception...\n");

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tests\generic\generic.h ===
#define IDM_NEW            100
#define IDM_OPEN           101
#define IDM_SAVE           102
#define IDM_SAVEAS         103
#define IDM_PRINT          104
#define IDM_PRINTSETUP     105
#define IDM_EXIT           106
#define IDM_UNDO           200
#define IDM_CUT            201
#define IDM_COPY           202
//---------------------------------------------------------------------------
//  GENERIC.H
//---------------------------------------------------------------------------

#define IDM_PASTE          203
#define IDM_LINK           204
#define IDM_LINKS          205
#define IDM_HELPCONTENTS   300
#define IDM_HELPSEARCH     301
#define IDM_HELPHELP       302
#define IDM_ABOUT          303
#define IDM_HELPTOPICS     304

#define IDC_STATIC -1

#define DLG_VERFIRST        400
#define IDC_COMPANY        DLG_VERFIRST
#define IDC_FILEDESC          DLG_VERFIRST+1
#define IDC_PRODVER         DLG_VERFIRST+2
#define IDC_COPYRIGHT       DLG_VERFIRST+3
#define IDC_OSVERSION       DLG_VERFIRST+4
#define IDC_TRADEMARK       DLG_VERFIRST+5
#define DLG_VERLAST         DLG_VERFIRST+5

#define IDC_LABEL           DLG_VERLAST+1


#define IDS_APP_TITLE       500
#define IDS_DISPLAYCHANGED  501
#define IDS_VER_INFO_LANG   502
#define IDS_VERSION_ERROR   503
#define IDS_NO_HELP         504

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tests\generic\generic.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1996  Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM: Generic.c
//
// PURPOSE: Illustrates the 'minimum' functionality of a well-behaved Win32 application..
//
// PLATFORMS:  Windows 95, Windows NT, Win32s
//
// FUNCTIONS:
//    WinMain() - calls initialization function, processes message loop
//    InitApplication() - Initializes window data nd registers window
//    InitInstance() -saves instance handle and creates main window
//    WindProc() Processes messages
//    About() - Process menssages for "About" dialog box
//    MyRegisterClass() - Registers the application's window class
//    CenterWindow() -  Centers one window over another
//
// SPECIAL INSTRUCTIONS: N/A
//
#define APPNAME "Generic"

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>

// Local Header Files
#include "generic.h"

// Makes it easier to determine appropriate code paths:
#if defined (WIN32)
   #define IS_WIN32 TRUE
#else
   #define IS_WIN32 FALSE
#endif
#define IS_NT      IS_WIN32 && (BOOL)(GetVersion() < 0x80000000)
#define IS_WIN32S  IS_WIN32 && (BOOL)(!(IS_NT) && (LOBYTE(LOWORD(GetVersion()))<4))
#define IS_WIN95 (BOOL)(!(IS_NT) && !(IS_WIN32S)) && IS_WIN32

// Global Variables:

HINSTANCE hInst;      // current instance
char szAppName[100];  // Name of the app
char szTitle[100];    // The title bar text


// Foward declarations of functions included in this code module:

ATOM MyRegisterClass(CONST WNDCLASS*);
BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM);
BOOL CenterWindow (HWND, HWND);
LPTSTR   GetStringRes (int id);


//
//  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)
//
//  PURPOSE: Entry point for the application.
//
//  COMMENTS:
//
// This function initializes the application and processes the
// message loop.
//
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
   MSG msg;
   HANDLE hAccelTable;

   // Initialize global strings
   lstrcpy (szAppName, APPNAME);
   LoadString (hInstance, IDS_APP_TITLE, szTitle, 100);


   if (!hPrevInstance) {
      // Perform instance initialization:
      if (!InitApplication(hInstance)) {
         return (FALSE);
      }
   }

   // Perform application initialization:
   if (!InitInstance(hInstance, nCmdShow)) {
      return (FALSE);
   }

   hAccelTable = LoadAccelerators (hInstance, szAppName);

   // Main message loop:
   while (GetMessage(&msg, NULL, 0, 0)) {
      if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg)) {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
      }
   }

   return (msg.wParam);

   lpCmdLine; // This will prevent 'unused formal parameter' warnings
}

//
//  FUNCTION: MyRegisterClass(CONST WNDCLASS*)
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
// function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(CONST WNDCLASS *lpwc)
{
   HANDLE  hMod;
   FARPROC proc;
   WNDCLASSEX wcex;

   hMod = GetModuleHandle ("USER32");
   if (hMod != NULL) {

#if defined (UNICODE)
      proc = GetProcAddress (hMod, "RegisterClassExW");
#else
      proc = GetProcAddress (hMod, "RegisterClassExA");
#endif

      if (proc != NULL) {

         wcex.style         = lpwc->style;
         wcex.lpfnWndProc   = lpwc->lpfnWndProc;
         wcex.cbClsExtra    = lpwc->cbClsExtra;
         wcex.cbWndExtra    = lpwc->cbWndExtra;
         wcex.hInstance     = lpwc->hInstance;
         wcex.hIcon         = lpwc->hIcon;
         wcex.hCursor       = lpwc->hCursor;
         wcex.hbrBackground = lpwc->hbrBackground;
                     wcex.lpszMenuName  = lpwc->lpszMenuName;
         wcex.lpszClassName = lpwc->lpszClassName;

         // Added elements for Windows 95:
         wcex.cbSize = sizeof(WNDCLASSEX);
         wcex.hIconSm = LoadIcon(wcex.hInstance, "SMALL");

         return (*proc)(&wcex);//return RegisterClassEx(&wcex);
      }
   }
   return (RegisterClass(lpwc));
}


//
//  FUNCTION: InitApplication(HANDLE)
//
//  PURPOSE: Initializes window data and registers window class
//
//  COMMENTS:
//
//       In this function, we initialize a window class by filling out a data
//       structure of type WNDCLASS and calling either RegisterClass or
//       the internal MyRegisterClass.
//
BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    HWND      hwnd;

    // Win32 will always set hPrevInstance to NULL, so lets check
    // things a little closer. This is because we only want a single
    // version of this app to run at a time
    hwnd = FindWindow (szAppName, szTitle);
    if (hwnd) {
        // We found another version of ourself. Lets defer to it:
        if (IsIconic(hwnd)) {
            ShowWindow(hwnd, SW_RESTORE);
        }
        SetForegroundWindow (hwnd);

        // If this app actually had any functionality, we would
        // also want to communicate any action that our 'twin'
        // should now perform based on how the user tried to
        // execute us.
        return FALSE;
        }

        // Fill in window class structure with parameters that describe
        // the main window.
        wc.style         = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc   = (WNDPROC)WndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hInstance;
        wc.hIcon         = LoadIcon (hInstance, szAppName);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);

        // Since Windows95 has a slightly different recommended
        // format for the 'Help' menu, lets put this in the alternate menu like this:
        if (IS_WIN95) {
   wc.lpszMenuName  = "WIN95";
        } else {
   wc.lpszMenuName  = szAppName;
        }
        wc.lpszClassName = szAppName;

        // Register the window class and return success/failure code.
        if (IS_WIN95) {
   return MyRegisterClass(&wc);
        } else {
   return RegisterClass(&wc);
        }
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(szAppName, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
      NULL, NULL, hInstance, NULL);

   if (!hWnd) {
      return (FALSE);
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return (TRUE);
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  MESSAGES:
//
// WM_COMMAND - process the application menu
// WM_PAINT - Paint the main window
// WM_DESTROY - post a quit message and return
//    WM_DISPLAYCHANGE - message sent to Plug & Play systems when the display changes
//    WM_RBUTTONDOWN - Right mouse click -- put up context menu here if appropriate
//    WM_NCRBUTTONUP - User has clicked the right button on the application's system menu
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   int wmId, wmEvent;
   PAINTSTRUCT ps;
   HDC hdc;
      POINT pnt;
   HMENU hMenu;
      BOOL bGotHelp;

   switch (message) {

      case WM_COMMAND:
         wmId    = LOWORD(wParam); // Remember, these are...
         wmEvent = HIWORD(wParam); // ...different for Win32!

         //Parse the menu selections:
         switch (wmId) {

            case IDM_ABOUT:
               DialogBox(hInst, "AboutBox", hWnd, (DLGPROC)About);
               break;

            case IDM_EXIT:
               DestroyWindow (hWnd);
               break;

            case IDM_HELPTOPICS: // Only called in Windows 95
               bGotHelp = WinHelp (hWnd, APPNAME".HLP", HELP_FINDER,(DWORD)0);
               if (!bGotHelp)
               {
                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP),
                              szAppName, MB_OK|MB_ICONHAND);
               }
               break;

            case IDM_HELPCONTENTS: // Not called in Windows 95
               bGotHelp = WinHelp (hWnd, APPNAME".HLP", HELP_CONTENTS,(DWORD)0);
               if (!bGotHelp)
               {
                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP),
                              szAppName, MB_OK|MB_ICONHAND);
               }
               break;

            case IDM_HELPSEARCH: // Not called in Windows 95
               if (!WinHelp(hWnd, APPNAME".HLP", HELP_PARTIALKEY,
                           (DWORD)(LPSTR)""))
               {
                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP),
                              szAppName, MB_OK|MB_ICONHAND);
               }
               break;

            case IDM_HELPHELP: // Not called in Windows 95
               if(!WinHelp(hWnd, (LPSTR)NULL, HELP_HELPONHELP, 0))
               {
                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP),
                              szAppName, MB_OK|MB_ICONHAND);
               }
               break;

            // Here are all the other possible menu options,
            // all of these are currently disabled:
            case IDM_NEW:
            case IDM_OPEN:
            case IDM_SAVE:
            case IDM_SAVEAS:
            case IDM_UNDO:
            case IDM_CUT:
            case IDM_COPY:
            case IDM_PASTE:
            case IDM_LINK:
            case IDM_LINKS:

            default:
               return (DefWindowProc(hWnd, message, wParam, lParam));
         }
         break;

      case WM_NCRBUTTONUP: // RightClick on windows non-client area...
         if (IS_WIN95 && SendMessage(hWnd, WM_NCHITTEST, 0, lParam) == HTSYSMENU)
         {
            // The user has clicked the right button on the applications
            // 'System Menu'. Here is where you would alter the default
            // system menu to reflect your application. Notice how the
            // explorer deals with this. For this app, we aren't doing
            // anything
            return (DefWindowProc(hWnd, message, wParam, lParam));
         } else {
            // Nothing we are interested in, allow default handling...
            return (DefWindowProc(hWnd, message, wParam, lParam));
         }
            break;

        case WM_RBUTTONDOWN: // RightClick in windows client area...
            pnt.x = LOWORD(lParam);
            pnt.y = HIWORD(lParam);
            ClientToScreen(hWnd, (LPPOINT) &pnt);
      // This is where you would determine the appropriate 'context'
      // menu to bring up. Since this app has no real functionality,
      // we will just bring up the 'Help' menu:
            hMenu = GetSubMenu (GetMenu (hWnd), 2);
            if (hMenu) {
                TrackPopupMenu (hMenu, 0, pnt.x, pnt.y, 0, hWnd, NULL);
            } else {
            // Couldn't find the menu...
                MessageBeep(0);
            }
            break;


      case WM_DISPLAYCHANGE: // Only comes through on plug'n'play systems
      {
         SIZE  szScreen;
         DWORD dwBitsPerPixel = (DWORD)wParam;

         szScreen.cx = LOWORD(lParam);
         szScreen.cy = HIWORD(lParam);

         MessageBox (GetFocus(), GetStringRes(IDS_DISPLAYCHANGED),
                     szAppName, 0);
      }
      break;

      case WM_PAINT:
         hdc = BeginPaint (hWnd, &ps);
         // Add any drawing code here...
         EndPaint (hWnd, &ps);
         break;

      case WM_DESTROY:
         // Tell WinHelp we don't need it any more...
               WinHelp (hWnd, APPNAME".HLP", HELP_QUIT,(DWORD)0);
         PostQuitMessage(0);
         break;

      default:
         return (DefWindowProc(hWnd, message, wParam, lParam));
   }
   return (0);
}

//
//  FUNCTION: About(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for "About" dialog box
//       This version allows greater flexibility over the contents of the 'About' box,
//       by pulling out values from the 'Version' resource.
//
//  MESSAGES:
//
// WM_INITDIALOG - initialize dialog box
// WM_COMMAND    - Input received
//
//
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
   static  HFONT hfontDlg;    // Font for dialog text
   static   HFONT hFinePrint; // Font for 'fine print' in dialog
   DWORD   dwVerInfoSize;     // Size of version information block
   LPSTR   lpVersion;         // String pointer to 'version' text
   DWORD   dwVerHnd=0;        // An 'ignored' parameter, always '0'
   UINT    uVersionLen;
   WORD    wRootLen;
   BOOL    bRetCode;
   int     i;
   char    szFullPath[256];
   char    szResult[256];
   char    szGetName[256];
   DWORD dwVersion;
   char  szVersion[40];
   DWORD dwResult;

   switch (message) {
        case WM_INITDIALOG:
         ShowWindow (hDlg, SW_HIDE);

         if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE)
         {
            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, SHIFTJIS_CHARSET, 0, 0, 0,
                                  VARIABLE_PITCH | FF_DONTCARE, "");
            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, SHIFTJIS_CHARSET, 0, 0, 0,
                                    VARIABLE_PITCH | FF_DONTCARE, "");
         }
         else
         {
            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                  VARIABLE_PITCH | FF_SWISS, "");
            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                    VARIABLE_PITCH | FF_SWISS, "");
         }

         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
         GetModuleFileName (hInst, szFullPath, sizeof(szFullPath));

         // Now lets dive in and pull out the version information:
         dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &dwVerHnd);
         if (dwVerInfoSize) {
            LPSTR   lpstrVffInfo;
            HANDLE  hMem;
            hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
            lpstrVffInfo  = GlobalLock(hMem);
            GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo);
            // The below 'hex' value looks a little confusing, but
            // essentially what it is, is the hexidecimal representation
            // of a couple different values that represent the language
            // and character set that we are wanting string values for.
            // 040904E4 is a very common one, because it means:
            //   US English, Windows MultiLingual characterset
            // Or to pull it all apart:
            // 04------        = SUBLANG_ENGLISH_USA
            // --09----        = LANG_ENGLISH
            // --11----        = LANG_JAPANESE
            // ----04E4 = 1252 = Codepage for Windows:Multilingual

            lstrcpy(szGetName, GetStringRes(IDS_VER_INFO_LANG));

            wRootLen = lstrlen(szGetName); // Save this position

            // Set the title of the dialog:
            lstrcat (szGetName, "ProductName");
            bRetCode = VerQueryValue((LPVOID)lpstrVffInfo,
               (LPSTR)szGetName,
               (LPVOID)&lpVersion,
               (UINT *)&uVersionLen);

            // Notice order of version and string...
            if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE)
            {
               lstrcpy(szResult, lpVersion);
               lstrcat(szResult, " ̃o[W");
            }
            else
            {
               lstrcpy(szResult, "About ");
               lstrcat(szResult, lpVersion);
            }

            // -----------------------------------------------------

            SetWindowText (hDlg, szResult);

            // Walk through the dialog items that we want to replace:
            for (i = DLG_VERFIRST; i <= DLG_VERLAST; i++) {
               GetDlgItemText(hDlg, i, szResult, sizeof(szResult));
               szGetName[wRootLen] = (char)0;
               lstrcat (szGetName, szResult);
               uVersionLen   = 0;
               lpVersion     = NULL;
               bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
                  (LPSTR)szGetName,
                  (LPVOID)&lpVersion,
                  (UINT *)&uVersionLen);

               if ( bRetCode && uVersionLen && lpVersion) {
               // Replace dialog item text with version info
                  lstrcpy(szResult, lpVersion);
                  SetDlgItemText(hDlg, i, szResult);
               }
               else
               {
                  dwResult = GetLastError();

                  wsprintf(szResult, GetStringRes(IDS_VERSION_ERROR), dwResult);
                  SetDlgItemText (hDlg, i, szResult);
               }
               SendMessage (GetDlgItem (hDlg, i), WM_SETFONT,
                  (UINT)((i==DLG_VERLAST)?hFinePrint:hfontDlg),
                  TRUE);
            } // for (i = DLG_VERFIRST; i <= DLG_VERLAST; i++)


            GlobalUnlock(hMem);
            GlobalFree(hMem);

         } else {
            // No version information available.
         } // if (dwVerInfoSize)

            SendMessage (GetDlgItem (hDlg, IDC_LABEL), WM_SETFONT,
            (WPARAM)hfontDlg,(LPARAM)TRUE);

         // We are  using GetVersion rather then GetVersionEx
         // because earlier versions of Windows NT and Win32s
         // didn't include GetVersionEx:
         dwVersion = GetVersion();

         if (dwVersion < 0x80000000) {
            // Windows NT
            wsprintf (szVersion, "Microsoft Windows NT %u.%u (Build: %u)",
               (DWORD)(LOBYTE(LOWORD(dwVersion))),
               (DWORD)(HIBYTE(LOWORD(dwVersion))),
                    (DWORD)(HIWORD(dwVersion)) );
         } else if (LOBYTE(LOWORD(dwVersion))<4) {
            // Win32s
                wsprintf (szVersion, "Microsoft Win32s %u.%u (Build: %u)",
               (DWORD)(LOBYTE(LOWORD(dwVersion))),
               (DWORD)(HIBYTE(LOWORD(dwVersion))),
                    (DWORD)(HIWORD(dwVersion) & ~0x8000) );
         } else {
            // Windows 95
                wsprintf (szVersion, "Microsoft Windows 95 %u.%u",
                    (DWORD)(LOBYTE(LOWORD(dwVersion))),
                    (DWORD)(HIBYTE(LOWORD(dwVersion))) );
         }

          SetWindowText (GetDlgItem(hDlg, IDC_OSVERSION), szVersion);
         ShowWindow (hDlg, SW_SHOW);
         return (TRUE);

      case WM_COMMAND:
         if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, TRUE);
            DeleteObject (hfontDlg);
            DeleteObject (hFinePrint);
            return (TRUE);
         }
         break;
   }

    return FALSE;
}

//
//   FUNCTION: CenterWindow(HWND, HWND)
//
//   PURPOSE: Centers one window over another.
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
//       This functionwill center one window over another ensuring that
//    the placement of the window is within the 'working area', meaning
//    that it is both within the display limits of the screen, and not
//    obscured by the tray or other framing elements of the desktop.
BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
   RECT    rChild, rParent, rWorkArea;
   int     wChild, hChild, wParent, hParent;
   int     xNew, yNew;
   BOOL  bResult;

   // Get the Height and Width of the child window
   GetWindowRect (hwndChild, &rChild);
   wChild = rChild.right - rChild.left;
   hChild = rChild.bottom - rChild.top;

   // Get the Height and Width of the parent window
   GetWindowRect (hwndParent, &rParent);
   wParent = rParent.right - rParent.left;
   hParent = rParent.bottom - rParent.top;

   // Get the limits of the 'workarea'
   bResult = SystemParametersInfo(
      SPI_GETWORKAREA,  // system parameter to query or set
      sizeof(RECT),
      &rWorkArea,
      0);
   if (!bResult) {
      rWorkArea.left = rWorkArea.top = 0;
      rWorkArea.right = GetSystemMetrics(SM_CXSCREEN);
      rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN);
   }

   // Calculate new X position, then adjust for workarea
   xNew = rParent.left + ((wParent - wChild) /2);
   if (xNew < rWorkArea.left) {
      xNew = rWorkArea.left;
   } else if ((xNew+wChild) > rWorkArea.right) {
      xNew = rWorkArea.right - wChild;
   }

   // Calculate new Y position, then adjust for workarea
   yNew = rParent.top  + ((hParent - hChild) /2);
   if (yNew < rWorkArea.top) {
      yNew = rWorkArea.top;
   } else if ((yNew+hChild) > rWorkArea.bottom) {
      yNew = rWorkArea.bottom - hChild;
   }

   // Set it, and return
   return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


//---------------------------------------------------------------------------
//
// FUNCTION:    GetStringRes (int id INPUT ONLY)
//
// COMMENTS:    Load the resource string with the ID given, and return a
//              pointer to it.  Notice that the buffer is common memory so
//              the string must be used before this call is made a second time.
//
//---------------------------------------------------------------------------

LPTSTR   GetStringRes (int id)
{
  static TCHAR buffer[MAX_PATH];

  buffer[0]=0;
  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH);
  return buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tests\generic\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Generic.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tools\gen.h ===
/*++
                                                                                
Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    gen.h

Abstract:
    
    Types shared between the Wx86 tools
    
Author:

    ??-???-?? Unknown

Revision History:

--*/

// Increment this number whenever the format of winincs.ppm changes
#define VM_TOOL_VERSION_BASE     0x80000006

// Make the 64-bit PPM file format incompatible to prevent badness
#if _WIN64
    #define VM_TOOL_VERSION (VM_TOOL_VERSION_BASE | 0x01000000)
#else
    #define VM_TOOL_VERSION (VM_TOOL_VERSION_BASE)
#endif

// Make the compiler more struct.
#pragma warning(3:4033)   // function must return a value
//#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect

extern const char *ErrMsgPrefix;    // string to put in front of all error
                                    // messages so that BUILD can find them.
                                    // This is something like:
                                    // "NMAKE :  U8600: 'GENTHNK' "

struct _KnownTypesInfo;

typedef enum _TokenType {
    TK_NONE,            // 0
    TK_IDENTIFIER,      // 1
    TK_NUMBER,          // 2
    TK_PLUS,            // 3
    TK_MINUS,           // 4
    TK_STAR,            // 5
    TK_DIVIDE,          // 6
    TK_LSQUARE,         // 7
    TK_RSQUARE,         // 8
    TK_LBRACE,          // 9
    TK_RBRACE,          // a
    TK_LPAREN,          // b
    TK_RPAREN,          // c
    TK_VARGS,           // d
    TK_CONST,           // e
    TK_VOLATILE,        // f
    TK_REGISTER,        // 10
    TK_EXTERN,          // 11
    TK_CDECL,           // 12
    TK_STDCALL,         // 13
    TK_TYPEDEF,         // 14
    TK_STATIC,          // 15
    TK_COMMA,           // 16
    TK_SEMI,            // 17
    TK_STRUCT,          // 18
    TK_UNION,           // 19
    TK_ENUM,            // 1a
    TK_INLINE,          // 1b
    TK_COLON,           // 1c
    TK_ASSIGN,          // 1d
    TK_DOT,             // 1e
    TK_LSHIFT,          // 1f
    TK_RSHIFT,          // 20
    TK_LESS,            // 21
    TK_GREATER,         // 22
    TK_UNALIGNED,       // 23
    TK_DECLSPEC,        // 24
    TK_RESTRICT,        // 25
    TK_FASTCALL,        // 26
    TK_IN,              // 27
    TK_OUT,             // 28
    TK_INOUT,           // 29
    TK_BITWISE_AND,     // 30
    TK_BITWISE_OR,      // 31
    TK_LOGICAL_AND,     // 32
    TK_LOGICAL_OR,      // 33
    TK_MOD,             // 34
    TK_XOR,             // 35
    TK_NOT,             // 36
    TK_TILDE,           // 37
    TK_STRING,          // 38
    TK_SIZEOF,          // 39
    TK_TEMPLATE,        // 40
    TK___W64,           // 41
    TK_EOS              // end-of-statement
} TOKENTYPE, *PTOKENTYPE;

typedef struct _cvmheapinfo {
    ULONG_PTR uBaseAddress;
    ULONG_PTR uReserveSize;
    ULONG_PTR uRegionSize;
    ULONG_PTR uUncomitted;
    ULONG_PTR uUnReserved;
    ULONG_PTR uAvailable;
} CVMHEAPINFO;

typedef struct _memberinfo {
    struct _memberinfo *pmeminfoNext;   // ptr to next member
    DWORD dwOffset;                     // offset in structure of member
    char *sName;                        // member name
    char *sType;                        // type name
    struct _KnownTypesInfo *pkt;        // Info for this type 
    int IndLevel;                       // levels of indirection
    struct _KnownTypesInfo *pktCache;   // used by MemberTypes() in genthnk
    BOOL bIsBitfield;                   // Determines if this is a bitfield
    int BitsRequired;                   // Number of bits required for bitfield
    BOOL bIsPtr64;                      // Pointer is a 64 bit pointer
    BOOL bIsArray;                      // This member is an array
    int ArrayElements;                  // Number of elements in the array
} MEMBERINFO, *PMEMBERINFO;

typedef struct _funcinfo {
    struct _funcinfo *pfuncinfoNext;
    BOOL fIsPtr64;                  // TRUE if this is a __ptr64
    TOKENTYPE tkDirection;          // TK_IN, TK_OUT, TK_INOUT or TK_NONE
    TOKENTYPE tkPreMod;             // TK_CONST, TK_VOLATILE, or TK_NONE
    TOKENTYPE tkSUE;                // TK_STRUCT/UNION/ENUM, or TK_NONE
    char *sType;                    // name of the type
    struct _KnownTypesInfo *pkt;    // Info for this type
    TOKENTYPE tkPrePostMod;         // TK_CONST, TK_VOLATILE, or TK_NONE
    int IndLevel;                   // indirection level
    TOKENTYPE tkPostMod;            // TK_CONST, TK_VOLATILE, or TK_NONE
    char *sName;                    // name of the argment
} FUNCINFO, *PFUNCINFO;

#if _WIN64
  // The sizes must be bigger since the MEMBERINFO structs themselves are bigger
  #define FUNCMEMBERSIZE   (40*1024)  // storage for members or MEMINFO list
  #define MEMBERMETHODSSIZE  8192     // storage for names of methods
#else
  #define FUNCMEMBERSIZE   (20*1024)  // storage for members or MEMINFO list
  #define MEMBERMETHODSSIZE  4096     // storage for names of methods
#endif

typedef enum _TypeKind {
    TypeKindEmpty = 0,              // Members[] is unused
    TypeKindStruct,                 // TYPESINFO.Members is array of MEMBERINFO
    TypeKindFunc                    // TYPESINFO.Members is array of FUNCINFO
} TYPEKIND;

#define DIR_INOUT   0
#define DIR_IN      1
#define DIR_OUT     2

#define SIZEOFPOINTER   4   // standard size for 32 bit pointer
#define SIZEOFPOINTER64 8   // standard size for 64 bit pointer


// The colors
typedef enum {RED, BLACK} COL;

typedef struct _KnownTypesInfo {
     // elements used by the Red-Black tree code, along with TypeName
     struct _KnownTypesInfo *RBParent;
     struct _KnownTypesInfo *RBLeft;
     struct _KnownTypesInfo *RBRight;
     COL    RBColor;
     struct _KnownTypesInfo *Next;

     ULONG Flags;
     int   IndLevel;
     int   RetIndLevel;
     int   Size;
     int   iPackSize;
     char  *BasicType;
     char  *BaseName;
     char  *FuncRet;
     char  *FuncMod;
     char  *TypeName;
     char  *Methods;
     char  *IMethods;
     char  *BaseType;
     GUID  gGuid;
     DWORD dwVTBLSize;
     DWORD dwVTBLOffset;
     int   TypeId;    
     int   LineNumber;
     DWORD dwScopeLevel;
     struct _KnownTypesInfo *pktBase;   // a cache, used by genthnk
     struct _KnownTypesInfo *pktRet;    // a cache, used by genthnk
     int   SizeMembers; // size of Members[], in bytes
     char  *Members;
     char  *FileName;
     PMEMBERINFO pmeminfo;
     PFUNCINFO   pfuncinfo;
     DWORD dwArrayElements;
     DWORD dwBaseSize;
     struct _KnownTypesInfo *pTypedefBase;
     DWORD dwCurrentPacking;
     char  Names[1];
} KNOWNTYPES, *PKNOWNTYPES;

typedef struct _RBTree {
     PKNOWNTYPES pRoot;
     PKNOWNTYPES pLastNodeInserted;
} RBTREE, *PRBTREE;

typedef struct _DefaultBasicTypes {
     char *BasicType;
}DEFBASICTYPES, *PDEFBASICTYPES;

typedef struct _TypesInfo {
     ULONG Flags;
     int  IndLevel;                 // indirection level
     int  Size;                     // size of the type in bytes
     int  iPackSize;                // packing size
     char BasicType[MAX_PATH];
     char BaseName[MAX_PATH];
     char FuncRet[MAX_PATH];
     char FuncMod[MAX_PATH];
     char TypeName[MAX_PATH];       // typedef or struc name
     TYPEKIND TypeKind;             // how to interpret Members[] data
     PFUNCINFO pfuncinfo;           // if TypeKind==TypeKindFunc, ptr to first FUNCINFO
     int   RetIndLevel;             // if TypeKind==TypeKindFunc, indlevel of return type for function
     DWORD dwMemberSize;            // #bytes used in Members array
     char Members[FUNCMEMBERSIZE];  // stores either MEMBERINFOs or FUNCINFOs
//   Added to support automatic retrival of COM objects
//   If a class or struct is found with virtual methods, an extra VTLB member
//   is created at the top.
//   Note: a class has a VTLB if virtual methods are found or base class
//   has virtual methods
//   A type is a COM object if it is IUnknown or it derives from a COM object
     GUID gGuid;                        // Guid for this object if
     DWORD dwVTBLSize;                  // Total size of the VTBL
     DWORD dwVTBLOffset;                // Offset of VTLB from parent
     char Methods[MEMBERMETHODSSIZE];   // Names of methods
     char IMethods[MEMBERMETHODSSIZE];  // Names of methods not inherited 
     char BaseType[MAX_PATH];           // Name of the base class
//////////////////////////////////////////////////////////////////////
//   Added to support reordering of definations later
//////////////////////////////////////////////////////////////////////
     int TypeId;    //is actually a defination ID
     char FileName[MAX_PATH];
     int LineNumber;
     DWORD dwCurrentPacking;            // Packing level when structure defined
     DWORD dwScopeLevel;
     DWORD dwArrayElements;             // If this is an array, the number of elements
     DWORD dwBaseSize;                  // Base size before it is multiplied for the array
     PKNOWNTYPES pTypedefBase;
} TYPESINFO, *PTYPESINFO;

#define BTI_DLLEXPORT       1       // the function decl had __declspec(dllimport)
#define BTI_CONTAINSFUNCPTR 2       // the type contains a function pointer
#define BTI_PTR64           4       // the type is a __ptr64
#define BTI_HASGUID         8       // A guid has been found for this type
#define BTI_ISCOM           16      // This is a COM object 
#define BTI_DISCARDABLE     32      // Type is overwriteable
#define BTI_VIRTUALONLY     64      // Contains only virtual methods
#define BTI_ANONYMOUS       128     // Type is anonymous
#define BTI_POINTERDEP      256     // Type is dependent on the standard pointer size
#define BTI_NOTDERIVED      512     // Type is not derived, but a placeholder
#define BTI_ISARRAY        1024     // Element is an array
#define BTI_UNSIGNED     2048       // Used only on default derived types
                                    // Signals that the type is unsigned
#define BTI_INT64DEP     4096       // this is a 8byte integer value that 
                                    // might be union as well 

// contiguous allocation in a buffer
typedef struct _bufallocinfo {
    BYTE *pb;           // ptr to buffer pool
    DWORD dwSize;       // size of buffer pool
    DWORD dwLen;        // current length of buffer pool
} BUFALLOCINFO;

typedef struct _TokenMatch {
    TOKENTYPE Tk;
    char *MatchString;
} TOKENMATCH, *PTOKENMATCH;


extern char *TokenString[];
extern TOKENMATCH KeywordList[];

typedef struct _Token {
    TOKENTYPE TokenType;
    union _TokenName {
        char *Name;     // filled in only for TokenType==TK_IDENTIFIER or TK_STRING
        long Value;     // filled in only for TokenType==TK_NUMBER
    };
    DWORD dwValue; //unsigned version of Value
} TOKEN, *PTOKEN;

#define MAX_CHARS_IN_LINE           4096
#define MAX_TOKENS_IN_STATEMENT     4096
extern TOKEN Tokens[MAX_TOKENS_IN_STATEMENT];
extern int CurrentTokenIndex;

void
ResetLexer(
    void
    );

char *
LexOneLine(
    char *p,
    BOOL fStopAtStatement,
    BOOL *pfLexDone
    );

BOOL
UnlexToText(
    char *dest,
    int destlen,
    int StartToken,
    int EndToken
    );

void
DumpLexerOutput(
    int FirstToken
    );

void
HandlePreprocessorDirective(
    char *Line
    );

TOKENTYPE
ConsumeDirectionOpt(
    void
    );

TOKENTYPE
ConsumeConstVolatileOpt(
    void
    );

PMEMBERINFO
AllocMemInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PMEMBERINFO pmeminfo
    );

PFUNCINFO
AllocFuncInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PFUNCINFO pfuncinfo
    );

DWORD 
SizeOfMultiSz(
    char *c
    );

BOOL
CatMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    );


BOOL
AppendToMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    );

BOOL IsInMultiSz(
    const char *multisz,
    const char *element
    );

BOOL 
ConvertStringToGuid(
    const char *pString, 
    GUID *pGuid
    );

//
// Inline code

#define iswhitespace(c) ((c == ' ') || (c == '\t'))

//
// initialize BUFALLOCINFO structure
_inline void BufAllocInit(BUFALLOCINFO *pbufallocinfo, 
                  BYTE *pb, DWORD dwSize, DWORD dwLen)
{
    pbufallocinfo->pb = pb;
    pbufallocinfo->dwSize = dwSize;
    pbufallocinfo->dwLen = dwLen;
}

//
// allocate memory from buffer
_inline void *BufAllocate(BUFALLOCINFO *pbufallocinfo, DWORD dwLen)
{
    void *pv = NULL;        
    DWORD dwNewLen;

    // Pad to quadword alignment, like malloc does, so RISC builds don't
    // take alignment faults.
    dwLen = (dwLen+7) & ~7;

    dwNewLen = pbufallocinfo->dwLen + dwLen;
    
    if (dwNewLen < pbufallocinfo->dwSize)
    {
        pv = &pbufallocinfo->pb[pbufallocinfo->dwLen];
        pbufallocinfo->dwLen = dwNewLen;
    }
    
    return(pv);
}

//
// determine if we could allocate from buffer pool
_inline BOOL BufCanAllocate(BUFALLOCINFO *pbufallocinfo, DWORD dwLen)
{
    return( (pbufallocinfo->dwLen + dwLen) < pbufallocinfo->dwSize);
}

//
// get pointer to current free area
_inline void *BufPointer(BUFALLOCINFO *pbufallocinfo)
{
    return(&pbufallocinfo->pb[pbufallocinfo->dwLen]);
}

//
// get remaining space in buffer
_inline DWORD BufGetFreeSpace(BUFALLOCINFO *pbufallocinfo)
{
    return pbufallocinfo->dwSize - pbufallocinfo->dwLen;
}

_inline char *SkipWhiteSpace(char *s)
{
    while (iswhitespace(*s) && (*s != 0)) {
        s++;
        }
    return(s);
}

__inline void
ConsumeToken(
    void
    )
{
    if (Tokens[CurrentTokenIndex].TokenType != TK_EOS) {
        CurrentTokenIndex++;
    }
}

__inline PTOKEN
CurrentToken(
    void
    )
{
    return &Tokens[CurrentTokenIndex];
}


//
// function prototypes
char *SkipKeyWord(char *pSrc, char *pKeyWord);
BOOL IsSeparator(char ch);
BOOL IsTokenSeparator(void);
size_t  CopyToken(char *pDst, char *pSrc, size_t Size);
char *GetNextToken(char *pSrc);

void DumpKnownTypes(PKNOWNTYPES pKnownTypes, FILE *fp);
void DumpTypesInfo(PTYPESINFO pTypesInfo, FILE *fp);
void FreeTypesList(PRBTREE HeadList);

void __cdecl ErrMsg(char *pch, ...);
void __cdecl ExitErrMsg(BOOL bSysError, char *pch, ...);
void __cdecl DbgPrintf(char *pch, ...);

char *ReadEntireFile(HANDLE hFile, DWORD *pBytesRead);
HANDLE CreateTempFile(VOID);

BOOL
ParseTypes(
    PRBTREE pTypesList,
    PTYPESINFO pTypesInfo,
    PKNOWNTYPES *ppKnownTypes
    );

PFUNCINFO
RelocateTypesInfo(
    char *dest,
    PTYPESINFO src
    );

void ParseIndirection(
    DWORD *pIndLevel,
    DWORD *pdwSize,
    DWORD *pFlags,
    PTOKENTYPE tkPrePostMod,
    PTOKENTYPE tkPostMod
);

PKNOWNTYPES
GetNameFromTypesList(
     PRBTREE pHeadList,
     char *pTypeName
     );

PDEFBASICTYPES
GetDefBasicType(
     char *pBasicType
     );

PKNOWNTYPES
AddToTypesList(
     PRBTREE pHeadList,
     PTYPESINFO pTypesInfo
     );

BOOL
AddOpenFile(
    char   *FileName,
    FILE   *fp,
    HANDLE hFile
    );

void
DelOpenFile(
    FILE   *fp,
    HANDLE hFile
    );

void
CloseOpenFileList(
    BOOL DeleteFiles
    );


BOOL
ConsoleControlHandler(
    DWORD dwCtrlType
    );




//
// global vars
extern char szVARGS[];
extern char szNULL[];
extern char szCONST[];
extern char szVOLATILE[];
extern char szREGISTER[];
extern char szEXTERN[];
extern char szCDECL[];
extern char sz_CDECL[];
extern char szSTDCALL[];
extern char sz__FASTCALL[];
extern char szUNALIGNED[];
extern char szTYPEDEF[];
extern char szCHAR[];
extern char szINT[];
extern char szLONG[];
extern char szSHORT[];
extern char szDOUBLE[];
extern char szENUM[];
extern char szFLOAT[];
extern char szSTRUCT[];
extern char szUNION[];
extern char szVOID[];
extern char szINT64[];
extern char sz_INT64[];
extern char szFUNC[];
extern char szSIGNED[];
extern char szUNSIGNED[];
extern char szFUNCTIONS[];
extern char szSTRUCTURES[];
extern char szTYPEDEFS[];
extern char szPragma[];
extern char szPack[];
extern char szPush[];
extern char szPop[];
extern char szSTATIC[];
extern char szUNSIGNEDCHAR[];
extern char szUNSIGNEDSHORT[];
extern char szUNSIGNEDLONG[];
extern CHAR szINOUT[];
extern CHAR szIN[];
extern CHAR szOUT[];
extern CHAR szVTBL[];
extern char szGUID[];


extern BOOLEAN bDebug;
extern BOOLEAN bExitClean;

extern PVOID (*fpTypesListMalloc)(ULONG Len);

PKNOWNTYPES GetBasicType(
            char *sTypeName,
            PRBTREE TypeDefsList,
            PRBTREE StructsList);
void ReplaceInTypesList(PKNOWNTYPES pKnownTypes, PTYPESINFO pTypesInfo);

HANDLE CreateAllocCvmHeap(ULONG_PTR uBaseAddress,
                          ULONG_PTR uReserveSize,
                          ULONG_PTR uRegionSize,
                          ULONG_PTR uUncomitted,
                          ULONG_PTR uUnReserved,
                          ULONG_PTR uAvailable);

PVOID GetCvmHeapBaseAddress(HANDLE hCvmHeap);
PVOID
AllocCvm(HANDLE hCvmHeap,
    ULONG_PTR Size
    );
void DeleteAllocCvmHeap(HANDLE hCvmHeap);

// This structure is the first thing allocated within the CvmHeap.  It contains
// the roots of all data stored within the heap.
typedef struct _CvmHeapHeader {
    ULONG Version;
    ULONG_PTR BaseAddress;
    RBTREE FuncsList;
    RBTREE StructsList;
    RBTREE TypeDefsList;
    KNOWNTYPES NIL;
} CVMHEAPHEADER, *PCVMHEAPHEADER;

PVOID GetCvmHeapAvailable(HANDLE hCvmHeap);

// from redblack.c:
VOID
RBInsert(
    PRBTREE proot,
    PKNOWNTYPES x
    );

PKNOWNTYPES
RBFind(
    PRBTREE proot,
    PVOID addr
    );

PKNOWNTYPES
RBDelete(
    PRBTREE proot,
    PKNOWNTYPES z
    );

VOID
RBInitTree(
    PRBTREE proot
    );

extern PKNOWNTYPES NIL;

//
// Use these allocators instead of malloc/free
//
PVOID GenHeapAlloc(INT_PTR Len);
void GenHeapFree(PVOID pv);

BOOL
IsDefinedPointerDependent(
    char *pName
    );

PCHAR
IsDefinedPtrToPtrDependent(
    IN char *pName
    );

BOOL
ClosePpmFile(
   BOOL bExitFailure
   );

PCVMHEAPHEADER 
MapPpmFile(
   char *sPpmfile,
   BOOL bExitFailure
   );

char *GetHostPointerName(BOOL bIsPtr64);
char *GetHostBasicTypeName(PKNOWNTYPES pkt);
char *GetHostTypeName(PKNOWNTYPES pkt, char *pBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tools\genlib\genmisc.c ===
// Copyright (c) 1994-1999 Microsoft Corporation

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "gen.h"

BOOLEAN bDebug = FALSE;
BOOLEAN bExitClean= TRUE;

char szNULL[]="";
char szVARGS[]="...";
char szCONST[] = "const";
char szVOLATILE[] = "volatile";
char szREGISTER[] = "register";
char szEXTERN[] = "extern";
char sz_CDECL[] = "__cdecl";
char szCDECL[] = "_cdecl";
char szSTDCALL[] = "__stdcall";
char sz__FASTCALL[] = "__fastcall";
char szUNALIGNED[] = "__unaligned";
char szTYPEDEF[] = "typedef";
char szCHAR[] = "char";
char szINT[] = "int";
char szLONG[] = "long";
char szSHORT[] = "short";
char szDOUBLE[] = "double";
char szENUM[] = "enum";
char szFLOAT[] = "float";
char szSTRUCT[] = "struct";
char szUNION[] = "union";
char szVOID[] = "void";
char szINT64[] = "_int64";
char sz_INT64[] = "__int64";
char sz__PTR64[] = "__ptr64";
char szFUNC[] = "()";
char szSIGNED[] = "signed";
char szUNSIGNED[] = "unsigned";
char szSTATIC[] = "static";
char szIN[] = "__in";
char szOUT[] = "__out";
char szINOUT[] = "__in __out";
char szGUID[] = "GUID";
char sz__W64[] = "__w64";


char szPragma[] = "#pragma";
char szPack[] = "pack";
char szPush[] = "push";
char szPop[] = "pop";

char szFUNCTIONS[]  = "Functions";
char szSTRUCTURES[] = "Structures";
char szTYPEDEFS[]   = "TypeDefs";
char szUNSIGNEDCHAR[] = "unsigned char";
char szUNSIGNEDSHORT[] = "unsigned short";
char szUNSIGNEDLONG[] = "unsigned long";


DEFBASICTYPES DefaultBasicTypes[] = {
      { "unsigned int" },
      { "int" },
      { "short int" },
      { "unsigned short int" },
      { "long int" },
      { "unsigned long int" },
      { "char" },
      { "unsigned char" },
      { szINT64 },
      { sz_INT64 },
      { szGUID    },
      { szDOUBLE  },
      { szFLOAT   },
      { szENUM    },
      { szSTRUCT  },
      { szUNION   },
      { szVOID    },
      { szFUNC    }
     };

CHAR szVTBL[] = "VTBL";

#define NUMDEFBASICTYPES sizeof(DefaultBasicTypes)/sizeof(DEFBASICTYPES);

// List mapping TokenTypes to human-readable strings.  TK_NONE, TK_IDENTIFIER,
// TK_NUMBER, and TK_STRING must be special-cased.
char *TokenString[] = {
    "",             // TK_NONE
    "",             // TK_IDENTIFIER
    "",             // TK_NUMBER
    "+",            // TK_PLUS
    "-",            // TK_MINUS
    "*",            // TK_STAR
    "/",            // TK_DIVIDE
    "[",            // TK_LSQUARE
    "]",            // TK_RSQUARE
    "{",            // TK_LBRACE
    "}",            // TK_RBRACE
    "(",            // TK_LPAREN
    ")",            // TK_RPAREN
    "...",          // TK_VARGS
    "const",        // TK_CONST
    "volatile",     // TK_VOLATILE
    "register",     // TK_REGISTER
    "extern",       // TK_EXTERN
    "__cdecl",      // TK_CDECL
    "__stdcall",    // TK_STDCALL
    "typedef",      // TK_TYPEDEF
    "static",       // TK_STATIC
    ",",            // TK_COMMA
    ";",            // TK_SEMI
    "struct",       // TK_STRUCT
    "union",        // TK_UNION
    "enum",         // TK_ENUM
    "__inline",     // TK_INLINE
    ":",            // TK_COLON
    "=",            // TK_ASSIGN
    ".",            // TK_DOT
    "<<",           // TK_LSHIFT
    ">>",           // TK_RSHIFT
    "<",            // TK_LESS
    ">",            // TK_GREATER
    "__unaligned",  // TK_UNALIGNED
    "__declspec",   // TK_DECLSPEC
    "__restrict",   // TK_RESTRICT  (MIPS-only keyword - a pointer modifier)
    "__fastcall",   // TK_FASTCALL
    "__in",         // TK_IN
    "__out",        // TK_OUT
    "__in __out",   // TK_INOUT
    "&",            // TK_BITWISE_AND
    "|",            // TK_BITWISE_OR
    "&&",           // TK_LOGICAL_AND
    "||",           // TK_LOGICAL_OR
    "%",            // TK_MOD
    "^",            // TK_XOR
    "!",            // TK_NOT
    "~",            // TK_TILDE
    "",             // TK_STRING
    "sizeof",       // TK_SIZEOF
    "template",     // TK_TEMPLATE
    "__w64",        // TK___W64
    ""              // TK_EOS
};


// List of keyword names.  When an identifier is recognized, it is
// compared against this list, and if it matches, TK_IDENTIFIER is
// replaced by the appropriate keyword token id.
//
// NOTE: This must remain in sorted order.
TOKENMATCH KeywordList[] = {
    { TK_CDECL,     "__cdecl"     },
    { TK_DECLSPEC,  "__declspec"  },
    { TK_FASTCALL,  "__fastcall"  },
    { TK_INLINE,    "__forceinline" },
    { TK_IN,        "__in"        },
    { TK_INLINE,    "__inline"    },
    { TK_OUT,       "__out"       },
    { TK_RESTRICT,  "__restrict"  },
    { TK_STDCALL,   "__stdcall"   },
    { TK_UNALIGNED, "__unaligned" },
    { TK___W64,     "__w64"       },
    { TK_CDECL,     "_cdecl"      },
    { TK_FASTCALL,  "_fastcall"   },
    { TK_INLINE,    "_inline"     },
    { TK_STRUCT,    "class"       },
    { TK_CONST,     "const"       },
    { TK_ENUM,      "enum"        },
    { TK_EXTERN,    "extern"      },
    { TK_INLINE,    "inline"      },
    { TK_REGISTER,  "register"    },
    { TK_SIZEOF,    "sizeof"      },
    { TK_STATIC,    "static"      },
    { TK_STRUCT,    "struct"      },
    { TK_TEMPLATE,  "template"    },
    { TK_TYPEDEF,   "typedef"     },
    { TK_UNION,     "union"       },
    { TK_VOLATILE,  "volatile"    },
    { TK_NONE,      NULL          }
};


LIST_ENTRY OpenFileHead= {&OpenFileHead, &OpenFileHead};

typedef struct _OpenFileEntry {
    LIST_ENTRY FileEntry;
    HANDLE hFile;
    FILE *fp;
    char FileName[MAX_PATH+1];
} OPENFILEENTRY, *POPENFILEENTRY;

TOKEN Tokens[MAX_TOKENS_IN_STATEMENT];
int CurrentTokenIndex;

void
CheckForKeyword(
    PTOKEN Token
    );


BOOL
ConsoleControlHandler(
    DWORD dwCtrlType
    )
/*++

Routine Description:

    Called if user hits Ctrl+C or Ctrl+Break.  Closes all open files,
    allowing for a graceful exit.

Arguments:

    dwCtrlType -- ????

Return Value:

    ????

--*/
{
    CloseOpenFileList(TRUE);
    return FALSE;
}


BOOL
AddOpenFile(
    char   *FileName,
    FILE   *fp,
    HANDLE hFile
    )
/*++

Routine Description:

    Records that a file has been opened.  If an error occurs within
    the app, files in this list will be closed.

Arguments:

    FileName    -- name of open file
    fp          -- OPTIONAL file pointer
    hFile       -- OPTIONAL file handle

Return Value:

    TRUE if file added to the list, FALSE if failure (probably out of memory)

--*/
{
    POPENFILEENTRY pofe;

    pofe = GenHeapAlloc(sizeof(OPENFILEENTRY));
    if (!pofe) {
        ErrMsg("AddOpenWriteFile: insuf memory: %s\n", strerror(errno));
        return FALSE;
    }
    pofe->fp = fp;
    pofe->hFile = hFile;
    strcpy(pofe->FileName, FileName);

    InsertHeadList(&OpenFileHead, &pofe->FileEntry);
    return TRUE;
}


void
DelOpenFile(
    FILE   *fp,
    HANDLE hFile
    )
/*++

Routine Description:

    Deletes a file from the open file list.  Note that the file is not
    closed, the caller must do that.

Arguments:

    fp          -- OPTIONAL file pointer
    hFile       -- OPTIONAL file handle

Return Value:

    None.

--*/
{
    PLIST_ENTRY Next;
    POPENFILEENTRY pofe;

    Next = OpenFileHead.Flink;
    while (Next != &OpenFileHead) {
        pofe = CONTAINING_RECORD(Next, OPENFILEENTRY, FileEntry);
        if ((fp && pofe->fp == fp) || (hFile && pofe->hFile == hFile)) {
            RemoveEntryList(&pofe->FileEntry);
            GenHeapFree(pofe);
            return;
        }

        Next= Next->Flink;
    }
}



void
CloseOpenFileList(
    BOOL DeleteFiles
    )
/*++

Routine Description:

    Closes all open files and optionally deletes the files themselves.

Arguments:

    DeleteFiles -- TRUE if open files are to be deleted.

Return Value:

    None.

--*/
{
    PLIST_ENTRY Next;
    POPENFILEENTRY pofe;

    Next = OpenFileHead.Flink;
    while (Next != &OpenFileHead) {
        pofe = CONTAINING_RECORD(Next, OPENFILEENTRY, FileEntry);
        if (pofe->fp) {
            fclose(pofe->fp);
        } else if (pofe->hFile) {
            CloseHandle(pofe->hFile);
        }

        if (DeleteFiles && bExitClean) {
            DeleteFile(pofe->FileName);
        }

        // cheat, skip mem cleanup since we know we are exiting
        // GenHeapFree(pofe);

        Next= Next->Flink;
    }
}





void
DumpKnownTypes(
     PKNOWNTYPES pKnownTypes,
     FILE *fp
     )
/*++

Routine Description:

    Outputs the contents of a PKNOWNTYPES in a semi-readable format.

Arguments:

    pKnownTypes -- type to output
    fp          -- destination of the output

Return Value:

    None.

--*/
{
     fprintf(fp,"%2.1x|%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|\n",
                pKnownTypes->Flags,
                pKnownTypes->IndLevel,
                pKnownTypes->RetIndLevel,
                pKnownTypes->Size,
                pKnownTypes->BasicType,
                pKnownTypes->BaseName ? pKnownTypes->BaseName : szNULL,
                pKnownTypes->FuncRet ? pKnownTypes->FuncRet : szNULL,
                pKnownTypes->FuncMod ? pKnownTypes->FuncMod : szNULL,
                pKnownTypes->TypeName
                );

}


void
DumpTypesInfo(
    PTYPESINFO pTypesInfo,
    FILE *fp
    )
/*++

Routine Description:

    Outputs the contents of a PTYPESINFO in a semi-readable format.

Arguments:

    pTypesInfo  -- type to output
    fp          -- destination of the output

Return Value:

    None.

--*/
{
     fprintf(fp,"%2.1x|%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|\n",
                pTypesInfo->Flags,
                pTypesInfo->IndLevel,
                pTypesInfo->RetIndLevel,
                pTypesInfo->Size,
                pTypesInfo->BasicType,
                pTypesInfo->BaseName ? pTypesInfo->BaseName : szNULL,
                pTypesInfo->FuncRet  ? pTypesInfo->FuncRet : szNULL,
                pTypesInfo->FuncMod  ? pTypesInfo->FuncMod : szNULL,
                pTypesInfo->TypeName
                );
}




void
FreeTypesList(
    PRBTREE ptree
    )
/*++

Routine Description:

    Frees an entire red-black tree.

Arguments:

    ptree   -- tree to free.

Return Value:

    None.

--*/
{
    PKNOWNTYPES pNext, pNode;

    pNode = ptree->pLastNodeInserted;
    while (pNode) {
        pNext = pNode->Next;
        GenHeapFree(pNode);
        pNode = pNext;
    }
    RBInitTree(ptree);
}




PKNOWNTYPES
GetBasicType(
    char *sTypeName,
    PRBTREE TypeDefsList,
    PRBTREE StructsList
    )
/*++

Routine Description:

    Determines the basic type of a typedef.

Arguments:

    sTypeName       -- type name to look up
    TypeDefsList    -- list of typedefs
    StructsList     -- list of structs

Return Value:

    Ptr to the KNOWNTYPES for the basic type, or NULL if no basic type
    found.

--*/
{
    PKNOWNTYPES pkt, pktLast;

    //
    // go down the typedef list
    //
    pktLast = NULL;
    for (pkt = GetNameFromTypesList(TypeDefsList, sTypeName);
                                      (pkt != NULL) && (pkt != pktLast); ) {
        pktLast = pkt;
        pkt = GetNameFromTypesList(TypeDefsList, pktLast->BaseName);
    }

    //
    // see what the the final typedef stands for
    //
    if (pktLast == NULL) {
        pkt = GetNameFromTypesList(StructsList, sTypeName);
    } else {
        if (strcmp(pktLast->BasicType, szSTRUCT)) {
            pkt = pktLast;
        } else {
                                // if base type a struct get its definition
            pkt = GetNameFromTypesList(StructsList, pktLast->BaseName);
        }
    }

    return pkt;
}


PDEFBASICTYPES
GetDefBasicType(
    char *pBasicType
    )
/*++

Routine Description:

    Determines if a typename is a basic type, and if so, which one.

Arguments:

    pBasicType      -- typename to examine

Return Value:

    Ptr to the basic type info if pBasicType is a basic type.
    NULL if the type is not a default basic type (int, sort, struct, etc.)

--*/
{
    PDEFBASICTYPES pDefBasicTypes = DefaultBasicTypes;
    int i = NUMDEFBASICTYPES;

    do {
        if (!strcmp(pDefBasicTypes->BasicType, pBasicType)) {
            return pDefBasicTypes;
        }
        pDefBasicTypes++;
    } while (--i);

    return NULL;
}


PKNOWNTYPES
GetNameFromTypesList(
     PRBTREE pKnownTypes,
     char *pTypeName
     )
/*++

Routine Description:

    Searches a type list for a type name.

Arguments:

    pKnownType  -- type list to search
    pTypeName   -- type name to look for

Return Value:

    Ptr to the type info if pTypeName is in the list.
    NULL if the type was not found.

--*/
{
   //
   // Find the entry in the Red/Black tree
   //
   return RBFind(pKnownTypes, pTypeName);
}



PVOID
TypesListMalloc(
    ULONG Len
    )
/*++

Routine Description:

    Default memory allocator used to allocate a new KNOWNTYPES.
    It can be overridden by setting fpTypesListMalloc.

Arguments:

    Len     -- number of bytes of memory to allocate.

Return Value:

    Ptr to the memory or NULL of out-of-memory.

--*/
{
    return GenHeapAlloc(Len);
}

PVOID (*fpTypesListMalloc)(ULONG Len) = TypesListMalloc;

VOID
ReplaceInfoInKnownTypes(
    PKNOWNTYPES pKnownTypes,
    PTYPESINFO pTypesInfo
    )
{

    BYTE *pNames;
    int Len;
    int SizeBasicType, SizeBaseName, SizeMembers, SizeFuncMod, SizeFuncRet;
    int SizeTypeName, SizeBaseType, SizeMethods, SizeIMethods, SizeFileName;

    SizeBasicType = strlen(pTypesInfo->BasicType) + 1;
    SizeBaseName = strlen(pTypesInfo->BaseName) + 1;
    SizeFuncRet = strlen(pTypesInfo->FuncRet) + 1;
    SizeFuncMod = strlen(pTypesInfo->FuncMod) + 1;
    SizeTypeName = strlen(pTypesInfo->TypeName) + 1;
    SizeMembers = pTypesInfo->dwMemberSize;
    SizeBaseType = strlen(pTypesInfo->BaseType) + 1;
    SizeFileName = strlen(pTypesInfo->FileName) + 1;
    SizeMethods = SizeOfMultiSz(pTypesInfo->Methods);
    SizeIMethods = SizeOfMultiSz(pTypesInfo->IMethods);

    // The extra sizeof(DWORD) allows the Members[] array to be DWORD-aligned
    Len = SizeBasicType + SizeBaseName + SizeMembers + SizeFuncMod +
        SizeFuncRet + SizeTypeName + SizeBaseType + SizeFileName + SizeMethods + SizeIMethods + sizeof(DWORD_PTR);

    pNames = (*fpTypesListMalloc)(Len);
    if (!pNames) {
        fprintf(stderr, "%s pKnownTypes failed: ", ErrMsgPrefix, strerror(errno));
        DumpTypesInfo(pTypesInfo, stderr);
        ExitErrMsg(FALSE, "Out of memory!\n");
    }

    memset(pNames, 0, Len);

    pKnownTypes->Flags        = pTypesInfo->Flags;
    pKnownTypes->IndLevel     = pTypesInfo->IndLevel;
    pKnownTypes->RetIndLevel  = pTypesInfo->RetIndLevel;
    pKnownTypes->Size         = pTypesInfo->Size;
    pKnownTypes->iPackSize    = pTypesInfo->iPackSize;
    pKnownTypes->gGuid        = pTypesInfo->gGuid;
    pKnownTypes->dwVTBLSize   = pTypesInfo->dwVTBLSize;
    pKnownTypes->dwVTBLOffset = pTypesInfo->dwVTBLOffset;
    pKnownTypes->TypeId       = pTypesInfo->TypeId;
    pKnownTypes->LineNumber   = pTypesInfo->LineNumber;
    pKnownTypes->dwCurrentPacking = pTypesInfo->dwCurrentPacking;
    pKnownTypes->dwScopeLevel = pTypesInfo->dwScopeLevel;
    pKnownTypes->dwArrayElements = pTypesInfo->dwArrayElements;
    pKnownTypes->dwBaseSize   = pTypesInfo->dwBaseSize;
    pKnownTypes->pTypedefBase = pTypesInfo->pTypedefBase;
    Len = 0;

    pKnownTypes->BasicType = pNames + Len;
    strcpy(pKnownTypes->BasicType, pTypesInfo->BasicType);
    Len += SizeBasicType;

    pKnownTypes->BaseName = pNames + Len;
    strcpy(pKnownTypes->BaseName, pTypesInfo->BaseName);
    Len += SizeBaseName;

    pKnownTypes->FuncRet = pNames + Len;
    strcpy(pKnownTypes->FuncRet, pTypesInfo->FuncRet);
    Len += SizeFuncRet;

    pKnownTypes->FuncMod = pNames + Len;
    strcpy(pKnownTypes->FuncMod, pTypesInfo->FuncMod);
    Len += SizeFuncMod;

    if (SizeFileName > 0) {
        pKnownTypes->FileName = pNames + Len;
        strcpy(pKnownTypes->FileName, pTypesInfo->FileName);
        Len += SizeFileName;
    }
    else pKnownTypes->FileName = NULL;

    // Ensure that Members[] is DWORD-aligned, so the structures within the
    // Members[] are aligned.
    Len = (Len+sizeof(DWORD_PTR)) & ~(sizeof(DWORD_PTR)-1);

    if (SizeMembers == 0) {
        pKnownTypes->Members = NULL;
        pKnownTypes->pmeminfo = NULL;
        pKnownTypes->pfuncinfo = NULL;
    }
    else {
        pKnownTypes->Members = pNames + Len;
        memcpy(pKnownTypes->Members, pTypesInfo->Members, SizeMembers);

        //
        // Fix up pointers within the Members data, so they point into the
        // pKnownTypes data instead of the pTypesInfo.
        //
        pKnownTypes->pfuncinfo = RelocateTypesInfo(pKnownTypes->Members,
            pTypesInfo);

        if (pTypesInfo->TypeKind == TypeKindStruct) {
            pKnownTypes->pmeminfo = (PMEMBERINFO)pKnownTypes->Members;
        }
        Len += SizeMembers;
    }

    if (SizeMethods == 0) pKnownTypes->Methods = NULL;
    else {
        pKnownTypes->Methods = pNames + Len;
        memcpy(pKnownTypes->Methods, pTypesInfo->Methods, SizeMethods);
        Len += SizeMethods;
    }

    if (SizeIMethods == 0) pKnownTypes->IMethods = NULL;
    else {
        pKnownTypes->IMethods = pNames + Len;
        memcpy(pKnownTypes->IMethods, pTypesInfo->IMethods, SizeIMethods);
        Len += SizeIMethods;
    }

    pKnownTypes->BaseType = pNames + Len;
    strcpy(pKnownTypes->BaseType, pTypesInfo->BaseType);
    Len += SizeBaseType;

    pKnownTypes->TypeName = pNames + Len;
    strcpy(pKnownTypes->TypeName, pTypesInfo->TypeName);
    Len += SizeTypeName;

}

PKNOWNTYPES
AddToTypesList(
   PRBTREE pTree,
   PTYPESINFO pTypesInfo
   )
/*++

Routine Description:

    Adds a PTYPESINFO to the list of known types.

    This function makes the following ASSUMPTIONS:
       1. The MEMBERINFO buffer passed in the TYPESINFO structure is all
          allocated from one contiguous block of memory, ie completely
          contained within the Members[] buffer.

       2. The MEMBERINFO buffer built in the KNOWNTYPESINFO structure is
          also allocated from one contiguous block of memory.

       The code requires this since it will block copy the entire data
       structure and then "fixup" the pointers within the MEMBERINFO elements.

Arguments:

    pTree       -- types list to add the new type to
    pTypesInfo  -- the type to add.

Return Value:

    Ptr to the new PKNOWNTYPES, or NULL if out-of-memory.

--*/
{
    PKNOWNTYPES pKnownTypes;

    pKnownTypes = (*fpTypesListMalloc)(sizeof(KNOWNTYPES));
    if (!pKnownTypes) {
        fprintf(stderr, "%s pKnownTypes failed: ", ErrMsgPrefix, strerror(errno));
        DumpTypesInfo(pTypesInfo, stderr);
        return pKnownTypes;
    }

    memset(pKnownTypes, 0, sizeof(KNOWNTYPES));

    ReplaceInfoInKnownTypes(pKnownTypes, pTypesInfo);

    RBInsert(pTree, pKnownTypes);

    if (bDebug) {
        DumpKnownTypes(pKnownTypes, stdout);
    }

    return pKnownTypes;
}


void
ReplaceInTypesList(
    PKNOWNTYPES pKnownTypes,
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Replaces an existing PKNOWNTYPES with a new PTYPESINFO.  The old data
    is overwritten with new data, so pointers to the old PKNOWNTYPES will
    still be valid.

    This function makes the following ASSUMPTIONS:
       1. The MEMBERINFO buffer passed in the TYPESINFO structure is all
          allocated from one contiguous block of memory, ie completely
          contained within the Members[] buffer.

       2. The MEMBERINFO buffer built in the KNOWNTYPESINFO structure is
          also allocated from one contiguous block of memory.

       The code requires this since it will block copy the entire data
       structure and then "fixup" the pointers within the MEMBERINFO elements.

Arguments:

    pKnownTypes -- type to overwrite
    pTypesInfo  -- the type to add.

Return Value:

    None.

--*/
{

    ReplaceInfoInKnownTypes(pKnownTypes, pTypesInfo);

    if (bDebug) {
        DumpKnownTypes(pKnownTypes, stdout);
    }
}


PFUNCINFO
RelocateTypesInfo(
    char *dest,
    PTYPESINFO src
    )
/*++

Routine Description:

    Adjusts pointers within the Members[] array which point back into
    the Members[].  After a TYPESINFO is copied, the destination TYPESINFO
    or KNOWNTYPES Members[] array must be relocated.

Arguments:

    dest        -- start of the destination Members[] data
    src         -- the source TYPESINFO from which the Members[] was copied

Return Value:

    Address for first pfuncinfo within dest, NULL if dest does not contain
    funcinfos.  Destination Members[] data is relocated no matter what.

--*/
{
    INT_PTR iPtrFix;
    PMEMBERINFO pmeminfo;
    PFUNCINFO pfuncinfo;
    PFUNCINFO pfuncinfoRet = NULL;

    iPtrFix = (INT_PTR)(dest - src->Members);
    if (src->TypeKind == TypeKindStruct) {

        pmeminfo = (PMEMBERINFO)dest;

        while (pmeminfo != NULL) {
            if (pmeminfo->pmeminfoNext != NULL) {
                pmeminfo->pmeminfoNext = (PMEMBERINFO)
                                    ((char *)pmeminfo->pmeminfoNext + iPtrFix);
            }
            if (pmeminfo->sName != NULL) {
                if (pmeminfo->sName < src->Members || pmeminfo->sName > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sName not within Members[]\n");
                }
                pmeminfo->sName += iPtrFix;
            }
            if (pmeminfo->sType != NULL) {
                if (pmeminfo->sType < src->Members || pmeminfo->sType > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sType not within Members[]\n");
                }
                pmeminfo->sType += iPtrFix;
            }
            pmeminfo = pmeminfo->pmeminfoNext;
        }
    } else if (src->TypeKind == TypeKindFunc) {

        //
        // Make pfuncinfo point into the 'dest' array by fixing up the
        // source pointer.
        //
        pfuncinfo = (PFUNCINFO)((INT_PTR)src->pfuncinfo + iPtrFix);
        if ((char *)pfuncinfo < dest || (char *)pfuncinfo > dest+FUNCMEMBERSIZE) {
            ExitErrMsg(FALSE, "RelocateTypesInfo: pfuncinfo bad\n");
        }
        pfuncinfoRet = pfuncinfo;

        while (pfuncinfo != NULL) {
            if (pfuncinfo->pfuncinfoNext) {
                pfuncinfo->pfuncinfoNext = (PFUNCINFO)
                                    ((char *)pfuncinfo->pfuncinfoNext + iPtrFix);
            }
            if (pfuncinfo->sName != NULL) {
                if (pfuncinfo->sName < src->Members || pfuncinfo->sName > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sName not within Members[]\n");
                }
                pfuncinfo->sName += iPtrFix;
            }
            if (pfuncinfo->sType != NULL) {
                if (pfuncinfo->sType < src->Members || pfuncinfo->sType > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sType not within Members[]\n");
                }
                pfuncinfo->sType += iPtrFix;
            }
            pfuncinfo = pfuncinfo->pfuncinfoNext;
        }
    }

    return pfuncinfoRet;
}


BOOL
ParseTypes(
    PRBTREE pTypesList,
    PTYPESINFO  pTypesInfo,
    PKNOWNTYPES *ppKnownTypes
    )
/*++

Routine Description:

    Parses the Tokens[] and recognizes the following syntaxes:
        BasicType
        DerivedType
        unsigned|signed <int type>
        unsigned|signed
        unsigned|signed short|long int
        short|long int

Arguments:

    pTypesList      -- list of known types
    pTypesInfo      -- [OPTIONAL OUT] info about the type that was recognized
    ppKnownTypes    -- [OPTIONAL OUT] KNOWNTYPES info about the type

Return Value:

    TRUE - type was recognized.  pTypeInfo and ppKnownTypes are set,
           CurrentToken() points to token following the type.
    FALSE - type not recognized.

--*/
{
    PKNOWNTYPES pkt;
    char TypeName[MAX_PATH];
    char *SizeMod = NULL;
    char *SignMod = NULL;
    BOOL fLoopMore;

    if (pTypesInfo) {
        memset(pTypesInfo, 0, sizeof(TYPESINFO));
    }

    switch (CurrentToken()->TokenType) {
    case TK_STRUCT:
    case TK_UNION:
    case TK_ENUM:
        ConsumeToken();
        break;

    case TK_VARGS:
        pkt = GetNameFromTypesList(pTypesList, szVARGS);
        ConsumeToken();
        goto PKTExit;

    default:
        break;
    }


    //
    // Process 'long', 'short', 'signed' and 'unsigned' modifiers
    //
    while (CurrentToken()->TokenType == TK_IDENTIFIER) {
        if (strcmp(CurrentToken()->Name, szLONG) == 0) {
            SizeMod = szLONG;
        } else if (strcmp(CurrentToken()->Name, szSHORT) == 0) {
            SizeMod = szSHORT;
        } else if (strcmp(CurrentToken()->Name, szUNSIGNED) == 0) {
            SignMod = szUNSIGNED;
        } else if (strcmp(CurrentToken()->Name, szSIGNED) == 0) {
            SignMod = NULL;
        } else {
            break;
        }
        ConsumeToken();
    }

    //
    // Convert the modifier list into a standardized type string and
    // look it up.
    //
    TypeName[0] = '\0';
    if (SignMod) {
        strcpy(TypeName, SignMod);
    }
    if (SizeMod) {
        if (TypeName[0]) {
            strcat(TypeName, " ");
        }
        strcat(TypeName, SizeMod);
    }

    //
    // Append the type name to the optional list of type modifiers
    //
    if (CurrentToken()->TokenType != TK_IDENTIFIER) {
        if (TypeName[0] == '\0') {
            return FALSE;   // no qualifiers, so not a type
        }
        //
        // Append the implict 'int' on the end of the type qualifiers
        //
        strcat(TypeName, " ");
        strcat(TypeName, szINT);
    } else {
        char *Name = CurrentToken()->Name;

        if (strcmp(Name, szVOID) == 0 ||
            strcmp(Name, szINT) == 0 ||
            strcmp(Name, szINT64) == 0 ||
            strcmp(Name, sz_INT64) == 0 ||
            strcmp(Name, szCHAR) == 0 ||
            strcmp(Name, szFLOAT) == 0 ||
            strcmp(Name, szDOUBLE) == 0) {

            // Append the intrinsic type to the list of type modifiers
            if (TypeName[0]) {
                strcat(TypeName, " ");
            }
            strcat(TypeName, Name);

            //
            // Don't worry about explicitly disallowing things like
            // 'unsigned double' or 'short char'.  They won't be
            // in the pTypesList, so the parse will fail.
            //

            ConsumeToken();

        } else if (TypeName[0]) {
            //
            // The identifier is not an intrinsic type, and type modifiers
            // were seen.  The identifier is a variable name, not part of the
            // type name.  The type name is implicitly 'int'.
            //
            strcat(TypeName, " ");
            strcat(TypeName, szINT);

        } else {
            //
            // The identifier is not an intrinsic type, and no type
            // modifiers have been seen.  It is probably a typedef name.
            //
            strcpy(TypeName, Name);
            ConsumeToken();
        }
    }

    //
    // Look up the type name with all of its glorious modifiers
    //
    pkt = GetNameFromTypesList(pTypesList, TypeName);
    if (!pkt) {
        //
        // Type not found
        //
        return FALSE;
    }

PKTExit:
    if (pTypesInfo) {
        BUFALLOCINFO bufallocinfo;
        char *ps;
        PFUNCINFO pfuncinfoSrc = pkt->pfuncinfo;
        PMEMBERINFO pmeminfoSrc = pkt->pmeminfo;

        BufAllocInit(&bufallocinfo, pTypesInfo->Members, sizeof(pTypesInfo->Members), 0);

        pTypesInfo->Flags = pkt->Flags;
        pTypesInfo->IndLevel = pkt->IndLevel;
        pTypesInfo->Size = pkt->Size;
        pTypesInfo->iPackSize = pkt->iPackSize;
        strcpy(pTypesInfo->BasicType,pkt->BasicType);
        if (pkt->BaseName) {
            strcpy(pTypesInfo->BaseName,pkt->BaseName);
        }
        strcpy(pTypesInfo->TypeName,pkt->TypeName);
        if (pfuncinfoSrc) {
            PFUNCINFO pfuncinfoDest = NULL;

            pTypesInfo->pfuncinfo = BufPointer(&bufallocinfo);
            pTypesInfo->TypeKind = TypeKindFunc;

            while (pfuncinfoSrc) {
                pfuncinfoDest = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfoDest);
                if (!pfuncinfoDest) {
                    ExitErrMsg(FALSE, "ParseTypes - out of memory at line %d\n", __LINE__);
                }
                pfuncinfoDest->fIsPtr64 = pfuncinfoSrc->fIsPtr64;
                pfuncinfoDest->tkPreMod = pfuncinfoSrc->tkPreMod;
                pfuncinfoDest->tkSUE    = pfuncinfoSrc->tkSUE;
                pfuncinfoDest->tkPrePostMod = pfuncinfoSrc->tkPrePostMod;
                pfuncinfoDest->IndLevel = pfuncinfoSrc->IndLevel;
                pfuncinfoDest->tkPostMod = pfuncinfoSrc->tkPostMod;

                ps = BufPointer(&bufallocinfo);
                pfuncinfoDest->sType = ps;
                strcpy(ps, pfuncinfoSrc->sType);
                BufAllocate(&bufallocinfo, strlen(ps)+1);

                if (pfuncinfoSrc->sName) {
                    ps = BufPointer(&bufallocinfo);
                    pfuncinfoDest->sName = ps;
                    strcpy(ps, pfuncinfoSrc->sName);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                pfuncinfoSrc = pfuncinfoSrc->pfuncinfoNext;
            }
        } else if (pmeminfoSrc) {
            PMEMBERINFO pmeminfoDest = NULL;

            pTypesInfo->TypeKind = TypeKindStruct;

            while (pmeminfoSrc) {
                pmeminfoDest = AllocMemInfoAndLink(&bufallocinfo, pmeminfoDest);
                pmeminfoDest->dwOffset = pmeminfoSrc->dwOffset;

                if (pmeminfoSrc->sName) {
                    ps = BufPointer(&bufallocinfo);
                    pmeminfoDest->sName = ps;
                    strcpy(ps, pmeminfoSrc->sName);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                if (pmeminfoSrc->sType) {
                    ps = BufPointer(&bufallocinfo);
                    pmeminfoDest->sType = ps;
                    strcpy(ps, pmeminfoSrc->sType);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                pmeminfoSrc = pmeminfoSrc->pmeminfoNext;
            }
        }
        pTypesInfo->dwMemberSize = bufallocinfo.dwLen;
    }

    if (ppKnownTypes) {
        *ppKnownTypes = pkt;
    }

    return TRUE;
}



void
__cdecl ErrMsg(
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays an error message to stderr in a format that BUILD can find.
    Use this instead of fprintf(stderr, ...).

Arguments:

    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr.

--*/
{
    va_list pArg;

    fputs(ErrMsgPrefix, stderr);
    va_start(pArg, pch);
    vfprintf(stderr, pch, pArg);
}


void
__cdecl ExitErrMsg(
    BOOL bSysError,
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays an error message to stderr in a format that BUILD can find.
    Use this instead of fprintf(stderr, ...).

Arguments:

    bSysErr -- TRUE if the value of errno should be printed with the error
    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr, open files closed and
    deleted, process terminated.

--*/
{
    va_list pArg;
    if (bSysError) {
        fprintf(stderr, "%s System ERROR %s", ErrMsgPrefix, strerror(errno));
    } else {
        fprintf(stderr, "%s ERROR ", ErrMsgPrefix);
    }

    va_start(pArg, pch);
    vfprintf(stderr, pch, pArg);

    CloseOpenFileList(TRUE);

    //
    // Flush stdout and stderr buffers, so that the last few printfs
    // get sent back to BUILD before ExitProcess() destroys them.
    //
    fflush(stdout);
    fflush(stderr);

    ExitProcess(1);
}




void
__cdecl DbgPrintf(
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays a message to stdout if bDebug is set.

Arguments:

    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr.

--*/
{
    va_list pArg;

    if (!bDebug) {
        return;
    }

    va_start(pArg, pch);
    vfprintf(stdout, pch, pArg);
}




char *
ReadEntireFile(
    HANDLE hFile,
    DWORD *pBytesRead
    )
/*++

Routine Description:

    Allocates memory on the local heap and reads an entire file into it.

Arguments:

    hFile       -- file to read in
    bBytesRead  -- [OUT] number of bytes read from the file

Return Value:

    pointer to the memory allocated for the file, or NULL on error.

--*/
{
    DWORD  Bytes;
    char *pch = NULL;

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xffffffff ||
        (Bytes = GetFileSize(hFile, NULL)) == 0xffffffff) {
        goto ErrorExit;
    }

    pch = GenHeapAlloc(Bytes);
    if (!pch) {
        return NULL;
    }

    if (!ReadFile(hFile, pch, Bytes, pBytesRead, NULL) ||
        *pBytesRead != Bytes) {
        DbgPrintf("BytesRead %d Bytes %d\n", *pBytesRead, Bytes);
        GenHeapFree(pch);
        pch = NULL;
    }

ErrorExit:
    if (!pch) {
        DbgPrintf("GetLastError %d\n", GetLastError());
    }

   return pch;
}


HANDLE
CreateTempFile(
    void
    )
/*++

Routine Description:

    Creates and opens a temporary file.  It will be deleted when it is
    closed.

Arguments:

    None.

Return Value:

    File handle, or INVALID_HANDLE_VALUE on error.

--*/
{
    DWORD dw;
    char PathName[MAX_PATH+1];
    char FileName[2*MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    dw = GetTempPath(MAX_PATH, PathName);
    if (!dw || dw > MAX_PATH) {
        strcpy(PathName, ".");
    }

    dw = GetTempFileName(PathName, "thk", 0, FileName);
    if (!dw) {
        strcpy(PathName, ".");
        dw = GetTempFileName(PathName, "thk", 0, FileName);
        if (!dw) {
            DbgPrintf("GetTempFileName %s GLE=%d\n", FileName, GetLastError());
        }
    }

    hFile = CreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_TEMPORARY |
                      FILE_FLAG_DELETE_ON_CLOSE |
                      FILE_FLAG_SEQUENTIAL_SCAN,
                      0
                      );

    if (hFile == INVALID_HANDLE_VALUE) {
        DbgPrintf("Create %s GLE=%d\n", FileName, GetLastError());
    }

    return hFile;
}



size_t
CopyToken(
    char *pDst,
    char *pSrc,
    size_t Size
    )
/*++

Routine Description:

    Copies a token (a separator-delimited string) from pSrc to pDst.

Arguments:

    pDst    -- destination to write the token to
    pSrc    -- source to copy token from
    Size    -- number of bytes available at pDst.

Return Value:

    Number of bytes copied from pSrc to pDst.

--*/
{
    size_t i = 0;

    while (!IsSeparator(*pSrc) && i < Size) {
        i++;
        *pDst++ = *pSrc++;
    }

    *pDst = '\0';

    return i;
}



char *
SkipKeyWord(
    char *pSrc,
    char *pKeyWord
    )
/*++

Routine Description:

    If the first word at pSrc matches the specified keyword, then skip
    over that keyword.

Arguments:

    pSrc        -- source string to examine
    pKeyWord    -- keyword to try and match

Return Value:

    pSrc unchanged if keyword not matched.  If keyword matched, returns
    ptr to text following the keyword after pSrc.

--*/
{
    int  LenKeyWord;
    char *pch;

    LenKeyWord = strlen(pKeyWord);
    pch = pSrc + LenKeyWord;

    if (!strncmp(pSrc, pKeyWord, LenKeyWord) && IsSeparator(*pch)) {
        pSrc = GetNextToken(pch - 1);
    }

    return pSrc;
}


BOOL
IsSeparator(
    char ch
    )
/*++

Routine Description:

    Determines if a character is a separator or not.
    over that keyword.

Arguments:

    ch      -- character to examine.

Return Value:

    TRUE if the character is a separator, FALSE if not.

--*/
{
   switch (ch) {
      case ' ':
      case '|':
      case '(':
      case ')':
      case '*':
      case ',':
      case '{':
      case '}':
      case ';':
      case '[':
      case ']':
      case '=':
      case '\n':
      case '\r':
      case ':':
      case '.':
      case '\0':
          return TRUE;
      }

    return FALSE;
}



/*
 *  GetNextToken
 */
char *
GetNextToken(
    char *pSrc
    )
/*++

Routine Description:

    Scans the input string and returns the next separator-delimited string.

Arguments:

    pSrc    -- input string

Return Value:

    Ptr to start of the next separator char which isn't a space.

--*/
{
    if (!*pSrc) {
        return pSrc;
    }

    if (!IsSeparator(*pSrc++)) {
        while (*pSrc && !IsSeparator(*pSrc)) {
            pSrc++;
        }
    }

    while (*pSrc && *pSrc == ' ') {
        pSrc++;
    }

    return pSrc;
}


void
DeleteAllocCvmHeap(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Cleans up the mapped shared memory.

Arguments:

    hCvmHeap    -- memory to clean up.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;

    Status = NtFreeVirtualMemory(NtCurrentProcess(),
                        (PVOID *)&pcvmheap->uBaseAddress,
                        &pcvmheap->uRegionSize,
                        MEM_RELEASE);

    if (!NT_SUCCESS(Status)) {
        DbgPrintf("Error freeing CVM %x", Status);
    }
}


HANDLE
CreateAllocCvmHeap(
    ULONG_PTR uBaseAddress,
    ULONG_PTR uReserveSize,
    ULONG_PTR uRegionSize,
    ULONG_PTR uUncomitted,
    ULONG_PTR uUnReserved,
    ULONG_PTR uAvailable
    )
/*++

Routine Description:

    Allocates a region of memory and makes it into a heap.

Arguments:

    uBaseAddress    -- base address to allocate the heap at
    uReserveSize    -- number of bytes to reserve
    uRegionSize     -- size of the region
    uUncomitted     -- amount of uncommitted memory
    uUnReserved     -- amount of unreserved memory
    uAvailable      -- amount of available memory

Return Value:

    Handle to the heap, or NULL on error.

--*/
{
    CVMHEAPINFO *pcvmheap;
    NTSTATUS Status;
    PULONG_PTR pBaseAddress= NULL;

    pcvmheap = GenHeapAlloc(sizeof(CVMHEAPINFO));
    if (pcvmheap == NULL) {
        return NULL;
    }

    pcvmheap->uBaseAddress = uBaseAddress;
    pcvmheap->uReserveSize = uReserveSize;
    pcvmheap->uRegionSize = uRegionSize;
    pcvmheap->uUncomitted = uUncomitted;
    pcvmheap->uUnReserved = uUnReserved;
    pcvmheap->uAvailable = uAvailable;

    //
    // Reserve enuf contiguous address space, for expected needs
    //
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheap->uBaseAddress,
                                         0,
                                         &pcvmheap->uReserveSize,
                                         MEM_RESERVE,
                                         PAGE_NOACCESS
                                         );

    if (!NT_SUCCESS(Status)) {
        //
        // May want to retry this, with a different base address
        //
        ErrMsg(
               "Unable to reserve vm %x %x %x\n",
               pcvmheap->uBaseAddress,
               pcvmheap->uReserveSize,
               Status
              );
        return NULL;
    }

    pcvmheap->uUnReserved = pcvmheap->uBaseAddress + pcvmheap->uReserveSize;


    //
    // Commit the first page, we will grow this a page at a time
    // as its needed.
    //
    pcvmheap->uAvailable = pcvmheap->uBaseAddress;
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheap->uAvailable,
                                         0,
                                         &pcvmheap->uRegionSize,
                                         MEM_COMMIT,
                                         PAGE_READWRITE
                                         );

    if (!NT_SUCCESS(Status)) {
        //
        // May want to retry this, with a different base address
        //
        ErrMsg(
               "Unable to commit vm %x %x %x\n",
               pcvmheap->uBaseAddress,
               pcvmheap->uReserveSize,
               Status
              );
        return NULL;
    }

    pcvmheap->uUncomitted = pcvmheap->uBaseAddress + pcvmheap->uRegionSize;


            // paranoia!
    if (pcvmheap->uAvailable != pcvmheap->uBaseAddress) {
        ErrMsg(
               "commit pvAvailable(%x) != gBaseAddress(%x)\n",
               pcvmheap->uAvailable,
               pcvmheap->uBaseAddress
              );
        return NULL;
    }

    DbgPrintf("Ppm: BaseAddress %x\n", pcvmheap->uBaseAddress);

    return pcvmheap;
}


PVOID
GetCvmHeapBaseAddress(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Returns the base address of a heap.

Arguments:

    hCvmHeap        -- heap to examine

Return Value:

    Base address, or NULL.

--*/
{
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;
    return pcvmheap == NULL ? NULL : (PVOID)pcvmheap->uBaseAddress;
}


PVOID
GetCvmHeapAvailable(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Returns the number of bytes available in a heap.

Arguments:

    hCvmHeap        -- heap to examine

Return Value:

    Bytes available, or NULL.

--*/
{
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;
    return pcvmheap == NULL ? NULL : (PVOID)pcvmheap->uAvailable;
}


PVOID
AllocCvm(
    HANDLE hCvmHeap,
    ULONG_PTR Size
    )
/*++

Routine Description:

    Allocate memory from a heap.

Arguments:

    hCvmHeam        -- heap to allocate from
    Size            -- number of bytes to allocate

Return Value:

    Ptr to allocated memory, or NULL of insufficient memory.

--*/
{
    CVMHEAPINFO *pcvmheapinfo = (CVMHEAPINFO *)hCvmHeap;
    NTSTATUS Status;
    ULONG_PTR Available;
    ULONG_PTR AlignedSize;

    if (pcvmheapinfo == NULL) {
        return NULL;
    }

    //
    // Round the allocation up to the next-highest multiple of 8, so that
    // allocations are correctly aligned.
    //
    AlignedSize = (Size + 7) & ~7;

    Available = pcvmheapinfo->uAvailable;
    pcvmheapinfo->uAvailable += AlignedSize;

    if (pcvmheapinfo->uAvailable >= pcvmheapinfo->uUnReserved) {
        ErrMsg("AllocCvm: Allocation Size exceeds reserved size\n");
        return NULL;
    }

    if (pcvmheapinfo->uAvailable >= pcvmheapinfo->uUncomitted) {
        //
        // Commit enuf pages to exceed the requested allocation size
        //
        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheapinfo->uUncomitted,
                                         0,
                                         &Size,
                                         MEM_COMMIT,
                                         PAGE_READWRITE
                                         );

        if (!NT_SUCCESS(Status)) {
            ErrMsg(
                   "Unable to commit vm %x %x %x\n",
                   pcvmheapinfo->uBaseAddress,
                   Size,
                   Status
                   );
            return NULL;
        }

        pcvmheapinfo->uUncomitted += Size;
    }

    return (PVOID)Available;
}



void ParseIndirection(
    DWORD *pIndLevel,
    DWORD *pdwSize,
    DWORD *pFlags,
    PTOKENTYPE ptkPrePostMod,
    PTOKENTYPE ptkPostMod
    )
/*++

Routine Description:

    Parse any indirection level specificiations ('*') taking into
    account const, volatile, and __ptr64 modifiers.  For example:
    void * const __ptr64 ** const * __ptr64 would be valid.

    NOTE: the pointer is a 64-bit pointer only if the last pointer
          declared is modified by __ptr64.

Arguments:

    pIndlevel       -- [OUT] indirection level (number of '*'s)
    pdwSize         -- [OUT] size of the type (4 or 8)
    pFlags          -- [OUT] BTI_ flags
    ptkPrePostMod   -- [OUT] TK_CONST, TK_VOLATILE, or TK_NONE, depending
                             on modifiers seen before the first '*'
    ptkPostMod      -- [OUT] TK_CONST, TK_VOLATILE, or TK_NONE, depending
                             on modifiers seen after the first '*'

Return Value:

    None.  May not consume any tokens if there are no levels of indirection.

--*/
{
    int IndLevel = 0;
    DWORD dwSize = 0;
    DWORD Flags = 0;
    BOOL fStopScanning = FALSE;
    TOKENTYPE tkPrePostMod = TK_NONE;
    TOKENTYPE tkPostMod = TK_NONE;

    do {
        switch (CurrentToken()->TokenType) {
        case TK_BITWISE_AND:
            ////////////////////////////////////////////////////////////////////
            //The ref operator in C++ is equilivalent to * const in C
            //This implies that & should be treated as a * but add a postmod of const.
            /////////////////////////////////////////////////////////////////////
            tkPostMod = TK_CONST;
        case TK_STAR:
            IndLevel++;
            dwSize = SIZEOFPOINTER;
            Flags &= ~BTI_PTR64;
            ConsumeToken();
            break;

        case TK_CONST:
        case TK_VOLATILE:
            //
            // The caller may be interrested in whether the 'const' or
            // 'volatile' keywords are before or after the '*'
            //
            if (IndLevel) {
                tkPostMod = CurrentToken()->TokenType;
            } else {
                tkPrePostMod = CurrentToken()->TokenType;
            }
            ConsumeToken();
            break;

        case TK_IDENTIFIER:
            if (strcmp(CurrentToken()->Name, sz__PTR64) == 0) {
                dwSize = SIZEOFPOINTER64;
                Flags |= BTI_PTR64;
                ConsumeToken();
                break;
            }

        default:
            fStopScanning = TRUE;
            break;
        }
    } while (!fStopScanning);

    if (pIndLevel != NULL) {
        *pIndLevel += IndLevel;
    }
    if ((pdwSize != NULL) && (dwSize != 0)) {
        *pdwSize = dwSize;
    }
    if (pFlags != NULL) {
        *pFlags |= Flags;
    }
    if (ptkPostMod) {
        *ptkPostMod = tkPostMod;
    }
    if (ptkPrePostMod) {
        *ptkPrePostMod = tkPrePostMod;
    }
}



BOOL
IsTokenSeparator(
    void
    )
/*++

Routine Description:

    Determines if a token is a separator character or not.

Arguments:

    None.  Examines CurrentToken()->TokenType.

Return Value:

    TRUE if CurrentToken() is a separator, FALSE if not.

--*/
{
    switch (CurrentToken()->TokenType) {
    case TK_LPAREN:
    case TK_RPAREN:
    case TK_STAR:
    case TK_BITWISE_AND:
    case TK_COMMA:
    case TK_LBRACE:
    case TK_RBRACE:
    case TK_SEMI:
    case TK_LSQUARE:
    case TK_RSQUARE:
    case TK_COLON:
        return TRUE;

    default:
        return FALSE;
    }
}

VOID
ReleaseToken(
    PTOKEN Token
)
{

/*++

Routine Description:

        Releases any additional memory associated with a token.

Arguments:

        dest        - [IN] ptr to the token.

Return Value:

--*/

    if (Token->TokenType == TK_IDENTIFIER ||
        Token->TokenType == TK_STRING) {
        GenHeapFree(Token->Name);
    }
    Token->TokenType = TK_NONE;
    Token->Value = 0;
    Token->dwValue = 0;
}

void
ResetLexer(
    void
    )
/*++

Routine Description:

    Resets the lexer in preparation to analyze a new statement.

Arguments:

    None.

Return Value:

    None.  Lexer's state reset.

--*/
{
    int TokenCount;

    for (TokenCount = 0;
         TokenCount < MAX_TOKENS_IN_STATEMENT &&
         Tokens[TokenCount].TokenType != TK_EOS;
         ++TokenCount) {

         ReleaseToken(&Tokens[TokenCount]);
    }

    CurrentTokenIndex = 0;
}

__inline
VOID
InitializeToken(
    PTOKEN Token
    )
/*++

Routine Description:

    Initialize a token so the lexer can fill it in.

Arguments:

    Token       -- TOKEN to initialize

Return Value:

    None.

--*/
{
    // The number parser expects Value to be 0.
    Token->TokenType = TK_NONE;
    Token->Value = 0;
    Token->dwValue = 0;
}

void
ProcessEscapes(
    char *String
    )
/*++

Routine Description:

    Process escape characters, replacing them by the proper char.

Arguments:

    String  -- null-terminated string to process

Return Value:

    None.  Conversion is done in-place.

--*/
{
    char *pDest;
    char *pSrc;
    char c;
    int i;

    pSrc = pDest = String;
    while (*pSrc) {
        if (*pSrc != '\\') {
            *pDest = *pSrc;
            pSrc++;
            pDest++;
        } else {
            pSrc++;
            switch (*pSrc) {
            case 'n':
                c = '\n';
                break;

            case 't':
                c = '\t';
                break;

            case 'v':
                c = '\v';
                break;

            case 'b':
                c = '\b';
                break;

            case 'r':
                c = '\r';
                break;

            case 'f':
                c = '\f';
                break;

            case 'a':
                c = '\a';
                break;

            case '\\':
                c = '\\';
                break;

            case '?':
                c = '\?';
                break;

            case '\'':
                c = '\'';
                break;

            case '\"':
                c = '\"';
                break;

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
                // Octal number
                c = 0;
                for (i=0; i<3;++i) {
                    c = (c * 8) + (*pSrc) - '0';
                    pSrc++;
                    if (*pSrc < '0' || *pSrc > '7') {
                        // hit end of number
                        break;
                    }
                }
                break;

            case 'x':
            case 'X':
                // Hex number
                pSrc++;
                c = 0;
                for (i=0; i<3;++i) {
                    char digit;

                    digit = *pSrc;
                    if (digit >= '0' && digit <= '9') {
                        digit -= '0';
                    } else if (digit >= 'a' && digit <= 'f') {
                        digit = digit - 'a' + 10;
                    } else if (digit >= 'A' && digit <= 'A') {
                        digit = digit - 'A' + 10;
                    } else {
                        // hit end of number
                        break;
                    }
                    c = (c * 16) + digit;
                    pSrc++;
                }
                break;

            default:
                // Parse error in the string literal.
                goto Exit;

            }
            *pDest = c;
            pDest++;
        }
    }
Exit:
    // Write the new null-terminator in
    *pDest = '\0';
}



char *
LexOneLine(
    char *p,
    BOOL fStopAtStatement,
    BOOL *pfLexDone
    )
/*++

Routine Description:

    Performs lexical analysis on a single line of input.  The lexer
    may stop before consuming an entire line of input, so the caller
    must closely examine the return code before grabbing the next line.

    __inline functions are deleted by the lexer.  The lexer consumes input
    until it encounters a '{' (assumed to be the start of the function
    body), then consumes input until the matching '}' is found (assumed to
    be the end of the function body).

    "template" is deleted by the lexer and treated as if it was
    an "__inline" keyword... it consumes everything upto '{' then
    keeps consuming until a matching '}' is found.  That makes unknwn.h
    work.

    Lexer unwraps extern "C" {} blocks.

    'static' and '__unaligned' keywords are deleted by the lexer.

    Preprocessor directives are handled via a callout to
    HandlePreprocessorDirective().

Arguments:

    p                   -- ptr into the line of input
    fStopAtStatement    -- TRUE if caller wants lexer to stop at ';' at
                           file-scope.  FALSE if caller wants lexer to stop
                           at ')' at file-scope.
    pfLexDone           -- [OUT] lexer sets this to TRUE if the analysis
                           is complete.  Lexer sets this to FALSE if
                           it needs another line of input from the caller.

Return Value:

    ptr into the line of input where lexing left off, or NULL if entire
    line was consumed.

    CurrentTokenIndex is the index of the next element of the Tokens[]
    array that the lexer will fill in.

    Tokens[] is the array of tokens the lexer has generated.

--*/
{
    static int NestingLevel=0;      // level of nesting of braces and parens
    static BOOL fInlineSeen=FALSE;  // TRUE while deleting __inline functions
    static int ExternCLevel=0;      // tracks the number of extern "C" blocks
    static int InlineLevel=0;       // NestingLevel for the outermost __inline
    int Digit;                      // a digit in a numeric constant
    int NumberBase = 10;            // assume numbers are base-10
    PTOKEN Token;                   // ptr to current token being lexed

    //
    // Assume the lexical analysis is not done
    //
    *pfLexDone = FALSE;

    //
    // Pick up analysis where we left off...
    //
    Token = &Tokens[CurrentTokenIndex];
    InitializeToken(Token);

    //
    // Loop over all characters in the line, or until a complete lexical
    // unit is done (depends on fStopAtStatement).
    //
    while (*p) {
        switch (*p) {
        case ' ':
        case '\t':
        case '\r':
        case '\n':
        case '\v':
        case '\f':
        case '\b':
        case '\a':
        case '\\':  // line-continuation characters are ignored
            p++;
            continue;

        case '#':
            //
            // HandlePreprocessorDirective() is implemented in the
            // app which links to genmisc.c.
            //
            HandlePreprocessorDirective(p);
            CurrentTokenIndex = (int)(Token - Tokens);
            return NULL;

        case '+':
            Token->TokenType = TK_PLUS;
            break;

        case '-':
            Token->TokenType = TK_MINUS;
            break;

        case ':':
            Token->TokenType = TK_COLON;
            break;

        case '=':
            Token->TokenType = TK_ASSIGN;
            break;

        case ';':
            if (NestingLevel == 0 && fStopAtStatement) {
                //
                // Found a ';' at file-scope.  This token marks the
                // end of the C-language statement.
                //
                p++;
                if (*p == '\n') {
                    //
                    // ';' is at EOL - consume it now.
                    //
                    p++;
                }
                Token->TokenType = TK_EOS;
                *pfLexDone = TRUE;
                CurrentTokenIndex = (int)(Token - Tokens + 1);
                return p;
            }
            Token->TokenType = TK_SEMI;
            break;

        case '*':
            Token->TokenType = TK_STAR;
            break;

        case '/':
            Token->TokenType = TK_DIVIDE;
            break;

        case ',':
            Token->TokenType = TK_COMMA;
            break;

        case '<':
            if (p[1] == '<') {
                Token->TokenType = TK_LSHIFT;
                p++;
            } else {
                Token->TokenType = TK_LESS;
            }
            break;

        case '>':
            if (p[1] == '>') {
                Token->TokenType = TK_RSHIFT;
                p++;
            } else {
                Token->TokenType = TK_GREATER;
            }
            break;

        case '&':
            if (p[1] == '&') {
                Token->TokenType = TK_LOGICAL_AND;
                p++;
            } else {
                Token->TokenType = TK_BITWISE_AND;
            }
            break;

        case '|':
            if (p[1] == '|') {
                Token->TokenType = TK_LOGICAL_OR;
                p++;
            } else {
                Token->TokenType = TK_BITWISE_OR;
            }
            break;

        case '%':
            Token->TokenType = TK_MOD;
            break;

        case '^':
            Token->TokenType = TK_XOR;
            break;

        case '!':
            Token->TokenType = TK_NOT;
            break;

        case '~':
            Token->TokenType = TK_TILDE;
            break;

        case '[':
            Token->TokenType = TK_LSQUARE;
            break;

        case ']':
            Token->TokenType = TK_RSQUARE;
            break;

        case '(':
            NestingLevel++;
            Token->TokenType = TK_LPAREN;
            break;

        case ')':
            NestingLevel--;
            if (NestingLevel == 0 && !fStopAtStatement) {
                //
                // Found a ')' at file-scope, and we're lexing
                // the contents of an @-command in genthnk.
                // Time to stop lexing.
                //
                p++;
                Token->TokenType = TK_EOS;
                *pfLexDone = TRUE;
                CurrentTokenIndex = (int)(Token - Tokens + 1);
                return p;
            } else if (NestingLevel < 0) {
                ExitErrMsg(FALSE, "Parse Error: mismatched nested '(' and ')'\n");
            }
            Token->TokenType = TK_RPAREN;
            break;

        case '{':
            //check for a 'extern "C" {}' or 'extern "C++" {}'
            if (Token - Tokens >= 2 &&
                Token[-2].TokenType == TK_EXTERN &&
                Token[-1].TokenType == TK_STRING &&
                (strcmp(Token[- 1].Name, "C") == 0 || strcmp(Token[-1].Name, "C++") == 0)) {

                    if (NestingLevel == 0 && fInlineSeen) {
                        ExitErrMsg(FALSE, "Extern \"C\" blocks only supported at file scope\n");
                    }
                    ExternCLevel++;


                    //remove the last 2 tokens and skip this token
                    ReleaseToken(Token - 2);
                    ReleaseToken(Token - 1);
                    Token -= 2;
                    p++;
                    continue;
            }

            NestingLevel++;
            Token->TokenType = TK_LBRACE;
            break;

        case '.':
            if (p[1] == '.' && p[2] == '.') {
                Token->TokenType = TK_VARGS;
                p+=2;
            } else {
                Token->TokenType = TK_DOT;
            }
            break;

        case '}':
            if (NestingLevel == 0 && ExternCLevel > 0) {
                //omit this token since it is the end of an extern "C" block
                ExternCLevel--;
                p++;
                continue;
            }
            NestingLevel--;
            if (NestingLevel < 0) {
                ExitErrMsg(FALSE, "Parse Error: mismatched nested '{' and '}'\n");
            }
            else if (NestingLevel == InlineLevel && fInlineSeen) {
                //
                // Found the closing '}' for the end of an inline
                // function.  Advance past the '}' and start lexing
                // again as if the __inline was never there.
                //
                fInlineSeen = FALSE;
                p++;
                continue;
            }
            else {
                Token->TokenType = TK_RBRACE;
            }
            break;

        case '0':
            if (p[1] == 'x' || p[1] == 'X') {
                //
                // Found '0x' prefix - the token is a hex constant
                //
                Token->TokenType = TK_NUMBER;

                for (p+=2; *p != '\0'; p++) {
                    if (isdigit(*p)) {
                        int i;
                        i = *p - '0';
                        Token->Value = Token->Value * 16 + i;
                        Token->dwValue = Token->dwValue * 16 + i;
                    } else {
                        char c = (char)toupper(*p);
                        if (c >= 'A' && c <= 'F') {
                            int i;
                            i = c - 'A' + 10;
                            Token->Value = Token->Value * 16 + i;
                            Token->dwValue = Token->dwValue * 16 + i;
                        } else if (c == 'L') {
                            //
                            // Numeric constant ending in 'L' is a long-integer
                            // type.
                            //
                            break;
                        } else if (isalpha(c)) {
                            DumpLexerOutput(0);
                            ExitErrMsg(FALSE, "Parse Error in hex constant.\n");
                        } else {
                            p--;
                            break;
                        }

                    }
                }
                break;
            } else if (isdigit(p[1])) {
                //
                // Found '0' followed by a valid number - the token is
                // an octal constant.
                //
                NumberBase = 8;

            }
            // fall into general number processing code

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            Token->TokenType = TK_NUMBER;

            for (; *p != '\0'; p++) {
                Digit = *p - '0';
                if (*p == 'l' || *p == 'L') {
                    //
                    // Numeric constant ending in 'l' is a long-integer
                    //
                    break;
                } else if (Digit < 0 || Digit >= NumberBase) {
                    p--;
                    break;
                }
                Token->Value = Token->Value * NumberBase + Digit;
                Token->dwValue = Token->dwValue * NumberBase + Digit;
            }
            break;

        case '\'':
            Token->TokenType = TK_NUMBER;
            p++;  //skip past beginning '
            for(; *p != '\''; p++) {
                if (*p == '\0') {
                   ExitErrMsg(FALSE, "\' without ending \'\n");
                }
                Token->Value = Token->Value << 8 | (UCHAR)*p;
                Token->dwValue = Token->dwValue << 8 | (UCHAR)*p;
            }
            break;

        case '"':
            // A string literal. ie. char *p = "foo";
            {
                char *strStart;

                Token->TokenType = TK_STRING;
                strStart = ++p; //skip begining quote

                //get a count of the number of characters
                while (*p != '\0' && *p != '"') p++;

                if ('\0' == *p || '\0' == *(p+1)) {
                    ExitErrMsg(FALSE, "String without ending quote\n");
                }
                p++; //skip past the ending quote

                Token->Name = GenHeapAlloc(p - strStart); //1+strlen
                if (Token->Name == NULL) {
                    ExitErrMsg(FALSE, "Out of memory in lexer\n");
                }

                memcpy(Token->Name, strStart, p-strStart-1);
                Token->Name[p-strStart-1] = '\0';
                p--;
                ProcessEscapes(Token->Name);
            }
            break;

        default:
            if (*p == '_' || isalpha(*p)) {
                //
                // An identifier or keyword
                //
                char *IdStart = p;

                Token->TokenType = TK_IDENTIFIER;

                while (*p == '_' || isalpha(*p) || isdigit(*p)) {
                    p++;
                }
                Token->Name = GenHeapAlloc(p - IdStart + 1);
                if (Token->Name == NULL) {
                    ExitErrMsg(FALSE, "Out of memory in lexer\n");
                }
                memcpy(Token->Name, IdStart, p-IdStart);
                Token->Name[p-IdStart] = '\0';

                CheckForKeyword(Token);
                if (Token->TokenType == TK_TEMPLATE) {
                    fInlineSeen = TRUE;
                    InlineLevel = NestingLevel; // want to get back to the same scope
                } else if (Token->TokenType == TK_INLINE) {
                    if (NestingLevel) {
                        //
                        // __inline keyword embedded inside {}.  It's
                        // technically an error but we want to allow it
                        // during inclusion of ntcb.h.
                        //
                        continue;
                    }
                    fInlineSeen = TRUE;
                    InlineLevel = 0;    // want to get back to file scope
                } else if (Token->TokenType == TK_STATIC ||
                           Token->TokenType == TK_UNALIGNED ||
                           Token->TokenType == TK_RESTRICT ||
                           Token->TokenType == TK___W64) {
                    // filter out 'static', '__restrict', '__unaligned' and '__w64'
                    // keywords
                    continue;
                }
                p--;
            } else if (fInlineSeen) {
                //
                // While processing __inline functions, the lexer is
                // going to encounter all sorts of weird characters
                // in __asm blocks, etc.  Just ignore them and keep
                // consuming input.
                //
                p++;
                continue;
            } else {
                ExitErrMsg(FALSE, "Lexer: unexpected char '%c' (0x%x) found\n", *p, *p);
            }
        } // switch

        p++;
        if (!fInlineSeen) {
            Token++;
            if (Token == &Tokens[MAX_TOKENS_IN_STATEMENT]) {
                ExitErrMsg(FALSE, "Lexer internal error - too many tokens in this statement.");
            }
            InitializeToken(Token);
        }
    } // while (*p)

    //
    // Hit end-of-line.  Indicate this to the caller
    //
    Token->TokenType = TK_EOS;
    CurrentTokenIndex = (int)(Token - Tokens);
    return NULL;
}


void
CheckForKeyword(
    PTOKEN Token
    )
/*++

Routine Description:

    Converts a TK_INDENTIFIER token into a C-language keyword token, if
    the identifier is in the KeywordList[].

Arguments:

    Token       -- Token to convert

Return Value:

    None.       Token->TokenType and Token->Name may be changed.

--*/
{
    int i;
    int r;

    for (i=0; KeywordList[i].MatchString; ++i) {
        r = strcmp(Token->Name, KeywordList[i].MatchString);
        if (r == 0) {
            GenHeapFree(Token->Name);
            Token->Name = NULL;
            Token->TokenType = KeywordList[i].Tk;
            return;
        } else if (r < 0) {
            return;
        }
    }
}

void
DumpLexerOutput(
    int FirstToken
    )
/*++

Routine Description:

    Debug routine to dump out the Token list as human-readable text.

Arguments:

    FirstToken      -- Index of the first token to list back.

Return Value:

    None.

--*/
{
    int i;

    for (i=0; i<FirstToken; ++i) {
        if (Tokens[i].TokenType == TK_EOS) {
            fprintf(stderr, "DumpLexerOutput: FirstToken %d is after EOS at %d\n", FirstToken, i);
            return;
        }
    }

    fprintf(stderr, "Lexer: ");
    for (i=FirstToken; Tokens[i].TokenType != TK_EOS; ++i) {
        switch (Tokens[i].TokenType) {
        case TK_NUMBER:
            fprintf(stderr, "0x%X ", Tokens[i].Value);
            break;

        case TK_IDENTIFIER:
        case TK_STRING:
            fprintf(stderr, "%s ", Tokens[i].Name);
            break;

        case TK_NONE:
            fprintf(stderr, "<TK_NONE> ");
            break;

        default:
            fprintf(stderr, "%s ", TokenString[(int)Tokens[i].TokenType]);
            break;
        }
    }
    fprintf(stderr, "<EOS>\n");
}


BOOL
UnlexToText(
    char *dest,
    int destlen,
    int StartToken,
    int EndToken
    )
/*++

Routine Description:

    Convert a sequence of Tokens back into human-readable text.

Arguments:

    dest        -- ptr to destination buffer
    destlen     -- length of destination buffer
    StartToken  -- index of first token to list back
    EndToken    -- index of last token (this token is *not* listed back)

Return Value:

    TRUE if Unlex successful.  FALSE if failure (ie. buffer overflow).

--*/
{
    int i;
    int len;
    char buffer[16];
    char *src;

    if (bDebug) {
        for (i=0; i<StartToken; ++i) {
            if (Tokens[i].TokenType == TK_EOS) {
                ErrMsg("UnlexToText: StartToken %d is after EOS %d\n", StartToken, i);
                return FALSE;
            }
        }
    }

    for (i=StartToken; i<EndToken; ++i) {
        switch (Tokens[i].TokenType) {
        case TK_EOS:
            return FALSE;

        case TK_NUMBER:
            sprintf(buffer, "%d", Tokens[i].Value);
            src = buffer;
            break;

        case TK_IDENTIFIER:
                case TK_STRING:
            src = Tokens[i].Name;
            break;

        case TK_NONE:
            src = "<TK_NONE>";
            break;

        default:
            src = TokenString[(int)Tokens[i].TokenType];
            break;
        }

        len = strlen(src);
        if (len+1 > destlen) {
            return FALSE;
        }
        strcpy(dest, src);
        dest += len;
        *dest = ' ';
        dest++;
        destlen -= len+1;
    }
    dest--;         // back up over the trailing ' '
    *dest = '\0';   // null-terminate

    return TRUE;
}


PVOID
GenHeapAlloc(
    INT_PTR Len
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, Len);
}

void
GenHeapFree(
    PVOID pv
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, pv);
}


TOKENTYPE
ConsumeDirectionOpt(
    void
    )
/*++

Routine Description:

    Comsumes a TK_IN or TK_OUT, if present in the lexer stream.  TK_IN
    followed by TK_OUT is converted to TK_INOUT.

Arguments:

    None.

Return Value:

    TK_IN, TK_OUT, TK_INOUT, or TK_NONE.

--*/
{
    TOKENTYPE t = CurrentToken()->TokenType;

    switch (t) {
    case TK_IN:
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_OUT) {
            ConsumeToken();
            t = TK_INOUT;
        }
        break;

    case TK_OUT:
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_IN) {
            ConsumeToken();
            t = TK_INOUT;
        }
        break;

    default:
        t = TK_NONE;
        break;
    }

    return t;
}


TOKENTYPE
ConsumeConstVolatileOpt(
    void
    )
/*++

Routine Description:

    Comsumes a TK_CONST or TK_VOLATILE, if present in the lexer stream.

Arguments:

    None.

Return Value:

    TK_CONST, TK_VOLATILE, or TK_NONE.

--*/
{
    TOKENTYPE t = CurrentToken()->TokenType;

    switch (t) {
    case TK_CONST:
    case TK_VOLATILE:
        ConsumeToken();
        break;

    default:
        t = TK_NONE;
        break;
    }

    return t;
}


PMEMBERINFO
AllocMemInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PMEMBERINFO pmeminfo
    )
/*++

Routine Description:

    Allocates a new MEMBERINFO struct from the buffer

Arguments:

    pbufallocinfo -- ptr to memory buffer to allocate from
    pmeminfo      -- ptr to list of MEMBERINFOs to link the new one into

Return Value:

    Newly-allocated, initialized, linked-in MEMBERINFO struct (or NULL)

--*/
{
    PMEMBERINFO pmeminfoNext;

    pmeminfoNext = BufAllocate(pbufallocinfo, sizeof(MEMBERINFO));
    if (pmeminfoNext) {
        if (pmeminfo) {
            pmeminfo->pmeminfoNext = pmeminfoNext;
        }
        memset(pmeminfoNext, 0, sizeof(MEMBERINFO));
    }   
    return pmeminfoNext;
}

PFUNCINFO
AllocFuncInfoAndLink(
    BUFALLOCINFO *bufallocinfo,
    PFUNCINFO pfuncinfo
    )
/*++

Routine Description:

    Allocates a new FUNCINFO struct from the buffer

Arguments:

    pbufallocinfo -- ptr to memory buffer to allocate from
    pmeminfo      -- ptr to list of FUNCINFOs to link the new one into

Return Value:

    Newly-allocated, initialized, linked-in FUNCINFO struct (or NULL)

--*/
{
    PFUNCINFO pfuncinfoNext;

    pfuncinfoNext = BufAllocate(bufallocinfo, sizeof(FUNCINFO));
    if ((pfuncinfoNext != NULL) && (pfuncinfo != NULL)) {
        pfuncinfo->pfuncinfoNext = pfuncinfoNext;
        pfuncinfoNext->sName = NULL;
        pfuncinfoNext->sType = NULL;
    }
    return pfuncinfoNext;
}

DWORD
SizeOfMultiSz(
    char *c
    )
{
/*++

Routine Description:

        Determines the number of bytes used by double '\0' terminated list.

Arguments:

        c           - [IN] ptr to the double '\0' termined list.

Return Value:

        Bytes used.
--*/
    DWORD dwSize = 1;
    char cPrevChar = '\0'+1;
    do {
        dwSize++;
        cPrevChar = *c;
    } while(*++c != '\0' || cPrevChar != '\0');
    return dwSize;
}

BOOL
CatMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    )
{
/*++

Routine Description:

        Concatinates two double '\0' terminated lists.
        New list is stored at dest.

Arguments:

        dest        - [IN/OUT] ptr to the head double '\0' terminated list.
        element     - [IN] ptr to the head double '\0' terminated list.
        dwMaxSize   - [IN] max size of the new list in bytes.

Return Value:

        TRUE     - Success.
        FALSE    - Failure.
--*/
    //Find end of MultiSz
    DWORD dwLengthDest, dwLengthSource;
    dwLengthDest = SizeOfMultiSz(dest);
    if (2 == dwLengthDest) dwLengthDest = 0;
    else dwLengthDest--;
    dwLengthSource = SizeOfMultiSz(source);
    if (dwLengthDest + dwLengthSource > dwMaxSize) return FALSE;
    memcpy(dest + dwLengthDest, source, dwLengthSource);
    return TRUE;
}

BOOL
AppendToMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    )
{
/*++

Routine Description:

        Adds a string to the end of a double '\0' terminated list.

Arguments:

        dest      - [IN/OUT] ptr to the double '\0' terminated list.
        source    - [IN] ptr to the string to add.
        dwMaxSize - [IN] max number of bytes that can be used by the list.

Return Value:

        TRUE     - Success.
        FALSE    - Failure.
--*/
    DWORD dwLengthDest, dwLengthSource;
    dwLengthDest = SizeOfMultiSz(dest);
    if (2 == dwLengthDest) dwLengthDest = 0;
    else dwLengthDest--;
    dwLengthSource = strlen(source) + 1;
    if (dwLengthDest + dwLengthSource + 1 > dwMaxSize) return FALSE;
    memcpy(dest + dwLengthDest, source, dwLengthSource);
    *(dest + dwLengthDest + dwLengthSource) = '\0';
    return TRUE;
}

BOOL IsInMultiSz(
    const char *multisz,
    const char *element
    )
{
/*++

Routine Description:

        Determines if a string exists in a double '\0' terminated list.

Arguments:

        ppHead  - [IN] ptr to the double '\0' terminated list.
        element - [IN] ptr to the element to find.
Return Value:

        TRUE     - element is in the list.
        FALSE    - element is not in the list.
--*/
    do {
        if (strcmp(multisz, element) == 0) return TRUE;
        //skip to end of string
        while(*multisz++ != '\0');
    } while(*multisz != '\0');
    return FALSE;
}

BOOL
ConvertGuidCharToInt(
    const char *pString,
    DWORD *n,
    unsigned short number
    )
{
/*++

Routine Description:

        Internal route to be called only from ConvertStringToGuid.
        Converts segements of the GUID to numbers.

Arguments:

        pString  - [IN] ptr to the string segment to process.
        n        - [OUT] ptr to number representation of string segment.
        number   - [IN] size of string segment in characters.

Return Value:

        TRUE  - Success.
--*/
    unsigned short base = 16; //guid numbers are in hex
    *n = 0;

    while(number-- > 0) {
        int t;

        if (*pString >= '0' && *pString <= '9') {
            t = *pString++ - '0';
        }
        else if (*pString >= 'A' && *pString <= 'F') {
            t = (*pString++ - 'A') + 10;
        }
        else if (*pString >= 'a' && *pString <= 'f') {
            t = (*pString++ - 'a') + 10;
        }
        else return FALSE;

        *n = (*n * base) + t;
    }

    return TRUE;
}

BOOL
ConvertStringToGuid(
    const char *pString,
    GUID *pGuid
    )
{

/*++

Routine Description:

        Converts a string in the form found in _declspec(uuid(GUID)) to a GUID.
        Braces around guid are acceptable and are striped before processing.

Arguments:

        pString - [IN] ptr to the string that represents the guid.
        pGuid   - [OUT] ptr to the new guid.

Return Value:

        TRUE    - Success.
--*/

    DWORD t;
    unsigned int c;
    unsigned int guidlength = 36;
    char tString[37]; //guidlength + 1

    t = strlen(pString);
    if (guidlength + 2 == t) {
        //string is surounded with braces
        //check for braces and chop
        if (pString[0] != '{' || pString[guidlength + 1] != '}') return FALSE;
        memcpy(tString, pString + 1, guidlength);
        tString[guidlength] = '\0';
        pString = tString;
    }

    else if (t != guidlength) return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 8)) return FALSE;
    pString += 8;
    pGuid->Data1 = t;
    if (*pString++ != '-') return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 4)) return FALSE;
    pString += 4;
    pGuid->Data2 = (unsigned short)t;
    if (*pString++ != '-') return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 4)) return FALSE;
    pString += 4;
    pGuid->Data3 = (unsigned short)t;
    if (*pString++ != '-') return FALSE;

    for(c = 0; c < 8; c++) {
        if (!ConvertGuidCharToInt(pString, &t, 2)) return FALSE;
        pString += 2;
        pGuid->Data4[c] = (unsigned char)t;
        if (c == 1)
            if (*pString++ != '-') return FALSE;
    }

    return TRUE;
}

BOOL
IsDefinedPointerDependent(
    char *pName
    )
{
/*++

Routine Description:

        Determines if a typename is inharenty pointer size dependent.
        The user is expected to check pointers and derived types.

Arguments:

        pName   - [IN] Type to check.

Return Value:

        TRUE    - Type is pointer size dependent.
--*/
    if (NULL == pName) return FALSE;
    if (strcmp(pName, "INT_PTR") == 0) return TRUE;
    if (strcmp(pName, "UINT_PTR") == 0) return TRUE;
    if (strcmp(pName, "HALF_PTR") == 0) return TRUE;
    if (strcmp(pName, "UHALF_PTR") == 0) return TRUE;
    if (strcmp(pName, "LONG_PTR") == 0) return TRUE;
    if (strcmp(pName, "ULONG_PTR") == 0) return TRUE;
    if (strcmp(pName, "__int64") == 0) return TRUE;
    if (strcmp(pName, "_int64") == 0) return TRUE;
    return FALSE;
}

PCHAR
IsDefinedPtrToPtrDependent(
    IN char *pName
    )
/*++

Routine Description:

        Determines if a typename is inharenty a pointer to a pointer
        dependent type. The user is expected to check pointers to pointers and derived types.
        All of these types have an indirection level of 1.

Arguments:

        pName   - [IN] Type to check.

Return Value:

        Pointer to the name of the indirection of this type.
--*/
{
   if (*pName != 'P') return NULL;
   if (strcmp(pName, "PINT_PTR") == 0) return "INT_PTR";
   if (strcmp(pName, "PUINT_PTR") == 0) return "UINT_PTR";
   if (strcmp(pName, "PHALF_PTR") == 0) return "HALF_PTR";
   if (strcmp(pName, "PUHALF_PTR") == 0) return "UHALF_PTR";
   if (strcmp(pName, "PLONG_PTR") == 0) return "LONG_PTR";
   if (strcmp(pName, "PULONG_PTR") == 0) return "ULONG_PTR";
   return NULL;
}

static HANDLE hFile = INVALID_HANDLE_VALUE;
static HANDLE hMapFile = NULL;
static void  *pvMappedBase = NULL;

BOOL
ClosePpmFile(
   BOOL bExitFailure
   )
{
/*++

Routine Description:

        Closes the opened ppm file.

Arguments:

        bExitFailure - [IN] Terminate program on error

Return Value:

        Error        - FALSE
        Success      - TRUE

--*/

   if (NULL != pvMappedBase) {
      if(!UnmapViewOfFile(pvMappedBase)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to unmap ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      pvMappedBase = NULL;
   }
   if (NULL != hMapFile) {
      if(!CloseHandle(hMapFile)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to close ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      hMapFile = NULL;
   }
   if (INVALID_HANDLE_VALUE != hFile) {
      if(!CloseHandle(hFile)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to close ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      hFile = INVALID_HANDLE_VALUE;
   }
   return TRUE;
}

PCVMHEAPHEADER
MapPpmFile(
   char *sPpmfile,
   BOOL bExitFailure
   )
{

/*++

Routine Description:

       Opens a Ppm file and maps it.

Arguments:

        pName        - [IN] Name of the file to map.
        bExitFailure - [IN] Terminate program on error

Return Value:

        Error        - NULL
        Success      - Pointer to the VCVMHEAPHEADER

--*/
   void  *pvBaseAddress;
   DWORD  dwBytesRead;
   BOOL   fSuccess;
   ULONG Version;
   DWORD dwErrorNo;

   PCVMHEAPHEADER pHeader;

   hFile = CreateFile(sPpmfile,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL
                      );

   if (hFile == INVALID_HANDLE_VALUE) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to open %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   fSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(ULONG)) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to read version for %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   if (Version != VM_TOOL_VERSION) {
       //SetLastError(ERROR_BAD_DATABASE_VERSION);
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Ppm file file has version %x, expect %x\n", Version, VM_TOOL_VERSION);
   }

#if _WIN64
   // Read and skip the padding between the version and the base
   fSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(ULONG)) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to read version for %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

#endif


   fSuccess = ReadFile(hFile,
                       &pvBaseAddress,
                       sizeof(pvBaseAddress),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(pvBaseAddress)) {
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Unable to read base address of ppm file %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }


   hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
   if (!hMapFile) {
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmfile: Unable to map %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   pvMappedBase = MapViewOfFileEx(hMapFile, FILE_MAP_READ, 0, 0, 0, pvBaseAddress);
   if (! pvMappedBase || pvMappedBase != pvBaseAddress) {
       // If the file can't be mapped at the expected base, we must fail
       // since the memory is chock full o' pointers.
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Unable to map view of %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   NIL = &((PCVMHEAPHEADER)pvMappedBase)->NIL;
   return (PCVMHEAPHEADER)pvMappedBase;

fail:

   dwErrorNo = GetLastError();
   ClosePpmFile(FALSE);
   SetLastError(dwErrorNo);
   return NULL;

}

char szHOSTPTR32[] = "/* 64 bit ptr */ _int64";
char szHOSTPTR64[] = "/* 32 bit ptr */ _int32";

char *GetHostPointerName(BOOL bIsPtr64) {
   if (bIsPtr64)
      return szHOSTPTR32;
   else
      return szHOSTPTR64;
}

char szHOSTUSIZE8[] = "unsigned _int8";
char szHOSTUSIZE16[] = "unsigned _int16";
char szHOSTUSIZE32[] = "unsigned _int32";
char szHOSTUSIZE64[] = "unsigned _int64";
char szHOSTSIZE8[] = "_int8";
char szHOSTSIZE16[] = "_int16";
char szHOSTSIZE32[] = "_int32";
char szHOSTSIZE64[] = "_int64";
char szHOSTSIZEGUID[] = "struct _GUID";

char *GetHostBasicTypeName(PKNOWNTYPES pkt) {

   DWORD dwSize;

   if (pkt->Flags & BTI_ISARRAY)
      dwSize = pkt->dwBaseSize;
   else
      dwSize = pkt->Size;

   if (pkt->Flags & BTI_UNSIGNED) {
      switch(pkt->Size) {
         case 1:
             return szHOSTUSIZE8;
         case 2:
             return szHOSTUSIZE16;
         case 4:
             return szHOSTUSIZE32;
         case 8:
             return szHOSTUSIZE64;
         default:
             ExitErrMsg(FALSE, "Unknown type size of %d for type %s.\n", pkt->Size, pkt->TypeName);
             return 0;
      }
   }
   else {
      switch(pkt->Size) {
         case 0:
             return szVOID;
         case 1:
             return szHOSTSIZE8;
         case 2:
             return szHOSTSIZE16;
         case 4:
             return szHOSTSIZE32;
         case 8:
             return szHOSTSIZE64;
         case 16:
             return szHOSTSIZEGUID;
         default:
             ExitErrMsg(FALSE, "Unknown type size of %d for type %s.\n", pkt->Size, pkt->TypeName);
             return 0;
      }
   }
}

char *GetHostTypeName(PKNOWNTYPES pkt, char *pBuffer) {
   if (pkt->IndLevel > 0) {
      strcpy(pBuffer, GetHostPointerName(pkt->Flags & BTI_PTR64));
   }
   else if(!(BTI_NOTDERIVED & pkt->Flags)) {
      if (strcmp(pkt->BaseName, "enum") == 0) {
         strcpy(pBuffer, szHOSTSIZE32);
      }
      else if (strcmp(pkt->BaseName, "union") == 0 ||
               strcmp(pkt->BaseName, "struct") == 0) {
         strcpy(pBuffer, pkt->BaseName);
         strcat(pBuffer, " NT32");
         strcat(pBuffer, pkt->TypeName);
      }
      else {
         strcpy(pBuffer, "NT32");
         strcat(pBuffer, pkt->TypeName);
      }
   }
   else {
      strcpy(pBuffer, GetHostBasicTypeName(pkt));
   }
   return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tools\genlib\redblack.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    redblack.c

Abstract:
    
    This module implements red/black trees.
    
Author:

    16-Jun-1995 t-orig

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "gen.h"

PKNOWNTYPES NIL;

#define RIGHT(x)        x->RBRight
#define LEFT(x)         x->RBLeft
#define PARENT(x)       x->RBParent
#define COLOR(x)        x->RBColor
#define KEY(x)          x->TypeName

VOID
RBInitTree(
    PRBTREE ptree
    )
{
    ptree->pRoot = NIL;
    ptree->pLastNodeInserted = NULL;
}


PKNOWNTYPES
RBLeftRotate(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Rotates the tree to the left at node x.


         x                     y
        / \                   / \
       A   y       ==>>      x   C
          / \               / \
         B   C             A   B

Arguments:

    root - The root of the Red/Black tree
    x - The node at which to rotate

Return Value:

    return-value - The new root of the tree (which could be the same as 
                   the old root).

--*/
{
    PKNOWNTYPES y;

    y = RIGHT(x);
    RIGHT(x) = LEFT(y);
    if (LEFT(y) != NIL){
        PARENT(LEFT(y)) = x;
    }
    PARENT(y) = PARENT(x);
    if (PARENT(x) == NIL){
        root = y;
    } else if (x==LEFT(PARENT(x))) {
        LEFT(PARENT(x)) = y;
    } else {
        RIGHT(PARENT(x))= y;
    }
    LEFT(y) = x;
    PARENT(x) = y;
    return root;
}



PKNOWNTYPES
RBRightRotate(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Rotates the tree to the right at node x.


         x                     y
        / \                   / \
       y   C       ==>>      A   x
      / \                       / \
     A   B                     B   C

Arguments:

    root - The root of the Red/Black tree
    x - The node at which to rotate

Return Value:

    return-value - The new root of the tree (which could be the same as
                   the old root).

--*/
{
    PKNOWNTYPES y;

    y = LEFT(x);
    LEFT(x) = RIGHT(y);
    if (RIGHT(y) != NIL) {
        PARENT(RIGHT(y)) = x;
    }
    PARENT(y) = PARENT(x);
    if (PARENT(x) == NIL) {
        root = y;
    } else if (x==LEFT(PARENT(x))) {
        LEFT(PARENT(x)) = y;
    } else {
        RIGHT(PARENT(x))= y;
    }
    RIGHT(y) = x;
    PARENT(x) = y;
    return root;
}




PKNOWNTYPES
RBTreeInsert(
    PKNOWNTYPES root,
    PKNOWNTYPES z
    )
/*++

Routine Description:

    Inserts a new node into a tree without preserving the red/black properties.
    Should ONLY be called by RBInsert!  This is just a simple binary tree
    insertion routine.

Arguments:

    root -  The root of the red/black tree
    z - The new node to insert

Return Value:

    return-value - The new root of the tree (which could be the same as the
    old root).
    

--*/
{
    PKNOWNTYPES x,y;
    int i;

    y = NIL;
    x = root;

    LEFT(z) = RIGHT(z) = NIL;

    // Find a place to insert z by doing a simple binary search
    while (x!=NIL) {
        y = x;
        i = strcmp(KEY(z), KEY(x));
        if (i < 0){
            x = LEFT(x);
        } else {
            x = RIGHT(x);
        }
    }

    // Insert z into the tree
    PARENT(z)= y;

    if (y==NIL) {
        root = z;
    } else if (i<0) {
        LEFT(y) = z;
    } else {
        RIGHT(y) = z;
    }

    return root;
}


VOID
RBInsert(
    PRBTREE     ptree,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Inserts a node into a red/black tree while preserving the red/black
    properties.

Arguments:

    root -  The root of the red/black tree
    z - The new node to insert

Return Value:

    return-value - The new root of the tree (which could be the same as
                   the old root).

--*/
{
    PKNOWNTYPES root = ptree->pRoot;
    PKNOWNTYPES y;

    // Make a linked-list of nodes for easy deletion
    x->Next = ptree->pLastNodeInserted;
    ptree->pLastNodeInserted = x;
    
    // Insert x into the tree without preserving the red/black properties
    root = RBTreeInsert (root, x);
    COLOR(x) = RED;

    // We can stop fixing the tree when either:
    // 1) We got to the root 
    // 2) x has a BLACK parent (the tree obeys the red/black properties,
    //    because no RED parent has a RED child.
    while ((x != root) && (COLOR(PARENT(x)) == RED)) {
        if (PARENT(x) == LEFT(PARENT(PARENT(x)))) {
            // Parent of x is a left child with sibling y.
            y = RIGHT(PARENT(PARENT(x)));
            if (COLOR(y) == RED) {
                // Since y is red, just change everyone's color and try again
                // with x's grandfather
                COLOR (PARENT (x)) = BLACK;
                COLOR(y) = BLACK;
                COLOR(PARENT(PARENT(x))) = RED;
                x =  PARENT(PARENT(x));
            } else if (x == RIGHT (PARENT (x))) {
                // Here y is BLACK and x is a right child.  A left rotation
                // at x would prepare us for the next case
                x = PARENT(x);
                root = RBLeftRotate (root, x);
            } else {
                // Here y is BLACK and x is a left child.  We fix the tree by
                // switching the colors of x's parent and grandparent and
                // doing a right rotation at x's grandparent.
                COLOR (PARENT (x)) = BLACK;
                COLOR (PARENT (PARENT (x))) = RED;
                root = RBRightRotate (root, PARENT(PARENT(x)));
            }
        } else {
            // Parent of x is a right child with sibling y.
            y = LEFT(PARENT(PARENT(x)));
            if (COLOR(y) == RED) {
                // Since y is red, just change everyone's color and try again
                // with x's grandfather
                COLOR (PARENT (x)) = BLACK;
                COLOR(y) = BLACK;
                COLOR(PARENT(PARENT(x))) = RED;
                x =  PARENT(PARENT(x));
            } else if (x == LEFT (PARENT (x))) {
                // Here y is BLACK and x is a left child.  A right rotation
                // at x would prepare us for the next case
                x = PARENT(x);
                root = RBRightRotate (root, x);
            } else {
                // Here y is BLACK and x is a right child.  We fix the tree by
                // switching the colors of x's parent and grandparent and
                // doing a left rotation at x's grandparent.
                COLOR (PARENT (x)) = BLACK;
                COLOR (PARENT (PARENT (x))) = RED;
                root = RBLeftRotate (root, PARENT(PARENT(x)));
            }
        }
    } // end of while loop

    COLOR(root) = BLACK;
    ptree->pRoot= root;
}


PKNOWNTYPES
RBFind(
    PRBTREE ptree,
    char *Name
    )
/*++

Routine Description:

    Finds a node in the red black tree given a name

Arguments:

    root - The root of the red/black tree
    name - The name corresponding to the node to be searched for.

Return Value:

    return-value - The node in the tree (entry point of code containing name), or
        NULL if not found.


--*/
{
    int i;
    PKNOWNTYPES root = ptree->pRoot;

    while (root != NIL) {
        i = strcmp(Name, KEY(root));
        if (i < 0) {
            root = LEFT(root);
        } else if (i > 0) {
            root = RIGHT(root);
        } else {
            return root;
        }
    }
    return NULL;  // Range not found
}


PKNOWNTYPES
RBTreeSuccessor(
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Returns the successor of a node in a binary tree (the successor of x 
    is defined to be the node which just follows x in an inorder
    traversal of the tree).

Arguments:

    x - The node whose successor is to be returned

Return Value:

    return-value - The successor of x

--*/

{
    PKNOWNTYPES y;

    // If x has a right child, the successor is the leftmost node to the
    // right of x.
    if (RIGHT(x) != NIL) {
        x = RIGHT(x);
        while (LEFT(x) != NIL) {
            x = LEFT(x);
        }
        return x;
    }
    
    // Else the successor is an ancestor with a left child on the path to x
    y = PARENT(x);
    while ((y != NIL) && (x == RIGHT(y))) {
        x = y;
        y = PARENT(y);
    }
    return y;
}



PKNOWNTYPES
RBDeleteFixup(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Fixes the red/black tree after a delete operation.  Should only be 
    called by RBDelete

Arguments:

    root - The root of the red/black tree
    x - Either a child of x, or or a child or x's successor

Return Value:

    return-value - The new root of the red/black tree

--*/
{
    PKNOWNTYPES w;

    // We stop when we either reached the root, or reached a red node (which
    // means that property 4 is no longer violated).
    while ((x!=root) && (COLOR(x)==BLACK)) {
        if (x == LEFT(PARENT(x))) {
            // x is a left child with sibling w      
            w = RIGHT(PARENT(x));
            if (COLOR(w) == RED) {
                // If w is red it must have black children.  We can switch
                // the colors of w and its parent and perform a left
                // rotation to bring w to the top.  This brings us to one
                // of the other cases.
                COLOR(w) = BLACK;
                COLOR(PARENT(x)) = RED;
                root = RBLeftRotate (root, PARENT(x));
                w = RIGHT(PARENT(x));
            }
            if ((COLOR(LEFT(w)) == BLACK) && (COLOR(RIGHT(w)) == BLACK)) {
                // Here w is black and has two black children.  We can thus
                // change w's color to red and continue.
                COLOR(w) = RED;
                x = PARENT(x);
            } else {
                if (COLOR(RIGHT(w)) == BLACK) {
                    // Here w is black, its left child is red, and its right child
                    // is black.  We switch the colors of w and its left child,
                    // and perform a left rotation at w which brings us to the next
                    // case.
                    COLOR(LEFT(w)) = BLACK;
                    COLOR(w) = RED;
                    root = RBRightRotate (root, w);
                    w = RIGHT(PARENT(x));
                } 
                // Here w is black and has a red right child.  We change w's
                // color to that of its parent, and make its parent and right
                // child black.  Then a left rotation brings w to the top.
                // Making x the root ensures that the while loop terminates.
                COLOR(w) = COLOR(PARENT(x));
                COLOR(PARENT(x)) = BLACK;
                COLOR(RIGHT(w)) = BLACK;
                root = RBLeftRotate (root, PARENT(x));
                x = root;
            }
        } else {
            // The symmetric case:  x is a right child with sibling w.
            w = LEFT(PARENT(x));
            if (COLOR(w) == RED) {
                COLOR(w) = BLACK;
                COLOR(PARENT(x)) = RED;
                root = RBRightRotate (root, PARENT(x));
                w = LEFT(PARENT(x));
            }
            if ((COLOR(LEFT(w)) == BLACK) && (COLOR(RIGHT(w)) == BLACK)) {
                COLOR(w) = RED;
                x = PARENT(x);
            } else {
                if (COLOR(LEFT(w)) == BLACK) {
                    COLOR(RIGHT(w)) = BLACK;
                    COLOR(w) = RED;
                    root = RBLeftRotate (root, w);
                    w = LEFT(PARENT(x));
                } 
                COLOR(w) = COLOR(PARENT(x));
                COLOR(PARENT(x)) = BLACK;
                COLOR(LEFT(w)) = BLACK;
                root = RBRightRotate (root, PARENT(x));
                x = root;
            }
        }
    } // end of while loop

    //printf ("Changing color at %i to BLACK\n", x->intelColor);
    COLOR(x) = BLACK;
    return root;
}




PKNOWNTYPES
RBDelete(
    PRBTREE ptree,
    PKNOWNTYPES z
    )
/*++

Routine Description:

    Deletes a node in a red/black tree while preserving the red/black 
    properties.

Arguments:

    root - The root of the red/black tree
    z - The node to be deleted

Return Value:

    return-value - The new root of the red/black tree

--*/
{
    PKNOWNTYPES x,y;
    PKNOWNTYPES root = ptree->pRoot;
    COL c;

    
    // It's easy to delete a node with at most one child:  we only need to
    // remove it and put the child in its place.  It z has at most one child,
    // we can just remove it.  Otherwise we'll replace it with its successor
    // (which is guaranteed to have at most one child, or else one of its
    // children would be the succecssor), and delete the successor.
    if ((LEFT(z) == NIL) || (RIGHT(z) == NIL)) {
        y = z;
    } else {
        y = RBTreeSuccessor(z);
    }

    // Recall that y has at most one child.  If y has one child, x is set to
    // it.  Else x will be set to NIL which is OK.  This way we don't have
    // to worry about this special case.
    if (LEFT(y) != NIL){
        x = LEFT(y);
    } else {
        x = RIGHT(y);
    }
    
    // Now we will remove y from the tree
    PARENT(x) = PARENT(y);
    
    if (PARENT(y) == NIL) {
        root = x;
    } else if (y == LEFT(PARENT(y))) {
        LEFT(PARENT(y)) = x;
    } else {
        RIGHT(PARENT(y)) = x;
    }

    if (PARENT(x) == z) {
        PARENT(x) = y;
    }

    c = COLOR(y);

    // Since each node has lots of fields (fields may also change during
    // the lifetime of this code), I found it safer to copy the
    // pointers as opposed to data.
    if (y!=z) { // Now swapping y and z, but remembering color of y
        PARENT(y) = PARENT(z);

        if (root == z) {
            root = y;
        } else if (z == RIGHT(PARENT(z))) {
            RIGHT(PARENT(z)) = y;
        } else {
            LEFT(PARENT(z)) = y;
        }

        LEFT(y) = LEFT(z);
        if (LEFT(y) != NIL) {
            PARENT(LEFT(y)) = y;
        }

        RIGHT(y) = RIGHT(z);
        if (RIGHT(y) != NIL) {
            PARENT(RIGHT(y)) = y;
        }

        COLOR(y) = COLOR(z);
    }


    // Need to fix the tree (fourth red/black property).
    if (c == BLACK) {
        root = RBDeleteFixup (root, x);
    }
    return root;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tools\idlclean\idlclean.c ===
//////////////////////////////////////////////////////////////////////////////
// idlclean
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
//      Takes a MIDL-generated .H file and converts the commented-out
//      [in] and [out] keywords into IN and OUT so sortpp/genthnk can
//      find them.
//
//////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'IDLCLEAN' ";

#define BUFLEN 8192
char buffer[BUFLEN];

const char szLinePrefix[]="/* ";
const char szIn[] = "[in]";
const char szOut[] = "[out]";

                        
int __cdecl main(int argc, char *argv[])
{
    FILE *fpIn, *fpOut;
    char *p;
    char *pchLineStart;
    BOOL fInPrinted;
    BOOL fOutPrinted;

    if (argc != 3) {
        fprintf(stderr, "%sUsage: IDLCLEAN infile outfile\n", ErrMsgPrefix);
        return 1;
    }
    fpIn = fopen(argv[1], "r");
    if (!fpIn) {
        fprintf(stderr, "%sCould not open input file '%s'\n", ErrMsgPrefix, argv[1]);
        return 1;
    }
    fpOut = fopen(argv[2], "w");
    if (!fpOut) {
        fprintf(stderr, "%sCould not open output file '%s\n", ErrMsgPrefix, argv[2]);
        return 1;
    }

    while (!feof(fpIn)) {
        //
        // Read a line from the input file
        //
        if (!fgets(buffer, BUFLEN, fpIn)) {
            break;
        }
        if (feof(fpIn)) {
            break;
        }
        pchLineStart = buffer;

        //
        // Skip leading spaces
        //
        while (*pchLineStart == ' ') {
            fprintf(fpOut, " ");
            pchLineStart++;
        }

        if (strncmp(pchLineStart, szLinePrefix, sizeof(szLinePrefix)-1) != 0) {
            //
            // Line doesn't start with the character sequence which prefixes
            // in/out decorators on arguments.
            //
            goto PrintLine;
        }

        //
        // Don't generate 'IN IN', etc. caused by MIDL output like
        // '[in][size_is][in]'
        //
        fInPrinted = FALSE;
        fOutPrinted = FALSE;

        //
        // Set a pointer to the first '['
        //
        p = pchLineStart + sizeof(szLinePrefix)-1;
        if (*p != '[') {
            //
            // The first char inside the comment isn't a '['.  Just print
            // the line as-is.
            //
            goto PrintLine;
        }

        //
        // The line needs modification.  Do it now.
        //
        fprintf(fpOut, "    ");
        while (*p == '[') {
            if (strncmp(p, szIn, sizeof(szIn)-1) == 0) {
                if (!fInPrinted) {
                    fprintf(fpOut, "IN ");
                    fInPrinted = TRUE;
                }
                p += sizeof(szIn)-1;
            } else if (strncmp(p, szOut, sizeof(szOut)-1) == 0) {
                if (!fOutPrinted) {
                    fprintf(fpOut, "OUT ");
                    fOutPrinted = TRUE;
                }
                p += sizeof(szOut)-1;
            } else {
                //
                // Uninterresting [keyword].  Skip it.
                //
                while (*p != ']') {
                    p++;
                }
                p++;
            }
        }

        //
        // pchLineStart points at the first non-space in the line, so the
        // whole line will be printed.
        //
PrintLine:
        fprintf(fpOut, "%s", pchLineStart);
    }
    fclose(fpOut);
    fclose(fpIn);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tools\sortpp\sortpp.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    sortpp.c

Abstract:

    This program parses the file winincs.pp and generates a .PPM file
    compatible with GENTHNK.

Author:

    08-Jul-1995 JonLe

Revision History:

    27-Nov-1996 BarryBo -- code cleanup and documentation
    20-Mar-1998 mzoran  -- Added support for finding COM interfaces

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include "gen.h"

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8604: 'SORTPP' ";

FILE *fpHeaders;
int StatementLineNumber;
char SourceFileName[MAX_PATH+1];
int  SourceLineNumber;
int TypeId = 0;

void DumpLexerOutput(int FirstToken);

//
// packing size as specified by /Zp option to the CL command
//
#define DEFAULTPACKINGSIZE 8

DWORD dwPackingCurrent = DEFAULTPACKINGSIZE;

typedef struct _packholder {
    struct _packholder *ppackholderNext;
    DWORD dwPacking;
    char sIdentifier[1];
    } PACKHOLDER;

PACKHOLDER *ppackholderHead = NULL;

struct TypeInfoListElement {
    struct TypeInfoListElement *pNext;
    TYPESINFO *pTypeInfo;
};

typedef struct TypeInfoListElement *PTYPEINFOELEMENT;

PKNOWNTYPES NIL;    // for red-black trees
PRBTREE FuncsList;
PRBTREE StructsList;
PRBTREE TypeDefsList;
RBTREE _VarsList;
PRBTREE VarsList = &_VarsList; // Used to track global variable declarations.
                               // Should not appear in the PPM file

char Headers[MAX_PATH+1];
char ppmName[MAX_PATH+1];

HANDLE hCvmHeap;
ULONG uBaseAddress = 0x30000000;
ULONG uReserveSize = 0x01800000;

BOOL bLine = FALSE;
char szThis[] = "This";

DWORD dwScopeLevel = 0;

void ExtractDerivedTypes(void);
BOOL LexNextStatement(void);
BOOL ParseFuncTypes(PTYPESINFO pTypesInfo, BOOL fDllImport);
BOOL ParseStructTypes(PTYPESINFO pTypesInfo);
BOOL ParseTypeDefs(PTYPESINFO pTypesInfo);
BOOL ParseVariables(VOID);
BOOL ParseGuid(GUID *pGuid);
BOOL AddDefaultDerivedTypes(void);
PKNOWNTYPES AddNewType(PTYPESINFO pTypesInfo, PRBTREE pTypesList);
BOOL CopyStructMembers(PTYPESINFO pTypesInfo, BOOL bUnion, PKNOWNTYPES pBaseType);
BOOL CopyEnumMembers(PTYPESINFO);
int CreatePseudoName(char *pDst, char *pSrc);
BOOL GetArrayIndex(DWORD *pdw);
LONGLONG expr(void);
LONGLONG expr_a1(void);
LONGLONG expr_a(void);
LONGLONG expr_b(void);
LONGLONG expr_c(void);
void CheckUpdateTypedefSizes(PTYPESINFO ptypesinfo);
PVOID SortppAllocCvm(ULONG Size);
BOOL WritePpmFile(char *PpmName);
void BumpStructUnionSize(DWORD *pdwSize, DWORD dwElemSize, BOOL bUnion);
BOOL GetExistingType(PTYPESINFO pTypesInfo, PBOOL pbFnPtr, PKNOWNTYPES *ppKnownTypes);
BOOL PrepareMappedMemory(void);
DWORD PackPaddingSize(DWORD dwCurrentSize, DWORD dwBase);
void PackPush(char *sIdentifier);
DWORD PackPop(char *sIdentifier);
BOOL ConsumeDeclSpecOpt(BOOL IsFunc, BOOL bInitReturns, BOOL *pIsDllImport, BOOL *pIsGuidDefined, GUID *pGuid);
TOKENTYPE ConsumeDirectionOpt(void);
TOKENTYPE ConsumeConstVolatileOpt(void);
PTYPEINFOELEMENT TypeInfoElementAllocateLink(PTYPEINFOELEMENT *ppHead, PTYPEINFOELEMENT pThis, TYPESINFO *pType);
VOID UpdateGuids(VOID);
BOOL AddVariable(char *Name, GUID * pGuid);
VOID GenerateProxy(char *pName, PTYPESINFO pTypesInfo);
VOID FreeTypeInfoList(PTYPEINFOELEMENT pThis);
PMEMBERINFO CatMeminfo(BUFALLOCINFO *pBufallocinfo, PMEMBERINFO pHead, PMEMBERINFO pTail, DWORD dwOffset, BOOL bStatus);
BOOL ConsumeExternC(void);

//
// PPC compiler is screwing up the Initializa list head macro !
//
#if defined (_PPC_)
#undef InitializeListHead
#define InitializeListHead(ListHead) ( (ListHead)->Flink = (ListHead), \
                                       (ListHead)->Blink = (ListHead) \
                                      )
#endif


_inline void
PackModify(
    DWORD dw
)
{
    dwPackingCurrent = dw;
    DbgPrintf("new packing is %x\n", dw);
}

_inline DWORD
PackCurrentPacking(
    void
)
{
    return dwPackingCurrent;
}

DWORD PackPaddingSize(DWORD dwCurrentSize, DWORD dwBase)
{
    DWORD dw;

    if (dwCurrentSize == 0) {
        return 0;                   // no padding for first member
    }

    if (dwBase == 0) {
        dwBase = SIZEOFPOINTER;
    }                               // if no base size yet then must be a ptr

                                    // base is min(size, packing)
    if (dwBase > PackCurrentPacking()) {
        dwBase = PackCurrentPacking();
    }

                                    // figure out padding
    return (dwBase - (dwCurrentSize % dwBase)) % dwBase;
}

_inline DWORD PackPackingSize(DWORD dwCurrentSize, DWORD dwSize,
                              DWORD dwBase)
{
                                    // round up to nearest dwBase
    return PackPaddingSize(dwCurrentSize, dwBase) + dwSize;
}



/* main
 *
 * standard win32 base windows entry point
 * returns 0 for clean exit, otherwise nonzero for error
 *
 *
 * ExitCode:
 *  0       - Clean exit with no Errors
 *  nonzero - error ocurred
 *
 */
int __cdecl main(int argc, char **argv)
{
    int      i;
    char *pHeaders = NULL;
    char *pch;
    DWORD LenHeaders=0;

    SetConsoleCtrlHandler(ConsoleControlHandler, TRUE);

    try {

        /*
         *  Get cmd line args.
         */
        i = 0;
        while (++i < argc)  {
            pch = argv[i];
            if (*pch == '-' || *pch == '/') {
                pch++;
                switch (toupper(*pch)) {
                case 'D':     // debug forces extra check
                    bDebug = TRUE;
                    setvbuf(stderr, NULL, _IONBF, 0);
                    break;

                case 'L':
                    bLine = TRUE;
                    break;

                case 'M':    // ppm output filename
                    strcpy(ppmName, ++pch);
                    DeleteFile(ppmName);
                    break;

                 case 'B':   // gBaseAddress
                     pch++;
                     uBaseAddress = atoi(pch);
                     break;

                 case 'R':   // Reserve size
                     pch++;
                     uReserveSize = atoi(pch);
                     break;

                 case '?':   // usage
                     ExitErrMsg(FALSE,
                     "sortpp -d -l -w -m<ppm file> -b<Base addr> -r<reserved> <pp file>\n");

                 default:
                     ExitErrMsg(FALSE, "Unrecognized option %s\n", pch);
                 }
            } else if (*pch) {
               strcpy(Headers, pch);
            }
        }

        if (!*Headers) {
            ExitErrMsg(FALSE, "no Headers file name\n");
        }

        if (!*ppmName) {
          ExitErrMsg(FALSE, "no -m<PPM filename>\n");
        }


        DbgPrintf("%s -> %s\n", Headers, ppmName);


        if (!PrepareMappedMemory()) {
            ExitErrMsg(FALSE, "Problem in PrepareMappedMemory %s, gle = %d\n",
                                                  Headers, GetLastError());
        }

        RBInitTree(FuncsList);
        RBInitTree(StructsList);
        RBInitTree(TypeDefsList);
        RBInitTree(VarsList);  //not in the PPM file

        fpHeaders = fopen(Headers, "r");

        if (fpHeaders == NULL) {
            ExitErrMsg(FALSE, "Headers open '%s' errno=%d\n", Headers, errno);
        }

        if (!AddDefaultDerivedTypes()) {
            ExitErrMsg(TRUE, "AddDefaultDerivedTypes failed\n");
        }

        // pull out the different types: structs, typedefs function prototypes
        ExtractDerivedTypes();

        // Attempt to update guids for structs that don't have them
        UpdateGuids();

        if (!WritePpmFile(ppmName)) {
            ExitErrMsg(FALSE, "Problem in WritePpmFile gle = %d\n", GetLastError());
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExitErrMsg(FALSE,
                   "sortpp: ExceptionCode=%x\n",
                   GetExceptionCode()
                   );
    }

    DeleteAllocCvmHeap(hCvmHeap);

    return 0;
}



BOOL
AddDefaultDerivedTypes(
    void
    )
/*++

Routine Description:

    Add signed, unsigned to TypeDefsList.  Treated as derived types
    based on int.

Arguments:

    None.

Return Value:

    TRUE on success, FALSE on failure (probably out-of-memory)

--*/
{
    TYPESINFO TypesInfo;
    PFUNCINFO funcinfo;

    memset(&TypesInfo, 0, sizeof(TYPESINFO));

    strcpy(TypesInfo.BasicType,szINT);
    strcpy(TypesInfo.BaseName,szINT);
    strcpy(TypesInfo.TypeName,szINT);
    TypesInfo.Size = sizeof(int);
    TypesInfo.iPackSize = sizeof(int);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"short int");
    TypesInfo.Size = sizeof(short int);
    TypesInfo.iPackSize = sizeof(short int);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned short int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"long int");
    TypesInfo.Size = sizeof(long int);
    TypesInfo.iPackSize = sizeof(long int);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned long int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szCHAR);
    strcpy(TypesInfo.BaseName,szCHAR);
    strcpy(TypesInfo.TypeName,szCHAR);
    TypesInfo.Size = sizeof(char);
    TypesInfo.iPackSize = sizeof(char);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,szUNSIGNEDCHAR);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szINT64);
    strcpy(TypesInfo.BaseName,szINT64);
    strcpy(TypesInfo.TypeName,szINT64);
    TypesInfo.Size = sizeof(__int64);
    TypesInfo.iPackSize = sizeof(__int64);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned _int64");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,sz_INT64);
    strcpy(TypesInfo.BaseName,sz_INT64);
    strcpy(TypesInfo.TypeName,sz_INT64);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned __int64");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szDOUBLE);
    strcpy(TypesInfo.BaseName,szDOUBLE);
    strcpy(TypesInfo.TypeName,szDOUBLE);
    TypesInfo.Size = sizeof(double);
    TypesInfo.iPackSize = sizeof(double);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szFLOAT);
    strcpy(TypesInfo.BaseName,szFLOAT);
    strcpy(TypesInfo.TypeName,szFLOAT);
    TypesInfo.Size = sizeof(float);
    TypesInfo.iPackSize = sizeof(float);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szVOID);
    strcpy(TypesInfo.BaseName,szVOID);
    strcpy(TypesInfo.TypeName,szVOID);
    TypesInfo.Size = 0;
    TypesInfo.iPackSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szGUID);
    strcpy(TypesInfo.BaseName,szGUID);
    strcpy(TypesInfo.TypeName,szGUID);
    TypesInfo.Size = 16;
    TypesInfo.iPackSize = 16;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szFUNC);
    strcpy(TypesInfo.BaseName,szFUNC);
    strcpy(TypesInfo.TypeName,szFUNC);
    TypesInfo.Flags = BTI_CONTAINSFUNCPTR | BTI_NOTDERIVED;
    TypesInfo.Size = 4;
    TypesInfo.iPackSize = 4;
    TypesInfo.dwMemberSize = sizeof(FUNCINFO)+strlen(szVOID)+1;
    TypesInfo.TypeKind = TypeKindFunc;
    funcinfo = (PFUNCINFO)TypesInfo.Members;
    TypesInfo.pfuncinfo = funcinfo;
    funcinfo->sType = TypesInfo.Members + sizeof(FUNCINFO);
    strcpy(funcinfo->sType, szVOID);
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    TypesInfo.dwMemberSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    TypesInfo.TypeKind = TypeKindEmpty;
    TypesInfo.pfuncinfo = NULL;
    memset(TypesInfo.Members, 0, sizeof(TypesInfo.Members));

    strcpy(TypesInfo.BasicType,szVARGS);
    strcpy(TypesInfo.BaseName,szVARGS);
    strcpy(TypesInfo.TypeName,szVARGS);
    TypesInfo.Size = 0;               // varargs has size of 0
    TypesInfo.iPackSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic pointer type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "*");
    strcpy(TypesInfo.BaseName, "*");
    strcpy(TypesInfo.TypeName, "*");
    TypesInfo.IndLevel = 1;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic struct type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "struct");
    strcpy(TypesInfo.BaseName, "struct");
    strcpy(TypesInfo.TypeName, "struct");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic union type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "union");
    strcpy(TypesInfo.BaseName, "union");
    strcpy(TypesInfo.TypeName, "union");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Default type that matches all types.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "default");
    strcpy(TypesInfo.BaseName, "default");
    strcpy(TypesInfo.TypeName, "default");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ConsumeExternC(
    void
    )
{

/*++

Routine Description:

    Consumes an extern or an extern "C".

Arguments:

    None.

Return Value:

    TRUE - extern or extern "C" was consumed.

--*/

    PTOKEN Token;
    Token = CurrentToken();
    if (Token->TokenType == TK_EXTERN) {
        ConsumeToken();
        Token = CurrentToken();
        if (Token->TokenType == TK_STRING &&
            strcmp(Token->Name, "C") == 0)
            ConsumeToken();
        return TRUE;
    }
    return FALSE;
}

void
ExtractDerivedTypes(
    void
    )

/*++

Routine Description:

    Removes derived type definitions from headers, building the
    TypesDef, Structs, and Funcs lists.

Arguments:

    None.

Return Value:

    None.

--*/
{
    TYPESINFO TypesInfo;
    PRBTREE pListHead;
    BOOL fDllImport;

    //
    // Lex in entire C-language statements, then parse them.  Stops at EOF.
    //
    while (LexNextStatement()) {

        int OldTokenIndex;
        int c;

        if (bDebug) {
            DumpLexerOutput(0);
        }

        if (bLine) {
            for(c=80; c > 0; c--)
                fputc('\b', stderr);
            c = fprintf(stderr, "Status: %s(%d)", SourceFileName, StatementLineNumber);
            for(; c < 78; c++)
                fputc(' ', stderr);
            fflush(stderr);
        }

        pListHead = NULL;
        assert(dwScopeLevel == 0);

        if (CurrentToken()->TokenType == TK_EOS) {

            //ddraw.h has an extra ; at the end of an extern "C" block
            continue;

        }

        ConsumeExternC();

        ConsumeDeclSpecOpt(TRUE, TRUE, &fDllImport, NULL, NULL);

        ConsumeExternC();

        OldTokenIndex = CurrentTokenIndex;
        //
        // Try to parse as a TypeDef.
        //
        if (ParseTypeDefs(&TypesInfo)) {
            //
            // Got a typedef
            //
            if (CurrentToken()->TokenType == TK_EOS) {
                pListHead = TypeDefsList;
                goto DoAddNewType;
            }
        }

        //
        // Failed to parse as TypeDef.  Try to parse as a struct/union/enum
        //
        CurrentTokenIndex = OldTokenIndex;
        if (ParseStructTypes(&TypesInfo)) {
            //
            // got a struct definition
            //
            if (CurrentToken()->TokenType == TK_EOS) {
                pListHead = StructsList;
                goto DoAddNewType;
            }
        }

        //
        // Failed to parse as struct/union/enum.  Try to parse as function
        //
        CurrentTokenIndex = OldTokenIndex;
        if (ParseFuncTypes(&TypesInfo, fDllImport)) {
            //
            // got a function prototype
            //
            if (CurrentToken()->TokenType == TK_EOS && !TypesInfo.IndLevel) {
                pListHead = FuncsList;
                goto DoAddNewType;
            }
        }

        CurrentTokenIndex = OldTokenIndex;
        if (ParseVariables()) continue;

        CurrentTokenIndex = OldTokenIndex;

DoAddNewType:
        if (pListHead && !AddNewType(&TypesInfo, pListHead)) {
            ErrMsg("AddNewType fail\n");
        }

        if (CurrentToken()->TokenType != TK_EOS && bDebug) {

            fprintf(stderr, "Warning: Rejected %s(%d)\n", SourceFileName, StatementLineNumber);
            //
            // Use the 8k buffer in TypesInfo.Members to unlex the source stmt
            //
            UnlexToText(TypesInfo.Members,
                        sizeof(TypesInfo.Members),
                        0,
                        MAX_TOKENS_IN_STATEMENT);
            fprintf(stderr, "\t%s;\n", TypesInfo.Members);
        }
    }
}



PKNOWNTYPES
AddNewType(
    PTYPESINFO pTypesInfo,
    PRBTREE pTypesList
    )
/*++

Routine Description:

    Adds a new type to a types list.

Arguments:

    pTypesInfo  -- type to add
    pTypesList  -- list to add the type to

Return Value:

    Returns a pointer to the KNOWNTYPES for the new type on success,
    NULL for error.

--*/
{
    PKNOWNTYPES pkt;
    PKNOWNTYPES pKnownTypes = NULL;
    PDEFBASICTYPES pdbt;
    ULONG Flags = 0;
    BOOL bRet = FALSE;

    if (((pTypesList == TypeDefsList) || (pTypesList == StructsList)) &&
        (((pTypesInfo->Size == 0) || (pTypesInfo->iPackSize == 0)) &&
        (*pTypesInfo->Members != 0))) {
        DbgPrintf("Added type with invalid size %s %s %s %d %d\n",
                     pTypesInfo->BasicType,
                     pTypesInfo->BaseName,
                     pTypesInfo->TypeName,
                     pTypesInfo->Size,
                     pTypesInfo->iPackSize);
    }

    pTypesInfo->TypeId = TypeId++;
    pTypesInfo->LineNumber = SourceLineNumber;
    pTypesInfo->dwScopeLevel = dwScopeLevel;
    pTypesInfo->dwCurrentPacking = PackCurrentPacking();
    if (strlen(SourceFileName) > sizeof(pTypesInfo->FileName) - 1)
        ExitErrMsg(FALSE, "Source file name is too large.\n");
    strcpy(pTypesInfo->FileName, SourceFileName);
    if (IsDefinedPointerDependent(pTypesInfo->TypeName))
       pTypesInfo->Flags |= BTI_POINTERDEP;

    //
    // Loop up the type and see if it is already in the list
    //
    pkt = GetNameFromTypesList(pTypesList, pTypesInfo->TypeName);
    if (pkt) {
//
// Uncomment the next line and comment the following line to change the
// behavior of this function. By doing this you will allow functions to be
// redefined in the following case: First a function that has no arguments
// is encountered and entered in the list. Later the same function is
// encountered with arguments and the new definition for it would override
// the old.
//      if ((pTypesList == StructsList) || (pTypesList == FuncsList)) {
        if (pTypesList == StructsList) {

            if (pTypesInfo->dwMemberSize == 0) {
                //
                // Since the struct has already been defined lets grab its
                // relevant size information.
                //
                pTypesInfo->IndLevel = pkt->IndLevel;
                pTypesInfo->Size = pkt->Size;
                pTypesInfo->iPackSize = pkt->iPackSize;
                pTypesInfo->TypeId = pkt->TypeId;
                return pkt;
            }

            if (! pkt->pmeminfo) {
                //
                // Find any previously defined typedefs that are based upon this
                // struct and fix their size.

                CheckUpdateTypedefSizes(pTypesInfo);
                ReplaceInTypesList(pkt, pTypesInfo);
                return pkt;
            }
        }
        else if (pkt->Flags & BTI_DISCARDABLE) {
            ReplaceInTypesList(pkt, pTypesInfo);
            return pkt;
        }
        //
        // else if it already exists, assume is the same
        //
        DbgPrintf("typedef: %s previously defined\n", pTypesInfo->TypeName);
        return pkt;
    }

    //
    // Type is not already listed.  Look up its basic type
    //
    pdbt = GetDefBasicType(pTypesInfo->BasicType);
    if (pdbt) {
       Flags = 0;
    } else {
        pkt = GetNameFromTypesList(pTypesList, pTypesInfo->BasicType);
        if (pkt) {
            Flags = pkt->Flags;
            pdbt = GetDefBasicType(pkt->BasicType);
            if (!pdbt) {
                ErrMsg("types Table corrupt %s\n", pkt->TypeName);
            }
        } else {
            ErrMsg("ant: unknown Basic Type %s\n", pTypesInfo->BasicType);
            goto ErrorExit;
        }
    }

    pTypesInfo->Flags |= Flags;
    strcpy(pTypesInfo->BasicType, pdbt->BasicType);
    pKnownTypes = AddToTypesList(pTypesList, pTypesInfo);
    if (pKnownTypes == NULL)
       goto ErrorExit;

    if (bDebug)
       DumpTypesInfo(pTypesInfo, stdout);

    return pKnownTypes;

ErrorExit:
    if (bDebug) {
        DumpTypesInfo(pTypesInfo, stdout);
    }


    DumpTypesInfo(pTypesInfo, stderr);
    return NULL;

}


void
CheckUpdateTypedefSizes(
    PTYPESINFO ptypesinfo
    )
/*++

Routine Description:

    We are about to replace an empty struct definition with one that has
    members and thus a size. We need to look through the typedefs list and
    see if any that have a size of 0 are defined from this new struct and if
    so then fix its size and packing size.

Arguments:

    ptypesinfo  -- struc definition with members

Return Value:

    None.

--*/
{
    PKNOWNTYPES pknwntyp, pkt;

    pknwntyp = TypeDefsList->pLastNodeInserted;

    while (pknwntyp) {
        if (pknwntyp->Size == 0) {
            pkt = GetBasicType(pknwntyp->TypeName, TypeDefsList, StructsList);
            if (pkt && ( ! strcmp(pkt->BasicType, szSTRUCT)) &&
                       ( ! strcmp(pkt->TypeName, ptypesinfo->TypeName))) {
                pknwntyp->Size = ptypesinfo->Size;
                pknwntyp->iPackSize = ptypesinfo->iPackSize;
                pknwntyp->Flags |= (ptypesinfo->Flags & BTI_CONTAINSFUNCPTR);
            }
        }
        pknwntyp = pknwntyp->Next;
    }
}


BOOL
GetExistingType(
    PTYPESINFO pTypesInfo,
    PBOOL pbFnPtr,
    PKNOWNTYPES *ppKnownTypes
    )
/*++

Routine Description:

    Gets an existing type from the lexer stream and returns the type
    information for it.

Arguments:

    pSrc        -- IN ptr to start of typename to look up
    pTypesInfo  -- Information of
    pbFnPtr     -- [OPTIONAL] OUT TRUE if the type is a pointer to a function
    ppKnownTypes-- [OPTIONAL] OUT KnownType infomation for this type if not a function pointer.

Return Value:

    FALSE if the name is not an existing type, or TRUE if the name is an
    existing type (CurrentToken ends up pointing at the token following the
    type).

--*/
{
    PKNOWNTYPES pKnownType;
    int OldCurrentTokenIndex = CurrentTokenIndex;

    if (bDebug) {
        fputs("GetExisting type called with the following lexer state:\n", stderr);
        DumpLexerOutput(CurrentTokenIndex);
    }
    memset(pTypesInfo, 0, sizeof(TYPESINFO));
    if (pbFnPtr) {
        *pbFnPtr = FALSE;
    }

    if (ParseStructTypes(pTypesInfo)) {
        if ((pKnownType = AddNewType(pTypesInfo, StructsList)) != NULL) {
            if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
            return TRUE;
        } else {
            if (ppKnownTypes != NULL) *ppKnownTypes = NULL;
            return FALSE;
        }
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (pbFnPtr && ParseFuncTypes(pTypesInfo, FALSE)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = NULL;
        *pbFnPtr = TRUE;
        return TRUE;
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (ParseTypes(TypeDefsList, pTypesInfo, &pKnownType)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
        return TRUE;
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (ParseTypes(StructsList, pTypesInfo, &pKnownType)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
        return TRUE;
    }

    return FALSE;
}


BOOL
ParseTypeDefs(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Parses a C-language statement if it is a 'typedef'.  Accepted syntaxes are:

    typedef <mod> type <indir> NewName<[]> <, <indir> NewName<[]>>
    typedef <mod> struct|enum|union <name> <indir> NewName <, <indir> NewName>
    typedef <mod> rtype <indir>(<modifiers * NewName ) ( <arg List>)

    (Note that we don't deal with extraneous parens very well)

Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the statement is a typedef
    FALSE if the statement is not a typedef or some kind of error

--*/
{
    int IndLevel;
    BOOL bFnPtr = FALSE;
    TYPESINFO TypesInfo;
    DWORD dwSize;
    PKNOWNTYPES pKnownTypes = NULL;
    int i;
    int Flags;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));

    if (CurrentToken()->TokenType == TK_DECLSPEC) {
        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
    }

    if (CurrentToken()->TokenType != TK_TYPEDEF) {
        //
        // Line doesn't start with 'typedef'
        //
        return FALSE;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_STAR ||
        CurrentToken()->TokenType == TK_BITWISE_AND) {
        //
        // We have something like: 'typedef *foo;'.  This happens if a
        // .IDL file has a bogus typedef.  MIDL just omits the typename
        // if it isn't recognized.  Fake up a TypesInfo for 'int'.
        //
        ConsumeToken();
        bFnPtr = FALSE;
        memset(&TypesInfo, 0, sizeof(TypesInfo));
        strcpy(TypesInfo.BasicType,szINT);
        strcpy(TypesInfo.BaseName,szINT);
        strcpy(TypesInfo.TypeName,szINT);
        TypesInfo.Size = sizeof(int);
        TypesInfo.iPackSize = sizeof(int);
    } else {
        if (IsTokenSeparator() && CurrentToken()->TokenType != TK_LPAREN) {
            //
            // Text after 'typedef' doesn't start with anything plausible.
            //
            return FALSE;
        }

        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
        ConsumeConstVolatileOpt();
        if (!GetExistingType(&TypesInfo, &bFnPtr, &pKnownTypes)) {
            return FALSE;
        }
    }

    //
    // We now know the type.  Parse new type names derived from that type.
    //
    pTypesInfo->IndLevel = TypesInfo.IndLevel;
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_CONTAINSFUNCPTR);
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_POINTERDEP);
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_UNSIGNED);
    pTypesInfo->pTypedefBase = pKnownTypes;
    strcpy(pTypesInfo->BasicType, TypesInfo.BasicType);
    strcpy(pTypesInfo->TypeName, TypesInfo.TypeName);

    if (bFnPtr) {
        //
        // The type is a pointer to a function
        //
        pTypesInfo->Flags |= BTI_CONTAINSFUNCPTR;
        strcpy(pTypesInfo->BaseName, TypesInfo.BaseName);
        strcpy(pTypesInfo->FuncRet, TypesInfo.FuncRet);
        strcpy(pTypesInfo->FuncMod, TypesInfo.FuncMod);
        pTypesInfo->Size = SIZEOFPOINTER;
        pTypesInfo->iPackSize = SIZEOFPOINTER;
        pTypesInfo->dwMemberSize = TypesInfo.dwMemberSize;
        pTypesInfo->TypeKind = TypesInfo.TypeKind;
        memcpy(pTypesInfo->Members, TypesInfo.Members, sizeof(TypesInfo.Members));
        pTypesInfo->pfuncinfo = RelocateTypesInfo(pTypesInfo->Members,
                                                  &TypesInfo);
        return TRUE;
    }

    if (CurrentToken()->TokenType == TK_EOS) {
        return FALSE;
    }

    strcpy(pTypesInfo->BaseName, TypesInfo.TypeName);
    *pTypesInfo->TypeName = '\0';

    // don't handle extraneous parens.
    i = CurrentTokenIndex;
    while (CurrentToken()->TokenType != TK_EOS) {
        if (CurrentToken()->TokenType == TK_LPAREN) {
            return FALSE;
        }
        ConsumeToken();
    }
    CurrentTokenIndex = i;

    IndLevel = pTypesInfo->IndLevel;
    Flags = pTypesInfo->Flags;

    for (;;) {
        pTypesInfo->IndLevel = IndLevel;
        pTypesInfo->iPackSize = TypesInfo.iPackSize;
        pTypesInfo->Flags = Flags;
        dwSize = TypesInfo.Size;

        //
        // Skip 'const' keyword, if present.
        //
        if (CurrentToken()->TokenType == TK_CONST) {
            ConsumeToken();
        }

        //
        // Handle pointers to the base type
        //
        if (IsTokenSeparator() &&
            CurrentToken()->TokenType != TK_STAR &&
            CurrentToken()->TokenType != TK_BITWISE_AND) {
            return FALSE;
        }
        ParseIndirection(&pTypesInfo->IndLevel,
                         &dwSize,
                         &pTypesInfo->Flags,
                         NULL,
                         NULL);

        // This is a hack for the busted way that sortpp parses
        // data.   New types do not inherit the pointer size
        // properly.   We also can't inherit it at the top
        // since this might be a pointer to a pointer.  So what
        // we do is try to parse this as a pointer, and if the IndLevel
        // increases we know this is a pointer so do nothing.  If the IndLevel
        // doesn't increase, this is not a pointer so inherite the pointer attributes
        // from the parent.

        ASSERT(pTypesInfo->IndLevel >= IndLevel);
        if (pTypesInfo->IndLevel == IndLevel) {
            // inherite is ptr64 attribute from the base type.
            pTypesInfo->Flags |= (TypesInfo.Flags & BTI_PTR64);
        }

        if (CurrentToken()->TokenType != TK_IDENTIFIER) {
            return FALSE;
        }

        //
        // Get the name of the new typedef
        //
        if (CopyToken(pTypesInfo->TypeName,
                      CurrentToken()->Name,
                      sizeof(pTypesInfo->TypeName)-1
                      )
               >= sizeof(pTypesInfo->TypeName)) {
            return FALSE;
        }
        ConsumeToken();

        //
        // Handle an array of the type
        //
        while (CurrentToken()->TokenType == TK_LSQUARE) {
            DWORD dwIndex;

            if (!GetArrayIndex(&dwIndex)) {
                return FALSE;
            }

            if (dwIndex == 0) {          // a[] is really *a
                pTypesInfo->IndLevel++;
            } else {
                pTypesInfo->Flags |= BTI_ISARRAY;
                pTypesInfo->dwArrayElements = dwIndex;
                pTypesInfo->dwBaseSize = dwSize;
                dwSize = dwSize * dwIndex;
            }
        }

        if (pTypesInfo->IndLevel) {
            if (pTypesInfo->Flags & BTI_PTR64) {
                pTypesInfo->Size = SIZEOFPOINTER64;
                pTypesInfo->iPackSize = SIZEOFPOINTER64;
            } else {
                pTypesInfo->Size = SIZEOFPOINTER;
                pTypesInfo->iPackSize = SIZEOFPOINTER;
            }
            pTypesInfo->Flags |= BTI_POINTERDEP;
        } else {
            pTypesInfo->Size = dwSize;
        }

        switch (CurrentToken()->TokenType) {
        case TK_EOS:
            return TRUE;

        case TK_COMMA:
            //
            // There is a list of types derived from the base type
            // Add the current type in and loop to parse the next
            // type.
            //
            if (!AddNewType(pTypesInfo, TypeDefsList)) {
                return FALSE;
            }

            ConsumeToken(); // consume the ','
            break;

        default:
            return FALSE;
        }

    }

}



BOOL
ParseFuncTypes(
    PTYPESINFO pTypesInfo,
    BOOL fDllImport
    )
/*++

Routine Description:

    Parses a C-language statement if it is a function declaration:

    <mod> type <*> <mod> Name ( type <arg1>, type <arg2>, type <argn> )
    <mod> type <*> (<mod> * Name ) ( type <arg1>, type <arg2>, type <argn> )
    (Note that we don't deal with extraneous parens very well, and don't
     handle function pointers as return types.
     e.g. "void (*(*foo)(void))(void);" ).

Arguments:

    pTypesInfo  -- OUT ptr to info about the type
    fDllImport  -- TRUE if __declspec(dllimport) already consumed

Return Value:

    TRUE if the statement is a function declaration
    FALSE if the statement is not a function declaration or some kind of error

--*/
{
    char *pName;
    char *ps;
    char *pArgName;
    BOOL bFnPtr = FALSE;
    ULONG ArgNum = 0;
    int  IndLevel = 0;
    int  ArgIndLevel;
    int  Len;
    TYPESINFO ti;
    PFUNCINFO pfuncinfo;
    BUFALLOCINFO bufallocinfo;
    int  OldTokenIndex;
    char NoNameArg[32];
    PKNOWNTYPES pkt;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));
    BufAllocInit(&bufallocinfo, pTypesInfo->Members, sizeof(pTypesInfo->Members), 0);
    pfuncinfo = NULL;


    if (fDllImport) {
        //
        // Declaration has __declspec(dllimport).  Genthnk should emit
        // __declspec(dllexport) in the function definition.
        //
        pTypesInfo->Flags |= BTI_DLLEXPORT;
    }

    // for functions, the first token is ret type
    if (IsTokenSeparator() && CurrentToken()->TokenType != TK_LPAREN) {
        //
        // First token isn't even an identifier - bail out.
        //
        return FALSE;
    }

    ConsumeDeclSpecOpt(TRUE, FALSE, &fDllImport, NULL, NULL);

    //
    // Remember the index of the first token which describes the return type.
    //
    OldTokenIndex = CurrentTokenIndex;

    if (CurrentToken()->TokenType == TK_LPAREN) {
        // This is this start of a typedef (pfn)()
        //  where the pfn has an implecit return type of
        // int.
        strcpy(pTypesInfo->FuncRet, "int");
        goto ImplicitReturnType;
    }

    if (ConsumeDirectionOpt() != TK_NONE && bDebug) {
         // A struct element had a direction on it.  Ignore it and
         // warn the user.
         fprintf(stderr, "Warning: IN and OUT are ignored on function return types. %s line %d\n", SourceFileName, StatementLineNumber);
    }
    ConsumeConstVolatileOpt();
    if (!GetExistingType(&ti, NULL, NULL)) {
        ErrMsg("pft.rtype: unknown return type\n");
        DumpLexerOutput(OldTokenIndex);
        return FALSE;
    }

    // get indir for ret type
    ParseIndirection(&pTypesInfo->RetIndLevel, NULL, NULL, NULL, NULL);

    // Copy out ret type to FuncRet
    if (!UnlexToText(pTypesInfo->FuncRet, sizeof(pTypesInfo->FuncRet),
                     OldTokenIndex, CurrentTokenIndex)) {
        return FALSE;
    }

    ConsumeDeclSpecOpt(TRUE, FALSE, &fDllImport, NULL, NULL);

    if (fDllImport) {
        // Declaration has __declspec(dllimport).  Genthnk should emit
        // __declspec(dllexport) in the function definition.
        //
        pTypesInfo->Flags |= BTI_DLLEXPORT;
    }


    // if open paren, assume a fn pointer
ImplicitReturnType:
    if (CurrentToken()->TokenType == TK_LPAREN) {
        bFnPtr = TRUE;
        ConsumeToken();
    }

    // include cdecl, stdcall, save as FuncMod
    switch (CurrentToken()->TokenType) {
    case TK_CDECL:
        Len = CopyToken(pTypesInfo->FuncMod, szCDECL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        break;

    case TK_FASTCALL:
        Len = CopyToken(pTypesInfo->FuncMod, sz__FASTCALL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        break;

    case TK_STDCALL:
        Len = CopyToken(pTypesInfo->FuncMod, szSTDCALL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        //
        // some funky ole include has:
        // "BOOL (__stdcall __stdcall *pfnContinue)(DWORD)"
        //
        if (CurrentToken()->TokenType == TK_STDCALL) {
            ConsumeToken();
        }
        break;

    default:
        break;
    }

    pTypesInfo->TypeKind = TypeKindFunc;
    pTypesInfo->dwMemberSize = 0;

    //
    // count indir on function
    //
    if (bFnPtr) {
        while (CurrentToken()->TokenType == TK_STAR ||
               CurrentToken()->TokenType == TK_BITWISE_AND) {
           IndLevel++;
           ConsumeToken();
        }
    }

    //
    // We expect the next token to be the func name.
    //
    if (CurrentToken()->TokenType != TK_RPAREN &&
        CurrentToken()->TokenType != TK_IDENTIFIER) {
        return FALSE;
    }

    pName = (bFnPtr && CurrentToken()->TokenType == TK_RPAREN) ? "" : CurrentToken()->Name;
    strcpy(pTypesInfo->BaseName, szFUNC);

    // look for beg of ArgList
    ConsumeToken();
    if (bFnPtr && CurrentToken()->TokenType == TK_RPAREN) {
        ConsumeToken();
    }

    if (CurrentToken()->TokenType != TK_LPAREN) {
        return FALSE;
    }
    ConsumeToken();     // consume the '('

    //
    // copy out the ArgList
    //
    while (CurrentToken()->TokenType != TK_EOS) {
        if (CurrentToken()->TokenType == TK_RPAREN) {
            break;
        }

        ArgIndLevel = 0;

        // ([mod] type [mod] [*] [mod] [ArgName] , ...)
        bFnPtr = FALSE;

        // skip register keywords all together
        if (CurrentToken()->TokenType == TK_REGISTER) {
            ConsumeToken();
        }

        //
        // Remember where we are in the parse
        //
        OldTokenIndex = CurrentTokenIndex;

        //
        // Allocate a new FUNCINFO struct for this parameter
        //
        pfuncinfo = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfo);
        if (!pTypesInfo->pfuncinfo) {
            pTypesInfo->pfuncinfo = pfuncinfo;
        }

        if (CurrentToken()->TokenType == TK_VARGS) {
            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, szVARGS);
            BufAllocate(&bufallocinfo, strlen(szVARGS)+1);
            ConsumeToken();
            break;
        }

        // grab the IN, OUT, or 'IN OUT', if present
        pfuncinfo->tkDirection = ConsumeDirectionOpt();

        pfuncinfo->tkPreMod = ConsumeConstVolatileOpt();

        if (!GetExistingType(&ti, &bFnPtr, &pkt)) {
            ErrMsg("pft.args: unknown argument type at %d\n", OldTokenIndex);
            return FALSE;
        }
        pfuncinfo->pkt = pkt;

        // enter fp member as a typedef to store args and rettype
        if (bFnPtr) {
            TYPESINFO tiTmp;

            tiTmp = ti;
            tiTmp.pfuncinfo = RelocateTypesInfo(tiTmp.Members, &ti);
            tiTmp.Flags |= BTI_CONTAINSFUNCPTR;

            Len = CreatePseudoName(tiTmp.TypeName, ti.TypeName);
            if (!Len) {
                return FALSE;
            }

            pkt = AddNewType(&tiTmp, TypeDefsList);
            if (NULL == pkt) {
                return FALSE;
            }

            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, tiTmp.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);

            pArgName = ti.TypeName;
            goto aftername;
        } else {

            DWORD Flags = 0;

            // skip indirection
            ParseIndirection(&pfuncinfo->IndLevel,
                             NULL,
                             &Flags,
                             &pfuncinfo->tkPrePostMod,
                             &pfuncinfo->tkPostMod
                             );

            if (Flags & BTI_PTR64) {
                pfuncinfo->fIsPtr64 = TRUE;
            }

            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, ti.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);

            //
            // If the type of the parameter has an explicit
            // struct/union/enum keyword, pass that info on to
            // genthnk.  ie. if the parameter type is like
            // 'struct typename argname', set tkSUE to TK_STRUCT.
            //
            if (strcmp(ti.BaseName, szSTRUCT) == 0) {
                pfuncinfo->tkSUE = TK_STRUCT;
            } else if (strcmp(ti.BaseName, szUNION) == 0) {
                pfuncinfo->tkSUE = TK_UNION;
            } else if (strcmp(ti.BaseName, szENUM) == 0) {
                pfuncinfo->tkSUE = TK_ENUM;
            } else {
                pfuncinfo->tkSUE = TK_NONE;
            }
        }

        // if no argument name present, create one
        switch (CurrentToken()->TokenType) {
        case TK_RPAREN:
        case TK_LSQUARE:
        case TK_COMMA:
            // but null arg list doesn't have any name
            if (CurrentToken()->TokenType == TK_COMMA ||
                ArgNum      ||
                ti.IndLevel ||
                pfuncinfo->IndLevel ||
                strcmp(ti.BasicType, szVOID) ) {

                pArgName = NoNameArg;
                sprintf(NoNameArg, "_noname%x", ArgNum++);
            } else {
                pArgName = NULL;
            }
            break;

        case TK_IDENTIFIER:
            pArgName = CurrentToken()->Name;
            if (ArgNum == 0 &&
                pfuncinfo->IndLevel == 1 &&
                strcmp(pArgName, "This") == 0) {
                //
                // This is the first arg and it is a pointer with name 'This'.
                // Assume it is a MIDL-generated proxy prototype.
                //
                pfuncinfo->tkDirection = TK_IN;
            }
            ConsumeToken();
            break;

        default:
            return FALSE;
        }

aftername:
        if (pArgName) {
            //
            // Copy the argument name from pArgName into pfuncinfo->sName.
            //
            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sName = ps;
            strcpy(ps, pArgName);
        }

        //
        // Handle parameter which is a single-dimension array by copying the
        // entire string from '[' to ']' (inclusive)
        // ie.  int foo(int i[3])
        //
        if (CurrentToken()->TokenType == TK_LSQUARE) {
            int OldCurrentTokenIndex = CurrentTokenIndex;
            int ArgNameLen = strlen(ps);

            do {
                ConsumeToken();
            } while (CurrentToken()->TokenType != TK_RSQUARE &&
                     CurrentToken()->TokenType != TK_EOS);

            if (CurrentToken()->TokenType == TK_EOS) {
                // Reject - unmatched '[' and ']'
                return FALSE;
            }
//            if (CurrentTokenIndex - OldCurrentTokenIndex == 1) {
                //
                // Found: empty array bounds '[]'.  Bump IndLevel and
                // don't append the '[]' to the parameter name.
                //
                pfuncinfo->IndLevel++;
//            } else if (!UnlexToText(ps + ArgNameLen,
//                                    BufGetFreeSpace(&bufallocinfo) - ArgNameLen,
//                                    OldCurrentTokenIndex,
//                                    CurrentTokenIndex+1)) {
//                ErrMsg("pft: args list too long\n");
//                return FALSE;
//            }
            ConsumeToken();
        }
        BufAllocate(&bufallocinfo, strlen(ps)+1);

        //bug bug , hack hack, danger danger
        if (CurrentToken()->TokenType == TK_ASSIGN) {
            //Header is using the C++ syntax of assigning
            //a default value to a argument.
            //This will be skipped.  Skip until a TK_COMMA, TK_EOS, TK_RPAREN
            ConsumeToken();

            while(CurrentToken()->TokenType != TK_COMMA &&
                  CurrentToken()->TokenType != TK_EOS &&
                  CurrentToken()->TokenType != TK_RPAREN) {
                    ConsumeToken();
            }
        }

        if (CurrentToken()->TokenType == TK_RPAREN) {
            break;
        } else {  // more args to go, add comma delimiter
            ConsumeToken();
        }
    }

    if (CurrentToken()->TokenType != TK_RPAREN) {
        ErrMsg("pft: unknown syntax for fn args\n");
        return FALSE;
    }

    ConsumeToken(); // consume the ')'

    pTypesInfo->IndLevel = IndLevel;
    pTypesInfo->Size = 4;
    pTypesInfo->iPackSize = 4;
    strcpy(pTypesInfo->BasicType, szFUNC);
    if (CopyToken(pTypesInfo->TypeName,
                  pName,
                  sizeof(pTypesInfo->TypeName)-1
                  )
           >= sizeof(pTypesInfo->TypeName) ) {
       return FALSE;
    }
    if (pfuncinfo == NULL) {
        //
        // No args encountered - create VOID args now
        //
        pfuncinfo = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfo);
        ps = BufPointer(&bufallocinfo);
        strcpy(ps, szVOID);
        pfuncinfo->sType = ps;
        BufAllocate(&bufallocinfo, strlen(ps)+1);
        pTypesInfo->pfuncinfo = pfuncinfo;
    }
    pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

    return TRUE;
}

BOOL
ParseStructTypes(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Parses a C-language statement if it is struct/union/enum declaration.

    struct|union|enum NewName <{}>
    struct NewName : <permission> BaseName <{}>
 (Note that we don't deal with extraneous parens very well)


Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the statement is a struct/union/enum
    FALSE if the statement is not a s/u/e, or some other error

--*/
{
    TOKENTYPE FirstToken;
    BOOL bEnum = FALSE;
    BOOL bUnion = FALSE;
    DWORD dwOldScopeLevel = dwScopeLevel;
    BOOL IsGuidDefined = FALSE;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));

    //
    // Match one of: STRUCT, UNION, or ENUM
    //
    FirstToken = CurrentToken()->TokenType;
    switch (FirstToken) {
    case TK_STRUCT:
        break;

    case TK_UNION:
        bUnion = TRUE;
        break;

    case TK_ENUM:
        bEnum = TRUE;
        break;

    default:
        goto retfail;   // no match
    }
    ConsumeToken();

    // BasicType is "struct", "union", or "enum"
    if (CopyToken(pTypesInfo->BasicType,
                  TokenString[FirstToken],
                  sizeof(pTypesInfo->BasicType)-1
                  )
            >= sizeof(pTypesInfo->BasicType) ) {
        goto retfail;
    }
    strcpy(pTypesInfo->BaseName, pTypesInfo->BasicType);

    //handle declspecs
    if (!bUnion && !bEnum) {
        while(ConsumeDeclSpecOpt(FALSE, FALSE, NULL, &IsGuidDefined, &(pTypesInfo->gGuid)));
        if (IsGuidDefined) pTypesInfo->Flags |= BTI_HASGUID;
    }

    switch (CurrentToken()->TokenType) {
    case TK_IDENTIFIER:
        {
            if (CopyToken(pTypesInfo->TypeName,
                CurrentToken()->Name,
                sizeof(pTypesInfo->BasicType)-1
                )
                >= sizeof(pTypesInfo->BasicType) ) {
                goto retfail;
            }
            ConsumeToken();
            break;
        }

    case TK_LBRACE:         // anonymous struct/union/enum
        if (!CreatePseudoName(pTypesInfo->TypeName, TokenString[FirstToken])) {
            //
            // call failed - probably buffer overflow
            //
            goto retfail;
        }
        pTypesInfo->Flags |= BTI_ANONYMOUS;
        break;

    default:
        //
        // STRUCT/UNION/ENUM followed by something other than an identifier
        // or a '{'.
        //
        goto retfail;
    }

    //
    // Process the contents of the curly braces, if present.
    //
    switch (CurrentToken()->TokenType) {
    case TK_EOS:
        goto retsuccess;

    case TK_LBRACE:
        {
            if (bEnum) {
                if(CopyEnumMembers(pTypesInfo)) goto retsuccess;
                else goto retfail;
            }
            if(CopyStructMembers(pTypesInfo, bUnion, NULL)) goto retsuccess;
            else goto retfail;

        }
    case TK_COLON: //entering a derived struct
        if (bEnum || bUnion) goto retfail;
        ConsumeToken();
        //look for base skipping public, private, and protected
        {
            PTOKEN pToken;
            BOOL bRetVal;
            PTYPEINFOELEMENT pMemFuncs;
            PKNOWNTYPES BaseType;

            pToken = CurrentToken();

            if (pToken->TokenType != TK_IDENTIFIER) goto retfail;
            if (strcmp(pToken->Name, "public") == 0 ||
                strcmp(pToken->Name, "private") == 0 ||
                strcmp(pToken->Name, "protected") == 0) {
                ConsumeToken();
            }
            //look for base
            if (CopyToken(pTypesInfo->BaseType,
                CurrentToken()->Name,
                sizeof(pTypesInfo->BasicType)-1
                )
                >= sizeof(pTypesInfo->BasicType) ) {
                goto retfail;
            }

            //lookup the base in structures
            BaseType = GetNameFromTypesList(StructsList,pTypesInfo->BaseType);
            if (NULL == BaseType) {
                //ErrMsg("Base type is unknown or not a structure\n");
                goto retfail;
            }

            //look for opening brace or EOS
            ConsumeToken();
            if (CurrentToken()->TokenType == TK_EOS) goto retsuccess;
            if (CurrentToken()->TokenType != TK_LBRACE) goto retfail;
            if (CopyStructMembers(pTypesInfo, FALSE, BaseType)) goto retsuccess;
            else goto retfail;
        }

    default:
        break;
    }

    goto retsuccess;
retfail:
    dwScopeLevel = dwOldScopeLevel;
    return FALSE;
retsuccess:
    dwScopeLevel = dwOldScopeLevel;
    return TRUE;
}

BOOL
CopyEnumMembers(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Scans over members of an enumeration declaration.  Nobody cares
    about the actual names and values, so they are simply skipped over
    until the matching '}' is found.

Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the declaration is parsed OK
    FALSE if the statement is mis-parsed, or some other error

--*/
{
    DWORD *pdwSize = &(pTypesInfo->Size);
    DWORD *pdwPackSize = &(pTypesInfo->iPackSize);
    dwScopeLevel++;

    if (CurrentToken()->TokenType != TK_LBRACE) {
        return FALSE;
    } else {
        ConsumeToken();
    }

    //
    // Find the '}' which ends the enumeration declaration
    //
    while (CurrentToken()->TokenType != TK_RBRACE) {
        ConsumeToken();
    }
    ConsumeToken(); // consume the '}', too

    *pdwSize = sizeof(int);     // enum
    *pdwPackSize = sizeof(int); // enum

    return TRUE;
}


// How sortpp computes packing sizes:
//
// * Each member has a packing size which is
//    - size of a appropriate pointer if member is a pointer
//    - packing size of its base type
// * The packing size of struc or union is min(packing_size_of_largest_member,
//   current_packing_size_when_struct_defined)
// * Each member in a struct is aligned according to min(current_packing_size,
//   member_packing_size).
// * All pointers have size sizeof(void *) except __ptr64 pointers which
//   have a size sizeof(PVOID64)
// * bit fields are coallessed until
//   - the end of the struct
//   - a non bit field member
//   - a bit field member, but of different base type size
// * char s[] as the last member of a struct adds nothing to the size of the
//   struct and should not be aligned.
// * each member of a union is packed at offset 0.


BOOL
pCopyStructMembers(
    PTYPESINFO pTypesInfo,
    BOOL bUnion,
    PTYPEINFOELEMENT * ppMemberFuncs,
    DWORD Size,
    DWORD iPackSize
    )
/*++

Routine Description:

    Copies out struct members, verifying type of each member.

    { [mod] type [*] varname; [mod] type [*] varname; ...}
    { {varname, varname, ...}

    Assumes CurrentToken points at the '{' for the member list.
    Also determines the size of the struct/union.

Arguments:

    pTypesInfo  -- OUT ptr to info about the type
    bUnion      -- TRUE if parsing union, FALSE if parsing STRUCT.
    ppMemberFuncs -- OUT returns a list of virtual member functions or NULL.

Return Value:

    TRUE if the declaration is parsed OK
    FALSE if the statement is mis-parsed, or some other error

--*/
{
    char *psMemBuf = pTypesInfo->Members;
    DWORD *pdwSize = &(pTypesInfo->Size);
    DWORD *pdwPackSize = &(pTypesInfo->iPackSize);
    int Len;
    BOOL bFnPtr;
    TYPESINFO ti;
    DWORD dw;
    DWORD dwBase;                   // running size of struct element
    DWORD dwElemSize;               // size of a particular element
    DWORD dwBaseTypeSize;           // size of basic type of element
    DWORD dwBits;                   // # bits in a bitfield element
    DWORD dwBitsTotal;              // running # bits for string of elemnts
    DWORD dwBitsTypeSize;           // bit fields base type size
    BOOL bForceOutBits = FALSE;
    BOOL bTailPointer = FALSE;
    DWORD dwLastPackSize = 0;
    DWORD dwLastSize = 0;
    PMEMBERINFO pmeminfo;
    BUFALLOCINFO bufallocinfo;
    char *ps;
    DWORD Flags;
    DWORD dwIndex;
    int ParenDepth = 0;

    PTYPEINFOELEMENT pMethods = NULL;
    DWORD dwMethodNumber = 0;

    PKNOWNTYPES pkt;

    if (ppMemberFuncs != NULL) *ppMemberFuncs = NULL;

    *pdwSize = Size;                  // initialize size of structure
    *pdwPackSize = iPackSize;              // initialize packing alignment
    dwLastSize = Size;
    dwLastPackSize = iPackSize;

    BufAllocInit(&bufallocinfo, psMemBuf, sizeof(pTypesInfo->Members), 0);
    pmeminfo = NULL;

    pTypesInfo->TypeKind = TypeKindStruct;
    pTypesInfo->dwMemberSize = 0;
    bFnPtr = FALSE;

    // loop over members of the structure or union

    dwBitsTotal = 0;
    dwBitsTypeSize = 0;

    if (CurrentToken()->TokenType != TK_LBRACE) {
        return FALSE;
    }
    ConsumeToken();

    while (CurrentToken()->TokenType != TK_RBRACE) {
        int OldCurrentTokenIndex = CurrentTokenIndex;

        if (bDebug)
            DumpLexerOutput(CurrentTokenIndex);

        //strip off permission attributes
        //{public private protected} :
        while(CurrentToken()->TokenType == TK_IDENTIFIER &&
                (strcmp(CurrentToken()->Name, "public") == 0 ||
                 strcmp(CurrentToken()->Name, "private") == 0 ||
                 strcmp(CurrentToken()->Name, "protected") == 0
                 ))
        {
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_COLON) return FALSE;
            ConsumeToken();

            if (CurrentToken()->TokenType == TK_RBRACE) goto done;
        }

        if (!bUnion &&
            ppMemberFuncs != NULL &&
            CurrentToken()->TokenType == TK_IDENTIFIER &&
            strcmp(CurrentToken()->Name, "virtual") == 0) {

            PTYPESINFO pFuncInfo;
            int TokenNumber = CurrentTokenIndex;
            ConsumeConstVolatileOpt();

            pFuncInfo = GenHeapAlloc(sizeof(TYPESINFO));
            if (pFuncInfo == NULL) ExitErrMsg(FALSE, "Out of memory!\n");
            ConsumeToken();

            //virtual method
            if (!ParseFuncTypes(pFuncInfo, FALSE)) {
                ErrMsg("Unable to parse method %u of %s\n", dwMethodNumber, pTypesInfo->TypeName);
                DumpLexerOutput(TokenNumber);
                return FALSE;
            }

            pMethods = TypeInfoElementAllocateLink(ppMemberFuncs, pMethods, pFuncInfo);

            //remove extra ;
            if (CurrentToken()->TokenType == TK_SEMI)
                ConsumeToken();
            //remove extra = 0;
            else if (CurrentToken()->TokenType == TK_ASSIGN) {
                ConsumeToken();
                //parsing 0;
                if (!(CurrentToken()->TokenType == TK_NUMBER &&
                    CurrentToken()->Value == 0)) return FALSE;
                ConsumeToken();
                //parsing ;
                if (CurrentToken()->TokenType != TK_SEMI) return FALSE;
                ConsumeToken();
            }
            else return FALSE; //fail

            dwMethodNumber++;
            continue;
        }


        if (ConsumeDirectionOpt() != TK_NONE && bDebug) {
            // A struct element had a direction on it.  Ignore it and
            // warn the user.
            fprintf(stderr, "Warning: IN and OUT are ignored on struct members. %s line %d\n", SourceFileName, StatementLineNumber);
        }

        ConsumeConstVolatileOpt();

        pmeminfo = AllocMemInfoAndLink(&bufallocinfo, pmeminfo);
        if (pmeminfo == NULL) {
            ErrMsg("CopyStructMembers: No memberinfo\n");
            return FALSE;
        }

        if (!GetExistingType(&ti, &bFnPtr, &pkt)) {
            ErrMsg("csm: unknown Type %d\n", OldCurrentTokenIndex);
            return FALSE;
        }
        pmeminfo->pkt = pkt;

        // enter function pointer member as a typedef to store args, rettype
        if (bFnPtr) {
            TYPESINFO tiTmp;

            ti.Flags |= BTI_CONTAINSFUNCPTR;
            tiTmp = ti;
            tiTmp.pfuncinfo = RelocateTypesInfo(tiTmp.Members, &ti);

            Len = CreatePseudoName(tiTmp.TypeName, ti.TypeName);
            if (!Len) {
                return FALSE;
            }
            tiTmp.Size = ti.Size;
            tiTmp.iPackSize = ti.iPackSize;

            pkt = AddNewType(&tiTmp, TypeDefsList);
            if (NULL == pkt) {
                return FALSE;
            }
            ps = BufPointer(&bufallocinfo);
            pmeminfo->sName = ps;
            strcpy(ps, ti.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);
            pmeminfo->pkt = pkt;
        }
        /*else {
            ////////////////////////////////////////////////////////////////
            //This type has no members for it, do no process further.
            /////////////////////////////////////////////////////////////////
            if (CurrentToken()->TokenType == TK_SEMI) {
                ConsumeToken();
                continue;
            }
        }*/
        //
        // If the member contains a function pointer, then mark
        // this struct has containing a function pointer
        // Also mark if member is pointer dependent.

        pTypesInfo->Flags |= ((ti.Flags & BTI_CONTAINSFUNCPTR) | (ti.Flags & BTI_POINTERDEP));

        //
        // Union arm initialization
        dwBaseTypeSize = ti.iPackSize;

        if ((dwBitsTotal > 0) && (dwBaseTypeSize != dwBitsTypeSize)) {
            //
            // Determine size of bitfields
            //
            dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) / (dwBitsTypeSize*8);
            *pdwSize = *pdwSize + PackPackingSize(bUnion ? 0 : *pdwSize,
                                                  dw*dwBitsTypeSize,
                                                  dwBitsTypeSize);
            dwBitsTotal = 0;
        }
        dwBitsTypeSize = dwBaseTypeSize;

        // element initialization
        dwBase = ti.Size;
        dwBits = 0;

        bTailPointer = FALSE;

        pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);

        //
        // Copy in the typename
        //
        ps = BufPointer(&bufallocinfo);
        pmeminfo->sType = ps;
        strcpy(ps, ti.TypeName);
        BufAllocate(&bufallocinfo, strlen(ps)+1);

        //
        // Skip just past the terminating ';' for this member and
        // figure out any size modifers to size of the base type.
        //
        while (CurrentToken()->TokenType != TK_SEMI) {

            PMEMBERINFO pmeminfoNew;

            switch (CurrentToken()->TokenType) {
            case TK_CONST:
            case TK_VOLATILE:
                ConsumeToken();
                break;

            case TK_COMMA:  // comma-separated list

                // update structure packing value
                if (dwBaseTypeSize > *pdwPackSize) {
                    *pdwPackSize = dwBaseTypeSize;
                }

                // flush out any bit fields not accounted for
                if ((dwBitsTotal > 0) && (dwBits == 0)) {
                    dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) /
                                                        (dwBitsTypeSize*8);
                    dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                    dw*dwBitsTypeSize, dwBitsTypeSize);
                    BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
                    dwBitsTotal = 0;
                    // recompute offset
                    pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                }

                // account for member just completed
                if (dwBits == 0) {
                    dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                                             dwBase,
                                                             dwBaseTypeSize);
                    BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
                    dwBase = dwBaseTypeSize;
                }

                // update bit field count
                dwBitsTotal = dwBitsTotal + dwBits;
                dwBits = 0;

                // reset tail pointer flag
                bTailPointer = FALSE;

                // allocate space for new structure member and init it
                pmeminfoNew = AllocMemInfoAndLink(&bufallocinfo, pmeminfo);
                if (pmeminfoNew == NULL) {
                    ErrMsg("CopyStructMembers: No memberinfo\n");
                    return FALSE;
                    }

                // Copy over type information from previous meminfo.
                pmeminfoNew->sType = pmeminfo->sType;
                pmeminfoNew->pkt = pmeminfo->pkt;
                pmeminfo = pmeminfoNew;

                pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                ConsumeToken();
                break;

            case TK_STAR:
            case TK_BITWISE_AND:
                Flags = 0;
                ParseIndirection(&pmeminfo->IndLevel, NULL, &Flags, NULL, NULL);
                if (Flags & BTI_PTR64) {
                    pmeminfo->bIsPtr64 = TRUE;
                    dwBase = SIZEOFPOINTER64;
                } else {
                    dwBase = SIZEOFPOINTER;
                }
                //  If a pointer is present, mark as being pointer dependent.
                if (pmeminfo->IndLevel > 0) pTypesInfo->Flags |= BTI_POINTERDEP;
                dwBaseTypeSize = dwBase;
                if (*pdwPackSize < dwBase) {
                    *pdwPackSize = dwBase;
                }
                pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                break;

            case TK_LSQUARE:    // array declaration

                if (!GetArrayIndex(&dwIndex)) {
                    return FALSE;
                }
                if (dwIndex == 0) {          // a[] is really *a
                    bTailPointer = TRUE;
                    dwLastPackSize = *pdwPackSize;
                    dwLastSize = *pdwSize;
                    dwBase = SIZEOFPOINTER;
                    dwBaseTypeSize = SIZEOFPOINTER;
                    pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                } else {
                    pmeminfo->bIsArray = TRUE;
                    pmeminfo->ArrayElements = dwIndex;
                    dwBase = dwBase * dwIndex;
                }
                break;

            case TK_COLON:          // bit field
                ConsumeToken();     // consume the ':'

                if (CurrentToken()->TokenType != TK_NUMBER) {
                    return FALSE;
                }

                dwBits = (DWORD)CurrentToken()->Value;
                ConsumeToken(); // consume the TK_NUMBER
                pmeminfo->bIsBitfield = TRUE;
                pmeminfo->BitsRequired = (int)dwBits;
                break;

            case TK_IDENTIFIER:
                ps = BufPointer(&bufallocinfo);
                pmeminfo->sName = ps;
                CopyToken(ps, CurrentToken()->Name, MAX_PATH);

                if (!BufAllocate(&bufallocinfo, strlen(ps)+1)) {
                    ErrMsg("csm.members: BufAllocate failed\n");
                    return FALSE;
                }
                ConsumeToken();
                break;

            case TK_LPAREN:
                //
                // windows\inc\wingdip.h has a type named GDICALL, which
                // has a member in it with the following declaration:
                //      WCHAR (*pDest)[MAX_PATH];
                // We are just going to skip the parens and assume all is OK.
                //
                ParenDepth++;
                ConsumeToken();
                break;

            case TK_RPAREN:
                ParenDepth--;
                ConsumeToken();
                break;

            default:
                ErrMsg("csm.members: unknown type (%d)\n", (int)CurrentToken()->TokenType);
                return FALSE;
            }

        }

        // hit ; at end of a members list
        if (ParenDepth) {
            ErrMsg("csm.members: mismatched parentheses at index %d\n", CurrentTokenIndex);
            return FALSE;
        }

        // update struct packing size to that of largest member
        if (dwBaseTypeSize > *pdwPackSize) {
            *pdwPackSize = dwBaseTypeSize;
        }

        ConsumeToken(); // consume the ';'

        if ((bUnion) || (CurrentToken()->TokenType == TK_SEMI)) {
            dwBitsTotal = dwBitsTotal + dwBits;
            bForceOutBits = TRUE;
                                       // always force out bits in union arm
        }                              // or at end of structure

        // flush out any bit fields not accounted for
        if ( (dwBitsTotal > 0) && ( (dwBits == 0) || bForceOutBits) ) {
            dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) / (dwBitsTypeSize*8);
            dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                          dw*dwBitsTypeSize, dwBitsTypeSize);
            BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
            dwBitsTotal = 0;
            // recompute offset
            pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
            }

        // account for member just completed
        if (dwBits == 0) {                    // add in last non bit fields
            dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                          dwBase, dwBaseTypeSize);
            BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
        }

        // update bit field counter
        dwBitsTotal = dwBitsTotal + dwBits;
        dwBits = 0;

    }

done:
    // Advance past the '}'
    if ((CurrentToken()->TokenType == TK_RBRACE)) {
        ConsumeToken();
    }

    // if last member was something like foo[] then we roll back the size
    if ((bTailPointer) && (*pdwSize != 4)) {
        *pdwSize = dwLastSize;
        *pdwPackSize = dwLastPackSize;
        pmeminfo->dwOffset = dwLastSize;
    }

    // pack overall structure on it packing size
    dwBaseTypeSize = PackCurrentPacking() < *pdwPackSize ?
                                  PackCurrentPacking() : *pdwPackSize;
    if (*pdwSize != 0) {         // round up to min(packing level,4)
        dwBase = *pdwSize % dwBaseTypeSize;
        if (dwBase != 0) {
            *pdwSize = *pdwSize + (dwBaseTypeSize - dwBase);
        }
    }

    *pdwPackSize = dwBaseTypeSize;
    pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

    return TRUE;
}

PMEMBERINFO
CatMeminfo(
    BUFALLOCINFO *pBufallocinfo,
    PMEMBERINFO pHead,
    PMEMBERINFO pTail,
    DWORD dwOffset,
    BOOL bStatus
    )
{

/*++

Routine Description:

    Concatinates the member info lists pointed to by pHead and pTail and
    copies them to the memory controled by the BUFALLOCINFO.  dwOffset is
    added to the offset for each of the members of the tail list.

Arguments:

    pBufallocinfo    -- [IN] ptr to buffer that represents the destination.
    pHead            -- [IN] ptr to the head list.
    pTail            -- [IN] ptr to the tail list.
    dwOffset         -- [IN] amount to add to the offset of elements in the tail.
    bStatus          -- [IN] Should be FALSE on initial call.

Return Value:

    Head of the new list.

--*/

    PMEMBERINFO pThis;
    char *pName, *pType;

    if (!bStatus && NULL == pHead) {
        pHead = pTail;
        bStatus = TRUE;
    }

    if (NULL == pHead) return NULL;

    pThis = (PMEMBERINFO)BufAllocate(pBufallocinfo, sizeof(MEMBERINFO));
    if (NULL == pThis) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);
    *pThis = *pHead;

    if (pHead->sName != NULL) {
        pName = (char *)BufAllocate(pBufallocinfo, strlen(pHead->sName) + 1);
        if (NULL == pName) ExitErrMsg(FALSE, "Out of buffer memory! %d %s", __LINE__, pHead->sName);
        pThis->sName = strcpy(pName, pHead->sName);
    }

    if (pHead->sType != NULL) {
        pType = (char *)BufAllocate(pBufallocinfo, strlen(pHead->sType) + 1);
        if (NULL == pType) ExitErrMsg(FALSE, "Out of buffer memory! %d %s", __LINE__, pHead->sType);
        pThis->sType = strcpy(pType, pHead->sType);
    }

    if (bStatus) pThis->dwOffset += dwOffset;
    pThis->pmeminfoNext = CatMeminfo(pBufallocinfo, pHead->pmeminfoNext, pTail, dwOffset, bStatus);

    return pThis;
}

VOID
FreeTypeInfoList(
    PTYPEINFOELEMENT pThis
    )
{
/*++

Routine Description:

    Frees the memory associated with a TYPEINFOELEMENT.

Arguments:

    pThis        -- [IN] ptr to the list to free.

Return Value:

    None.

--*/

    PTYPEINFOELEMENT pNext;

    while(NULL != pThis) {
        pNext = pThis->pNext;
        if (pThis->pTypeInfo != NULL) GenHeapFree(pThis->pTypeInfo);
        GenHeapFree(pThis);
        pThis = pNext;
    }
}

VOID
GenerateProxy(
    char *pName,
    PTYPESINFO pTypesInfo
    )
{

/*++

Routine Description:

    Generates proxy infomation for functions in a struct with virtual methods.
    The infomation is of the form structname_functionname_Proxy.
    The function is added to the functions list if not already in the list.
    The discardable flag is set so that this type will be redefined in refound in the code.

Arguments:

    pName        -- [IN] ptr to the name of the struct that the method is in.
    pTypesInfo   -- [IN] Information for the function.

Return Value:

    None.

--*/

    TYPESINFO NewTypesInfo;
    PFUNCINFO pFuncInfo;
    PFUNCINFO *ppFuncInfo;
    PFUNCINFO pCurrent;
    BUFALLOCINFO bufallocinfo;
    char *pChar;
    DWORD dwSizeArgName, dwSizeTypeName;

    // Bail out if not func, no struct name, or no class name
    if (pName == NULL || pTypesInfo->TypeName == NULL) return;
    if (pTypesInfo->TypeKind != TypeKindFunc ||
        strlen(pName) == 0 ||
        strlen(pTypesInfo->TypeName) == 0) return;

    NewTypesInfo = *pTypesInfo;
    strcpy(NewTypesInfo.TypeName, pName);
    strcat(NewTypesInfo.TypeName, "_");
    strcat(NewTypesInfo.TypeName, pTypesInfo->TypeName);
    strcat(NewTypesInfo.TypeName, "_Proxy");

    /////////////////////////////////////////////////////////////////
    //Check if the function has already been added.
    //If it has, no more work is needed.
    /////////////////////////////////////////////////////////////////
    if (GetNameFromTypesList(FuncsList, NewTypesInfo.TypeName) != NULL)
        return;

    ////////////////////////////////////////////////////////////////////
    //Copy function members adding a this pointer at head
    //and skipping void arguments.
    ////////////////////////////////////////////////////////////////////
    BufAllocInit(&bufallocinfo, NewTypesInfo.Members, FUNCMEMBERSIZE, 0);
    dwSizeTypeName = strlen(pName) + 1;
    dwSizeArgName = strlen(szThis) + 1;
    pFuncInfo = (PFUNCINFO)BufAllocate(&bufallocinfo, sizeof(FUNCINFO) + dwSizeArgName + dwSizeTypeName);
    if (NULL == pFuncInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

    pFuncInfo->fIsPtr64 = FALSE;
    pFuncInfo->tkDirection = TK_IN;
    pFuncInfo->tkPreMod = TK_NONE;
    pFuncInfo->tkSUE = TK_NONE;
    pFuncInfo->tkPrePostMod = TK_NONE;
    pFuncInfo->IndLevel = 1;
    pFuncInfo->tkPostMod = TK_NONE;
    pChar = ((char *)pFuncInfo) + sizeof(FUNCINFO);
    strcpy(pChar, pName);
    pFuncInfo->sType = pChar;
    pChar += dwSizeTypeName;
    strcpy(pChar, szThis);
    pFuncInfo->sName = pChar;
    pFuncInfo->pfuncinfoNext = NULL;
    NewTypesInfo.pfuncinfo = pFuncInfo;
    ppFuncInfo = &(pFuncInfo->pfuncinfoNext);

    //skip an argument of type void if it is at the begining.
    //This is needed since ParseFuncTypes puts a void arg if the
    //func does not have any arguments
    pCurrent = pTypesInfo->pfuncinfo;
    if (pCurrent != NULL &&
        strcmp(szVOID, pCurrent->sType) == 0
        && pCurrent->IndLevel == 0) {
        pCurrent = pCurrent->pfuncinfoNext;
    }

    for(; pCurrent != NULL; pCurrent=pCurrent->pfuncinfoNext) {

        dwSizeTypeName = strlen(pCurrent->sType) + 1;
        dwSizeArgName = strlen(pCurrent->sName) + 1;
        pFuncInfo = (PFUNCINFO)BufAllocate(&bufallocinfo, sizeof(FUNCINFO) + dwSizeArgName + dwSizeTypeName);
        if (NULL == pFuncInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

        *pFuncInfo = *pCurrent;
        pChar = ((char *)pFuncInfo) + sizeof(FUNCINFO);
        strcpy(pChar, pCurrent->sType);
        pFuncInfo->sType = pChar;
        pChar += dwSizeTypeName;
        strcpy(pChar, pCurrent->sName);
        pFuncInfo->sName = pChar;
        pFuncInfo->pfuncinfoNext = NULL;
        *ppFuncInfo = pFuncInfo;
        ppFuncInfo = &(pFuncInfo->pfuncinfoNext);

    }

    NewTypesInfo.Flags |= BTI_DISCARDABLE;
    NewTypesInfo.dwMemberSize = bufallocinfo.dwLen;
    if (!AddNewType(&NewTypesInfo, FuncsList))
        ExitErrMsg(FALSE, "Unable to add proxy information.(Type was not in list)\n");

}

BOOL
CopyStructMembers(
    PTYPESINFO pTypesInfo,
    BOOL bUnion,
    PKNOWNTYPES pBaseType
    )
{

/*++

Routine Description:

    Parses the members of the structure and adds them to the pTypesInfo.
    Handles merging of members and methods when the structure is derived
    from another structure.  Delegates actual parsing to pCopyStructMembers.

Arguments:

    pTypesInfo   -- [IN OUT] ptr to infomation for the type being processed.
    dwElemSize   -- [IN] TRUE if processing a union, FALSE if a struct.
    bUnion       -- [IN] ptr to KNOWNTYPE of base structure or NULL.

Return Value:

    TRUE - If success.

--*/

    PTYPEINFOELEMENT pMemberFuncs = NULL;
    char *VTBLFakeMember;
    PMEMBERINFO pHead = NULL; //Head in final merge
    PMEMBERINFO pTail = NULL; //Tail in final merge
    DWORD dwiPackSize; //For tail
    DWORD dwSize; //For tail
    DWORD dwOffset; //For tail
    BUFALLOCINFO bufallocinfo;


    dwScopeLevel++;

    /////////////////////////////////////////////////////////////////
    //Add a discardable version of this struct if one doesn't exist
    /////////////////////////////////////////////////////////////////
    if (GetNameFromTypesList(StructsList, pTypesInfo->TypeName) == NULL) {
        TYPESINFO TTypesInfo;
        TTypesInfo = *pTypesInfo;
        TTypesInfo.Flags |= BTI_DISCARDABLE;
        AddNewType(&TTypesInfo, StructsList); //intentionally do not check
    }

    if(bUnion) return pCopyStructMembers(pTypesInfo, bUnion, NULL, 0, 0);

    if (pBaseType == NULL) {
        if (!pCopyStructMembers(pTypesInfo, FALSE, &pMemberFuncs, 0, 0)) {
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }
        if (pMemberFuncs!=NULL && pTypesInfo->Size > 0) {
            ErrMsg("Error: struct %s mixes data members and virtual functions(sortpp limitation).\n", pTypesInfo->TypeName);
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }

        pTypesInfo->dwVTBLSize = 0;
        pTypesInfo->dwVTBLOffset = 0;

        if (pMemberFuncs != NULL) {


            PTYPEINFOELEMENT pThisElement;
            DWORD dwElements = 0;
            DWORD dwLength, dwVoidLen, dwVTBLLen;
            PMEMBERINFO pMemberInfo;
            char *pName;

            ///////////////////////////////////////////////////////////////////////////
            //Build the fake VTBL pointer
            /////////////////////////////////////////////////////////////////////////////

            //Add the VTBL member
            dwVoidLen = strlen(szVOID) + 1;
            dwVTBLLen = strlen(szVTBL) + 1;

            memset(pTypesInfo->Members, 0, FUNCMEMBERSIZE);
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            pMemberInfo = (PMEMBERINFO)BufAllocate(&bufallocinfo, sizeof(MEMBERINFO) + dwVoidLen + dwVTBLLen);
            if (NULL == pMemberInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

            pName = ((char *)pMemberInfo) + sizeof(MEMBERINFO);
            strcpy(pName, szVTBL);
            pMemberInfo->sName = pName;

            pName += dwVTBLLen;
            strcpy(pName, szVOID);
            pMemberInfo->sType = pName;

            pMemberInfo->pmeminfoNext = NULL;
            pMemberInfo->dwOffset = 0;
            pMemberInfo->IndLevel = 1;
            pMemberInfo->pktCache = 0;

            pTypesInfo->iPackSize = PackCurrentPacking() < SIZEOFPOINTER ?
                                      PackCurrentPacking() : SIZEOFPOINTER;
            pTypesInfo->Size = SIZEOFPOINTER;
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;
            pTypesInfo->Flags |= BTI_VIRTUALONLY;

            ///////////////////////////////////////////////////////////////////////////////
            //Build the list of functions in the VTBL
            ///////////////////////////////////////////////////////////////////////////////

            //copy methods over to Methods and IMethods
            for(pThisElement = pMemberFuncs; pThisElement != NULL; pThisElement = pThisElement->pNext) {
                if(pThisElement->pTypeInfo != NULL) {
                    if(!AppendToMultiSz(pTypesInfo->Methods, pThisElement->pTypeInfo->TypeName, MEMBERMETHODSSIZE) ||
                        !AppendToMultiSz(pTypesInfo->IMethods, pThisElement->pTypeInfo->TypeName, MEMBERMETHODSSIZE)) {
                        ExitErrMsg(FALSE,"Too many methods in %s\n", pTypesInfo->TypeName);
                    }
                    GenerateProxy(pTypesInfo->TypeName, pThisElement->pTypeInfo);
                    dwElements++;
                }
            }

            pTypesInfo->dwVTBLSize = dwElements;
            pTypesInfo->dwVTBLOffset = 0;

            //If this is IUnknown, it is a COM object
            if (strcmp("IUnknown", pTypesInfo->TypeName) == 0)
                pTypesInfo->Flags |= BTI_ISCOM;

        }

    }

    else {

        if(!pCopyStructMembers(pTypesInfo, FALSE, &pMemberFuncs, pBaseType->Size, pBaseType->iPackSize)) {
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }
        // This checks that structures with data member are not mixed with structures with virtual methods.
        // This is a sortpp limitation that makes computing the packing size during inheritance easier.
        // The if statement say that a valid inheritance is either.
        // 1. The derived class does not add new virtual methods or data members.
        // 2. The derived class does not add new virtual methods, adds no new data members, and it inherites from a class with no virtual functions.
        // 3. The derived class adds virtual functions, adds no new data members, and the base class has no data members.
        if (!((pMemberFuncs == NULL && pTypesInfo->dwMemberSize == 0) ||
              (pMemberFuncs == NULL && pTypesInfo->dwMemberSize > 0 && pBaseType->dwVTBLSize == 0) ||
              (pMemberFuncs != NULL && pTypesInfo->dwMemberSize == 0 && pBaseType->SizeMembers == 0)
             )) {
            ErrMsg("Error: struct %s mixes data members and virtual functions(sortpp limitation).\n", pTypesInfo->TypeName);
            ErrMsg("pMemberFuncs %p\n pTypesInfo->dwMemberSize %x\n pBaseType->Flags %x\n pBaseType->pmeminfo %p\n",
                    pMemberFuncs,
                    pTypesInfo->dwMemberSize,
                    pBaseType->Flags,
                    pBaseType->pmeminfo);
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }

        pTypesInfo->dwVTBLSize = pTypesInfo->dwVTBLOffset = pBaseType->dwVTBLSize;
        pTypesInfo->Flags |= (pBaseType->Flags & ~BTI_HASGUID);
        if(pMemberFuncs == NULL) {

            char *Members;
            PMEMBERINFO pHead, pTail, pTemp;

            if (pBaseType->pmeminfo != NULL)
                pHead = (PMEMBERINFO)pBaseType->pmeminfo;
            else
                pHead = NULL;

            if (pTypesInfo->dwMemberSize > 0)
                pTail = (PMEMBERINFO)pTypesInfo->Members;
            else
                pTail = NULL;

            /////////////////////////////////////////////////////////////////////////////
            //Allocate memory for the temp array
            /////////////////////////////////////////////////////////////////////////////
            Members = GenHeapAlloc(FUNCMEMBERSIZE);

            if (Members == NULL)
                ExitErrMsg(FALSE, "Out of memory!\n");

            /////////////////////////////////////////////////////////////////////////////
            //merge members lists with basetype
            /////////////////////////////////////////////////////////////////////////////

            //copy the concatination of the two to the temp buffer
            BufAllocInit(&bufallocinfo, Members, FUNCMEMBERSIZE, 0);
            pTemp = CatMeminfo(&bufallocinfo, pHead, pTail, 0, FALSE);

            ////////////////////////////////////////////////////////////////////////
            //copy members from temp buffers back to pTypesInfo
            ////////////////////////////////////////////////////////////////////////
            memset( pTypesInfo->Members, 0, FUNCMEMBERSIZE );
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            if (pTemp) {
                // Only call this one if the first one did anyting.  Otherwise
                // This one reads from uninitialized heap.
                CatMeminfo(&bufallocinfo, (PMEMBERINFO)Members, NULL, 0, FALSE);
            }
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

            GlobalFree(Members);
        }

        else {

            PTYPEINFOELEMENT pThisElement;
            DWORD dwElements = 0;

            // This struct is virtual only since methods are being added.  We already checked that no
            // data members will be in the structure.
            pTypesInfo->Flags |= BTI_VIRTUALONLY;

            ////////////////////////////////////////////////////////
            //Copy base members over
            ////////////////////////////////////////////////////////

            memset( pTypesInfo->Members, 0, FUNCMEMBERSIZE );
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            CatMeminfo(&bufallocinfo, pBaseType->pmeminfo, NULL, 0, FALSE);
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

            ///////////////////////////////////////////////////////////////////////////////
            //Build the list of functions in the VTBL
            ///////////////////////////////////////////////////////////////////////////////

            //copy unique methods over to IMethods
            for(pThisElement = pMemberFuncs; pThisElement != NULL; pThisElement = pThisElement->pNext) {
                if(pThisElement->pTypeInfo != NULL) {
                    if (!IsInMultiSz(pBaseType->Methods, pThisElement->pTypeInfo->TypeName)) {
                        if(!AppendToMultiSz(pTypesInfo->IMethods, pThisElement->pTypeInfo->TypeName,
                            MEMBERMETHODSSIZE)) {
                            ExitErrMsg(FALSE,"Too many methods in %s\n", pTypesInfo->TypeName);
                        }
                        GenerateProxy(pTypesInfo->TypeName, pThisElement->pTypeInfo);
                        dwElements++;
                    }
                }
            }

            memcpy(pTypesInfo->Methods, pBaseType->Methods, SizeOfMultiSz(pBaseType->Methods));
            if (!CatMultiSz(pTypesInfo->Methods, pTypesInfo->IMethods, MEMBERMETHODSSIZE))
                ExitErrMsg(FALSE, "Too many methods in %s\n", pTypesInfo->TypeName);

            pTypesInfo->dwVTBLSize = dwElements + pBaseType->dwVTBLSize;
            pTypesInfo->dwVTBLOffset = pBaseType->dwVTBLSize;

        }

    }

    FreeTypeInfoList(pMemberFuncs);
    return TRUE;
}

void
BumpStructUnionSize(
    DWORD *pdwSize,
    DWORD dwElemSize,
    BOOL bUnion
    )
/*++

Routine Description:

    Updates overall size of a struct/union

Arguments:

    pdwSize      -- [IN OUT] overall size of struct/union
    dwElemSize   -- size of new element to add into the struct/union
    bUnion       -- TRUE if a union, FALSE if a struct

Return Value:

    None.

--*/
{
    if (bUnion) {
        //
        // Size of a union is max(dwSize, dwElementSize)
        //
        if (dwElemSize > *pdwSize) {
            *pdwSize = dwElemSize;
        }
    } else {
        //
        // Size of a struct is current size of struct plus element size
        //
        *pdwSize = *pdwSize + dwElemSize;
    }
}

BOOL
ParseGuid(
    GUID *pGuid
    )
{
/*++

Routine Description:

    Parses a guid of the type found in a variable declaration.

Arguments:

    pGuid    -  [OUT] ptr to the guid.

Return Value:

    TRUE    - Guid parsed.
    FALSE   - Parse failed.

--*/
    unsigned int c;
    LONGLONG value;

    if (CurrentToken()->TokenType != TK_LBRACE) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFFFFFF) return FALSE;
    pGuid->Data1 = (unsigned long)value;

    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFF) return FALSE;
    pGuid->Data2 = (unsigned short)value;

    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFF) return FALSE;
    pGuid->Data2 = (unsigned short)value;


    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_LBRACE) return FALSE;
    ConsumeToken();

    c = 0;
    while(TRUE) {

        if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
        value = expr();
        if(value < 0 || value > 0xFF) return FALSE;
        pGuid->Data4[c] = (unsigned char)value;

        if (7 == c) break;

        if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
        ConsumeToken();

        c++;

    }

    for(c=0; c<2; c++) {
        if (CurrentToken()->TokenType != TK_RBRACE) return FALSE;
        ConsumeToken();
    }

    return TRUE;

}

BOOL
ParseVariables(
    VOID
    )
{

/*++

Routine Description:

    Attempts to parse a variable declaration. If successful, the variable
    is added to the variable list.

Arguments:

    none

Return Value:

    TRUE - If success.

--*/


    TYPESINFO TypesInfo;
    GUID Guid;
    char *Name;

    ConsumeConstVolatileOpt();
    if (!GetExistingType(&TypesInfo, NULL, NULL)) return FALSE;
    while(CurrentToken()->TokenType == TK_STAR) ConsumeToken();

    if (CurrentToken()->TokenType == TK_DECLSPEC) {
        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
    }

    //next token should be the variable name
    if (CurrentToken()->TokenType != TK_IDENTIFIER) return FALSE;
    Name = CurrentToken()->Name;
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, NULL);
    if (CurrentToken()->TokenType != TK_ASSIGN) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_NUMBER || CurrentToken()->TokenType == TK_STRING) {
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, NULL);
        return FALSE;
    }
    else if (CurrentToken()->TokenType == TK_LBRACE) {
        //attempt to parse a guid definition
        if (ParseGuid(&Guid) &&
            CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, &Guid);
        else return FALSE;
    }
    else return FALSE;

}

BOOL
GetArrayIndex(
    DWORD *pdw
    )
/*++

Routine Description:

    Parses the size of an array index by evaluating a C-language constant
    expression.

Arguments:

    pdw     -- [OUT] ptr to size of the array index.

Return Value:

    TRUE if array index parsed (CurrentToken points after the ']')
    FALSE if parse failed.

--*/
{
    LONGLONG value;

    *pdw = 0;       // assume no size

    if (CurrentToken()->TokenType != TK_LSQUARE) {
        return FALSE;
    }
    ConsumeToken();

    value = expr();
    if (value < 0 || value > 0xFFFFFFFF) return FALSE;

    *pdw = (DWORD)value;

    if (CurrentToken()->TokenType != TK_RSQUARE) {
        return FALSE;
    }
    ConsumeToken();

    return TRUE;
}

LONGLONG
expr(
    void
    )

{
    LONGLONG val = expr_a1();

    while(1) {
        switch (CurrentToken()->TokenType) {
        case TK_BITWISE_AND:
            ConsumeToken();
            val &= expr_a1();
            break;

        case TK_BITWISE_OR:
            ConsumeToken();
            val |= expr_a1();
            break;

        default:
            return val;
        }
    } while (1);

}

LONGLONG
expr_a1(
    void
    )
{
    LONGLONG val = expr_a();

    while(1) {
        switch (CurrentToken()->TokenType) {
        case TK_LSHIFT:
            ConsumeToken();
            val <<= expr_a();
            break;

        case TK_RSHIFT:
            ConsumeToken();
            val >>= expr_a();
            break;

        default:
            return val;
        }
    }

}

LONGLONG
expr_a(
    void
    )
/*++

Routine Description:

    Parses a C-language constant expression and returns the value - handles
    the operators 'plus' and 'minus'.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val = expr_b();

    do
    {
        switch (CurrentToken()->TokenType) {
        case TK_PLUS:
            ConsumeToken();
            val += expr_b();
            break;

        case TK_MINUS:
            ConsumeToken();
            val -= expr_b();
            break;

        default:
            return val;
        }
    } while (1);
}

LONGLONG
expr_b(
    void
    )
/*++

Routine Description:

    Part of expression evaluator - handles the highest-precedence operators
    'multiply' and 'divide'.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val = expr_c();

    do
    {
        switch (CurrentToken()->TokenType) {
        case TK_STAR:
            ConsumeToken();
            val *= expr_c();
            break;

        case TK_DIVIDE:
            ConsumeToken();
            val /= expr_c();
            break;

        case TK_MOD:
            ConsumeToken();
            val %= expr_c();
            break;

        default:
            // done
            return val;
        }
    } while (1);

}

LONGLONG
expr_c(
    void
    )
/*++

Routine Description:

    Part of expression evaluator - handles unary parts of the expression, like
    numbers, unary minus, and parentheses.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val;
    PKNOWNTYPES pkt;

    switch (CurrentToken()->TokenType) {
    case TK_NUMBER:
        val = CurrentToken()->dwValue;
        ConsumeToken();
        break;

    case TK_MINUS:  // unary minus
        ConsumeToken();
        val = -expr_c();
        break;

    case TK_TILDE:  // unary not
        ConsumeToken();
        val = ~expr_c();
        break;

    case TK_LPAREN:
        ConsumeToken();
        val = expr();
        if (CurrentToken()->TokenType != TK_RPAREN) {
            ErrMsg("Syntax error:  expected ')'");
        }
        ConsumeToken();
        break;

    case TK_RSQUARE:
        val = 0;
        break;

    case TK_SIZEOF:
        ConsumeToken(); // eat the sizeof keyword
        if (CurrentToken()->TokenType != TK_LPAREN) {
            ErrMsg("Expected '(' after 'sizeof\n");
            val = 0;
            break;
        }
        ConsumeToken(); // eat the '('
        if (CurrentToken()->TokenType == TK_STRING) {
            // sizeof(string literal)
            val = strlen(CurrentToken()->Name) + 1;
            ConsumeToken();
        } else {
            // sizeof(some type)
            TYPESINFO TypesInfo;
            DWORD dwIndLevel;
            DWORD dwSize;

            if (!GetExistingType(&TypesInfo, NULL, NULL)) {
                ExitErrMsg(FALSE, "Parse error in sizeof(typename)\n");
            }
            dwIndLevel = 0;
            ParseIndirection(&dwIndLevel, &dwSize, NULL, NULL, NULL);
            if (dwIndLevel) {
                val = (int)dwSize;
            } else {
                val = TypesInfo.Size;
            }
        }
        if (CurrentToken()->TokenType != TK_RPAREN) {
            ErrMsg("Expected ')' after 'sizeof(expr)\n");
        val = 0;
            break;
        }
        ConsumeToken(); // eat the ')'
        break;

    default:
        ErrMsg("Syntax error parsing expression\n");
        val = 0;
        break;
    }

    return val;
}


int
CreatePseudoName(
    char *pDst,
    char *pSrc
    )
/*++

Routine Description:

    Prefixes a given name with an index number and copies it into a buffer.

Arguments:

    pDst        -- [OUT] destination for the new name
    pSrc        -- [IN]  source for the base name (may be same as pDst)

Return Value:

    Chars copied, 0 for failure.

--*/
{
   static PseudoNameIndex = 0;
   int Len;
   char Buffer[MAX_PATH];

   Len = _snprintf(Buffer,
                   sizeof(Buffer) - 1,
                   "__wx86%2.2d%s",
                   PseudoNameIndex++,
                   pSrc
                   );

   if (Len <= 0) {
       ErrMsg("cpn: buffer overflow <%s>\n", pSrc);
       return 0;
       }

   strcpy(pDst, Buffer);

   return Len;

}




void
PackPush(
    char *sIdentifier
    )
/*++

Routine Description:

    Handles '#pragma pack (push...)'

Arguments:

    sIdentifier     -- [OPTIONAL] name to associate with the current pack level

Return Value:

    None.  Pack-stack updated.

--*/
{
    PACKHOLDER *ppackholder;

    if (!sIdentifier) {
        sIdentifier = "";
    }

    DbgPrintf("push (%d)\n", PackCurrentPacking());

    ppackholder = GenHeapAlloc(sizeof(PACKHOLDER) + strlen(sIdentifier));
    if (ppackholder == NULL) {
        ExitErrMsg(FALSE, "Out of memory for packing stack");
    }

    ppackholder->dwPacking = PackCurrentPacking();
    ppackholder->ppackholderNext = ppackholderHead;
    strcpy(ppackholder->sIdentifier, sIdentifier);
    ppackholderHead = ppackholder;
}


DWORD
PackPop(
    char *sIdentifier
    )
/*++

Routine Description:

    Handles '#pragma pack (pop...)'

Arguments:

    sIdentifier -- [OPTIONAL] name to pop to

Return Value:

    Returns new packing value.  Pack-stack updated.

--*/
{
    PACKHOLDER *ppackholder;
    PACKHOLDER *ppackholderPop;
    PACKHOLDER *ppackholderNext;
    DWORD dw = DEFAULTPACKINGSIZE;

    if (ppackholderHead == NULL) {
        ExitErrMsg(FALSE, "Error:  '#pragma pack' stack underflow.");
    }

    if (sIdentifier == NULL) {
        ppackholder = ppackholderHead;
        ppackholderHead = ppackholder->ppackholderNext;
        dw = ppackholder->dwPacking;
        GenHeapFree(ppackholder);
    } else {
        ppackholderPop = ppackholderHead;
        do {
            DbgPrintf("Poping for %s [%s]\n", sIdentifier, ppackholderPop ? ppackholderPop->sIdentifier : "-");
            ppackholderNext = ppackholderPop->ppackholderNext;
            if (strcmp(sIdentifier, ppackholderPop->sIdentifier) == 0) {
                dw = ppackholderPop->dwPacking;
                break;
            }
            ppackholderPop = ppackholderNext;
        } while (ppackholderPop != NULL);

        DbgPrintf("Found %s\n", ppackholderPop ? ppackholderPop->sIdentifier : "-");
        if (ppackholderPop != NULL) {
            ppackholderNext = ppackholderHead;
            do {
                ppackholder = ppackholderNext;
                ppackholderNext = ppackholder->ppackholderNext;
                ppackholderHead = ppackholderNext;
                GenHeapFree(ppackholder);
            } while (ppackholder != ppackholderPop);
        }
    }

    DbgPrintf("pop (%d)\n", dw);
    return(dw);
}

BOOL
PrepareMappedMemory(
    void
    )
/*++

Routine Description:

    Creates the memory for the .PPM file.

Arguments:

    None.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PCVMHEAPHEADER pHeader;
    hCvmHeap = CreateAllocCvmHeap(uBaseAddress,     // uBaseAddress
                       uReserveSize,   // uReservedSize
                       0x00010000,     // uRegionSize
                       0,              // uUncommited
                       0,              // uUnReserved
                       0);             // uAvailable

    if (hCvmHeap != NULL) {

        // create the heap header
        pHeader = SortppAllocCvm(sizeof(CVMHEAPHEADER));
        if (!pHeader) {
            return FALSE;
        }
        pHeader->Version = VM_TOOL_VERSION;
        pHeader->BaseAddress = (ULONG_PTR)GetCvmHeapBaseAddress(hCvmHeap);

        fpTypesListMalloc = SortppAllocCvm;

        FuncsList = &pHeader->FuncsList;
        StructsList = &pHeader->StructsList;
        TypeDefsList = &pHeader->TypeDefsList;
        NIL = &pHeader->NIL;
    }

    return(hCvmHeap != NULL);
}


PVOID
SortppAllocCvm(
    ULONG Size
    )
/*++

Routine Description:

    Allocates memory from the .PPM file mapping.

Arguments:

    None.

Return Value:

    ptr to new memory, or NULL on failure.

--*/
{
    return AllocCvm(hCvmHeap, Size);
}


BOOL
WritePpmFile(
    char *PpmName
    )
/*++

Routine Description:

    Write the .PPM file out to disk.

Arguments:

    Ppmname     -- [IN] name for .PPM file

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    NTSTATUS Status;
    BOOL bSuccess;
    HANDLE hPpmFile;
    DWORD BytesWritten;
    ULONG_PTR uBaseAddress = (ULONG_PTR)GetCvmHeapBaseAddress(hCvmHeap);
    ULONG_PTR uAvailable = (ULONG_PTR)GetCvmHeapAvailable(hCvmHeap);

    hPpmFile = CreateFile(PpmName,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if (hPpmFile == INVALID_HANDLE_VALUE) {
        ExitErrMsg(FALSE,
                   "CreateFile(%s) failed %x\n",
                   PpmName,
                   GetLastError()
                   );
    }

    if (!AddOpenFile(PpmName, 0, hPpmFile)) {
        ExitErrMsg(FALSE, "AddOpenFile failed\n");
    }

#if _WIN64
    if ((uAvailable - uBaseAddress) > MAXHALF_PTR) {
        ExitErrMsg(FALSE, "Attempt to write more than 0x%x bytes not allowed\n", MAXHALF_PTR);
    }
#endif

    bSuccess = WriteFile(hPpmFile,
                         (PVOID)uBaseAddress,
                         (DWORD)(uAvailable - uBaseAddress),
                         &BytesWritten,
                         NULL
                         );

    if (!bSuccess || BytesWritten != uAvailable - uBaseAddress) {
        ExitErrMsg(FALSE,
                   "WriteFile(%s) failed %x\n",
                   PpmName,
                   GetLastError()
                   );
    }

    DelOpenFile(0, hPpmFile);
    CloseHandle(hPpmFile);
    return TRUE;
}

void
HandlePreprocessorDirective(
    char *Line
    )
/*++

Routine Description:

    Scan and process a '#' preprocessor directive.
    Accepts:
        #pragma line LINENUM SOURCEFILE
        #pragma pack( [ [ { push | pop}, ] [  identifier,  ] ] [ n ] )

Arguments:

    Line    -- ptr to the source line (points at the '#' character)

Return Value:

    None.

--*/
{
    char *p;

    // skip over '#' character
    Line++;

    // skip over any spaces between '#' and the next token
    while (*Line == ' ' || *Line == '\t') {
        Line++;
    }

    // find the first token
    for (p = Line; isalpha(*p); ++p)
        ;

    *p = '\0';

    if (strcmp(Line, "pragma") == 0) {
        //
        // found: #pragma
        //
        char c;
        p++;

        while (*p == ' ' || *p == '\t') {
            p++;
        }

        //
        // Set 'Line' to the start of the word following '#pragma' and
        // move 'p' to the character following that word.
        //
        for (Line = p; isalpha(*p); ++p)
            ;

        //
        // Null-terminate the keyword, but save the overwritten character
        // for later.
        //
        c = *p;
        *p = '\0';

        if (strcmp(Line, "pack") != 0) {
            //
            // Might be "warning", "function" or "once".  Ignore these.
            //
            return;
        }

        //
        // Remove the null-terminator from the pragma and move 'p' to the
        // first character after "#pragma pack"
        //
        *p = c;
        while (*p == ' ' || *p == '\t') {
            p++;
        }

        if (*p == '\0') {
            //
            // Found: "#pragma pack" all by itself.  Reset packing to the
            // default value.
            //
            PackModify(DEFAULTPACKINGSIZE);
            return;
        } else if (*p != '(') {
            ExitErrMsg(FALSE, "Unknown '#pragma pack' syntax '%s'.\n", Line);
        }

        //
        // skip over the '(' character and any whitespace
        //
        do {
            p++;
        } while (*p == ' ' || *p == '\t');

        if (isdigit(*p)) {
            //
            // Found: '#pragma pack(NUMBER)'
            //
            PackModify(atol(p));
            //
            // Don't worry about the closing ')' - assume things are alright.
            //
            return;
        } else if (*p == ')') {
            //
            // Found: '#pragma pack()'
            //
            PackModify(DEFAULTPACKINGSIZE);
            return;
        } else if (!isalpha(*p)) {
            ExitErrMsg(FALSE, "Bad '#pragma pack' syntax '%s'.\n", Line);
            return;
        }

        //
        // Grab the next keyword following '#pragma pack('
        //
        for (Line = p; isalpha(*p); ++p)
            ;
        c = *p;
        *p = '\0';

        if (strcmp(Line, "push") == 0) {
            //
            // Restore the old character and skip over any whitespace
            //
            *p = c;
            while (*p == ' ' || *p == '\t') {
                p++;
            }

            if (*p == ',') {
                //
                // Skip the ',' and any whitespace
                //
                do {
                    p++;
                } while (*p == ' ' || *p == '\t');

                if (isdigit(*p)) {
                    //
                    // Found: "#pragma pack(push, n)"
                    //
                    PackPush(NULL);
                    PackModify(atoi(p));
                } else if (isalpha(*p) || *p == '_') {
                    //
                    // Found an identifier after "#pragma pack(push, ".
                    // Scan ahead to end of identifier.
                    //
                    Line = p;
                    do {
                        p++;
                    } while (isalnum(*p) || *p == '_');

                    //
                    // null-terminate the identifier, in 'Line'
                    //
                    c = *p;
                    *p = '\0';

                    //
                    // Skip past whitespace
                    //
                    while (c == ' ' || c == '\t') {
                        p++;
                        c = *p;
                    }
                    // 'c' is the first non-white char after identifier


                    if (c == ')') {
                        //
                        // Found: "#pragma pack(push, identifier)"
                        //
                        PackPush(Line);
                    } else if (c == ',') {
                        //
                        // Expect a number as the last thing on the line
                        //
                        PackPush(Line);
                        PackModify(atoi(p+1));
                    } else {
                        ExitErrMsg(FALSE, "Unknown #pragma pack syntax '%s' at %s(%d)\n", p, SourceFileName, StatementLineNumber );
                    }
                } else {
                    ExitErrMsg(FALSE, "Unknown #pragma pack syntax '%s'\n", p);
                }
            } else if (*p == ')') {
                //
                // Found: "#pragma pack(push)"
                //
                PackPush(NULL);

            } else {
                ExitErrMsg(FALSE, "Bad '#pragma pack(push)' syntax '%s' at %s(%d).\n", Line, SourceFileName, StatementLineNumber);
            }

        } else if (strcmp(Line, "pop") == 0) {
            //
            // Restore the old character and skip over any whitespace
            //
            *p = c;
            while (*p == ' ' || *p == '\t') {
                p++;
            }

            if (*p == ')') {
                //
                // Found: "#pragma pack(pop)"
                //
                PackModify(PackPop(NULL));
            } else if (*p == ',') {
                //
                // Found: "#pragma pack(pop, identifier)"
                //
                p++;
                while (*p == ' ' || *p == '\t') p++;

                if (!(isalpha(*p) || *p == '_'))
                    ExitErrMsg(FALSE, "Bad '#pragma pack(pop)' syntax '%s' at %s(%d).\n", p, SourceFileName, StatementLineNumber);

                Line = p;
                do {
                    p++;
                } while (isalnum(*p) || *p == '_');
                *p = '\0';
                PackModify(PackPop(Line));
            } else {
                ExitErrMsg(FALSE, "Bad '#pragma pack(pop)' syntax '%s' at %s(%d).\n", p, SourceFileName, StatementLineNumber);
            }
        } else {
            ExitErrMsg(FALSE, "Bad '#pragma pack' syntax '%s' at %s(%d).\n", Line, SourceFileName, StatementLineNumber);
        }

    } else if (strcmp(Line, "line") == 0) {
        //
        // found: #line LINE_NUMBER "FILENAME"
        //
        int i;

        //
        // skip over any spaces between '#line' and the line number
        //
        p++;
        while (*p == ' ' || *p == '\t') {
            p++;
        }

        //
        // copy in the new line number
        //
        SourceLineNumber = 0;
        while (isdigit(*p)) {
            SourceLineNumber = SourceLineNumber * 10 + *p - '0';
            p++;
        }
        SourceLineNumber--;

        //
        // Skip over any spaces between line number and the filename
        //
        while (*p == ' ' || *p == '\t') {
          p++;
        }

        //
        // Skip over the opening quote
        //
        if (*p == '\"') {
            p++;
        } else {
            ExitErrMsg(FALSE, "Badly-formed #line directive - filename missing");
        }

        //
        // Copy in the filename, converting "\\" sequences to single '\'
        //
        for (i=0; *p && *p != '\"' && i<sizeof(SourceFileName)-1; ++i, ++p) {
            if (*p == '\\' && p[1] == '\\') {
                p++;
            }
            SourceFileName[i] = *p;
        }
        SourceFileName[i] = '\0';
        StatementLineNumber = SourceLineNumber;
    } else {
        ExitErrMsg(FALSE, "Unknown '#' directive (%s).\n", Line);
    }

}


BOOL
LexNextStatement(
    void
    )
/*++

Routine Description:

    Read from the input file and perform lexical analysis.  On return, an
    entire C-language statement has been tokenized.  Use CurrentToken(),
    ConsumeToken(), and CurrentTokenIndex to access the tokenized statement.

    The preprocessor recognizes #pragma and #line directives, ignoring all
    other directives.

Arguments:

    None.

Return Value:

    TRUE if analysis successful.
        - Tokens[] is filled in with the tokenized statement
        - CurrentTokenIndex is set to 0
        - StatmentLineNumber is the line number in the original header file
          corresponding to the first token in the statement
        - SourceFileName[] is the name of the current header file
        - SourceFileLineNumber is the current line number in the header file
    FALSE if end-of-file encountered.

--*/
{
    static char Line[MAX_CHARS_IN_LINE+2];  // a line from the .pp file
    static char *p;                         // ptr into Line[]
    BOOL fParseDone;

    //
    // Clean up after the previous statment and prep for the next statement
    //
    ResetLexer();
    StatementLineNumber = SourceLineNumber;

    //
    // Lex source lines until a complete statement is recognized.  That
    // occurs when a ';' character is found at file-scope.
    //
    do {

        if (p == NULL || *p == '\0') {
            do {
                //
                // Get an entire source line from the file, and set p to
                // point to the first non-space character
                //
                if (feof(fpHeaders)) {
                    return FALSE;
                }

                SourceLineNumber++;
                if (!fgets(Line, MAX_CHARS_IN_LINE, fpHeaders)) {
                    return FALSE;
                }
                for (p = Line; isspace(*p); ++p)
                    ;
            } while (*p == '\0');
        }

        StatementLineNumber = SourceLineNumber;
        p = LexOneLine(p, TRUE, &fParseDone);

    } while (!fParseDone);

    CurrentTokenIndex = 0;
    return TRUE;
}


BOOL
ConsumeDeclSpecOpt(
    BOOL IsFunc,
    BOOL bInitReturns,
    BOOL *pIsDllImport,
    BOOL *pIsGuidDefined,
    GUID *pGuid
    )
/*++

Routine Description:

    Comsumes a __declspec modifier. Returns are unaffected if the corresponding
    __declspec is not found.


    Accepts:
        <not a __declspec keyword>
        __declspec()
        __declspec(naked)           (only if parsing functions)
        __declspec(thread)          (only if parsing data)
        __declspec(novtable)        (only if parsing data)
        __declspec(uuid(GUID))      (only if parsing data)
        __declspec(dllimport)       (both functions and data)
        __declspec(dllexport)       (both functions and data)
        __declspec(align(x))        (only if parsing data)

Arguments:

    IsFunc  -- TRUE if parsing a function declaration, FALSE if parsing
               a data/object declaration.  Affects which keywords are
               allowed within the __declspec.
    bInitReturns -- TRUE if returns should be initialized to FALSE.
    pIsDllImport -- [OPTIONAL OUT] set to TRUE if __declspec(dllimport) found
    pIsGuidDefined -- [OPTIONAL OUT] set to TRUE if __declspec(uuid(GUID)) found
    pGuid -- [OPTIONAL OUT] set to guid of __declspec(uuid(GUID)) if found.

Return Value:

    TRUE if __declspec consumed OK, FALSE if __declspec parse error.

--*/
{

    int OldTokenIndex;
    OldTokenIndex = CurrentTokenIndex;

    if (bInitReturns) {
        if (pIsDllImport != NULL) *pIsDllImport = FALSE;
        if (pIsGuidDefined != NULL) *pIsGuidDefined = FALSE;
    }

    if (CurrentToken()->TokenType != TK_DECLSPEC) {
        // Reject: no __declspec found
        goto dofail;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_LPAREN) {
        // Reject: __declspec found without '(' following
        goto dofail;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_RPAREN) {
        // Accept:  "__declspec ()"
        ConsumeToken();
        return TRUE;
    }
    else if (CurrentToken()->TokenType != TK_IDENTIFIER) {
        goto dofail;
    }

    //handle cases for both data and functions
    if (strcmp(CurrentToken()->Name, "dllimport") == 0) {
        //Parsing: __declspec(dllimport
        if (NULL != pIsDllImport) *pIsDllImport = TRUE;
        ConsumeToken();
    }
    else if (strcmp(CurrentToken()->Name, "dllexport") == 0) {
        //Parsing: __declspec(dllexport
        ConsumeToken();
    }
    else if (IsFunc) {
        if (strcmp(CurrentToken()->Name, "naked") == 0) {
            //Parsing: __declspec(naked
            ConsumeToken();
        } else if (strcmp(CurrentToken()->Name, "noreturn") == 0) {
            //Parsing: __declspec(noreturn
            ConsumeToken();
        } else if (strcmp(CurrentToken()->Name, "address_safe") == 0) {
            //Parsing: __declspec(address_safe
            ConsumeToken();
        }
        else goto dofail; //reject
    }
    else { //data
        if (strcmp(CurrentToken()->Name, "thread") == 0) {
            //Parsing: __declspec(thread
            ConsumeToken();
        }
        else if (strcmp(CurrentToken()->Name, "novtable") == 0) {
            //Parsing: __declspec(novtable
            ConsumeToken();
        }
        else if (strcmp(CurrentToken()->Name, "uuid") == 0) {
            GUID gTemp;
            //Parsing: __declspec(uuid
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_LPAREN) goto dofail;
            //Parsing: __declspec(uuid(
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_STRING) goto dofail;
            //Parsing: __declspec(uuid(guid
            if(!ConvertStringToGuid(CurrentToken()->Name, &gTemp)) goto dofail;
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_RPAREN) goto dofail;
            //Parsing: __declspec(uuid(guid)
            ConsumeToken();
            if (pIsGuidDefined != NULL) *pIsGuidDefined = TRUE;
            if (pGuid != NULL) *pGuid = gTemp;
        }
        else if (strcmp(CurrentToken()->Name, "align") == 0) {
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_LPAREN) goto dofail;
            ConsumeToken();
            expr();
            if (CurrentToken()->TokenType != TK_RPAREN) goto dofail;
            ConsumeToken();
        }
        else goto dofail; //reject
    }

    if (CurrentToken()->TokenType != TK_RPAREN) {
        // Reject: expect ')' after __declspec(extended-decl-modifier)
        goto dofail;
    }
    ConsumeToken();

    // Accept: __declspec(extended-decl-modifier)
    return TRUE;

dofail:
    CurrentTokenIndex = OldTokenIndex;
    return FALSE;
}

PTYPEINFOELEMENT
TypeInfoElementAllocateLink(
    PTYPEINFOELEMENT *ppHead,
    PTYPEINFOELEMENT pThis,
    TYPESINFO *pType
    )
{

/*++

Routine Description:

        Allocates a TYPEINFOELEMENT and linked it to the end of the list.

Arguments:

        ppHead  - [IN/OUT] ptr ptr to the head of the list.
        pThis   - [IN] ptr to the tail of the list.
        pType   - [IN] ptr to the typeinfo to add to the list.

Return Value:

        NON-NULL - New tail.
        NULL     - Failure.
--*/

    PTYPEINFOELEMENT pNew= GenHeapAlloc(sizeof(struct TypeInfoListElement));
    if (NULL == pNew) ExitErrMsg(FALSE, "Out of memory!");
    pNew->pNext = NULL;
    pNew->pTypeInfo = pType;
    if (NULL == pThis) *ppHead = pNew;
    else pThis->pNext = pNew;
    return pNew;
}

BOOL
AddVariable(
    char *Name,
    GUID * pGuid
    )
{
/*++

Routine Description:

        Adds a variable to the list of declared global variabled.

Arguments:

        Name -      [IN] ptr to name of variable to add.
        pGuid -     [OPTIONAL IN] ptr to guid for this variable.

Return Value:

        TRUE - if success.
--*/
    PKNOWNTYPES pKnownTypes;
    int Len;

    if(NULL == Name) return FALSE;

    //Already in the tree
    pKnownTypes = RBFind(VarsList, Name);
    if (NULL != pKnownTypes) {
        //replace guid in list if pGuid != NULL and ignore the duplication
        if (NULL != pGuid) {
            pKnownTypes->Flags |= BTI_HASGUID;
            pKnownTypes->gGuid = *pGuid;
        }
        return TRUE;
    }

    //Create a KNOWNTYPES structure for variable
    Len = sizeof(KNOWNTYPES) + strlen(Name) + 1;
    pKnownTypes = GenHeapAlloc(Len);
    if(NULL == pKnownTypes) return FALSE;

    memset(pKnownTypes, 0, Len);
    pKnownTypes->TypeName = pKnownTypes->Names;
    strcpy(pKnownTypes->Names, Name);
    if(NULL != pGuid) {
        pKnownTypes->Flags |= BTI_HASGUID;
        pKnownTypes->gGuid = *pGuid;
    }

    RBInsert(VarsList, pKnownTypes);
    return TRUE;
}



VOID
UpdateGuids(
    VOID
    )
{
/*++

Routine Description:

        Looks for variables of whose name starts with IID_ and assigned a guid structure.
        The IID_ is striped and the guid of the corresponding struct is updated

Arguments:

        None.

Return Value:

        None.
--*/
    PKNOWNTYPES pThis;
    PKNOWNTYPES pLookup;
    char *LookupName;

    for(pThis = VarsList->pLastNodeInserted; pThis != NULL; pThis = pThis->Next) {

        //test if name has guid associated with it and that it begins with IID_
        if ((pThis->Flags & BTI_HASGUID) &&
            pThis->TypeName[0] == 'I' &&
            pThis->TypeName[1] == 'I' &&
            pThis->TypeName[2] == 'D' &&
            pThis->TypeName[3] == '_' )
        {
            //Attempt to find a structure with the name except the IID_
            LookupName = pThis->TypeName + 4; //skip the IID_
            pLookup = RBFind(StructsList, LookupName);

            if(NULL != pLookup) {

                //if types does not have a GUID defined already, copy guid from here
                if (!(pLookup->Flags & BTI_HASGUID)) {
                    pLookup->Flags |= BTI_HASGUID;
                    pLookup->gGuid = pThis->gGuid;
                }

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tools\gennt32t\gennt32t.cpp ===
/*++
                                                                                
Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    gennt32t.cpp

Abstract:
    
    Generates NT32 headers for use in the NT64 build.
    
Author:

    mzoran  5-8-98

Revision History:

--*/

#pragma warning( disable : 4786) //disable identifier is too long for debugging error
#pragma warning( disable : 4503) //disable decorated name is too long
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <sstream>
#include <set>
#include <map>

extern "C" {

#include "gen.h"

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'GENNT32T' ";

void
HandlePreprocessorDirective(
   char *p
   )
{
   ExitErrMsg(FALSE, "Preprocessor directives not allowed by gennt32t.\n");
}

}

using namespace std;
typedef string String;

PRBTREE pFunctions = NULL;
PRBTREE pStructures = NULL;
PRBTREE pTypedefs = NULL;
PKNOWNTYPES NIL = NULL;

void ExtractCVMHeader(PCVMHEAPHEADER pHeader) {
   pFunctions = &pHeader->FuncsList;
   pTypedefs =  &pHeader->TypeDefsList;
   pStructures =&pHeader->StructsList;
   NIL         =&pHeader->NIL; 
}

 
void GetType(PKNOWNTYPES pTypes, char *pPrepend, ostream & oType, ostream & oName, BOOL bAddTypeName) {
  
   while(1) {
      PKNOWNTYPES pBasicType = NULL;
      assert(pTypes->TypeName != NULL);
      
      oType << "/* " << pTypes->TypeName << " */";
                          
      if(pTypes->Flags & BTI_ISARRAY)
         oName << '[' << pTypes->dwArrayElements << ']';
      if (pTypes->IndLevel > 0) {
         oType << GetHostPointerName(pTypes->Flags & BTI_PTR64);
         return;
      }
      if(!(BTI_NOTDERIVED & pTypes->Flags)) {
         
         if (strcmp(pTypes->BaseName, "enum") == 0) {
            if (bAddTypeName)
               oType << "enum " << pPrepend << pTypes->TypeName << " {} \n";
            else
               oType << "_int32 \n";
            return;
         }

         else if (strcmp(pTypes->BaseName, "union") == 0 ||
             strcmp(pTypes->BaseName, "struct") == 0) {

            oType << "\n#pragma pack(" << pTypes->dwCurrentPacking 
                  << ")\n";
            if (bAddTypeName) 
              oType << pTypes->BaseName << " " << pPrepend << pTypes->TypeName;
            else
              oType << pTypes->BaseName << " ";

            if (NULL != pTypes->pmeminfo) {
               oType << "{\n";
               PMEMBERINFO pmeminfo = pTypes->pmeminfo;
               do {
                  ostringstream oMemberType("");
                  ostringstream oMemberName("");
                  PKNOWNTYPES pMemberType = pmeminfo->pkt;
                  if(pmeminfo->sName != NULL)
                     (ostream)oMemberName << pmeminfo->sName;
                  if (pmeminfo->bIsArray) 
                     (ostream)oMemberName << '[' << pmeminfo->ArrayElements << ']';
                  if (pmeminfo->IndLevel > 0) {
                     (ostream)oMemberType << GetHostPointerName(pmeminfo->bIsPtr64);
                  }
                  else {
                     GetType(pMemberType, pPrepend, oMemberType, oMemberName, FALSE);
                     if (pmeminfo->bIsBitfield) 
                        (ostream)oMemberName << " : " << pmeminfo->BitsRequired;
                  }
                  oType << oMemberType.str() << " " << oMemberName.str() << ";\n";
                  pmeminfo = pmeminfo->pmeminfoNext;
               } while(NULL != pmeminfo);
               oType << "}\n";
            }
            
            return;
         }
         else {
            pBasicType = pTypes->pTypedefBase;
            if (NULL == pBasicType) {
               oType << GetHostPointerName(pTypes->Flags & BTI_PTR64);
               return;
            }
            pTypes = pBasicType;
         }
      }
      else {
         char Buffer[MAX_PATH];
         oType << GetHostTypeName(pTypes, Buffer);
         return;
      }      
   }
}

void DumpTypesHeader(void) {
    PKNOWNTYPES pTypes; 

    cout << "///////////////////////////////////////////\n";
    cout << "// This file is autogenerated by gennt32t. \n";
    cout << "// Do not edit                             \n";
    cout << "///////////////////////////////////////////\n";
    cout << '\n' << '\n';

    cout << "#include <guiddef.h>\n\n";

    cout << "#pragma pack(push, gennt32t)\n\n";

    cout << "///////////////////////////////////////////\n";
    cout << "//  Structures                             \n";
    cout << "///////////////////////////////////////////\n";
    for(pTypes = pStructures->pLastNodeInserted; pTypes != NULL; pTypes = pTypes->Next) {
      if (pTypes->TypeName != NULL && !(pTypes->Flags & BTI_NOTDERIVED)) {
         ostringstream oType;
         ostringstream oName;
         GetType(pTypes, "NT32", oType, oName, TRUE);
         cout << "/* " << pTypes->TypeName << " */";
         cout << oType.str() << "\n";
         cout << oName.str() << ";" << "\n";
         cout << "/* End of definition for " << pTypes->TypeName << " */\n";
         cout << '\n';
      }    }
    cout << '\n' << '\n';

    cout << "///////////////////////////////////////////\n";
    cout << "//  TypeDefs                               \n";
    cout << "///////////////////////////////////////////\n";
    for(pTypes = pTypedefs->pLastNodeInserted; pTypes != NULL; pTypes = pTypes->Next) {
      if (pTypes->TypeName != NULL && !(pTypes->Flags & BTI_NOTDERIVED)) {
         ostringstream oType;
         ostringstream oName;
         oName << "NT32" << pTypes->TypeName << " ";
         GetType(pTypes, "NT32", oType, oName, FALSE);
         cout << "/* " << pTypes->TypeName << " */" << " typedef \n";
         cout << oType.str() << "\n";
         cout << oName.str() << "\n";
         cout << ";" << "\n";
         cout << "/* End of definition for " << pTypes->TypeName << " */\n";
         cout << '\n';
      }
    }
    cout << '\n' << '\n';

    cout << "#pragma pack(pop, gennt32t)\n\n";

}

int _cdecl main(int argc, char*argv[]) {
    ExtractCVMHeader(MapPpmFile(argv[1], TRUE));
    DumpTypesHeader();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\whnt32\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
GENTHNK_FLAGS=-d -w
!else
GENTHNK_FLAGS=-w
!endif

PPMFILE=..\cgen\$(O)\winincs.ppm
NT32HDR=..\cgen\$(O)\nt32.h

WHLOGGENDIR=..\wow64log\$(O)

WHNT32TAB=$(O)\whnt32.tab
WHNT32C=$(O)\whnt32.c
WHNT32LOGC=$(WHLOGGENDIR)\whnt32.c

$(WHNT32C): $(PPMFILE) \
           $(BASE_INC_PATH)\apithunk.tpl \
           $(BASE_INC_PATH)\genmacro.tpl \
           $(BASE_INC_PATH)\gentypes.tpl \
           whnt32.tpl \
           whnt32t.tpl \
           $(WHNT32TAB)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\gentypes.tpl \
                -twhnt32.tpl \
                -twhnt32t.tpl \
                -c$(WHNT32C):whnt32 \
                -s$(WHNT32TAB):Nt

$(WHNT32LOGC): $(PPMFILE) \
              $(BASE_INC_PATH)\apithunk.tpl \
              $(BASE_INC_PATH)\genmacro.tpl \
              $(BASE_INC_PATH)\thunklog.tpl \
              $(WHNT32TAB)
    -mkdir $(WHLOGGENDIR)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\thunklog.tpl \
                -c$(WHNT32LOGC):whnt32log \
                -s$(WHNT32TAB):Nt

thunks: $(WHNT32NC) $(WHNT32LOGC)

cleanfiles:
    -del $(WHNT32C)
    -del $(WHNT32LOGC)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\whbase\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
GENTHNK_FLAGS=-d -w
!else
GENTHNK_FLAGS=-w
!endif

PPMFILE=..\cgen\$(O)\winincs.ppm
NT32HDR=..\cgen\$(O)\nt32.h

WHLOGGENDIR=..\wow64log\$(O)

WHBASETAB=..\..\win32\client\wow6432\services.tab
WHBASEC=$(O)\whbase.c
WHBASELOGC=$(WHLOGGENDIR)\whbase.c
WHBASEERRC=$(O)\whbaseerr.c

$(WHBASEC): $(PPMFILE) \
           $(BASE_INC_PATH)\apithunk.tpl \
           $(BASE_INC_PATH)\genmacro.tpl \
           $(BASE_INC_PATH)\gentypes.tpl \
           whbase.tpl \
           $(WHBASETAB)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\gentypes.tpl \
                -twhbase.tpl \
                -c$(WHBASEC):whbase \
                -s$(WHBASETAB)

$(WHBASEERRC): $(PPMFILE) \
               whbaseerr.tpl \
               $(WHBASETAB)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -twhbaseerr.tpl \
                -c$(WHBASEERRC):whbase \
                -s$(WHBASETAB)

$(WHBASELOGC): $(PPMFILE) \
              $(BASE_INC_PATH)\apithunk.tpl \
              $(BASE_INC_PATH)\genmacro.tpl \
              $(BASE_INC_PATH)\thunklog.tpl \
              $(WHBASETAB)
    -mkdir $(WHLOGGENDIR)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\thunklog.tpl \
                -c$(WHBASELOGC):whbaselog \
                -s$(WHBASETAB)

thunks: $(WHBASEC) $(WHBASEERRC) $(WHBASELOGC)

cleanfiles:
    -del $(WHBASEC)
    -del $(WHBASEERRC)
    -del $(WHBASELOGC)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tools\genthnk\genthnk.c ===
/*++
                                                                                
Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    genthnk.c

Abstract:
    
    This program generates thunks.
    
Author:

    08-Jul-1995 JonLe

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "gen.h"

// bitfield values to indicate which platform an API should be switched in on.
#define API_NONE        0
#define API_WIN95       1
#define API_WIN98       2
#define API_NT4         4
#define API_NT5         8
#define API_WIN9x       (API_WIN95 | API_WIN98)
#define API_NTx         (API_NT4 | API_NT5)
#define API_ALL         (API_WIN9x | API_NTx)

#define API_SHIFT_WIN9x 0   // shift API bits right 0 to make Win9x leftmost
#define API_SHIFT_NTx   2   // shift API bits right 2 to make NTx leftmost

// This is the new VC6 import structure.  VC6 import lib spec is checked
// in as wx86\doc\vc6.doc.  Contact Dan Spalding or Kathleen Herold for
// more info.  Or look at sdktools\vctools\coff\deflib.h ImportHdr.
typedef struct ImgImportHdr {
    WORD    Sig1;       // always 0 (IMAGE_FILE_MACHINE_UNKNOWN)
    WORD    Sig2;       // always ffff (IMPORT_HDR_SIG2)
    WORD    Version;
    WORD    Machine;
    DWORD   TimeStamp;
    DWORD   SizeOfData; // count of bytes in strings that follow
    union {
        WORD Ordinal;
        WORD Hint;
    };

    WORD    Type : 2;   // IMPORT_TYPE
    WORD    NameType : 3; // IMPORT_NAME_TYPE
    WORD    Reserved : 11;// Reserved.  Must be 0.
} VC6_IMAGE_IMPORT_HEADER, *PVC6_IMAGE_IMPORT_HEADER; 

enum IMPORT_TYPE
{
    IMPORT_CODE = 0,
    IMPORT_DATA = 1,
    IMPORT_CONST = 2,
};

enum IMPORT_NAME_TYPE
{
    IMPORT_ORDINAL,
    IMPORT_NAME,
    IMPORT_NAME_NO_PREFIX,
    IMPORT_NAME_UNDECORATE
};
// end of VC6 import structure


// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8600: 'GENTHNK' ";

// template sections types
char szIFUNC[]= "IFunc";
char szEFUNC[]= "EFunc";
char szEFAST[]= "EFast";
char szTYPES[]= "Types";
char szCODE[] = "Code";
char szFAILTYPES[] = "FailTypes";
char szMACROS[]="Macros";

// template properties
char szTEMPLENAME[]= "TemplateName";
char szMACRONAME[] = "MacroName";
char szTYPENAME[]  = "TypeName";
char szINDLEVEL[]  = "IndLevel";
char szDIRECTION[] = "Direction";
char szNUMARGS[]   = "NumArgs";
char szCGENBEG[]   = "Begin";       // default codeburst name
char szCGENEND[]   = "End";
char szUSE[]       = "Use";
char szALSO[]      = "Also";
char szNOTYPE[]    = "NoType";
char szCASE[]      = "Case";

// substitution macros
char szTEMPLATE[]="Template";
char szDLLNAME[]="DllName";
char szXPTNAME[]="XPTName";
char szDLLTARGET[]="DllTarget";
char szAPIFNRET[]="ApiFnRet";
char szAPIFNMOD[]="ApiFnMod";
char szAPINAME[]="ApiName";
char szAPINAMESKIP[]="ApiNameSkip";
char szAPIFORWARD[]="ApiForward";
char szAPINUM[]="ApiNum";
char szAPIUNKNOWN[]="ApiUnknown";
char szAPINODECL[]="ApiNoDecl";
char szFASTCALL[]="FastCall";
char szSLOWCALL[]="SlowCall";
char szFASTX2NMETH[]="FastX2NMethod";
char szSLOWX2NMETH[]="SlowX2NMethod";
char szFATX2NMETH[]="FatX2NMethod";
char szMETHODNUMBER[]="MethodNumber";
char szRETSIZE[]="RetSize";
char szUNALIGNEDTAG64[]="UnalignedTag64";
char szARGSIZE[]="ArgSize";
char szARGTYPE[]="ArgType";
char szARGHOSTTYPE[] = "ArgHostType";
char szARGTYPEIND[]="ArgTypeInd";
char szARGHOSTTYPEIND[]="ArgHostTypeInd";
char szARGNAME[]="ArgName";
char szARGNAMEHOSTCASTED[]="ArgHostName";
char szARGVAL[]="ArgVal";
char szFUNCARGNUM[]="FuncArgNum";
char szARGMOD[]="ArgMod";
char szARGPOSTMOD[]="ArgPostMod";
char szARGLIST[]="ArgList";
char szIFAPIRET[]="IfApiRet";
char szIFARGS[]="IfArgs";
char szARGMORE[]="ArgMore";
char szAPILIST[]="ApiList";
char szAPIMORE[]="ApiMore";
char szLISTCOL[]="ListCol";
char szARGLOCAL[]="ArgLocal";
char szARGOFF[]="ArgOff";
char szARGADDR[]="ArgAddr";
char szEXPORTLIST[]="ExportList";
char szEXPNAME[]= "ExpName";
char szIFEXPFORWARD[]= "IfExpForward";
char szADDRARGSLIST[]="AddrArgsList";
char szNARGTYPE[]="NArgType";
char szNARGNAME[]="NArgName";
char szIFRETTYPE[]="IfRetType";
char szIFORDINALS[]="IfOrdinals";
char szAPISTRINGS[]="ApiStrings";
char szDBGSINDEX[]="DbgsIndex";
char szDBGSLIST[]="DbgsList";
char szDBGSSTRINGS[]="DbgsStrings";
char szDBGSMORE[]="DbgsMore";
char szCPPEXPORT[]="CppExport";
char szCEXPORT[]="CExport";
char szCPPOUTPUT[]="CppOutput";
char szCOUTPUT[]="COutput";
char szAPIDECLSPEC[]="ApiDeclSpec";
char szIFAPICODE[]="IfApiCode";
char szRETTYPE[]="RetType";
char szMARG[]="MArg";
char szMEMBERTYPES[]="MemberTypes";
char szBTOTMEMBERTYPES[]="BtoTMemberTypes";
char szFORCETYPE[]="ForceType";
char szLOG[]="Log";
char szRTOLTYPES[]= "RtoLTypes";
char szIFNOTRETTYPE[]="IfNotRetType";
char szIFISMEMBER[]="IfIsMember";
char szIFNISMEMBER[]="IfNotIsMember";
char szIFISBITFIELD[]="IfIsBitfield";
char szIFNISBITFIELD[]="IfNotIsBitfield";
char szIFISARRAY[]="IfIsArray";
char szIFNISARRAY[]="IfNotIsArray";
char szARGARRAYELEMENTS[]="ArrayElements";
char szIFPOINTERTOPTRDEP[]="IfPointerToPtrDep";
char szIFNPOINTERTOPTRDEP[]="IfNotPointerToPtrDep";
char szISPOINTERTOPTRDEP[]="IsPointerToPtrDep";
char szIFPTRDEP[]="IfPtrDep";
char szIFNPTRDEP[]="IfNotPtrDep";
char szIFINT64DEPUNION[]="IfInt64DepUnion";
char szIFNINT64DEPUNION[]="IfNotInt64DepUnion";
char szNL[]="NL";
char szINDENT[]="Indent";
char szNOFORMAT[]="NoFormat";
char szALIGN[]="Align";
char szCOMMENT[]="Comment";

char szOFFSET[]="OffSet";

char szHOSTAPPEND[]="Host";

char szCARG[]="CArg";
char szCARGEXIST[]="CArgExist";
char szFORCASE[]="ForCase";
char szCNUMBER[]="CNumber";

// if support
char szIF[]="If";
char szELSE[]="Else";
char szOR[]="Or";
char szAND[]="And";
char szNOT[]="Not";

char szARGUNIONULARGEINTEGER[]="PULARGE_INTEGER";
char szARGUNIONLARGEINTEGER[]="PLARGE_INTEGER";



extern char sz__PTR64[];


#define MAX_ALSO        80
#define MAX_CODEBURST   20
#define MAX_NOTYPE      32

typedef struct tagCODEBURST {
    char *Name;
} CODEBURST;

CODEBURST CodeBursts[MAX_CODEBURST];

typedef struct _Templates{
   LIST_ENTRY   TempleEntry;
   char *Name;
   int  IndLevel;
   TOKENTYPE tkDirection;
   PKNOWNTYPES pktType;
   char *Comment;
   char *CodeBurst[MAX_CODEBURST];
   char *NoTypes[MAX_NOTYPE];
   PLIST_ENTRY pCaseList;
   char Buffer[1];
}TEMPLES, *PTEMPLES;

typedef struct _CGenerate {
   LIST_ENTRY CGenerateEntry;
   FILE *fp;
   
   FILE *fpC;
   char *FileNameC;
   char *FileBaseNameC;
   
   FILE *fpCpp;
   char *FileNameCpp;
   char *FileBaseNameCpp;
   
   char TempleName[1];
}CGENERATE, *PCGENERATE;

FILE *fpLog;    // file pointer to optional log file for @Log() calls


//
// handy macro to knock out the hi bit in implib style ordinals
//
#define IMPORDINAL(o) ((o) & ~0x80000000)

//
// Structure definining the list of arguments for a function
//
typedef struct _ArgumentsList {
   LIST_ENTRY   ArgumentsEntry;     // ptr to prev and next arg
   PKNOWNTYPES  pKnownTypes;        // type of this arg
   PKNOWNTYPES  pStructType;        // cache used by MemberTypes()
   DWORD        ArgSize;            // size of this arg
   BOOL         IsPtr64;            // TRUE if this arg is __ptr64
   int          OffSet;             // offset from stack for this arg
   int          IndLevel;           // indirection level
   TOKENTYPE    tkDirection;        // TK_NONE, TK_IN, TK_OUT, TK_INOUT
   TOKENTYPE    Mod;                // modifier (TK_CONST/VOLATILE/NONE)
   TOKENTYPE    SUEOpt;             // TK_STRUCT/ENUM/UNION/NONE
   char         *Type;              // typename for this arg
   TOKENTYPE    PostMod;            // modifier (TK_CONST/VOLATILE/NONE)
   TOKENTYPE    PrePostMod;         // modifier (TK_CONST/VOLATILE/NONE)
   char          *Name;              // argument name (may be a nonameX)
   char         *ArgLocal;          // name of local var containing copy of arg
   char         *HostCastedName;    // Contains full name of struct member with 
                                    // host casts or NULL
   BOOL         fRequiresThunk;     // TRUE if arg type contains a nested
                                    //  function pointer (and hence needs
                                    //  special thunking)
   BOOL         fNoType;            // TRUE if types templates should *not*
                                    //  be expanded for this param.
   BOOL         fIsMember;          // This arg is actually a member of an array
   BOOL         bIsBitfield;        // Determines if this is a bitfield
   int          BitsRequired;       // Number of bits required for bitfield
   BOOL         bIsArray;           // This member is an array
   int          ArrayElements;      // Number of elements in the array
} ARGSLIST, *PARGSLIST;

//
// Structure containing the list of macro arguments
//
typedef struct _MacroArgsList {
    int  NumArgs;
    LPSTR ArgText[1];
} MACROARGSLIST, *PMACROARGSLIST;

typedef struct _MLListEntry {
   LIST_ENTRY ListEntry;
   PMACROARGSLIST pMArgs;
} MLLISTENTRY, *PMLLISTENTRY;

#define MAX_MACRO_STACK     20
PMACROARGSLIST MacroStack[MAX_MACRO_STACK];
int MacroStackTop;


//
// This defines the first method number that would not be supported as a
// fast or slow method call. If this is to be changed then FastN2X and SlowN2X
// worker routines need to be addeed in whole32.dll
#define MAXFASTN2XMETHODNUMBER  16

//
// This defines the maximum number of parameters that are allowed to be in a
// FastX2N or SlowX2N method call. To change it new code would have to be
// added to FastX2N and SlowX2N in whole32\methods.c to deal with the 
// additional number of parameters.
#define MAXX2NPARAMETERS        10

typedef enum {
    UNKNOWNMETHOD = 0,
    FATX2NMETHOD = 1,
    FASTX2NMETHOD = 2,
    SLOWX2NMETHOD = 3
} METHODTYPE;

typedef struct _ExportDebugInfo {
   LIST_ENTRY  ExportsDbgEntry;
   LIST_ENTRY  ArgsListHead;
   struct _ExportDebugInfo  *IntForward;
   int         ArgsSize;
   ULONG       Function;
   char       *ExtForward;
   char       *ExportName;
   char       *CplusDecoration;
   ULONG       Ordinal;

   // 0 = known fn, -1 incomplete declaration, 1 no declaration
   char        UnKnownApi;
   BOOLEAN     Data;
   BOOLEAN     PrivateNamed;
   CHAR        FastCall;
   BYTE        ApiPlatform;     // the API_ bit collection
   METHODTYPE  X2NMethodType;
   ULONG       MethodNumber;
   char        Buffer[1];
}EXPORTSDEBUG, *PEXPORTSDEBUG;

typedef struct _DebugStringsList {
   LIST_ENTRY  DebugStringsEntry;
   char *Name;
   char *ArgFormat;
   char *RetFormat;
   char Buffer[1];
} DEBUGSTRINGS, *PDEBUGSTRINGS;

typedef struct _CGenerateState {
   PEXPORTSDEBUG  ExportsDbg;
   PDEBUGSTRINGS  DebugStrings;
   PCGENERATE     CGen;
   PTEMPLES       Temple;       // template for this func (may be IFunc or EFunc)
   PKNOWNTYPES    ApiTypes;
   int            ApiNum;
   PARGSLIST      pArgsList;
   int            ListCol;
   BOOLEAN        MoreApis;
   BOOLEAN        ExTemplate;   // true if Temp is an EFunc template with a 'Begin='
   PTEMPLES       TempleEx;     // EFunc for this API (if there is one)
   int            CodeBurstIndex;
   PTEMPLES       CurrentTemple; // This is the template that is currently being expanded.
   PMACROARGSLIST pMacroArgsList;
   PCHAR          *MemberNoType; // Additional set of notypes to applyPMACROARGSLIST pMacroArgsList;
   int            CaseNumber;  // Number of the current Case being expanded.
   PLIST_ENTRY    pCaseList;
   PMACROARGSLIST pCaseArgsList;
} CGENSTATE, *PCGENSTATE;

int BeginCBI;       // CodeBurstIndex for 'Begin='

PKNOWNTYPES NIL;    // for red-black trees
PRBTREE FuncsList;
PRBTREE TypeDefsList;
PRBTREE StructsList;

RBTREE FakeFuncsList;
LIST_ENTRY TypeTempleList;
LIST_ENTRY FailTempleList;
LIST_ENTRY IFuncTempleList;
LIST_ENTRY EFuncTempleList;
LIST_ENTRY EFastTempleList;
LIST_ENTRY CodeTempleList;
LIST_ENTRY CGenerateList;
LIST_ENTRY ExportsList;
LIST_ENTRY DebugStringsList;
LIST_ENTRY MacroList;
ULONG NumDebugStringsEntries;

BOOL MapViewDll(char *DllName);
char DllName[MAX_PATH+1]= "";
char ExplicitDllBaseName[MAX_PATH+1] = "UNSPECIFIED";
char *DllBaseName = ExplicitDllBaseName;
PVOID DllMappedBase = NULL;
ULONG_PTR DllRvaOffset;
PULONG DllFunctions = NULL;
PUSHORT DllNameOrdinals = NULL;
PULONG DllNameTable = NULL;
ULONG DllExportDirSize;
PIMAGE_EXPORT_DIRECTORY DllExportDir;

BOOL MapViewImplib(char *ImplibName);
char ImplibName[MAX_PATH+1]="";
char *ImplibBaseName = NULL;
PVOID ImplibMappedBase= NULL;
ULONG ImplibNumSymbols=0;
PULONG ImplibSymbolMembers=NULL;
PCHAR ImplibSymbolNames=NULL;
char szIMPPREFIX[]="__imp_";
char szIDATA5[]=".idata$5";
char szTEXT[]=".text";

char szINTFORWARD[]="_IntForward_";

char XptName[MAX_PATH+1]= "";
char *XptBaseName = NULL;

// these are used to report errors while parsing .tpl files
char *TemplateFileName;
int TemplateLine;

char iHandleCpp = 0; // if == 0, Don't use CPP macros,  and warn if CPP exports found
                     // if < 0, Don't use CPP macros, no warn if CPP exports found
                     // if > 0, Use CPP macros.

BOOL bNoFuzzyLogic;
BOOL bUseExpListAndImplib;
BOOL bWarnAboutNestedFuncPtrs;
BOOL bUseDirection = TRUE;
BOOL bStripNewline = TRUE;

int OutputColumn = 0;
int IndentLevel = 0;
BOOL bFirstCharHit = FALSE;
#define INDENTSIZE 4

void SetInternalForwards(void);
BOOL ExtractXpt(char *XptName, char *DllName);
BOOL ExtractExports(void);
BOOL ExtractPpm(char *FileName);
BOOL ExtractTemples(char *FileName);
BOOL ExtractCGenerate(char *pNames);
BOOL ExtractImplib(char *LibName);


char *CopyField(char *pDst, char *pSrc, int Len, char Sep);
void DumpTemplate(PTEMPLES ptpl, FILE *fp);
PTEMPLES GetTemplate(PLIST_ENTRY pHeadList, char *TempleName);
char *CGenerate(char *pSrc, PCGENSTATE pCGenState);
char *CGenerateEx(char *pSrc, PCGENSTATE pCGenState, char *OutBuffer, SIZE_T MaxLen, SIZE_T *BytesReturned);
char *ListApis(char *pSrc, PCGENSTATE pCGenState, BOOL bExports);
char *ListArgs(char *pSrc, PCGENSTATE pCGenState, BOOL Always);
void ProcessTemple(PCGENSTATE pCGenState);
char *IncludeTemplate(char *pSrc, PCGENSTATE pCGenState);
char *IncludeTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bRtoL);
char *MemberTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bBtoT);
char *IfNotRetType(char *pSrc, PCGENSTATE pCGenState);
char *IncludeRetType(char *pSrc, PCGENSTATE pCGenState);
char *WriteMore(char *pSrc, PCGENSTATE pCGenState, BOOL bMore);
BOOL AddToExportsList(PEXPORTSDEBUG pExportsDebug);
PEXPORTSDEBUG FindInExportsList(char *Name);
char *SkipSubExpression(char *pSrc, char **pSubExpression);
PKNOWNTYPES BuildFakeTypesInfo(PEXPORTSDEBUG pExportsDbg, PKNOWNTYPES pKnownTypes);
void WriteListColumn(PCGENSTATE pCGenState);
char *GetAltExportName(char *Buffer, PCGENSTATE pCGenState, int Len);
void BuildArgsList(PTEMPLES pTempleEx, PFUNCINFO funcinfo, PLIST_ENTRY pListHead);
char *IfApiRet(char *pSrc, PCGENSTATE pCGenState);
char *IfApiCode(char *pSrc, PCGENSTATE pCGenState);
char *IfRetType(char *pSrc, PCGENSTATE pCGenState);
char *IfArgs(char *pSrc, PCGENSTATE pCGenState);
void ApiStrings(PCGENSTATE pCGenState);
int GetFuncArgNum(PCGENSTATE pCGenState);
int GetFuncIndex(PCGENSTATE pCGenState, char *FuncTypeName);
char *ListDbgs(char *pSrc, PCGENSTATE pCGenState);
void WriteDbgsStrings(char *pSrc, PCGENSTATE pCGenState);
int GetRetSize(PCGENSTATE pCGenState);
int GetArgSize(PEXPORTSDEBUG ExportDebug);
char *GetOffSet(char *pSrc, char *Buffer);
char *LexMacroArgs(char *pch);
PLIST_ENTRY ListFromTempleType(char *TempleType);
void UseLogMacros(char *pLogName);
char *UpdateLog(char *pSrc, PCGENSTATE pCGenState);
BOOL IsPointerToPtrDep(PARGSLIST pArgsList);
char* ForceTypeExpand( char *pSrc, PCGENSTATE pCGenState);
VOID SetArgListToTypeForArg(PARGSLIST pArgsList, PARGSLIST pArgsListOld, char * pTypeName);

BOOLEAN
IsFastCall(
     PCGENSTATE pCGenState
     );

METHODTYPE
GetX2NMethodType(
     PCGENSTATE pCGenState
     );



char *
GetAddrFirstArg(
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen
      );

PKNOWNTYPES
IsSameType(
     PKNOWNTYPES pktArgs,
     int IndLevel,
     TOKENTYPE tkArgDirection,
     char *tplTypeName,
     int tplIndLevel,
     TOKENTYPE tkTypeDirection,
     BOOL bScanBaseTypes
     );

char *
WriteArgAddr(
      char *pSrc,
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen
      );

BOOL
WriteArgLocal(
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen
       );

BOOL
AddTemple(
    char *TempleType,
    char *TempleName,
    char *Comment,
    char *IndLevel,
    char *pCCode[MAX_CODEBURST],
    TOKENTYPE tkDirection,
    char *Also[MAX_ALSO],
    int AlsoCount,
    char *NoType[MAX_NOTYPE],
    int NoTypeCount,
    PLIST_ENTRY pCaseList
    );


int
GetCodeBurstIndex(
    char *BurstName
    );

int
GetExistingCodeBurstIndex(
    char *BurstName
    );

BOOLEAN
ExpandMacro(
    char *MacroName,
    PCGENSTATE pCGenState,
    char **ppIn,
    char *OutBuffer,
    SIZE_T MaxLen,
    SIZE_T *BytesReturned
    );

BOOLEAN
TempleHasNoCodeBursts(
    PTEMPLES pTemple
    );

void
PlatformSwitchStart(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

void
PlatformSwitchEnd(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

void
PlatformSwitchEndTable(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

char *
ExtractBoolean1(
    char *pSrc, 
    PCGENSTATE pCGenState,
    BOOLEAN *result
    );

char *
ExtractBoolean2(
    char *pSrc, 
    PCGENSTATE pCGenState,
    BOOLEAN *result1,
    BOOLEAN *result2
    );

void
WriteBoolean (
    char *pSrc,
    BOOL Value	
    );


char *CPlatformSwitches[] = { "",
                              "(%s==0x0400)",
                              "(%s>0x0400)",
                              "(%s>=0x0400)" };
char *AsmPlatformSwitches[] = { "",
                                "(%s_ASM EQ 0400h)",
                                "(%s_ASM GT 0400h)",
                                "(%s_ASM GE 0400h)" };

BOOL
ExpandTemple(PTEMPLES ptpl,
             int CodeBurstIndex,
             PCGENSTATE pCGenState) 
{

   PLIST_ENTRY pOldCaseList;
   PTEMPLES    pOldCurrentTemple;
   char *pSrc = ptpl->CodeBurst[CodeBurstIndex];

   if (NULL == pSrc) {
      return FALSE;
   }  
 
   pSrc = ptpl->CodeBurst[CodeBurstIndex];
      
   while (*pSrc && !isgraph(*pSrc)) {
       pSrc++;
   }
   
   if ('\0' == *pSrc) {
       return FALSE;
   }
      
   //
   // Expand the type here

   pOldCurrentTemple = pCGenState->CurrentTemple;
   pOldCaseList = pCGenState->pCaseList;

   if(ptpl->pCaseList != NULL &&
      !IsListEmpty(ptpl->pCaseList)) {
           
       pCGenState->pCaseList = ptpl->pCaseList;
   }

   pCGenState->CurrentTemple = ptpl;
   CGenerate(pSrc, pCGenState);

   pCGenState->CurrentTemple = pOldCurrentTemple;
   pCGenState->pCaseList = pOldCaseList;

   return TRUE;

}

PVOID CheckHeapAlloc(SIZE_T Size) {
   PVOID pMem;

   pMem = GenHeapAlloc(Size);
   if(NULL == pMem) {
       DbgPrintf("Error: Out of Memory!\n");
       DebugBreak();
       ExitErrMsg(FALSE, "Error: Out of Memory!\n");
   }
   return pMem;
}

typedef struct _StringListEntry {
    LIST_ENTRY ListEntry;
    PSTR pStr;
} STRINGLISTENTRY, *PSTRINGLISTENTRY;

VOID
FreeMacroArgsList(PMACROARGSLIST pArgs) {
   SIZE_T c;
   for(c=0; c < (SIZE_T)pArgs->NumArgs; c++) {
      GenHeapFree(pArgs->ArgText[c]);
   }
   GenHeapFree(pArgs);
}

char *
CArg(
    char *pSrc,
    PCGENSTATE pCGenState,
    PSTR *pBuffer,
    BOOL TestExistOnly
    )
{
    int i;
    int ArgNum;
    CHAR s[MAX_PATH];
    PCHAR pResult;
    PMACROARGSLIST pList = pCGenState->pCaseArgsList;
    PCHAR pCommandName = TestExistOnly ? szCARGEXIST : szCARG;

    if (!pList) {
        ExitErrMsg(FALSE, "%s(%d) %s unexpected: no case is currently being applied\n", 
                   TemplateFileName, TemplateLine, pCommandName);
        return NULL;
    }

    if (*pSrc != '(') {
        ExitErrMsg(FALSE, "%s(%d) %s Incorrect parameter %s\n", 
                   TemplateFileName, TemplateLine, pCommandName, pSrc);
        return NULL;
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < sizeof(s)-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    ArgNum = atoi(s);
    pSrc++;     // skip ')'

    if (ArgNum-- == 0) {
        ExitErrMsg(FALSE, "%s(%d) Invalid %s parameter %s\n", TemplateFileName, TemplateLine, 
                   pCommandName, s);
        return NULL;
    }

    if (TestExistOnly) {
       pResult = (ArgNum >= pList->NumArgs) ? "0" : "1";  
    }
    else {
        if (ArgNum >= pList->NumArgs) { 
            ExitErrMsg(FALSE, "%s(%d) Case only has %d arguments\n", TemplateFileName, TemplateLine, pList->NumArgs);
            return NULL; 
        }
        pResult = pList->ArgText[ArgNum];
    }
    if (pBuffer != NULL) {
        *pBuffer = pResult;
    }
    else {
        CGenerate(pResult, pCGenState);
    }
    return pSrc;
}

char *ForCase(char *pSrc, PCGENSTATE pCGenState) {

   PMACROARGSLIST pCaseArgsListOld;
   PLIST_ENTRY pHead, pThis;
   char *pch;
   char *pExpression;
   int OldCaseNumber;

   // Are any cases available for application
   if (pCGenState->pCaseList == NULL ||
       (pCGenState->pCaseList != NULL && IsListEmpty(pCGenState->pCaseList))) {
      //Do nothing
      return SkipSubExpression(pSrc, NULL);
   }

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
      return pch;
   }
   pSrc = pch;
   
   pCaseArgsListOld = pCGenState->pCaseArgsList;
   pHead = pCGenState->pCaseList;
   pThis = pHead->Flink;
   OldCaseNumber = pCGenState->CaseNumber;
   pCGenState->CaseNumber = 0;
   do {
      pCGenState->pCaseArgsList = CONTAINING_RECORD(pThis,MLLISTENTRY,ListEntry)->pMArgs;
      CGenerate(pExpression, pCGenState);
      pThis = pThis->Flink;
      pCGenState->CaseNumber++;
   } while (pThis != pHead );
   pCGenState->CaseNumber = OldCaseNumber;
   pCGenState->pCaseArgsList = pCaseArgsListOld;

   return pSrc;
}

PCHAR 
ParseMacroArgs(IN PCHAR pch,
               IN SIZE_T maxlen,
               OUT PMACROARGSLIST *ppMArgsList
               )
{
   PMACROARGSLIST pMArgsList = NULL;
   LIST_ENTRY ArgsList;
   PCHAR pl;
   int ArgCount=0;
   int ParenDepth=0;
   SIZE_T len = 0;

   if (maxlen == 0) {
      len = MAXUINT_PTR;
   }

   InitializeListHead(&ArgsList);

   if (*pch != '(') {
      ExitErrMsg(FALSE, "ParseMacroArgs: Expected to find ( for args list\n");
   }

   pch++;
   ParenDepth++;
   len++;

   while(ParenDepth > 0) {
      
      pl = pch;

      while(1) {
         if('\0' == *pl || len > maxlen) {
            ExitErrMsg(FALSE, "ParseMacroArgs: Unmatched paren for args list\n");
         }

         if (*pl == '(') {
            ParenDepth++;
         }

         else if (*pl == ')') {
            ParenDepth--;
         }

         if (ParenDepth == 0 || 
             (ParenDepth == 1 && *pl == ',')) {
            PSTRINGLISTENTRY pSl;
            pSl = CheckHeapAlloc(sizeof(STRINGLISTENTRY));
            pSl->pStr = CheckHeapAlloc(pl - pch + 1);
            memcpy(pSl->pStr, pch, pl - pch);
            pSl->pStr[pl - pch] = '\0';
            InsertTailList(&ArgsList, &(pSl->ListEntry));

            ArgCount++;
            pch = pl + 1;
            if (ParenDepth == 0) {
               // No more arguments
               goto Exit;
            }
            else {
               // Do next argument
               break;
            }
         }

         pl++;

      }

   }
Exit:
   pMArgsList = CheckHeapAlloc(sizeof(MACROARGSLIST) + sizeof(LPSTR) * ArgCount);
   pMArgsList->NumArgs = ArgCount;
   for(ArgCount = 0; ArgCount < pMArgsList->NumArgs; ArgCount++) {
      PSTRINGLISTENTRY pSl;
     
      pSl = CONTAINING_RECORD(ArgsList.Flink,STRINGLISTENTRY,ListEntry);
      RemoveHeadList(&ArgsList);

      pMArgsList->ArgText[ArgCount] = pSl->pStr;
      GenHeapFree(pSl);
   }

   *ppMArgsList = pMArgsList;
   return pch;
}

void ExtractServicesTab(char *pch);
/* main
 *
 * standard win32 base windows entry point
 * returns 0 for clean exit, otherwise nonzero for error
 *
 *
 * ExitCode:
 *  0       - Clean exit with no Errors
 *  nonzero - error ocurred
 *
 */
int __cdecl main(int argc, char **argv)
{
   int   i;
   DWORD dw;
   char *pch;
   CGENSTATE CGenState;
   PLIST_ENTRY Next;
   BOOL bUseServicesTab = FALSE;

   // init the lists
   InitializeListHead(&TypeTempleList);
   InitializeListHead(&FailTempleList);
   InitializeListHead(&CodeTempleList);
   InitializeListHead(&IFuncTempleList);
   InitializeListHead(&EFuncTempleList);
   InitializeListHead(&EFastTempleList);
   InitializeListHead(&CGenerateList);
   InitializeListHead(&ExportsList);
   InitializeListHead(&DebugStringsList);
   InitializeListHead(&MacroList);
   NumDebugStringsEntries = 0;
   BeginCBI = GetCodeBurstIndex(szCGENBEG);    // Preload 'Begin=' as a valid codeburst


   SetConsoleCtrlHandler(ConsoleControlHandler, TRUE);


   /*try*/ {


       /*
        *  Get cmd line args.
        */
       i = 0;
       while (++i < argc)  {
            pch = argv[i];
            if (*pch == '-' || *pch == '/') {
                pch++;
                switch (toupper(*pch)) {
                   case 'D':
                      bDebug = TRUE;
                      setvbuf(stderr, NULL, _IONBF, 0);
                      break;

                   case 'F':
                      bExitClean = FALSE;
                      break;
                     
                   case 'T':  // template file name
                      if (!ExtractTemples(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractTemples failed %s\n", pch);
                          }

                      break;

                   case 'C':  //cgenerate "-cOutputFileName[,CppOutputFileName]:TemplateName"
                      if (!ExtractCGenerate(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractCGenerate failed %s\n", pch);
                          }

                      break;

                   case 'M':   // ppm file name (only 1 expected!)
                      if (FuncsList) {
                          ExitErrMsg(FALSE, "ExtractPpm only one Ppm file allowed %s\n", pch);
                          }

                      if (!ExtractPpm(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractPpm failed %s\n", pch);
                          }

                      break;
                   case 'S':   //use a services.tab instead of an exports list
                      bUseServicesTab = TRUE;
                      ExtractServicesTab(pch+1);
                      break;
                   case 'E':   // xpt list for exports "-eExportListName"
                      dw = GetFullPathName(pch+1,
                                           sizeof(XptName) - 1,
                                           XptName,
                                           &XptBaseName
                                           );
                      if (!dw || dw >= sizeof(XptName) - 1) {
                          ExitErrMsg(FALSE, "Invalid XptName %s\n", pch);
                          }

                      break;

                   case 'X':  // Enable exports from implib, -eXptName assumed
                      bUseExpListAndImplib = TRUE;
                      break;

                   case 'I':   // implib file name "-iImplibName"
                      dw = GetFullPathName(pch+1,
                                           sizeof(ImplibName) - 1,
                                           ImplibName,
                                           &ImplibBaseName
                                           );
                      if (!dw || dw >= sizeof(ImplibName) - 1) {
                          ExitErrMsg(FALSE, "Invalid Import Library Name %s\n", pch);
                          }
                      break;

                   case 'L':   // Disable fuzzy logic symbol name matching
                      bNoFuzzyLogic = TRUE;
                      break;

                   case 'W':   // warn about unthunked structures containing function ptrs
                      bWarnAboutNestedFuncPtrs = TRUE;
                      break;

                   case 'U':   // [U]se direction information (__in, __out)
                      bUseDirection = FALSE;    // turn it off
                      break;

                   case 'K':    // generate chec[K] file from @Log() macros
                      UseLogMacros(pch+1);
                      break;

                   case 'N':    // specify explicit DLL base name
                      strncpy(DllBaseName, pch+1, MAX_PATH);
                      break;

                   default:
                      ExitErrMsg(FALSE, "Unrecognized option %s\n", pch);
                   }
                }
            else if (*pch) {

                dw = GetFullPathName(pch,
                                    sizeof(DllName) - 1,
                                    DllName,
                                    &DllBaseName
                                    );
                if (!dw || dw >= sizeof(DllName) - 1) {
                     ExitErrMsg(FALSE, "Invalid DllName %s\n", pch);
                     }

                }
            }

       if(!bUseServicesTab) {

         //
         // MapView of importlib and dll into memory and
         // set up global variables for easy access
         //

         if (ImplibName[0]) {
            if (!MapViewImplib(ImplibName)) {
                  ExitErrMsg(FALSE, "Couldn't open import lib '%s'\n", ImplibName);
            }
         }

         if (DllName[0]) {
            if (!MapViewDll(DllName)) {
               ExitErrMsg(FALSE, "Couldn't open DLL '%s'\n", DllName);
            }
         }



         //
         // Extract exports using dll and implib.
         //

         if (DllName[0] && (!XptName[0] || bUseExpListAndImplib)) {

           // Insist that we have both an implib and a dll.
           if ((DllName[0] && !ImplibName[0]) || (ImplibName[0] && !DllName[0])) {
                ExitErrMsg(FALSE, "DllName or ImplibName missing\n");
           }

           if (!ExtractExports()) {
               ExitErrMsg(FALSE, "Failed to get exports for <%s>\n", DllName);
           }

         }

         //
         // Extract exports from the api list
         //

         if (XptName[0]) {
            if (!ExtractXpt(XptName, DllName)) {
               ExitErrMsg(FALSE, "Failed to get exports for <%s>\n", XptName);
            }
         }
       }

       //
       // Set Internal forwards.
       //
       SetInternalForwards();


       Next = CGenerateList.Flink;
       while (Next != &CGenerateList) {

           memset(&CGenState, 0, sizeof(CGenState));

           CGenState.CGen = CONTAINING_RECORD(Next,CGENERATE,CGenerateEntry);

           ProcessTemple(&CGenState);

           DelOpenFile(CGenState.CGen->fp, NULL);
           fclose(CGenState.CGen->fp);

           Next= Next->Flink;
           }
       }
     /*except(EXCEPTION_EXECUTE_HANDLER) {
       ExitErrMsg(FALSE,
                  "ExceptionCode=%x\n",
                  GetExceptionCode()
                  );
       }*/

   CloseOpenFileList(FALSE);
   return 0;
}


int
GetCodeBurstIndex(
    char *BurstName
    )
/*++

Routine Description:

    Given a name of a 'foo='  (ie. "foo"), return its index in the array
    of codebursts.  If there is no 'foo=' on file, add it.

Arguments:

    BurstName   - name of codeburst to get/add.

Return Value:

    Index into template->CodeBursts[], or calls ExitErrMsg() on error.

--*/
{
    int i;
    int FirstFree = -1;

    if (strcmp(BurstName, "CGenBegin") == 0) {
        // Compatibility:  Accept 'CGenBegin' as 'Begin'
        return BeginCBI;
    }

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (CodeBursts[i].Name) {
            if (strcmp(BurstName, CodeBursts[i].Name) == 0) {
                return i;
            }
        } else {
            if (FirstFree == -1) {
                FirstFree = i;
            }
        }
    }

    if (FirstFree == -1) {
        if (TemplateFileName) {
            ExitErrMsg(FALSE,
                   "%s(%d) Cannot specify more than %d unique codeburst names (%s)",
                   TemplateFileName, TemplateLine,
                   MAX_CODEBURST, BurstName
                  );
        } else {
            ExitErrMsg(FALSE,
                   "Cannot specify more than %d unique codeburst names (%s)",
                   MAX_CODEBURST, BurstName
                  );
        }
    }

    i = strlen(BurstName)+1;

    CodeBursts[FirstFree].Name = GenHeapAlloc(i);
    if (!CodeBursts[FirstFree].Name) {
        ExitErrMsg(TRUE, "Out of memory in GetCodeBurstIndex");
    }
    memcpy(CodeBursts[FirstFree].Name, BurstName, i);

    return FirstFree;
}


int
GetExistingCodeBurstIndex(
    char *BurstName
    )
/*++

Routine Description:

    Given a name of a 'foo='  (ie. "foo"), return its index in the array
    of codebursts.  If there is no 'foo=' on file, call ExitErrMsg().

Arguments:

    BurstName   - name of codeburst to get.

Return Value:

    Index into template->CodeBursts[], or -1 on error.

--*/
{
    int i;

    if (strcmp(BurstName, "CGenBegin") == 0) {
        // Compatibility:  Accept 'CGenBegin' as 'Begin'
        return BeginCBI;
    }

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (CodeBursts[i].Name) {
            if (strcmp(BurstName, CodeBursts[i].Name) == 0) {
                return i;
            }
        }
    }

    return -1;
}


PKNOWNTYPES
GetApiTypes(
    PEXPORTSDEBUG ExportsDbg
    )
{
    PKNOWNTYPES ApiTypes;
    char *ExpName;
    char *pch;

    ExpName = ExportsDbg->IntForward ? ExportsDbg->IntForward->ExportName
                                     : ExportsDbg->ExportName;


    //
    // Look in the FakeFuncsLIst, and the FuncsList.
    //

    ApiTypes = GetNameFromTypesList(&FakeFuncsList, ExpName);
    if (!ApiTypes) {
        ApiTypes = GetNameFromTypesList(FuncsList, ExpName);
        }


    //
    // If export is a decorated name then lets see if we have
    // a func that matches the undecorated name
    //

    if (!ApiTypes) {
        pch = strchr(ExpName, '@');
        if (pch) {
            *pch = '\0';
            ApiTypes = GetNameFromTypesList(&FakeFuncsList, ExpName);
            if (!ApiTypes) {
                ApiTypes = GetNameFromTypesList(FuncsList, ExpName);
                }
            *pch = '@';
            }
        }

    if (!ApiTypes && ExportsDbg->Data) {
        ApiTypes = GetNameFromTypesList(TypeDefsList, "PVOID");
        }

    else
    {

        if (!ApiTypes || !ApiTypes->pfuncinfo) {
            ApiTypes = BuildFakeTypesInfo(ExportsDbg, ApiTypes);
            }

        if (!ApiTypes->pktRet) {
            // Get KnownTypes info for Return Type
            PKNOWNTYPES pkt;

            ResetLexer();
            LexMacroArgs(ApiTypes->FuncRet);
            ConsumeConstVolatileOpt();

            if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
                CurrentTokenIndex = 0;
                if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {
                    ExitErrMsg(FALSE, "GetApiTypes: Undefined return type %s\n", ApiTypes->FuncRet);
                }
            }
            ApiTypes->pktRet = pkt;
        }
    }

    return ApiTypes;

}






/*
 * ProcessTemple
 */
void ProcessTemple(PCGENSTATE pCGenState)
{
    PLIST_ENTRY Next;
    PTEMPLES pTemple;
    PTEMPLES pTempleEx;
    int i;

    pTemple = GetTemplate(&CodeTempleList, pCGenState->CGen->TempleName);
    if (pTemple) {
        fprintf(pCGenState->CGen->fp,
                "%s CodeTemplate:%s\n",
                pTemple->Comment,
                pTemple->Name
                );
        pCGenState->Temple = pTemple;
        ExpandTemple(pCGenState->Temple, pCGenState->CodeBurstIndex, pCGenState); 
    } else if (pTemple = GetTemplate(&IFuncTempleList,
                                    pCGenState->CGen->TempleName
                                    )) {
        pCGenState->ApiNum = 0;
        Next = ExportsList.Flink;
        while (Next != &ExportsList) {
            BYTE ApiPlatform;

            pCGenState->ExportsDbg = CONTAINING_RECORD(Next,
                                                       EXPORTSDEBUG,
                                                       ExportsDbgEntry
                                                       );

            //
            // Switch this API in or out depending on the platform info
            //
            ApiPlatform = pCGenState->ExportsDbg->ApiPlatform;
            pCGenState->Temple = pTemple;
            PlatformSwitchStart(pCGenState, ApiPlatform);

            pCGenState->ApiTypes = GetApiTypes(pCGenState->ExportsDbg);

            //
            // Use exception template for this api if there is one
            //
            pTempleEx = GetTemplate(&EFuncTempleList,
                                    pCGenState->ExportsDbg->ExportName
                                    );
            pCGenState->TempleEx = pTempleEx;
            if (pTempleEx) {
                pCGenState->ExTemplate = TRUE;
            } else {
                pCGenState->ExTemplate = FALSE;
            }

            if (pTempleEx && (pTempleEx->CodeBurst[BeginCBI] || TempleHasNoCodeBursts(pTempleEx))) {

                pCGenState->Temple = pTempleEx;
                fprintf(pCGenState->CGen->fp,
                        "%s Func Template:%s\n",
                        pTempleEx->Comment,
                        pTempleEx->Name
                        );

                 if (TempleHasNoCodeBursts(pTempleEx)) {
                    // skip this API:  ex template, but not code at all
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluded Api %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                }
            } else {
                // no ex template

                pCGenState->Temple = pTemple;

                if (pCGenState->ExportsDbg->Data) {
                    // DATA export - skip the API
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluded Data Export %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                } else if (!pCGenState->ApiTypes->pfuncinfo) {
                    // members unknown - skip the API
                    ExitErrMsg(FALSE, 
                               "API %s has no function prototype - unable to generate code.", 
                               pCGenState->ExportsDbg->ExportName
                              );
                } else if (!iHandleCpp && pCGenState->ExportsDbg->CplusDecoration) {
                    // CPP export and we aren't set up for CPP exports
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluding CPP Api: %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                }
            }

               //
               // skip this api if:
               // - external forward reference
               // - internal forward which does not define the fn
               //
               //
            if ( (pCGenState->ExportsDbg->ExtForward ||
                      (pCGenState->ExportsDbg->IntForward &&
                       pCGenState->ExportsDbg->IntForward != pCGenState->ExportsDbg))) {
               fprintf(pCGenState->CGen->fp,
                        "%s %s forwarded to %s\n",
                       pCGenState->Temple->Comment,
                       pCGenState->ExportsDbg->ExportName,
                       pCGenState->ExportsDbg->ExtForward
                          ? pCGenState->ExportsDbg->ExtForward
                          : pCGenState->ExportsDbg->IntForward->ExportName
                       );

               if (pTempleEx) {
                  fprintf(pCGenState->CGen->fp,
                          "%s WARNING: forwarded function has an exception template\n",
                          pCGenState->Temple->Comment,
                          pTempleEx->Name
                         );
               }

            } else {    // gen code for this api
                PLIST_ENTRY NextArg;
                PARGSLIST   pArgsList;

                BuildArgsList(pTempleEx,
                              pCGenState->ApiTypes->pfuncinfo,
                              &pCGenState->ExportsDbg->ArgsListHead
                              );

                if (GetArgSize(pCGenState->ExportsDbg) < 0) {
                    ExitErrMsg(FALSE, 
                               "API %s has no function prototype - unable to generate code.", 
                               pCGenState->ExportsDbg->ExportName
                              );
                } else {

                    ExpandTemple(pCGenState->Temple, BeginCBI, pCGenState);

                    //
                    // Dump warnings about unthunked parameters which 
                    // contain nested function pointers.
                    //
                    if (bWarnAboutNestedFuncPtrs && !pTempleEx) {
                        int ArgNum = 1;
                        NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;

                        while (NextArg != &pCGenState->ExportsDbg->ArgsListHead) {
                           pArgsList = CONTAINING_RECORD(NextArg,
                                                         ARGSLIST,
                                                         ArgumentsEntry
                                                         );
                           if (pArgsList->fRequiresThunk) {
                                //
                                // The argument contained a nested function
                                // pointer, and nothing thunked that
                                // function pointer.  Warn about a potential
                                // bug.
                                //
                                fprintf(pCGenState->CGen->fp,
                                    "// *** WARNING: Arg %d: type '%s' contains an unthunked function pointer ***\n",
                                    ArgNum,
                                    pArgsList->Type
                                    );
                            }
                            NextArg = NextArg->Flink;
                            ArgNum++;
                        }
                    }

                    //
                    // clean up pArgsList->LocalVar and ArgHostName
                    //
                    NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;
                    while (NextArg != &pCGenState->ExportsDbg->ArgsListHead) {
                       pArgsList = CONTAINING_RECORD(NextArg,
                                                     ARGSLIST,
                                                     ArgumentsEntry
                                                     );
                       if (pArgsList->ArgLocal) {
                           GenHeapFree(pArgsList->ArgLocal);
                           pArgsList->ArgLocal = NULL;
                           }
                       if (pArgsList->HostCastedName) {
                          GenHeapFree(pArgsList->HostCastedName);
                          pArgsList->HostCastedName = NULL;
                       }

                       NextArg = NextArg->Flink;
                       }

                    pCGenState->ApiNum++;
                    }
                }

SkipGen:
            //
            // End switching this API in or out depending on the platform info
            //
            ApiPlatform = pCGenState->ExportsDbg->ApiPlatform;
            PlatformSwitchEnd(pCGenState, ApiPlatform);

            Next= Next->Flink;
        }
    } else {
        ExitErrMsg(FALSE,
                   "%s,%s:%s Template undefined\n",
                   pCGenState->CGen->FileNameC,
                   pCGenState->CGen->FileNameCpp ? pCGenState->CGen->FileNameCpp : "",
                   pCGenState->CGen->TempleName
                   );
    }
}


void
PlatformSwitchStart(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    BOOL fIsAsm;

    if (ApiPlatform == API_ALL) {
        return;
    }

    //
    // Switch this API in or out depending on the platform info
    //      00: don't emit anything
    //      01: emit "== 0x0400"
    //      10: emit "> 0x0400"
    //      11: emit ">= 0x0400"
    //
    if (!pCGenState->Temple || !pCGenState->Temple->Comment) {
        fIsAsm = FALSE;
    } else {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fIsAsm = TRUE;
        } else {
            fIsAsm = FALSE;
        }
    }

    if (fIsAsm) {
        fprintf(pCGenState->CGen->fp, "\nif ");
    } else {
        fprintf(pCGenState->CGen->fp, "\n#if ");
    }

    if (ApiPlatform & API_WIN9x) {
        BYTE Plat = (ApiPlatform & API_WIN9x) >> API_SHIFT_WIN9x;

        fprintf(pCGenState->CGen->fp,
                (fIsAsm) ? AsmPlatformSwitches[Plat] : CPlatformSwitches[Plat],
                "_WIN32_WINDOWS"
                );
    }

    if ((ApiPlatform & API_WIN9x) && (ApiPlatform & API_NTx)) {
        // API is on some flavor of Win9x and some NTx flavor
        fprintf(pCGenState->CGen->fp, (fIsAsm) ? " OR " : " || ");
    }

    if (ApiPlatform & API_NTx) {
        BYTE Plat = (ApiPlatform & API_NTx) >> API_SHIFT_NTx;

        fprintf(pCGenState->CGen->fp,
                (fIsAsm) ? AsmPlatformSwitches[Plat] : CPlatformSwitches[Plat],
                "_WIN32_WINNT"
                );
    }

    if (pCGenState->ListCol) {
        WriteListColumn(pCGenState);
    } else {
        fprintf(pCGenState->CGen->fp, "\n");
    }

}



void
PlatformSwitchEnd(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    if (ApiPlatform != API_ALL) {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fprintf(pCGenState->CGen->fp, "\nendif ; _WIN32_WIN...\n");
        } else {
            fprintf(pCGenState->CGen->fp, "\n#endif // _WIN32_WIN...\n");
        }
        if (pCGenState->ListCol) {
            WriteListColumn(pCGenState);
        } else {
            fprintf(pCGenState->CGen->fp, "\n");
        }
    }
}

void
PlatformSwitchEndTable(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    if (ApiPlatform != API_ALL) {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fprintf(pCGenState->CGen->fp, "\nendif ; _WIN32_WIN...\n");
        } else {
       fprintf(pCGenState->CGen->fp, "\n#else\n     {whInvalidCall, 0, 0},");
            fprintf(pCGenState->CGen->fp, "\n#endif // _WIN32_WIN...\n");
        }
        if (pCGenState->ListCol) {
            WriteListColumn(pCGenState);
        } else {
            fprintf(pCGenState->CGen->fp, "\n");
        }
    }
}

/*
 *  BuildArgsList
 *
 *
 */
void BuildArgsList(PTEMPLES pTempleEx, PFUNCINFO funcinfo, PLIST_ENTRY pListHead)
{
    int  i;
    ULONG Size;
    int OffSet=0;
    int ArgOffSet;
    PKNOWNTYPES pkt;
    PARGSLIST pArgsList;
    int NoTypeCount;
    char *HostCastedName;

    if (!IsListEmpty(pListHead)) {
        return;
    }

    if (!pTempleEx) {
        NoTypeCount = 0;
    } else {
        //
        // There is an [EFunc] for this API.  Get the count of
        // NoType= entries for the EFunc.
        //
        for (NoTypeCount=0; NoTypeCount<MAX_NOTYPE; ++NoTypeCount) {
            if (!pTempleEx->NoTypes[NoTypeCount]) {
                break;
            }
        }
    }

    while (funcinfo) {
        pkt = GetNameFromTypesList(TypeDefsList, funcinfo->sType);
        if (!pkt) {
            pkt = GetNameFromTypesList(StructsList, funcinfo->sType);
            if (!pkt) {
                ExitErrMsg(FALSE, "Unknown type %s\n", funcinfo->sType);
            }
        }

        //
        // Save the ArgOffSet, and add the args size to the cumulative
        // offset for the next argument.
        //
        // Round up the arg size to the next dword. Assumes intel stack
        // parameter passing conventions, and that all pointers are
        // sizeof(int *) except __ptr64 which are sizeof(PVOID64).
        //
        ArgOffSet = OffSet;

        Size = funcinfo->IndLevel +
                pkt->IndLevel ?
                funcinfo->fIsPtr64 ?
                  SIZEOFPOINTER64 : SIZEOFPOINTER : pkt->Size;

        OffSet += ((Size + 3) & ~3) >> 2;

        //
        // Create ARGSLIST entry, and add it to the list
        //
        pArgsList = GenHeapAlloc(sizeof(ARGSLIST));
        if (!pArgsList) {
            ExitErrMsg(TRUE, "bal.\n");
        }
        memset(pArgsList, 0, sizeof(ARGSLIST));

        if(funcinfo->sName == NULL) {
           HostCastedName = GenHeapAlloc(sizeof(szHOSTAPPEND));
           if (NULL == HostCastedName)
              ExitErrMsg(FALSE, "Out of memory in BuildArgsList\n");
           strcpy(HostCastedName, szHOSTAPPEND);
        }
        else {
           HostCastedName = GenHeapAlloc(sizeof(szHOSTAPPEND) + strlen(funcinfo->sName));
           if (NULL == HostCastedName)
              ExitErrMsg(FALSE, "Out of memory in BuildArgsList\n");
           strcpy(HostCastedName, funcinfo->sName);
           strcat(HostCastedName, szHOSTAPPEND);
        }

        pArgsList->pKnownTypes = pkt;
        pArgsList->OffSet      = ArgOffSet;
        pArgsList->IndLevel    = funcinfo->IndLevel;
        pArgsList->ArgSize     = Size;
        pArgsList->IsPtr64     = funcinfo->fIsPtr64;  
        pArgsList->Mod         = funcinfo->tkPreMod;
        pArgsList->tkDirection = funcinfo->tkDirection;
        pArgsList->SUEOpt      = funcinfo->tkSUE;
        pArgsList->Type        = funcinfo->sType;
        pArgsList->PostMod     = funcinfo->tkPostMod;
        pArgsList->PrePostMod  = funcinfo->tkPrePostMod;
        pArgsList->Name        = funcinfo->sName;
        pArgsList->HostCastedName = HostCastedName;
        pArgsList->fIsMember   = FALSE;
        pArgsList->bIsBitfield = FALSE;        
        pArgsList->BitsRequired= 0;       
        pArgsList->bIsArray    = FALSE;           
        pArgsList->ArrayElements=0;

        if (pkt->Flags & BTI_CONTAINSFUNCPTR) {
            //
            // This parameter type is either a function pointer, or
            // a type which contains an embedded function pointer.
            // Something is going to have to thunk it.
            //
            pArgsList->fRequiresThunk = TRUE;
        }

        if (pTempleEx) {
            //
            // There is an [EFunc] for this API.  See if this param
            // should have [Types] templates expanded or not.
            //
            for (i=0; i<NoTypeCount; ++i) {
                if (pTempleEx->NoTypes[i] &&
                    strcmp(pArgsList->Name, pTempleEx->NoTypes[i]) == 0) {
                    //
                    // This param is not supposed to have [Types] expanded
                    //
                    pArgsList->fNoType = TRUE;
                    pTempleEx->NoTypes[i] = NULL;
                }
            }
        }


        InsertTailList(pListHead, &pArgsList->ArgumentsEntry);

        //
        // and on to the next argument .....
        //
        funcinfo = funcinfo->pfuncinfoNext;
    }

    if (pTempleEx) {
        //
        // For error reporting, indicate any NoTypes= that did not match
        // a param name
        //
        for (i=0; i<NoTypeCount; ++i) {
            if (pTempleEx->NoTypes[i]) {
                ExitErrMsg(FALSE, "[EFunc] %s(%x) has a 'NoType=%s' which does not correspond to an argument name\n", pTempleEx->Name, pTempleEx, pTempleEx->NoTypes[i]);
            }
        }
    }

    return;
}


//
// return pointer to type of first argument
char *NArgType(PCGENSTATE pCGenState, char *s, int iLen, char **ppSrc)
{
    PARGSLIST pArgsList;
    PLIST_ENTRY Next;
    char *pch = s;
    CGENSTATE CGenState;
    int Len, i;
    char *pSrc;

    pSrc = *ppSrc;
    if (*pSrc != '(') {
        ErrMsg("Incorrect NArgType parameter %s\n", pSrc);
        fprintf(pCGenState->CGen->fp, "** ERROR ** Incorrect NArgType parameter %s\n", pSrc);
        return NULL;
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < iLen-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    *ppSrc = ++pSrc;
    Len = atoi(s);

    if (Len-- == 0) {
        ErrMsg("Invalid NArgType parameter %s\n", s);
        fprintf(pCGenState->CGen->fp, "** ERROR ** Invalid NArgType parameter %s\n", s);
        return NULL;
    }


    if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
        fprintf(pCGenState->CGen->fp,
                "\n\t*** ERROR ***\n*** NArgType Missing argument List: %s\n\n",
                pCGenState->ApiTypes->TypeName
                );

        return NULL;
    }

    Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

    // check for void arg list
    pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
    if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
        return NULL;
    }

    CGenState = *pCGenState;

    for (i = 0; (i < Len) && (Next != &CGenState.ExportsDbg->ArgsListHead); i++) {
        Next= Next->Flink;
    }
    if (Next == &CGenState.ExportsDbg->ArgsListHead) {
        ErrMsg("NArgType parameter out of range %d\n", Len);
        fprintf(pCGenState->CGen->fp, "** ERROR ** NArgType parameter out of range %d\n", Len);
        return NULL;
    }

    CGenState.pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);

    //
    // Copy in the explicit struct/union/enum keyword, if present
    //
    strcat(pch, TokenString[CGenState.pArgsList->SUEOpt]);

    //
    // Copy in the actual typename
    //
    strcpy(pch, CGenState.pArgsList->Type);

    if (CGenState.pArgsList->PrePostMod != TK_NONE) {
        strcat(pch, " ");
        strcat(pch,  TokenString[CGenState.pArgsList->PrePostMod]);
    }
    pch = pch  + strlen(pch);
    if (CGenState.pArgsList->IndLevel) {
        *pch++ = ' ';
        for (i=0; i<CGenState.pArgsList->IndLevel; ++i) {
            *pch++ = '*';
        }
    }
    *pch = '\0';
          
    return(s);
}

//
// return pointer to name of first argument
char *NArgName(PCGENSTATE pCGenState, char *s, int iLen, char **ppSrc)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   char *pch = s;
   CGENSTATE CGenState;
   int Len, i;
   char *pSrc;

   pSrc = *ppSrc;
   if (*pSrc != '(') {
       ErrMsg("Incorrect NArgType parameter %s\n", pSrc);
       fprintf(pCGenState->CGen->fp, "** ERROR ** Incorrect NArgType parameter %s\n", pSrc);
       return(NULL);
       }
       
   pSrc++;
   i = 0;
   while ((*pSrc != ')') && (i < iLen-1)) {
       s[i++] = *pSrc++;
       }
   s[i] = 0;
   *ppSrc = ++pSrc;
   Len = atoi(s);

   if (Len-- == 0) {
       ErrMsg("Invalid NArgType parameter %s\n", s);
       fprintf(pCGenState->CGen->fp, "** ERROR ** Invalid NArgType parameter %s\n", s);
       return(NULL);
       }

   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** NArgType Missing argument List: %s\n\n",
               pCGenState->ApiTypes->TypeName
               );

       return(NULL);
       }

   Next = pCGenState->ExportsDbg->ArgsListHead.Flink;
   
   // check for void arg list
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return(NULL);
       }

   CGenState = *pCGenState;
   
   for (i = 0; (i < Len) && (Next != &CGenState.ExportsDbg->ArgsListHead); i++) {
       Next= Next->Flink;       
       }
   if (Next == &CGenState.ExportsDbg->ArgsListHead) {
       ErrMsg("NArgName parameter out of range %d\n", Len);
       fprintf(pCGenState->CGen->fp, "** ERROR ** NArgName parameter out of range %d\n", Len);
       return(NULL);
       }       
              
   CGenState.pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   
   strcpy(pch, CGenState.pArgsList->Name);
          
   return(s);
}

char *
MArg(
    char *pSrc,
    PCGENSTATE pCGenState,
    PSTR *pBuffer
    )
/*++

Routine Description:

    Expand the n'th argument for the current macro

Arguments:

    pSrc        - pointer to character following 'MArg'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the macro argument

--*/
{
    int i;
    int ArgNum;
    PMACROARGSLIST pList = pCGenState->pMacroArgsList;
    char s[MAX_PATH];
    PMACROARGSLIST OldList;

    if (!pList) {
        ExitErrMsg(FALSE, "%s(%d) MArg unexpected: no macro is currently being expanded\n", TemplateFileName, TemplateLine);
        return NULL;
    }

    if (*pSrc != '(') {
        ExitErrMsg(FALSE, "%s(%d) Incorrect MArg parameter %s\n", TemplateFileName, TemplateLine, pSrc);
        return NULL;
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < sizeof(s)-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    ArgNum = atoi(s);
    pSrc++;     // skip ')'

    if (ArgNum-- == 0) {
        ExitErrMsg(FALSE, "%s(%d) Invalid MArg parameter %s\n", TemplateFileName, TemplateLine, s);
        return NULL;
    }

    if (ArgNum >= pList->NumArgs) {
        ExitErrMsg(FALSE, "%s(%d) Macro only takes %d arguments\n", TemplateFileName, TemplateLine, pList->NumArgs);
        return NULL;
    }

    if (pBuffer == NULL) {
       OldList = pCGenState->pMacroArgsList;
       pCGenState->pMacroArgsList = MacroStack[--MacroStackTop];
       CGenerate(pList->ArgText[ArgNum], pCGenState);
       MacroStack[MacroStackTop++] = pCGenState->pMacroArgsList;
       pCGenState->pMacroArgsList = OldList;    
    }
    else {
       *pBuffer = pList->ArgText[ArgNum];
    }
    return pSrc;
}

char *ArgType(char *Buffer, PCGENSTATE pCGenState) {
   char *pch;
   if (pCGenState->pArgsList) {
        int i;

        pch = Buffer;
        if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
            strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
            strcat(pch, " ");
            pch += strlen(pch);
        }
        strcpy(pch,  pCGenState->pArgsList->Type);
        if (pCGenState->pArgsList->PrePostMod != TK_NONE) {
            strcat(pch, " ");
            strcat(pch,  TokenString[pCGenState->pArgsList->PrePostMod]);
        }
        pch = pch+strlen(pch);
        if (pCGenState->pArgsList->IndLevel) {
            *pch++ = ' ';
            for (i=0; i<pCGenState->pArgsList->IndLevel; ++i) {
                *pch++ = '*';
            }
        }
        *pch = '\0';
        pch = Buffer;
        return pch;
   }
   else 
      return NULL;
}

char *UnalignedTag64(char *Buffer, PCGENSTATE pCGenState) {

    //
    // PUT UNALIGNED TAg for interested type like KLPWST KHBITMAP all kernel mode shareable struct
    //

    char CurrArgType[256];
    if ( NULL == ArgType ( CurrArgType, pCGenState))
        return NULL;
    
    //
    // Now chek the name 
    //

    if ( pCGenState->pArgsList->ArgSize == 8 ) {
        
         //
         // BUGBUG: check if you need special case for KLPWSTR and KHBITMAP
         //         if so put more generic form
         //(strncmp ( CurrAgrType, "KLPWSTR ",7) == 0) || 
         //(strncmp ( CurrAgrType, "KHBITMAP ",8) == 0)
         //

        strcpy (Buffer, "*(UNALIGNED ");
        strcat (Buffer, CurrArgType);
        if (strchr(CurrArgType, '*') == NULL )
            strcat ( Buffer, " ");
        strcat (Buffer, "*)&");
        return Buffer;
    }
    return NULL;

}


char *ArgHostType(char *Buffer, PCGENSTATE pCGenState) {
   char *pch;
   if (pCGenState->pArgsList) {
      int i;
      pch = Buffer;
      /*if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
         strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
         strcat(pch, " ");
         pch += strlen(pch);
      }*/
      if (pCGenState->pArgsList->IndLevel > 0) {
         strcpy(pch, GetHostPointerName(pCGenState->pArgsList->IsPtr64));
         pch += strlen(pch);
      }
      else {
         char Buffer[MAX_PATH];
         strcpy(pch, GetHostTypeName(pCGenState->pArgsList->pKnownTypes, Buffer));
         pch += strlen(pch);
      }
      *pch = '\0';
      pch = Buffer;
      return pch;
   }
   else 
      return NULL;
}

BOOL IsPointer(PCGENSTATE pCGenState) {
    return (pCGenState->pArgsList->IndLevel > 0) || (pCGenState->pArgsList->pKnownTypes->IndLevel > 0);
}

char *ArgTypeInd(char *Buffer, PCGENSTATE pCGenState, BOOL bHostName) {
   
   CGENSTATE GenStateOld;
   ARGSLIST ArgsListOld;
   KNOWNTYPES KnownTypes;
   PKNOWNTYPES pCurrent;
   int IndLevel;
   char *pch;

   //copy over the old structures before mangaling them
   GenStateOld = *pCGenState;
   ArgsListOld = *(pCGenState->pArgsList);
   KnownTypes = *(pCGenState->pArgsList->pKnownTypes);
   pCGenState->pArgsList->pKnownTypes = &KnownTypes;
   
   if (pCGenState->pArgsList->IndLevel > 0) {
      IndLevel = pCGenState->pArgsList->IndLevel - 1;
      goto success;
   }

   pCurrent = &KnownTypes;
   IndLevel = pCurrent->IndLevel;
   if (IndLevel == 0) {
      ErrMsg("ArgTypeInd: Tried to get name of type pointed to by %s\n",pCGenState->pArgsList->Name);
      ExitErrMsg(FALSE, "ArgTypeInd: %s is not a pointer!\n", pCGenState->pArgsList->Name);
   }

   while(1) {//chase all the way down to a struct/union/enum or a func_ptr
      PCHAR IndName; 
      ASSERT(pCurrent != NULL);
      if (pCurrent->IndLevel == 1 && !bHostName && ((IndName = IsDefinedPtrToPtrDependent(pCurrent->TypeName)) != NULL)) {
          PKNOWNTYPES pkt;
          IndLevel--;
          pkt = GetNameFromTypesList(TypeDefsList, IndName);
         
          ASSERT(pkt != NULL);
          KnownTypes = *pkt;
          goto success;
      }      
      else if (pCurrent->pTypedefBase != NULL) {
         pCurrent = pCurrent->pTypedefBase;
      }
      else {
         //hit a struct/union/enum or func_ptr
         KnownTypes = *pCurrent;
         pCGenState->pArgsList->pStructType = NULL;
         pCGenState->pArgsList->SUEOpt = TK_NONE;
         IndLevel--;

         if (pCurrent->Flags & BTI_NOTDERIVED) {
            pCGenState->pArgsList->SUEOpt = TK_NONE;
			  goto success;
         }
         else if(strcmp("struct", KnownTypes.BaseName) == 0) { 
            pCGenState->pArgsList->SUEOpt = TK_STRUCT;
            goto success;
         }
         else if(strcmp("union", KnownTypes.BaseName) == 0) {
            pCGenState->pArgsList->SUEOpt = TK_UNION;
            goto success;
         }
         else if(strcmp("enum", KnownTypes.BaseName) == 0) {
            pCGenState->pArgsList->SUEOpt = TK_ENUM;
            goto success;
         }            
         else {
            ExitErrMsg(FALSE, "ArgTypeInd: Can't determine what %s is.\n", pCGenState->pArgsList->Name);
         }
      }      
   }

success:
   //fake out the typename and the indirection
   KnownTypes.IndLevel = 0;
   pCGenState->pArgsList->IndLevel = IndLevel;
   pCGenState->pArgsList->Type = KnownTypes.TypeName;
   //Print the mangled type, then restore the old type
   if (bHostName) 
      pch = ArgHostType(Buffer, pCGenState);
   else 
      pch = ArgType(Buffer, pCGenState);

   *pCGenState = GenStateOld;
   *(pCGenState->pArgsList) = ArgsListOld;

   return pch;
}

char *ApiName(char *pSrc, char**pch, char *Buffer, PCGENSTATE pCGenState) {
   char *pTemp;
   strcpy(Buffer, pCGenState->ExportsDbg->ExportName);

   // if ApiName has decoration then truncate it
   pTemp = strchr(Buffer, '@');
   if (pTemp) {
      *pTemp = '\0';
   }
   
   *pch = Buffer;
   return pSrc;
}

char *ApiNameSkip(char *pSrc, char**pch, char *Buffer, PCGENSTATE pCGenState) {
   char *pNewSrc, *pTemp, *pEnd;
   int CharsToSkip;
   
   pNewSrc = ApiName(pSrc, pch, Buffer, pCGenState);
   
   pEnd = SkipSubExpression(pNewSrc, NULL);
   if (pNewSrc == pEnd)
      return pNewSrc;

   pTemp = pNewSrc+1;
   CharsToSkip = atoi(pTemp);
   while(**pch != '\0' && CharsToSkip > 0) {
      (*pch)++;
      CharsToSkip--;
   }
   
   return pEnd;

}

BOOL IsPointerToPtrDep(PARGSLIST pArgsList) {
   PKNOWNTYPES pCurrent;

   pCurrent = pArgsList->pKnownTypes;

   if (pArgsList->IndLevel + pCurrent->IndLevel < 1)
      ExitErrMsg(FALSE, "IsPointerToPtrDep: %s is not a pointer\n", pArgsList->Name);
   
   if (pArgsList->IndLevel + pCurrent->IndLevel > 1) {

      // Since pCurrent->IndLevel is acumulative, this can happen if and 
      // only if this type or one of its base types is a pointer to 
      // another pointer.  This case is defined to be pointer dependent.

      return TRUE;
   }

   // At this point, either pArgsList->IndLevel == 1 and pCurrent->IndLevel == 0
   // or pArgsList->IndLevel == 0 and pCurrent->IndLevel = 1.
   // First check if this type is defined to be a pointer to a pointer dependent type.
   // If not, defererence the pointer by walking through typedefs until pCurrent->IndLevel = 0
   // Note that multiple levels of pointers are no longer possible.

   if(IsDefinedPtrToPtrDependent(pCurrent->TypeName)) {
       return TRUE;
   }

   while(pCurrent->IndLevel != 0) {
      
      // Check if this type is one of the special types used
      // between sortpp and genthnk.
  
      if (pCurrent->Flags & BTI_NOTDERIVED) 
	 return FALSE;     

      // Assert that this type is not a struct, union, or enum.
      // This shouldn't happen because sortpp should store
      // these with an indlevel of 0.
 
      ASSERT(strcmp(pCurrent->BaseName, "struct") != 0);
      ASSERT(strcmp(pCurrent->BaseName, "union") != 0);
      ASSERT(strcmp(pCurrent->BaseName, "enum") != 0);

      // Check if this type is a function pointer.  If it is,
      // return FALSE since they are arbitrarly defined to not
      // be pointer dependent.  This may be changed check if any
      // of the arguments to the function pointer are pointer dependent.
   
      if (strcmp(pCurrent->BaseName, "()") == 0) 
	 return FALSE;
  
      // Get the base typedef.
      pCurrent = pCurrent->pTypedefBase;  
   }
   
   // Now that the pointer has been dereferenced, test if 
   // this type is pointer dependent.

   return (pCurrent->Flags & BTI_POINTERDEP) != 0;
}

char *TestIfPointerToPtrDep(char *pSrc, PCGENSTATE pCGenState, PCHAR pch) {

    PCHAR pEnd;
    PMACROARGSLIST pMArgsList;
    ARGSLIST ArgsList;
    CHAR TypeName[MAX_PATH];
    SIZE_T BytesReturned;

    pEnd = SkipSubExpression(pSrc, NULL);
    if (pSrc == pEnd) {
       ExitErrMsg(FALSE, "TestIfPointerToPtrDep: exactly 1 argument is required.\n"); 
    }

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs != 1) {
       ExitErrMsg(FALSE, "IncludeRetTypes: exactly 1 argument is required.\n");
    }
    
    CGenerateEx(pMArgsList->ArgText[0], pCGenState, TypeName, MAX_PATH, &BytesReturned);
    SetArgListToTypeForArg(&ArgsList, &ArgsList, TypeName);
    
    if(IsPointerToPtrDep(&ArgsList)) {
        strcpy(pch, "1");
    }
    else {
        strcpy(pch, "0");
    }
    FreeMacroArgsList(pMArgsList); 
    return pEnd;   
}
 
BOOL IsPtrDep(PARGSLIST pArgsList) {
   //This is a pointer to something(ptr dep.)
   if (pArgsList->IndLevel > 0)
      return TRUE;
   return pArgsList->pKnownTypes->Flags & ( BTI_POINTERDEP | BTI_INT64DEP );
}
BOOL IsInt64DepUnion(PCGENSTATE pCGenState) {

   
   char Buff[256];

   Buff[0]=0;
   ArgTypeInd( Buff, pCGenState, FALSE);

   // make exception for union _ULARGE_INTEGER
   if (strncmp(Buff, "union _ULARGE_INTEGER", sizeof ("union _ULARGE_INTEGER")) == 0 )
        return TRUE; //IsPointerToPtrDep ( pArgsList );
   if (strncmp(Buff, "union _LARGE_INTEGER", sizeof ("union _LARGE_INTEGER")) == 0 )
        return TRUE; //IsPointerToPtrDep ( pArgsList );


   return FALSE; //pArgsList->pKnownTypes->Flags & BTI_INT64DEP;
}

void DoIndent(PCGENSTATE pCGenState) {
	int i;
	for(i=IndentLevel, OutputColumn = 1; i > 0; i--,OutputColumn++) {
		if (fputc(' ', pCGenState->CGen->fp) != ' ')
			ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
		OutputColumn++;
	}
}

char * CGeneratePrintChar(char *pch, PCGENSTATE pCGenState) {
   if (!bStripNewline) {
      if('\n' == *pch)
         OutputColumn = 0; //will be incremented to 1
      goto PrintIt;
   }
   else {
      int i;
      if (*pch == '\n')
         goto SkipIt;
      if (!bFirstCharHit) {
         if(!isspace(*pch)) {
			DoIndent(pCGenState);
            bFirstCharHit = TRUE;
            goto PrintIt;
         }
		 else
			goto SkipIt;
      }
      else
         goto PrintIt;
   }
PrintIt:
   if (fputc(*pch, pCGenState->CGen->fp) != *pch) 
      goto PrintError;
   OutputColumn++;
SkipIt:
   return pch + 1;
PrintError:
   ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
   return NULL;
}

char *CGenerate(char *pSrc, PCGENSTATE pCGenState) {
   return CGenerateEx(pSrc, pCGenState, NULL, 0, NULL);
}

/*
 *  CGenerate
 *
 */
char *CGenerateEx(char *pSrc, PCGENSTATE pCGenState, char *OutBuffer, SIZE_T MaxLen, SIZE_T *BytesReturned)
{
   FILE **pfp = &pCGenState->CGen->fp;
   char *pch;
   int  i;
   size_t Len;
   char Buffer[MAX_PATH*4];
   char *BufferPos = NULL;

   if (OutBuffer != NULL) {
      BufferPos = OutBuffer;
      *BytesReturned = 0;
   }

   while (*pSrc) {
  
       if (OutBuffer != NULL && MaxLen == 0) {
          ExitErrMsg(FALSE, "Out of buffer space!\n");
       }

       if (*pSrc != '@') {
          if (OutBuffer != NULL) {
             *BufferPos++ = *pSrc++;
             *BytesReturned += 1;
             MaxLen--;
          }
          else {
             pSrc = CGeneratePrintChar(pSrc, pCGenState);
          }      
       }
       else if (*(pSrc + 1) == '@') {
          pSrc++;
          if (OutBuffer != NULL) {
             *BufferPos++ = *pSrc++;
             *BytesReturned += 1;
             MaxLen--;
          }
          else {
             pSrc = CGeneratePrintChar(pSrc, pCGenState);
          }
       }
       else {
           pch = NULL;
           memset(Buffer, 0, sizeof(Buffer));
		     pSrc++;    //skip the @ is the command name
           
		     if(bStripNewline && !bFirstCharHit) {
			     OutputColumn = 1 + IndentLevel;
		     }

           if (!strncmp(pSrc, szNL, sizeof(szNL) - 1)) {              
               pSrc += sizeof(szNL) - 1;
               if (fputc('\n', *pfp) != '\n')
                  ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);                 
               OutputColumn = 1;
               bFirstCharHit = FALSE;
           }
           else if (!strncmp(pSrc, szINDENT, sizeof(szINDENT) - 1)) {
               int OldIndent;
               pSrc += sizeof(szINDENT) - 1;
               OldIndent = IndentLevel;
               IndentLevel += INDENTSIZE;
               pSrc = WriteMore(pSrc, pCGenState, TRUE);
               IndentLevel = OldIndent;
           }
           else if (!strncmp(pSrc, szNOFORMAT, sizeof(szNOFORMAT) - 1)) {
              BOOL bOldStripNewline;
			     pSrc += sizeof(szNOFORMAT) - 1;
              bOldStripNewline = bStripNewline;
              bStripNewline = FALSE;
              pSrc = WriteMore(pSrc, pCGenState, TRUE);
              bStripNewline = bOldStripNewline;
           }
           else if (!strncmp(pSrc, szTEMPLATE, sizeof(szTEMPLATE) - 1)) {
               pSrc += sizeof(szTEMPLATE) - 1;
               pSrc = IncludeTemplate(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szAPILIST, sizeof(szAPILIST) - 1)) {
               pSrc += sizeof(szAPILIST) - 1;
               pSrc = ListApis(pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szAPINAMESKIP, sizeof(szAPINAMESKIP) -1 )) {
               pSrc += sizeof(szAPINAMESKIP) - 1;
               pSrc = ApiNameSkip(pSrc, &pch, Buffer, pCGenState);
           }           
           else if (!strncmp(pSrc, szAPINAME, sizeof(szAPINAME) - 1)) {
               pSrc += sizeof(szAPINAME) - 1;
               pSrc = ApiName(pSrc, &pch, Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szAPIFORWARD, sizeof(szAPIFORWARD) - 1)) {
               pSrc += sizeof(szAPIFORWARD) - 1;

               if (pCGenState->ExportsDbg->IntForward) {
                   strcpy(Buffer, szINTFORWARD);
                   strcpy(Buffer + sizeof(szINTFORWARD) - 1,
                          pCGenState->ExportsDbg->IntForward->ExportName
                          );
                   }
               else {
                   strcpy(Buffer, pCGenState->ExportsDbg->ExportName);
                   }

               // if ApiName has decoration then truncate it
               pch = strchr(Buffer, '@');
               if (pch) {
                   *pch = '\0';
                   }

               pch = Buffer;

               }

           else if (!strncmp(pSrc, szAPINUM, sizeof(szAPINUM) - 1)) {
               _itoa(pCGenState->ApiNum, Buffer, 10);
               pch = Buffer;
               pSrc += sizeof(szAPINUM) - 1;
               }
           else if (!strncmp(pSrc, szAPIFNRET, sizeof(szAPIFNRET) - 1)) {
               if (pCGenState->ApiTypes) {
                   pch = pCGenState->ApiTypes->FuncRet;
                   }
               pSrc += sizeof(szAPIFNRET) - 1;
               }
           else if (!strncmp(pSrc, szAPIDECLSPEC, sizeof(szAPIDECLSPEC) - 1)) {
               BOOL b = pCGenState->ApiTypes && (pCGenState->ApiTypes->Flags & BTI_DLLEXPORT);

               pSrc += sizeof(szAPIDECLSPEC) - 1;
               pSrc = WriteMore(pSrc, pCGenState, b);
               }
           else if (!strncmp(pSrc, szAPIFNMOD, sizeof(szAPIFNMOD) - 1)) {
               if (pCGenState->ApiTypes) {
                   pch = pCGenState->ApiTypes->FuncMod;
                   }
               pSrc += sizeof(szAPIFNMOD) - 1;
               }
           else if (!strncmp(pSrc, szAPIMORE, sizeof(szAPIMORE) - 1)) {
               pSrc += sizeof(szAPIMORE) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->MoreApis);
               }
           else if (!strncmp(pSrc, szIFAPIRET, sizeof(szIFAPIRET) - 1)) {
               pSrc += sizeof(szIFAPIRET) - 1;
               pSrc = IfApiRet(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szIFISMEMBER, sizeof(szIFISMEMBER) - 1)) {
               pSrc += sizeof(szIFISMEMBER) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->fIsMember);
           }
           else if (!strncmp(pSrc, szIFNISMEMBER, sizeof(szIFNISMEMBER) - 1)) {
              pSrc += sizeof(szIFNISMEMBER) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->fIsMember));
           }
           else if (!strncmp(pSrc, szIFISBITFIELD, sizeof(szIFISBITFIELD) - 1)) {
               pSrc += sizeof(szIFISBITFIELD) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->bIsBitfield);
           }
           else if (!strncmp(pSrc, szIFNISBITFIELD, sizeof(szIFNISBITFIELD) - 1)) {
              pSrc += sizeof(szIFNISBITFIELD) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->bIsBitfield));
           }
           else if (!strncmp(pSrc, szIFISARRAY, sizeof(szIFISARRAY) - 1)) {
               pSrc += sizeof(szIFISARRAY) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->bIsArray);
           }
           else if (!strncmp(pSrc, szIFNISARRAY, sizeof(szIFNISARRAY) - 1)) {
              pSrc += sizeof(szIFNISARRAY) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->bIsArray));
           }
           else if (!strncmp(pSrc, szARGARRAYELEMENTS, sizeof(szARGARRAYELEMENTS) - 1)) {
              pSrc += sizeof(szARGARRAYELEMENTS) - 1;
              _itoa((int)(pCGenState->pArgsList->ArrayElements), Buffer, 10);
              pch = Buffer;
           }
           else if (!strncmp(pSrc, szIFPOINTERTOPTRDEP, sizeof(szIFPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szIFPOINTERTOPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsPointerToPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFNPOINTERTOPTRDEP, sizeof(szIFNPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szIFNPOINTERTOPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsPointerToPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szISPOINTERTOPTRDEP, sizeof(szISPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szISPOINTERTOPTRDEP) - 1;
              pch = Buffer;
              pSrc = TestIfPointerToPtrDep(pSrc, pCGenState, pch);
           }
           else if (!strncmp(pSrc, szIFPTRDEP, sizeof(szIFPTRDEP) -1 )) {
              pSrc += sizeof(szIFPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFNPTRDEP, sizeof(szIFNPTRDEP) -1 )) {
              pSrc += sizeof(szIFNPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFINT64DEPUNION, sizeof(szIFINT64DEPUNION) -1 )) {
              pSrc += sizeof(szIFINT64DEPUNION) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsInt64DepUnion(pCGenState));
           }
           else if (!strncmp(pSrc, szIFNINT64DEPUNION, sizeof(szIFNINT64DEPUNION) -1 )) {
              pSrc += sizeof(szIFNINT64DEPUNION) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsInt64DepUnion(pCGenState));
           }           
           else if (!strncmp(pSrc, szIFAPICODE, sizeof(szIFAPICODE) -  1)) {
               pSrc += sizeof(szIFAPICODE) - 1;
               pSrc = IfApiCode(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szFASTCALL, sizeof(szFASTCALL) - 1)) {
               pSrc += sizeof(szFASTCALL) - 1;
               pSrc = WriteMore(pSrc, pCGenState, IsFastCall(pCGenState));
               }
           else if (!strncmp(pSrc, szSLOWCALL, sizeof(szSLOWCALL) - 1)) {
               pSrc += sizeof(szSLOWCALL) - 1;
               pSrc = WriteMore(pSrc, pCGenState, !IsFastCall(pCGenState));
               }
           else if (!strncmp(pSrc, szFASTX2NMETH, sizeof(szFASTX2NMETH) - 1)) {
               pSrc += sizeof(szFASTX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == FASTX2NMETHOD);
               }
           else if (!strncmp(pSrc, szSLOWX2NMETH, sizeof(szSLOWX2NMETH) - 1)) {
               pSrc += sizeof(szSLOWX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == SLOWX2NMETHOD);
               }
           else if (!strncmp(pSrc, szFATX2NMETH, sizeof(szFATX2NMETH) - 1)) {
               pSrc += sizeof(szFATX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == FATX2NMETHOD);
               }
           else if (!strncmp(pSrc, szMETHODNUMBER, sizeof(szMETHODNUMBER) - 1)) {
               pSrc += sizeof(szMETHODNUMBER) - 1;
               _itoa(pCGenState->ExportsDbg->MethodNumber, Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szIFARGS, sizeof(szIFARGS) - 1)) {
               pSrc += sizeof(szIFARGS) - 1;
               pSrc = IfArgs(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szFUNCARGNUM, sizeof(szFUNCARGNUM) - 1)) {
               pSrc += sizeof(szFUNCARGNUM) - 1;
               _itoa(GetFuncArgNum(pCGenState), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szRETSIZE, sizeof(szRETSIZE) - 1)) {
               pSrc += sizeof(szRETSIZE) - 1;
               _itoa(GetRetSize(pCGenState), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szARGSIZE, sizeof(szARGSIZE) - 1)) {
               pSrc += sizeof(szARGSIZE) - 1;
               _itoa(GetArgSize(pCGenState->ExportsDbg), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szFORCASE, sizeof(szFORCASE) - 1)) {
               pSrc += sizeof(szFORCASE) - 1;
               pSrc = ForCase(pSrc, pCGenState);
           }
           else if (!strncmp(pSrc, szCARGEXIST, sizeof(szCARGEXIST) - 1)) {
               pSrc += sizeof(szCARGEXIST) - 1;
               if (OutBuffer != NULL) {
                  pSrc = CArg(pSrc, pCGenState, &pch, TRUE);
               }
               else {
                  pSrc = CArg(pSrc, pCGenState, NULL, TRUE);
               }
           }
           else if (!strncmp(pSrc, szCARG, sizeof(szCARG) - 1)) {
               pSrc += sizeof(szCARG) - 1;
               if (OutBuffer != NULL) {
                  pSrc = CArg(pSrc, pCGenState, &pch, FALSE);
               }
               else {
                  pSrc = CArg(pSrc, pCGenState, NULL, FALSE);
               }
           }
           else if (!strncmp(pSrc, szCNUMBER, sizeof(szCNUMBER) - 1)) {
               pSrc += sizeof(szCNUMBER) - 1;
               _itoa(pCGenState->CaseNumber, Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szARGLIST, sizeof(szARGLIST) - 1)) {
               pSrc += sizeof(szARGLIST) - 1;
               if (pCGenState->ApiTypes) {
                   pSrc = ListArgs(pSrc, pCGenState, TRUE);
                   }
               }
           else if (!strncmp(pSrc, szNARGTYPE, sizeof(szNARGTYPE) - 1)) {
               pSrc += sizeof(szNARGTYPE) - 1;
               pch = NArgType(pCGenState, Buffer, sizeof(Buffer), &pSrc);
               }
           else if (!strncmp(pSrc, szNARGNAME, sizeof(szNARGNAME) - 1)) {
               pSrc += sizeof(szNARGNAME) - 1;
               pch = NArgName(pCGenState, Buffer, sizeof(Buffer), &pSrc);
               }
           else if (!strncmp(pSrc, szMARG, sizeof(szMARG) - 1)) {
               pSrc += sizeof(szMARG) - 1;
               if (OutBuffer != NULL) {
                  pSrc = MArg(pSrc, pCGenState, &pch);
               }
               else {
                  pSrc = MArg(pSrc, pCGenState, NULL);
               }
           }
           else if (!strncmp(pSrc, szFORCETYPE, sizeof(szFORCETYPE) - 1)) {
               pSrc += sizeof(szFORCETYPE) - 1;
               pSrc = ForceTypeExpand( pSrc, pCGenState);
           }
           else if (!strncmp(pSrc, szMEMBERTYPES, sizeof(szMEMBERTYPES) - 1)) {
               pSrc += sizeof(szMEMBERTYPES) - 1;
               pSrc = MemberTypes( pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szBTOTMEMBERTYPES, sizeof(szBTOTMEMBERTYPES) - 1)) {
               pSrc += sizeof(szBTOTMEMBERTYPES) - 1;
               pSrc = MemberTypes( pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szLOG, sizeof(szLOG) - 1)) {
               pSrc += sizeof(szLOG) - 1;
               pSrc = UpdateLog(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szIFRETTYPE, sizeof(szIFRETTYPE) - 1)) {
               pSrc += sizeof(szIFRETTYPE) - 1;
               pSrc = IfRetType(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szIFNOTRETTYPE, sizeof(szIFNOTRETTYPE) - 1)) {
               pSrc += sizeof(szIFNOTRETTYPE) - 1;
               pSrc = IfNotRetType(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szARGMOD, sizeof(szARGMOD) - 1)) {
               pSrc += sizeof(szARGMOD) - 1;
               if (pCGenState->pArgsList) {
                   pch = TokenString[pCGenState->pArgsList->Mod];
                   }
               }
           else if (!strncmp(pSrc, szARGPOSTMOD, sizeof(szARGPOSTMOD) - 1)) {
               pSrc += sizeof(szARGPOSTMOD) - 1;
               if (pCGenState->pArgsList) {
                   pch = TokenString[pCGenState->pArgsList->PostMod];
                   }
               }
           else if (!strncmp(pSrc, szARGTYPEIND, sizeof(szARGTYPEIND) - 1)) {
              pSrc += sizeof(szARGTYPEIND) - 1;
              pch = ArgTypeInd(Buffer, pCGenState, FALSE);    
           }
           else if (!strncmp(pSrc, szARGHOSTTYPEIND, sizeof(szARGHOSTTYPEIND) - 1)) {
              pSrc += sizeof(szARGHOSTTYPEIND) - 1;
              pch = ArgTypeInd(Buffer, pCGenState, TRUE);    
           }
           else if (!strncmp(pSrc, szARGHOSTTYPE, sizeof(szARGHOSTTYPE) -1 )) {
              pSrc += sizeof(szARGHOSTTYPE) - 1;
              pch = ArgHostType(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szARGTYPE, sizeof(szARGTYPE) - 1)) {
              pSrc += sizeof(szARGTYPE) - 1;
              pch = ArgType(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szUNALIGNEDTAG64, sizeof(szUNALIGNEDTAG64) - 1)) {
              pSrc += sizeof(szUNALIGNEDTAG64) - 1;
              pch = UnalignedTag64(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szARGNAME, sizeof(szARGNAME) - 1)) {
               if (pCGenState->pArgsList) {
                   pch = pCGenState->pArgsList->Name;
                   if (!pch) {
                       pch = "";
                   }
               }
               pSrc += sizeof(szARGNAME) - 1;
           }
           else if (!strncmp(pSrc, szARGNAMEHOSTCASTED, sizeof(szARGNAMEHOSTCASTED) - 1)) {
               if (pCGenState->pArgsList) {
                  pch = pCGenState->pArgsList->HostCastedName;
                  if (!pch) {
                     if (pCGenState->pArgsList->Name == NULL)
                        pch = "";
                     else 
                        pch = pCGenState->pArgsList->Name;
                  }
               }
              pSrc += sizeof(szARGNAMEHOSTCASTED) - 1; 
           }
           else if (!strncmp(pSrc, szARGVAL, sizeof(szARGVAL) - 1)) {
               if (pCGenState->pArgsList) {
                   strcpy(Buffer, pCGenState->pArgsList->Name);

                   // replace all occurrences of '->' by '__'
                   // and '.', '*', ')', and '(' by '_'
                   pch = Buffer;
                   while (*pch) {
                       if (*pch == '.' || *pch == ')' || *pch == '(' || *pch == '*')
                          *pch = '_';
                       else if (*pch == '-' && *(pch+1) == '>') {
                           *pch = '_';
                           *(pch+1) = '_';
                           pch++;
                       }
                       pch++;
                   }
                   pch = Buffer;
               } else {
                   pch = "";
               }
               pSrc += sizeof(szARGVAL) - 1;
               }
           else if (!strncmp(pSrc, szARGOFF, sizeof(szARGOFF) - 1)) {
               pSrc += sizeof(szARGOFF) - 1;
               if (pCGenState->pArgsList) {
                   _itoa(pCGenState->pArgsList->OffSet, Buffer, 10);
                   pch = Buffer;
                   }
               }
           else if (!strncmp(pSrc, szARGADDR, sizeof(szARGADDR) - 1)) {
               pSrc += sizeof(szARGADDR) - 1;
               if (pCGenState->pArgsList) {
                   if (pCGenState->pArgsList->ArgLocal) {
                       pch = Buffer;
                       *pch = '&';
                       strcpy(pch+1, pCGenState->pArgsList->ArgLocal);
                       pSrc = SkipSubExpression(pSrc, NULL);                       }
                   else {
                       pch = Buffer;
                       pSrc = WriteArgAddr(pSrc,
                                           pCGenState,
                                           pch,
                                           sizeof(Buffer)-1
                                           );
                       }
                   }
               }
           else if (!strncmp(pSrc, szADDRARGSLIST, sizeof(szADDRARGSLIST) - 1)) {
               pSrc += sizeof(szADDRARGSLIST) - 1;
               pch = GetAddrFirstArg(pCGenState, Buffer, sizeof(Buffer) - 1);
               }
           else if (!strncmp(pSrc, szARGLOCAL, sizeof(szARGLOCAL) - 1)) {
               pSrc += sizeof(szARGLOCAL) - 1;
               if (pCGenState->pArgsList) {
                   pch = Buffer;
                   if (!WriteArgLocal(pCGenState, pch, sizeof(Buffer)-1)) {
                      ExitErrMsg(FALSE, "CGenerate failed\n");
                      }
                   }
               }
           else if (!strncmp(pSrc, szARGMORE, sizeof(szARGMORE) - 1)) {
               pSrc += sizeof(szARGMORE) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->pArgsList &&
                                pCGenState->pArgsList->ArgumentsEntry.Flink
                                  != &pCGenState->ExportsDbg->ArgsListHead
                                );
               }
           else if (!strncmp(pSrc, szTYPES, sizeof(szTYPES) - 1)) {
               pSrc += sizeof(szTYPES) - 1;
               pSrc = IncludeTypes(pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szRTOLTYPES, sizeof(szRTOLTYPES) - 1)) {
               pSrc += sizeof(szRTOLTYPES) - 1;
               pSrc = IncludeTypes(pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szRETTYPE, sizeof(szRETTYPE) - 1)) {
               pSrc += sizeof(szRETTYPE) - 1;
               pSrc = IncludeRetType(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szEXPORTLIST, sizeof(szEXPORTLIST) - 1)) {
               pSrc += sizeof(szEXPORTLIST) - 1;
               pSrc = ListApis(pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szEXPNAME, sizeof(szEXPNAME) - 1)) {
               pSrc += sizeof(szEXPNAME) - 1;
               pch = pCGenState->ExportsDbg->ExportName;
               }
           else if (!strncmp(pSrc, szIFEXPFORWARD, sizeof(szIFEXPFORWARD) - 1)) {
               pSrc += sizeof(szIFEXPFORWARD) - 1;
               pch = GetAltExportName(Buffer,  pCGenState, sizeof(Buffer) - 1);
               }
           else if (!strncmp(pSrc, szIFORDINALS, sizeof(szIFORDINALS) - 1)) {
               pSrc += sizeof(szIFORDINALS) - 1;

               if (pCGenState->ExportsDbg &&
                   (pCGenState->ExportsDbg->Ordinal & 0x80000000))
                 {
                   pch = Buffer;
                   *pch = '@';
                   _itoa(IMPORDINAL(pCGenState->ExportsDbg->Ordinal),
                         pch + 1,
                         10
                         );
                   }
               }
           else if (!strncmp(pSrc, szLISTCOL, sizeof(szLISTCOL) - 1)) {
               pSrc += sizeof(szLISTCOL) - 1;
               pCGenState->ListCol = OutputColumn;
               }
           else if (!strncmp(pSrc, szDLLNAME, sizeof(szDLLNAME) - 1)) {
               Len = CopyToken(Buffer, DllBaseName, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "OverFlow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szDLLNAME) - 1;
               }
           else if (!strncmp(pSrc, szXPTNAME, sizeof(szXPTNAME) - 1)) {
               Len = CopyToken(Buffer, XptBaseName, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "OverFlow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szXPTNAME) - 1;
               }
           else if (!strncmp(pSrc, szDLLTARGET, sizeof(szDLLTARGET) - 1)) {
               Len = CopyToken(Buffer, pCGenState->CGen->FileBaseNameC, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "Overflow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szDLLTARGET) - 1;
               }
           else if (!strncmp(pSrc, szAPIUNKNOWN, sizeof(szAPIUNKNOWN) - 1)) {
               pSrc += sizeof(szAPIUNKNOWN) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->ExportsDbg->UnKnownApi
                                );
               }
           else if (!strncmp(pSrc, szAPINODECL, sizeof(szAPINODECL) - 1)) {
               pSrc += sizeof(szAPINODECL) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->ExportsDbg->UnKnownApi == 1
                                );
               }

           else if (!strncmp(pSrc, szAPISTRINGS, sizeof(szAPISTRINGS) - 1)) {
               pSrc += sizeof(szAPISTRINGS) - 1;
               if (pCGenState->ApiTypes) {
                   ApiStrings(pCGenState);
                   }
               }
           else if (!strncmp(pSrc, szDBGSINDEX, sizeof(szDBGSINDEX) - 1)) {
               char *pExpression, *pFree;
               int Index;

               pSrc += sizeof(szDBGSINDEX) - 1;
               pch = pSrc;
               pSrc = SkipSubExpression(pch, &pFree);

               if (pSrc != pch) {
                   if (!pFree && pCGenState->pArgsList ) {
                       pExpression = pCGenState->pArgsList->Type;
                       }
                   else {
                       pExpression = pFree;
                       }

                   Index = GetFuncIndex(pCGenState, pExpression);
                   if (Index == -1) {
                       ExitErrMsg(FALSE, "DebugsIndex unknown! %s\n", pch);
                       }

                   _itoa(Index, Buffer, 10);
                   pch = Buffer;
                   if (pFree) {
                       GenHeapFree(pFree);
                       }
                   }
               else {
                   pch = NULL;
                   }

               }

           else if (!strncmp(pSrc, szDBGSLIST, sizeof(szDBGSLIST) - 1)) {
               pSrc += sizeof(szDBGSLIST) - 1;
               pSrc = ListDbgs(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szDBGSSTRINGS, sizeof(szDBGSSTRINGS) - 1)) {
               pSrc += sizeof(szDBGSSTRINGS) - 1;
               WriteDbgsStrings(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szDBGSMORE, sizeof(szDBGSMORE) - 1)) {
               pSrc += sizeof(szDBGSMORE) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->MoreApis);
               }
           else if (!strncmp(pSrc, szOFFSET, sizeof(szOFFSET) - 1)) {
               pSrc += sizeof(szOFFSET) - 1;
               pSrc = GetOffSet(pSrc, Buffer);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szCPPEXPORT, sizeof(szCPPEXPORT) - 1)) {
               pSrc += sizeof(szCPPEXPORT) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                iHandleCpp > 0 && pCGenState->ExportsDbg->CplusDecoration
                                );
               }
           else if (!strncmp(pSrc, szCEXPORT, sizeof(szCEXPORT) - 1)) {
               pSrc += sizeof(szCEXPORT) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                !(iHandleCpp > 0 && pCGenState->ExportsDbg->CplusDecoration)
                                );
               }
           else if (!strncmp(pSrc, szCPPOUTPUT, sizeof(szCPPOUTPUT) - 1)) {
               pSrc += sizeof(szCPPOUTPUT) - 1;
               if (pCGenState->CGen->FileNameCpp != NULL) {
                   pCGenState->CGen->fp = pCGenState->CGen->fpCpp;
                   }
               }
           else if (!strncmp(pSrc, szCOUTPUT, sizeof(szCOUTPUT) - 1)) {
               pSrc += sizeof(szCOUTPUT) - 1;
               pCGenState->CGen->fp = pCGenState->CGen->fpC;
               }
           else if (!strncmp(pSrc, szIF, sizeof(szIF) - 1)) {
               BOOLEAN result;

               pSrc += sizeof(szIF) - 1;
               pSrc = ExtractBoolean1(pSrc, pCGenState, &result);
               pSrc = WriteMore(pSrc, pCGenState, result );

               if ( *pSrc == '@' &&
		       !strncmp(pSrc+1, szELSE, sizeof(szELSE) - 1)) {
		            pSrc += sizeof(szELSE) - 1+1;				
	                pSrc = WriteMore(pSrc, pCGenState, !result);
	                }
               }
           else if (!strncmp(pSrc, szELSE, sizeof(szELSE) - 1)) {
               ExitErrMsg ( FALSE, "@Else not immediately following @If" );
               }
           else if (!strncmp(pSrc, szOR, sizeof(szOR) - 1)) {			   
               BOOLEAN result1, result2;
               pSrc += sizeof(szOR) - 1;
               pSrc = ExtractBoolean2(pSrc, pCGenState, &result1, &result2);
               WriteBoolean ( Buffer, result1 || result2 );
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szAND, sizeof(szAND) - 1)) {			   
               BOOLEAN result1, result2;
               pSrc += sizeof(szAND) - 1;
               pSrc = ExtractBoolean2(pSrc, pCGenState, &result1, &result2);
               WriteBoolean ( Buffer, result1 && result2 );
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szNOT, sizeof(szNOT) - 1)) {			   
               BOOLEAN result1;
               pSrc += sizeof(szNOT) - 1;
               pSrc = ExtractBoolean1(pSrc, pCGenState, &result1);
               WriteBoolean ( Buffer, !result1);
               pch = Buffer;
               }
           else {
                //
                // See if this is an '@macroname'
                //
                char MacroName[MAX_PATH];
                char *p = MacroName;
                char *pIn = pSrc;
                SIZE_T Bytes;

                while (isalnum(*pIn)) {
                    *p++ = *pIn++;
                }
                *p = '\0';
                if (ExpandMacro(MacroName, pCGenState, &pIn, BufferPos, MaxLen, &Bytes)) {
                   if (OutBuffer != NULL) {
                      Bytes--; // subtract off terminating zero.
                      BufferPos += Bytes;
                      MaxLen -= Bytes;
                      *BytesReturned += Bytes;                      
                   }
                   pSrc = pIn;
                } else {
                    ExitErrMsg(FALSE, "Unknown keyword '@%s'", MacroName);
                }
            }

           if (pch) {
               if (OutBuffer != NULL) {
                  SIZE_T Bytes;
                  CGenerateEx(pch, pCGenState, BufferPos, MaxLen, &Bytes);
                  Bytes--; // subtract off terminating zero.
                  BufferPos += Bytes;
                  MaxLen -= Bytes;
                  *BytesReturned += Bytes;
               }
               else {
                  while (*pch) 
                     pch = CGeneratePrintChar(pch, pCGenState);
               }
           }
      }
      
   }

   if (OutBuffer != NULL) {
      if(MaxLen == 0) {
         ExitErrMsg(FALSE, "Out of Buffer space!\n");
      }
      *BufferPos = '\0';
      *BytesReturned += 1;
   }

   return pSrc;
}


int GetMemberOffset(char *sTypeName, char *sMemberName)
{
    PKNOWNTYPES pkt = NULL;
    PMEMBERINFO pmi;
    int i;

    //
    // This is the same as running the lexer on a single identifier...
    //
    Tokens[0].TokenType = TK_IDENTIFIER;
    Tokens[0].Name = sTypeName;
    Tokens[1].TokenType = TK_EOS;

    CurrentTokenIndex = 0;
    if (ParseTypes(TypeDefsList, NULL, &pkt) && pkt != NULL) {
        pkt = GetBasicType(pkt->BaseName, TypeDefsList, StructsList);
    } else {
        CurrentTokenIndex = 0;
        ParseTypes(StructsList, NULL, &pkt);
    }

    if (pkt == NULL) {
        ExitErrMsg(FALSE,
               "GetOffSet: Unknown Type %s\n",
               sTypeName
               );
    }

    pmi = pkt->pmeminfo;
    while (pmi) {

        if (!pmi->sName) {
            //
            // Found a nameless member.  See if the member name we're
            // looking for is a member of this nameless member.
            //
            //  ie.  typedef struct { int bar; } FOO;
            //
            //       typedef struct TEST {
            //          union {
            //              int i;
            //              FOO;
            //          }
            //       } test;
            //
            // GetOffset(TEST, bar) will recurse when pmi points
            // at the memberinfo for the nameless member 'FOO'.
            //
            i = GetMemberOffset(pmi->sType, sMemberName);
            if (i != -1) {
                return i;
            }
        } else if (!strcmp(pmi->sName, sMemberName)) {
            return pmi->dwOffset;
        }
        pmi = pmi->pmeminfoNext;
    }
    return -1;
}


char *
GetOffSet(
    char *pSrc,
    char *Buffer
    )
{
    char *pOrg = pSrc;
    char *pch;
    int  Len;
    char TypeName[MAX_PATH];
    char MemberName[MAX_PATH];

    if (*pSrc != '(') {
        ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pSrc);
        return NULL;
        }

    while (IsSeparator(*pSrc)) {
        pSrc = GetNextToken(pSrc);
        if (!*pSrc || *pSrc == ')') {
            ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pOrg);
            return NULL;
            }
        }

    pch = TypeName;
    Len = sizeof(TypeName)-1;
    while ((*pSrc != ',') && (*pSrc != 0)) {
         if (!--Len) {
             *pch = '\0';
             ExitErrMsg(TRUE, "GetOffset: Overflow %s\n", TypeName);
             return NULL;
             }
         *pch++ = *pSrc++;
         }
    *pch = '\0';


     while (IsSeparator(*pSrc)) {
         pSrc = GetNextToken(pSrc);
         if (!*pSrc || *pSrc == ')') {
             ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pOrg);
             return NULL;
             }
         }

    pch = MemberName;
    Len = sizeof(MemberName)-1;
    while (!IsSeparator(*pSrc)) {
         if (!--Len) {
             *pch = '\0';
             ExitErrMsg(TRUE, "GetOffset: Overflow %s\n", MemberName);
             return NULL;
             }
         *pch++ = *pSrc++;
         }
    *pch = '\0';

    while (*pSrc && *pSrc++ != ')') {
         ;
         }

    Len = GetMemberOffset(TypeName, MemberName);
    if (Len < 0) {
        ExitErrMsg(FALSE,
               "GetOffSet: Unknown Member %s.%s\n",
               TypeName,
               MemberName
               );

        return NULL;
    } 
    
    _ltoa(Len, Buffer, 16);
    return(pSrc);
}






/*
 *  GetRetSize
 *
 */
int GetRetSize(PCGENSTATE pCGenState)
{
    FILE *fp = pCGenState->CGen->fp;
    PKNOWNTYPES pkt;
    int i, Len;
    int RetSize, RetIndLevel;

    if (!pCGenState->ApiTypes) {
        fprintf(pCGenState->CGen->fp,
                "\n\t*** ERROR ***\n*** GetRetSize: No Api defined\n\n"
                );
        return -1;
    }

    // Get KnownTypes info for Return Type.  Can't use the ApiTypes->pktRet
    // cache as ParseIndirection() needs the state of the parse.
    ResetLexer();
    LexMacroArgs(pCGenState->ApiTypes->FuncRet);
    ConsumeConstVolatileOpt();

    if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
       CurrentTokenIndex = 0;
       if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {

           fprintf(pCGenState->CGen->fp,
                   "\n\t*** ERROR ***\n*** GetRetSize: Undefind Type %s\n\n",
                   pCGenState->ApiTypes->FuncRet
                   );

           return -1;
        }
    }

   if (pCGenState->ApiTypes->RetIndLevel) {
      RetSize = SIZEOFPOINTER;
   } else {
      RetSize = pkt->Size;
   }

   return RetSize;
}

/*
 *  GetArgSize
 *
 */
int GetArgSize(PEXPORTSDEBUG ExportDebug)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   int Total = 0;
   int ArgSize;           

   if (IsListEmpty(&ExportDebug->ArgsListHead)) {
       return -1;
       }

   if (ExportDebug->ArgsSize >= 0) {
       return ExportDebug->ArgsSize;
       }

   if (ExportDebug->IntForward && ExportDebug->IntForward->ArgsSize >= 0) {
       ExportDebug->ArgsSize = ExportDebug->IntForward->ArgsSize;
       return ExportDebug->ArgsSize;
       }

   Next = ExportDebug->ArgsListHead.Flink;

   // check for void arg list
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return 0;
       }

   do {
       pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

       ArgSize = (pArgsList->ArgSize + 3) & ~3;
       Total += ArgSize;

       Next= Next->Flink;

     } while (Next != &ExportDebug->ArgsListHead);

   ExportDebug->ArgsSize = Total;

   if (ExportDebug->IntForward) {
       ExportDebug->IntForward->ArgsSize = Total;
       }

   return Total;
}


/*
 *  ApiStrings
 *
 */
void ApiStrings(PCGENSTATE pCGenState)
{
    FILE *fp = pCGenState->CGen->fp;
    PLIST_ENTRY Next;
    PARGSLIST pArgsList;
    PKNOWNTYPES pkt;
    int ArgSize, IndLevel;
    char *pRet;
    char BaseName[MAX_PATH];
    char *c;

    // copy in the DLL name and whack off the extension
    strcpy(BaseName, DllBaseName);
    c = strchr(BaseName, '.');
    if (c) {
        *c = '\0';
    }

    //
    // Write the ApiName <"ApiName", ">
    //
    fprintf(fp, "\"%s!%s\", \"", BaseName, pCGenState->ExportsDbg->ExportName);

    //
    // Write out the Args <Arg1 %x, ArgN %x>
    //
    if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
        fprintf(fp,
                "\n\t*** ERROR ***\n*** ArgFormat Missing argument List: %s\n\n",
                pCGenState->ApiTypes->TypeName
                );
        return;
    }

    Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

    do {
        pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

        // check for void arg list
        if (!pArgsList->Name) {
            break;
        }

        fprintf(fp, "%s %s ",
                pArgsList->pKnownTypes->TypeName,
                pArgsList->Name
                );

        // check for vargs
        if (!strcmp(pArgsList->Name, szVARGS)) {
            break;
        }

        ArgSize = pArgsList->ArgSize;

        while (ArgSize > 0) {
           ArgSize -= sizeof(int);
           fprintf(fp,
                   "%s%s",
                   "%x",
                   ArgSize > 0 ? "." : ""
                   );
        }

        Next= Next->Flink;
        if (Next != &pCGenState->ExportsDbg->ArgsListHead) {
            fputc(',', fp);
        }

    } while (Next != &pCGenState->ExportsDbg->ArgsListHead);

    //
    // Write out Return Type <", "RetType %x">
    //
    pRet = pCGenState->ApiTypes->FuncRet;
    fprintf(fp, "\", \"%s ", pRet);

    ResetLexer();
    LexMacroArgs(pRet);
    ConsumeConstVolatileOpt();

       // Get Known Types for size of Return Type
    if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE) {

            fprintf(pCGenState->CGen->fp,
                    "\n\t*** ERROR ***\n*** GetRetSize: Undefind Type %s\n\n",
                    pCGenState->ApiTypes->FuncRet
                    );
            return;
        }
    }

    ArgSize = pkt->Size;
    ParseIndirection(NULL, &ArgSize, NULL, NULL, NULL);

    while (ArgSize > 0) {
        ArgSize -= sizeof(int);
        fprintf(fp,
                "%s%s",
                "%x",
                ArgSize > 0 ? "." : ""
                );
    }

    fprintf(fp, "\"");
}






char *
GetAddrFirstArg(
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen)
{

     PLIST_ENTRY pFirstEntry;
     PARGSLIST pArgsList;

     if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
         return "NULL";
         }

     pFirstEntry = pCGenState->ExportsDbg->ArgsListHead.Flink;
     pArgsList = CONTAINING_RECORD(pFirstEntry, ARGSLIST, ArgumentsEntry);
     if (!pArgsList->Name) {
         return "NULL";
         }

     Buffer[0] = '&';
     BuffLen--;

     if ((int)strlen(pArgsList->Name) > BuffLen) {
         ExitErrMsg(TRUE, "gafa: Overflow %s\n", pArgsList->Name);
         }

     strcpy(&Buffer[1], pArgsList->Name);

     return Buffer;
}



/*
 *  IfArgs
 *
 */
char *IfArgs(char *pSrc, PCGENSTATE pCGenState)
{
   BOOL bMore = TRUE;
   PARGSLIST pArgsList;
   PLIST_ENTRY pFirstEntry;
   PKNOWNTYPES pkt;


      // skip empty list,
   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       bMore = FALSE;
       }

      // check for void arg list
   else {
      pFirstEntry = pCGenState->ExportsDbg->ArgsListHead.Flink;
      pArgsList = CONTAINING_RECORD(pFirstEntry, ARGSLIST, ArgumentsEntry);
      if (!pArgsList->Name) {
          pkt = GetNameFromTypesList(TypeDefsList, pArgsList->Type);
          if (!pkt) {
              pkt = GetNameFromTypesList(StructsList, pArgsList->Type);
              }
          if (!pkt) {
              ExitErrMsg(FALSE,
                         "ifArgs: Unknown Type %s\n",
                         pArgsList->Type
                         );
              }

          if (!pkt->IndLevel && !strcmp(pkt->BasicType, szVOID)) {
              bMore = FALSE;
              }
          }
      }

   return WriteMore(pSrc,pCGenState, bMore);
}




/*
 *  IfApiRet
 *
 */
char *IfApiRet(char *pSrc, PCGENSTATE pCGenState)
{
    int i, Len;
    BOOL bMore = TRUE;
    PKNOWNTYPES pkt;

    ResetLexer();
    LexMacroArgs(pCGenState->ApiTypes->FuncRet);
    ConsumeConstVolatileOpt();

    if (ParseTypes(TypeDefsList,NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE) {
            bMore = FALSE;
        }
    }

    if (bMore && CurrentToken()->TokenType != TK_STAR &&
        !pkt->IndLevel && !strcmp(pkt->BasicType, szVOID)) {
        bMore = FALSE;
    }

    return WriteMore(pSrc, pCGenState, bMore);
}


char *
IfApiCode(
    char *pSrc,
    PCGENSTATE pCGenState
    )
/*++

Routine Description:

    Expands an EFunc's codeburst, if it exists.  ie. @IfApiCode(foo) will
    expand to the 'foo=' section of the current EFunc, if the current EFunc
    has a 'foo='.  Otherwise, there is no expansion.

Arguments:

    pSrc        - pointer to character following '@IfApiCode'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pch;
    char *pEnd;
    size_t  Len;
    int CodeBurstIndex;
    char CodeName[MAX_PATH];
    char *CodeBurst;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    pch = pSrc+1;
    if (IsSeparator(*pch)) {
        return pSrc;
    }

    pSrc = pch;
    while (!IsSeparator(*pch)) {
        pch++;
    }
    Len = pch - pSrc;

    // Copy name to a buffer and null-terminate
    memcpy(CodeName, pSrc, Len);
    CodeName[Len] = '\0';

    CodeBurstIndex = GetExistingCodeBurstIndex(CodeName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", CodeName);
    }

    if (pCGenState->ExTemplate) {
        CodeBurst = pCGenState->TempleEx->CodeBurst[CodeBurstIndex];
        if (CodeBurst) {
            //
            // There is an [Efunc] with a non-empty codeburst for this API.
            // Generate its codeburst.
            //
            CGenerate(CodeBurst, pCGenState);
        }
    }

    return pEnd;
}


/*
 *  CheckFastCallArgs
 *
 */
BOOLEAN
FastCallArgs(
    PLIST_ENTRY ArgsListHead,
    int ArgLimit,
    BOOL fCheckTypes,
    BOOL fCheckFirstArgType    
    )
{
   PARGSLIST pArgsList;
   PTEMPLES pTypeTemple;
   PKNOWNTYPES pktTemple;
   int tplIndLevel, NumArgs, ArgSize;
   PLIST_ENTRY Next, NextTemple;

   if (IsListEmpty(ArgsListHead)) {
       return FALSE;
       }


   Next = ArgsListHead->Flink;

   // check for void arg list, or vargs as first arg
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name) {
       return strcmp(pArgsList->Type, szVARGS) ? TRUE : FALSE;
       }

   NumArgs = 0;
   while (Next != ArgsListHead) {
       pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);

       //
       // Cannot have more than 4 args
       //

       if (++NumArgs > ArgLimit) {
           return FALSE;
           }


       //
       // arg size must be dword or less
       //

       ArgSize = (pArgsList->ArgSize + 3) & ~3;

       if (ArgSize < 0 || ArgSize > 4) {
           return FALSE;
           }

       //
       // vargs of any indlevel aren't allowed
       //

       if (!strcmp(pArgsList->pKnownTypes->BaseName, szVARGS)) {
           return FALSE;
           }

       //
       // floats of Zero IndLevel aren't allowed
       //

       if (pArgsList->IndLevel == 0 &&
           !strcmp(pArgsList->pKnownTypes->BaseName, szFLOAT))
          {
           return FALSE;
           }


       //
       // type templates are not allowed except for the first arg in methods
       //

       if ((fCheckTypes) &&
           ((NumArgs != 1) ||
           ((NumArgs == 1) && fCheckFirstArgType))) {
           NextTemple = TypeTempleList.Flink;
           while (NextTemple != &TypeTempleList) {
               pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);


               //
               // get the Known types info for each type template.
               //

               pktTemple = pTypeTemple->pktType;
               if (!pktTemple) {

                   //
                   // Don't have the Known types info yet, fetch it
                   // and save it in the TypeTemplate
                   //

                   pktTemple = GetNameFromTypesList(TypeDefsList,
                                                pTypeTemple->Name
                                                );
                   if (!pktTemple) {
                       pktTemple = GetNameFromTypesList(StructsList,
                                                        pTypeTemple->Name
                                                    );
                       }
    
                   pTypeTemple->pktType = pktTemple;
                   }

               if (!pktTemple) {
                   ExitErrMsg(FALSE,
                          "Temple: Type not found %s\n",
                          pTypeTemple->Name
                          );
                   }


               //
               // See if arg matches this type template
               //

               if (IsSameType(pArgsList->pKnownTypes,
                              pArgsList->IndLevel,
                              TK_NONE,
                              pTypeTemple->Name,
                              pTypeTemple->IndLevel + pktTemple->IndLevel,
                              TK_NONE,
                              TRUE
                              ))
                  {
                   return FALSE;
                  }

               NextTemple = NextTemple->Flink;
               }  
           }
           Next= Next->Flink;
       }


   return TRUE;
}


BOOLEAN
IsFastCall(
     PCGENSTATE pCGenState
)
{
     if (!pCGenState->ExportsDbg) { // can this occur ?
         return FALSE;
         }

     //
     // If first time, determine if Api can be a fastcall.
     // tri state flag, where:
     //    -1 == Cannot be a fastcall
     //    0  == undetermined
     //    1  == Can be a fastcall
     //

     if (!pCGenState->ExportsDbg->FastCall) {
         int Size;

         pCGenState->ExportsDbg->FastCall = -1; // assume not a fastcall

         //
         // Fast call criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. 0 to 4 params
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Not have have a type template
         // 7. Must not be in the EFastTemplate list
         // 8. Must not have a C++ linkage
         //

         if (!pCGenState->ExTemplate && !pCGenState->ExportsDbg->CplusDecoration) {
             Size =  GetRetSize(pCGenState);
             if (Size >= 0 && Size <= 4 &&
                 !GetTemplate(&EFastTempleList, pCGenState->ExportsDbg->ExportName) &&
                 FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, 4, TRUE, TRUE))
                {
                 pCGenState->ExportsDbg->FastCall = 1;
                 }
             }
         }

     return pCGenState->ExportsDbg->FastCall == 1;
}

METHODTYPE
GetX2NMethodType(
     PCGENSTATE pCGenState
     )
{
    int RetSize;

         //
         // Fast X2N method criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. Number of parameters between 1 and MAXX2NPARAMETERS 
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Not have have a type template, except for this pointer
         // 7. Must not be in the EFastTemplate list
         // 8. Must not have a C++ linkage
         //

         //
         // Slow X2N method criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. Number of parameters between 1 and MAX2NPARAMETERS 
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Must not be in the EFastTemplate list
         // 7. Must not have a C++ linkage
         //

         // Fat X2N methods are neither Slow X2N methods or Fast X2N methods


    if (!pCGenState->ExportsDbg) { // can this occur ?
         return FALSE;
         }

    if (pCGenState->ExportsDbg->X2NMethodType == UNKNOWNMETHOD) {

        RetSize = GetRetSize(pCGenState);
        if (pCGenState->ExTemplate ||
            pCGenState->ExportsDbg->CplusDecoration ||
            GetTemplate(&EFastTempleList, pCGenState->ExportsDbg->ExportName) ||
            (RetSize > 4) || (RetSize < 0)) {
            pCGenState->ExportsDbg->X2NMethodType = FATX2NMETHOD;
            }
        else if (FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, MAXX2NPARAMETERS, TRUE, FALSE)) {
            pCGenState->ExportsDbg->X2NMethodType = FASTX2NMETHOD;
            }
        else if (FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, MAXX2NPARAMETERS, FALSE, FALSE)) {
            pCGenState->ExportsDbg->X2NMethodType = SLOWX2NMETHOD;
            }
        else {
            pCGenState->ExportsDbg->X2NMethodType = FATX2NMETHOD;
            }
        }

    return(pCGenState->ExportsDbg->X2NMethodType);
}

/*
 *  IfRetType
 *
 */
char *IfRetType(char *pSrc, PCGENSTATE pCGenState)
{
   char *pch;
   BOOL bMore = FALSE;
   char c;
   
   pch = GetNextToken(pSrc);
   if (pch != pSrc)
   {
       bMore = ( ! strncmp(pch, pCGenState->ApiTypes->FuncRet,
                                strlen( pCGenState->ApiTypes->FuncRet)));
   }
   pSrc = GetNextToken(pch);
   
   pch = WriteMore(pSrc ,pCGenState, bMore);   
   
   return(pch);
}

/*
 *  IfNotRetType
 *
 */
char *IfNotRetType(char *pSrc, PCGENSTATE pCGenState)
{
   char *pch;
   BOOL bMore = FALSE;
   char c;
   
   pch = GetNextToken(pSrc);
   if (pch != pSrc)
   {
       bMore = (strncmp( pch, pCGenState->ApiTypes->FuncRet, strlen( pCGenState->ApiTypes->FuncRet ) ) != 0);
   }
   pSrc = GetNextToken(pch);
   
   pch = WriteMore(pSrc ,pCGenState, bMore);   
   
   return(pch);
}

BOOL
ExpandType(
   PCGENSTATE pCGenState,
   PKNOWNTYPES pkt,
   PLIST_ENTRY pTempleList,
   int CodeBurstIndex
   )
{
   
   PARGSLIST pArgsList;
   PKNOWNTYPES pktTemple;
   int tplIndLevel;
   PLIST_ENTRY NextArg, NextTemple;
   PTEMPLES pTypeTemple;
   BOOL bMatchFound = FALSE;
   int i;

   pArgsList = pCGenState->pArgsList;

   i=2;
   while (i--) {
       NextTemple = pTempleList->Flink;
       while (NextTemple != pTempleList) {
           pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);

           tplIndLevel = pTypeTemple->IndLevel;
           pktTemple = pTypeTemple->pktType;
           if (!pktTemple) {
               pktTemple = GetNameFromTypesList(TypeDefsList,
                                                pTypeTemple->Name
                                               );
               if (!pktTemple) {
                   pktTemple = GetNameFromTypesList(StructsList,
                                                    pTypeTemple->Name
                                                   );
               }
               pTypeTemple->pktType = pktTemple;
           }


           if (!pktTemple) {
               ExitErrMsg(FALSE,
                          "Temple: Type not found %s\n",
                          pTypeTemple->Name
                          );
           }

           tplIndLevel += pktTemple->IndLevel;

           if (IsSameType(pkt,
                          pArgsList->IndLevel,
                          pArgsList->tkDirection,
                          pTypeTemple->Name,
                          tplIndLevel,
                          pTypeTemple->tkDirection,
                          i == 0
                          )) {
                DbgPrintf("ttpl: MEMBER %s.%s Type=%s IndLevel=%d\n",
                          pCGenState->ApiTypes->FuncRet,
                          pTypeTemple->Name,
                          pTypeTemple->Name,
                          pTypeTemple->IndLevel
                         );

               if(ExpandTemple(pTypeTemple, CodeBurstIndex, pCGenState)){
                   return TRUE;
               }
           }

       NextTemple = NextTemple->Flink;
       }

   }

   return FALSE;

}

BOOL IsInNoType(PCHAR *NoTypes, PMEMBERINFO pmi) {
    SIZE_T NoTypeCount;
    if (NoTypes == NULL || pmi->sName == NULL) {
       return FALSE;
    }
    for (NoTypeCount=0; NoTypeCount<MAX_NOTYPE; ++NoTypeCount) {  
        if (!NoTypes[NoTypeCount]) {
            return FALSE;
        }
        else {
           if (strcmp(pmi->sName, NoTypes[NoTypeCount]) == 0) {
              return TRUE;
           }
        }
    }
    return FALSE;
}

SIZE_T CountNoTypes(PCHAR *NoTypes) {
   SIZE_T Count = 0;
   if (NoTypes == NULL) {
      return 0;
   }
   while(*NoTypes++ != NULL) {
      Count++;
   }
   return Count;
}

VOID pMemberTypes( PCGENSTATE pCGenState, int CodeBurstIndex, char *MemReference, BOOL bBtoT);

void ExpandMemberType( PMEMBERINFO pmi, CGENSTATE CGenState, int CodeBurstIndex,
    PKNOWNTYPES pktStruct, char* pszStructName, char *pszHostCastedStructName, PARGSLIST pArgsList, FILE* fpLog,
    PARGSLIST pArgsListOld, char *pMemReference, BOOL bBtoT)
{                      
    char *sName;
    char *sNameNew;
    char *sHostCastedName;
    int i, Len, HostCastedNameLen;
    int tplIndLevel;
    PLIST_ENTRY NextArg, NextTemple;
    PTEMPLES pTypeTemple;
    PKNOWNTYPES pktTemple;
    PKNOWNTYPES pkt;
    BOOL bAddCast = TRUE;
    SIZE_T NoTypeCount;
    char Type[MAX_PATH];
    PARGSLIST pArgsListTemp;

    // Determine if this member should be expanded by checking for a NoType entry.
    if (pmi->sName != NULL) {
       if(IsInNoType(CGenState.CurrentTemple->NoTypes, pmi) ||
          IsInNoType(CGenState.MemberNoType, pmi)) {
          goto NextMember;
       }
    }

    // Get the pkt for the member type
    if ( pmi->pktCache )
    {
        pkt = pmi->pktCache;
    }
    else
    {
        ResetLexer();
        LexMacroArgs(pmi->sType);
        ConsumeConstVolatileOpt();

        if (ParseTypes(TypeDefsList,NULL, &pkt) == FALSE)
        {
            CurrentTokenIndex = 0;
            if ( ParseTypes( StructsList, NULL, &pkt ) == FALSE )
            {
                fprintf( fpLog, "%s *** WARNING *** Member %s->%s skipped - unknown type\n", CGenState.Temple->Comment,
                    pszStructName, pmi->sType );

                goto NextMember;
            }
        }
        pmi->pktCache = pkt;
    }

    if ( pktStruct == pkt )
    {
        //
        // Rats!  The structure contains a member which is a pointer
        // with the same type as this structure.  ie.  this struct
        // is self-referential.  We can't expand it as the expansion
        // is recursive.
        //
        fprintf( fpLog, "%s *** WARNING *** Member %s->%s skipped - self-referencing structure\n", CGenState.Temple->Comment,
            pszStructName, pmi->sType );

        goto NextMember;
    }        
        
    // Build the new names.
    sName = pmi->sName;
    
    // This is a type without a name. No casting is needed.    
    if (pktStruct->Flags & BTI_ANONYMOUS) {

       if (sName == NULL) {
          sHostCastedName = CheckHeapAlloc(strlen(pszHostCastedStructName) + 1); 
          sNameNew = CheckHeapAlloc(strlen(pszStructName) + 1);
          strcpy(sHostCastedName, pszHostCastedStructName);
          strcpy(sNameNew, pszStructName);
       }

       else {
          sHostCastedName = CheckHeapAlloc(strlen(pszHostCastedStructName) + strlen(pMemReference) + strlen(sName) + 1);
          strcpy(sHostCastedName, pszHostCastedStructName);
          strcat(sHostCastedName, pMemReference);
          strcat(sHostCastedName, sName);
          sNameNew = CheckHeapAlloc(strlen(pszStructName) + strlen(pMemReference) + strlen(sName) + 1);
          strcpy(sNameNew, pszStructName);
          strcat(sNameNew, pMemReference);
          strcat(sNameNew, sName);
       }

    }
    else {
       
       pArgsListTemp = CGenState.pArgsList;
       CGenState.pArgsList = pArgsListOld;
       if (IsPointer(&CGenState)) {
           ArgTypeInd(Type, &CGenState, TRUE);
           strcat(Type, " *");
       }
       else {
           ArgHostType(Type, &CGenState);
       }
   
       if (CGenState.pArgsList->bIsBitfield ||
               (CGenState.pArgsList->IndLevel == 0 &&
                CGenState.pArgsList->pKnownTypes->IndLevel == 0 &&
                  (strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "struct") == 0 ||
                   strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "enum") == 0 ||
                   strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "union") == 0)
                  )
                
           ) {
           bAddCast = FALSE;
       }
       else {
           bAddCast = TRUE;
       }
   
       CGenState.pArgsList = pArgsListTemp;
       
       HostCastedNameLen = strlen(pszHostCastedStructName) + strlen(Type) + 8; 
              
       Len = strlen(pszStructName) + 1;

       if (sName != NULL) {
          HostCastedNameLen += strlen(pMemReference) + strlen(sName);
          Len += strlen(pMemReference) + strlen(sName);
       
       }
   
       if (Len >= MAX_PATH || HostCastedNameLen >= MAX_PATH) {
           fprintf( fpLog,
                    "%s *** WARNING *** Member %s->%s skipped - name is too long\n",
                    CGenState.Temple->Comment,
                    pszStructName,
                    pmi->sType
                  );
           goto NextMember;
   
       }
   
       sHostCastedName = CheckHeapAlloc(HostCastedNameLen);
       sHostCastedName[0] = '\0';
   
       if (bAddCast) {
           strcpy(sHostCastedName, "((");
           strcat(sHostCastedName, Type);
           strcat(sHostCastedName, ")(");
           strcat(sHostCastedName, pszHostCastedStructName);
           strcat(sHostCastedName, "))");
       }
       else {
           strcat(sHostCastedName, pszHostCastedStructName);
       }
   
       if(sName != NULL) {
          strcat(sHostCastedName, pMemReference);
          strcat(sHostCastedName, sName);
       }
           
       sNameNew = CheckHeapAlloc(Len);        
       strcpy(sNameNew, pszStructName);
       
       if(sName != NULL) {
          strcat(sNameNew, pMemReference);
          strcat(sNameNew, sName);       
       }

    }
        
    pArgsList->pKnownTypes = pkt;
    pArgsList->ArgSize = pkt->Size;
    pArgsList->IsPtr64 = pmi->bIsPtr64;
    pArgsList->OffSet = -1;     // there is no stack offset for this member
    pArgsList->IndLevel = pmi->IndLevel;
    // pArgsList->tkDirection is same as the original arg
    pArgsList->Type = pmi->sType;
    pArgsList->pStructType = NULL;
    pArgsList->Mod = TK_NONE;
    pArgsList->SUEOpt = TK_NONE;
    pArgsList->PostMod = TK_NONE;
    pArgsList->PrePostMod = TK_NONE;
    pArgsList->Name = sNameNew;
    pArgsList->ArgLocal = sNameNew;
    pArgsList->HostCastedName = sHostCastedName;
    pArgsList->fIsMember      = TRUE;
    pArgsList->bIsBitfield = pmi->bIsBitfield;        
    pArgsList->BitsRequired= pmi->BitsRequired;       
    pArgsList->bIsArray    = pmi->bIsArray;           
    pArgsList->ArrayElements=pmi->ArrayElements;
    pArgsList->fRequiresThunk = ((pkt->Flags & BTI_CONTAINSFUNCPTR) != 0);

    if (sName != NULL) {
       CGenState.MemberNoType = NULL;
       ExpandType(&CGenState, pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);        
    }
    else {
       
       // This field is a nameless field in a structure or union.
       // Example:
       //     struct foobar {
       //         int x;
       //     };
       //     struct foobar2 {
       //         struct foobar;
       //         int y;
       //     };
       // foobar2 will import all the fields of foobar.
       //
       // When walking down the structure, we want to continue expanding foobar when we reach the nameless field.
       
       SIZE_T NumNoTypes1, NumNoTypes2;
       PCHAR *NewNoTypes;
       
       NumNoTypes1 = CountNoTypes(CGenState.MemberNoType); 
       NumNoTypes2 = CountNoTypes(CGenState.CurrentTemple->NoTypes);
       if (NumNoTypes1 + NumNoTypes2 + 1 > MAX_NOTYPE) {
          ExitErrMsg(FALSE, "ExpandMemberType: too many notypes.\n");
       }
       NewNoTypes = CheckHeapAlloc((NumNoTypes1 + NumNoTypes2 + 1)*sizeof(PCHAR));
       
       memcpy(NewNoTypes, CGenState.MemberNoType, NumNoTypes1 * sizeof(PCHAR));
       memcpy(NewNoTypes + NumNoTypes1, CGenState.CurrentTemple->NoTypes, NumNoTypes2 * sizeof(PCHAR));
       NewNoTypes[NumNoTypes1 + NumNoTypes2] = NULL;
       CGenState.MemberNoType = NewNoTypes;
       pMemberTypes( &CGenState, CodeBurstIndex, pMemReference, bBtoT);
       GenHeapFree(NewNoTypes);
    }

    GenHeapFree(sNameNew);
    GenHeapFree(sHostCastedName); 

NextMember:;
}

void ExpandMemberTypesBackwards( PMEMBERINFO pmi, CGENSTATE CGenState, int CodeBurstIndex,
    PKNOWNTYPES pktStruct, char* pszStructName, char *pszHostCastedStructName, PARGSLIST pArgsList, FILE* fpLog,
    PARGSLIST pArgsListOld, char *pMemReference, BOOL bBtoT)
{
    if ( pmi->pmeminfoNext != NULL )
    {
        ExpandMemberTypesBackwards( pmi->pmeminfoNext, CGenState, CodeBurstIndex, pktStruct,
            pszStructName, pszHostCastedStructName, pArgsList, fpLog,
            pArgsListOld, pMemReference, bBtoT);
    }

    ExpandMemberType( pmi, CGenState, CodeBurstIndex, pktStruct,
        pszStructName, pszHostCastedStructName, pArgsList, fpLog,
        pArgsListOld, pMemReference, bBtoT);
}

VOID pMemberTypes( PCGENSTATE pCGenState, int CodeBurstIndex, char *MemReference, BOOL bBtoT) {
    
    int Len;
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    PKNOWNTYPES pkt;
    PKNOWNTYPES pktLast;
    ARGSLIST ArgsListOld;
    PMEMBERINFO pmi;

    pCGen = CheckHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);

    InitializeListHead(&pCGen->CGenerateEntry);
   
    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);
   
    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    pkt = pCGenState->pArgsList->pKnownTypes;
    while(pkt->pTypedefBase != NULL) {
       pkt = pkt->pTypedefBase;
    }
    pCGenState->pArgsList->pStructType = pkt;

    // Save the old ARGSLIST away
    ArgsListOld = *(pCGenState->pArgsList);

    // get a ptr to the member list for the struct
    pmi = pkt->pmeminfo;
    if ( !pmi )
    {
        ExitErrMsg(FALSE, "Type '%s' is not a struct", pCGenState->pArgsList->Type);
    }

    if(strcmp(pkt->BasicType, "union") == 0) {
        PMEMBERINFO pmiTemp;
        // check if any of the members of this union are in the notype list.
        for (pmiTemp = pkt->pmeminfo; pmiTemp != NULL; pmiTemp = pmiTemp->pmeminfoNext) {
           if (IsInNoType(pCGenState->MemberNoType, pmiTemp) || 
               IsInNoType(pCGenState->CurrentTemple->NoTypes, pmiTemp)) {
               //A member of the union is in the notype list, skip union.
               goto done;
           }
        }
    }

    // loop over each member variable within the type
    if ( bBtoT )
    {
        do
        {
            ExpandMemberType( pmi, CGenState, CodeBurstIndex, ArgsListOld.pKnownTypes, ArgsListOld.Name, 
                ArgsListOld.HostCastedName, pCGenState->pArgsList, pCGenState->CGen->fp,
                &ArgsListOld, MemReference, bBtoT);
            pmi = pmi->pmeminfoNext;
        }
        while ( pmi != NULL );
    }
    else
    {
        ExpandMemberTypesBackwards( pmi, CGenState, CodeBurstIndex, ArgsListOld.pKnownTypes, ArgsListOld.Name,
                ArgsListOld.HostCastedName, pCGenState->pArgsList, pCGenState->CGen->fp,
                &ArgsListOld, MemReference, bBtoT);
    }

done:
    // Restore the old ARGSLIST
    *pCGenState->pArgsList = ArgsListOld;
    GenHeapFree(pCGen);
}

char* MemberTypes( char *pSrc, PCGENSTATE pCGenState, BOOL bBtoT)
/*++

Routine Description:

    Expands [Type] templates for the return value of an API call.

Arguments:

    pSrc        - pointer to character following '@RetType'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pEnd;
    char *pch;
    int Len;
    char BurstName[MAX_PATH];
    int CodeBurstIndex;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;

    char MemReference[MAX_PATH];

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs < 1 || pMArgsList->NumArgs > 2) {
       ExitErrMsg(FALSE, "MemberTypes: 1 or 2 arguments are required.\n");
    }

    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);    
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    //handle optional member reference symbol
    if (pMArgsList->NumArgs == 2) {
       CGenerateEx(pMArgsList->ArgText[1], pCGenState, MemReference, MAX_PATH, &BytesReturned);
    }
    else {
       strcpy(MemReference, "->");
    }

    pMemberTypes(pCGenState, CodeBurstIndex, MemReference, bBtoT);  
    FreeMacroArgsList(pMArgsList);    
    return pEnd;
}

char* ForceTypeExpand( char *pSrc, PCGENSTATE pCGenState)
{
    char *pEnd;
    char *pch;
    int Len;
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    char BurstName[MAX_PATH];
    char ArgName[MAX_PATH];
    char ArgHostName[MAX_PATH];
    char TypeName[MAX_PATH];
    char Direction[MAX_PATH];
    int CodeBurstIndex;
    PARGSLIST pArgsList;
    ARGSLIST ArgsListOld;
    ARGSLIST ArgsListNew;
    TOKENTYPE tkDirection;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;
    BOOL bHasArgsList=FALSE;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);    
    
    if (pMArgsList->NumArgs != 5) {
       ExitErrMsg(FALSE, "ForceTypeExpand: 5 arguments are required.\n");
    }

    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
    if (!pCGen) {
        ExitErrMsg(TRUE, "mt: %s\n", pSrc);
    }

    CGenerateEx(pMArgsList->ArgText[1], pCGenState, ArgName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[2], pCGenState, ArgHostName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[3], pCGenState, TypeName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[4], pCGenState, Direction, MAX_PATH, &BytesReturned);

    // Parse the direction
    if(strcmp(Direction, "IN OUT") == 0) {
       tkDirection = TK_INOUT;
    }
    else if (strcmp(Direction, "IN") == 0) {
       tkDirection = TK_IN;
    }
    else if (strcmp(Direction, "OUT") == 0) {
       tkDirection = TK_OUT;
    }
    else if (strcmp(Direction, "none") == 0) {
       tkDirection = TK_NONE;
    }
    else {
       ExitErrMsg(FALSE, "FORCETYPE: Unknown direction %s\n", Direction);
       return NULL;
    }
                
    InitializeListHead(&pCGen->CGenerateEntry);
       
    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);
   
    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    // Save the old ARGSLIST away
    pArgsList = pCGenState->pArgsList;
    if (pArgsList == NULL) {
       CGenState.pArgsList = &ArgsListNew;
       pArgsList = &ArgsListOld;
       *pArgsList = *(PARGSLIST)pCGenState->ExportsDbg->ArgsListHead.Flink;
    }
    else {
       ArgsListOld = *pArgsList;
       bHasArgsList = TRUE;
    }
    
    pArgsList->pKnownTypes = NULL;
    pArgsList->ArgSize = 0;
    pArgsList->IsPtr64 = FALSE;
    pArgsList->OffSet = -1;     // there is no stack offset for this member
    pArgsList->IndLevel = 0;
    pArgsList->tkDirection = tkDirection;
    pArgsList->Type = TypeName;
    pArgsList->pStructType = NULL;
    pArgsList->Mod = TK_NONE;
    pArgsList->SUEOpt = TK_NONE;
    pArgsList->PostMod = TK_NONE;
    pArgsList->PrePostMod = TK_NONE;
    pArgsList->Name = ArgName;
    pArgsList->ArgLocal = ArgName;
    pArgsList->HostCastedName = ArgHostName;
    pArgsList->fIsMember      = TRUE;
    pArgsList->bIsBitfield = FALSE;        
    pArgsList->BitsRequired= FALSE;       
    pArgsList->bIsArray    = FALSE;           
    pArgsList->ArrayElements=0;
    pArgsList->fRequiresThunk = FALSE;

    SetArgListToTypeForArg(CGenState.pArgsList, pArgsList, TypeName);
    ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);

    // Restore the old ARGSLIST
    if (bHasArgsList) {
        *pCGenState->pArgsList = ArgsListOld;
    }
    else {
         pCGenState->pArgsList = NULL;
    }
    GenHeapFree(pCGen);
    FreeMacroArgsList(pMArgsList);
    return pEnd;
}

char *
IncludeRetType(
    char *pSrc,
    PCGENSTATE pCGenState
    )
/*++

Routine Description:

    Expands [Type] templates for the return value of an API call.

Arguments:

    pSrc        - pointer to character following '@RetType'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pEnd;
    char *pch;
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    PKNOWNTYPES pkt;
    int i, Len;
    int tplIndLevel;
    PTEMPLES pTypeTemple;
    PKNOWNTYPES pktTemple;
    PLIST_ENTRY NextArg, NextTemple;
    char BurstName[MAX_PATH];
    int CodeBurstIndex;
    char *CodeBurst;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs != 1) {
       ExitErrMsg(FALSE, "IncludeRetTypes: exactly 1 argument is required.\n");
    }
    
    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
    if (!pCGen) {
        ExitErrMsg(TRUE, "it: %s\n", pSrc);
    }

    InitializeListHead(&pCGen->CGenerateEntry);
   
    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);
   
    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    if (pCGenState->ExTemplate) {
        CodeBurst = pCGenState->TempleEx->CodeBurst[CodeBurstIndex];
        if (CodeBurst) {
            //
            // The [EFunc] template for this API has a return-type codeburst.
            // That is expanded in lieu of a [Types] template.
            //
            CGenerate(CodeBurst, &CGenState);
            return pEnd;
        }
    }

    pkt = pCGenState->ApiTypes->pktRet;
    pkt = pCGenState->ApiTypes->pktRet;
    i=2;
    while (i--) {
        NextTemple = TypeTempleList.Flink;
        while (NextTemple != &TypeTempleList) {
            pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);

            tplIndLevel = pTypeTemple->IndLevel;
            pktTemple = pTypeTemple->pktType;
            if (!pktTemple) {
                pktTemple = GetNameFromTypesList(TypeDefsList,
                                                 pTypeTemple->Name
                                                );
                if (!pktTemple) {
                    pktTemple = GetNameFromTypesList(StructsList,
                                                     pTypeTemple->Name
                                                    );
                }
                pTypeTemple->pktType = pktTemple;
            }


            if (!pktTemple) {
                ExitErrMsg(FALSE,
                           "Temple: Type not found %s\n",
                           pTypeTemple->Name
                           );
            }

            tplIndLevel += pktTemple->IndLevel;

            if (IsSameType(pkt,
                           pCGenState->ApiTypes->RetIndLevel,
                           TK_NONE,
                           pTypeTemple->Name,
                           tplIndLevel,
                           TK_NONE,
                           i == 0
                           )) {
                 DbgPrintf("ttpl: RETURN %s.%s Type=%s IndLevel=%d\n",
                           CGenState.ApiTypes->FuncRet,
                           pTypeTemple->Name,
                           pTypeTemple->Name,
                           pTypeTemple->IndLevel
                          );

                if (pTypeTemple->CodeBurst[CodeBurstIndex]) {
                    pSrc = pTypeTemple->CodeBurst[CodeBurstIndex];
                    while (*pSrc && !isgraph(*pSrc)) {
                        pSrc++;
                    }
                    if (*pSrc) {
                        CGenerate(pSrc, &CGenState);
                    }
                }

                i = 0;
                break;  // break from while loop over all templates
            }

        NextTemple = NextTemple->Flink;
        }

    }
    
    GenHeapFree(pCGen);
    FreeMacroArgsList(pMArgsList);

    return pEnd;
}

VOID
SetArgListToTypeForArg(
    PARGSLIST pArgsList,
    PARGSLIST pArgsListOld,
    char * pTypeName
    )
{
   int IndLevel = 0;
   char TypeNameCopy[MAX_PATH];
   PKNOWNTYPES pkt;
   char *p;
   BOOL bIsTypedef = TRUE;

   *pArgsList = *pArgsListOld;
   p = pTypeName;
   strcpy(TypeNameCopy, p);
   p = TypeNameCopy;

   while(*p != '\0') {
      if (*p == '*') {
         IndLevel++;
         *p = ' ';
      }
      p++;
   }

   ResetLexer();
   LexMacroArgs(TypeNameCopy);
   ConsumeConstVolatileOpt();
   
   if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        bIsTypedef = FALSE;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {
            ExitErrMsg(FALSE, "SetArgListToType: %s is not a valid type\n", TypeNameCopy);
        }
   }

   pArgsList->pKnownTypes = pkt;
   pArgsList->pStructType = NULL;   
   //DWORD        ArgSize;            // size of this arg (should be unchanged)
   pArgsList->IsPtr64 = (IndLevel == 0 && (pkt->Flags & BTI_PTR64));
   //BOOL         IsPtr64;            // TRUE if this arg is __ptr64 (should be unchanged)
   //int          OffSet;             // offset from stack for this arg(should be unchanged)
   pArgsList->IndLevel = IndLevel;
   //TOKENTYPE    tkDirection;        // TK_NONE, TK_IN, TK_OUT, TK_INOUT(should be unchanged)
   //TOKENTYPE    Mod;                // modifier (TK_CONST/VOLATILE/NONE)(should be unchanged)
   
   if (!bIsTypedef) {
      if (strcmp(pkt->BasicType, szSTRUCT) == 0) {
         pArgsList->SUEOpt = TK_STRUCT;
      } else if (strcmp(pkt->BasicType, szUNION) == 0) {
         pArgsList->SUEOpt = TK_UNION;
      } else if (strcmp(pkt->BasicType, szENUM) == 0) {
         pArgsList->SUEOpt = TK_ENUM;
      } else {
         pArgsList->SUEOpt = TK_NONE;
      }
   }

  pArgsList->Type = pkt->TypeName; 
   //TOKENTYPE    PostMod;            // modifier (TK_CONST/VOLATILE/NONE)
   //TOKENTYPE    PrePostMod;         // modifier (TK_CONST/VOLATILE/NONE)
   //char          *Name;              // argument name (may be a nonameX)
   //char         *ArgLocal;          // name of local var containing copy of arg
   //char         *HostCastedName;    // Contains full name of struct member with 
                                    // host casts or NULL
  pArgsList->fRequiresThunk = pkt->Flags & BTI_CONTAINSFUNCPTR;
  pArgsList->fNoType = FALSE;            // TRUE if types templates should *not*
                                    //  be expanded for this param.
   //BOOL         fIsMember;          // This arg is actually a member of an array
   //BOOL         bIsBitfield;        // Determines if this is a bitfield
   //int          BitsRequired;       // Number of bits required for bitfield
   //BOOL         bIsArray;           // This member is an array
   //int          ArrayElements;      // Number of elements in the array

}



BOOL
ExpandTypesForApi(
    PLIST_ENTRY ArgsListHead,
    PCGENSTATE CGenState,
    PLIST_ENTRY pTypesList,
    int CodeBurstIndex,
    BOOL bExpandAll,
    BOOL bRtoL
    )
{
   int  i, Len;
   int tplIndLevel;
   PCGENERATE pCGen;
   PARGSLIST pArgsList;
   PTEMPLES pTypeTemple;
   PKNOWNTYPES pktArgs, pktTemple;
   PLIST_ENTRY NextArg, NextTemple;
   BOOL fKeepGoing = TRUE;

   //
   // For each argument process a type template if any.
   //

   if ( bRtoL )
   {
      NextArg = &CGenState->ExportsDbg->ArgsListHead;
      NextArg = NextArg->Blink;
   }
   else
   {
      NextArg = ArgsListHead;
   }

   do
   {
       CGenState->pArgsList = CONTAINING_RECORD(NextArg,ARGSLIST,ArgumentsEntry);

        if (CGenState->pArgsList->fNoType) {
            //
            // This arg is listed in this API's [EFunc] NoTypes list.
            // Do not expand [Types] templates for it.
            //
            goto NextArg;
        }


       ResetLexer();
       LexMacroArgs(CGenState->pArgsList->Type);
       ConsumeConstVolatileOpt();

        // Get KnownTypes info for Argument
        if (ParseTypes(TypeDefsList, NULL, &pktArgs) == FALSE) {
            CurrentTokenIndex = 0;
            if (ParseTypes(StructsList, NULL, &pktArgs) == FALSE ) {
                ErrMsg(
                      "Args: Type not found %s %s\n",
                       CGenState->pArgsList->Type,
                       CGenState->ApiTypes->TypeName
                       );
               return fKeepGoing;
            }
        }

        fKeepGoing = !ExpandType(CGenState, CGenState->pArgsList->pKnownTypes, 
                                 pTypesList, CodeBurstIndex);
        fKeepGoing = fKeepGoing | bExpandAll;

NextArg:
      if ( bRtoL )
      {
         if ( NextArg == ArgsListHead )
         {
             break;
         }

         NextArg = NextArg->Blink;
      }
      else
      {
         NextArg = NextArg->Flink;

         if ( NextArg == &CGenState->ExportsDbg->ArgsListHead )
         {
            break;
         }
      }

   } while (fKeepGoing);

   return fKeepGoing;
}

/*
 *  IncludeTypes
 *
 */
char *IncludeTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bRtoL)
{
   char *pEnd;
   char *pch;
   int  Len;
   PCGENERATE pCGen;
   CGENSTATE CGenState;
   PARGSLIST pArgsList;
   PLIST_ENTRY NextArg;
   char BurstName[MAX_PATH];
   PMACROARGSLIST pMArgsList = NULL;
   SIZE_T BytesReturned;
   int CodeBurstIndex;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   //
   // Functions must have an argument list (at least void)
   //
   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n IncludeTypes Missing argument List: %s\n",
               pCGenState->ApiTypes->TypeName
               );

       return pEnd;
       }


   //
   // If void arg list, nothing to do!
   //
   NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;
   pArgsList = CONTAINING_RECORD(NextArg, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return pEnd;
       }

   ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

   if (pMArgsList->NumArgs < 1) {
      ExitErrMsg(FALSE, "IncludeTypes: CodeBurst name required\n");
   }

   CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
   CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
   if (CodeBurstIndex == -1) {
       ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
   }

   pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
   if (!pCGen) {
       ExitErrMsg(TRUE, "it: %s\n", pSrc);
       }

   InitializeListHead(&pCGen->CGenerateEntry);
   
   pCGen->fp = pCGenState->CGen->fp;   
   pCGen->FileNameC = pCGenState->CGen->FileNameC;
   pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
   pCGen->fpCpp = pCGenState->CGen->fpCpp;
   pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
   pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
   strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);

   CGenState = *pCGenState;
   CGenState.CGen = pCGen;

   if (pMArgsList->NumArgs >= 2) {
      char ArgName[MAX_PATH];
      char TypeName[MAX_PATH];
      char CastedArgName[MAX_PATH];
      size_t ArgNameLen;
      size_t ArgTypeLen;
      char *p;
      BOOL bHasType = FALSE;

      //extract arg name to expand types for
      CGenerateEx(pMArgsList->ArgText[1], pCGenState, ArgName, MAX_PATH, &BytesReturned);
      if (BytesReturned == 0) {
         ExitErrMsg(FALSE, "IncludeTypes: Empty arg name is not allowed.\n");
      }
      ArgNameLen = BytesReturned - 1;

      if (pMArgsList->NumArgs == 3) {

         //extract the type name
         CGenerateEx(pMArgsList->ArgText[2], pCGenState, TypeName, MAX_PATH, &BytesReturned);
         if (BytesReturned == 0) {
            ExitErrMsg(FALSE, "IncludeTypes: Empty type name is not allowed.\n");
         }

         ArgTypeLen = BytesReturned - 1;
         bHasType = TRUE;

         if (ArgTypeLen + ArgNameLen + 4 >= MAX_PATH) {
            ExitErrMsg(FALSE, "ArgType + ArgName is too long\n");
         }

         memcpy(CastedArgName, "((", 2);
         p = CastedArgName + 2;
         memcpy(p, TypeName, ArgTypeLen);
         p += ArgTypeLen;         
         memcpy(p, ")", 1);
         p++;
         memcpy(p, ArgName, ArgNameLen);
         p += ArgNameLen;
         memcpy(p, ")", 2);

      }

      else {
         ExitErrMsg(FALSE, "IncludeTypes: Too many arguments\n");
      }

      //Find arg in the arglist.
      do {

        pArgsList = CONTAINING_RECORD(NextArg, ARGSLIST, ArgumentsEntry);
        if (pArgsList->Name != NULL) {
           if (strcmp(pArgsList->Name, ArgName) == 0) {
              //Expand this argument
              
              if (bHasType) {
                 CGenState.pArgsList = GenHeapAlloc(sizeof(ARGSLIST));
                 if(NULL == CGenState.pArgsList)
                    ExitErrMsg(FALSE, "IncludeTypes: out of memory.\n");
                 SetArgListToTypeForArg(CGenState.pArgsList, pArgsList, TypeName);
                 CGenState.pArgsList->Name = CastedArgName;
              }
              else {
                 CGenState.pArgsList = pArgsList;
              }

              if (!ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &FailTempleList, CodeBurstIndex))
                 ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);
              
              if (bHasType) {
                 GenHeapFree(CGenState.pArgsList);
              }
              
              GenHeapFree(pCGen);
              FreeMacroArgsList(pMArgsList);
              return pEnd;
           }
        }
              
        NextArg = NextArg->Flink;
      } while (NextArg != &CGenState.ExportsDbg->ArgsListHead);
      ExitErrMsg(FALSE, "IncludeTypes: %s is not a known argument for %s\n", ArgName, pCGenState->ExportsDbg->ExportName);

   }
   else {
      if (ExpandTypesForApi(NextArg,
                            &CGenState,
                            &FailTempleList,
                            CodeBurstIndex,
                            FALSE,
                            bRtoL)) {

         ExpandTypesForApi(NextArg,
                            &CGenState,
                            &TypeTempleList,
                            CodeBurstIndex,
                            TRUE,
                            bRtoL);
      }
   }

   GenHeapFree(pCGen);
   FreeMacroArgsList(pMArgsList);
   return pEnd;
}




/*
 *   IsSameType
 *
 */
PKNOWNTYPES
IsSameType(
    PKNOWNTYPES pktArgs,
    int IndLevel,
    TOKENTYPE tkArgDirection,
    char *tplTypeName,
    int tplIndLevel,
    TOKENTYPE tkTypeDirection,
    BOOL bScanBaseTypes
    )
{ 

    if (*tplTypeName != '*' && strcmp(tplTypeName, "default") != 0 &&
        IndLevel + pktArgs->IndLevel != tplIndLevel) {
        //
        // Not a generic '*' or 'default' types template, and levels of indirection
        // don't match
        //
        return NULL;
    }

    if (!bUseDirection) {
        tkArgDirection = TK_NONE;
    }
    if (tkTypeDirection != TK_EOS && tkArgDirection != tkTypeDirection) {
        //
        // Direction-sensitivity enabled, type template isn't generic to
        // all directions, and IN, OUT, IN/OUT don't match
        //
        return NULL;
    }

    if (!strcmp(pktArgs->TypeName, tplTypeName)) {
        //
        // type names match
        //
        return pktArgs;
    }

    if (bScanBaseTypes) {
        PKNOWNTYPES pkt;

        if (strcmp(tplTypeName, "struct") == 0 &&
            strcmp(pktArgs->BasicType, "struct") == 0) {
            //
            // This matches a generic 'struct' template.
            //
            return pktArgs;
        }

        if (strcmp(tplTypeName, "union") == 0 &&
            strcmp(pktArgs->BasicType, "union") == 0) {
            //
            // This matches a generic 'union' template.
            //
            return pktArgs;
        }

        if (*tplTypeName == '*' && IndLevel+pktArgs->IndLevel) {
            //
            // The template is a generic pointer template, and the arg type
            // is a pointer to something.  Match.
            //
            return pktArgs;
        }

        if (!strcmp(pktArgs->BaseName, pktArgs->TypeName)) {
           //
            // Base name of the arg type matches this arg type, no
            // possiblity of a match.
            //
            pkt = NULL; 
            goto try_default;
        }

        //
        // Get the knowntype for basetype of the arg
        //
        if (pktArgs->pktBase) {
            // the knowntype is already cached
            pkt = pktArgs->pktBase;
        } else {
            pkt = GetNameFromTypesList(TypeDefsList, pktArgs->BaseName);
            if (!pkt) {
                pkt = GetNameFromTypesList(StructsList, pktArgs->BaseName);
            }
            if (!pkt) {
                goto try_default;
            }
            pktArgs->pktBase = pkt;
        }

        IndLevel += pktArgs->IndLevel - pkt->IndLevel;

        pkt = IsSameType(pkt,
                         IndLevel,
                         tkArgDirection,
                         tplTypeName,
                         tplIndLevel,
                         tkTypeDirection,
                         TRUE
                         );

        if (NULL == pkt) {
try_default:
            // The default type template matches everything
            if (strcmp(tplTypeName, "default") == 0) {
               //printf("Applying default template to %s\n", pktArgs->TypeName);
               return pktArgs;
            }
        }

        return pkt;

    }

    return NULL;
}



/*
 * GetAltExportName
 *
 * Fetches the forward name if one exists, returns NULL if none.
 *
 */
char *GetAltExportName(char *Buffer, PCGENSTATE pCGenState, int Len)
{
   PKNOWNTYPES pkt;
   PEXPORTSDEBUG pExportDebug;

   PLIST_ENTRY Next;
   int i;

   pExportDebug = pCGenState->ExportsDbg;

   if (pExportDebug->ExtForward) {
       i = _snprintf(Buffer, Len, "=%s", pExportDebug->ExtForward);
       }
   else if (pExportDebug->IntForward) {
       if (bNoFuzzyLogic && !strchr(pExportDebug->IntForward->ExportName, '@')) {

           i = _snprintf(Buffer, Len, "=%s%s@%d",
                         szINTFORWARD,
                         pExportDebug->IntForward->ExportName,
                         GetArgSize(pExportDebug)
                         );
           }
       else {
           i = _snprintf(Buffer, Len, "=%s%s",
                         szINTFORWARD,
                         pExportDebug->IntForward->ExportName
                         );
           }
       }
   else if (bNoFuzzyLogic &&
            !strchr(pExportDebug->ExportName, '@') &&
            !strstr(pCGenState->ApiTypes->FuncMod, "cdecl"))
      {
       i = _snprintf(Buffer, Len, "=%s@%d",
                     pExportDebug->ExportName,
                     GetArgSize(pExportDebug)
                     );
       }
   else {
       return NULL;
       }


   if (i < 0) {
       ExitErrMsg(FALSE,
                  "GetAltExportName: Overflow %s\n",
                  pExportDebug->ExportName
                  );
       }

   return Buffer;

}



/*
 *  IncludeTemplate
 *
 */
char *IncludeTemplate(char *pSrc, PCGENSTATE pCGenState)
{
   char *pEnd;
   char *pch;
   size_t  Len;
   PCGENERATE pCGen;
   CGENSTATE CGenState;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   pch = pSrc + 1;
   if (IsSeparator(*pch)) {
       return pSrc;
       }

   pSrc = pch;
   while (!IsSeparator(*pch)) {
      pch++;
      }
   Len = pch - pSrc;

   pCGen = GenHeapAlloc(Len + 1 + sizeof(CGENERATE));
   if (!pCGen) {
       ExitErrMsg(TRUE, "it: %s\n", pSrc);
       }

   InitializeListHead(&pCGen->CGenerateEntry);
   pCGen->fp = pCGenState->CGen->fp;
   pCGen->fpC = pCGenState->CGen->fpC;
   pCGen->FileNameC = pCGenState->CGen->FileNameC;
   pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
   pCGen->fpCpp = pCGenState->CGen->fpCpp;
   pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
   pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
   memcpy(pCGen->TempleName, pSrc, Len);
   *(pCGen->TempleName + Len) = '\0';

   memset(&CGenState, 0, sizeof(CGENSTATE));
   CGenState.CGen = pCGen;

   CGenState.ExportsDbg = pCGenState->ExportsDbg;
   CGenState.DebugStrings = pCGenState->DebugStrings;
   CGenState.ApiTypes = pCGenState->ApiTypes;
   CGenState.ApiNum = pCGenState->ApiNum;
   CGenState.pArgsList = pCGenState->pArgsList;
   CGenState.ListCol = pCGenState->ListCol;
   CGenState.MoreApis = pCGenState->MoreApis;
   CGenState.CodeBurstIndex = pCGenState->CodeBurstIndex;

   ProcessTemple(&CGenState);

   GenHeapFree(pCGen);
   return pEnd;
}



/*
 *  WriteMore
 */
char *WriteMore(char *pSrc, PCGENSTATE pCGenState, BOOL bMore)
{
   char *pch;
   char *pExpression;
   CGENSTATE CGenState;

   pch = SkipSubExpression(pSrc, bMore ? &pExpression : NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pSrc = pch;

   if (!bMore || !pExpression) {
       return pSrc; 
       }

   CGenState = *pCGenState;
   CGenerate(pExpression, &CGenState);

   GenHeapFree(pExpression);
   return pSrc;
}




/*
 *  WriteArgLocal
 */
BOOL
WriteArgLocal(
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen)
{
   char *pExpression;
   char *pEnd;
   char *pch;
   int i, Len;

   if (pCGenState->pArgsList->ArgLocal) {
       ErrMsg("Type Template error multiple ArgLocals\n");
       return FALSE;
       }

   // format the local var name
   Len = _snprintf(Buffer, BuffLen, "%s", pCGenState->pArgsList->Name);
   if (Len <= 0) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   // alloc space for the local var name, and stash it away
   pCGenState->pArgsList->ArgLocal = GenHeapAlloc(Len + 1);
   if (!pCGenState->pArgsList->ArgLocal) {
        ErrMsg("GenHeapAlloc(ArgLocal) %s\n", pCGenState->pArgsList->Name);
        return FALSE;
        }
   strcpy(pCGenState->pArgsList->ArgLocal, Buffer);

   //
   // format the declarator statement: "ArgType IndLevel *ArgName"
   //

   pch = Buffer;
   i = strlen(pCGenState->pArgsList->Type) +
       strlen(TokenString[pCGenState->pArgsList->SUEOpt]) + 1;
   if (i >= BuffLen) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
       strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
       strcat(pch, " ");
       strcat(pch, pCGenState->pArgsList->Type);
   } else {
       strcpy(pch, pCGenState->pArgsList->Type);
   }
   if (pCGenState->pArgsList->PrePostMod != TK_NONE) {
       strcat(pch, " ");
       strcat(pch,  TokenString[pCGenState->pArgsList->PrePostMod]);
   }
   i = strlen(pch);
   Len = BuffLen - i - 1;
   pch += i;
   
   i = pCGenState->pArgsList->IndLevel;
   if (!Len || i > Len) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

    if (i) {
        *pch++ = ' ';
        while (i) {
            *pch++ = '*';
            i--;
        }
    }
   *pch++ = ' ';

   i = strlen(pCGenState->pArgsList->ArgLocal);
   if (!Len || i > Len) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   strcpy(pch, pCGenState->pArgsList->ArgLocal);

   //
   // Record that some kind of exception template has been used
   // during generation of this argument.
   //
   pCGenState->pArgsList->fRequiresThunk = FALSE;

   return TRUE;
}




/*
 *  WriteArgAddr
 */
char *
WriteArgAddr(
       char *pSrc,
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen)
{
   char *pEnd;
   char *pch;
   size_t Len;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   Len = --pch - ++pSrc;

   if (Len + 32 >= (size_t)BuffLen) {
       ExitErrMsg(FALSE,
                  "WriteArgAddr buffer overflow %s\n",
                  pSrc
                  );
       }

   while (pSrc < pch) {
      *Buffer++ = *pSrc++;
      }

   *Buffer++ = ' ';
   *Buffer++ = '+';
   *Buffer++ = ' ';

   _itoa(pCGenState->pArgsList->OffSet, Buffer, 10);

   return pEnd;
}



BOOLEAN
TempleHasNoCodeBursts(
    PTEMPLES pTemple
    )
/*++

Routine Description:

    Determines if a template has no codebursts at all or not.

Arguments:

    pTemple     - template to examine

Return Value:

    TRUE if template has no codebursts, FALSE if there is at least one.

--*/
{
    int i;

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (pTemple->CodeBurst[i]) {
            return FALSE;
        }
    }

    return TRUE;
}


/*
 *  ListApis
 */
char *ListApis(char *pSrc, PCGENSTATE pCGenState, BOOL bExports)
{

   char *pch;
   char *pExpression;
   PLIST_ENTRY Next;
   CGENSTATE CGenState;
   PTEMPLES pTemple;
   BOOL GenerateCode;
   BYTE ApiPlatform;
   BOOL ExcludedApi;

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   memset(&CGenState, 0, sizeof(CGenState));
   CGenState.CGen = pCGenState->CGen;
   CGenState.Temple = pCGenState->Temple;
   CGenState.MoreApis = TRUE;
   CGenState.ListCol = pCGenState->ListCol;
   CGenState.CodeBurstIndex = pCGenState->CodeBurstIndex;

   Next = ExportsList.Flink;
   while (Next != &ExportsList) {
       CGenState.ExportsDbg = CONTAINING_RECORD(Next,
                                                EXPORTSDEBUG,
                                                ExportsDbgEntry
                                                );

       Next= Next->Flink;
       if (Next == &ExportsList) {
           CGenState.MoreApis = FALSE;
           }

       //
       // Switch this API in or out depending on the platform info
       //
       ApiPlatform = CGenState.ExportsDbg->ApiPlatform;
       PlatformSwitchStart(&CGenState, ApiPlatform);

       CGenState.ApiTypes = GetApiTypes(CGenState.ExportsDbg);

       pTemple = GetTemplate(&EFuncTempleList,
                             CGenState.ExportsDbg->ExportName
                             );



       ExcludedApi = FALSE;

           // skip this api if ex template, but no code
       if (!bExports && pTemple && TempleHasNoCodeBursts(pTemple)) {
      ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluded Api %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

          //
          // skip this api if:
          // - external forward reference
          // - internal forward which does not define the function.
          //   (exportname != forwardname)
          //
       else if (!bExports &&
                (CGenState.ExportsDbg->ExtForward ||
                 (CGenState.ExportsDbg->IntForward &&
                  CGenState.ExportsDbg->IntForward != CGenState.ExportsDbg)))
          {
            ExcludedApi = TRUE;
            fprintf(pCGenState->CGen->fp,
                     "%s %s forwarded to %s\n",
                    CGenState.Temple->Comment,
                    CGenState.ExportsDbg->ExportName,
                    CGenState.ExportsDbg->ExtForward
                       ? CGenState.ExportsDbg->ExtForward
                       : CGenState.ExportsDbg->IntForward->ExportName
                    );

            }


          // skip this api if DATA and no ex template
       else if (!pTemple && CGenState.ExportsDbg->Data) {
           ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluded Data Export %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

          // skip this api if CPP export and we aren't setup for CPP exports,
       else if (!pTemple && !iHandleCpp && CGenState.ExportsDbg->CplusDecoration)
         {
           ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluding CPP Api: %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

           // skip this api if members are unknown
       else if (!CGenState.ApiTypes->pfuncinfo) {
           ExcludedApi = TRUE;
           ExitErrMsg(FALSE, 
                      "API %s has no function prototype - unable to generate code.", 
                      CGenState.ExportsDbg->ExportName
                     );

           }

           // gen code for this api
       else {

           if (pTemple) {
               CGenState.ExTemplate= TRUE;
               }
           else {
               CGenState.ExTemplate= FALSE;
               }

           BuildArgsList(pTemple,
                         CGenState.ApiTypes->pfuncinfo,
                         &CGenState.ExportsDbg->ArgsListHead
                         );


           if (GetArgSize(CGenState.ExportsDbg) < 0) {
          ExcludedApi = TRUE;
               ExitErrMsg(FALSE, 
                          "API %s has no function prototype - unable to generate code.", 
                          CGenState.ExportsDbg->ExportName
                         );
               }
           else {
               CGenerate(pExpression, &CGenState);

               if (bExports) {
                    //
                    // we're generating the .DEF file.   Mark some APIs
                    // as private so the linker doesn't warn us.
                    //
                    if (strcmp(CGenState.ExportsDbg->ExportName,
                               "DllGetClassObject") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllCanUnloadNow") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllRegisterServer") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllRegisterServerEx") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllInstall") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllUnregisterServer") == 0) {

                        fprintf(pCGenState->CGen->fp, " PRIVATE");
                    }

               }
               CGenState.ApiNum++;
               }
           }

       if (bExports)
    PlatformSwitchEnd(&CGenState, ApiPlatform);
       else{
    if (ExcludedApi)
      PlatformSwitchEnd(&CGenState, ApiPlatform);
    else
      PlatformSwitchEndTable(&CGenState, ApiPlatform);
       }

       if (CGenState.ListCol) {
           WriteListColumn(&CGenState);
           }
       }

   GenHeapFree(pExpression);
   return pSrc;
}


PKNOWNTYPES
BuildFakeTypesInfo(
    PEXPORTSDEBUG pExportsDbg,
    PKNOWNTYPES pKnownTypes
    )
{
   TYPESINFO ti;
   int ArgsSize, i;
   size_t Len;
   PFUNCINFO funcinfo;
   char *pch;

   memset(&ti, 0, sizeof(TYPESINFO));
   strcpy(ti.TypeName, pExportsDbg->ExportName);

   if (pKnownTypes) {
       strcpy(ti.BasicType, pKnownTypes->BasicType);
       strcpy(ti.BaseName, pKnownTypes->BaseName);
       strcpy(ti.FuncRet, pKnownTypes->FuncRet);
       strcpy(ti.FuncMod, pKnownTypes->FuncMod);

       pExportsDbg->UnKnownApi = -1; // incomplete fn declaration

       /*
        *  WARNING:
        *  The type is added to the FakeFuncsList with args
        *  info from the dll symbols. The type is NOT removed
        *  from the FuncsList.
        */

       }
   else {
       strcpy(ti.BasicType, szFUNC);
       strcpy(ti.FuncRet, szINT);

       pExportsDbg->UnKnownApi = 1;  // missing fn declaration
       }

   ArgsSize = pExportsDbg->ArgsSize;

   if (!ArgsSize) {
       ti.TypeKind = TypeKindFunc;
       ti.dwMemberSize = sizeof(FUNCINFO) + strlen(szVOID) + 1;
       ti.pfuncinfo = (PFUNCINFO)ti.Members;
       pch = ti.Members + sizeof(FUNCINFO);
       strcpy(pch, szVOID);
       ti.pfuncinfo->sType = pch;
       }
   else if (ArgsSize < 0) {
       ;
       }
   else {
       ti.TypeKind = TypeKindFunc;
       pch = ti.Members + sizeof(FUNCINFO);
       Len = sizeof(ti.Members) - 1 - sizeof(FUNCINFO);
       funcinfo = (PFUNCINFO)ti.Members;
       ti.pfuncinfo = funcinfo;
       while (ArgsSize && Len) {
           ti.dwMemberSize+=sizeof(FUNCINFO);
           i = _snprintf(pch, Len, "Fake%x", ArgsSize);
           if (i < 0) {
               return NULL;
               }
           i++;
           Len -= i;
           funcinfo->sName = pch;
           pch += i;
           ti.dwMemberSize+=i;
           strcpy(pch, szINT);
           funcinfo->sType = pch;
           i = strlen(szINT) + 1;
           pch += i;
           ti.dwMemberSize+=i;
           ArgsSize -= sizeof(int);

           if (ArgsSize) {
               PFUNCINFO funcinfoNext;
               INT_PTR Realignment;

               //
               // Allocate space for another FUNCINFO, ensuring that
               // it is DWORD-aligned.
               //
               Len -= sizeof(FUNCINFO);
               Realignment = 4 - ((INT_PTR)pch & 3);
               Len -= Realignment;
               funcinfoNext = (PFUNCINFO)(pch + Realignment);
               pch += sizeof(FUNCINFO)+Realignment;
               ti.dwMemberSize += (DWORD)Realignment;
               if ((INT_PTR)Len < 0) {
                   return NULL;
                   }
               funcinfo->pfuncinfoNext = funcinfoNext;
               funcinfo = funcinfoNext;
               }
           }
       }

   return AddToTypesList(&FakeFuncsList, &ti);
}

/*
 *  GetFuncArgNum
 */
int GetFuncArgNum(PCGENSTATE pCGenState)
{
   PARGSLIST pArgsList;
   PKNOWNTYPES pkt;
   int NumArgs;
   PFUNCINFO funcinfo;

   pArgsList = pCGenState->pArgsList;

   if (!pArgsList) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncArgNum Missing argument List\n\n"
               );

       return -1;
       }

   pkt = pArgsList->pKnownTypes;
   while (!pkt->Members || !pkt->pfuncinfo) {
       if (pkt->pktBase) {
           // the knowntype is already cached
           pkt = pkt->pktBase;
       } else {
           PKNOWNTYPES pktOrg = pkt;
           pkt = GetNameFromTypesList(TypeDefsList, pkt->BaseName);
           if (!pkt) {
               if (pArgsList->pKnownTypes) {
                   fprintf(pCGenState->CGen->fp,
                           "\n\t*** ERROR ***\n*** GetFuncArgNum BaseType Not found:<%s:%s>\n\n",
                           pArgsList->pKnownTypes->TypeName,
                           pArgsList->pKnownTypes->BasicType
                           );
               } else {
                   fprintf(pCGenState->CGen->fp,
                           "\n\t*** ERRR ***\n*** GetFuncArgNum BaseType Not found: no KnownTypes\n\n"
                          );
                   }
               return -1;
               }
            pktOrg->pktBase = pkt;
       }

       if (!strcmp(pkt->BasicType, pkt->TypeName)) {
           break;
           }
       }

   funcinfo = pkt->pfuncinfo;
   if (!pkt->Members || !funcinfo) {
       fprintf(pCGenState->CGen->fp,
               "/*** WARN gfan No Members:<%s:%s> ***/ ",
               pArgsList->pKnownTypes->TypeName,
               pkt->BasicType
               );

       return 0;
   }

   //
   //  "..." vargs is nonsense can't do it!
   //
   if (strcmp(funcinfo->sType, szVARGS) == 0) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncArgNum variable Args:<%s:%s>\n\n",
               pArgsList->pKnownTypes->TypeName,
               pkt->BasicType
               );
       return -1;
   }

   //
   //  void arg list, Zero Args
   //
   if (strcmp(funcinfo->sType, szVOID) == 0) {
       return 0;
   }

   NumArgs = 0;
   do {
       NumArgs++;
       funcinfo = funcinfo->pfuncinfoNext;
   } while(funcinfo);

   return NumArgs;
}



/*
 *  GetFuncIndex
 */
int GetFuncIndex(PCGENSTATE pCGenState, char *FuncTypeName)
{
   PKNOWNTYPES pkt, pktFunc;
   int  Len, LenExpr, LenArgs, LenRet;
   char *pch;
   char Args[1024];
   PFUNCINFO funcinfo;
   PDEBUGSTRINGS DebugStrings;

   if (!FuncTypeName || !*FuncTypeName) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncIndex TypeName Not specified\n\n"
               );
       return -1;
       }

   pkt = GetNameFromTypesList(TypeDefsList, FuncTypeName);
   if (!pkt) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncIndex Type Not found:<%s>\n\n",
               FuncTypeName
               );
       return -1;
       }

   pktFunc = pkt;
   while (!pkt->Members || !pkt->pfuncinfo) {
       // NOTE: we cannot look at pkt->pktBase as it may point to a struct
       //       knowntype instead of a typedef
       pkt = GetNameFromTypesList(TypeDefsList, pkt->BaseName);
       if (!pkt) {
           fprintf(pCGenState->CGen->fp,
                   "\n\t*** ERROR ***\n*** GetFuncIndex BaseType Not found:<%s:%s>\n\n",
                   FuncTypeName,
                   pktFunc->BaseName
                   );
           return -1;
           }

       if (!strcmp(pkt->BasicType, pkt->TypeName)) {
           break;
           }
       }


   LenArgs = 1;
   Args[0] = '\0';

   funcinfo = pkt->pfuncinfo;
   if (pkt->Members && funcinfo) {

        //
        //  "..." vargs is nonsense can't do it!
        //
        if (strcmp(funcinfo->sType, szVARGS) == 0) {
            fprintf(pCGenState->CGen->fp,
                    "\n\t*** ERROR ***\n*** GetFuncIndex variable Args:<%s:%s>\n\n",
                    FuncTypeName,
                    pkt->BasicType
                    );
            return -1;
        }

        //
        //  void arg list means no args
        //
        if (strcmp(funcinfo->sType, szVOID) != 0) {
            pch = Args;
            do {
                //
                // Copy in the typename
                //
                Len = strlen(funcinfo->sType);
                LenArgs += Len;
                if (LenArgs >= sizeof(Args)-3) {
                    break;
                }
                strcpy(pch, funcinfo->sType);
                pch += Len;

                //
                // Copy in the levels of indirection
                //
                LenArgs += funcinfo->IndLevel;
                if (LenArgs >= sizeof(Args)-3) {
                    break;
                }
                for (Len = 0; Len<funcinfo->IndLevel; ++Len) {
                    *pch++ = '*';
                }

                //
                // Copy in the argument name, if present
                //
                if (funcinfo->sName) {
                    Len = strlen(funcinfo->sName) + 1;
                    LenArgs += Len;
                    if (LenArgs >= sizeof(Args)-3) {
                        break;
                    }
                    *pch = ' ';
                    strcpy(pch+1, funcinfo->sName);
                    pch += Len;
                }

                //
                // Copy in the printf-style formatting for this argument
                //
                LenArgs += 3;
                *pch++ = ' ';
                *pch++ = '%';
                *pch++ = 'x';
                funcinfo = funcinfo->pfuncinfoNext;
                if (funcinfo) {
                    LenArgs+=2;
                    *pch++ = ',';
                    *pch++ = ' ';
                }
            } while (funcinfo);

           if (LenArgs >= sizeof(Args)-5) {
               ExitErrMsg(FALSE,
                          "GetFuncIndex overflow %s.%s\n",
                          FuncTypeName,
                          pkt->Members
                          );
               }
           }

           //
           // Null-terminate the Args[] string.
           //
           Args[LenArgs-1] = '\0';
       }



   LenExpr = strlen(FuncTypeName) + 1;
   LenRet = strlen(pkt->FuncRet) + 4;

   DebugStrings = GenHeapAlloc(LenExpr + LenRet + LenArgs + sizeof(DEBUGSTRINGS));
   if (!DebugStrings) {
       ExitErrMsg(TRUE,
                  "GetFuncIndex: GenHeapAlloc(DebugStrings) %s.%s\n",
                  FuncTypeName,
                  pkt->Members
                  );
       }

   Len = 0;
   DebugStrings->Name = DebugStrings->Buffer;
   strcpy(DebugStrings->Name, FuncTypeName);
   Len += LenExpr;

   DebugStrings->ArgFormat = DebugStrings->Buffer + Len;
   strcpy(DebugStrings->ArgFormat, Args);
   Len += LenArgs;

   DebugStrings->RetFormat = DebugStrings->Buffer + Len;
   strcpy(DebugStrings->RetFormat, pkt->FuncRet);
   strcat(DebugStrings->RetFormat, " %x");
   Len += LenRet;

   InsertTailList(&DebugStringsList, &DebugStrings->DebugStringsEntry);

   return NumDebugStringsEntries++;
}




/*
 *  WriteDbgsStrings
 *
 */
void WriteDbgsStrings(char *pSrc, PCGENSTATE pCGenState)
{
    DEBUGSTRINGS DebugStrings;
    char BaseName[MAX_PATH];
    char *c;

    // copy in the DLL name and whack off the extension
    strcpy(BaseName, DllBaseName);
    c = strchr(BaseName, '.');
    if (c) {
        *c = '\0';
    }

    if (!pCGenState->DebugStrings) {
        pCGenState->DebugStrings = &DebugStrings;
        DebugStrings.Name =
        DebugStrings.ArgFormat =
        DebugStrings.RetFormat = "";
        }

    fprintf(pCGenState->CGen->fp,
            "\"%s!%s\",\"%s\",\"%s\"",
            BaseName,
            pCGenState->DebugStrings->Name,
            pCGenState->DebugStrings->ArgFormat,
            pCGenState->DebugStrings->RetFormat
            );
}


/*
 *  ListDbgs
 */
char *ListDbgs(char *pSrc, PCGENSTATE pCGenState)
{

   char *pch;
   char *pExpression;
   PLIST_ENTRY Next;
   CGENSTATE CGenState;
   PTEMPLES pTemple;

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   memset(&CGenState, 0, sizeof(CGenState));
   CGenState.CGen = pCGenState->CGen;
   CGenState.Temple = pCGenState->Temple;
   CGenState.ListCol = pCGenState->ListCol;

   if (!IsListEmpty(&DebugStringsList)) {
       Next = DebugStringsList.Flink;
       while (Next != &DebugStringsList) {
           CGenState.DebugStrings = CONTAINING_RECORD(Next,
                                                      DEBUGSTRINGS,
                                                      DebugStringsEntry
                                                      );

           Next= Next->Flink;
           CGenState.MoreApis = Next != &DebugStringsList;
           CGenerate(pExpression, &CGenState);
           if (CGenState.ListCol) {
               WriteListColumn(&CGenState);
               }
           }
       }
   else {
       CGenState.MoreApis = FALSE;
       CGenerate(pExpression, &CGenState);
       if (CGenState.ListCol) {
           WriteListColumn(&CGenState);
           }
       }

   GenHeapFree(pExpression);
   return pSrc;
}


/*
 *  ListArgs
 */
char *ListArgs(char *pSrc, PCGENSTATE pCGenState, BOOL Always)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   char *pch;
   char *pExpression;
   CGENSTATE CGenState;

   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** ListArgs Missing argument List: %s\n\n",
               pCGenState->ApiTypes->TypeName
               );

       return SkipSubExpression(pSrc, NULL);
       }

   Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

   // check for void arg list
   if (!Always) {
       pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
       if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
           return SkipSubExpression(pSrc, NULL);
           }
       }

   CGenState = *pCGenState;
   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   do {
       CGenState.pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

       CGenerate(pExpression, &CGenState); 

       if (CGenState.ListCol) {
          WriteListColumn(&CGenState);
          }

       Next= Next->Flink;

     } while (Next != &CGenState.ExportsDbg->ArgsListHead);


   GenHeapFree(pExpression);
   return pSrc;
}



/*
 *  WriteListColumn
 */
void WriteListColumn(PCGENSTATE pCGenState)
{
    int Len;
    FILE *fp = pCGenState->CGen->fp;

    OutputColumn = pCGenState->ListCol;
    Len =  OutputColumn - 1;

    if (fputc('\n', fp) != '\n') {
        ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC); 
        return;
        }
    while (Len--) {
        if (fputc(' ', fp) != ' ') {
            ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
            }
        }


}




/*
 *  SkipSubExpression
 *
 */
char *SkipSubExpression(char *pSrc, char **pSubExpression)
{
   char *pOrg = pSrc;
   char *pSave;
   int  Len = 0;
   int ParenLevel;

   if ((*pSrc != '(') && (*pSrc != ',')) {
       return pOrg;
       }

   pSrc++;

   pSave = pSrc;
   ParenLevel = 1;
   Len = 0;

   while (*pSrc) {
       if (*pSrc == '(') {
           ParenLevel++;
           }
       else if (*pSrc == ')') {
           ParenLevel--;
           }

       pSrc++;

       if (!ParenLevel) {
           break;
           }

       Len++;
       }


   if (pSubExpression) {
       if (Len) {
           *pSubExpression = GenHeapAlloc(Len + 1);
           if (!*pSubExpression) {
               ExitErrMsg(TRUE, "GenHeapAlloc(SubExpression) %s\n", pOrg);
               }
           if (Len) {
               memcpy(*pSubExpression, pSave, Len);
               }
           *(*pSubExpression + Len) = '\0';
           }
       else {
           *pSubExpression = NULL;
           }
       }

   return pSrc;
}






/*
 *  GetTemplate
 */
PTEMPLES GetTemplate(PLIST_ENTRY pHeadList, char *TempleName)
{
   PTEMPLES ptpl;
   PLIST_ENTRY Next;

   Next = pHeadList->Flink;
   while (Next != pHeadList) {
      ptpl = CONTAINING_RECORD(Next, TEMPLES, TempleEntry);
      if (!strcmp(ptpl->Name, TempleName)) {
          return ptpl;
          }
      Next= Next->Flink;
      }

   return NULL;
}


void
UseLogMacros(char *LogName)
{
    DWORD Len;
    char FullLogName[MAX_PATH+1];
    char *LogBaseName;

    Len = GetFullPathName(LogName,
                          sizeof(FullLogName) - 1,
                          FullLogName,
                          &LogBaseName
                          );
    if (Len == 0 || Len >= sizeof(FullLogName) - 1) {
        ExitErrMsg(TRUE, "Could not fully-qualify log filename '%s'\n", LogName);
    }

    fpLog = fopen(FullLogName, "w");
    if (!fpLog) {
        ExitErrMsg(TRUE, "fopen(%s) failed\n", FullLogName);
    }
    if (!AddOpenFile(FullLogName, fpLog, NULL)) {
        ExitErrMsg(FALSE, "AddOpenFile failed\n");
    }
}


char *
UpdateLog(
    char *pSrc,
    PCGENSTATE pCGenState
    )
{
    FILE *fpOld;
    BOOL bMore;

    if (fpLog) {
        fpOld = pCGenState->CGen->fp;
        pCGenState->CGen->fp = fpLog;
        bMore = TRUE;
    } else {
        fpOld = NULL;
        bMore = FALSE;
    }

    pSrc = WriteMore(pSrc,pCGenState,bMore);

    if (bMore) {
        pCGenState->CGen->fp = fpOld;
        fprintf(fpLog, "\n");
    }

    return pSrc;
}



/*
 *  ExtractCGenerate
 */
BOOL ExtractCGenerate(char *pNames)
{
   FILE *fp=NULL, *fpCpp=NULL;
   size_t Len;
   DWORD SizeFileName, SizeTempleName;
   DWORD SizeFileNameCpp = 0;
   char *pch;
   char *pchColon, *pchComma;
   PCGENERATE pCGen;
   char *OutputBaseNameCpp;
   char FullOutputNameCpp[MAX_PATH+1];
   char *OutputBaseName;
   char FullOutputName[MAX_PATH+1];
   char OutputName[MAX_PATH+1];
   char OutputNameCpp[MAX_PATH+1];
   char TempleName[MAX_PATH];



   DbgPrintf("CGenerate: %s\n", pNames);

   pchComma = strchr(pNames, ',');
   pchColon = strchr(pNames, ':');

   if (pchComma != NULL) {
       pch = pchComma;
       }
   else {
       pch = pchColon;
       }
   Len = pch - pNames;
   if (!pch || !Len || Len >= sizeof(OutputName) - 1) {
       return FALSE;
       }
   strncpy(OutputName, pNames, Len);
   *(OutputName + Len) = '\0';

   //
   // Extract the CPP filename, and initialize iHandleCPP
   //

   OutputNameCpp[0] = '\0';
   if (pchComma) {
       size_t LenCpp;

       LenCpp = pchColon - ++pchComma;
       if (LenCpp >= sizeof(OutputNameCpp) - 1) {
           return(FALSE);
           }

       if (LenCpp) {
           iHandleCpp = 1;      // use CPP macros
           strncpy(OutputNameCpp, pchComma, LenCpp);
           *(OutputNameCpp + LenCpp) = '\0';
           }
       else {
           iHandleCpp = -1;     // ignore CPP macros, and don't warn
           }

       Len += LenCpp + 1;

       }
      
   pNames += Len;
   if (*pNames != ':') {  // no template name!
       return FALSE;
       }

   Len = GetFullPathName(OutputName,
                         sizeof(FullOutputName) - 1,
                         FullOutputName,
                         &OutputBaseName
                         );
   if (Len >= sizeof(FullOutputName) - 1) {
       return FALSE;
       }

   SizeFileName = Len + 1;

   fp = fopen(FullOutputName, "w");
   if (!fp) {
       ExitErrMsg(TRUE, "fopen(%s) failed\n", FullOutputName);
       }
   if (!AddOpenFile(FullOutputName, fp, NULL)) {
       ExitErrMsg(FALSE, "AddOpenFile failed\n");
       }
   if (fseek(fp, 0, SEEK_SET)) {
       ExitErrMsg(TRUE, "ExtractCGenerate: fseek to 0 failed\n");
   }


   //
   // Open the CPP file name
   //

   //if (iHandleCpp > 0) {
   if (OutputNameCpp[0]) {

       Len = GetFullPathName(OutputNameCpp,
                             sizeof(FullOutputNameCpp) - 1,
                             FullOutputNameCpp,
                             &OutputBaseNameCpp
                             );
       if (!Len || (Len >= sizeof(FullOutputNameCpp) - 1)) {
           return FALSE;
           }

       SizeFileNameCpp = Len + 1;

       fpCpp = fopen(FullOutputNameCpp, "w");
       if (!fpCpp) {
           ExitErrMsg(TRUE, "fopen(%s) failed\n", FullOutputNameCpp);
           }
       if (!AddOpenFile(FullOutputNameCpp, fpCpp, NULL)) {
           ExitErrMsg(FALSE, "AddOpenFile failed\n");
           }

       if (fseek(fpCpp, 0, SEEK_SET)) {
           ExitErrMsg(TRUE, "ExtractCGenerate fseek #2 to 0 failed\n");
       }

       }
   
   pch = GetNextToken(pNames);
   if (pch == pNames || !*pch) {
       return FALSE;
       }

   Len = CopyToken(TempleName, pch, sizeof(TempleName) - 1);
   if (!Len || Len >= sizeof(TempleName) - 1) {
       return FALSE;
       }

   SizeTempleName = Len + 1;

   Len = sizeof(CGENERATE) + 1;
   Len += SizeFileName + SizeTempleName + SizeFileNameCpp;
   pCGen = GenHeapAlloc(Len);
   if (!pCGen) {
       ExitErrMsg(TRUE, "GenHeapAlloc(CGENERATE)");
       }
   memset(pCGen, 0, Len);

   if (bDebug) {
       setvbuf(fp, NULL, _IONBF, 0);
       }

   pCGen->fp = fp;
   pCGen->fpC = fp;
   strcpy(pCGen->TempleName, TempleName);
   pCGen->FileNameC = pCGen->TempleName + SizeTempleName;
   pCGen->FileBaseNameC = pCGen->FileNameC;
   pCGen->FileBaseNameC += OutputBaseName - FullOutputName;
   strcpy(pCGen->FileNameC, FullOutputName);


   //
   // Save the CPP filename, and file handle.
   //

   if (iHandleCpp > 0 && OutputNameCpp[0]) {
       if (bDebug) {
           setvbuf(fpCpp, NULL, _IONBF, 0);
           }
       pCGen->fpCpp = fpCpp;
       pCGen->FileNameCpp = pCGen->FileNameC + SizeFileName;
       pCGen->FileBaseNameCpp = pCGen->FileNameCpp;
       pCGen->FileBaseNameCpp += OutputBaseNameCpp - FullOutputNameCpp;
       strcpy(pCGen->FileNameCpp, FullOutputNameCpp);
       }
       
   InsertTailList(&CGenerateList, &pCGen->CGenerateEntry);

   return TRUE;
}



/*
 *  ExtractTemples
 *
 */
BOOL ExtractTemples(char *FileName)
{
    FILE *fp;
    int  FileSize;
    BOOL bRet = FALSE;
    char *pSrc;
    char *pch;
    size_t  Len;
    int  CGenLen;
    LPSTR pCCode[MAX_CODEBURST];
    char Comment[MAX_PATH];
    char IndLevel[MAX_PATH];
    char TempleType[MAX_PATH];
    char TempleName[MAX_PATH];
    char CodeBurstName[MAX_PATH];
    LPSTR Also[MAX_ALSO];
    int AlsoCount;
    LPSTR NoType[MAX_NOTYPE];
    int NoTypeCount;
    PLIST_ENTRY pCaseList;
    char Line[1024];
    int  CodeBurstIndex;
    TOKENTYPE tkDirection;
    PTEMPLES tpl;
    BOOL fFreeCCode = TRUE;
    int i;


    DbgPrintf("Template: %s\n", FileName);

    fp = fopen(FileName, "r");
    if (!fp) {
        ExitErrMsg(TRUE, "fopen(%s) failed\n", FileName);
    }
    if (fseek(fp, 0, SEEK_END)) {
        ExitErrMsg(TRUE, "fseek to EOF failed\n");
    }
    FileSize = ftell(fp);
    if (fseek(fp, 0, SEEK_SET)) {
        ExitErrMsg(TRUE, "fseek to 0 failed\n");
    }

    // Record the filename/line number information for error messages
    TemplateFileName = FileName;
    TemplateLine = 1;

    if (!fgets(Line, sizeof(Line) - 1, fp)) {
        if (ferror(fp)) {
            ExitErrMsg(TRUE, "Failed to get Types from %s\n", FileName);

        } else if (feof(fp)) {
            ExitErrMsg(TRUE, "Premature EOF %s\n", FileName);
        }
    }

    // reset the TempleType:  no [TempleType] is active
    *TempleType = '\0';

    // reset all variables used within a [TempleType]
    CGenLen = 0;
    *IndLevel = 0;
    *TempleName = '\0';
    strcpy(Comment, "//");
    memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
    tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
    AlsoCount=0;
    NoTypeCount=0;
    pCaseList = NULL;

    // loop over all lines in the template file
    do {
        pSrc = Line;

        // skip whitespace at the start of the line
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }

        // if at end-of-line or encountered ';'  (comment-to-EOL), go to
        // next line.
        if (!*pSrc || *pSrc == ';') {
            goto GetNextLine;
        }

        if (*pSrc == '[') {
            // encountered new [TempleType].  If there was a previous template,
            // add it now.
            if (*TempleName &&
                !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {
                ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
            }

            // free the previous template's memory
            if (fFreeCCode) {
                for (i=0; i < MAX_CODEBURST; ++i) {
                    if (pCCode[i]) {
                        GenHeapFree(pCCode[i]);
                    }
                }
            }
            fFreeCCode = TRUE;

            // reset the vars used for each template
            CGenLen = 0;
            memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
            *IndLevel = 0;
            *TempleName = '\0';
            strcpy(Comment, "//");
            tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
            pCaseList = NULL;

            for (i=0; i<AlsoCount; ++i) {
                GenHeapFree(Also[i]);
            }
            AlsoCount=0;
            for (i=0; i<NoTypeCount; ++i) {
                GenHeapFree(NoType[i]);
            }
            NoTypeCount=0;

            // set up the new TempleType
            pSrc++;
            Len = CopyToken(TempleType, pSrc, sizeof(TempleType) - 1);
            if (Len >= sizeof(TempleType) - 1) {
                goto ETPLExit;
            }
            pch = pSrc + Len;
            if (*pch != ']') {
                *TempleType = '\0';
            }
            goto GetNextLine;
        }

        // if no active [TempleType], ignore the line
        if (!*TempleType) {
            goto GetNextLine;
        }

        // a [TempleType] is active.  Scan for known property names
        if ( ((pch = SkipKeyWord(pSrc, szTEMPLENAME)) != pSrc ||
              (pch = SkipKeyWord(pSrc, szMACRONAME)) != pSrc ||
              (pch = SkipKeyWord(pSrc, szTYPENAME)) != pSrc)
             && *pch == '=') {

            // found:       TemplateName=
            //           or MacroName=
            //           or TypeName=
            // They all mean the same thing.

            // If a template is outstanding, add it now.
            if (*TempleName &&
                !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {
                ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
            }

            // free the previous template's memory
            if (fFreeCCode) {
                for (i=0; i < MAX_CODEBURST; ++i) {
                    if (pCCode[i]) {
                        GenHeapFree(pCCode[i]);
                    }
                }
            }
            fFreeCCode = TRUE;

            // reset the vars used for each template
            CGenLen = 0;
            memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
            *IndLevel = 0;
            *TempleName = '\0';
            tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
            pCaseList = NULL;
            for (i=0; i<AlsoCount; ++i) {
                GenHeapFree(Also[i]);
            }
            AlsoCount=0;
            for (i=0; i<NoTypeCount; ++i) {
                GenHeapFree(NoType[i]);
            }
            NoTypeCount=0;

            // copy in the new TemplateName
            pch = GetNextToken(pch);
            Len = sizeof(TempleName) - 1;
            pSrc = TempleName;
            while (isgraph(*pch) && Len--) {
                *pSrc++ = *pch++;
            }
            if (Len == 0) {
                // name too long
                goto ETPLExit;
            }
            *pSrc = '\0';

        } else if ((pch = SkipKeyWord(pSrc, szCOMMENT)) != pSrc &&
                   *pch == '=') {

            // found:   Comment=
            pch = GetNextToken(pch);
            Len = sizeof(Comment) - 1;
            pSrc = Comment;
            while (isgraph(*pch) && Len--) {
                *pSrc++ = *pch++;
            }

            *pSrc = '\0';

        } else if ( ((pch = SkipKeyWord(pSrc, szINDLEVEL)) != pSrc ||
                     (pch = SkipKeyWord(pSrc, szNUMARGS)) != pSrc)
                    && *pch == '=') {

            // Found:       IndLevel=
            //           or NumArgs=
            // They mean the same thing
            pch = GetNextToken(pch);
            if (IsSeparator(*pch)) {
                goto ETPLExit;
            }
            pSrc = pch;
            Len = CopyToken(IndLevel, pSrc, sizeof(IndLevel) - 1);
            pch += Len;

        } else if ((pch = SkipKeyWord(pSrc, szDIRECTION)) != pSrc &&
                *pch == '=') {
            pch++;
            // Found:   Direction=
            if (strncmp(pch, "IN OUT", 6) == 0) {
                tkDirection = TK_INOUT;
                pch += 6;
            } else if (strncmp(pch, "IN", 2) == 0) {
                tkDirection = TK_IN;
                pch += 2;
            } else if (strncmp(pch, "OUT", 3) == 0) {
                tkDirection = TK_OUT;
                pch += 3;
            } else if (strncmp(pch, "none", 4) == 0) {
                // this allows a type template to explicitly catch
                // all pointer types which have no IN/OUT modifiers.
                tkDirection = TK_NONE;
                pch+=4;
            } else {
                goto ETPLExit;
            }

        } else if ((pch = SkipKeyWord(pSrc, szUSE)) != pSrc &&
                *pch == '=') {
            PLIST_ENTRY pHeadList;
            char buffer[MAX_PATH];

            // Found: Use=
            pch++;
            pHeadList = ListFromTempleType(TempleType);
            if (!pHeadList) {
                ExitErrMsg(FALSE, "%s(%d) Use= can only be used after a [Temple]\n", TemplateFileName, TemplateLine);
            }
            Len = CopyToken(buffer, pch, sizeof(buffer));
            tpl = GetTemplate(pHeadList, buffer);
            if (!tpl) {
                ExitErrMsg(FALSE, "%s(%d) Use=%s: Template not found\n", TemplateFileName, TemplateLine, pch);
            }

            // copy the template back to our locals
            strcpy(Comment, tpl->Comment);
            sprintf(IndLevel, "%d", tpl->IndLevel);
            tkDirection = tpl->tkDirection;
            memcpy(pCCode, tpl->CodeBurst, sizeof(LPSTR)*MAX_CODEBURST);
            fFreeCCode = FALSE; // Don't GenHeapFree() the pCCode array
                                // after adding this temple.
            pch += Len;

        } else if ((pch = SkipKeyWord(pSrc, szNOTYPE)) != pSrc &&
                *pch == '=') {
            char *t;

            if (AlsoCount) {
                ExitErrMsg(FALSE, "%s(%d) Cannot have both NoType= and Also= in the same template\n", TemplateFileName, TemplateLine);
            }

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the NoType= name
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            // copy the name
            t = GenHeapAlloc(Len + 1);
            memcpy(t, pch, Len);
            t[Len] = '\0';

            if (NoTypeCount == MAX_NOTYPE) {
                ExitErrMsg(FALSE, "%s(%d) Max. of %d NoType= clauses allowed.  Also=%s\n", TemplateFileName, TemplateLine, MAX_ALSO, t);
            }

            NoType[NoTypeCount++] = t;

            pch += Len;
        
        } else if ((pch = SkipKeyWord(pSrc, szCASE)) != pSrc &&
                *pch == '=') {
            char *t;
            PMACROARGSLIST pMArgsList = NULL;
            PMLLISTENTRY pMLListEntry = NULL;

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the Case=
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            if (pCaseList == NULL) {
               pCaseList = CheckHeapAlloc(sizeof(LIST_ENTRY));
               InitializeListHead(pCaseList);
            }

            ParseMacroArgs(pch, Len, &pMArgsList);
            pMLListEntry = CheckHeapAlloc(sizeof(MLLISTENTRY));
            if (NULL == pMLListEntry) {
               ExitErrMsg(FALSE, "Out of memory\n");
            }
            pMLListEntry->pMArgs = pMArgsList;
            InsertTailList(pCaseList, &(pMLListEntry->ListEntry));
            pch += Len;


        } else if ((pch = SkipKeyWord(pSrc, szALSO)) != pSrc &&
                *pch == '=') {
            char *t;

            if (NoTypeCount) {
                ExitErrMsg(FALSE, "%s(%d) Cannot have both Also= and NoType= in the same template\n", TemplateFileName, TemplateLine);
            }

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the Also= name
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            // copy the name
            t = GenHeapAlloc(Len + 1);
            memcpy(t, pch, Len);
            t[Len] = '\0';

            if (AlsoCount == MAX_ALSO) {
                ExitErrMsg(FALSE, "%s(%d) Max. of %d Also= clauses allowed.  Also=%s\n", TemplateFileName, TemplateLine, MAX_ALSO, t);
            }

            Also[AlsoCount++] = t;

            pch += Len;

        } else {

GetNextCodeBurst:
            // grab the name, and if the next thing isn't '=', error out.
            pch = GetNextToken(pSrc);
            if (*pch != '=') {
                goto ETPLExit;
            }
            Len = CopyToken(CodeBurstName, pSrc, pch-pSrc);
            pch += Len;

            // convert the name into an index
            CodeBurstIndex = GetCodeBurstIndex(CodeBurstName);
            if (pCCode[CodeBurstIndex]) {
                // Two codebursts with the same name in this template
                goto ETPLExit;
            }

            pCCode[CodeBurstIndex] = GenHeapAlloc(FileSize*2 + 1);
            CGenLen = 0;

            pSrc = pCCode[CodeBurstIndex];
            while (fgets(pSrc, FileSize*2 - CGenLen, fp)) {
                char buffer[MAX_PATH];
                int len;

                TemplateLine++;

                len = CopyToken(buffer, pSrc, sizeof(buffer));
                pch = pSrc;
                if (len && pSrc[len] == '=') {
                    // The line starts with some keyword and is followed by
                    // an '=' sign.
                    if (strcmp(buffer, szCGENEND) == 0 ||
                        strcmp(buffer, "CGenEnd") == 0) {

                        // The string is 'End=' or 'CGenEnd='.  The CodeBurst
                        // is done.
                        *pSrc = '\0';
                        CGenLen++;
                        pch += len+1;
                        break;
                    }

                    // See if it is the start of a new CodeBurst:
                    CodeBurstIndex = GetExistingCodeBurstIndex(buffer);
                    if (CodeBurstIndex != -1) {
                        strcpy(Line, pSrc);
                        *pSrc = '\0';
                        CGenLen++;
                        pSrc = Line;
                        goto GetNextCodeBurst;
                    }
                }

                Len = strlen(pSrc);
                CGenLen += Len;
                pSrc += Len;

            }

            if (!CGenLen) {
                GenHeapFree(pCCode[CodeBurstIndex]);
                pCCode[CodeBurstIndex] = NULL;
            }
        }

        while (*pch && *pch != ';' && IsSeparator(*pch)) {
            pch++;
        }
        if (*pch) {
            if (*pch == ';') {
                // comment to end-of-line
                goto GetNextLine;
            }
            goto ETPLExit;
        }

GetNextLine:
        TemplateLine++;
    } while (fgets(Line, sizeof(Line) - 1, fp));

    // If there is an outstanding template when EOF is hit, add it now.
    if (*TempleName &&
        !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {

        ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
    }


    if (!feof(fp) && ferror(fp)) {
        ExitErrMsg(TRUE, "%s(%d) Read error: %s\n", TemplateFileName, TemplateLine, TempleName);
    }

    bRet = TRUE;

ETPLExit:
    if (!bRet) {
        ErrMsg("%s(%d) ETPL: Invalid Line <%s>\n%s\n", TemplateFileName, TemplateLine, pSrc, Line);
    }

    if (fFreeCCode) {
        for (i=0; i < MAX_CODEBURST; ++i) {
            if (pCCode[i]) {
                GenHeapFree(pCCode[i]);
            }
        }
    }
    for (i=0; i<AlsoCount; ++i) {
        GenHeapFree(Also[i]);
    }
    for (i=0; i<NoTypeCount; ++i) {
        GenHeapFree(NoType[i]);
    }

    fclose(fp);

    TemplateFileName = NULL;

    return bRet;
}



PEXPORTSDEBUG
FindInExportsList(char *Name)
{
    PLIST_ENTRY pNext;
    PEXPORTSDEBUG pexportsdbg;

    pNext = ExportsList.Flink;
    while (pNext != &ExportsList) {
        pexportsdbg = CONTAINING_RECORD(pNext, EXPORTSDEBUG, ExportsDbgEntry);
        if (!strcmp(Name, pexportsdbg->ExportName)) {
            return pexportsdbg;
        }
        pNext = pNext->Flink;
    }
    return NULL;
}




PLIST_ENTRY
ListFromTempleType(
    char *TempleType
    )
{
    if (!TempleType || !*TempleType) {
        return NULL;
    }

    if (!strcmp(TempleType, szIFUNC)) {
        return &IFuncTempleList;
    } else if (!strcmp(TempleType, szEFUNC)) {
        return &EFuncTempleList;
    } else if (!strcmp(TempleType, szTYPES)) {
        return &TypeTempleList;
    } else if (!strcmp(TempleType, szCODE)) {
        return &CodeTempleList;
    } else if (!strcmp(TempleType, szEFAST)) {
        return &EFastTempleList;
    } else if (!strcmp(TempleType, szMACROS)) {
        return &MacroList;
    } else if (!strcmp(TempleType, szFAILTYPES)) {
        return &FailTempleList;
    }
    return NULL;
}

/*
 *  AddTemple
 *
 *  worker function for ExtractTemple, to verify and store template.
 */

#pragma optimize("", off)
BOOL
AddTemple(
    char *TempleType,
    char *TempleName,
    char *Comment,
    char *IndLevel,
    char *pCCode[MAX_CODEBURST],
    TOKENTYPE tkDirection,
    char *Also[MAX_ALSO],
    int AlsoCount,
    char *NoType[MAX_NOTYPE],
    int NoTypeCount,
    PLIST_ENTRY pCaseList
    )
{
    PLIST_ENTRY pHeadList = NULL;
    PTEMPLES ptpl;
    char *pch;
    int SizeCGen, SizeTempleName, SizeComment, SizeNoType;
    int Len;
    int i;
    int AlsoIndex;

    if (!*TempleName) {
        return FALSE;
    }

    pHeadList = ListFromTempleType(TempleType);
    if (!pHeadList) {
        return FALSE;
    }

    SizeCGen = 0;
    for (i=0; i<MAX_CODEBURST; ++i) {
         SizeCGen++;
         if (pCCode[i]) {
            SizeCGen += strlen(pCCode[i]);
         }
    }

    AlsoIndex=0;

    for (;;) {
        if (pHeadList != &TypeTempleList && GetTemplate(pHeadList, TempleName)) {
            ExitErrMsg(FALSE, "Multiple templates are not allowed.  TemplateName=%s, Type=%s\n", TempleName, TempleType);
        }

        SizeTempleName = strlen(TempleName) + 1;
        SizeComment = strlen(Comment) + 1;
        SizeNoType = 0;
        for (i=0; i<NoTypeCount; ++i) {
            SizeNoType += strlen(NoType[i])+1;
        }


        Len = SizeCGen + SizeTempleName + SizeComment + SizeNoType;
        Len +=  sizeof(TEMPLES);

        ptpl = GenHeapAlloc(Len);
        if (!ptpl) {
            ExitErrMsg(TRUE, "GenHeapAlloc(TEMPLE)");
            }

        memset(ptpl, 0, Len);
        ptpl->IndLevel = strtoul(IndLevel, &pch, 10);
        ptpl->tkDirection = tkDirection;

        Len = 0;
        ptpl->Name = ptpl->Buffer;
        strcpy(ptpl->Name, TempleName);
        Len += SizeTempleName;

        ptpl->Comment = ptpl->Buffer + Len;
        strcpy(ptpl->Comment, Comment);
        Len += SizeComment;

        for (i=0; i<MAX_CODEBURST; ++i) {
            if (pCCode[i]) {
                //
                // Copy the code for this codeburst name
                //
                ptpl->CodeBurst[i] = ptpl->Buffer + Len;
                Len++;
                strcpy(ptpl->CodeBurst[i], pCCode[i]);
                Len += strlen(pCCode[i]);
            }
        }

        for (i=0; i<NoTypeCount; ++i) {
            ptpl->NoTypes[i] = ptpl->Buffer + Len;
            Len++;
            strcpy(ptpl->NoTypes[i], NoType[i]);
            Len += strlen(NoType[i]);
        }

        ptpl->pCaseList = pCaseList;

        InsertTailList(pHeadList, &ptpl->TempleEntry);

        if (bDebug && Len >= SizeCGen+SizeTempleName+SizeComment+SizeNoType) {
            ExitErrMsg(FALSE, "Buffer overrun in AddTemple!  Heap is trashed! ptpl=%x\n", ptpl);
        }

        if (bDebug) {
            DumpTemplate(ptpl, stdout);
            }

        if (AlsoIndex == AlsoCount) {
            break;
        }
        // there are Also= lines, add those template, too
        strcpy(TempleName, Also[AlsoIndex]);
        AlsoIndex++;
    }

   return TRUE;
}
#pragma optimize("", on)


/*
 *
 */
void DumpTemplate(PTEMPLES ptpl, FILE *fp)
{
     int i;

     fprintf(fp,"Temple: %d Name<%s>\n",
                 ptpl->IndLevel,
                 ptpl->Name
                 );

     for (i=0; i<MAX_CODEBURST; ++i) {
         if (CodeBursts[i].Name) {
             fprintf(fp,"%s(%d) Temple: %s<%s>\n", TemplateFileName, TemplateLine, CodeBursts[i].Name, ptpl->CodeBurst[i]);
         }
     }
}


ULONG
EndianSwitch(
    PULONG pul
    )
{
    ULONG NewValue;
    PBYTE pbValue = (PBYTE)pul;
    PBYTE pbNewValue = (PBYTE) &NewValue;

    *pbNewValue++ = *(pbValue + 3);
    *pbNewValue++ = *(pbValue + 2);
    *pbNewValue++ = *(pbValue + 1);
    *pbNewValue   = *pbValue;

    return NewValue;
}


/*  MapViewDll
 *
 *  Creates a Mapped view of a Dll and intializes
 *  Dll global variables for easy access to the Export Directory
 *
 *  DllMappedBase
 *  DllRvaOffset
 *  DllExportDir
 *  DllExportDirSize
 *  DllFunctions
 *  DllNameOrdinals
 *  DllNameTable
 *
 *
 */
BOOL MapViewDll(char *DllName)
{
    ULONG_PTR RvaOffset;
    HANDLE hFile;
    HANDLE hMapFile;
    PVOID  MappedBase;
    PIMAGE_EXPORT_DIRECTORY ExportDir;
    ULONG ExportDirSize;
    ULONG Forward;



    //
    // open and map the file to get the exports info
    //

    hFile = CreateFile(DllName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE) {
        ErrMsg("MapViewDll CreateFile(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
    if (!hMapFile) {
        ErrMsg("MapViewDll CreateFileMapping(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    MappedBase = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (!MappedBase) {
        ErrMsg("MapViewDll MapViewOfFile(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    ExportDir = ImageDirectoryEntryToData( MappedBase,
                                           TRUE,
                                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                                           &ExportDirSize
                                           );
    if (!ExportDir) {
        ErrMsg("MapViewDll ImageDirectoryEntryToData=NULL\n");
        return FALSE;
        }

    //
    // Initialize the global variables.
    //

    RvaOffset = (ULONG_PTR)ExportDir - (ULONG_PTR)MappedBase;

    ExportDir = ImageDirectoryEntryToData( MappedBase,
                                           FALSE,
                                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                                           &ExportDirSize
                                           );
    if (!ExportDir) {
        ErrMsg("MapViewDll ImageDirectoryEntryToData=NULL on the second call\n");
        return FALSE;
    }


    DllExportDirSize = ExportDirSize;
    DllMappedBase = MappedBase;
    DllRvaOffset = RvaOffset;
    DllExportDir = ExportDir;

    DllFunctions = (PULONG)((ULONG_PTR)ExportDir +
                            (ULONG_PTR)ExportDir->AddressOfFunctions - RvaOffset
                            );


    DllNameTable  = (PULONG)((ULONG_PTR)ExportDir +
                          (ULONG_PTR)ExportDir->AddressOfNames - RvaOffset
                          );

    DllNameOrdinals = (PUSHORT)((ULONG_PTR)ExportDir +
                             (ULONG_PTR)ExportDir->AddressOfNameOrdinals - RvaOffset
                             );

    fprintf(stdout,
            "Name %s Base %x Ver %x.%x NumberOfFunctions %x NumberOfNames %x\n",
            (PCHAR)((ULONG_PTR)ExportDir + (ULONG_PTR)ExportDir->Name - RvaOffset),
            ExportDir->Base,
            (ULONG)ExportDir->MajorVersion,
            (ULONG)ExportDir->MinorVersion,
            ExportDir->NumberOfFunctions,
            ExportDir->NumberOfNames
            );


    return TRUE;

}


ULONG
DllOrdinalByName(
    char *ExportName
    )
{
    PULONG pNames;
    ULONG NumNames;
    PUSHORT pNameOrdinals;
    char *Name;

    pNames  = DllNameTable;
    pNameOrdinals = DllNameOrdinals;

    NumNames = DllExportDir->NumberOfNames;
    while (NumNames--) {
        Name = (char *)((ULONG_PTR)DllExportDir + *pNames - DllRvaOffset);

        if (!strcmp(Name, ExportName)) {
            return *pNameOrdinals + DllExportDir->Base;
            }

        pNames++;
        pNameOrdinals++;
        }


   return 0;
}





/*  MapViewImplib
 *
 *  Creates a Mapped view of an import library and intializes
 *  ImpLib global variables for access to symbols in the first
 *  special linker member.
 *
 *  ImplibMappedBase
 *  ImplibNumSymbols
 *  ImplibSymbolMembers
 *  ImplibSymbolNames
 *
 */

BOOL MapViewImplib(char *LibName)
{
    HANDLE hFile;
    HANDLE hMapFile;
    PBYTE  MappedBase;
    PBYTE  VirtualOffset;
    ULONG  MemberSize;
    PIMAGE_ARCHIVE_MEMBER_HEADER ArchiveMemberHeader;


    //
    // open and map the file.
    //

    hFile = CreateFile(LibName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE) {
        ErrMsg("MapViewImplib CreateFile(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }

    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
    if (!hMapFile) {
        ErrMsg("MapViewImplib CreateFileMapping(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }

    MappedBase = (PBYTE)MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (!MappedBase) {
        ErrMsg("MapViewImplib MapViewOfFile(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }


    //
    // Verify the file is an archive
    //

    if (memcmp(MappedBase, IMAGE_ARCHIVE_START, IMAGE_ARCHIVE_START_SIZE)) {
        ErrMsg("MapViewImplib IMAGE_ARCHIVE_START_SIZE invalid(%s)\n", LibName);
        return FALSE;
        }

    VirtualOffset = MappedBase + IMAGE_ARCHIVE_START_SIZE;

    ArchiveMemberHeader = (PIMAGE_ARCHIVE_MEMBER_HEADER) VirtualOffset;
    if (sscanf((char *) ArchiveMemberHeader->Size, "%ld", &MemberSize) != 1) {
        ErrMsg("MapViewImplib ArchiveMemberHeader->Size '%s' corrupt\n", (char *) ArchiveMemberHeader->Size);
        return FALSE;
    }


    //
    // Verify first special linker member exists (name == "\\")
    //

    if (memcmp(ArchiveMemberHeader->Name, IMAGE_ARCHIVE_LINKER_MEMBER, sizeof(ArchiveMemberHeader->Name))) {
        ErrMsg("MapViewImplib first special linker member missing (%s)\n", LibName);
        return FALSE;
        }

    //
    // First Linker Member format (Big endian!)
    //  NumberOfSymbols, 4 bytes
    //  Offsets,         4 bytes * NumSymbols
    //  StringTable      NumSymbols == NumStrings
    //

    VirtualOffset += sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);
    ImplibNumSymbols = EndianSwitch((PULONG)VirtualOffset);


    VirtualOffset += 4;
    ImplibSymbolMembers = (PULONG)VirtualOffset;

    VirtualOffset +=  ImplibNumSymbols * sizeof(ULONG);
    ImplibSymbolNames = (PCHAR)VirtualOffset;

    ImplibMappedBase = MappedBase;

    fprintf(stdout, "Implib: %s Base %p\n", LibName, ImplibMappedBase);


    return TRUE;

}


BOOL
ExtractMember(
    ULONG MemberOffset,
    PULONG Ordinal,
    BOOLEAN *Data
    )
{
    PIMAGE_FILE_HEADER ImageFileHeader;
    PBYTE VirtualOffset;
    BOOL Idata5Found, TextFound;

    VirtualOffset = (PBYTE)ImplibMappedBase + MemberOffset;

    VirtualOffset += sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);
    ImageFileHeader = (PIMAGE_FILE_HEADER) VirtualOffset;

    *Ordinal = 0;
    Idata5Found = FALSE;
    TextFound = FALSE;

    if (ImageFileHeader->Machine == 0 &&
        ImageFileHeader->NumberOfSections == 0xffff) {
        //
        // VC6 format import lib found.
        //
        PVC6_IMAGE_IMPORT_HEADER pHdr;

        pHdr = (PVC6_IMAGE_IMPORT_HEADER)ImageFileHeader;
        if (pHdr->NameType == IMPORT_ORDINAL) {
            //
            // pHdr->wOrdinal specifies the ordinal for this import.
            //
            *Ordinal = 0x80000000 | (ULONG)pHdr->Ordinal;
        }
        if (pHdr->Type == IMPORT_DATA) {
            //
            // This is a data import
            //
            *Data = TRUE;
        }
        Idata5Found = TRUE;
    } else {
        //
        // Pre-VC6 import lib.
        //
        ULONG NumSections;
        ULONG UNALIGNED *RawDataPointer;
        IMAGE_SECTION_HEADER UNALIGNED *ImageSectionHeader;

        NumSections = ImageFileHeader->NumberOfSections;

        //
        // Carefull, librarian doesn't align the Image section header according
        // to normal rules for images.
        //

        VirtualOffset += sizeof(IMAGE_FILE_HEADER) + ImageFileHeader->SizeOfOptionalHeader;
        ImageSectionHeader = (IMAGE_SECTION_HEADER UNALIGNED *)VirtualOffset;

        while (NumSections--) {

            //
            // Implib provides .idata5, and .idata4 (duplicate) which
            // contains the ordinal number with the hi bit set if it
            // was specified in the module definition file. Otherwise
            // the ordinal number is not specified in the implib.
            //

            if (!Idata5Found &&
                !strncmp(ImageSectionHeader->Name, szIDATA5, sizeof(szIDATA5)-1)) {

                //
                // Carefull, librarian doesn't align the begining of raw data
                // according to normal rules for images.
                //

                RawDataPointer = (ULONG UNALIGNED *)((PBYTE)ImageFileHeader + ImageSectionHeader->PointerToRawData);
                if (*RawDataPointer & 0x80000000) {
                    *Ordinal = *RawDataPointer;
                }
                Idata5Found = TRUE;

            } else if (!TextFound &&
                 !strncmp(ImageSectionHeader->Name, szTEXT, sizeof(szTEXT)-1)) {
                TextFound = TRUE;
            }

            ImageSectionHeader++;
        }

        *Data = !TextFound;  // if no text section, must be data export
    }
    return Idata5Found;
}






BOOL
InitExportDebug(
    PEXPORTSDEBUG ExportDebug,
    char *SymbolName,
    ULONG SymbolMember
    )
{
    ULONG_PTR Forward;
    ULONG OrdinalIndex;
    char *pch = SymbolName; // we assume __implib_ prefix not present

    //
    // C fn begins with "_"
    // C++ fn begins with "?"
    // Data export begins with  "??_C" in real symbols,
    // but in implib looks a C function
    //

    if (*pch == '?') {
        ExportDebug->CplusDecoration = pch;
        DbgPrintf("C++ export %s\n", SymbolName);
        }
    else {
        ExportDebug->CplusDecoration = NULL;
        }

    //
    //  Copy out the ExportName.
    //

    if (*pch == '_' || *pch == '?') {
        pch++;                          // skip lead char (underscor, qmark)
    }
    strcpy(ExportDebug->ExportName, pch);
    pch = strchr(ExportDebug->ExportName, '@');
    if (SymbolName[0] == '?' && SymbolName[1] == '?') {
        //
        // Found a "real" C++ name: a mangled version of
        // "classname::membername".  Use the fully-mangled function name,
        // instead of the name with the leading '?' stripped, and don't
        // truncate after the '@'.
        //
        strcpy(ExportDebug->ExportName, SymbolName);
        pch = NULL;
    }
    if (pch && ExportDebug->CplusDecoration && pch[1] != '@') {
        //
        // This export is '?membername@classname@@...'.  Don't truncate!
        //
        strcpy(ExportDebug->ExportName, SymbolName);
        pch = NULL;
    }

    if (pch && !bNoFuzzyLogic) {   // truncate the symbol from ExportName
        *pch = '\0';
        }

    //
    // Get the decoration, for synthetic args
    // cdecl has no decoration
    // stdcall has total arg size
    //

    if (pch && !ExportDebug->CplusDecoration) {
        ExportDebug->ArgsSize = strtol(pch + 1, NULL, 10);
        }
    else {
        ExportDebug->ArgsSize = -1;
        }


    //
    // Fetch the ordinal from the implib. In an Implib the ordinal
    // only appears if an ordinal is specifed in the def file.
    //

    if (!ExtractMember(SymbolMember, &ExportDebug->Ordinal, &ExportDebug->Data)) {
        ErrMsg("InitExportDebug: %s Member not found\n", SymbolName);
        return FALSE;
        }

    if (ExportDebug->Data) {
        DbgPrintf("DATA export %s\n", SymbolName);
        }

    //
    // If we don't yet have an ordinal, search the ExportNameTable
    // for the Ordinal number. Note that Ordinals which *must* appear
    // in generated def files have the hi-bit set!
    //

    if (!ExportDebug->Ordinal) {
        ExportDebug->Ordinal = DllOrdinalByName(ExportDebug->ExportName);
        if (!ExportDebug->Ordinal) {
            ErrMsg("InitExportDebug: %s Ordinal not found\n", SymbolName);
            return FALSE;
            }
        }


    //
    // Look up function using ordinal as index to function table.
    //

    OrdinalIndex = IMPORDINAL(ExportDebug->Ordinal) - DllExportDir->Base;
    ExportDebug->Function = *(DllFunctions + OrdinalIndex);


    //
    // Check for references forwarded externally, we only need
    // external forwards which are really internal forwards.
    //
    // e.g rpcrt4.dll has following def file entries:
    //
    // I_RpcBindingInqDynamicEndpoint=RPCRT4.I_RpcBindingInqDynamicEndpointW
    // I_RpcBindingInqDynamicEndpointW
    //
    // Our thunk dll will use the following:
    //
    // I_RpcBindingInqDynamicEndpoint=I_RpcBindingInqDynamicEndpointW
    // I_RpcBindingInqDynamicEndpointW
    //
    // It is important to strip the "rpcrt4." as this adds an extra
    // loader reference to rpcrt4.dll.
    //
    //
    ExportDebug->ExtForward = NULL;

    Forward = (ULONG_PTR)DllExportDir + ExportDebug->Function - DllRvaOffset;
    if (Forward > (ULONG_PTR)DllExportDir &&
        Forward < (ULONG_PTR)DllExportDir + DllExportDirSize)
       {
        char *pSrc;

        pSrc = (char *) Forward;
        pch = DllBaseName;

        while (*pSrc && *pSrc != '.' && toupper(*pSrc) == toupper(*pch)) {
            pSrc++;
            pch++;
            }

        if (*pSrc == *pch) {
            ExportDebug->ExtForward = pSrc + 1;
            }
        }



    DbgPrintf("%4.1d %8.1x(%4.1d) %8.1x %s(%s)\n",
              ExportDebug->ArgsSize,
              ExportDebug->Ordinal,
              IMPORDINAL(ExportDebug->Ordinal),
              ExportDebug->Function,
              ExportDebug->ExportName,
              ExportDebug->ExtForward ? ExportDebug->ExtForward : ""
              );

   return TRUE;
}




/*
 *  SetInternalForwards
 *
 *
 *
 */
void
SetInternalForwards(void)
{
   PLIST_ENTRY NextExport;
   PEXPORTSDEBUG ExportDebug;


   //
   // check each export in the list for multiple exports to same function.
   // For each set of internal forwards identify which export defines the api,
   // and save this in the IntForward field.
   //

   NextExport= ExportsList.Flink;
   while (NextExport != &ExportsList) {
        ExportDebug = CONTAINING_RECORD(NextExport,
                                       EXPORTSDEBUG,
                                       ExportsDbgEntry
                                       );

        if (ExportDebug->Function &&
           !ExportDebug->ExtForward &&
           !ExportDebug->IntForward)
         {
            PLIST_ENTRY Next;
            PEXPORTSDEBUG pexdbg;
            PEXPORTSDEBUG KnownApi =NULL;
            int ArgSize = ExportDebug->ArgsSize;

            //
            // Walk the rest of the list to find first duplicate function
            //

            Next = NextExport->Flink;
            while (Next != &ExportsList) {
                pexdbg = CONTAINING_RECORD(Next,
                                           EXPORTSDEBUG,
                                           ExportsDbgEntry
                                           );

                if (pexdbg->Function == ExportDebug->Function) {
                    if (pexdbg->ArgsSize >= 0) {
                        ArgSize = pexdbg->ArgsSize;
                        }
                    break;
                    }

                 Next = Next->Flink;

                }


            if (Next != &ExportsList) {

                //
                // We found one dup function. Temporarily link together this set
                // of dup functions using the IntForward field, and determine
                // the first KnownApi.
                //

                if (GetNameFromTypesList(FuncsList, ExportDebug->ExportName)) {
                    KnownApi = ExportDebug;
                    }


                do {

                    pexdbg = CONTAINING_RECORD(Next,
                                               EXPORTSDEBUG,
                                               ExportsDbgEntry
                                               );


                    if (pexdbg->Function == ExportDebug->Function) {
                        pexdbg->IntForward = ExportDebug->IntForward;
                        ExportDebug->IntForward = pexdbg;
                        if (pexdbg->ArgsSize >= 0) {
                            ArgSize = pexdbg->ArgsSize;
                            }

                        if (!KnownApi &&
                            GetNameFromTypesList(FuncsList, pexdbg->ExportName))
                          {
                            KnownApi = pexdbg;
                            }
                        }

                    Next = Next->Flink;

                } while (Next != &ExportsList);



                //
                // If we found multiple entries, walk the temp links, and insert
                // the KnownApi, which is used to define the api. If we didn't
                // find a known api, use ExportDebug, and hope for the best
                // (since its not known).
                //

                if (!KnownApi) {
                    KnownApi = ExportDebug;
                    }

                pexdbg = ExportDebug;

                while (pexdbg) {
                    PEXPORTSDEBUG NextForward;

                    NextForward = pexdbg->IntForward;
                    pexdbg->IntForward = KnownApi;
                    pexdbg->ArgsSize =  ArgSize;

                    DbgPrintf("IntForward: %s to %s\n",
                              pexdbg->ExportName,
                              KnownApi->ExportName
                              );

                    pexdbg = NextForward;

                    }
                }
            }

         NextExport = NextExport->Flink;

         }

}




/*
 *  ExtractExports -
 *
 *  reads the exports debug info from a dll,
 *  and builds the exports list.
 *
 */
BOOL ExtractExports(void)
{
    char *pch, pDst;

    ULONG  NumNames;
    PULONG pNames;
    PUSHORT pNameOrdinals;
    PULONG ImpSymbolMember;
    PCHAR  ImpSymbolName;
    EXPORTSDEBUG ExportDebug;
    PEXPORTSDEBUG pexdbgForward;
    char ExportName[MAX_PATH+1];

    //
    // For each "__imp_" in the implib, gather name, symbol and ordinal
    // and determine its forward status. This will pick up all exports
    // except those which are marked "PRIVATE".
    //

    NumNames   = ImplibNumSymbols;
    ImpSymbolMember = ImplibSymbolMembers;
    ImpSymbolName   = ImplibSymbolNames;

    while (NumNames--) {

         if (!strncmp(szIMPPREFIX, ImpSymbolName, sizeof(szIMPPREFIX) - 1)) {
             memset(&ExportDebug, 0, sizeof(ExportDebug));
             ExportDebug.ApiPlatform = API_ALL;
             ExportDebug.ExportName = ExportName;
             if (!InitExportDebug(&ExportDebug,
                                  ImpSymbolName + sizeof(szIMPPREFIX) - 1,
                                  EndianSwitch(ImpSymbolMember)
                                  ))
                {
                 return FALSE;
                 }

             if (!AddToExportsList(&ExportDebug)) {
                 return FALSE;
                 }

             }

         ImpSymbolMember++;
         ImpSymbolName += strlen(ImpSymbolName) + 1;
         }


    //
    // Search the Export name table for exports which haven't been added yet.
    // These are "PRIVATE" exports with names. We will still be missing
    // exports which are "PRIVATE NONAME", and we won't have symbolic info
    // for the private named exports.
    //

    NumNames = DllExportDir->NumberOfNames;
    pNames   = DllNameTable;
    pNameOrdinals = DllNameOrdinals;

    while (NumNames--) {

       memset(&ExportDebug, 0, sizeof(ExportDebug));

       ExportDebug.Ordinal = *pNameOrdinals + DllExportDir->Base;
       ExportDebug.Ordinal |= 0x80000000;
       ExportDebug.Function = *(DllFunctions + *pNameOrdinals);
       ExportDebug.ExportName = (char *)((ULONG_PTR)DllExportDir + *pNames - DllRvaOffset);
       ExportDebug.ApiPlatform = API_ALL;

       if (!FindInExportsList(ExportDebug.ExportName)) {
           ULONG_PTR Forward;
           char *pch;

           //
           // Check for references forwarded externally, we only need
           // external forwards which are really internal forwards.
           //

           ExportDebug.ExtForward = NULL;

           Forward = (ULONG_PTR)DllExportDir + ExportDebug.Function - DllRvaOffset;
           if (Forward > (ULONG_PTR)DllExportDir &&
               Forward < (ULONG_PTR)DllExportDir + DllExportDirSize)
              {
               char *pSrc;

               pSrc = (char *)Forward;
               pch = DllBaseName;

               while (*pSrc && *pSrc != '.' && *pSrc == *pch) {
                   pSrc++;
                   pch++;
                   }

               if (*pSrc == '.' && *pSrc == *pch) {
                   ExportDebug.ExtForward = pSrc + 1;
                   }
               }


           //
           // Check for decorations embedded in the exportname
           //

           pch = strchr(ExportDebug.ExportName, '@');
           if (pch++ && *pch != '@') {
               ExportDebug.ArgsSize = strtol(pch, NULL, 10);
               }
           else {
               ExportDebug.ArgsSize = -1;
               }

           ExportDebug.PrivateNamed = TRUE;

           DbgPrintf("Private Named Export: %4.1d %8.1x(%4.1d) %8.1x %s(%s)\n",
                     ExportDebug.ArgsSize,
                     ExportDebug.Ordinal,
                     IMPORDINAL(ExportDebug.Ordinal),
                     ExportDebug.Function,
                     ExportDebug.ExportName,
                     ExportDebug.ExtForward ? ExportDebug.ExtForward : ""
                     );

           if (!AddToExportsList(&ExportDebug)) {
               return FALSE;
               }
           }


       // advance to next name\ordinal
       pNames++;
       pNameOrdinals++;

       }





    return TRUE;
}

/*
    ExtractServicesTab-
    
    Used as a replacement to ExtractXpt.  Extracts file list from a services.tab
    file as used in the ntos project.
    
*/

void ExtractServicesTab(char *pch) {
   FILE *fp;
   char pTemp;

   EXPORTSDEBUG ExportDebug;
   char Line[MAX_PATH];
   char ExportName[MAX_PATH];
   char *ApiName;
   char TempBuffer[MAX_PATH];
   char *Prepend;   
   char *FileName;
   size_t len, PrependLen;

   //extract filename and optional prepend name
   FileName = pch;
   while(*pch != ':' && *pch != '\0') 
      pch++;

   pTemp = *pch;
   *pch = '\0';
   
   if (pTemp == ':') {
      pch++;
      Prepend = pch;
      while(*pch != '\0') {
         pch++;
      }
      PrependLen = pch-Prepend;
   }
   else {
      Prepend = pch;
      PrependLen = 0;
   }
   if (PrependLen > MAX_PATH - 1) {
      ExitErrMsg(FALSE, "ExSt: Text to prepend to functions names is too long\n");
   }
   memcpy(ExportName, Prepend, PrependLen);

   DbgPrintf("ExST: %s,%s\n", FileName, Prepend);

   fp = fopen(FileName, "r");
   if (!fp) {
       ExitErrMsg(TRUE, "ExST: fopen(%s) failed\n", FileName);
   }

   if (fseek(fp, 0, SEEK_SET)) {
       ExitErrMsg(TRUE, "ExST: fseek to 0 failed\n");
   }
   if (!fgets(Line, sizeof(Line) - 1, fp)) {
       if (ferror(fp)) {
           ExitErrMsg(FALSE, "ExST: Failed to get Defs from %s\n", FileName);
       } else if (feof(fp)) {
           ExitErrMsg(FALSE, "ExST: Premature EOF %s\n", FileName);
       }
   }

   do {
       // skip leading spaces
       pch = Line;
       while (*pch && isspace(*pch)) {
           pch++;
       }
       if (*pch == '\0')
          continue;

       // Grab the function name
       ApiName = pch;
       while(*pch != ',' && *pch != '\0')
          pch++;

       len = pch - ApiName;
       if (len + PrependLen + 1 > sizeof(ExportName)) {
           ErrMsg("ExST: ExportName Buffer overflow\n");
       }

       //Copy everything over
       memcpy(ExportName + PrependLen, ApiName, len);
       ExportName[PrependLen + len] = '\0';

       if (FindInExportsList(ExportName)) {
           //
           // Name is already in the Exports list.  Ignore the second
           // one.
           //
           DbgPrintf("Warning:  API %s was listed more than once in the services.tab.  Ignoring subsequent copies.\n", ExportName);
           continue;
       }

       memset(&ExportDebug, 0, sizeof(ExportDebug));
       ExportDebug.ExportName = ExportName;
       ExportDebug.MethodNumber = 3;
       ExportDebug.ApiPlatform = API_ALL;
       ExportDebug.Ordinal = 0;
       ExportDebug.ArgsSize = -1;

       if (!AddToExportsList(&ExportDebug)) {
           ExitErrMsg(FALSE, "ExST: Invalid Line %s\n", Line);
       }


   } while (fgets(Line, sizeof(Line) - 1, fp));


   if (!feof(fp) && ferror(fp)) {
       ExitErrMsg(FALSE, "ExST: File Read error: %s\n", FileName);   
   }

   fclose(fp);

   return;


}

/*
 *  ExtractXpt-
 *
 *  reads the exports from a ".xpt" file and builds the exports list.
 *  An ".xpt" file is simply a list of all of the exports.
 *
 */
BOOL ExtractXpt(char *XptListName, char *DllName)
{
    FILE *fp=NULL;
    BOOL bRet = FALSE;
    char *pch;
    char *pSrc=NULL;

    EXPORTSDEBUG ExportDebug;
    ULONG MethodNumber = 3;
    char Line[MAX_PATH];
    char ExportName[MAX_PATH];
    char ApiName[MAX_PATH];
    char Platform[MAX_PATH];
    BYTE ApiPlatform;
    size_t len;


    DbgPrintf("ExXpt: %s\n", XptListName);

    fp = fopen(XptListName, "r");
    if (!fp) {
        ErrMsg("ExXpt: fopen(%s) failed\n", XptListName);
        goto ExSrcExit;
    }

    if (fseek(fp, 0, SEEK_SET)) {
        ErrMsg("ExXpt: fseek failed.\n");
        goto ExSrcExit;
    }
    if (!fgets(Line, sizeof(Line) - 1, fp)) {
        if (ferror(fp)) {
            ErrMsg("ExXpt: Failed to get Defs from %s\n", XptListName);
            goto ExSrcExit;
        } else if (feof(fp)) {
            ErrMsg("ExXpt: Premature EOF %s\n", XptListName);
            goto ExSrcExit;
        }
    }

    do {
        // skip leading spaces
        pSrc = Line;
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }
        if (!*pSrc) {
            // line was blank.  Reset OLE method stuff for start of new
            // interface then get the next line.
            MethodNumber = 3;
            continue;
        }

        if (*pSrc == ';') {
            // line starts with comment.  If the comment indicates the
            // ole method number, grab that, then ignore the rest of the line.
            pSrc++;
            if (*pSrc++ == '*') {
                MethodNumber = atoi(pSrc);
            }
            continue;
        }

        // Grab the exported function name
        len = CopyToken(ApiName, pSrc, sizeof(ApiName)-1);
        if (len >= sizeof(ApiName) -1) {
            ErrMsg("ExXpt: ExportName Buffer overflow\n");
        }
        pSrc += len;

        if (FindInExportsList(ApiName)) {
            //
            // Name is already in the Exports list.  Ignore the second
            // one.
            //
            DbgPrintf("Warning:  API %s was listed more than once in the .xpt.  Ignoring subsequent copies.\n", ApiName);
            continue;
        }

        // skip over any whitespace after the export name
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }
        if (*pSrc == '\0' || *pSrc == ';') {
            // nothing else interresting on the line.  This API is supported
            // on all platoforms.
            ApiPlatform = API_ALL;
        } else {
            // next non-whitespace is not a comment.  This API has an explicit
            // list of supported platforms.
            ApiPlatform = API_NONE;

            do {
                len = CopyToken(Platform, pSrc, sizeof(Platform)-1);
                if (_stricmp(Platform, "win95") == 0) {
                    ApiPlatform |= API_WIN95;
                } else if (_stricmp(Platform, "win98") == 0) {
                    ApiPlatform |= API_WIN98;
                } else if (_stricmp(Platform, "nt4") == 0) {
                    ApiPlatform |= API_NT4;
                } else if (_stricmp(Platform, "nt5") == 0) {
                    ApiPlatform |= API_NT5;
                } else if (_stricmp(Platform, "ntx") == 0) {
                    ApiPlatform |= API_NTx;
                } else if (_stricmp(Platform, "win9x") == 0) {
                    ApiPlatform |= API_WIN9x;
                } else {
                    ExitErrMsg(FALSE, "Error: %s(%d) Unknown platform name '%s'.\n", TemplateFileName, TemplateLine, Platform);
                }
                pSrc += len;
                while (*pSrc && isspace(*pSrc)) {
                    pSrc++;
                }
            } while (*pSrc && *pSrc != ';');

            DbgPrintf("API %s has Platform %x\n", ExportName, ApiPlatform);
        }

        memset(&ExportDebug, 0, sizeof(ExportDebug));
        ExportDebug.ExportName = ExportName;
        ExportDebug.MethodNumber = MethodNumber++;
        ExportDebug.ApiPlatform = ApiPlatform;

        //
        // Look up the export in the implib
        //

        if (ImplibMappedBase) {
            int    Len;
            ULONG  SymbolMember=0;
            ULONG  ImpNumSymbols   = ImplibNumSymbols;
            PULONG ImpSymbolMember = ImplibSymbolMembers;
            PCHAR  ImpSymbolName   = ImplibSymbolNames;

            while (ImpNumSymbols--) {

                Len = strlen(ApiName);
                pch = ImpSymbolName + 1 + Len;
                if (!strncmp(ApiName, ImpSymbolName + 1, Len) &&
                    (!*pch  || *pch == '@')) {
                    SymbolMember = EndianSwitch(ImpSymbolMember);
                    break;
                }

                ImpSymbolMember++;
                ImpSymbolName += strlen(ImpSymbolName) + 1;
            }

            if (SymbolMember) {
                if (!InitExportDebug(&ExportDebug, ImpSymbolName, SymbolMember)) {
                    goto ExSrcExit;
                }
            } else {

                //
                // The export was not found in the implib, and for
                // flexibility we don't required it to be in implib.
                // fill up what we know.
                //

                ExportDebug.Ordinal = 0;
                ExportDebug.ArgsSize = -1;
                strcpy(ExportName, ApiName);
            }

        } else {

            // most info is unknown!

            ExportDebug.Ordinal = 0;
            ExportDebug.ArgsSize = -1;
            strcpy(ExportName, ApiName);
        }

        if (!AddToExportsList(&ExportDebug)) {
            goto ExSrcExit;
        }


    } while (fgets(Line, sizeof(Line) - 1, fp));


    if (!feof(fp) && ferror(fp)) {
        ErrMsg("ExXpt: File Read error: %s\n", XptListName);
        goto ExSrcExit;
    }

    bRet = TRUE;

ExSrcExit:
    if (!bRet) {
        ErrMsg("ExXpt: Invalid Line <%s>\n%s\n", pSrc, Line);
    }

    if (fp) {
        fclose(fp);
    }

    return bRet;
}



BOOL AddToExportsList(PEXPORTSDEBUG pExportsDebug)
{
   PEXPORTSDEBUG pexdbg;
   int Len;
   int SizeExportName;

   SizeExportName = strlen(pExportsDebug->ExportName) + 1;

   Len = sizeof(EXPORTSDEBUG) + SizeExportName + 1;

   pexdbg = GenHeapAlloc(Len);
   if (!pexdbg) {
       ExitErrMsg(TRUE, "GenHeapAlloc(EXPORTSDEBUG)");
   }
   memset(pexdbg, 0, Len);
   *pexdbg = *pExportsDebug;

   pexdbg->ExportName = pexdbg->Buffer;
   strcpy(pexdbg->ExportName, pExportsDebug->ExportName);

   InitializeListHead(&pexdbg->ArgsListHead);

   InsertTailList(&ExportsList, &pexdbg->ExportsDbgEntry);

   return TRUE;
}


/*
 *  ExtractPpm.  The on-disk .PPM file is opened as read-only, but
 *               the pages are copy-on-write to the pagefile, so genthnk
 *               can make changes to the in-memory version which go away
 *               when it exits.
 *
 */
BOOL ExtractPpm(char *PpmName)
{
   HANDLE hFile;
   HANDLE hMapFile = NULL;
   PVOID  pvBaseAddress;
   ULONG  Version;
   PVOID  MappedBase;
   ULONG  BytesRead;
   BOOL   bSuccess;
   NTSTATUS Status;
   PCVMHEAPHEADER pHeader;


   DbgPrintf("PpmName: %s\n", PpmName);

   hFile = CreateFile(PpmName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL
                      );

   if (hFile == INVALID_HANDLE_VALUE) {
       hFile = NULL;
       ErrMsg("ExtractPpm CreateFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }


   bSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &BytesRead,
                       NULL
                       );
   if (!bSuccess || BytesRead != sizeof(ULONG)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   if (Version != VM_TOOL_VERSION) {
      ErrMsg("ExtractPpm: .PPM version %x does not match genthnk version %x\n",
             Version, VM_TOOL_VERSION);
      return FALSE;
      }

#if _WIN64
   // Read and ignore the 4-byte padding between the Version and the Base
   bSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &BytesRead,
                       NULL
                       );
   if (!bSuccess || BytesRead != sizeof(ULONG)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }
#endif

   bSuccess = ReadFile(hFile,
                       &pvBaseAddress,
		       sizeof(ULONG_PTR),
                       &BytesRead,
                       NULL
                       );

   if (!bSuccess || BytesRead != sizeof(ULONG_PTR)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }


   hMapFile = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,NULL);
   if (!hMapFile) {
       ErrMsg("ExtractPpm CreateFileMapping(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   MappedBase = MapViewOfFileEx(hMapFile, FILE_MAP_COPY, 0, 0, 0, pvBaseAddress);
   if (!MappedBase || MappedBase != pvBaseAddress) {
       ErrMsg("ExtractPpm MapViewOfFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   pHeader = (PCVMHEAPHEADER)pvBaseAddress;

   FuncsList = &pHeader->FuncsList;
   StructsList = &pHeader->StructsList;
   TypeDefsList = &pHeader->TypeDefsList;
   NIL = &pHeader->NIL;

   // This must be done after NIL is initialized.
   RBInitTree(&FakeFuncsList);

   return TRUE;

}

void
HandlePreprocessorDirective(
    char *p
    )
{
    ExitErrMsg(FALSE, "Preprocessor directives not allowed: '%s'\n", p);
}

char *
LexMacroArgs(
    char *pch
    )
{
    BOOL fLexDone;
    char *pchNew;

    ResetLexer();
    pchNew = LexOneLine(pch, FALSE, &fLexDone);
    CurrentTokenIndex = 0;

    if (fLexDone) {
        return pchNew;
    } else {
        return pch;
    }
}

BOOLEAN
ExpandMacro(
    char *MacroName,
    PCGENSTATE pCGenState,
    char **ppIn,
    char *OutBuffer,
    SIZE_T MaxLen,
    SIZE_T *BytesReturned
    )
/*++

Routine Description:

    Expands an @MacroName(arg1, arg2, ...).

Arguments:

    MacroName   - name of macro to expand
    pCGenState  - current code-gen state
    ppIn        - pointer to pointer to character following '@MacroName'

Return Value:

    TRUE if macro expanded OK, FALSE if not.  *ppIn will be updated to
    point to the character following the end of the macro.

--*/
{
    PTEMPLES pMacroTemple;
    PLIST_ENTRY NextMacro;
    char *pIn;
    char *pArg;
    PMACROARGSLIST NewMacroArgsList;
    int ArgCount;
    int ParenDepth;

    NextMacro = MacroList.Flink;
    while (NextMacro != &MacroList) {
        pMacroTemple = CONTAINING_RECORD(NextMacro, TEMPLES, TempleEntry);

        if (strcmp(MacroName, pMacroTemple->Name) == 0) {
            //
            // Found a macro by that name
            //
            break;
        }
        NextMacro = NextMacro->Flink;
    }

    if (NextMacro == &MacroList) {
        //
        // No macro by that name.
        //
        return FALSE;
    }

    pIn = *ppIn;

    ArgCount = pMacroTemple->IndLevel;
    NewMacroArgsList = GenHeapAlloc(sizeof(MACROARGSLIST) + sizeof(LPSTR) * ArgCount);
    if (!NewMacroArgsList) {
        ExitErrMsg(TRUE, "ExpandMacro out of memory");
    }
    NewMacroArgsList->NumArgs = ArgCount;

    if (!ArgCount) {
        //
        // This macro doesn't expect arguments
        //
    } else {
        //
        //
        // This macro expects arguments.  Parse the arguments.
        //

        pIn = ParseMacroArgs(pIn, 0, &NewMacroArgsList);

        if (NewMacroArgsList->NumArgs != ArgCount) {
            ExitErrMsg(FALSE, "Macro %s expects %d arguments\n", MacroName, ArgCount);
        }

    }

    // swap out the currently active macro (if any) and swap in the new macro
    MacroStack[MacroStackTop++] = pCGenState->pMacroArgsList;
    pCGenState->pMacroArgsList = NewMacroArgsList;

    // generate code for the Begin=/End= section of the macro
    if (!pMacroTemple->CodeBurst[BeginCBI]) {
        ExitErrMsg(FALSE, "%s(%d) Macro %s has no Begin= section: %s\n", TemplateFileName, TemplateLine, MacroName, *ppIn);
    }
    CGenerateEx(pMacroTemple->CodeBurst[BeginCBI], pCGenState, OutBuffer, MaxLen, BytesReturned);
   
    // swap the previously active macro back in
    pCGenState->pMacroArgsList = MacroStack[--MacroStackTop];
                                                            
    FreeMacroArgsList(NewMacroArgsList);

    *ppIn = pIn;

    return TRUE;
}


void
WriteBoolean (
    char *pSrc,
    BOOL Value	
    )
{
    if (pSrc){
        if ( Value ){
            *pSrc++ = '1';
        }
        else{
            *pSrc++ = '0';
        }
        *pSrc = '\0';
    }	
}

char *
ExtractBoolean (
    char *expression,
    BOOLEAN *result
    )
{	
	char thischar =*expression;

	*result = FALSE;


	if ( thischar != '\0') {
		char nextchar =*(expression+1);
		if ( nextchar != '\0' && nextchar != ')' && nextchar != ',' ) {
			ExitErrMsg(FALSE,"Invalid Expression");
			return expression;
		}
	}

	if (thischar == '0') {
        *result = FALSE;	
        return expression+1;
    }
    else if (thischar == '1') {
        *result = TRUE;
        return expression+1;
	}
	else{		
        ExitErrMsg(FALSE,"Invalid Expression");
        return expression;
    }
}

char *
ExtractBoolean1(
    char *pSrc, 
    PCGENSTATE pCGenState,
    BOOLEAN *result
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    BOOLEAN TempResult = FALSE;	
    char *pExpression;
    char *pch, *pch2;
    char Buffer[MAX_PATH];
    SIZE_T BytesReturned;

    *result = FALSE;

    pch = SkipSubExpression(pSrc, &pExpression);
    if (pSrc == pch) {
        return pSrc;
        }
    pSrc = pch;

    if (pExpression) {
        CGenerateEx(pExpression, pCGenState, Buffer, MAX_PATH, &BytesReturned);
        ExtractBoolean ( Buffer, result );		

        GenHeapFree(pExpression);
    }

    return pSrc;
}

char *
ExtractBoolean2(
    char *pSrc, 
    PCGENSTATE pCGenState,
    BOOLEAN *result1,
    BOOLEAN *result2
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    char *pExpression;
    char *pch, *pch2;
    char Buffer[MAX_PATH];
    SIZE_T BytesReturned;	

    *result1 = FALSE;
    *result2 = FALSE;

    pch = SkipSubExpression(pSrc, &pExpression);
    if (pSrc == pch) {
        return pSrc;
        }
    pSrc = pch;

    if (pExpression) {
        CGenerateEx(pExpression, pCGenState, Buffer, MAX_PATH, &BytesReturned);
        pch = Buffer;
        pch = ExtractBoolean ( Buffer, result1 );		
        if ( *pch == ',') {
            pch++;
        }
        else {
            ExitErrMsg(FALSE,"Invalid Expression");
        }
        ExtractBoolean ( pch, result2 );
				
        GenHeapFree(pExpression);        
    }
    return pSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\tools\ppm2pps\ppm2pps.c ===
//////////////////////////////////////////////////////////////////////////////
// ppm2pps
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
//     Dump contents of ppm file
//
//////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "gen.h"

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'PPM2PPS' ";

//
// global variables
BOOL fDebug;            // global debug flag
BOOL fDumpCCheck;       // when set build ppswind.h for checking sizes/offsets
HANDLE hFile;
HANDLE hMapFile = NULL;

PRBTREE pFunctions = NULL;
PRBTREE pStructures = NULL;
PRBTREE pTypedefs = NULL;
PKNOWNTYPES NIL = NULL;

// function prototypes
void __cdecl ErrMsg(char *pch, ...);
void __cdecl ExitErrMsg(BOOL bSysError, char *pch, ...);
BOOL DumpTypedefs(FILE *filePpsfile,            // file to write output
                   BOOL fDumpNamedOnly,         // when set don't do unnamed 
                   PRBTREE pHead);              // known types function list
BOOL DumpStructures(FILE *filePpsfile,          // file to write output
                   BOOL fDumpNamedOnly,         // when set don't do unnamed 
                   PRBTREE pHead);              // known types function list
BOOL DumpFunctions(FILE *filePpsfile,           // file to write output
                   BOOL fDumpNamedOnly,         // when set don't do unnamed
                   PRBTREE pHead);              // known types function list
void Usage(char *s);
BOOL ParseArguments(int argc, char *argv[], char *sPpmfile, char *sPpsfile,
                    BOOL *pfDumpNamedOnly, BOOL *pfDebug, 
                    BOOL *pfDumpCCheck);
BOOL DumpCCheckHeader(PRBTREE pTypedefs,   // typedef lsit
                      PRBTREE pStructs);   // structs sit

                        
int __cdecl main(int argc, char *argv[])
{
    void *pvPpmData = NULL;
    BOOL fDumpNamedOnly;
    char sPpmfile[MAX_PATH];
    char sPpsfile[MAX_PATH];
    FILE *pfilePpsfile;

    try {

    if (! ParseArguments(argc, argv, sPpmfile, sPpsfile, 
                                    &fDumpNamedOnly, &fDebug, &fDumpCCheck))
    {
        Usage(argv[0]);
        return(-1);
    }
    
    if (*sPpmfile)
    {
        PCVMHEAPHEADER pHeader;

        pvPpmData = MapPpmFile(sPpmfile, TRUE);

        pHeader = (PCVMHEAPHEADER)pvPpmData;

        pFunctions = &pHeader->FuncsList;
        pTypedefs =  &pHeader->TypeDefsList;
        pStructures =&pHeader->StructsList;
        NIL         =&pHeader->NIL;
    
        pfilePpsfile = fopen(sPpsfile, "w");
        if (pfilePpsfile == 0)
        {
            ErrMsg("ERROR - Could not open output file %s\n", sPpsfile);
            CloseHandle(hFile);
            CloseHandle(hMapFile);
            return(-1);
        }
    
        if (DumpFunctions(pfilePpsfile, fDumpNamedOnly, 
                                                    pFunctions))
        {
            if (DumpStructures(pfilePpsfile, fDumpNamedOnly, 
                                                    pStructures))
            {
                DumpTypedefs(pfilePpsfile,fDumpNamedOnly, pTypedefs);
            }
        }
        fclose(pfilePpsfile);
    }
    
    if (fDumpCCheck && pTypedefs && pStructures)
    {
        DumpCCheckHeader(pTypedefs, pStructures);
    }
        
    CloseHandle(hFile);
    CloseHandle(hMapFile);

   } except(EXCEPTION_EXECUTE_HANDLER) {
       ExitErrMsg(FALSE,
                  "ExceptionCode=%x\n",
                  GetExceptionCode()
                  );
       }

    return(0);
}

void
DumpFuncinfo(FILE *pfilePpsfile, PFUNCINFO pf)
{
    while (pf) {
        int i;

        fprintf(pfilePpsfile,
                "%s %s%s %s %s %s",
                TokenString[pf->tkDirection],
                (pf->fIsPtr64) ? "__ptr64 " : "",
                TokenString[pf->tkPreMod],
                TokenString[pf->tkSUE],
                pf->sType,
                TokenString[pf->tkPrePostMod]
                );
        i = pf->IndLevel;
        while (i--) {
            fprintf(pfilePpsfile, "*");
        }
        fprintf(pfilePpsfile,
                "%s %s",
                TokenString[pf->tkPostMod],
                (pf->sName) ? pf->sName : ""
                );

        pf = pf->pfuncinfoNext;
        if (pf) {
            fprintf(pfilePpsfile, ", ");
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//  DumpCCheckHeader
//
//      dump header file that can be used to check sizes in ppm file against
//      those that are generated by C
//
//      returns TRUE on success
//
/////////////////////////////////////////////////////////////////////////////
BOOL DumpCCheckHeader(PRBTREE pTypedefs,   // typedef lsit
                      PRBTREE pStructs)    // structs lsit

{
    PKNOWNTYPES pknwntyp, pknwntypBasic;
    FILE *pfile;
    
    pfile = fopen("ppswind.h", "w");
    if (pfile == NULL) 
    {
        ErrMsg("Error opening ppwind.h for output\n");
        return(FALSE);
    }
    
    fprintf(pfile, "CCHECKSIZE cchecksize[] = {\n");

//
// typedefs
    pknwntyp = pTypedefs->pLastNodeInserted;

    while (pknwntyp) {
        if ((! isdigit(*pknwntyp->TypeName)) &&
            (strcmp(pknwntyp->TypeName,"...")) &&
            (strcmp(pknwntyp->TypeName,"()")) && 
            (strcmp(pknwntyp->BasicType, szFUNC)) &&
            (pknwntyp->Size > 0) &&
            (pknwntyp->dwScopeLevel == 0)) {

            pknwntypBasic = GetBasicType(pknwntyp->TypeName, 
                                     pTypedefs, pStructs);

            if (! ( (pknwntypBasic == NULL) || 
                    ( (! strcmp(pknwntypBasic->BaseName, szVOID)) &&
                      (pknwntypBasic->pmeminfo == NULL)))) {
 
                fprintf(pfile, " { %4d, sizeof(%s), \"%s\"}, \n",
                    pknwntyp->Size,
                    pknwntyp->TypeName,
                    pknwntyp->TypeName);        
            }
        }
        pknwntyp = pknwntyp->Next;
    }
    
    
//
// structs
    pknwntyp = pStructs->pLastNodeInserted;

    while (pknwntyp) {
        if ((! isdigit(*pknwntyp->TypeName) &&
            (pknwntyp->pmeminfo)))
        {
            if (!(pknwntyp->Flags & BTI_ANONYMOUS) && (pknwntyp->Size > 0) && (pknwntyp->dwScopeLevel == 0)) {
                fprintf(pfile, " { %4d, sizeof(%s %s), \"%s %s\" }, \n",
                    pknwntyp->Size,
                    pknwntyp->BaseName,
                    pknwntyp->TypeName,
                    pknwntyp->BaseName,
                    pknwntyp->TypeName);
            }
        }
        pknwntyp = pknwntyp->Next;
    }

    fprintf(pfile, " {0xffffffff, 0xffffffff,  \"\"}\n");
    fprintf(pfile,"\n};\n");
    
//
// structs fields
    fprintf(pfile, "CCHECKOFFSET ccheckoffset[] = {\n");

    pknwntyp = pStructs->pLastNodeInserted;

    while (pknwntyp) {
        if (! isdigit(*pknwntyp->TypeName)) 
        {
            if (!(pknwntyp->Flags & BTI_ANONYMOUS) && !(pknwntyp->Flags & BTI_VIRTUALONLY) && (pknwntyp->Size > 0) && (pknwntyp->dwScopeLevel == 0)) {
                PMEMBERINFO pmeminfo = pknwntyp->pmeminfo;
                while (pmeminfo != NULL) {
                    if ((pmeminfo->sName != NULL) && (*pmeminfo->sName != 0) && !(pmeminfo->bIsBitfield))
                    { 
                        fprintf(pfile, " { %4d, (long) (& (((%s %s *)0)->%s)), \"%s\", \"%s\" },\n",
                            pmeminfo->dwOffset,
                            pknwntyp->BaseName,
                            pknwntyp->TypeName,
                            pmeminfo->sName,
                            pknwntyp->TypeName,                   
                            pmeminfo->sName);
                    }
                    pmeminfo = pmeminfo->pmeminfoNext;
                }
                
            }
        }
        pknwntyp = pknwntyp->Next;
    }
    
    fprintf(pfile, " {0xffffffff, 0xffffffff, \"\", \"\"}\n");
    fprintf(pfile,"\n};\n");
    fclose(pfile);
    return(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
//
//  DumpTypedefs
//
//      dump structures from ppm file to output file
//
//      returns TRUE on success
//
/////////////////////////////////////////////////////////////////////////////
BOOL DumpTypedefs(FILE *pfilePpsfile,            // file to write output
                   BOOL fDumpNamedOnly,          // when set don't do unnamed 
                   PRBTREE pHead)                // known types function list
{
    KNOWNTYPES *pknwntyp;

    pknwntyp = pHead->pLastNodeInserted;

    fprintf(pfilePpsfile,"[Typedefs]\n\n");
    while (pknwntyp) {
        fprintf(pfilePpsfile,
                   "%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|",
                   pknwntyp->Flags,
                   pknwntyp->IndLevel,
                   pknwntyp->Size,
                   pknwntyp->BasicType,
                   pknwntyp->BaseName ? pknwntyp->BaseName : szNULL,
                   pknwntyp->FuncRet ? pknwntyp->FuncRet : szNULL,
                   pknwntyp->FuncMod ? pknwntyp->FuncMod : szNULL,
                   pknwntyp->TypeName
                   );
        DumpFuncinfo(pfilePpsfile, pknwntyp->pfuncinfo);
        fprintf(pfilePpsfile, "|\n");

        pknwntyp = pknwntyp->Next;
    }
    return(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
//
//  DumpStructures
//
//      dump structures from ppm file to output file
//
//      returns TRUE on success
//
/////////////////////////////////////////////////////////////////////////////
BOOL DumpStructures(FILE *pfilePpsfile,          // file to write output
                   BOOL fDumpNamedOnly,          // when set don't do unnamed 
                   PRBTREE pHead)                // known types function list
{
    KNOWNTYPES *pknwntyp;
    DWORD dw;
    PMEMBERINFO pmeminfo;

    pknwntyp = pHead->pLastNodeInserted;

    fprintf(pfilePpsfile,"[Structures]\n\n");
    while (pknwntyp) {
        if (! fDumpNamedOnly || ! isdigit(*pknwntyp->TypeName)) {
            fprintf(pfilePpsfile,
                   "%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|",
                   pknwntyp->Flags,
                   pknwntyp->IndLevel,
                   pknwntyp->Size,                
                   pknwntyp->BasicType,
                   pknwntyp->BaseName ? pknwntyp->BaseName : szNULL,
                   pknwntyp->FuncRet ? pknwntyp->FuncRet : szNULL,
                   pknwntyp->FuncMod ? pknwntyp->FuncMod : szNULL,
                   pknwntyp->TypeName);

            // dump out the structure member info, if present
            pmeminfo = pknwntyp->pmeminfo;
            while (pmeminfo) {
                int i;

                fprintf(pfilePpsfile, "%s", pmeminfo->sType);
                i = pmeminfo->IndLevel;
                if (i) {
                    fprintf(pfilePpsfile, " ");
                    while (i--) {
                        fprintf(pfilePpsfile, "*");
                    }
                }
                if (pmeminfo->sName) {
                    fprintf(pfilePpsfile, " %s", pmeminfo->sName);
                }
                fprintf(pfilePpsfile, " @ %d|", pmeminfo->dwOffset);
                pmeminfo = pmeminfo->pmeminfoNext;
            }

            // dump out the function info, if present
            DumpFuncinfo(pfilePpsfile, pknwntyp->pfuncinfo);

            fprintf(pfilePpsfile, "\n");
        }

        pknwntyp = pknwntyp->Next;
    }
    return(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
//
//  DumpFunctions
//
//      dump fucntion prototypes from ppm file to output file
//
//      returns TRUE on success
//
/////////////////////////////////////////////////////////////////////////////
BOOL DumpFunctions(FILE *pfilePpsfile,            // file to write output
                   BOOL fDumpNamedOnly,           // when set don't do unnamed
                   PRBTREE pHead)                 // known types function list
{
    KNOWNTYPES *pknwntyp;
    PFUNCINFO pf;

    pknwntyp = pHead->pLastNodeInserted;

    fprintf(pfilePpsfile,"[Functions]\n\n");
    while (pknwntyp) {
        fprintf(pfilePpsfile,
                   "%s|%s|%s|%s|",
                   (pknwntyp->Flags & BTI_DLLEXPORT) ? "dllexport" : "",
                   pknwntyp->FuncRet,
                   pknwntyp->FuncMod ? pknwntyp->FuncMod : szNULL,
                   pknwntyp->TypeName
                   );
        DumpFuncinfo(pfilePpsfile, pknwntyp->pfuncinfo);
        fprintf(pfilePpsfile, "|\n");
        pknwntyp = pknwntyp->Next;
    }
    return(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
//
//  Usgae
//
//      tells how to use
//
//
/////////////////////////////////////////////////////////////////////////////
void Usage(char *s)        // name of command invoked
{
    printf("Usage:\n");
    printf("    %s -d -n -x <ppm file> <pps output file>\n", s);
    printf("        -d set debug flag\n");
    printf("        -n dumps only named structs/enums/unions\n");
    printf("        -x creates ppswind.h for size/offset checking\n");
}

/////////////////////////////////////////////////////////////////////////////
//
//  ParseArgumaners
//
//      parse arguments
//
//      returnms FALSE on syntax error
//
/////////////////////////////////////////////////////////////////////////////

BOOL ParseArguments(int argc, char *argv[], char *sPpmfile, char *sPpsfile,
                    BOOL *pfDumpNamedOnly, BOOL *pfDebug, 
                    BOOL *pfDumpCCheck)
{
    int i;
    
    *sPpmfile = 0;
    *sPpsfile = 0;
    *pfDumpNamedOnly = FALSE;
    *pfDebug = FALSE;
    *pfDumpCCheck = FALSE;
    
    for (i = 1; i < argc; i++)
    {
        if (*argv[i] == '-')
        {
            switch(tolower(argv[i][1]))
            {
                case 'd':
                {
                    *pfDebug = TRUE;
                    break;
                }
                
                case 'n':
                {
                    *pfDumpNamedOnly = TRUE;
                    break;
                }
                
                case 'x':
                {
                    *pfDumpCCheck = TRUE;
                    break;
                }
                
                default:
                {
                    return(FALSE);
                }
            }
        } else {
            if (lstrlenA(argv[i]) >= MAX_PATH)
            {
                return(FALSE);
            }
            if (*sPpmfile == 0)
            {
                strcpy(sPpmfile, argv[i]);
            } else if (*sPpsfile == 0)
            {
                strcpy(sPpsfile, argv[i]);
            } else {
                return(FALSE);
            }
        }        
    }
    return( *pfDumpCCheck || ((*sPpmfile != 0) && (*sPpsfile != 0)));
}

void
HandlePreprocessorDirective(
    char *p
    )
{
    ExitErrMsg(FALSE, "Preprocessor directives not allowed by ppm2pps\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\callback.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    callback.c

Abstract:

    Provides generic 64-to-32 transfer routines.

Author:

    20-May-1998 BarryBo

Revision History:

    2-Sept-1999 [askhalid] Removing some 32bit alpha specific code and using right context.

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;

VOID
WOW64DLLAPI
Wow64ApcRoutine(
    ULONG_PTR ApcContext,
    ULONG_PTR Arg2,
    ULONG_PTR Arg3
    )
/*++

Routine Description:

    Call a 32-bit APC function.

Arguments:

    ApcContext  - wow64 APC context data
    Arg2        - second arg to APC routine
    Arg3        - third arg to APC routine

Return Value:

    None.  Returns contrl back to NTDLL's APC handler, which will
    call native NtContinue to resume execution.

--*/
{
    CONTEXT32 NewContext32;
    ULONG SP;
    PULONG Ptr;
    USER_APC_ENTRY UserApcEntry;

    //
    // Grab the current 32-bit context
    //
    NewContext32.ContextFlags = CONTEXT32_INTEGER|CONTEXT32_CONTROL;
    CpuGetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NULL,
                  &NewContext32);

    

    //
    // Build up the APC callback state in NewContext32
    //
    SP = CpuGetStackPointer() & (~3);
    SP -= 4*sizeof(ULONG)+sizeof(CONTEXT32);
    Ptr = (PULONG)SP;
    Ptr[0] = (ULONG)(ApcContext >> 32);            // NormalRoutine
    Ptr[1] = (ULONG)ApcContext;                    // NormalContext
    Ptr[2] = (ULONG)Arg2;                          // SystemArgument1
    Ptr[3] = (ULONG)Arg3;                          // SystemArgument2
    ((PCONTEXT32)(&Ptr[4]))->ContextFlags = CONTEXT32_FULL;
    CpuGetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NULL,
                  (PCONTEXT32)&Ptr[4]); // ContinueContext (BYVAL!)
    CpuSetStackPointer(SP);
    CpuSetInstructionPointer(Ntdll32KiUserApcDispatcher);

    //
    // Link this APC into the list of outstanding APCs
    //
    UserApcEntry.Next = (PUSER_APC_ENTRY)Wow64TlsGetValue(WOW64_TLS_APCLIST);
    UserApcEntry.pContext32 = (PCONTEXT32)&Ptr[4];
    Wow64TlsSetValue(WOW64_TLS_APCLIST, &UserApcEntry);

    //
    // Call the 32-bit APC function.  32-bit NtContinue will longjmp
    // back when the APC function is done.
    //
    if (setjmp(UserApcEntry.JumpBuffer) == 0) {
        RunCpuSimulation();
    }
    //
    // If we get here, Wow64NtContinue has done a longjmp back, so
    // return back to the caller (in ntdll.dll), which will do a
    // native NtContinue and restore the native stack pointer and
    // context back.
    //
    // This is critical to do.  The x86 CONTEXT above has an out-of-date
    // value for EAX.  It still contains the system-service number for
    // whatever kernel call was made that allowed the APC to run.  On
    // an x86 machine, the x86 CONTEXT above would have had STATUS_USER_APC
    // or some other code like it, but on WOW64 we don't know what value
    // to use.  The correct value is sitting in the 64-bit CONTEXT up
    // the stack from where we are.  So... by returning here via longjmp,
    // native ntdll.dll will do an NtContinue to resume execution in the
    // native Nt* API that allowed the native APC to fire.  It will load
    // the return register with the right NTSTATUS code, so the whNt*
    // thunk will see the correct code, and reflect it into EAX.
    //
}


NTSTATUS
WOW64DLLAPI
Wow64WrapApcProc(
    PVOID *pApcRoutine,
    PVOID *pApcContext
    )
/*++

Routine Description:

    Thunk a 32-bit ApcRoutine/ApcContext pair to 64-bit

Arguments:

    pApcRoutine - pointer to pointer to APC routine.  IN is the 32-bit
                  routine.  OUT is the 64-bit wow64 thunk
    pApcContext - pointer to pointer to APC context.  IN is the 32-bit
                  context.  OUT is the 64-bit wow64 thunk

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (*pApcRoutine) {

        //
        // Dispatch the call to the jacket routine inside Wow64
        //
        
        *pApcContext = (PVOID)((ULONG_PTR)*pApcContext | ((ULONG_PTR)*pApcRoutine << 32));
        *pApcRoutine = Wow64ApcRoutine;

    } else {

        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return NtStatus;
}

ULONG
Wow64KiUserCallbackDispatcher(
    PUSERCALLBACKDATA pUserCallbackData,
    ULONG ApiNumber,
    ULONG ApiArgument,
    ULONG ApiSize
    )
/*++

Routine Description:

    Make a call from a 64-to-32 user callback thunk into 32-bit code.
    This function calls ntdll32's KiUserCallbackDispatcher, and returns
    when 32-bit code calls NtCallbackReturn/ZwCallbackReturn.

Arguments:

    pUserCallbackData - OUT struct to use for tracking this callback
    ApiNumber       - index of API to call
    ApiArgument     - 32-bit pointer to 32-bit argument to the API
    ApiSize         - size of *ApiArgument

Return Value:

    Return value from the API call

--*/
{
    CONTEXT32 OldContext;
    ULONG ExceptionList;
    PTEB32 Teb32;
    ULONG NewStack;

    //
    // Handle nested callbacks
    //
    pUserCallbackData->PreviousUserCallbackData = Wow64TlsGetValue(WOW64_TLS_USERCALLBACKDATA);

    //
    // Store the callback data in the TEB.  whNtCallbackReturn will
    // use this pointer to pass information back here via a longjmp.
    //
    Wow64TlsSetValue(WOW64_TLS_USERCALLBACKDATA, pUserCallbackData);

    if (!setjmp(pUserCallbackData->JumpBuffer)) {
        //
        // Make the call to ntdll32.  whNtCallbackReturn will
        // longjmp back to this routine when it is called.
        //
        OldContext.ContextFlags = CONTEXT32_FULL;
        CpuGetContext(NtCurrentThread(),
                      NtCurrentProcess(),
                      NULL,
                      &OldContext);
        NewStack = OldContext.Esp - ApiSize;

        RtlCopyMemory((PVOID)NewStack, (PVOID)ApiArgument, ApiSize);

        *(PULONG)(NewStack - 4) = 0;  // InputLength
        *(PULONG)(NewStack - 8) = NewStack;
        *(PULONG)(NewStack - 12) = ApiNumber;
        *(PULONG)(NewStack - 16) = 0;
        NewStack -= 16;
        CpuSetStackPointer(NewStack);
        CpuSetInstructionPointer(Ntdll32KiUserCallbackDispatcher);

        //
        // Save the exception list in case another handler is defined during
        // the callout.
        //
        Teb32 = NtCurrentTeb32();
        ExceptionList = Teb32->NtTib.ExceptionList;

        //
        // Execte the callback
        //
        RunCpuSimulation();
        //
        // This never returns.  When 32-bit code is done, it calls
        // NtCallbackReturn.  The thunk does a longjmp back to this
        // routine and lands in the 'else' clause below:
        //

    } else {
        //
        // Made it back from the NtCallbackReturn thunk.  Restore the
        // 32-bit context as it was before the callback, and return
        // back to our caller.  Our caller will call 64-bit
        // NtCallbackReturn to finish blowing off the 64-bit stack.
        //
        CpuSetContext(NtCurrentThread(),
                      NtCurrentProcess(),
                      NULL,
                      &OldContext);
        //
        // Restore exception list.
        //

        NtCurrentTeb32()->NtTib.ExceptionList = ExceptionList;
        return pUserCallbackData->Status;
    }

    //
    // Should never get here.
    //
    WOWASSERT(FALSE);
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
Wow64NtCallbackReturn(
    PVOID OutputBuffer,
    ULONG OutputLength,
    NTSTATUS Status
    )
{
    PUSERCALLBACKDATA pUserCallbackData; 

    //
    // Find the callback data stuffed in TLS by Wow64KiUserCallbackDispatcher
    //
    pUserCallbackData = (PUSERCALLBACKDATA)Wow64TlsGetValue(WOW64_TLS_USERCALLBACKDATA);
    if (pUserCallbackData) {
        //
        // Restore previous User Callback context
        //
        Wow64TlsSetValue(WOW64_TLS_USERCALLBACKDATA, pUserCallbackData->PreviousUserCallbackData);

        //
        // Jump back to Wow64KiUserCallbackDispatcher
        //
        pUserCallbackData->UserBuffer = NULL;
        pUserCallbackData->OutputBuffer = OutputBuffer;

        //
        // realigned the buffer
        //
        if ((SIZE_T)OutputBuffer & 0x07) {
            pUserCallbackData->OutputBuffer = Wow64AllocateHeap ( OutputLength );
            RtlCopyMemory (pUserCallbackData->OutputBuffer, OutputBuffer, OutputLength );
            pUserCallbackData->UserBuffer = OutputBuffer;  // works as a flag
        }

        pUserCallbackData->OutputLength = OutputLength;
        pUserCallbackData->Status = Status;
        longjmp(pUserCallbackData->JumpBuffer, 1);
        // This never returns.
    }
    //
    // No callback data.  Probably a non-nested NtCallbackReturn call.
    // The kernel fails these with this return value.
    //
    return STATUS_NO_CALLBACK_ACTIVE;

}

WOW64DLLAPI
NTSTATUS
Wow64NtContinue(
    IN PCONTEXT ContextRecord, // really a PCONTEXT32
    IN BOOLEAN TestAlert
    )
/*++

Routine Description:

    32-bit wrapper for NtContinue.  Loads the new CONTEXT32 into the CPU
    and optionally allows usermode APCs to run.

Arguments:

    ContextRecord   - new 32-bit CONTEXT to use
    TestAlert       - TRUE if usermode APCs may be fired

Return Value:

    NTSTATUS.

--*/
{
    PCONTEXT32 Context32 = (PCONTEXT32)ContextRecord;
    PUSER_APC_ENTRY pApcEntry;
    PUSER_APC_ENTRY pApcEntryPrev;

    CpuSetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NULL,
                  Context32);

    pApcEntryPrev = NULL;
    pApcEntry = (PUSER_APC_ENTRY)Wow64TlsGetValue(WOW64_TLS_APCLIST);
    while (pApcEntry) {
        if (pApcEntry->pContext32 == Context32) {
            //
            // Found an outstanding usermode APC on this thread, and this
            // NtContinue call matches it.  Unwind back to the right place
            // on the native stack and have it do an NtContinue too.
            //
            if (pApcEntryPrev) {
                pApcEntryPrev->Next = pApcEntry->Next;
            } else {
                Wow64TlsSetValue(WOW64_TLS_APCLIST, pApcEntry->Next);
            }
            longjmp(pApcEntry->JumpBuffer, 1);
        }
        pApcEntryPrev = pApcEntry;
        pApcEntry = pApcEntry->Next;
    }
    //
    // No usermode APC is outstanding for this context record.  Don't
    // unwind the native stack because there is no place to go... just
    // continue the simulation.
    //
    if (TestAlert) {
        NtTestAlert();
    }
    return Context32->Eax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\thnkhlpr.c ===
/*++                 

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    thnkhlpr.c

Abstract:
    
    Thunk helper functions called by all thunks.

Author:

    19-Jul-1998 mzoran

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>                                         
#include <stdlib.h>
                                       
#include "nt32.h"                                                                                                                                     
#include "wow64p.h"
#include "thnkhlpr.h"                                         
ASSERTNAME;  

const UNICODE_STRING KnownDlls64 = {20, 20, L"\\KnownDlls"};
const UNICODE_STRING KnownDlls32 = {24, 24, L"\\KnownDlls32"};


//
// Array of directories to disable redirection for. The directory path is relative 
// to %windir%\system32
//

const PATH_REDIRECT_EXEMPT PathRediectExempt[] =
{
    // %windir%\system32\drivers\etc
    {L"\\drivers\\etc", ((sizeof(L"\\drivers\\etc")/sizeof(WCHAR)) - 1), FALSE} ,

    // %windir%\system32\spool
    {L"\\spool", ((sizeof(L"\\spool")/sizeof(WCHAR)) - 1), FALSE} ,

    // %windir%\system32\catroot
    {L"\\catroot", ((sizeof(L"\\catroot")/sizeof(WCHAR)) - 1), FALSE} ,

    // %windir%\system32\catroot2
    {L"\\catroot2", ((sizeof(L"\\catroot2")/sizeof(WCHAR)) - 1), FALSE} ,

};


VOID
RedirectObjectName(
    POBJECT_ATTRIBUTES Obj
    )
/*++

Routine Description:

    This function is called from any thunk with an IN POBJECT_ATTRIBUTES.
    The ObjectName field is redirected if it appears to point into the
    native system directory.

    The new name is allocated with Wow64AllocateTemp.
    
    An exception is thrown if an error occures.

Arguments:

    Obj - already-thunked 64-bit POBJECT_PARAMETERS.

Return Value:

    None

--*/
{
    PUNICODE_STRING Name;
    PUNICODE_STRING NewName;
    NTSTATUS st;
    PFILE_NAME_INFORMATION NameInformation;
    LONG Result;
    USHORT OriginalLength;
    PWCHAR RelativePath;
    ULONG Index;
    INT CompareResult;
    LPWSTR RedirDisableFilename, Temp;
    USHORT NewNameLength;
    BOOLEAN CaseInsensitive;
    BOOLEAN RedirectFile;


    if (!Obj || !Obj->ObjectName) {
        // No object, no name, or length is too short to hold Unicode "system32"
        return;
    }

    Name = Obj->ObjectName;
    if (RtlEqualUnicodeString(Name, 
                              &KnownDlls64,
                              (Obj->Attributes & OBJ_CASE_INSENSITIVE) ? TRUE : FALSE)) {
        // Map KnownDlls to KnownDlls32
        Obj->ObjectName = (PUNICODE_STRING)&KnownDlls32;
        LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
        return;
    }

    if (Obj->RootDirectory) {
        //
        // Need to fully qualify the object name, since part is a handle and
        // part is a path string.
        //
        PEB32 *pPeb32;
        NT32RTL_USER_PROCESS_PARAMETERS *pParams32;
        NT32CURDIR *pCurDir32;

        pPeb32 = NtCurrentPeb32();
        pParams32=(NT32RTL_USER_PROCESS_PARAMETERS*)pPeb32->ProcessParameters;
        pCurDir32 = (NT32CURDIR*)&pParams32->CurrentDirectory;

        if (pCurDir32->Handle == HandleToLong(Obj->RootDirectory)) {
            //
            // The object is relative to the process current directory
            //
            ULONG Length;
            UNICODE_STRING CurDirDosPath;

            Wow64ShallowThunkUnicodeString32TO64(&CurDirDosPath, &pCurDir32->DosPath);
            // Allocate space for the name, plus space for "\\??\\"
            Length = 8+CurDirDosPath.Length+Obj->ObjectName->Length;
            Name = Wow64AllocateTemp(sizeof(UNICODE_STRING)+Length);
            Name->Buffer = (LPWSTR)(Name+1);
            Name->MaximumLength = (USHORT)Length;
            Name->Length = 8;
            wcscpy(Name->Buffer, L"\\??\\");
            RtlAppendUnicodeStringToString(Name, &CurDirDosPath);
            RtlAppendUnicodeStringToString(Name, Obj->ObjectName);
        } else {
            //
            // Not the process current directory handle, so work it out the
            // hard way.
            //
            ULONG Length;
            IO_STATUS_BLOCK iosb;

            //
            // Allocate a buffer big enough for the biggest filename plus a null
            // terminator for the end (which we add later, if the API call
            // succeeds).
            //
            Length = sizeof(FILE_NAME_INFORMATION)+(MAXIMUM_FILENAME_LENGTH+1)*sizeof(WCHAR);

            NameInformation = Wow64AllocateTemp(Length);
            st = NtQueryInformationFile(Obj->RootDirectory,
                                        &iosb,
                                        NameInformation,
                                        Length,
                                        FileNameInformation);
            if (!NT_SUCCESS(st)) {
                // The handle is bad - don't try to redirect the filename part.
                return;
            }

            // null-terminate the filename
            NameInformation->FileName[NameInformation->FileNameLength / sizeof(WCHAR)] = L'\0';

            if (wcsncmp(NameInformation->FileName, L"\\??\\", 4) != 0) {
                // The name doesn't point to a file/directory, so no need
                // to redirect.
                return;
            }

            Name = Wow64AllocateTemp(sizeof(UNICODE_STRING));
            Name->Buffer = NameInformation->FileName;
            Name->Length = (USHORT)NameInformation->FileNameLength;
            Name->MaximumLength = MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR);
            RtlAppendUnicodeStringToString(Name, Obj->ObjectName);
        }
    }


    CaseInsensitive = (Obj->Attributes & OBJ_CASE_INSENSITIVE) ? TRUE : FALSE;

    RedirDisableFilename = (LPWSTR)Wow64TlsGetValue(WOW64_TLS_FILESYSREDIR);
    if (RedirDisableFilename) {
        // The caller has asked that the filesystem redirector be disabled
        // for a particular filename.
        UNICODE_STRING DisableFilename;

        if (RtlDosPathNameToNtPathName_U(RedirDisableFilename, &DisableFilename, NULL, NULL)) {
            // If the call fails, then don't try to disable redirection for it.
            // The failure may be out-of-memory, or it may be an invalid filename.
            Result = RtlCompareUnicodeString(Name, &DisableFilename, CaseInsensitive);
            if (Result == 0) {
                LOGPRINT((TRACELOG, "Filesystem redirection disabled for %wZ\n", &DisableFilename));
                return;
            }

        }
    }

    if (Name->Length >= NtSystem32Path.Length) {
        
        // Compare the strings, but force the lengths to be equal,
        // as RtlCompareUnicodeString returns the difference in length
        // if the strings are otherwise identical.
        OriginalLength = Name->Length;
        Name->Length = NtSystem32Path.Length;
        Result = RtlCompareUnicodeString(Name, &NtSystem32Path, CaseInsensitive);
        Name->Length = OriginalLength;
        if (Result == 0) {
        
            //
            // Make sure that the directory isn't part of our exception-list
            //
            RelativePath = (PWCHAR)((PCHAR)Name->Buffer + NtSystem32Path.Length);
            if (RelativePath[0] != UNICODE_NULL) {
                for (Index=0 ; Index < (sizeof(PathRediectExempt)/sizeof(PathRediectExempt[0])) ; Index++) {
                    CompareResult = _wcsnicmp(RelativePath, 
                                              PathRediectExempt[Index].Path, 
                                              PathRediectExempt[Index].CharCount);
                    if (CompareResult == 0) {
                        if ((PathRediectExempt[Index].ThisDirOnly == FALSE) ||
                            (wcschr(RelativePath+(PathRediectExempt[Index].CharCount+1), L'\\') == NULL)) {
                            return;
                        }
                    }
                }
            }

            //
            // Map system32 to syswow64
            //

            // Make a copy of the original string
            NewName = Wow64AllocateTemp(sizeof(UNICODE_STRING)+Name->MaximumLength);
            NewName->Length = Name->Length;
            NewName->MaximumLength = Name->MaximumLength;
            NewName->Buffer = (PWSTR)(NewName+1);
            RtlCopyMemory(NewName->Buffer, Name->Buffer, Name->MaximumLength);

            // Replace System32 by SysWow64
            RtlCopyMemory(&NewName->Buffer[(NtSystem32Path.Length - WOW64_SYSTEM_DIRECTORY_U_SIZE) / 2],
                          WOW64_SYSTEM_DIRECTORY_U,
                          WOW64_SYSTEM_DIRECTORY_U_SIZE);

            // Update the OBJECT_ATTRIBUTES.  Clear the RootDirectory handle
            // as the pathname is now fully-qualified.
            Obj->ObjectName = NewName;
            Obj->RootDirectory = NULL;
            LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
            return;
        }
    }


    if (Name->Length >= NtWindowsImePath.Length) {
        
        // Check if the name is %systemroot%\ime
        OriginalLength = Name->Length;
        Name->Length = NtWindowsImePath.Length;
        Result = RtlCompareUnicodeString(Name,
                                         &NtWindowsImePath,
                                         CaseInsensitive);
        Name->Length = OriginalLength;

        if (Result == 0) {
            
            // Map to %windir%\ime to %windir%\ime (x86).
        
            RedirectFile = TRUE;
            if (Name->Length > NtWindowsImePath.Length) {
                if ((*(PWCHAR)((PCHAR)Name->Buffer + NtWindowsImePath.Length)) != L'\\') {
                    RedirectFile = FALSE;
                } else {
                    
                    if ((Name->Length >= (NtWindowsImePath.Length + sizeof (WOW64_X86_TAG_U) - sizeof (UNICODE_NULL))) &&
                        (_wcsnicmp((PWCHAR)((PCHAR)Name->Buffer + NtWindowsImePath.Length), WOW64_X86_TAG_U, (sizeof(WOW64_X86_TAG_U) - sizeof(UNICODE_NULL))/sizeof(WCHAR)) != 0)) {
                        RedirectFile = FALSE;
                    }
                }
            }

            if (RedirectFile == TRUE) {

                NewNameLength = Name->Length+sizeof(WOW64_X86_TAG_U);
                NewName = Wow64AllocateTemp(sizeof(UNICODE_STRING)+NewNameLength);
                NewName->Length = (USHORT)NewNameLength-sizeof(UNICODE_NULL);
                NewName->MaximumLength = NewNameLength;
                NewName->Buffer = (PWSTR)(NewName+1);

                Temp = NewName->Buffer;
                RtlCopyMemory(Temp, Name->Buffer, NtWindowsImePath.Length);
                Temp = (PWCHAR)((PCHAR)Temp + NtWindowsImePath.Length);
        
                RtlCopyMemory(Temp, WOW64_X86_TAG_U, sizeof(WOW64_X86_TAG_U) - sizeof(UNICODE_NULL));
                Temp = (PWCHAR)((PCHAR)Temp + (sizeof(WOW64_X86_TAG_U) - sizeof(UNICODE_NULL)));

                RtlCopyMemory(Temp, ((PCHAR)Name->Buffer + NtWindowsImePath.Length) , Name->Length - NtWindowsImePath.Length);
    
                Obj->ObjectName = NewName;
                Obj->RootDirectory = NULL;
        
                LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
            }
            return;
        }
    }

    if (Name->Length >= RegeditPath.Length) {
        // Check if the name is %systemroot%\regedit.exe
        Result = RtlCompareUnicodeString(Name,
                                         &RegeditPath, 
                                         (Obj->Attributes & OBJ_CASE_INSENSITIVE) ? TRUE : FALSE);
        if (Result == 0) {
            // Map to %windir%\syswow64\regedit.exe.  Allocate enough space
            // for the UNICODE_STRING plus "\??\%systemroot%\syswow64\regedit.exe"
            // The memory allocation contains a terminating NULL character, but the
            // Unicode string's Length does not.
            SIZE_T SystemRootLength = wcslen(USER_SHARED_DATA->NtSystemRoot);
            SIZE_T NameLength = sizeof(L"\\??\\")-sizeof(WCHAR) +
                                SystemRootLength*sizeof(WCHAR) +
                                sizeof(L'\\') +
                                sizeof(WOW64_SYSTEM_DIRECTORY_U)-sizeof(WCHAR) +
                                sizeof(L"\\regedit.exe");
            NewName = Wow64AllocateTemp(sizeof(UNICODE_STRING)+NameLength);
            NewName->Length = (USHORT)NameLength-sizeof(WCHAR);
            NewName->MaximumLength = NewName->Length;
            NewName->Buffer = (PWSTR)(NewName+1);
            wcscpy(NewName->Buffer, L"\\??\\");
            wcscpy(&NewName->Buffer[4], USER_SHARED_DATA->NtSystemRoot);
            NewName->Buffer[4+SystemRootLength] = '\\';
            wcscpy(&NewName->Buffer[4+SystemRootLength+1], WOW64_SYSTEM_DIRECTORY_U);
            wcscpy(&NewName->Buffer[4+SystemRootLength+1+(sizeof(WOW64_SYSTEM_DIRECTORY_U)-1)/sizeof(WCHAR)], L"\\regedit.exe");
            Obj->ObjectName = NewName;
            Obj->RootDirectory = NULL;
            LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
            return;
        }
    }
}

VOID
Wow64RedirectFileName(
    IN OUT WCHAR *Name,
    IN OUT ULONG *Length
    )
/*++

Routine Description:

    This function is called to thunk a filename/length pair.
    
    An exception is thrown if an error occures.

Arguments:

    Name    - IN OUT UNICODE filename to thunk
    Length  - IN OUT pointer to filename length.
    

Return Value:

    None.  Contents of the Name and Length may be updated

--*/
{
    OBJECT_ATTRIBUTES Obj;
    UNICODE_STRING Ustr;

    if (*Length >= 0xffff) {
        RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    }
    Ustr.Length = Ustr.MaximumLength = (USHORT)*Length;
    Ustr.Buffer = Name;

    InitializeObjectAttributes(&Obj,
                               &Ustr,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    RedirectObjectName(&Obj);
    if (Obj.ObjectName != &Ustr) {
        // RedirectObjectName actually changed the name.  Copy it back
        *Length = Obj.ObjectName->Length;
        RtlCopyMemory(Name, Obj.ObjectName->Buffer, Obj.ObjectName->Length);
    }
}

PUNICODE_STRING
Wow64ShallowThunkAllocUnicodeString32TO64_FNC(
    IN NT32UNICODE_STRING *src
    )

/*++

Routine Description:

    This function allocates a new UNICODE_STRING by calling Wow64AllocateTemp 
    and thunks the source to the new string.
    
    The mimimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit string to be thunked.
    
Return Value:

    Ptr to the newly allocated 64 bit string.

--*/


{
   PUNICODE_STRING dst;

   if (src == NULL) {
      return NULL;
   }

   dst = Wow64AllocateTemp(sizeof(UNICODE_STRING));

   dst->Length = src->Length;
   dst->MaximumLength = src->MaximumLength;
   dst->Buffer = (PWSTR)src->Buffer;

   return dst;
}

PSECURITY_DESCRIPTOR
Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC(
    IN NT32SECURITY_DESCRIPTOR *src
    )

/*++
                                     
Routine Description:

    This function allocates a new SECURITY_DESCRIPTOR by calling Wow64AllocateTemp and 
    thunks the source to the new structure.
    
    The minimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit SECURITY_DESCRIPTOR to be thunked.
    
Return Value:

    Ptr to the newly allocated 64 bit SECURITY_DESCRIPTOR.
--*/


{

   SECURITY_DESCRIPTOR *dst;

   if (src == NULL) {
      return NULL;
   }

   if (src->Control & SE_SELF_RELATIVE) {
      // The security descriptor is self relative(no pointers).
      return (PSECURITY_DESCRIPTOR)src;
   }

   dst = Wow64AllocateTemp(sizeof(SECURITY_DESCRIPTOR));

   dst->Revision = src->Revision;
   dst->Sbz1 = src->Sbz1;
   dst->Control = (SECURITY_DESCRIPTOR_CONTROL)src->Control;
   dst->Owner = (PSID)src->Owner;
   dst->Group = (PSID)src->Group;
   dst->Sacl = (PACL)src->Sacl;
   dst->Dacl = (PACL)src->Dacl;

   return (PSECURITY_DESCRIPTOR)dst;
}
    
PSECURITY_TOKEN_PROXY_DATA
Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC(
    IN NT32SECURITY_TOKEN_PROXY_DATA *src
    )
/*++

Routine Description:

    This function allocates a new SECURITY_TOKEN_PRXY_DATA by calling Wow64AllocateTemp and 
    thunks the source to the new structure.
    
    The minimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit SECURITY_TOKEN_PROXY_DATA to be thunked.
    
Return Value:

    Ptr to the newly allocated 64 bit SECURITY_TOKEN_PROXY_DATA.

--*/
{
   SECURITY_TOKEN_PROXY_DATA *dst;

   if (NULL == src) {
      return NULL;
   }

   if (src->Length != sizeof(NT32SECURITY_TOKEN_PROXY_DATA)) {
      RtlRaiseStatus(STATUS_INVALID_PARAMETER);
   }

   dst = Wow64AllocateTemp(sizeof(SECURITY_TOKEN_PROXY_DATA));

   dst->Length = sizeof(SECURITY_TOKEN_PROXY_DATA);
   dst->ProxyClass = src->ProxyClass;
   Wow64ShallowThunkUnicodeString32TO64(&(dst->PathInfo), &(src->PathInfo));
   dst->ContainerMask = src->ContainerMask;
   dst->ObjectMask = src->ObjectMask;

   return (PSECURITY_TOKEN_PROXY_DATA)dst;
}


PSECURITY_QUALITY_OF_SERVICE
Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC(
    IN NT32SECURITY_QUALITY_OF_SERVICE *src
    )
/*++

Routine Description:

    This function allocates a new SECURITY_QUALITY_OF_SERVICE by calling Wow64AllocateTemp and 
    thunks the source to the new structure.
    
    The minimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit SECURITY_TOKEN_PROXY_DATA to be thunked.
    
Return Value:

    Ptr to the newly allocated 64 bit SECURITY_TOKEN_PROXY_DATA.

--*/

{

    SECURITY_QUALITY_OF_SERVICE *dst;
        
    if (NULL == src) {
        return NULL;
    }

    if (src->Length == sizeof(SECURITY_ADVANCED_QUALITY_OF_SERVICE)) {
        dst = Wow64AllocateTemp(sizeof(SECURITY_ADVANCED_QUALITY_OF_SERVICE));
        dst->Length = sizeof(SECURITY_ADVANCED_QUALITY_OF_SERVICE);
    } else {
        // if the size isn't right for an advanced QOS struct, assume it's
        // a regular QOS struct.  Many callers don't set the Length field
        // like LsaConnectUntrusted in lsa\security\client\austub.c
       
        dst = Wow64AllocateTemp(sizeof(SECURITY_QUALITY_OF_SERVICE));
        dst->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    }
    dst->ImpersonationLevel = (SECURITY_IMPERSONATION_LEVEL)src->ImpersonationLevel;
    dst->ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE)src->ContextTrackingMode;
    dst->EffectiveOnly = src->EffectiveOnly;

    if (src->Length == sizeof(NT32SECURITY_ADVANCED_QUALITY_OF_SERVICE)) {
        SECURITY_ADVANCED_QUALITY_OF_SERVICE *altdst = (SECURITY_ADVANCED_QUALITY_OF_SERVICE *)dst;
        NT32SECURITY_ADVANCED_QUALITY_OF_SERVICE *altsrc = (NT32SECURITY_ADVANCED_QUALITY_OF_SERVICE *)src;

        altdst->ProxyData = Wow64ShallowThunkAllocSecurityTokenProxyData32TO64(altsrc->ProxyData);
        altdst->AuditData = (PSECURITY_TOKEN_AUDIT_DATA)altsrc->AuditData;
    }

    return (PSECURITY_QUALITY_OF_SERVICE)dst;
    
}

POBJECT_ATTRIBUTES
Wow64ShallowThunkAllocObjectAttributes32TO64_FNC(
    IN NT32OBJECT_ATTRIBUTES *src
    )

/*++

Routine Description:

    This function allocates a new OBJECT_ATTRIBUTES by calling Wow64AllocateTemp and 
    thunks the source to the new structure.
    
    The minimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit OBJECT_ATTRIBUTES to be thunked.
    
Return Value:

    Ptr to the newly allocated 64 bit OBJECT_ATTRIBUTES.

--*/

{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   POBJECT_ATTRIBUTES dst = NULL;

   if (NULL != src) {

       //
       // Validate the object attribute as readable.
       //
       try {

           if(src->Length == sizeof(NT32OBJECT_ATTRIBUTES)) {
               
               dst = Wow64AllocateTemp(sizeof(OBJECT_ATTRIBUTES));

               dst->Length = sizeof(OBJECT_ATTRIBUTES);
               dst->RootDirectory = (HANDLE)src->RootDirectory;
               dst->ObjectName = Wow64ShallowThunkAllocUnicodeString32TO64(src->ObjectName);
               dst->Attributes = src->Attributes;
               dst->SecurityDescriptor = Wow64ShallowThunkAllocSecurityDescriptor32TO64(src->SecurityDescriptor);
               dst->SecurityQualityOfService = Wow64ShallowThunkAllocSecurityQualityOfService32TO64(src->SecurityQualityOfService);
   
               RedirectObjectName(dst);
          } else {

               NtStatus = STATUS_INVALID_PARAMETER;
          }
       } except (EXCEPTION_EXECUTE_HANDLER) {

           dst = NULL;
       }
   }

   if (!NT_SUCCESS (NtStatus)) {
       RtlRaiseStatus (NtStatus);
   }

   return dst;

}

NT32SIZE_T*
Wow64ShallowThunkSIZE_T64TO32(
    OUT NT32SIZE_T* dst,
    IN PSIZE_T src OPTIONAL
    )
/*++

Routine Description:

    This function converts a 64bit SIZE_T to a 32bit SIZE_T. 
    The result is saturated to 0xFFFFFFFF instead of truncating.
    
Arguments:

    src - Supplies the 64 bit SIZE_T to be thunked.
    dst - Receives the 32 bi SIZE_T.
    
Return Value:

    The value of dst.

--*/
{
    if (!src) {
       return (NT32SIZE_T*)src;
    }
    *dst = (NT32SIZE_T)min(*src,0xFFFFFFFF);  //saturate
    return dst;
}

PSIZE_T
Wow64ShallowThunkSIZE_T32TO64(
    OUT PSIZE_T dst,
    IN NT32SIZE_T *src OPTIONAL
    )
/*++

Routine Description:

    This function converts a 32bit SIZE_T to a 64bit SIZE_T. 
    The 64bit value is a zero extension of the 32bit value.
    
Arguments:

    src - Supplies the 64 bit SIZE_T to be thunked.
    dst - Receives the 32 bit SIZE_T.
    
Return Value:

    The value of dst.

--*/
{
   if (!src) {
      return (PSIZE_T)src;
   }

   try {
       *dst = (SIZE_T)*src; //zero extend
   } except (EXCEPTION_EXECUTE_HANDLER) {
       dst = NULL;
   }
   return dst;
}

ULONG 
Wow64ThunkAffinityMask64TO32(
    IN ULONG_PTR Affinity64
    )
/*++

Routine Description:

    This function converts a 64bit AffinityMask into a 32bit mask. 
    
Arguments:

    Affinity64 - Supplies the 64bit affinity mask.
    
Return Value:

    The converted 32bit affinity mask.

--*/
{

    // Create a 32bit affinity mask by ORing the top 32bits with the bottom 32bits.
    // Some care needs to be taken since the following is not always true:
    // Affinity32 == Wow64ThunkAffinityMask32TO64(Wow64ThunkAffinityMask64To32(Affinity32))

    return (ULONG)( (Affinity64 & 0xFFFFFFFF) | ( (Affinity64 & (0xFFFFFFFF << 32) ) >> 32) );
}

ULONG_PTR
Wow64ThunkAffinityMask32TO64(
    IN ULONG Affinity32
    )
/*++

Routine Description:

    This function converts a 32bit AffinityMask into a 64bit mask. 
    
Arguments:

    Affinity32 - Supplies the 32bit affinity mask.
    
Return Value:

    The converted 64bit affinity mask.

--*/
{
    return (ULONG_PTR)Affinity32;
}

VOID
WriteReturnLengthSilent(
    PULONG ReturnLength,
    ULONG Length
    )
/*++

Routine Description:

    Helper that writes back to a 32-bit ReturnLength parameter
    and silently ignores any faults that may occur.
    
Arguments:

    ReturnLength    - pointer to write the 32-bit return length to
    Length          - value to write
    
Return Value:

    None.  ReturnLength may not be updated if an exception occurs.

--*/
{
    if (!ReturnLength) {
        return;
    }
    try {
        *ReturnLength = Length;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        // do nothing
    }
}


VOID
WriteReturnLengthStatus(
    PULONG ReturnLength,
    NTSTATUS *pStatus,
    ULONG Length
    )
/*++

Routine Description:

    Helper that writes back to a 32-bit ReturnLength parameter
    and ignores any faults that may occur.  If a fault occurs,
    the write may not happen, but *pStatus will be updated.
    
Arguments:

    ReturnLength    - pointer to write the 32-bit return length to
    pStatus         - IN OUT pointer to the NTSTATUS
    Length          - value to write
    
Return Value:

    None.  ReturnLength may not be updated if an exception occurs.

--*/
{
    if (!ReturnLength) {
        return;
    }
    try {
        *ReturnLength = Length;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        *pStatus = GetExceptionCode();
    }
}


BOOL 
Wow64IsModule32bitHelper(
    HANDLE ProcessHandle,
    IN ULONG64 DllBase)
/*++

Routine Description:
    This is a helper routine to be called from Wow64IsModule32bit
    
Arguments:

    ProcessHandle   - The handle of the process within which the module is in
    DllBase         - Base Address of the Dll being loaded

Return Value:

    BOOL            - TRUE if Module at Dllbase is 32bit, FALSE otherwise

--*/

{

    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_DOS_HEADER DosHeader;
    BYTE Temp[0x2000];
    SIZE_T Size;
    
    NTSTATUS NtStatus;

    // read in the first 8k of the image
    NtStatus = NtReadVirtualMemory(ProcessHandle,
                                   (PVOID)DllBase,
                                   Temp,
                                   sizeof(Temp),
                                   &Size);
    if (!NT_SUCCESS(NtStatus)) {
		// failed to read
        return TRUE;	// assume the image is 32-bit
    }
    
    DosHeader = (PIMAGE_DOS_HEADER)Temp;
    if (Size < sizeof(Temp) ||
        DosHeader->e_lfanew+sizeof(IMAGE_NT_HEADERS) <= sizeof(Temp)) {
 		// the image is smaller than 8k, so the header is within the first 8k
		// or the image is 8k or larger, and the header is within the first 8k
		NtHeaders = RtlImageNtHeader(Temp);
    } else {
		// the image is 8k or larger, and the header isn't entirely within the first 8k.
		// Read the IMAGE_NT_HEADERS from whereever it is within the image
		if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
			// Not a legal DosHeader
            return TRUE;		// assume the image is 32-bit
		}
		NtStatus = NtReadVirtualMemory(ProcessHandle,
					(PCHAR)DllBase + DosHeader->e_lfanew,
					Temp,
					sizeof(IMAGE_NT_HEADERS),
					&Size);
		if (!NT_SUCCESS(NtStatus) || Size != sizeof(IMAGE_NT_HEADERS)) {
            return TRUE;	// assume the image is 32-bit
		}
		NtHeaders = (IMAGE_NT_HEADERS *)Temp;
		if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
            return TRUE;	// assume the image is 32-bit
		}
    }
    
    // RtlImageNtHeader may return NULL for non-image
    if (!NtHeaders) {
        return TRUE;	// assume the image is 32-bit
    }

    // at this point, NtHeaders points to a valid IMAGE_NT_HEADERS struct
    return (NtHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_I386);
}


    
BOOL
Wow64IsModule32bit(
    IN PCLIENT_ID ClientId,
    IN ULONG64 DllBase)
/*++

Routine Description:
    This function looks at the Image header of the module at 
    DllBase and returns TRUE if the module is 32-bit
    
Arguments:

    ClientId        - Client Id of the faulting thread by the bp
    DllBase         - Base Address of the Dll being loaded

Return Value:

    BOOL            - TRUE if Module at Dllbase is 32bit, FALSE otherwise

--*/
{
    NTSTATUS NtStatus;
    HANDLE ProcessHandle;
    BOOL retVal;
    OBJECT_ATTRIBUTES ObjectAttributes;
    
    
    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

    NtStatus = NtOpenProcess(&ProcessHandle,
                            PROCESS_VM_READ,
                            &ObjectAttributes,
                            ClientId);


    retVal = Wow64IsModule32bitHelper(ProcessHandle, DllBase);
    
    if (NT_SUCCESS(NtStatus)) {
        NtClose(ProcessHandle);
    }

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\debug.c ===
/*++                 

Copyright (c) 1998 Microsoft Corporation

Module Name:

    debug.c

Abstract:
    
    Debugging/Logging helpers

Author:

    11-May-1998 BarryBo    

Revision History:

    05-Oct-1999 SamerA 
    Move logging code to wow64ext.dll

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <stdio.h>
#include <stdlib.h>
#include "wow64p.h"
#include "wow64log.h"

ASSERTNAME;

extern                       WOW64SERVICE_PROFILE_TABLE ptwhnt32;
extern                       WOW64SERVICE_PROFILE_TABLE ptbase;


#if defined(_AMD64_)
WCHAR ProcessorName[]=L"AMD64";
#elif defined(_IA64_)
WCHAR ProcessorName[]=L"IA64";
#else
#error "No Target Architecture"
#endif

PWSTR ImageName=NULL;
WCHAR DefaultImageName[]=L"INameUnknown";
PWSTR ComputerName=NULL;
WCHAR DefaultComputerName[]=L"CNameUnknown";

#if defined(WOW64DOPROFILE)

#define REPORT_FAILURE_INFO_KEY L"\\Software\\Microsoft\\Wow64ReportFailed"
PWSTR ProfileReportDirectory; 
BOOLEAN ProfileReportEnabled;                                                                        
                                                                         
#endif

typedef enum _ENVIRONMENT_VALUES_TABLE_VALUE_TYPE {
   EnvironValueTypeNothing,  // Only used on terminating entry for documentation purposes.
   EnvironValueTypeBoolean,
   EnvironValueTypeUChar,
   EnvironValueTypeUniString // New string is allocated with Wow64AllocateHeap 
} ENVIRONMENT_VALUES_TABLE_VALUE_TYPE, *PENVIRONMENT_VALUES_TABLE_VALUE_TYPE;

typedef struct _ENVIRONMENT_VALUES_TABLE {
   PWSTR ValueName;
   ENVIRONMENT_VALUES_TABLE_VALUE_TYPE ValueType;
   PVOID Value;
   union {
      ULONG_PTR DefaultAssignValue; //Value assigned when union initialized.
      BOOLEAN DefaultBooleanValue;
      UCHAR DefaultUCharValue;
      PWSTR DefaultUniStringValue;
   };
} ENVIRONMENT_VALUES_TABLE, *PENVIRONMENT_VALUES_TABLE;


ENVIRONMENT_VALUES_TABLE EnvironValuesTable[] = {
#if defined(WOW64DOPROFILE)
   {L"WOW64PROFILEREPORTDIRECTORY",
    EnvironValueTypeUniString,
    &ProfileReportDirectory,
    (ULONG_PTR)L"\\\\barrybo\\public\\wow64logs\\profile"
   },
   
   {L"WOW64PROFILEREPORTENABLED",   EnvironValueTypeBoolean, 
    &ProfileReportEnabled,          (ULONG_PTR)FALSE},
#endif
   
   {NULL,                           EnvironValueTypeNothing,
    NULL,                           (ULONG_PTR)0} 
};


//
// Wow64log functions
//
PFNWOW64LOGINITIALIZE pfnWow64LogInitialize;
PFNWOW64LOGSYSTEMSERVICE pfnWow64LogSystemService;
PFNWOW64LOGMESSAGEARGLIST pfnWow64LogMessageArgList;
PFNWOW64LOGTERMINATE pfnWow64LogTerminate;



///////////////////////////////////////////////////////////////////////////////////////
//
//                        Generic utility routines.
//
///////////////////////////////////////////////////////////////////////////////////////

PWSTR
GetEnvironmentVariable(
    IN PWSTR Name,
    IN PWSTR DefaultValue
    )
/*++

Routine Description:

    Retires the value of the environment variable given by Name.

Arguments:

    Name - Supplies the name of the enviroment variable to retieve.
    DefaultValue - Supplies the default value to return on a error.

Return Value:

    Sucess  - The enviroment variable value allocated with Wow64AllocateHeap.
    Faulure - DefaultValue

--*/
{
    UNICODE_STRING UniString;
    UNICODE_STRING ValueName;
    RtlInitUnicodeString(&ValueName, Name);
    RtlZeroMemory(&UniString, sizeof(UNICODE_STRING));

    if ((STATUS_BUFFER_TOO_SMALL == RtlQueryEnvironmentVariable_U(NULL, &ValueName, &UniString)) &&
        //UniString.Buffer is set by the call to RtlQueryEnviromentVariable_U 
        (UniString.Buffer = 
          Wow64AllocateHeap(UniString.MaximumLength = UniString.Length + sizeof(UNICODE_NULL))) &&
        (NT_SUCCESS(RtlQueryEnvironmentVariable_U(NULL, &ValueName, &UniString)))) {

       //Everything worked, return the variable value.
      return UniString.Buffer;

    }
    else {
       // Else something failed, return the default value.
       // Free buffer if necessary.
       if (UniString.Buffer) {
          Wow64FreeHeap(UniString.Buffer);            
       }
       return DefaultValue;
    }
}

VOID
GetEnvironmentVariables(
    IN OUT PENVIRONMENT_VALUES_TABLE ValueTable
    )
/*++

Routine Description:

    Retrieves the value of a table of environment variables and the result is stored in
    the memory pointed to by the pointers in the table.   If an error occures, the default
    value from the table is returned.

Arguments:

    DefaultComputerName - Supplies the name to return on error.

Return Value:

    Success - The computer name allocated with Wow64AllocateHeap.
    Faulure - DefaultComputerName

--*/
{
    PENVIRONMENT_VALUES_TABLE ValueTableWork = ValueTable;

    if (!ValueTableWork) {
       return;
    }

    for(;ValueTableWork->ValueName;ValueTableWork++) {
       
       PWSTR Value;
       PWSTR EndPtr = NULL;
       ULONG NumericValue;

       Value = GetEnvironmentVariable(ValueTableWork->ValueName, NULL);
       
       switch(ValueTableWork->ValueType) {
       case EnvironValueTypeBoolean:
          if(!Value ) {

             *(PBOOLEAN)(ValueTableWork->Value) = ValueTableWork->DefaultBooleanValue;
             break;
          }
          *(PBOOLEAN)(ValueTableWork->Value) = (BOOLEAN)(0==wcscmp(L"0",  Value));
          break;

       case EnvironValueTypeUChar:
          if (!Value || // Could not retrieve the environment variable.
              // Attempt to parse the string, use default on error.
              ((NumericValue = wcstoul(Value,&EndPtr,10)),(EndPtr && (*EndPtr != L'\0')))) {
             *(PUCHAR)(ValueTableWork->Value) = ValueTableWork->DefaultUCharValue;
             break;
          }   
          *(PBOOLEAN)(ValueTableWork->Value) = (UCHAR)NumericValue;
          break;

       case EnvironValueTypeUniString:
          if (!Value) {
             *(PWSTR*)(ValueTableWork->Value) = ValueTableWork->DefaultUniStringValue;
             break;
          }
          // Transfer ownership of value to caller
          *(PWSTR*)(ValueTableWork->Value) = Value;
          Value = NULL;
          break;

       default:
          ASSERT(FALSE);
          break;

       }

       if (Value) {
          Wow64FreeHeap(Value);
       }

    }
}

PWSTR
GetComputerName(
    IN PWSTR DefaultComputerName
    )
/*++

Routine Description:

    Gets the name of this computer.

Arguments:

    DefaultComputerName - Supplies the name to return on error.

Return Value:

    Success - The computer name allocated with Wow64AllocateHeap.
    Faulure - DefaultComputerName

--*/
{
    return GetEnvironmentVariable(L"COMPUTERNAME", DefaultComputerName);
}

PWSTR
GetImageName(
    IN PWSTR DefaultImageName
    )
/*++

Routine Description:

    Gets the name of this image.

Arguments:

    DefaultImageName - Supplies the name to return on error.

Return Value:

    Success - The image name allocated with Wow64AllocateHeap.
    Failure - DefaultImageName 

--*/

{
   
   // Get the image name
   PPEB Peb;
   PWSTR Temp = NULL;
   PUNICODE_STRING ImagePathName;
   PWSTR ReturnValue;
   NTSTATUS Status;
   PVOID LockCookie = NULL;

   Peb = NtCurrentPeb();
   LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
   
   try {
            
      PWCHAR Index;
      ULONG NewLength;

      if (!Peb->ProcessParameters) {
          Temp = DefaultImageName;
          leave;
      }
      ImagePathName = &(Peb->ProcessParameters->ImagePathName);

      if (!ImagePathName->Buffer || !ImagePathName->Length) {   
          Temp = DefaultImageName;
          leave;
      }

      //Strip off the path from the image name.
      //Start just after the last character
      Index = (PWCHAR)((PCHAR)ImagePathName->Buffer + ImagePathName->Length);
      while(Index-- != ImagePathName->Buffer && *Index != '\\');
      Index++;
      NewLength = (ULONG)((ULONG_PTR)((PCHAR)ImagePathName->Buffer + ImagePathName->Length) - (ULONG_PTR)(Index));

      Temp = Wow64AllocateHeap(NewLength+sizeof(UNICODE_NULL));
      if (!Temp) {
          Temp = DefaultImageName;
          __leave;
      }

      RtlCopyMemory(Temp, Index, NewLength);
      Temp[(NewLength / sizeof(WCHAR))] = L'\0';
   } __finally {
       LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
   }

   return Temp;

}

///////////////////////////////////////////////////////////////////////////////////////
//
//                        Generic IO utility routines.
//
///////////////////////////////////////////////////////////////////////////////////////

VOID
FPrintf(
   IN HANDLE Handle,
   IN CHAR *Format,
   ...
   )
/*++

Routine Description:

   The same as the C library function fprintf, except errors are ignored and output is to a 
   NT executive file handle. 

Arguments:

    Handle - Supplies a NT executive file handle to write to.
    Format - Supplies the format specifier.

Return Value:

    None. All errors are ignored.
--*/    
{
   va_list pArg;                                                 
   CHAR Buffer[1024];
   int c;
   IO_STATUS_BLOCK IoStatus;

   va_start(pArg, Format);                                       
   if (-1 == (c = _vsnprintf(Buffer, 1024, Format, pArg))) {
      return;
   }

   NtWriteFile(Handle,                                                
               NULL,                                                  
               NULL,                                                  
               NULL,                                                  
               &IoStatus,                                             
               Buffer,                                                
               c,                     
               NULL,                                                  
               NULL);
}


PWSTR
GenerateLogName(
   IN PWSTR DirectoryName
   )
/*++

Routine Description:

    Create a log file name based on computer information.  

Arguments:

    DirectoryName - Supplies the directory that the file should be created in. 
    
Return Value:

    Success - A unicode string containing the full file name.  String should be freeed with
              Wow64FreeHeap.
    Failure - NULL

--*/
{
   ULONG MaxSize = 0xFFFFFFFF / 2;
   ULONG BufferSize = 0xFF;
   PWSTR Buffer = NULL;
   int i;

   while(BufferSize <= MaxSize) {
      
      Buffer = Wow64AllocateHeap(BufferSize);
      if (!Buffer) {
         return Buffer; // Exit on allocation failure
      }
   
      // Compute the name of the error log file.
      i = _snwprintf(Buffer, BufferSize / sizeof(WCHAR),
                     L"%s\\%u-%s-%s-%s-%I64u.log", DirectoryName, 
                     (ULONG)VER_PRODUCTBUILD, ProcessorName, ComputerName, 
                     ImageName, NtCurrentTeb()->RealClientId.UniqueProcess);

      if (-1 == i) {
         Wow64FreeHeap(Buffer);
         BufferSize <<= 1;
      }
      else {
         return Buffer;
      }
   }

   // Hit upper buffer bound, probably an error. Exit.
   return NULL;

}

///////////////////////////////////////////////////////////////////////////////////////
//
//                        Logging and assert routines.
//
///////////////////////////////////////////////////////////////////////////////////////

void
LogOut(
   IN UCHAR LogLevel,
   IN char *pLogOut
   )
/*++

Routine Description:

    Generic helper routine which outputs the string to the appropriate
    destination(s).

Arguments:

    pLogOut - string to output

Return Value:

    None.

--*/
{
    // Send the output to the debugger, if log flag is ERRORLOG.
    if (LogLevel == ERRORLOG)
    {
       DbgPrint(pLogOut);
    }
}

WOW64DLLAPI
VOID
Wow64Assert(
    IN CONST PSZ exp,
    OPTIONAL IN CONST PSZ msg,
    IN CONST PSZ mod,
    IN LONG line
    )
/*++

Routine Description:

    Function called in the event that an assertion failed.  This is always
    exported from wow64.dll, so a checked thunk DLL can coexist with a retail
    wow64.dll.

Arguments:

    exp     - text representation of the expression from the assert
    msg     - OPTIONAL message to display
    mod     - text of the source filename
    line    - line number within 'mod'

Return Value:

    None.

--*/
{
#if DBG
    if (msg) {
        LOGPRINT((ERRORLOG, "WOW64 ASSERTION FAILED:\r\n  %s\r\n%s\r\nFile: %s Line %d\r\n", msg, exp, mod, line));
    } else {
        LOGPRINT((ERRORLOG, "WOW64 ASSERTION FAILED:\r\n  %s\r\nFile: %s Line %d\r\n", exp, mod, line));
    }

    if (NtCurrentPeb()->BeingDebugged) {
        DbgBreakPoint();
    }
#endif
}


void
WOW64DLLAPI
Wow64LogPrint(
   UCHAR LogLevel,
   char *format,
   ...
   )
/*++

Routine Description:

    WOW64 logging mechanism.  If LogLevel > ModuleLogLevel then print the
    message, else do nothing.

Arguments:

    LogLevel    - requested verbosity level
    format      - printf-style format string
    ...         - printf-style args

Return Value:

    None.

--*/
{
    int i, Len;
    va_list pArg;
    char *pch;
    char Buffer[1024];

    //
    // Call wow64log DLL if loaded
    //
    if (pfnWow64LogMessageArgList) 
    {
        va_start(pArg, format);
        (*pfnWow64LogMessageArgList)(LogLevel, format, pArg);
        va_end(pArg);
        return;
    }

    pch = Buffer;
    Len = sizeof(Buffer) - 1;
    i = _snprintf(pch, Len, "%8.8X:%8.8X ",
                  PtrToUlong(NtCurrentTeb()->ClientId.UniqueProcess), 
                  PtrToUlong(NtCurrentTeb()->ClientId.UniqueThread));
   
    ASSERT((PVOID)PtrToUlong(NtCurrentTeb()->ClientId.UniqueProcess) == NtCurrentTeb()->ClientId.UniqueProcess);
    ASSERT((PVOID)PtrToUlong(NtCurrentTeb()->ClientId.UniqueThread) == NtCurrentTeb()->ClientId.UniqueThread);

    if (i == -1) {
        i = sizeof(Buffer) - 1;
        Buffer[i] = '\0';
    } else if (i < 0) {
        return;
    }

    Len -= i;
    pch += i;

    va_start(pArg, format);
    i = _vsnprintf(pch, Len, format, pArg);
    // Force null termination in case the call fails.  It may return
    // sizeof(buffer) and not null-terminate!
    Buffer[sizeof(Buffer)-1] = '\0';
    LogOut(LogLevel, Buffer);
}

///////////////////////////////////////////////////////////////////////////////////////
//
//                        Profile report routines.
//
///////////////////////////////////////////////////////////////////////////////////////

#if defined(WOW64DOPROFILE)

VOID 
pPrintProfileTable(
    IN HANDLE ReportHandle,
    IN PWOW64SERVICE_PROFILE_TABLE ProfileTable,
    IN OUT PSIZE_T ApiCount,
    IN OUT PSIZE_T HitApiCount,
    IN ULONG Level
    )
/*++

Routine Description:

    Helper function for GenerateProfileReport.  Sets indentation level and calls pPrintProfileTable.     

Arguments:

    ReportHandle - Supplies file to write profile table.
    ProfileTable - Supplies the profile table to print. 
    ApiCount     - Supplies counter to increment for each API.
    HitApiCount  - Supplies counter to increment for each hit API.
    
Return Value:

    None. Noop on error.

--*/
{

    PCHAR PreFix;
    PWOW64SERVICE_PROFILE_TABLE_ELEMENT ProfileElement;
    SIZE_T Count;
    SIZE_T LocalApiCount=0, LocalHitApiCount=0;

    // Allocate the text to precede the api.
    PreFix = _alloca((sizeof(CHAR) * Level) + sizeof(CHAR));
    RtlFillMemory(PreFix, Level, '\t');
    PreFix[Level] = '\0';

    if (ProfileTable->TableName && ProfileTable->FriendlyTableName) {
       FPrintf(ReportHandle, "%sBEGIN_PROFILE_TABLE: NAME: %S FRIENDLYNAME: %S\n",
               PreFix, ProfileTable->TableName, ProfileTable->FriendlyTableName);
    
    } else if (ProfileTable->TableName && !ProfileTable->FriendlyTableName) {
       FPrintf(ReportHandle, "%sBEGIN_PROFILE_TABLE: NAME: %S\n",
               PreFix, ProfileTable->TableName);
    
    } else if (!ProfileTable->TableName && ProfileTable->FriendlyTableName) {  
       FPrintf(ReportHandle, "%sBEGIN_PROFILE_TABLE: FRIENDLYNAME: %S\n",
               PreFix, ProfileTable->FriendlyTableName);
    }

    for(Count = ProfileTable->NumberProfileTableElements, ProfileElement = ProfileTable->ProfileTableElements;
        Count; ProfileElement++, Count--) {
       if (ProfileElement->ApiEnabled) {
          FPrintf(ReportHandle, "%s%S %I64u\n", PreFix, ProfileElement->ApiName, 
                  ProfileElement->HitCount);
          if (ProfileElement->SubTable) {
             // If the API has sub APIs, use the stats from those APIs.
             pPrintProfileTable(ReportHandle, ProfileElement->SubTable, &LocalApiCount,
                                &LocalHitApiCount, Level+1);
          }
          else {
             // If the API does not have any sub APIs, count the API in the
             // API stats.
             LocalApiCount++;
             if (ProfileElement->HitCount) {
                LocalHitApiCount++;
             }
          }                  
       }
    }

    if (ProfileTable->TableName || ProfileTable->FriendlyTableName) {
       FPrintf(ReportHandle, "%sEND_PROFILE_TABLE: HitApiCount %I64u ApiCount %I64u\n",
               PreFix, LocalHitApiCount, LocalApiCount);
    }
    if (0 == Level) {
        FPrintf(ReportHandle, "\n");
    }

    *HitApiCount += LocalHitApiCount;
    *ApiCount += LocalApiCount;
}

VOID 
PrintProfileTable(
   IN HANDLE ReportHandle,
   IN PWOW64SERVICE_PROFILE_TABLE ProfileTable,
   IN OUT PSIZE_T ApiCount,
   IN OUT PSIZE_T HitApiCount
   )
/*++

Routine Description:

    Helper function for GenerateProfileReport.  Recursive function that prints out a profile table
    report.     

Arguments:

    ReportHandle - Supplies file to write profile table.
    ProfileTable - Supplies the profile table to print. 
    ApiCount     - Supplies counter to increment for each API.
    HitApiCount  - Supplies counter to increment for each hit API.
    
Return Value:

    None. Noop on error.

--*/
{
   pPrintProfileTable(ReportHandle, ProfileTable, ApiCount, HitApiCount, 0);
}

NTSTATUS
GenerateProfileReport(
    VOID
    )
/*++

Routine Description:

    Outputs a profile report to a hard-coded share name.  This report lists machine and program
    information in addition to hit counts for the thunked APIs.  

Arguments:

    None.
    
Return Value:

    None.

--*/
{
   PWSTR ReportFileName = NULL;
   HANDLE ReportHandle;
   UNICODE_STRING NtFileName;
   OBJECT_ATTRIBUTES ObjectAttributes;
   IO_STATUS_BLOCK IoStatus;
   NTSTATUS Status;
   
   SIZE_T GlobalApiCount = 0;
   SIZE_T GlobalHitApiCount = 0;

   // Compute full name of report file.
   ReportFileName = GenerateLogName(ProfileReportDirectory);
   if (!ReportFileName) {
      return STATUS_NO_MEMORY;
   }

   if(!RtlDosPathNameToNtPathName_U(ReportFileName,&NtFileName,NULL,NULL)) {
      Wow64FreeHeap(ReportFileName);
      return STATUS_UNSUCCESSFUL;
   }
   Wow64FreeHeap(ReportFileName);

   InitializeObjectAttributes(&ObjectAttributes,
                              &NtFileName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

   Status = NtCreateFile(
            &ReportHandle,
            SYNCHRONIZE | GENERIC_WRITE,
            &ObjectAttributes,
            &IoStatus,
            NULL,
            0,
            FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            FILE_OVERWRITE_IF,
            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );
    RtlFreeHeap(RtlProcessHeap(),0,NtFileName.Buffer);

    if(!NT_SUCCESS(Status)) {
       return Status;
    }

    ///////////////////////////////////////////////////
    // Generate the actual report here.  Note that no error
    // checking is done.  If an error occures, the other print 
    // functions should also fail.
    ///////////////////////////////////////////////////
    
    // Print header
    FPrintf(ReportHandle, "TITLE:           Wow64 function profile report.\n");
    FPrintf(ReportHandle, "BUILD_NUMBER:    %u\n", (ULONG)VER_PRODUCTBUILD);
    FPrintf(ReportHandle, "PROCESSOR:       %S\n", ProcessorName);
    FPrintf(ReportHandle, "COMPUER_NAME:    %S\n", ComputerName);
    FPrintf(ReportHandle, "IMAGE_NAME:      %S\n", ImageName);
    FPrintf(ReportHandle, "PROCESS_ID:      %I64u\n", NtCurrentTeb()->RealClientId.UniqueProcess);
    FPrintf(ReportHandle, "\n");

    // Print Section Reports
    {
        PWOW64SERVICE_PROFILE_TABLE ReportList[6];
        PWOW64SERVICE_PROFILE_TABLE *ReportListElement = ReportList;
        UNICODE_STRING UnicodeName;
        ANSI_STRING AnsiName;
        PVOID DllHandle;
        int i;

        ReportList[0] = &ptwhnt32;
        ReportList[1] = &ptbase;

        RtlInitUnicodeString(&UnicodeName, L"wow64win.dll");
        Status = LdrGetDllHandle(NULL, NULL, &UnicodeName, &DllHandle);
        if (NT_SUCCESS(Status)) {
            RtlInitAnsiString(&AnsiName, "ptcon");
            if (!NT_SUCCESS(LdrGetProcedureAddress(DllHandle, &AnsiName, 0, &ReportList[2]))) {
                ReportList[2] = NULL;
            }
            RtlInitAnsiString(&AnsiName, "ptwhwin32");
            if (!NT_SUCCESS(LdrGetProcedureAddress(DllHandle, &AnsiName, 0, &ReportList[3]))) {
                ReportList[3] = NULL;
            }
            RtlInitAnsiString(&AnsiName, "ptcbc");
            if (!NT_SUCCESS(LdrGetProcedureAddress(DllHandle, &AnsiName, 0, &ReportList[4]))) {
                ReportList[4] = NULL;
            }
            RtlInitAnsiString(&AnsiName, "ptmsgthnk");
            if (!NT_SUCCESS(LdrGetProcedureAddress(DllHandle, &AnsiName, 0, &ReportList[5]))) {
                ReportList[5] = NULL;
            }
        }

        for(i = 0;i <sizeof(ReportList)/sizeof(ReportList[0]);i++,ReportListElement++) {
           
            PWOW64SERVICE_PROFILE_TABLE ProfileTable = *ReportListElement;
           
            if (ProfileTable) {
               PrintProfileTable(ReportHandle, ProfileTable, &GlobalApiCount, &GlobalHitApiCount);
            }
        }


    }

    // Print Footer
    FPrintf(ReportHandle, "END_REPORT: GlobalHitApiCount %I64u GlobalApiCount %I64u\n",
            GlobalHitApiCount, GlobalApiCount);
    FPrintf(ReportHandle, "\n");

    NtClose(ReportHandle);
    return STATUS_SUCCESS;
}

NTSTATUS
GetReportKeyName(
    PUNICODE_STRING pStr
    )
/*++

Routine Description:

    Create the UNICODE_STRING for the registry key used to determine
    if WOW64 should write the report or not.

Arguments:

    pStr - OUT string to write to.  It is under HKCU.
    
Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS st;
    UNICODE_STRING User;

    st = RtlFormatCurrentUserKeyPath(&User);
    if (!NT_SUCCESS(st)) {
        return st;
    }
    pStr->MaximumLength = User.Length + sizeof(REPORT_FAILURE_INFO_KEY);
    pStr->Buffer = Wow64AllocateHeap(pStr->MaximumLength);
    if (!pStr->Buffer) {
        return STATUS_NO_MEMORY;
    }
    pStr->Length = User.Length;
    RtlMoveMemory(pStr->Buffer, User.Buffer, User.Length);
    RtlFreeUnicodeString(&User);
    RtlInitUnicodeString(&User, REPORT_FAILURE_INFO_KEY);
    st = RtlAppendUnicodeStringToString(pStr, &User);
    if (!NT_SUCCESS(st)) {
        return st;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
HasReportFailedRecently(
    VOID
    )
/*++

Routine Description:

    Determine if the report has failed to be written since the user
    last rebooted the machine.  A volatile key under HKCU is used
    to record failure.

Arguments:

    None.
    
Return Value:

    TRUE if the report write has failed in the past, FALSE if not.

--*/
{
    NTSTATUS st;
    OBJECT_ATTRIBUTES Obja;
    ULONG Attributes;
    UNICODE_STRING KeyName;
    BOOLEAN b;
    HANDLE hKey;

    st = GetReportKeyName(&KeyName);
    if (!NT_SUCCESS(st)) {
        // Problem getting the key name - assume report has not failed recently
        return FALSE;
    }
    Attributes = OBJ_CASE_INSENSITIVE;
    InitializeObjectAttributes(&Obja, &KeyName, Attributes, NULL, NULL);
    st = NtOpenKey(&hKey, KEY_READ, &Obja);
    if (!NT_SUCCESS(st)) {
        // couldn't open the key - OK to write the report
        b = FALSE;
    } else {
        // oops - the key is there - don't try to write the report
        b = TRUE;
        NtClose(hKey);
    }

    Wow64FreeHeap(KeyName.Buffer);
    return b;
}

VOID
RecordReportHasFailed(
    VOID
    )
/*++

Routine Description:

    Record the fact that the report has failed to be written.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    NTSTATUS st;
    OBJECT_ATTRIBUTES Obja;
    ULONG Attributes;
    HANDLE hKey;
    ULONG dwDisposition;
    UNICODE_STRING KeyName;

    st = GetReportKeyName(&KeyName);
    if (!NT_SUCCESS(st)) {
        return;
    }
    Attributes = OBJ_CASE_INSENSITIVE;
    InitializeObjectAttributes(&Obja, &KeyName, Attributes, NULL, NULL);
    st = NtCreateKey(&hKey,
                     KEY_WRITE,
                     &Obja,
                     0,
                     NULL,
                     REG_OPTION_VOLATILE,
                     &dwDisposition);
    if (!NT_SUCCESS(st)) {
        // couldn't create the key.  Something bad happened.
    } else {
        NtClose(hKey);
    }
    Wow64FreeHeap(KeyName.Buffer);
}

#endif

///////////////////////////////////////////////////////////////////////////////////////
//
//                        Startup and shutdown routines.
//
///////////////////////////////////////////////////////////////////////////////////////


NTSTATUS
Wow64pLoadLogDll(
    VOID)
{
    NTSTATUS NtStatus;
    UNICODE_STRING Wow64LogDllName;
    ANSI_STRING ProcName;
    PVOID Wow64LogDllBase = NULL;


    RtlInitUnicodeString(&Wow64LogDllName, L"wow64log.dll");
    NtStatus = LdrLoadDll(NULL, NULL, &Wow64LogDllName, &Wow64LogDllBase);
    if (NT_SUCCESS(NtStatus)) 
    {

        //
        // Get the entry points
        //
        RtlInitAnsiString(&ProcName, "Wow64LogInitialize");
        NtStatus = LdrGetProcedureAddress(Wow64LogDllBase,
                                          &ProcName,
                                          0,
                                          (PVOID *) &pfnWow64LogInitialize);

        if (NT_SUCCESS(NtStatus)) 
        {
            RtlInitAnsiString(&ProcName, "Wow64LogSystemService");
            NtStatus = LdrGetProcedureAddress(Wow64LogDllBase,
                                              &ProcName,
                                              0,
                                              (PVOID *) &pfnWow64LogSystemService);
            if (!NT_SUCCESS(NtStatus)) 
            {
                goto RetStatus;
            }

            RtlInitAnsiString(&ProcName, "Wow64LogMessageArgList");
            NtStatus = LdrGetProcedureAddress(Wow64LogDllBase,
                                              &ProcName,
                                              0,
                                              (PVOID *) &pfnWow64LogMessageArgList);
            if (!NT_SUCCESS(NtStatus)) 
            {
                goto RetStatus;
            }

            RtlInitAnsiString(&ProcName, "Wow64LogTerminate");
            NtStatus = LdrGetProcedureAddress(Wow64LogDllBase,
                                              &ProcName,
                                              0,
                                              (PVOID *) &pfnWow64LogTerminate);

            //
            // If all is well, then let's initialize
            //
            if (NT_SUCCESS(NtStatus)) 
            {
                NtStatus = (*pfnWow64LogInitialize)();
            }
        }
    }

RetStatus:
    
    if (!NT_SUCCESS(NtStatus))
    {
        pfnWow64LogInitialize =  NULL;
        pfnWow64LogSystemService = NULL;
        pfnWow64LogMessageArgList = NULL;
        pfnWow64LogTerminate = NULL;

        if (Wow64LogDllBase) 
        {
            LdrUnloadDll(Wow64LogDllBase);
        }
    }

    return NtStatus;
}


VOID
InitializeDebug(
    VOID
    )

/*++

Routine Description:

    Initializes the debug system of wow64.

Arguments:

    None.
    
Return Value:

    None.

--*/

{
   ///////////////////////////////////////////
   // Collect information about this computer.
   ///////////////////////////////////////////
   
   ComputerName = GetComputerName(DefaultComputerName);   
   ImageName = GetImageName(DefaultImageName);
   
   GetEnvironmentVariables(EnvironValuesTable);

   Wow64pLoadLogDll();
}

VOID ShutdownDebug(
     VOID
     )
/*++

Routine Description:

    Shutdown the debug system of wow64.

Arguments:

    None.
    
Return Value:

    None.

--*/
{

#if defined(WOW64DOPROFILE)
    NTSTATUS st;

    if (ProfileReportEnabled) {
        if (!HasReportFailedRecently()) {
            st = GenerateProfileReport();
            if (!NT_SUCCESS(st)) {
                RecordReportHasFailed();
            }
        }
    }
#endif

    if (pfnWow64LogTerminate)
    {
        (*pfnWow64LogTerminate)();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\raiseex.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    raiseex.c

Abstract:

    This module contains the routines necesary to allow a software CPU
    to simulate software interrupts, and raise exceptions.

Author:

    22-Jan-2000    SamerA

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;



#define NUM_IDTSTATUS (sizeof(InterruptToNtStatus)/sizeof(NTSTATUS))

const NTSTATUS InterruptToNtStatus[] = 
{
   {STATUS_INTEGER_DIVIDE_BY_ZERO},   // 0
   {STATUS_WX86_SINGLE_STEP},         // 1 trace
   {STATUS_ACCESS_VIOLATION},         // 2 EXCEPTION_NMI BugCheck
   {STATUS_WX86_BREAKPOINT},          // 3 p1 BREAKPOINT_BREAK,
   {STATUS_INTEGER_OVERFLOW},         // 4
   {STATUS_ARRAY_BOUNDS_EXCEEDED},    // 5
   {STATUS_ILLEGAL_INSTRUCTION},      // 6 ? STATUS_INVALID_LOCK_SEQUENCE
   {STATUS_ACCESS_VIOLATION},         // 7 EXCEPTION_NPX_NOT_AVAILABLE ??
   {STATUS_ACCESS_VIOLATION},         // 8 EXCEPTION_DOUBLE_FAULT BugCheck
   {STATUS_ACCESS_VIOLATION},         // 9 EXCEPTION_NPX_OVERRUN BugCheck
   {STATUS_ACCESS_VIOLATION},         // a EXCEPTION_INVALID_TSS BugCheck
   {STATUS_ACCESS_VIOLATION},         // b Segment Not Present
   {STATUS_ACCESS_VIOLATION},         // c Stack Segment fault
   {STATUS_ACCESS_VIOLATION},         // d GP fault,
   {STATUS_ACCESS_VIOLATION},         // e Page Fault
   {STATUS_ACCESS_VIOLATION},         // f EXCEPTION_RESERVED BugCheck
   {STATUS_ACCESS_VIOLATION},         // 10 Coprocessor Error -> delayed via Trap07
   {STATUS_DATATYPE_MISALIGNMENT}     // 11 Alignment Fault
                                      //    p1= EXCEPT_LIMIT_ACCESS, p2 = Esp

   // 12 EXCEPTION_RESERVED_TRAP
   // 13 EXCEPTION_RESERVED_TRAP
   // 14 EXCEPTION_RESERVED_TRAP
   // 15 EXCEPTION_RESERVED_TRAP
   // 16 EXCEPTION_RESERVED_TRAP
   // 17 EXCEPTION_RESERVED_TRAP
   // 18 EXCEPTION_RESERVED_TRAP
   // 19 EXCEPTION_RESERVED_TRAP
   // 1A EXCEPTION_RESERVED_TRAP
   // 1B EXCEPTION_RESERVED_TRAP
   // 1C EXCEPTION_RESERVED_TRAP
   // 1D EXCEPTION_RESERVED_TRAP
   // 1E EXCEPTION_RESERVED_TRAP
   // 1F EXCEPTION_RESERVED_TRAP (APIC)

   // 21 reserved for WOW - Dos

   // 2A _KiGetTickCount
   // 2B _KiSetHighWaitLowThread
   // 2C _KiSetLowWaitHighThread
   // 2D _KiDebugService
   // 2E _KiSystemService
   // 2F _KiTrap0F
};


WOW64DLLAPI
NTSTATUS
Wow64RaiseException(
    IN DWORD InterruptNumber,
    IN OUT PEXCEPTION_RECORD ExceptionRecord)
/*++

Routine Description:

    This routine either simulates an x86 software interrupt, or generates a
    software exception. It's meant for CPU implementations to call this routine
    to raise an exception.
    
    NOTE : If this routine is called to raise a software exception (i.e.
           InterruptNumber is -1) and ExceptionRecord->ExceptionAddress is
           equal to NULL, then the return address of Wow64NotifyDebuggerHelper
           is used for that, otherwise the specified value is used.

Arguments:

    InterruptNumber   - If this parameter is -1, then the caller has supplied
                        an exception record to raise the exception for. If it
                        isn't -1, then a software exception is generated to simulate
                        the passed interrupt number
    ExceptionRecord   - Exception record to use if the InterruptNumber is -1                   
    
Return Value:

    The function returns to the caller if the exception has been handled.

--*/
{
    NTSTATUS NtStatus;
    CONTEXT32 Context32;
    EXCEPTION_RECORD ExceptionRecordLocal;
    PVOID CpuSimulationFlag;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    PBYTE Fir = NULL;

    if (InterruptNumber != -1)
    {
        RtlZeroMemory(&ExceptionRecordLocal, sizeof(ExceptionRecordLocal));
        ExceptionRecord = &ExceptionRecordLocal;

        if (InterruptNumber < NUM_IDTSTATUS)
        {
            NtStatus = InterruptToNtStatus[InterruptNumber];
        }
        else 
        {
            NtStatus = STATUS_ACCESS_VIOLATION;
        }

        ExceptionRecord->ExceptionCode = NtStatus;

        Context32.ContextFlags = (CONTEXT32_CONTROL | CONTEXT32_INTEGER);
        
        if (NT_SUCCESS(CpuGetContext(NtCurrentThread(),
                                     NtCurrentProcess(),
                                     NULL,
                                     &Context32)))
        {
            Fir = (PBYTE)Context32.Eip;
        }

        switch (NtStatus)
        {
        case STATUS_ACCESS_VIOLATION:
        case STATUS_DATATYPE_MISALIGNMENT:
            ExceptionRecord->NumberParameters        = 2;
            ExceptionRecord->ExceptionInformation[0] = 0;
            ExceptionRecord->ExceptionInformation[1] = (ULONG_PTR)Fir;
            break;

        case STATUS_WX86_BREAKPOINT:
            ExceptionRecord->ExceptionAddress        = (Fir-1);
            ExceptionRecord->NumberParameters        = 3;
            ExceptionRecord->ExceptionInformation[0] = 0;
            ExceptionRecord->ExceptionInformation[1] = Context32.Ecx;
            ExceptionRecord->ExceptionInformation[2] = Context32.Edx;
            break;

        default:
            ExceptionRecord->NumberParameters = 0;
            break;
        }
    }
    else
    {
        if (!ARGUMENT_PRESENT(ExceptionRecord))
        {
            ReturnStatus = STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Raise the exception
    //
    if (NT_SUCCESS(ReturnStatus))
    {
        //
        // The CPU has definitely left code simulation
        //
        CpuSimulationFlag = Wow64TlsGetValue(WOW64_TLS_INCPUSIMULATION);
        Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, FALSE);

        Wow64NotifyDebuggerHelper(ExceptionRecord,
                            TRUE);
        
        Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, CpuSimulationFlag);
    }
    
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\init.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    init.c

Abstract:

    Process and thread init code for wow64.dll

Author:

    12-May-1998 BarryBo

Revision History:

    08-Mar-2001 SamerA   Initialize the SystemEmulation environment using
                         the system serivces.

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbasep.h>
#include "wow64p.h"
#include "wow64cpu.h"
#include "nt32.h"
#include "thnkhlpr.h"
#include "regremap.h"

ASSERTNAME;


extern                       WOW64SERVICE_TABLE_DESCRIPTOR sdwhnt32;
extern __declspec(dllimport) WOW64SERVICE_TABLE_DESCRIPTOR sdwhwin32;
extern __declspec(dllimport) WOW64SERVICE_TABLE_DESCRIPTOR sdwhcon;
extern                       WOW64SERVICE_TABLE_DESCRIPTOR sdwhbase;
extern __declspec(dllimport) const PVOID Win32kCallbackTable[];   // in wow64win's ntcbc.c


ULONG Ntdll32LoaderInitRoutine;
ULONG Ntdll32KiUserExceptionDispatcher;
ULONG Ntdll32KiUserApcDispatcher;
ULONG Ntdll32KiUserCallbackDispatcher;
ULONG Ntdll32KiRaiseUserExceptionDispatcher;

PPEB32 Peb32;       // Pointer to 32-bit PEB for this process
ULONG NtDll32Base;  // Base address for 32-bit ntdll.dll

WOW64_SYSTEM_INFORMATION RealSysInfo;
WOW64_SYSTEM_INFORMATION EmulatedSysInfo;

WCHAR NtSystem32PathBuffer[264];
WCHAR NtWindowsImePathBuffer[264];
UNICODE_STRING NtSystem32Path;
UNICODE_STRING NtWindowsImePath;
WCHAR RegeditPathBuffer[264];
UNICODE_STRING RegeditPath;




NTSTATUS
Map64BitDlls(
    VOID
    );

NTSTATUS
LookupEntryPoint(
    IN ULONG DllBase,
    IN  PSZ NameOfEntryPoint,
    OUT ULONG *AddressOfEntryPoint,
    IN BOOLEAN DllIs64bit
    );

USHORT
NameToOrdinal (
    IN  PSZ NameOfEntryPoint,
    IN ULONG DllBase,
    IN ULONG NumberOfNames,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    );

NTSTATUS
MapNtdll32(
    OUT ULONG *pNtDllBase
    );

PWSTR
GetImageName (
    IN PWSTR DefaultImageName
    );

typedef DWORD (WINAPI *PPROCESS_START_ROUTINE)(
    VOID
    );

NTSTATUS
Wow64InitializeEmulatedSystemInformation(
    VOID
    )

/*++

Routine Description:
  
    This function initializes the global variable EmulatedSysInfo with the 
    system information for the emulated system.
  
Arguments:

    None.

--*/

{
    NTSTATUS NtStatus;

    NtStatus = NtQuerySystemInformation (SystemEmulationBasicInformation,
                                         &EmulatedSysInfo.BasicInfo,
                                         sizeof (EmulatedSysInfo.BasicInfo),
                                         NULL);

    if (NT_SUCCESS (NtStatus)) {

        NtStatus = NtQuerySystemInformation (SystemEmulationProcessorInformation,
                                             &EmulatedSysInfo.ProcessorInfo,
                                             sizeof (EmulatedSysInfo.ProcessorInfo),
                                             NULL);

        if (NT_SUCCESS (NtStatus)) {
            EmulatedSysInfo.RangeInfo =  0x80000000;
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64InitializeSystemInformation(
    VOID
    )
/*++

Routine Description:

    This function retrieves the status system information from
    the system and initializes the global variable RealSysInfo.

Arguments:

    None.

Return Value:

    Status.

--*/
{
    NTSTATUS Status;

    Status = NtQuerySystemInformation(SystemBasicInformation,
                                      &RealSysInfo.BasicInfo,
                                      sizeof(SYSTEM_BASIC_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status)) {

        Status = NtQuerySystemInformation(SystemProcessorInformation,
                                          &RealSysInfo.ProcessorInfo,
                                          sizeof(SYSTEM_PROCESSOR_INFORMATION),
                                          NULL);

        if (NT_SUCCESS(Status)) {
         
            Status = NtQuerySystemInformation(SystemRangeStartInformation,
                                              &RealSysInfo.RangeInfo,
                                              sizeof(ULONG_PTR),
                                              NULL);
        }
    }

    return Status;
}

VOID
Wow64pCopyString(
    PCHAR *p,
    PUNICODE_STRING32 str32,
    PUNICODE_STRING str64
    )
{
    *p = (PCHAR)ROUND_UP((SIZE_T)*p, sizeof(ULONG));

    str32->Length = str64->Length;
    str32->MaximumLength = str64->MaximumLength;
    RtlCopyMemory(*p, str64->Buffer, str64->MaximumLength);
    str32->Buffer = PtrToUlong(*p);

    *p += str64->MaximumLength;
}


ENVIRONMENT_THUNK_TABLE EnvironmentVariableTable[] = 
{
    { 
        L"ProgramFiles",            // Native environment variable to thunk
        L"ProgramFiles(x86)",       // Value for the thunked environment variable
        L"ProgramW6432",            // New environment variable to hold the original value being thunked
        TRUE                        // Treat the first value as an environment variable
    },
    { 
        L"CommonProgramFiles", 
        L"CommonProgramFiles(x86)", 
        L"CommonProgramW6432", 
        TRUE 
    },

    { 
        L"PROCESSOR_ARCHITECTURE",
        L"x86", 
        L"PROCESSOR_ARCHITEW6432",
        FALSE 
    },
};


NTSTATUS
Wow64pThunkEnvironmentVariables(
    VOID
    )

/*++

Routine Description:

    This function will thunk the environment variables pointed out by the EnvironmentVariableTable
    to the ones used on an x86 system, and will save the original values. The original
    values are restored when the 

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/

{
    UNICODE_STRING Name;
    UNICODE_STRING Value, Value2;
    WCHAR Buffer [ 128 ];
    WCHAR Buffer2 [ 128 ];
    NTSTATUS NtStatus;
    ULONG i;

    
    i = 0;

    while (i < (sizeof(EnvironmentVariableTable) / sizeof(EnvironmentVariableTable[0])))
    {

        //
        // If a fake name already exists, then skip this one.
        //

        RtlInitUnicodeString (&Name, EnvironmentVariableTable[i].FakeName);

        Value.Length = 0;
        Value.MaximumLength = sizeof (Buffer);
        Value.Buffer = Buffer;

        NtStatus = RtlQueryEnvironmentVariable_U (NULL,
                                                  &Name,
                                                  &Value
                                                  );

        if (!NT_SUCCESS (NtStatus)) {

            //
            // Retreive the name of the ProgramFiles(x86) environment variable
            //

            if (EnvironmentVariableTable[i].IsX86EnvironmentVar == TRUE) {

                RtlInitUnicodeString (&Name, EnvironmentVariableTable[i].X86);

                Value.Length = 0;
                Value.MaximumLength = sizeof (Buffer);
                Value.Buffer = Buffer;


                NtStatus = RtlQueryEnvironmentVariable_U (NULL,
                                                          &Name,
                                                          &Value
                                                          );
            } else {

                RtlInitUnicodeString(&Value, EnvironmentVariableTable[i].X86);

                NtStatus = STATUS_SUCCESS;
            }

            if (NT_SUCCESS (NtStatus))
            {

                //
                // Save the original ProgramFiles environment variable
                //
            
                RtlInitUnicodeString (&Name, EnvironmentVariableTable[i].Native);

                Value2.Length = 0;
                Value2.MaximumLength = sizeof (Buffer2);
                Value2.Buffer = Buffer2;

                NtStatus = RtlQueryEnvironmentVariable_U (NULL,
                                                          &Name,
                                                          &Value2                                                  
                                                          );

                if (NT_SUCCESS (NtStatus))
                {
                    //
                    // Set the ProgramFiles environment variable to the x86 one
                    //

                    NtStatus = RtlSetEnvironmentVariable (NULL,
                                                          &Name,
                                                          &Value
                                                          );

                    if (NT_SUCCESS (NtStatus))
                    {

                        RtlInitUnicodeString (&Name, EnvironmentVariableTable[i].FakeName);

                        NtStatus = RtlSetEnvironmentVariable (NULL,
                                                              &Name,
                                                              &Value2
                                                              );
                    }
                }
            }
        }
        
        i++;
    }

    LOGPRINT((TRACELOG, "Result of thunking programfiles environment variables - %lx\n", NtStatus));

    return NtStatus;
}


NTSTATUS
Wow64pThunkProcessParameters(
    PPEB32 Peb32,
    PPEB Peb
    )
/*++

Routine Description:

    This function copies the process parameters from the 64bit peb to the 32bit peb.

Arguments:

    Peb32  - Supplies the pointer to the 32bit peb that will recieve the process parameters.
    Peb    - Supplies the pointer to the 64bit peb that will supply the process parameters.

Return Value:

    Status.

--*/
{

    SIZE_T AllocSize;
    PRTL_USER_PROCESS_PARAMETERS Params64;
    PRTL_USER_PROCESS_PARAMETERS32 Params32;
    SIZE_T Index;
    PCHAR p;
    PVOID Base;
    SIZE_T RegionSize;
    NTSTATUS st;


    //
    // Thunk the environment variables now.
    //

    Wow64pThunkEnvironmentVariables();

    // Process Parameters should have been normalized by ntdll.

    Params64 = Peb->ProcessParameters;
    if(NULL == Params64) {
        Peb32->ProcessParameters = (TYPE32(PRTL_USER_PROCESS_PARAMETERS))0;
        return STATUS_SUCCESS;
    }

    //
    //  Compute the required space for the continous memory region.

    AllocSize = sizeof(RTL_USER_PROCESS_PARAMETERS32);
    AllocSize += ROUND_UP(Params64->CurrentDirectory.DosPath.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->DllPath.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->ImagePathName.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->CommandLine.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->WindowTitle.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->DesktopInfo.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->ShellInfo.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->RuntimeData.MaximumLength, sizeof(ULONG));

    for(Index=0; Index < RTL_MAX_DRIVE_LETTERS; Index++) {
        AllocSize += ROUND_UP(Params64->CurrentDirectores[Index].DosPath.MaximumLength, sizeof(ULONG));
    }

    Base = NULL;
    RegionSize = AllocSize;
    st = NtAllocateVirtualMemory(NtCurrentProcess(),
                                 &Base,
                                 0,
                                 &RegionSize,
                                 MEM_COMMIT|MEM_RESERVE,
                                 PAGE_READWRITE);

    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "ThunkProcessParameters: NtAllocateVirtualMemory failed allocating process paramaters, error %x.\n", st));
        return st;
    }

    Params32 = (PRTL_USER_PROCESS_PARAMETERS32)Base;
    Peb32->ProcessParameters = (TYPE32(PRTL_USER_PROCESS_PARAMETERS))PtrToUlong(Params32);
    p = (PCHAR)Params32 + sizeof(RTL_USER_PROCESS_PARAMETERS32);

    Params32->MaximumLength = Params32->Length = (ULONG)AllocSize;
    Params32->Flags = Params64->Flags;
    Params32->DebugFlags = Params64->DebugFlags;
    Params32->ConsoleHandle = (TYPE32(HANDLE))PtrToUlong(Params64->ConsoleHandle);
    Params32->ConsoleFlags = (ULONG)Params64->ConsoleFlags;
    Params32->StandardInput = (TYPE32(HANDLE)) PtrToUlong(Params64->StandardInput);
    Params32->StandardOutput = (TYPE32(HANDLE)) PtrToUlong(Params64->StandardOutput);
    Params32->StandardError = (TYPE32(HANDLE)) PtrToUlong(Params64->StandardError);

    Params32->CurrentDirectory.Handle = (TYPE32(HANDLE)) PtrToUlong(Params64->CurrentDirectory.Handle);
    Wow64pCopyString(&p, &Params32->CurrentDirectory.DosPath, &Params64->CurrentDirectory.DosPath);

    Wow64pCopyString(&p, &Params32->DllPath, &Params64->DllPath);
    Wow64pCopyString(&p, &Params32->ImagePathName, &Params64->ImagePathName);
    Wow64pCopyString(&p, &Params32->CommandLine, &Params64->CommandLine);
    Params32->Environment = PtrToUlong(Params64->Environment);

    Params32->StartingX = Params64->StartingX;
    Params32->StartingY = Params64->StartingY;
    Params32->CountX = Params64->CountX;
    Params32->CountY = Params64->CountY;
    Params32->CountCharsX = Params64->CountCharsX;
    Params32->CountCharsY = Params64->CountCharsY;
    Params32->FillAttribute = Params64->FillAttribute;

    Params32->WindowFlags = Params64->WindowFlags;
    Params32->ShowWindowFlags = Params64->ShowWindowFlags;
    Wow64pCopyString(&p, &Params32->WindowTitle, &Params64->WindowTitle);
    Wow64pCopyString(&p, &Params32->DesktopInfo, &Params64->DesktopInfo);
    Wow64pCopyString(&p, &Params32->ShellInfo, &Params64->ShellInfo);

    // RuntimeData is mis-prototyped as a UNICODE_STRING.  However,
    // it is really used by the C runtime as a mechanism to pass file
    // handles around.  Thunk it as such.  See sdktools\vctools\crtw32
    // \exec\dospawn.c and lowio\ioinit.c for the gory details.
    if (Params64->RuntimeData.Length && Params64->RuntimeData.Buffer) {
        int cfi_len;
        char *posfile64;
        UINT_PTR UNALIGNED *posfhnd64;
        char *posfile32;
        UINT UNALIGNED *posfhnd32;
        int i;

        cfi_len = *(int UNALIGNED *)Params64->RuntimeData.Buffer;

        Params32->RuntimeData.Length = Params64->RuntimeData.Length - cfi_len * sizeof(ULONG);
        Params32->RuntimeData.MaximumLength = Params32->RuntimeData.Length;
        Params32->RuntimeData.Buffer = PtrToUlong(p);
        p += Params32->RuntimeData.Length;

        posfile64 = (char *)((UINT_PTR)Params64->RuntimeData.Buffer+sizeof(int));
        posfhnd64 = (UINT_PTR UNALIGNED *)(posfile64 + cfi_len);
        posfile32 = (char *)((ULONG_PTR)Params32->RuntimeData.Buffer+sizeof(int));
        posfhnd32 = (UINT UNALIGNED *)(posfile32 + cfi_len);

        *(int *)Params32->RuntimeData.Buffer = cfi_len;
        for (i=0; i<cfi_len; ++i) {
            *posfile32 = *posfile64;
            *posfhnd32 = (ULONG)*posfhnd64;
            posfile32++;
            posfile64++;
            posfhnd32++;
            posfhnd64++;
        }

        // Any bytes past the end of 4+(cfi_len*(sizeof(UINT_PTR)+sizeof(UINT))
        // must be copied verbatim.  They are probably from a non-MS C runtime.
        memcpy(posfhnd32, posfhnd64, (Params64->RuntimeData.Length - ((ULONG_PTR)posfhnd64 - (ULONG_PTR)Params64->RuntimeData.Buffer)));
    }

    for(Index = 0; Index < RTL_MAX_DRIVE_LETTERS; Index++) {
        Params32->CurrentDirectores[Index].Flags = Params64->CurrentDirectores[Index].Flags;
        Params32->CurrentDirectores[Index].Length = sizeof(RTL_DRIVE_LETTER_CURDIR);
        Params32->CurrentDirectores[Index].TimeStamp = Params64->CurrentDirectores[Index].TimeStamp;
        Wow64pCopyString(&p, (PUNICODE_STRING32)&Params32->CurrentDirectores[Index].DosPath, (PUNICODE_STRING)&Params64->CurrentDirectores[Index].DosPath);
    }

    return STATUS_SUCCESS;
}

//
// This compile-time assert ensures that the PEB64 and PEB32 structures are in
// alignment on an IA64 build.  If this fails, someone added, deleted, or changed
// the type of a field in PEB32/PEB64 depending on the compile destination.  Check
// %ntdir%\base\published\wow64t.w for alignment errors.
//
// If you hit hit this, you'll see messages something like:
//
// error C2118: negative subscript or subscript is too large
//
#ifdef _WIN64
#define PEB_ALIGN_TARGET PEB64
#define PEB_ALIGN_SOURCE PEB
#else
#define PEB_ALIGN_TARGET PEB32
#define PEB_ALIGN_SOURCE PEB
#endif
#define CHECK_PEB_ALIGNMENT( f ) C_ASSERT( FIELD_OFFSET( PEB_ALIGN_SOURCE, f ) == FIELD_OFFSET( PEB_ALIGN_TARGET, f ) )

CHECK_PEB_ALIGNMENT( ActivationContextData );
CHECK_PEB_ALIGNMENT( ProcessAssemblyStorageMap );
CHECK_PEB_ALIGNMENT( SystemDefaultActivationContextData );
CHECK_PEB_ALIGNMENT( SystemAssemblyStorageMap );
CHECK_PEB_ALIGNMENT( pShimData );

#undef CHECK_PEB_ALIGNMENT
#undef PEB_ALIGN_TARGET
#undef PEB_ALIGN_SOURCE


NTSTATUS
ProcessInit(
    PSIZE_T pCpuThreadSize
    )
/*++

Routine Description:

    Perform per-process initialization for wow64.dll.  That includes
    creating the 32-bit PEB and mapping in 32-bit ntdll.dll.

Arguments:

    pCpuThreadSize  - OUT PTR to store the CPU's per-thread data requirements
                      in.

Return Value:

    Status.  If this fails, it doesn't clean up, assuming that the
    process is going to fail to run and exit right away, so nothing really
    gets leaked.

--*/
{
    NTSTATUS st;
    PVOID Base;
    SIZE_T RegionSize;
    PPEB Peb64 = NtCurrentPeb();  // get 64-bit PEB pointer
    ULONG ul;
    BOOLEAN b;
    HANDLE hKey;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjA;
    PWSTR defaultName;
    PWSTR imageName;

    InitializeDebug();

    //
    // Initialize Wow64Info
    //
    st = Wow64pInitializeWow64Info();
    if (!NT_SUCCESS (st)) {
    }

    st = InitializeContextMapper();
    if (!NT_SUCCESS (st)) {
       return st;
    }

    st = Wow64InitializeSystemInformation();
    if (!NT_SUCCESS (st)) {
       return st;
    }

    st = Wow64InitializeEmulatedSystemInformation();
    if (!NT_SUCCESS (st)) {
       return st;
    }

    //
    // Initialize all critical sections
    //
    st = RtlInitializeCriticalSection(&HandleDataCriticalSection);
    if (!NT_SUCCESS (st)) {
       return st;
    }

    //
    // Map in 32-bit ntdll32.dll and fill in the Ntdll32* global vars
    // with the system exports from ntdll.
    //
    st = MapNtdll32(&NtDll32Base);
    if (!NT_SUCCESS (st)) {
        LOGPRINT((ERRORLOG, "ProcessInit: MapNtdll32 failed, error %x \n", st));
        return st;
    }

    //Map in the 64bit DLLs.
    st = Map64BitDlls();
    if (!NT_SUCCESS (st)) {
        return st;
    }

    // Create the SuspendThread mutant to serialize access to the API
    st = Wow64pInitializeSuspendMutant();
    if (!NT_SUCCESS (st)) {
        return st;
    }

    // Get the full Nt Pathname to the %windir%\system32 directory, 
    // %windir% and %windir%\regedit.exe
    NtSystem32PathBuffer[0] = L'\\';
    NtSystem32PathBuffer[1] = L'?';
    NtSystem32PathBuffer[2] = L'?';
    NtSystem32PathBuffer[3] = L'\\';
    wcscpy(&NtSystem32PathBuffer[4], USER_SHARED_DATA->NtSystemRoot);
    wcscpy(RegeditPathBuffer, NtSystem32PathBuffer);
    wcscpy(NtWindowsImePathBuffer, NtSystem32PathBuffer);
    wcscat(&NtSystem32PathBuffer[4], L"\\system32");
    NtSystem32Path.Buffer = NtSystem32PathBuffer;
    NtSystem32Path.MaximumLength = sizeof(NtSystem32PathBuffer);
    NtSystem32Path.Length = wcslen(NtSystem32PathBuffer) * sizeof(WCHAR);

    wcscat(NtWindowsImePathBuffer, L"\\ime");
    NtWindowsImePath.Buffer = NtWindowsImePathBuffer;
    NtWindowsImePath.MaximumLength = sizeof(NtWindowsImePathBuffer);
    NtWindowsImePath.Length = wcslen(NtWindowsImePathBuffer) * sizeof(WCHAR);

    wcscat(RegeditPathBuffer, L"\\regedit.exe");
    RegeditPath.Buffer = RegeditPathBuffer;
    RegeditPath.MaximumLength = sizeof(RegeditPathBuffer);
    RegeditPath.Length = wcslen(RegeditPathBuffer) * sizeof(WCHAR);

    //
    // Initialize the system service tables
    //
    ServiceTables[WHNT32_INDEX] = sdwhnt32;
    ServiceTables[WHCON_INDEX] = sdwhcon;
    ServiceTables[WHWIN32_INDEX] = sdwhwin32;
    ServiceTables[WHBASE_INDEX] = sdwhbase;

    NtCurrentPeb()->KernelCallbackTable = Win32kCallbackTable;

    //
    // Get the address of the PEB32 from the process information
    //
    st = NtQueryInformationProcess(NtCurrentProcess(),
                                   ProcessWow64Information,
                                   &Peb32,
                                   sizeof(Peb32),
                                   NULL);
    if (!NT_SUCCESS (st)) {
        return st;
    }

    st = Wow64pThunkProcessParameters(Peb32, Peb64);
    if (!NT_SUCCESS (st)) {
       LOGPRINT((ERRORLOG, "ProcessInit: ThunkProcessParameters failed, error %x\n", st));
       return st;
    }

    //
    // Copy this one field down to the PEB32 from the native PEB.  It
    // is written into the 64-bit PEB by Fusion in csrss.exe after
    // NtCreateProcess has been called by the parent process.
    //

    Peb32->ActivationContextData = PtrToUlong(Peb64->ActivationContextData);
    Peb32->SystemDefaultActivationContextData = PtrToUlong(Peb64->SystemDefaultActivationContextData);

    //
    // Copy the pShimData if it exists on the 64-bit side and doesn't 
    // exist on the 32-bit side of the peb
    //

    if (Peb32->pShimData == 0L) {
        Peb32->pShimData = PtrToUlong (Peb64->pShimData);
    }

    //
    // If wow64 is running in guimode setup, then make sure the 32-bit Peb
    // BeingDebugged flag is FALSE.  Otherwise, if we are being debugged
    // by a 64-bit debugger with no WOW64 debugger extensions then it will
    // hit the STATUS_WX86_BREAKPOINT exception and halt.
    //
    RtlInitUnicodeString(&KeyName, L"\\Registry\\Machine\\System\\Setup");
    InitializeObjectAttributes(&ObjA, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenKey(&hKey, KEY_READ, &ObjA);
    if (NT_SUCCESS(st)) {
        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
        WCHAR Buffer[400];
        ULONG ResultLength;

        RtlInitUnicodeString(&KeyName, L"SystemSetupInProgress");
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        st = NtQueryValueKey(hKey,
                             &KeyName,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(Buffer),
                             &ResultLength);
        if (NT_SUCCESS(st) &&
            KeyValueInformation->Type == REG_DWORD &&
            *(DWORD *)(KeyValueInformation->Data)) {

            Peb32->BeingDebugged = FALSE;

        }
        NtClose(hKey);
    }

    //
    // Initialize the CPU
    //
    defaultName = L"Unknown Image";
    imageName = GetImageName(defaultName);

    st = CpuProcessInit(imageName, pCpuThreadSize);

    //
    // Success or failure, we are done with the image name
    //
    if (imageName != defaultName) {
        Wow64FreeHeap(imageName);
    }

    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "ProcessInit: CpuProcessInit failed, error %x.\n", st));
        return st;
    }

    return st;
}


VOID
Wow64Shutdown(
    HANDLE ProcessHandle
    )
{
    CpuProcessTerm(ProcessHandle);
    CleanupReflector ( 0);
    ShutdownDebug();
}


VOID
ThunkPeb64ToPeb32(
    IN PPEB Peb64,
    OUT PPEB32 Peb32
    )
{
    RtlZeroMemory(Peb32, sizeof(PEB32));
    Peb32->Mutant = 0xffffffff;

    //
    // Initialize the Peb32 (copied from ntos\mm\procsup.c's MmCreatePeb)
    //
    Peb32->ImageBaseAddress = PtrToUlong(Peb64->ImageBaseAddress);
    Peb32->AnsiCodePageData = PtrToUlong(Peb64->AnsiCodePageData);
    Peb32->OemCodePageData =  PtrToUlong(Peb64->OemCodePageData);
    Peb32->UnicodeCaseTableData = PtrToUlong(Peb64->UnicodeCaseTableData);
    Peb32->NumberOfProcessors = Peb64->NumberOfProcessors;
    Peb32->BeingDebugged = Peb64->BeingDebugged;
    Peb32->NtGlobalFlag = Peb64->NtGlobalFlag;
    Peb32->CriticalSectionTimeout = Peb64->CriticalSectionTimeout;
    if (Peb64->HeapSegmentReserve > 1024*1024*1024) {   // 1gig
        Peb32->HeapSegmentReserve = 1024*1024;          // 1meg
    } else {
        Peb32->HeapSegmentReserve = (ULONG)Peb64->HeapSegmentReserve;
    }
    if (Peb64->HeapSegmentCommit > Peb32->HeapSegmentReserve) {
        Peb32->HeapSegmentCommit = 2*PAGE_SIZE;
    } else {
        Peb32->HeapSegmentCommit = (ULONG)Peb64->HeapSegmentCommit;
    }
    Peb32->HeapDeCommitTotalFreeThreshold = (ULONG)Peb64->HeapDeCommitTotalFreeThreshold;
    Peb32->HeapDeCommitFreeBlockThreshold = (ULONG)Peb64->HeapDeCommitFreeBlockThreshold;
    Peb32->MaximumNumberOfHeaps = (PAGE_SIZE - sizeof(PEB32))/sizeof(ULONG);
    Peb32->ProcessHeaps = PtrToUlong(Peb32+1);
    Peb32->OSMajorVersion = Peb64->OSMajorVersion;
    Peb32->OSMinorVersion = Peb64->OSMinorVersion;
    Peb32->OSBuildNumber = Peb64->OSBuildNumber;
    Peb32->OSPlatformId = Peb64->OSPlatformId;
    Peb32->OSCSDVersion = Peb64->OSCSDVersion;
    Peb32->ImageSubsystem = Peb64->ImageSubsystem;
    Peb32->ImageSubsystemMajorVersion = Peb64->ImageSubsystemMajorVersion;
    Peb32->ImageSubsystemMinorVersion = Peb64->ImageSubsystemMinorVersion;
    Peb32->ImageProcessAffinityMask = PtrToUlong((PVOID)Peb64->ImageProcessAffinityMask);
    Peb32->SessionId = Peb64->SessionId;
}


NTSTATUS
ThreadInit(
    PVOID pCpuThreadData
    )
/*++

Routine Description:

    Perform per-thread initialization for wow64.dll.

Arguments:

    pCpuThreadData  - pointer to private per-thread data for the CPU to use.

Return Value:

    Status.

--*/
{
    NTSTATUS st;
    PVOID Base;
    SIZE_T RegionSize;
    PTEB32 Teb32;
    PCH Stack;
    BOOLEAN GuardPage;
    ULONG OldProtect;
    SIZE_T ImageStackSize, ImageStackCommit, MaximumStackSize, StackSize;
    PIMAGE_NT_HEADERS32 NtHeaders;
    PPEB Peb64;
    PTEB Teb64;

    

    Peb64 = NtCurrentPeb();
    Teb64 = NtCurrentTeb();
    Teb32 = NtCurrentTeb32();

    if (Teb32->DeallocationStack == PtrToUlong( NULL ))
    {
        //
        // Allocate the 32-bit stack.  Cloned from windows\base\client\support.c
        // If the stack size was not supplied, then use the sizes from the
        // image header.
        //
        NtHeaders = (PIMAGE_NT_HEADERS32)RtlImageNtHeader(Peb64->ImageBaseAddress);
        ImageStackSize = NtHeaders->OptionalHeader.SizeOfStackReserve;
        ImageStackCommit = NtHeaders->OptionalHeader.SizeOfStackCommit;

        MaximumStackSize = ImageStackSize;
        StackSize = ImageStackCommit;

        //
        // Align the stack size to a page boundry and the reserved size
        // to an allocation granularity boundry.
        //
        StackSize = ROUND_UP ( StackSize, PAGE_SIZE );
        MaximumStackSize = ROUND_UP ( MaximumStackSize, 65536 );
        
        //
        // Reserve address space for the stack
        //

        Stack = NULL;
        st = NtAllocateVirtualMemory(
                 NtCurrentProcess(),
                 (PVOID *)&Stack,
                 0,
                 &MaximumStackSize,
                 MEM_RESERVE,
                 PAGE_READWRITE 
                 );

        if (!NT_SUCCESS( st )) 
        {
            LOGPRINT((ERRORLOG, "ThreadInit: NtAllocateVirtualMemory failed, error %x\n", st));
            goto ReturnError;
        }

        LOGPRINT((TRACELOG, "ThreadInit: 32 bit stack allocated at %I64x \n", (ULONGLONG)Stack));

        Teb32->DeallocationStack = PtrToUlong(Stack);
        Teb32->NtTib.StackBase = PtrToUlong(Stack + MaximumStackSize);

        Stack += MaximumStackSize - StackSize;
        if (MaximumStackSize > StackSize) 
        {
            Stack -= PAGE_SIZE;
            StackSize += PAGE_SIZE;
            GuardPage = TRUE;
        } 
        else 
        {
            GuardPage = FALSE;
        }

        //
        // Commit the initially valid portion of the stack
        //
        st = NtAllocateVirtualMemory(
                 NtCurrentProcess(),
                 (PVOID *)&Stack,
                 0,
                 &StackSize,
                 MEM_COMMIT,
                 PAGE_READWRITE
                 );

        if (!NT_SUCCESS( st ))
        {
            //
            // commit failed
            //

            LOGPRINT((ERRORLOG, "ThreadInit: NtAllocateVirtualMemory commit failed, error %x\n", st));
            goto ErrorFreeStack;
        }

        Teb32->NtTib.StackLimit = PtrToUlong(Stack);

        //
        // if we have space, create a guard page.
        //   
        if (GuardPage) 
        {
            RegionSize = PAGE_SIZE;
            st = NtProtectVirtualMemory(
                     NtCurrentProcess(),
                     (PVOID *)&Stack,
                     &RegionSize,
                     PAGE_GUARD | PAGE_READWRITE,
                     &OldProtect
                     );
        
            if (!NT_SUCCESS( st )) 
            {
                LOGPRINT((ERRORLOG, "ThreadInit: NtAllocateVirtualMemory for guard-page failed, error %x\n", st));
                goto ErrorFreeStack;
            }
            Teb32->NtTib.StackLimit = PtrToUlong ((PUCHAR)Teb32->NtTib.StackLimit + RegionSize);
        }
    }

    //
    // Migrate the Teb->IdealProcessor & Teb->CurrentLocale from the 64-bit TEB.
    // The kernel does exactly the same thing before starting the usermode thread by 
    // migrating these values from the TCB.
    //
    Teb32->CurrentLocale = Teb64->CurrentLocale;
    Teb32->IdealProcessor = Teb64->IdealProcessor;

    //
    // Now that everything else is initialized, run the CPU's per-thread
    // initialization code.
    //
    
    st = CpuThreadInit (pCpuThreadData);
    
    if (NT_SUCCESS( st )) 
    {
        return st;
    }

    LOGPRINT((ERRORLOG, "ThreadInit: CpuThreadInit failed, error %x\n", st));

ErrorFreeStack:
    
    Base = (PVOID) Teb32->DeallocationStack;
    RegionSize = 0;
    NtFreeVirtualMemory(NtCurrentProcess(), &Base, &RegionSize, MEM_RELEASE);

ReturnError:

    return st;
}

NTSTATUS
MapNtdll32(
    OUT ULONG *pNtDll32Base
    )
/*++

Routine Description:

    Map 32-bit ntdll32.dll into memory and look up all of the important
    entrypoints.

Arguments:

    pNtDll32Base    - OUT base address of the DLL.

Return Value:

    Status.  On success, Ntdll32* globals are set.

--*/
{
    UNICODE_STRING SystemDllPath;
    WCHAR SystemDllPathBuffer[DOS_MAX_PATH_LENGTH];
    NTSTATUS st;
    UNICODE_STRING FullDllName;
    WCHAR FullDllNameBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE File;
    HANDLE Section;
    PVOID ViewBase;
    SIZE_T ViewSize;
    PVOID pv;
    PTEB Teb;
    PVOID ArbitraryUserPointer;


    //
    // Build up the name of the 32-bit system directory
    //
    SystemDllPath.Buffer = SystemDllPathBuffer;
    SystemDllPath.Length = 0;
    SystemDllPath.MaximumLength = sizeof(SystemDllPathBuffer);
    RtlAppendUnicodeToString(&SystemDllPath, USER_SHARED_DATA->NtSystemRoot);
    RtlAppendUnicodeToString(&SystemDllPath, L"\\" WOW64_SYSTEM_DIRECTORY_U);
    
    //
    // Build up the full pathname to %SystemRoot%\syswow64\ntdll32.dll
    //
    FullDllName.Buffer = FullDllNameBuffer;
    FullDllName.Length = 0;
    FullDllName.MaximumLength = sizeof(FullDllNameBuffer);
    RtlCopyUnicodeString(&FullDllName, &SystemDllPath);
    RtlAppendUnicodeToString(&FullDllName, L"\\ntdll.dll");

    //
    // Convert the Win32 pathname to an NT pathname
    //
    if (!RtlDosPathNameToNtPathName_U(FullDllName.Buffer,
                                      &NtFileName,
                                      NULL,
                                      NULL)) {
        // probably out-of-memory
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Open the file
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &NtFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    st = NtOpenFile(&File,
                    SYNCHRONIZE | FILE_EXECUTE,
                    &ObjectAttributes,
                    &IoStatus,
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);
    if (!NT_SUCCESS(st)) {
        return st;
    }

    //
    // Create the section
    //
    st = NtCreateSection(&Section,
                         SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE,
                         NULL,
                         NULL,
                         PAGE_EXECUTE,
                         SEC_IMAGE,
                         File);
    NtClose(File);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: NtCreateSection failed, error %x\n", st));
        return st;
    }

    //
    // Map the section in and let the debugger know the name of the image.
    // We lie to NTSD about the image name, calling it ntdll32.dll so
    // it can disambiguate between the two when doing name resolution.
    // Put 64-bit symbols first on sympath, then 32-bit, and NTSD will find
    // the 32-bit ntdll.pdb and use it for ntdll32.dll.
    //
    *pNtDll32Base = 0;
    pv = NULL;
    ViewSize = 0;
    Teb = NtCurrentTeb();
    ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
    FullDllName.Buffer = FullDllNameBuffer;
    FullDllName.Length = 0;
    FullDllName.MaximumLength = sizeof(FullDllNameBuffer);
    RtlCopyUnicodeString(&FullDllName, &SystemDllPath);
    RtlAppendUnicodeToString(&FullDllName, L"\\ntdll32.dll");
    Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;
    st = NtMapViewOfSection(Section,
                            NtCurrentProcess(),
                            &pv,
                            0,
                            0,
                            NULL,
                            &ViewSize,
                            ViewShare,
                            0,
                            PAGE_EXECUTE);
    Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;
    NtClose(Section);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32, NtMapViewOfSection failed, error %x\n", st));
        return st;
    } else if (st == STATUS_IMAGE_NOT_AT_BASE) {
        LOGPRINT((ERRORLOG, "ntdll32.dll not at base.\n"));
        return STATUS_UNSUCCESSFUL;
    }
    *pNtDll32Base = PtrToUlong(pv);

    //
    // Look up the required exports from the Dll.
    //
    // main entrypoint
    st = LookupEntryPoint(*pNtDll32Base,
                          "LdrInitializeThunk",
                          &Ntdll32LoaderInitRoutine,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint LdrInitializeThunk failed, error %x\n", st));
        return st;
    }

    // exception dispatching
    st = LookupEntryPoint(*pNtDll32Base,
                          "KiUserExceptionDispatcher",
                          &Ntdll32KiUserExceptionDispatcher,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint KiUserExceptionDispatcher failed, error %x\n", st));
        WOWASSERT(FALSE);
        return st;
    }

    // usermode APC dispatching
    st = LookupEntryPoint(*pNtDll32Base,
                          "KiUserApcDispatcher",
                          &Ntdll32KiUserApcDispatcher,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint KiUserApcDispatcher failed, error %x\n", st));
        WOWASSERT(FALSE);
        return st;
    }

    // callback dispatching
    st = LookupEntryPoint(*pNtDll32Base,
                          "KiUserCallbackDispatcher",
                          &Ntdll32KiUserCallbackDispatcher,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint KiUserCallbackDispatcher failed, error %x\n", st));
        WOWASSERT(FALSE);
        return st;
    }

    // raise a usermode exception
    st = LookupEntryPoint(*pNtDll32Base,
                          "KiRaiseUserExceptionDispatcher",
                          &Ntdll32KiRaiseUserExceptionDispatcher,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint KiRaiseUserExceptionDispatcher failed, error %x\n", st));
        WOWASSERT(FALSE);
        return st;
    }

    return st;
}


NTSTATUS
LookupEntryPoint(
    IN ULONG DllBase,
    IN  PSZ NameOfEntryPoint,
    OUT ULONG *AddressOfEntryPoint,
    BOOLEAN DllIs64bit
    )
/*++

Routine Description:

    Cloned from ntos\init\init.c LookupEntryPoint().  Tiny version of
    GetProcAddress.

Arguments:

    DllBase             - Dll to look export up in
    NameOfEntryPoint    - Name of export to look up
    AddressOfEntryPoint - OUT ptr to location to write the proc address
    DllIs64bit          - TRUE if DLL is 64bit
Return Value:

    Status.

--*/
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportSize;
    USHORT Ordinal;
    PULONG Addr;
    CHAR NameBuffer[64];

    if (DllIs64bit) {

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
        RtlImageDirectoryEntryToData(
            (PVOID)DllBase,
            TRUE,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &ExportSize);

    }
    else {

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
            RtlImageDirectoryEntryToData(
                (PVOID)DllBase,
                TRUE,
                IMAGE_DIRECTORY_ENTRY_EXPORT,
                &ExportSize);
    }

    if ( strlen(NameOfEntryPoint) > sizeof(NameBuffer)-2 ) {
        return STATUS_INVALID_PARAMETER;
    }

    strcpy(NameBuffer,NameOfEntryPoint);

    Ordinal = NameToOrdinal(
                NameBuffer,
                DllBase,
                ExportDirectory->NumberOfNames,
                (PULONG)((UINT_PTR)DllBase + ExportDirectory->AddressOfNames),
                (PUSHORT)((UINT_PTR)DllBase + ExportDirectory->AddressOfNameOrdinals)
                );

    //
    // If Ordinal is not within the Export Address Table,
    // then DLL does not implement function.
    //

    if ( (ULONG)Ordinal >= ExportDirectory->NumberOfFunctions ) {
        return STATUS_PROCEDURE_NOT_FOUND;
    }

    Addr = (PULONG)(DllBase + ExportDirectory->AddressOfFunctions);
    *AddressOfEntryPoint = (DllBase + Addr[Ordinal]);
    return STATUS_SUCCESS;
}


USHORT
NameToOrdinal (
    IN  PSZ NameOfEntryPoint,
    IN ULONG DllBase,
    IN ULONG NumberOfNames,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    )
/*++

Routine Description:

    Cloned from ntos\init\init.c NameToOrdinal().

Arguments:

    NameOfEntryPoint        - entrypoint name
    DllBase                 - base address of dll
    NumberOfNames           - # names in the dll export table
    NameTableBase           - address of the dll name table
    NameOrdinalTableBase    - address of the dll ordinal table

Return Value:

    Ordinal of the export.  -1 for failure.

--*/
{

    ULONG SplitIndex;
    LONG CompareResult;

    SplitIndex = NumberOfNames >> 1;

    CompareResult = strcmp(NameOfEntryPoint, (PSZ)(DllBase + NameTableBase[SplitIndex]));

    if ( CompareResult == 0 ) {
        return NameOrdinalTableBase[SplitIndex];
    }

    if ( NumberOfNames <= 1 ) {
        return (USHORT)-1;
    }

    if ( CompareResult < 0 ) {
        NumberOfNames = SplitIndex;
    } else {
        NameTableBase = &NameTableBase[SplitIndex+1];
        NameOrdinalTableBase = &NameOrdinalTableBase[SplitIndex+1];
        NumberOfNames = NumberOfNames - SplitIndex - 1;
    }

    return NameToOrdinal(NameOfEntryPoint,DllBase,NumberOfNames,NameTableBase,NameOrdinalTableBase);

}

CONST PCHAR  Kernel32ExportNames32[] = {
                              "BaseProcessStartThunk",
                              "BaseThreadStartThunk",
                              "CtrlRoutine",
                              "ConsoleIMERoutine"
                             };

CONST PCHAR  Kernel32ExportNames64[] = {
#if defined(_IA64_)
                              "BaseProcessStartThunk",
                              "BaseThreadStartThunk",
#else
                              "BaseProcessStart",
                              "BaseThreadStart",
#endif
                              "CtrlRoutine",
                              "ConsoleIMERoutine"
                             };

UINT NumberKernel32Exports = sizeof(Kernel32ExportNames32) / sizeof(PCHAR);
ULONG Kernel32Exports64[sizeof(Kernel32ExportNames64) / sizeof(PCHAR)];
ULONG Kernel32Exports32[sizeof(Kernel32ExportNames32) / sizeof(PCHAR)];

CONST WCHAR * Kernel32DllNames[] = {
                                L"\\System32\\Kernel32.dll",
                                L"\\" WOW64_SYSTEM_DIRECTORY_U L"\\kernel32.dll",
                              };
PULONG  Kernel32DllPtrTables[] = {Kernel32Exports64, Kernel32Exports32};
CONST PCHAR *Kernel32ExportNames[] = {Kernel32ExportNames64, Kernel32ExportNames32};

CONST BOOLEAN Kernel32Is64bit[] = {TRUE, FALSE};
#define NumberKernel32Dlls 2

#define BASE_PROCESS_START32         (Kernel32Exports32[0])
#define BASE_PROCESS_START64         (Kernel32Exports64[0])
#define BASE_THREAD_START32          (Kernel32Exports32[1])
#define BASE_THREAD_START64          (Kernel32Exports64[1])
#define BASE_ATTACH_COMPLETE_THUNK64 (Kernel32Exports64[2])

NTSTATUS
InitializeContextMapper(
   VOID
   )
/*++

Routine Description:

    Builds a mapping table that is used by ThunkInitialContext to map from addresses
    in 64bit kernel32 to address in 32bit kernel32.

Arguments:

   None.

Return Value:

   NT Error code.

--*/
{
   UINT DllNumber;
   UINT ExportNumber;
   PTEB Teb;

   LOGPRINT((TRACELOG, "Initializing context mapper\n"));

   Teb = NtCurrentTeb();

   for(DllNumber = 0; DllNumber < NumberKernel32Dlls; DllNumber++) {

       WCHAR FullDllNameBuffer[DOS_MAX_PATH_LENGTH];
       UNICODE_STRING DllName;
       BOOLEAN DllNameAllocated;
       HANDLE File, Section;
       OBJECT_ATTRIBUTES ObjectAttributes;
       IO_STATUS_BLOCK IoStatus;
       PVOID ViewBase;
       SIZE_T ViewSize;
       NTSTATUS st;
       PVOID ArbitraryUserPointer;

       File = Section = INVALID_HANDLE_VALUE;
       ViewBase = NULL;
       ViewSize = 0;
       DllNameAllocated = FALSE;

       try {

           LOGPRINT((TRACELOG, "InitializeContextMapper: Mapping in %S\n", Kernel32DllNames[DllNumber]));

           //Build up the file name
           wcscpy(FullDllNameBuffer, USER_SHARED_DATA->NtSystemRoot);
           wcscat(FullDllNameBuffer, Kernel32DllNames[DllNumber]);

           //
           // Convert the Win32 pathname to an NT pathname
           //
           if (!RtlDosPathNameToNtPathName_U(FullDllNameBuffer,
                                             &DllName,
                                             NULL,
                                             NULL)) {
                // probably out-of-memory
                return STATUS_UNSUCCESSFUL;
           }
           DllNameAllocated = TRUE;
           LOGPRINT((TRACELOG, "InitializeContextMapper: Opening %wZ\n", &DllName));

           //
           // Open the file
           //
           InitializeObjectAttributes(&ObjectAttributes,
                                      &DllName,
                                      OBJ_CASE_INSENSITIVE,
                                      NULL,
                                      NULL);

           st = NtOpenFile(&File,
                           SYNCHRONIZE | FILE_EXECUTE,
                           &ObjectAttributes,
                           &IoStatus,
                           FILE_SHARE_READ | FILE_SHARE_DELETE,
                           FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
           if (!NT_SUCCESS(st)) {
               LOGPRINT((TRACELOG, "InitializeContextMapper: Unable to open file, status %x\n", st));
               return st;
           }

           //
           // Create the section
           //
           st = NtCreateSection(&Section,
                                SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE,
                                NULL,
                                NULL,
                                PAGE_EXECUTE,
                                SEC_IMAGE,
                                File);

           if (!NT_SUCCESS(st)) {
               LOGPRINT((TRACELOG, "InitializeContextMapper: Unable to create section, status %x\n", st));
               return st;
           }

           ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
           Teb->NtTib.ArbitraryUserPointer = L"NOT_AN_IMAGE";
           st = NtMapViewOfSection(Section,
                                   NtCurrentProcess(),
                                   &ViewBase,
                                   0,
                                   0,
                                   NULL,
                                   &ViewSize,
                                   ViewUnmap,
                                   0,
                                   PAGE_EXECUTE);
           Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

           if (!NT_SUCCESS(st) || STATUS_IMAGE_NOT_AT_BASE == st) {
               LOGPRINT((TRACELOG, "InitializeContextMapper: Unable to map view of section, status %x\n", st));
               if (st == STATUS_IMAGE_NOT_AT_BASE) {
                   st = STATUS_UNSUCCESSFUL;
               }
               return st;
           }

           for(ExportNumber = 0; ExportNumber < NumberKernel32Exports; ExportNumber++) {

               st = LookupEntryPoint((ULONG)(ULONG_PTR)ViewBase,
                     Kernel32ExportNames[DllNumber][ExportNumber],
                                     &(Kernel32DllPtrTables[DllNumber][ExportNumber]),
                                     Kernel32Is64bit[DllNumber]);
               if (!NT_SUCCESS(st)) {
                   LOGPRINT((TRACELOG, "InitializeContextMapper: Unable to lookup entrypoint %s, status %x\n", Kernel32ExportNames[DllNumber][ExportNumber], st));
                   return st;
               }

               LOGPRINT((TRACELOG, "InitializeContextMapper: Found entrypoint %s at %x\n", Kernel32ExportNames[DllNumber][ExportNumber], Kernel32DllPtrTables[DllNumber][ExportNumber]));

           }

       }

       finally {

          //Deallocate all the allocated resources
          if (ViewBase) {
              NtUnmapViewOfSection(NtCurrentProcess(),
                                   ViewBase);
          }
          if (INVALID_HANDLE_VALUE != Section) {
              NtClose(Section);
          }
          if (INVALID_HANDLE_VALUE != File) {
              NtClose(File);
          }
          if (DllNameAllocated) {
              RtlFreeHeap(RtlProcessHeap(), 0, DllName.Buffer);
          }

       }

   }

   return STATUS_SUCCESS;

}

ULONG
MapContextAddress64TO32(
  IN ULONG Address
  )
{

   UINT i;

   for(i=0; i<NumberKernel32Exports; i++) {

      if (Address == Kernel32Exports64[i]) {
          return Kernel32Exports32[i];
      }

   }

   return Address;

}

VOID
ThunkStartupContext64TO32(
   IN OUT PCONTEXT32 Context32,
   IN PCONTEXT Context64
   )
/*++

Routine Description:

    Munges the InitialPC and arguments registers to compensate for the fact that
    32bit kernel32 has different entry points then 64bit kernel32.  The 32bit context must
    have had the context flags set to full and the stack pointer initialized.

Arguments:

   Context32 - Receives a munged 32bit context.
   Context64 - Supplies the initial 64bit context.

Return Value:

   NT Error code.

--*/
{
    //
    // Thunk the 64-bit CONTEXT down to 32-bit.
    //
    ULONG InitialPC, StartupAddress, Arg1;

#if defined(_AMD64_)
    InitialPC = (ULONG)Context64->Rip;
    StartupAddress = (ULONG)Context64->Rcx;
    Arg1 = (ULONG)Context64->Rdx;
#elif defined(_IA64_)
    InitialPC = (ULONG)Context64->StIIP;
    StartupAddress = (ULONG)Context64->IntS1;
    Arg1 = (ULONG)Context64->IntS2;
    if (Context64->IntS3 != 0) {
        Context32->Esp = (ULONG)Context64->IntS3;
    }
#else
#error "No Target Architecture"
#endif

    LOGPRINT((TRACELOG, "ThunkStartupContent64TO32: Original InitialPC %x, StartupAddress %x, Arg1 %x\n", InitialPC, StartupAddress, Arg1));

    if (InitialPC == BASE_PROCESS_START64) {
        LOGPRINT((TRACELOG, "ThunkStartupContext64TO32: Thunking kernel32 process start\n"));
        InitialPC = BASE_PROCESS_START32;
        StartupAddress = MapContextAddress64TO32(StartupAddress);
    }
    else if (InitialPC == BASE_THREAD_START64) {
        LOGPRINT((TRACELOG, "ThunkStartupContext64TO32: Thunking kernel32 thread start\n"));
        InitialPC = BASE_THREAD_START32;
        StartupAddress = MapContextAddress64TO32(StartupAddress);
    }
    else {
        LOGPRINT((TRACELOG, "ThunkStartupContext64TO32: thunking generic context\n"));
        InitialPC = MapContextAddress64TO32(InitialPC);
    }

    LOGPRINT((TRACELOG, "ThunkStartupContent64TO32: New InitialPC %x, StartupAddress %x, Arg1 %x\n", InitialPC, StartupAddress, Arg1));

    Context32->Eip = InitialPC;
    Context32->Eax = StartupAddress;
    Context32->Ebx = Arg1;
}

VOID
SetProcessStartupContext64(
    OUT PCONTEXT Context64,
    IN HANDLE ProcessHandle,
    IN PCONTEXT32 Context32,
    IN ULONGLONG InitialSP64,
    IN ULONGLONG TransferAddress64
    )
/*++

Routine Description:

   Initializes a 64bit context for startup of a 64bit process.

Arguments:

   Context32 - Receives a initial 64bit context.
   ProcessHandle - Handle to the process the context is being created for.
   Context32 - Supplies the initial 32bit context as passed to NtCreateThread.
   InitialSP64 - Supplies the Initial 64bit stack pointer.
   TransferAddress64 - Supplies the address of the app startup code.

Return Value:

   None.

--*/
{

    //
    // Do what BaseInitializeContext(&Context64) would have done
    //

#if defined(_AMD64_)

    RtlZeroMemory(Context64, sizeof(CONTEXT));
    Context64->Rsp = InitialSP64;
    Context64->ContextFlags = CONTEXT_FULL;
    if (Context32->Eip == BASE_PROCESS_START32) {

        //
        // This is a call from CreateProcess.
        //
        // RIP should be kernel32.dll's process startup routine and rcx should
        // contain the exe's startup address.
        //

        Context64->Rip = BASE_PROCESS_START64;
        Context64->Rcx = TransferAddress64;

    } else if (Context32->Eip == BASE_THREAD_START32) {

        //
        // This is a call from CreateThread.
        //
        // RIP should be kernel32.dll's process startup routine and rcx should
        // contain the exe's startup address.
        //

        Context64->Rip = BASE_THREAD_START64;
        Context64->Rcx = TransferAddress64;

    } else {

        //
        // This is a call from ntdll.
        //
        // RIP should point to the exe startup address and rcx is the parameter.
        //

        ULONGLONG Argument;
        NTSTATUS Status;

        Context64->Rip = TransferAddress64;
        Argument = 0;
        Status = NtReadVirtualMemory(ProcessHandle,
                                     (PVOID)(Context32->Esp + sizeof(ULONG)),
                                     &Argument,
                                     sizeof(ULONG),
                                     NULL);

        if (NT_SUCCESS(Status)) {
            Context64->Rcx = Argument;
        }
    }

#elif defined(_IA64_)

    RtlZeroMemory(Context64, sizeof(CONTEXT));

    //
    // Everyone is assumed to have this...
    //
    Context64->SegCSD = USER_CODE_DESCRIPTOR;
    Context64->SegSSD = USER_DATA_DESCRIPTOR;
    Context64->Cflag = (ULONGLONG)((CR4_VME << 32) | CR0_PE | CFLG_II);
    Context64->Eflag = 0x00003000ULL;

    //
    // from ...\win\base\client\ia64\context.c
    //
    // Context64->RsPFS = 0;     // Done by the RtlZeroMemory() above
    //
    Context64->StIPSR = USER_PSR_INITIAL;
    Context64->StFPSR = USER_FPSR_INITIAL;
    Context64->RsBSP = Context64->RsBSPSTORE = Context64->IntSp = InitialSP64;
    Context64->IntSp -= STACK_SCRATCH_AREA; // scratch area as per convention
    Context64->IntS1 = TransferAddress64;
    Context64->IntS0 = Context64->StIIP = BASE_PROCESS_START64;

    //
    // Enable RSE engine
    //
    Context64->RsRSC = (RSC_MODE_EA<<RSC_MODE)
                   | (RSC_BE_LITTLE<<RSC_BE)
                   | (0x3<<RSC_PL);

    //
    // Note that we purposely set IntGp = 0ULL, to indicate special protocol
    // (see ps\ia64\psctxia64.c) - specifically, the StIIP address is really
    // a pointer to a plabel instead of the usual (a valid executable
    // address)
    //
    // Context64->IntGp = 0ULL;     // Done by the RtlZeroMemory() above
    //
    //
    // set nat bits for every thing except ap, gp, sp, also  T0 and T1
    //
    Context64->ApUNAT = 0xFFFFFFFFFFFFEDF1ULL;

    Context64->ContextFlags = CONTEXT_CONTROL| CONTEXT_INTEGER;

    if (Context32->Eip == BASE_PROCESS_START32) {
        //
        // This is a call from CreateProcess.  The IIP should be
        // kernel32.dll's process startup routine, and IntS0 should contain
        // the exe's startup address
        //
        Context64->IntS0 = Context64->StIIP = BASE_PROCESS_START64;
        Context64->IntS1 = TransferAddress64;

    } else if (Context32->Eip == BASE_THREAD_START32) {
        //
        // This is a call from CreateThread.  The IIP should be
        // kernel32.dll's process startup routine, and IntS0 should contain
        // the exe's startup address
        //
        Context64->IntS0 = Context64->StIIP = BASE_THREAD_START64;
        Context64->IntS1 = TransferAddress64;

    } else {
        //
        // This is a call from ntdll.  The IIP should point to the
        // exe startup address, and IntA0 is the parameter.
        //
        ULONGLONG Argument;
        NTSTATUS Status;

        Context64->IntS0 = Context64->StIIP = TransferAddress64;
        Argument = 0;
        Status = NtReadVirtualMemory(ProcessHandle,
                                     (PVOID)(Context32->Esp + sizeof(ULONG)),
                                     &Argument,
                                     sizeof(ULONG),
                                     NULL);
        if (NT_SUCCESS(Status)) {
             //
             // Note:  IA64 RtlInitializeContext does this write and ignores
             //        the return value, so we'll do the same.
             //
             NtWriteVirtualMemory(ProcessHandle,
                                  (PVOID)((ULONG_PTR)Context64->RsBSPSTORE),
                                  (PVOID)&Argument,
                                  sizeof(Argument),
                                  NULL);
        }
    }
#else
#error "No Target Architecture"
#endif
}

//
// names are in the NT name space.
//
CONST WCHAR *DllsToMapList[] = {L"\\KnownDlls\\kernel32.dll",
                                L"\\KnownDlls\\user32.dll"};
struct {
    PVOID DllBase;
    SIZE_T Length;
} DllsToMap[sizeof(DllsToMapList) / sizeof(sizeof(DllsToMapList[0]))];

NTSTATUS
Map64BitDlls(
    VOID
    )
/*++

Routine Description:

    Reserve ONLY the dlls address space without committing.  This is to prevent 32bit versions
    of these DLLs appearing at the same address and to catch unthunked callbacks.

Arguments:

   None.

Return Value:

   NT Error code.

--*/
{

   NTSTATUS Status;
   UINT c;
   PTEB Teb;
   PVOID BaseAddress;
   SIZE_T RegionSize;
   HANDLE SectionHandle;

   Teb=NtCurrentTeb();

   for(c=0;c<sizeof(DllsToMapList)/sizeof(DllsToMapList[0]);c++) {

      OBJECT_ATTRIBUTES ObjectAttributes;
      UNICODE_STRING SectionName;
      SIZE_T ViewSize;
      PVOID ArbitraryUserPointer;

      LOGPRINT((TRACELOG, "Map64BitDlls: Mapping 64bit section for %S\n", DllsToMapList[c]));

      RegionSize = 0;
      BaseAddress = NULL;
      SectionHandle = INVALID_HANDLE_VALUE;

      RtlInitUnicodeString(&SectionName, DllsToMapList[c]);

      InitializeObjectAttributes(&ObjectAttributes,
                                 &SectionName,
                                 OBJ_CASE_INSENSITIVE,
                                 NULL,
                                 NULL);

      Status = NtOpenSection(&SectionHandle,
                             SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE | SECTION_QUERY,
                             &ObjectAttributes);

      if (!NT_SUCCESS(Status)) {
          LOGPRINT((ERRORLOG, "Map64BitDlls: Unable to open section for %S, error %x\n", DllsToMapList[c], Status));
          SectionHandle = INVALID_HANDLE_VALUE;
          goto cleanup;
      }

      // get the image base and size
      ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
      Teb->NtTib.ArbitraryUserPointer = L"NOT_AN_IMAGE";
      Status = NtMapViewOfSection(SectionHandle,
                                  NtCurrentProcess(),
                                  &BaseAddress,
                                  0,
                                  0,
                                  NULL,
                                  &RegionSize,
                                  ViewUnmap,
                                  0,
                                  PAGE_NOACCESS);
      Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

      if (!NT_SUCCESS(Status) || STATUS_IMAGE_NOT_AT_BASE == Status) {
          LOGPRINT((ERRORLOG, "Map64BitDlls: Unable to map view for %S, error %x\n", DllsToMapList[c], Status));
          BaseAddress = NULL;
          
          if (Status == STATUS_IMAGE_NOT_AT_BASE) {
              Status = STATUS_UNSUCCESSFUL;
          }
          goto cleanup;
      }
      
      NtUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
      NtClose(SectionHandle);

      // just reserve address space
      DllsToMap[c].DllBase = BaseAddress;

      Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                       &DllsToMap[c].DllBase,
                                       0,
                                       &RegionSize,
                                       MEM_RESERVE,
                                       PAGE_EXECUTE_READWRITE);

      if (!NT_SUCCESS(Status)) {
          LOGPRINT((ERRORLOG, "Map64BitDlls: Couldn't reserve memory Base=%lx, Size=%lx - Status = %lx\n",
                    DllsToMap[c].DllBase, RegionSize, Status));
                    DllsToMap[c].DllBase = NULL;
          goto CleanupLoop;
      }
      DllsToMap[c].Length = RegionSize;

      LOGPRINT((TRACELOG, "Map64BitDlls: %S mapped in at %p, size %p\n", DllsToMapList[c], DllsToMap[c].DllBase, DllsToMap[c].Length));
   }
   return STATUS_SUCCESS;

cleanup:
   
   if (NULL != BaseAddress) {
       NtUnmapViewOfSection(NtCurrentProcess(),
                            BaseAddress);
   }

   if (INVALID_HANDLE_VALUE != SectionHandle) {
       NtClose(SectionHandle);
   }

CleanupLoop:
   for(c=0;c<sizeof(DllsToMapList)/sizeof(DllsToMapList[0]);c++) {
       if (NULL != DllsToMap[c].DllBase) {
           RegionSize = 0;
           NtFreeVirtualMemory(NtCurrentProcess(),
                               &DllsToMap[c].DllBase,
                               &RegionSize,
                               MEM_RELEASE);
           DllsToMap[c].DllBase = NULL;
       }
   }

   return Status;
}

VOID
Wow64pBreakPoint(
    VOID
    )
/*++

Routine Description:

    This function is remote called to after a successful debug attach. Its
    purpose is to issue a breakpoint and then simulate 64-bit
    kernel32!ExitThread.
    
Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE DebugPort;
    NTSTATUS Status;

    DebugPort = (HANDLE)NULL;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDebugPort,
                (PVOID)&DebugPort,
                sizeof(DebugPort),
                NULL
                );

    if (NT_SUCCESS(Status) && DebugPort)
    {
        DbgBreakPoint();
    }
    
    Wow64ExitThread(NtCurrentThread(), 0);
}

VOID
Run64IfContextIs64(
    IN PCONTEXT Context,
    IN BOOLEAN IsFirstThread
    )
/*++

Routine Description:

    Called early in Wow64LdrpInitialize.  This routine checks the initial
    64-bit CONTEXT record, and if it looks like the new thread should be run
    as 64-bit (ie. without emulation), then this routine runs the 64-bit
    CONTEXT and terminates the thread/process.  If the initial CONTEXT
    appears to be one that should be run as 32-bit, then it returns back to
    its caller, and the caller must convert the CONTEXT to 32-bit and
    simulate it.

Arguments:

    Context                 - 64bit initial context for this thread.
    IsFirstThread           - TRUE for the initial thread in the process, FALSE
                              for all other threads.

Return Value:

    None - Runs context if context is 64bit.  Otherwise, return.
    
--*/
{    
    PLDR_DATA_TABLE_ENTRY Entry;
    PLDR_DATA_TABLE_ENTRY32 Entry32;
    PPEB_LDR_DATA32 Data32;
    ULONG64 InitialPC;
    NTSTATUS Status;
    LIST_ENTRY *NtDllEntry;
    int i;

#if defined(_AMD64_)
    InitialPC = Context->Rbx;
#elif defined(_IA64_)
    InitialPC = Context->IntS1;
#else
#error "No Target Architeture"
#endif   

    // Try to match the InitialPC with 64-bit ntdll.dll.  64-bit ntdll.dll
    // is the second entry in the InLoadOrderModuleList.
    NtDllEntry = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink->Flink;
    Entry = CONTAINING_RECORD(NtDllEntry, 
                              LDR_DATA_TABLE_ENTRY, 
                              InLoadOrderLinks);
    // Just put this statement in the code so this structure is loaded
    // in the .pdb file for debugging.
    Entry32 =  CONTAINING_RECORD(NtDllEntry,
                                 LDR_DATA_TABLE_ENTRY32,
                                 InLoadOrderLinks);
    Data32 = (PPEB_LDR_DATA32) NtCurrentPeb()->Ldr;
    
    if (InitialPC >= (ULONG64)Entry->DllBase &&
        InitialPC < (ULONG64)((PCHAR)Entry->DllBase + Entry->SizeOfImage))  {

        // The address is within 64-bit ntdll.dll.  Run the 64-bit function directly

#if defined(_AMD64_)
       // ****** fixfix ******
#elif defined(_IA64_)                                     
        Context->IntGp = ((PPLABEL_DESCRIPTOR)Context->IntS0)->GlobalPointer;
        Context->StIIP = ((PPLABEL_DESCRIPTOR)Context->IntS0)->EntryPoint;
        if (Context->StIPSR & IPSR_RI_MASK) { 
            LOGPRINT((ERRORLOG, "Warning!  IPSR has nonzero slot #.  Slot# is %d\n",(Context->StIPSR >> PSR_RI) & 3));
            Context->StIPSR &= ~IPSR_RI_MASK;
        }
#else
#error "No Target Architeture"
#endif
        LOGPRINT((TRACELOG, "InitialPC %p is within 64-bit ntdll.dll.  Running 64-bit context unchanged.\n", InitialPC));
        goto runcontext64;

    }

    // Check if the address is within one of the address-space holes reserved
    // for 64-bit kernel32 and user32.
    for (i=0; i<sizeof(DllsToMapList)/sizeof(DllsToMapList[0]); ++i) {
        if (InitialPC >= (ULONG64)DllsToMap[i].DllBase && 
            InitialPC < (ULONG64)DllsToMap[i].DllBase+DllsToMap[i].Length) {
            // The InitialPC is inside one of the reserved holes
            if (MapContextAddress64TO32((ULONG)InitialPC) == InitialPC) {
                // The InitialPC is not one that we special-case by converting
                // into a call to the 32-bit DLL.  It may be kernel32!DebugBreak
                // or some other routine.
                LOGPRINT((TRACELOG, "InitialPC %p found in the space reserved for 64-bit %wZ.", InitialPC, DllsToMapList[i]));
#if defined(_AMD64_)
    // ****** fixfix ******
#elif defined(_IA64_)
                Context->IntGp = ((PPLABEL_DESCRIPTOR)Wow64pBreakPoint)->GlobalPointer;
                Context->StIIP = ((PPLABEL_DESCRIPTOR)Wow64pBreakPoint)->EntryPoint;
                if (Context->StIPSR & IPSR_RI_MASK) { 
                    LOGPRINT((ERRORLOG, "Warning!  IPSR has nonzero slot #.  Slot# is %d\n",(Context->StIPSR >> PSR_RI) & 3));
                    Context->StIPSR &= ~IPSR_RI_MASK;
                }
#else
#error "No Target Architecture"
#endif                
                goto runcontext64;
            }
        }
    }

    // The initial context should be run as 32-bit
    return;

runcontext64:
    Status = NtContinue(Context, TRUE);
    WOWASSERT(!NT_SUCCESS(Status));
    if (IsFirstThread) {
       NtTerminateProcess(NtCurrentProcess(), Status);
    } else {
       NtTerminateThread(NtCurrentThread(), Status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\thread.c ===
/*++                 

Copyright (c) 1998 Microsoft Corporation

Module Name:

    thread.c

Abstract:
    
    Infrastructure for 32-bit code creating and manipulating threads

Author:

    17-Aug-1998 BarryBo - split out from wow64.c

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbasep.h>
#include "wow64p.h"
#include "wow64cpu.h"
#include "nt32.h"
#include "thnkhlpr.h"
#include "stdio.h"

ASSERTNAME;

SIZE_T Wow64MaximumStackSize = 384 * 1024;  // 384K is wow stack requirement
SIZE_T Wow64CommittedStackSize = 1024 * 32; // 32k

HANDLE SuspendThreadMutant;


WOW64DLLAPI
NTSTATUS
Wow64WriteTeb32(
   IN HANDLE ProcessHandle,
   IN HANDLE ThreadHandle,
   IN PINITIAL_TEB InitialTeb,
   IN ULONG pPeb32,
   OUT PTEB32 * NewTeb32 OPTIONAL
   )
/*++

Routine Description:

    Updates a 32-bit TEB by cloning the 64-bit TEB for the thread.

Arguments:

    ProcessHandle   - process to create the Teb in
    ThreadHandle    - thread to create the Teb for
    InitialTeb      - 64-bit initial Teb values
    pPeb32          - 32-bit pointer to 32-bit PEB in the remote process
    NewTeb32        - OUT ptr to new 32-bit TEB

Return Value:

    NTSTATUS.  On success, the teb64 for the thread points to the teb32.

--*/
{
    THREAD_BASIC_INFORMATION ThreadInfo;
    PTEB pTeb64;
    PTEB32 pTeb32;
    TEB32 Teb32;
    TEB Teb64;
    NTSTATUS Status;



    //
    // Update the target thread's 32-bit TEB
    //

    Status = NtQueryInformationThread (ThreadHandle,
                                       ThreadBasicInformation,
                                       &ThreadInfo,
                                       sizeof(THREAD_BASIC_INFORMATION),
                                       NULL
                                       );

    if (!NT_SUCCESS (Status)) 
    {
        return Status;
    }

    pTeb64 = ThreadInfo.TebBaseAddress;
    Status = NtReadVirtualMemory (ProcessHandle,
                                  pTeb64,
                                  &Teb64,
                                  sizeof (Teb64),
                                  NULL
                                  );
    if (!NT_SUCCESS (Status)) 
    {
        return Status;
    }

    pTeb32 = (PTEB32) WOW64_GET_TEB32 (&Teb64);
   
    //
    // Read the 32-bit TEB as initialized in ntos\mm\procsup.c
    //

    Status = NtReadVirtualMemory(ProcessHandle,
                                 pTeb32,
                                 &Teb32,
                                 sizeof (Teb32),
                                 NULL
                                 );

    if (!NT_SUCCESS (Status))
    {
        return Status;
    }

    //
    // Update the 32-bit TEB with the 32-bit stack information
    //

    Teb32.NtTib.StackBase = PtrToUlong (InitialTeb->StackBase);
    Teb32.NtTib.StackLimit = PtrToUlong (InitialTeb->StackLimit);
    Teb32.DeallocationStack = PtrToUlong (InitialTeb->StackAllocationBase);


    //
    // Write the 32-bit TEB into the process
    //

    Status = NtWriteVirtualMemory (ProcessHandle,
                                   pTeb32,
                                   &Teb32,
                                   sizeof (Teb32),
                                   NULL);

    if ((NT_SUCCESS( Status )) && (NewTeb32 != NULL)) 
    {
        *NewTeb32 = pTeb32;
    }

    return Status;

}


NTSTATUS
Wow64CreateStack64(
    IN HANDLE Process,
    IN SIZE_T MaximumStackSize,
    IN SIZE_T CommittedStackSize,
    OUT PINITIAL_TEB InitialTeb
    )
/*++

Routine Description:

    Create a 64-bit stack for a new thread created from 32-bit code.

Arguments:

    Process             - process to create the Teb in
    MaximumStackSize    - size of memory to reserve for the stack
    CommittedStackSize  - size to commit for the stack
    InitialTeb          - OUT 64-bit initial Teb values

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status;
    PCH Stack;
    SYSTEM_BASIC_INFORMATION SysInfo;
    BOOLEAN GuardPage;
    SIZE_T RegionSize;
    ULONG OldProtect;
#if defined(_IA64_)
    PCH Bstore;
    SIZE_T CommittedBstoreSize;
    SIZE_T MaximumBstoreSize;
    SIZE_T MstackPlusBstoreSize;
#endif

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       (PVOID)&SysInfo,
                                       sizeof( SysInfo ),
                                       NULL
                                     );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
        }

    //
    // For WOW64, make sure the 64-bit stack is at least as big as
    // what is needed to run the wow64 code
    //
    if (MaximumStackSize < Wow64MaximumStackSize) {
        MaximumStackSize = Wow64MaximumStackSize;
    }

    if (CommittedStackSize < Wow64CommittedStackSize) {
        CommittedStackSize = Wow64CommittedStackSize;
    }

    if ( CommittedStackSize >= MaximumStackSize ) {
        MaximumStackSize = ROUND_UP(CommittedStackSize, (1024*1024));
        }


    CommittedStackSize = ROUND_UP( CommittedStackSize, SysInfo.PageSize );
    MaximumStackSize = ROUND_UP( MaximumStackSize,
                                 SysInfo.AllocationGranularity
                               );

    Stack = NULL,

#if defined(_IA64_)

    //
    // Piggyback the backing store with the memory stack
    //

    CommittedBstoreSize = CommittedStackSize;
    MaximumBstoreSize = MaximumStackSize;
    MstackPlusBstoreSize = MaximumBstoreSize + MaximumStackSize;

    Status = NtAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      0,
                                      &MstackPlusBstoreSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
#else

    Status = NtAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      0,
                                      &MaximumStackSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
#endif // defined(_IA64_)

    if ( !NT_SUCCESS( Status ) ) {
        LOGPRINT((ERRORLOG, "Wow64CreateStack64( %lx ) failed.  Stack Reservation Status == %X\n",
                  Process,
                  Status
                ));
        return( Status );
        }

#if defined(_IA64_)
    InitialTeb->OldInitialTeb.OldBStoreLimit = NULL;
#endif // defined(_IA64_)

    InitialTeb->OldInitialTeb.OldStackBase = NULL;
    InitialTeb->OldInitialTeb.OldStackLimit = NULL;
    InitialTeb->StackAllocationBase = Stack;
    InitialTeb->StackBase = Stack + MaximumStackSize;

    Stack += MaximumStackSize - CommittedStackSize;
    if (MaximumStackSize > CommittedStackSize) {
        Stack -= SysInfo.PageSize;
        CommittedStackSize += SysInfo.PageSize;
        GuardPage = TRUE;
        }
    else {
        GuardPage = FALSE;
        }
    Status = NtAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      0,
                                      &CommittedStackSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    InitialTeb->StackLimit = Stack;

    if ( !NT_SUCCESS( Status ) ) {
        LOGPRINT((ERRORLOG, "Wow64CreateStack64( %lx ) failed.  Stack Commit Status == %X\n",
                  Process,
                  Status
                ));
        return( Status );
        }

    //
    // if we have space, create a guard page.
    //

    if (GuardPage) {
        RegionSize =  SysInfo.PageSize;
        Status = NtProtectVirtualMemory( Process,
                                         (PVOID *)&Stack,
                                         &RegionSize,
                                         PAGE_GUARD | PAGE_READWRITE,
                                         &OldProtect);


        if ( !NT_SUCCESS( Status ) ) {
            LOGPRINT(( ERRORLOG, "Wow64CreateStack( %lx ) failed.  Guard Page Creation Status == %X\n",
                      Process,
                      Status
                    ));
            return( Status );
            }
#if defined(_IA64_)
        InitialTeb->StackLimit = (PVOID)((PUCHAR)InitialTeb->StackLimit + RegionSize);
#else
        InitialTeb->StackLimit = (PVOID)((PUCHAR)InitialTeb->StackLimit - RegionSize);
#endif // defined(_IA64_)
        }

#if defined(_IA64_)

    //
    // Commit backing store pages and create guard pages if there is space
    //

    Bstore = InitialTeb->StackBase;
    if (MaximumBstoreSize > CommittedBstoreSize) {
        CommittedBstoreSize += SysInfo.PageSize;
        GuardPage = TRUE;
    } else {
        GuardPage = FALSE;
    }

    Status = NtAllocateVirtualMemory( Process,
                                      (PVOID *)&Bstore,
                                      0,
                                      &CommittedBstoreSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );

    InitialTeb->BStoreLimit = Bstore + CommittedBstoreSize;

    if ( !NT_SUCCESS(Status) ) {
        LOGPRINT((ERRORLOG, "Wow64CreateStack64( %lx ) failed. Backing Store Commit Status == %X\n",
                 Process,
                 Status
                ));
        return (Status);
    }

    if (GuardPage) {
        Bstore = (PCH)InitialTeb->BStoreLimit - SysInfo.PageSize;
        RegionSize = SysInfo.PageSize;
        Status = NtProtectVirtualMemory(Process,
                                        (PVOID *)&Bstore,
                                        &RegionSize,
                                        PAGE_GUARD | PAGE_READWRITE,
                                        &OldProtect
                                       );
        if ( !NT_SUCCESS(Status) ) {
            LOGPRINT((ERRORLOG, "Wow64CreateStack64.  Backing Store Guard Page Creation Status == %X\n",
                     Process,
                     Status
                    ));
            return (Status);
        }
        InitialTeb->BStoreLimit = (PVOID)((PUCHAR)InitialTeb->BStoreLimit - RegionSize);
    }

#endif // defined(_IA64_)

    return( STATUS_SUCCESS );
}


NTSTATUS
Wow64FreeStack64(
    IN HANDLE Process,
    IN PINITIAL_TEB InitialTeb
    )
/*++

Routine Description:

    Free a 64-bit stack

Arguments:

    Process             - process to create the Teb in
    InitialTeb          - OUT 64-bit initial Teb values

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status;
    SIZE_T Zero;

    Zero = 0;
    Status = NtFreeVirtualMemory( Process,
                                  &InitialTeb->StackAllocationBase,
                                  &Zero,
                                  MEM_RELEASE
                                );
    if ( !NT_SUCCESS( Status ) ) {
        LOGPRINT((ERRORLOG, "Wow64FreeStack64( %lx ) failed: Stack DeCommit Status == %X\n", 
                  Process, Status));
        return( Status );
    }

    RtlZeroMemory( InitialTeb, sizeof( *InitialTeb ) );
    return( STATUS_SUCCESS );
}



NTSTATUS
ReadProcessParameters32(
    HANDLE ProcessHandle,
    ULONG ProcessParams32Address,
    struct NT32_RTL_USER_PROCESS_PARAMETERS **pProcessParameters32
    )
{
    NTSTATUS Status;
    ULONG Length;
    struct NT32_RTL_USER_PROCESS_PARAMETERS *ProcessParameters32;
    PVOID Base;

    // Get the length of the struct
    Status = NtReadVirtualMemory(ProcessHandle,
                                 (PVOID)(ProcessParams32Address + sizeof(ULONG)),
                                 &Length,
                                 sizeof(Length),
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    ProcessParameters32 = Wow64AllocateHeap(Length);
    if (!ProcessParameters32) {
        return STATUS_NO_MEMORY;
    }

    Base = (PVOID)ProcessParams32Address;
    Status = NtReadVirtualMemory(ProcessHandle,
                                 Base,
                                 ProcessParameters32,
                                 Length,
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        Wow64FreeHeap(ProcessParameters32);
        return Status;
    }

    *pProcessParameters32 = ProcessParameters32;
    return STATUS_SUCCESS;
}


NTSTATUS
ThunkProcessParameters32To64(
    IN HANDLE ProcessHandle,
    IN struct NT32_RTL_USER_PROCESS_PARAMETERS *ProcessParameters32
    )
/*++

Routine Description:

    Given a denormalized 32-bit PRTL_USER_PROCESS_PARAMETERS, allocate
    a 64-bit version and thunk the 32-bit values over.

Arguments:

    ProcessHandle       - IN target process handle
    ProcessParameters32 - IN 32-bit parameters

Return Value:

    NTSTATUS.

--*/
{
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PRTL_USER_PROCESS_PARAMETERS ParametersInNewProcess=NULL;
    NTSTATUS Status;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING DllPath;
    UNICODE_STRING CurrentDirectory;
    UNICODE_STRING CommandLine;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    SIZE_T RegionSize;
    PROCESS_BASIC_INFORMATION pbi;
    PPEB pPeb64;

    //
    // The ProcessParameters struct is denormalized, so the
    // UNICODE_STRING Buffers are really just offsets in the
    // struct.  Normalize them to be pointers in our process.
    //

#define NormalizeString32(s, Base)              \
    if (s) {                                    \
        s = ((ULONG)(s) + PtrToUlong(Base));    \
    }

    NormalizeString32(ProcessParameters32->ImagePathName.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->DllPath.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->CommandLine.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->WindowTitle.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->DesktopInfo.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->ShellInfo.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->RuntimeData.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->CurrentDirectory.DosPath.Buffer,
                      ProcessParameters32);

    //
    // Thunk the bits and bobs back to 64-bit
    //
    Wow64ShallowThunkUnicodeString32TO64(&ImagePathName,
                                         &ProcessParameters32->ImagePathName);
    Wow64ShallowThunkUnicodeString32TO64(&DllPath,
                                         &ProcessParameters32->DllPath);
    Wow64ShallowThunkUnicodeString32TO64(&CommandLine,
                                         &ProcessParameters32->CommandLine);
    Wow64ShallowThunkUnicodeString32TO64(&WindowTitle,
                                         &ProcessParameters32->WindowTitle);
    Wow64ShallowThunkUnicodeString32TO64(&DesktopInfo,
                                         &ProcessParameters32->DesktopInfo);
    Wow64ShallowThunkUnicodeString32TO64(&ShellInfo,
                                         &ProcessParameters32->ShellInfo);
    Wow64ShallowThunkUnicodeString32TO64(&CurrentDirectory,
                                         &ProcessParameters32->CurrentDirectory.DosPath);

    if (ProcessParameters32->RuntimeData.Length &&
        ProcessParameters32->RuntimeData.Buffer) {
        //
        // See wow64\init.c's Wow64pThunkProcessParameters for details...
        //
        int cfi_len = *(UNALIGNED int *)ProcessParameters32->RuntimeData.Buffer;
        char *posfile32 = (char *)((UINT_PTR)ProcessParameters32->RuntimeData.Buffer+sizeof(int));
        UINT UNALIGNED *posfhnd32 = (UINT UNALIGNED *)(posfile32 + cfi_len);
        char *posfile64;
        UINT_PTR UNALIGNED *posfhnd64;
        int i;

        RuntimeData.Length = ProcessParameters32->RuntimeData.Length + sizeof(ULONG)*cfi_len;
        RuntimeData.MaximumLength = RuntimeData.Length;
        RuntimeData.Buffer = (LPWSTR)_alloca(RuntimeData.Length);

        posfile64 = (char *)( (ULONG_PTR)RuntimeData.Buffer + sizeof(int));
        posfhnd64 = (UINT_PTR UNALIGNED *)(posfile64 + cfi_len);

        *(int *)RuntimeData.Buffer = cfi_len;
        for (i=0; i<cfi_len; ++i) {
            // Use LongToPtr in order to sign-extend INVALID_FILE_HANDLE if
            // needed, from 32-bit to 64.
            *posfile64 = *posfile32;
            *posfhnd64 = (UINT_PTR)LongToPtr(*posfhnd32);
            posfile32++;
            posfile64++;
            posfhnd32++;
            posfhnd64++;
        }

        // Any bytes past the end of 4+(cfi_len*(sizeof(UINT_PTR)+sizeof(UINT))
        // must be copied verbatim.  They are probably from a non-MS C runtime.
        memcpy(posfhnd64, posfhnd32, (ProcessParameters32->RuntimeData.Length - ((ULONG_PTR)posfhnd32 - (ULONG_PTR)ProcessParameters32->RuntimeData.Buffer)));

    } else {
        RuntimeData.Length = RuntimeData.MaximumLength = 0;
        RuntimeData.Buffer = NULL;
    }

    //
    // Create a new 64-bit process parameters in denormalized form
    //
    Status = RtlCreateProcessParameters(&ProcessParameters,
                                        &ImagePathName,
                                        &DllPath,
                                        &CurrentDirectory,
                                        &CommandLine,
                                        NULL,   // no environment yet
                                        &WindowTitle,
                                        &DesktopInfo,
                                        &ShellInfo,
                                        &RuntimeData);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Thunk the rest of the fields.
    //
    ProcessParameters->DebugFlags =
        ProcessParameters32->DebugFlags;
    ProcessParameters->ConsoleHandle =
        (HANDLE)ProcessParameters32->ConsoleHandle;
    ProcessParameters->ConsoleFlags =
        ProcessParameters32->ConsoleFlags;
    ProcessParameters->StandardInput =
        (HANDLE)ProcessParameters32->StandardInput;
    ProcessParameters->StandardOutput =
        (HANDLE)ProcessParameters32->StandardOutput;
    ProcessParameters->StandardError =
        (HANDLE)ProcessParameters32->StandardError;
    ProcessParameters->Environment =
        (PVOID)ProcessParameters32->Environment;
    ProcessParameters->StartingX =
        ProcessParameters32->StartingX;
    ProcessParameters->StartingY =
        ProcessParameters32->StartingY;
    ProcessParameters->CountX =
        ProcessParameters32->CountX;
    ProcessParameters->CountY =
        ProcessParameters32->CountY;
    ProcessParameters->CountCharsX =
        ProcessParameters32->CountCharsX;
    ProcessParameters->CountCharsY =
        ProcessParameters32->CountCharsY;
    ProcessParameters->FillAttribute =
        ProcessParameters32->FillAttribute;
    ProcessParameters->WindowFlags =
        ProcessParameters32->WindowFlags;
    ProcessParameters->ShowWindowFlags =
        ProcessParameters32->ShowWindowFlags;

    //
    // RtlCreateProcessParameters fills this in, but not correctly
    // if the process is being created without bInheritHandles.
    // Clean up now by grabbing the 32-bit directory handle.
    //
    ProcessParameters->CurrentDirectory.Handle =
        (HANDLE)ProcessParameters32->CurrentDirectory.Handle;

    //
    // Allocate space in the new process and copy the params in
    //
    RegionSize = ProcessParameters->Length;
    Status = NtAllocateVirtualMemory(ProcessHandle,
                                     &ParametersInNewProcess,
                                     0,
                                     &RegionSize,
                                     MEM_COMMIT,
                                     PAGE_READWRITE
                                    );
    if (!NT_SUCCESS(Status)) {
        goto DoFail;
    }
    ProcessParameters->MaximumLength = (ULONG)RegionSize;

    Status = NtWriteVirtualMemory(ProcessHandle,
                                  ParametersInNewProcess,
                                  ProcessParameters,
                                  ProcessParameters->Length,
                                  NULL
                                 );
    if (!NT_SUCCESS(Status)) {
        goto DoFail;
    }

    //
    // Update the peb64->processParameters
    //
    Status = NtQueryInformationProcess(ProcessHandle,
                                       ProcessBasicInformation,
                                       &pbi,
                                       sizeof(pbi),
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        goto DoFail;
    }

    pPeb64 = (PPEB)pbi.PebBaseAddress;
    Status = NtWriteVirtualMemory(ProcessHandle,
                                  &pPeb64->ProcessParameters,
                                  &ParametersInNewProcess,
                                  sizeof(ParametersInNewProcess),
                                  NULL
                                 );
    if (!NT_SUCCESS(Status)) {
        goto DoFail;
    }

DoFail:
    //
    // On error, there's no need to free the processparameters from the
    // target process.  The 32-bit code which calls this via
    // NtCreateThread() will terminate the process for us.
    //
    RtlDestroyProcessParameters(ProcessParameters);
    return Status;
}


WOW64DLLAPI
NTSTATUS
Wow64NtCreateThread(
   OUT PHANDLE ThreadHandle, 
   IN ACCESS_MASK DesiredAccess,
   IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
   IN HANDLE ProcessHandle,
   OUT PCLIENT_ID ClientId,
   IN PCONTEXT ThreadContext,   // this is really a PCONTEXT32
   IN PINITIAL_TEB InitialTeb,
   IN BOOLEAN CreateSuspended
   )
/*++

Routine Description:

    Create a 32-bit thread.  The 32-bit caller has already created
    the 32-bit stack, so this function needs to create a 64-bit stack
    and the 64-bit context required for starting up a thread.

Arguments:

    << same as NtCreateThread >>

Return Value:

    NTSTATUS.

--*/
{

    NTSTATUS Status;
    INITIAL_TEB InitialTeb64;
    BOOLEAN StackCreated = FALSE;
    BOOLEAN ThreadCreated = FALSE;
    PCONTEXT32 pContext32 = (PCONTEXT32)ThreadContext;
    CONTEXT Context64;
    ULONG_PTR Wow64Info;
    struct NT32_RTL_USER_PROCESS_PARAMETERS *ProcessParameters32 = NULL;
    PEB32 Peb32;
    PVOID Base;
    CHILD_PROCESS_INFO ChildInfo;
    PVOID Ldr;

    if (NULL == ThreadHandle || NULL == InitialTeb ||
        NULL == ThreadContext) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = NtQueryInformationProcess(ProcessHandle,
                                       ProcessWow64Information,
                                       &Wow64Info,
                                       sizeof(Wow64Info),
                                       NULL
                                      );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Wow64Info) {
        //
        // Process is 32-bit.
        //
        ChildInfo.pPeb32 = (PPEB32)Wow64Info;

    } else {
        // process is 64-bit.  
        PROCESS_BASIC_INFORMATION pbi;

        // get the process basic information on the process
        Status = NtQueryInformationProcess(
           ProcessHandle,
           ProcessBasicInformation,
           &pbi,
           sizeof(pbi),
           NULL);

        if (!NT_SUCCESS(Status)) 
        {
           return STATUS_ACCESS_DENIED;
        }
         
        // read the child info struct, it contains a pointer to the PEB32
        Status = NtReadVirtualMemory(ProcessHandle,
                                     ((BYTE*)pbi.PebBaseAddress) + PAGE_SIZE - sizeof(ChildInfo),
                                     &ChildInfo,
                                     sizeof(ChildInfo),
                                     NULL);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        
        if ((ChildInfo.Signature != CHILD_PROCESS_SIGNATURE) ||
            (ChildInfo.TailSignature != CHILD_PROCESS_SIGNATURE)) {
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // Read the PEB32 from the process
    //
    Status = NtReadVirtualMemory(ProcessHandle,
                                 ChildInfo.pPeb32,
                                 &Peb32,
                                 sizeof(PEB32),
                                 NULL);
    
    if (!NT_SUCCESS(Status)) {
        return Status;
    }


    if (!Wow64Info) {
        //
        // The target process is 64-bit but was created by a 32-bit app
        //
        SIZE_T RegionSize;

        //
        // Read in the 32-bit ProcessParameters then free them
        //
        if (Peb32.ProcessParameters) {
            Status = ReadProcessParameters32(ProcessHandle,
                                             Peb32.ProcessParameters,
                                             &ProcessParameters32);
            if (!NT_SUCCESS(Status)) {
                goto DoFail;
            }

            RegionSize = 0;
            Base = (PVOID)Peb32.ProcessParameters;
            Status = NtFreeVirtualMemory(ProcessHandle,
                                         &Base,
                                         &RegionSize,
                                         MEM_RELEASE
                                        );
            WOWASSERT(NT_SUCCESS(Status));
        }

        //
        // Create a 64-bit stack with the size info from the image section
        //
        Status = Wow64CreateStack64(ProcessHandle,
                                    ChildInfo.ImageInformation.CommittedStackSize,
                                    ChildInfo.ImageInformation.MaximumStackSize,
                                    &InitialTeb64
                                   );
        if (!NT_SUCCESS(Status)) {
            goto DoFail;
        }
        StackCreated = TRUE;


        SetProcessStartupContext64(&Context64,
                                   ProcessHandle,
                                   pContext32, 
                                   (ULONGLONG)InitialTeb64.StackBase, 
                                   (ULONGLONG)ChildInfo.ImageInformation.TransferAddress);

        //
        // Thunk the processparameters up to 64-bit
        //
        if (ProcessParameters32) {
            Status = ThunkProcessParameters32To64(ProcessHandle,
                                                  ProcessParameters32);
            if (!NT_SUCCESS(Status)) {
                goto DoFail;
            }
        }

        Status = NtCreateThread(ThreadHandle,
                                DesiredAccess,
                                ObjectAttributes,
                                ProcessHandle,
                                ClientId,
                                &Context64,
                                &InitialTeb64,
                                CreateSuspended
                               );
        if (!NT_SUCCESS(Status)) {
            goto DoFail;
        }

        return STATUS_SUCCESS;
    } else {
        //
        // The target process is 32-bit.  Create a 64-bit stack for
        // wow64 to use.  The reserve/commit sizes come from globals
        // in wow64 instead of the image because we won't want to inherit
        // some tiny values from a highly-tuned app.
        //
        Status = Wow64CreateStack64(ProcessHandle,
                                    Wow64MaximumStackSize,
                                    Wow64CommittedStackSize,
                                    &InitialTeb64
                                   );

        if(!NT_SUCCESS(Status)) {
            LOGPRINT((ERRORLOG, "Wow64NtCreateThread: Couldn't create 64bit stack, Status %x\n", Status));
            return Status;
        }
        StackCreated = TRUE;

        if (Peb32.ProcessParameters) {
            PROCESS_BASIC_INFORMATION pbi;
            PPEB pPeb64;
            ULONG_PTR ParametersInNewProcess;

            //
            // If the process has no 64-bit parameters, then this is
            // the first 32-bit thread in a 64-bit process and needs
            // the parameters thunked up to 64-bit.
            //
            Status = NtQueryInformationProcess(ProcessHandle,
                                               ProcessBasicInformation,
                                               &pbi,
                                               sizeof(pbi),
                                               NULL);
            if (!NT_SUCCESS(Status)) {
               goto DoFail;
            }

            pPeb64 = (PPEB)pbi.PebBaseAddress;
            Status = NtReadVirtualMemory(ProcessHandle,
                                         &pPeb64->ProcessParameters,
                                         &ParametersInNewProcess,
                                         sizeof(ParametersInNewProcess),
                                         NULL
                                        );
            if (!NT_SUCCESS(Status)) {
                goto DoFail;
            }

            if (!ParametersInNewProcess) {
                Status = ReadProcessParameters32(ProcessHandle,
                                                 Peb32.ProcessParameters,
                                                 &ProcessParameters32);
                if (!NT_SUCCESS(Status)) {
                    goto DoFail;
                }

                Status = ThunkProcessParameters32To64(ProcessHandle,
                                                  ProcessParameters32);
                if (!NT_SUCCESS(Status)) {
                    goto DoFail;
                }
            }
        }

        ThunkContext32TO64(pContext32,
                           &Context64,
                           (ULONGLONG)InitialTeb64.StackBase);

        Status = NtCreateThread(ThreadHandle,
                                DesiredAccess,
                                ObjectAttributes,
                                ProcessHandle,
                                ClientId,
                                &Context64,
                                &InitialTeb64,
                                TRUE
                               );
  
        if (!NT_SUCCESS(Status)) {
            goto DoFail;
        }
   
        ThreadCreated = TRUE;

        //
        // Initialize the 32-bit TEB's fields
        //

        Status = Wow64WriteTeb32 (ProcessHandle,
                                  *ThreadHandle,
                                  InitialTeb,
                                  PtrToUlong( ChildInfo.pPeb32 ),
                                  NULL);

        if (!NT_SUCCESS( Status )) {
            goto DoFail;
        }


        if (!CreateSuspended) {
            Status = NtResumeThread(*ThreadHandle,
                                    NULL
                                   );

            if (!NT_SUCCESS(Status)) {
                goto DoFail;
            }
        }

        return STATUS_SUCCESS;
    }

DoFail:
    if (StackCreated) {
           Wow64FreeStack64(ProcessHandle,
                            &InitialTeb64
                            );
    }

    if (ThreadCreated) {
        NtTerminateThread(*ThreadHandle, 0);
    }

    if (ProcessParameters32) {
        Wow64FreeHeap(ProcessParameters32);
    }

    return Status;
}

NTSTATUS
Wow64ExitThread(
    HANDLE ThreadHandle,
    NTSTATUS ExitStatus
    )
/*++

Routine Description:

    This routine is copied from ExitThread in windows\base\thread.c
    It deletes the 64-bit stack and then calls NtTerminateThread

Arguments:

--*/
{
    MEMORY_BASIC_INFORMATION MemInfo;
    NTSTATUS st;

    st = NtQueryVirtualMemory(
                NtCurrentProcess(),
                NtCurrentTeb()->NtTib.StackLimit,
                MemoryBasicInformation,
                (PVOID)&MemInfo,
                sizeof(MemInfo),
                NULL
                );
    if ( !NT_SUCCESS(st) ) {
        RtlRaiseStatus(st);
        }

#ifdef _ALPHA_
    //
    // Note stacks on Alpha must be octaword aligned. Probably
    // a good idea on other platforms as well.
    //
    Wow64BaseSwitchStackThenTerminate(
            MemInfo.AllocationBase,
            (PVOID)(((ULONG_PTR)&NtCurrentTeb()->User32Reserved[0] - 0x10) & ~0xf),
            ExitStatus
            );
#else // _ALPHA
    //
    // Note stacks on i386 need not be octaword aligned.
    //
    Wow64BaseSwitchStackThenTerminate(
            MemInfo.AllocationBase,
            &NtCurrentTeb()->UserReserved[0],
            ExitStatus
            );
#endif // _ALPHA_
    return STATUS_SUCCESS;
}


WOW64DLLAPI
VOID
Wow64BaseFreeStackAndTerminate(
    IN PVOID OldStack,
    IN ULONG ExitCode
    )

/*++

Routine Description:

    This API is called during thread termination to delete a thread's
    stack and then terminate.

Arguments:

    OldStack - Supplies the address of the stack to free.

    ExitCode - Supplies the termination status that the thread
        is to exit with.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    SIZE_T Zero;
    PVOID BaseAddress;

    Zero = 0;
    BaseAddress = OldStack;

    Status = NtFreeVirtualMemory(
                NtCurrentProcess(),
                &BaseAddress,
                &Zero,
                MEM_RELEASE
                );
    ASSERT(NT_SUCCESS(Status));

    //
    // Don't worry, no commenting precedent has been set by SteveWo.  this
    // comment was added by an innocent bystander.
    //
    // NtTerminateThread will return if this thread is the last one in
    // the process.  So ExitProcess will only be called if that is the
    // case.
    //

    NtTerminateThread(NULL,(NTSTATUS)ExitCode);
    //
    // We will only get here if we snuck past the LastThread check in
    // kernel32!ExitThread. Regular kernel32 crashes attempting to call
    // ExitProcess() so we won't even bother... we'll just go straight to 
    // the crash as we fall off the stack
    //
}

NTSTATUS
WOW64DLLAPI
Wow64NtTerminateThread(
    HANDLE ThreadHandle,
    NTSTATUS ExitStatus
    )
/*++

Routine Description:

    Teminate a thread. If we were called from Kernel32!ExitThread
    then the 32-bit stack should already be gone. In this case we'll
    free the 64-bit stack as well.

Arguments:

    same as NtTerminateThread

--*/
{
    PTEB32 Teb32;
    SIZE_T Zero;
    PVOID StackBase;

    //
    // Check if we need to free the 32-bit stack
    //
    if (ThreadHandle == NULL) {
        
        CpuThreadTerm();

        Teb32 = NtCurrentTeb32();
        if (Teb32->FreeStackOnTermination) {
            
            Zero = 0;
            StackBase = UlongToPtr (Teb32->DeallocationStack);
            NtFreeVirtualMemory(NtCurrentProcess(),
                                &StackBase,
                                &Zero,
                                MEM_RELEASE);

            NtCurrentTeb()->FreeStackOnTermination = Teb32->FreeStackOnTermination;
        }
    }

    return NtTerminateThread(ThreadHandle, ExitStatus);
}

NTSTATUS
WOW64DLLAPI
Wow64QueryBasicInformationThread(
    IN HANDLE Thread,
    OUT PTHREAD_BASIC_INFORMATION ThreadInfo
    )
/*++

Routine Description:

    whNtQueryInformationFromThread calls this for ThreadBasicInformation.
    The TEB pointer in the basic information needs to be the TEB32 pointer.

Arguments:

    Thread      - thread to query
    ThreadInfo  - OUT pointer to 64-bit THREAD_BASIC_INFORMATION struct

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status, QIStatus; 
    HANDLE Process;
    PTEB32 Teb32;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN GotProcessHandle = FALSE;
    PVOID Wow64Info;

    QIStatus = NtQueryInformationThread(Thread,
                                        ThreadBasicInformation,
                                        (PVOID)ThreadInfo,
                                        sizeof(THREAD_BASIC_INFORMATION),
                                        NULL
                                        );

    if (!NT_SUCCESS(QIStatus)) {
       return QIStatus;
    }

    //Thunk the 64bit AffinityMask to the 32bit AffinityMask
    ThreadInfo->AffinityMask = Wow64ThunkAffinityMask64TO32(ThreadInfo->AffinityMask);

    //
    // if the thread is executing inside this process, then let's read the TEB right away
    //
    if ((ThreadInfo->ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) && 
        (ThreadInfo->TebBaseAddress != NULL)) {

        ThreadInfo->TebBaseAddress = (PTEB) WOW64_GET_TEB32 (ThreadInfo->TebBaseAddress);
        goto exit;
    }

    // At this point, the TebAddress is for the 64bit TEB.   We need to get the 
    // address of the 32bit TEB.  If this is not a 32bit process, or some other error
    // occures, return a bogus value for the TEB and let the app fail on the 
    // ReadVirtualMemory call.   Do not fail the api after this point.     
   
    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL
                               );

    Status = NtOpenProcess(&Process,
                           PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
                           &ObjectAttributes, //ObjectAttributes
                           &(ThreadInfo->ClientId)
                           );
 
    if (!NT_SUCCESS(Status)) {
        LOGPRINT((TRACELOG, "Wow64QueryInformationThread: NtOpenProcess failed, status %x\n",Status));
        ThreadInfo->TebBaseAddress = NULL;
        goto exit;
    }
  
    GotProcessHandle = TRUE; //Process handle is valid
    
    // Check if this is a 32bit process.

    Status = NtQueryInformationProcess(Process,
                                       ProcessWow64Information,
                                       &Wow64Info,
                                       sizeof(Wow64Info),
                                       NULL);
   
    if (!NT_SUCCESS(Status)) {
        LOGPRINT((TRACELOG, "Wow64QueryInformationThread: NtQueryProcessInformation failed, status %x\n",Status));
        ThreadInfo->TebBaseAddress = NULL;
        goto exit;
    }
    
    if (!Wow64Info) {
        LOGPRINT((TRACELOG, "Wow64QueryInformationThread: The queryied thread is not in a process marked 32bit, returning bogus TEB\n"));
        ThreadInfo->TebBaseAddress = NULL;
        goto exit;        
    }
    
    Status = NtReadVirtualMemory(Process,
                                 WOW64_TEB32_POINTER_ADDRESS(ThreadInfo->TebBaseAddress),
                                 &Teb32,
                                 sizeof(PTEB32),
                                 NULL
                                 );

     if (!NT_SUCCESS(Status)) {
        LOGPRINT((TRACELOG, "Wow64QueryInformationThread: NtReadVirtualMemory failed, status %x\n",Status));
        ThreadInfo->TebBaseAddress = NULL;
        goto exit;
     }
  
     // If the TEB32 hasn't been created yet, the TEB32 address will be a bogus value such
     // as NULL or -1.
     LOGPRINT((TRACELOG, "Wow64QueryInformationThread: TEB32 address %X\n", PtrToUlong(Teb32)));
     ThreadInfo->TebBaseAddress = (PTEB)Teb32;
     
exit:
    if (GotProcessHandle) {
        Status = NtClose(Process);
        WOWASSERT(NT_SUCCESS(Status));
    }

    return QIStatus;

}


NTSTATUS
Wow64pOpenThreadProcess(
    IN HANDLE ThreadHandle,
    IN ULONG DesiredAccess,
    OUT PTEB *Teb OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL,
    OUT PHANDLE ProcessHandle)
/*++

Routine Description:

    Opens the process handle, with the specified attributes, of the specified 
    target thread.

Arguments:

    ThreadHandle   - Handle of target thread
    DesiredAccess  - Supplies the desired types of access for the process to open
    Teb            - Optional pointer to receive the adress of the target thread's TEB
    ClientId       - Pointer to receive the clietn id structure of the target thread
    ProcessHandle  - Pointer to receive process handle 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    THREAD_BASIC_INFORMATION ThreadInformation;

    NtStatus = NtQueryInformationThread(ThreadHandle,
                                        ThreadBasicInformation,
                                        &ThreadInformation,
                                        sizeof( ThreadInformation ),
                                        NULL);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pOpenThreadProcess : failed to query threadinfo %lx-%lx\n",
                  ThreadHandle, NtStatus));
        return NtStatus;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

    NtStatus = NtOpenProcess(ProcessHandle,
                             DesiredAccess,
                             &ObjectAttributes,
                             &ThreadInformation.ClientId);

    if (NT_SUCCESS(NtStatus))
    {
        if (ARGUMENT_PRESENT(ClientId))
        {
            *ClientId = ThreadInformation.ClientId;
        }

        if (ARGUMENT_PRESENT(Teb))
        {
            *Teb = ThreadInformation.TebBaseAddress;
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "Wow64pOpenThreadProcess : failed to open thread (%lx) process -%lx\n",
                  ThreadHandle, NtStatus));

    }

    return NtStatus;
}


NTSTATUS
Wow64pSuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL,
    OUT BOOLEAN *ReleaseSuspendMutant)
/*++

Routine Description:

    Suspend the target 32-bit thread, and optionally returns 
    the previous suspend count.

Arguments:

    ThreadHandle           - Handle of target thread to suspend
    PreviousSuspendCount   - Optional pointer to a value that, if specified, received 
                             the previous suspend count.
    ReleaseSuspendMutant   - Out value to indicate whether the release suspend mutant has
                             already been called.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN CurrentThread;
    PPEB32 Peb32;
    PTEB Teb;
    HANDLE ProcessHandle;
    CLIENT_ID ThreadClientId;
    ULONG LocalSuspendCount;

    
    *ReleaseSuspendMutant = TRUE;
    if (ThreadHandle == NtCurrentThread())
    {
        *ReleaseSuspendMutant = FALSE;
        NtReleaseMutant(SuspendThreadMutant, NULL);
        return NtSuspendThread(ThreadHandle, PreviousSuspendCount);
    }

    NtStatus = Wow64pOpenThreadProcess(ThreadHandle,
                                       (PROCESS_VM_OPERATION | 
                                        PROCESS_VM_READ | 
                                        PROCESS_VM_WRITE | 
                                        PROCESS_QUERY_INFORMATION |
                                        PROCESS_DUP_HANDLE),
                                       &Teb,
                                       &ThreadClientId,
                                       &ProcessHandle);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    NtStatus = NtQueryInformationProcess(ProcessHandle,
                                         ProcessWow64Information,
                                         &Peb32,
                                         sizeof(Peb32),
                                         NULL);
    if (NT_SUCCESS(NtStatus))
    {
        if (Peb32)
        {
            CurrentThread = (ThreadClientId.UniqueThread == 
                             NtCurrentTeb()->ClientId.UniqueThread);

            if (!ARGUMENT_PRESENT(PreviousSuspendCount))
            {
                PreviousSuspendCount = &LocalSuspendCount;
            }
            else
            {
                try
                {
                    *PreviousSuspendCount = *PreviousSuspendCount;
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    PreviousSuspendCount = &LocalSuspendCount;
                }
            }

            if (CurrentThread)
            {
                *ReleaseSuspendMutant = FALSE;
                NtReleaseMutant(SuspendThreadMutant, NULL);
            }

            NtStatus = NtSuspendThread(ThreadHandle,
                                       PreviousSuspendCount);

            if (NT_SUCCESS(NtStatus))
            {
                if ((CurrentThread == FALSE) &&
                    (*PreviousSuspendCount == 0))
                {
                    NtStatus = CpuSuspendThread(ThreadHandle,
                                                ProcessHandle,
                                                Teb,
                                                PreviousSuspendCount);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        LOGPRINT((ERRORLOG, "Wow64SuspendThread : CPU couldn't suspend thread (%lx) -%lx\n",
                                  ThreadHandle, NtStatus));

                        NtResumeThread(ThreadHandle, NULL);
                    }
                }
            }
        }
        else
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "Wow64SuspendThread : failed to query processinfo %lx-%lx\n",
                  ProcessHandle, NtStatus));
    }

    NtClose(ProcessHandle);

    return NtStatus;
}


NTSTATUS
Wow64SuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )
/*++

Routine Description:

    Suspend the target 32-bit thread, and optionally returns 
    the previous suspend count. This routine is access-serialized through
    the SuspendThreadMutant.

Arguments:

    ThreadHandle           - Handle of target thread to suspend
    PreviousSuspendCount   - Optional pointer to a value that, if specified, received 
                             the previous suspend count.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    BOOLEAN ReleaseSuspendMutant;

    NtStatus = NtWaitForSingleObject(SuspendThreadMutant,
                                     FALSE,
                                     NULL);

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = Wow64pSuspendThread(ThreadHandle,
                                       PreviousSuspendCount,
                                       &ReleaseSuspendMutant);

        if (ReleaseSuspendMutant)
        {
            NtReleaseMutant(SuspendThreadMutant, NULL);
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64pContextThreadInformation(
     IN HANDLE ThreadHandle, 
     IN OUT PCONTEXT ThreadContext, // really a PCONTEXT32
     IN BOOLEAN SetContextThread
     )
/*++

Routine Description:

    Get/Set the 32-bit thread context.

Arguments:

    ThreadHandle     - thread to query
    ThreadContext    - OUT ptr to 32-bit context
    SetContextThread - TRUE if to set the thread context, otherwise FALSE.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN CurrentThread;
    PPEB32 Peb32;
    PTEB Teb;
    CLIENT_ID ThreadClientId;
    HANDLE ProcessHandle;
    ULONG PreviousSuspendCount;


    if (NtCurrentThread() == ThreadHandle)
    {
        if (SetContextThread)
        {
            return CpuSetContext(ThreadHandle,
                                 NtCurrentProcess(),
                                 NULL,
                                 (PCONTEXT32)ThreadContext);
        }
        else
        {
            return CpuGetContext(ThreadHandle,
                                 NtCurrentProcess(),
                                 NULL,
                                 (PCONTEXT32)ThreadContext);
        }
    }

    NtStatus = Wow64pOpenThreadProcess(ThreadHandle,
                                       (PROCESS_VM_OPERATION | 
                                        PROCESS_VM_READ | 
                                        PROCESS_VM_WRITE | 
                                        PROCESS_QUERY_INFORMATION |
                                        PROCESS_DUP_HANDLE),
                                       &Teb,
                                       &ThreadClientId,
                                       &ProcessHandle);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    NtStatus = NtQueryInformationProcess(ProcessHandle,
                                         ProcessWow64Information,
                                         &Peb32,
                                         sizeof(Peb32),
                                         NULL);
    if (NT_SUCCESS(NtStatus))
    {
        if (Peb32)
        {
            CurrentThread = (ThreadClientId.UniqueThread == 
                             NtCurrentTeb()->ClientId.UniqueThread);

            if (CurrentThread)
            {
                ThreadHandle = NtCurrentThread();
            }

            if (NT_SUCCESS(NtStatus))
            {
                if (SetContextThread)
                {
                    if (CurrentThread)
                    {
                        LOGPRINT((ERRORLOG, "Thread %lx is trying to change context of itself\n",
                                  ThreadHandle));
                    }
                    else
                    {
                        NtStatus = CpuSetContext(ThreadHandle,
                                                 ProcessHandle,
                                                 Teb,
                                                 (PCONTEXT32)ThreadContext);
                    }
                }
                else
                {
                    NtStatus = CpuGetContext(ThreadHandle,
                                             ProcessHandle,
                                             Teb,
                                             (PCONTEXT32)ThreadContext);

#if defined(_IA64_)
                    // XXX olegk - this is pure hack must be reimplemented!!!
                    if (!NT_SUCCESS(NtStatus)) 
                    {
                        // Probably just creating 32-bit thread, so "fake" the 
                        // context segment selectors specifically for Visual Studio 6
                        PCONTEXT32 FakeContext = (PCONTEXT32)ThreadContext;
                        FakeContext->SegGs = KGDT_R3_DATA|3;
                        FakeContext->SegEs = KGDT_R3_DATA|3;
                        FakeContext->SegDs = KGDT_R3_DATA|3;
                        FakeContext->SegSs = KGDT_R3_DATA|3;
                        FakeContext->SegFs = KGDT_R3_TEB|3;
                        FakeContext->SegCs = KGDT_R3_CODE|3;
                    }
#endif // defined(_IA64_)
                }
            }
        }
        else
        {
            NtStatus = STATUS_NOT_IMPLEMENTED;
            
            LOGPRINT((TRACELOG, "Wow64pContextThreadInformation : Calling %wsContextThread on a 64-bit Thread from a 32-bit context failed -%lx\n",
                      (SetContextThread) ? L"NtSet" : L"NtGet", NtStatus));
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "Wow64pContextThreadInformation : failed to query processinfo %lx-%lx\n",
                  ProcessHandle, NtStatus));
    }

    NtClose(ProcessHandle);

    return STATUS_SUCCESS; 
}


NTSTATUS
Wow64GetContextThread(
     IN HANDLE ThreadHandle, 
     IN OUT PCONTEXT ThreadContext // really a PCONTEXT32
     )
/*++

Routine Description:

    Get the 32-bit thread context.

Arguments:

    ThreadHandle    - thread to query
    ThreadContext   - OUT ptr to 32-bit context

Return Value:

    NTSTATUS.

--*/
{
    return Wow64pContextThreadInformation(ThreadHandle,
                                          ThreadContext,
                                          FALSE);
}


NTSTATUS
Wow64SetContextThread(
     IN HANDLE ThreadHandle,
     IN PCONTEXT ThreadContext  // really a PCONTEXT32
     )
/*++

Routine Description:

    Set the 32-bit thread context.

Arguments:

    ThreadHandle    - thread to query
    ThreadContext   - OUT ptr to 32-bit context

Return Value:

    NTSTATUS.

--*/
{
    return Wow64pContextThreadInformation(ThreadHandle,
                                          ThreadContext,
                                          TRUE);
}



NTSTATUS 
Wow64pCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR *ObjectSD,
    OUT PSID *WorldSidToFree,
    IN ACCESS_MASK AccessMask)
/*++

Routine Description:

    Creates a security descriptor representing EVERYONE to append for a kernel object.

Arguments:

    SecurityDescriptor      - Buffer to receive security descriptor information
    WorldSidToFree          - Address of World SID to free after the kernel object is initialized
    SecurityDescriptorLengh - Security descriptor buffer length
    AccessMask              - Access-allowed rights for the security descriptor

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    PACL AclBuffer;
    ULONG SidLength;
    ULONG SecurityDescriptorLength;
    PSID WorldSid = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_WORLD_SID_AUTHORITY;

    
    //
    //  Create the World (everyone) SID
    //
    SidLength = RtlLengthRequiredSid(1);

    WorldSid = Wow64AllocateHeap(SidLength);

    if (WorldSid == NULL)
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor - Could NOT Allocate SID Buffer.\n"));
        NtStatus = STATUS_NO_MEMORY;
        goto cleanup;
    }
    
    RtlZeroMemory(WorldSid, SidLength);
    RtlInitializeSid(WorldSid, &SidAuth, 1);

    *(RtlSubAuthoritySid(WorldSid, 0)) = SECURITY_WORLD_RID;
    

    SecurityDescriptorLength = SECURITY_DESCRIPTOR_MIN_LENGTH +
                               (ULONG)sizeof(ACL) +
                               (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
                               RtlLengthSid( WorldSid );

    SecurityDescriptor = Wow64AllocateHeap(SecurityDescriptorLength);

    if (SecurityDescriptor == NULL)
    {
      NtStatus = STATUS_NO_MEMORY;
      goto cleanup;
    }

    //
    //  Initialize Security Descriptor
    //
    NtStatus = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                           SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor - Failed to create security desc - %lx\n",
                  NtStatus));
        goto cleanup;
    }

    //
    //  Initialize ACL
    //
    AclBuffer = (PACL)((PBYTE)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);
    NtStatus = RtlCreateAcl(AclBuffer,
                            (SecurityDescriptorLength - SECURITY_DESCRIPTOR_MIN_LENGTH),
                            ACL_REVISION2);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor - Failed to create security desc ACL - %lx\n",
                  NtStatus));
        goto cleanup;
    }

    //
    //  Add an ACE to the ACL that allows World AccessMask to the
    //  object
    //
    NtStatus = RtlAddAccessAllowedAce(AclBuffer,
                                      ACL_REVISION2,
                                      AccessMask,
                                      WorldSid);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor - Failed to add access-allowed ACE  - %lx\n",
                  NtStatus));
        goto cleanup;
    }

    //
    //  Assign the DACL to the security descriptor
    //
    NtStatus = RtlSetDaclSecurityDescriptor((PSECURITY_DESCRIPTOR)SecurityDescriptor,
                                            TRUE,
                                            AclBuffer,
                                            FALSE );
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor- Could NOT Set DACL Security Descriptor - %lx.\n",
                 NtStatus));
        goto cleanup;
    }

cleanup:
    if (NT_SUCCESS(NtStatus))
    {
        *WorldSidToFree = WorldSid;
        *ObjectSD = SecurityDescriptor;
    }
    else
    {
        *WorldSidToFree = NULL;
        *ObjectSD = NULL;
        if (WorldSid)
        {
            Wow64FreeHeap(WorldSid);
        }

        if (SecurityDescriptor)
        {
            Wow64FreeHeap(SecurityDescriptor);
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64pInitializeSuspendMutant(
    VOID)
/*++

Routine Description:

    Creates the mutant to for execlusive access to Wow64SuspendThread API.

Arguments:

    None

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES MutantObjectAttributes;
    UNICODE_STRING MutantUnicodeString;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSID WorldSid;
    WCHAR SuspendMutantFullName[ 64 ];


    //
    // Construct the cache mutant in the correct session space, in case
    // we are running on Hydra
    //
    SuspendMutantFullName[ 0 ] = UNICODE_NULL;
    if (NtCurrentPeb()->SessionId != 0)
    {
        swprintf(SuspendMutantFullName, L"\\sessions\\%ld", NtCurrentPeb()->SessionId);
    }

    swprintf(SuspendMutantFullName, L"%ws\\BaseNamedObjects\\%ws", SuspendMutantFullName, WOW64_SUSPEND_MUTANT_NAME);
    RtlInitUnicodeString(&MutantUnicodeString, SuspendMutantFullName);

    NtStatus = Wow64pCreateSecurityDescriptor(&SecurityDescriptor,
                                              &WorldSid,
                                              MUTANT_ALL_ACCESS);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pInitializeSuspendMutant - Failed to create security descriptor - %lx",
                  NtStatus));
        return NtStatus;
    }


    InitializeObjectAttributes(&MutantObjectAttributes,
                               &MutantUnicodeString,
                               (OBJ_OPENIF | OBJ_CASE_INSENSITIVE),
                               NULL,
                               SecurityDescriptor);

    //
    // Let's create suspend thread mutant to serialize access
    // to Wow64SuspendThread
    //
    NtStatus = NtCreateMutant(&SuspendThreadMutant,
                              MUTANT_ALL_ACCESS,
                              &MutantObjectAttributes,
                              FALSE);

    Wow64FreeHeap(WorldSid);
    Wow64FreeHeap(SecurityDescriptor);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pInitializeSuspendMutant : Couldn't create/open SuspendThread mutant - %lx\n",
                  NtStatus));
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\vatrack.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    vatrack.c

Abstract:

    This module contains the internal routines for tracking the state of
    pages in the address space.

Author:

    Dave Hastings (daveh) creation-date 28-Feb-1996

Revision History:

    Modified to work w/ the native api (was win32.)

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wow64.h"
#include "va.h"

#ifdef SOFTWARE_4K_PAGESIZE

#if DBG
extern ULONG VaVerboseLog;
char szModule[] = "vatrack";
VOID
VaCheckList(
    IN PCHAR Routine
    );
VOID
VaDumpProtection(
    PROT Protection
    );
VOID 
VaDumpState(
    STATE State
    );
#endif


PVANODE VaRoot = NULL;

    
BOOL
VaQueryIntelPages(
    IN PVOID Address,
    OUT PULONG NumberOfPages,
    OUT PSTATE IntelState,
    OUT PPROT  IntelProtection,
    OUT PSTATE NativeState,
    OUT PPROT  NativeProtection
    )
/*++

Routine Description:

    This routine returns the state of pages in the address space.

Arguments:

    Address -- Supplies the address the information is desired for
    NumberOfPages -- Returns the number of pages from the address that
        have the returned characteristics (including the page containing
        Address)
    IntelState -- Returns the Intel apps view of the state of the page
    IntelProtection -- Returns the Intel apps view of the protection on the
        page
    NativeState -- Returns the actual state of the page
    NativeProtection -- Returns the actual protection of the page

Return Value:

    True for success

--*/
{
    PVANODE VaNode;

    VaNode = VaFindNode(Address);

    if (VaNode) {
        *IntelState = VaNode->IntelState;
        *IntelProtection = VaNode->IntelProtection;
        *NativeState = VaNode->State;
        *NativeProtection = VaNode->Protection;
        *NumberOfPages = (ULONG)((ULONG_PTR)VaNode->End - (ULONG_PTR)Address)/INTEL_PAGESIZE  + 1;
        return TRUE;
    }

    *IntelState = 0;
    *IntelProtection = 0;
    *NativeState = 0;
    *NativeProtection = 0;
    *NumberOfPages = 0;
    
    return FALSE;
}

BOOL
VaRecordMemoryOperation(
    PUCHAR IntelStart,
    PUCHAR IntelEnd,
    STATE IntelState,
    PROT  IntelProtection,
    PMEMCHUNK Pages,
    ULONG Number
    )
/*++

Routine Description:

    This function modifies the information about virtual memory.

Arguments:

    IntelStart -- Supplies the start of the region affected by the allocation
    IntelEnd -- Supplies the end of the region affected by the allocation
    IntelState -- Specifies the Intel state of the affected pages
    IntelProtection -- Specifies the Intel protection of the affected pages
    Pages -- Supplies information about the native pages in the allocation
    Number -- Supplies the number of entries in Pages

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    PVANODE Nodes[5];
    PVANODE VaNode;
    ULONG NumNodes = 0;
    PUCHAR StartAddress, EndAddress, AllocationStart, AllocationEnd;
    ULONG i;
    
    #ifdef DBG
    if (VaVerboseLog)
    {
        KdPrint(("VaRecordMemoryOperation: IStart=%08x IEnd=%08x IS=",
            IntelStart, IntelEnd));
        VaDumpState(IntelState);
        KdPrint((" IP="));
        VaDumpProtection(IntelProtection);
        KdPrint((" Pages=%d Number=%d\n", IntelState, IntelProtection));
    }
    #endif

    WOWASSERT(!(INTEL_PAGEMASK((ULONG_PTR)IntelStart)));
    WOWASSERT(!(INTEL_PAGEMASK((ULONG_PTR)IntelEnd + 1)));

    if ( (IntelEnd + 1) == IntelStart ) {
        // If the range is zero, do not touch the page list!
        return TRUE;
    }
    
    //
    // The system returns 0 for protection of un-committed pages
    //
    if (!(IntelState & MEM_COMMIT)) {
        IntelProtection = 0;
    }
    
    StartAddress = AllocationStart = IntelStart;
    EndAddress = AllocationEnd = IntelEnd;
    
    if (NATIVE_PAGEMASK((ULONG_PTR)IntelStart)) {
        //
        // We have to take care of the first page specially, because only
        // half of it is touched by this allocation
        //
        
        Nodes[NumNodes] = Wow64AllocateHeap(sizeof(VANODE));
        memset(Nodes[NumNodes], 0, sizeof(VANODE));
                
        Nodes[NumNodes]->Start = IntelStart - INTEL_PAGESIZE;
        Nodes[NumNodes]->End = StartAddress - 1;
        Nodes[NumNodes]->State = Pages[0].State;
        Nodes[NumNodes]->Protection = Pages[0].Protection;
        
        VaNode = VaFindNode(IntelStart - INTEL_PAGESIZE);
        if (VaNode) {
            //
            // Previous half native page is not yet described
            //
            Nodes[NumNodes]->IntelState = VaNode->IntelState;    
            Nodes[NumNodes]->IntelProtection = VaNode->IntelProtection;
        }
        
        NumNodes += 1;
        
        //
        // Describe second half of first native page
        //
        Nodes[NumNodes] = Wow64AllocateHeap(sizeof(VANODE));
        memset(Nodes[NumNodes], 0, sizeof(VANODE));
        Nodes[NumNodes]->Start = IntelStart;
        Nodes[NumNodes]->End = IntelStart + INTEL_PAGESIZE - 1;
        Nodes[NumNodes]->IntelState = IntelState;
        Nodes[NumNodes]->IntelProtection = IntelProtection;
        Nodes[NumNodes]->State = Pages[0].State;
        Nodes[NumNodes]->Protection = Pages[0].Protection;
	    NumNodes += 1;
        
        StartAddress = Nodes[NumNodes - 1]->End + 1;
        AllocationStart = IntelStart - INTEL_PAGESIZE;
    }
    
    if (NATIVE_PAGEMASK((ULONG_PTR)IntelEnd + 1)) {
        //
        // End falls in the middle of a Native page
        // Describe the first half
        //
        Nodes[NumNodes] = Wow64AllocateHeap(sizeof(VANODE));
        memset(Nodes[NumNodes], 0, sizeof(VANODE));

        Nodes[NumNodes]->Start = IntelEnd - INTEL_PAGESIZE + 1;
        Nodes[NumNodes]->End = IntelEnd;
        Nodes[NumNodes]->IntelState = IntelState;
        Nodes[NumNodes]->IntelProtection = IntelProtection;
        Nodes[NumNodes]->State = Pages[Number - 1].State;
        Nodes[NumNodes]->Protection = Pages[Number - 1].Protection;
    	NumNodes += 1;

        //
        // Take care of the second half of the native page
        //
        Nodes[NumNodes] = Wow64AllocateHeap(sizeof(VANODE));
        memset(Nodes[NumNodes], 0, sizeof(VANODE));
                
        Nodes[NumNodes]->Start = IntelEnd + 1;
        Nodes[NumNodes]->End = IntelEnd + INTEL_PAGESIZE;
        Nodes[NumNodes]->State = Pages[Number - 1].State;
        Nodes[NumNodes]->Protection = Pages[Number - 1].Protection;
        
        VaNode = VaFindNode(IntelEnd + 1);
        if (VaNode) {
            //
            // Previous half native page is not yet described
            //
            Nodes[NumNodes]->IntelState = VaNode->IntelState;    
            Nodes[NumNodes]->IntelProtection = VaNode->IntelProtection;
        }
        
        NumNodes += 1;
        
        EndAddress = IntelEnd - INTEL_PAGESIZE;
        AllocationEnd = IntelEnd + INTEL_PAGESIZE;
    }
    
    if (StartAddress < EndAddress) {
        //
        // Some of the allocation occupied full pages
        //
        Nodes[NumNodes] = Wow64AllocateHeap(sizeof(VANODE));
        memset(Nodes[NumNodes], 0, sizeof(VANODE));
            
        Nodes[NumNodes]->Start = StartAddress;
        Nodes[NumNodes]->End = EndAddress;
        Nodes[NumNodes]->IntelState = IntelState;
        Nodes[NumNodes]->IntelProtection = IntelProtection;
        Nodes[NumNodes]->State = IntelState;
        Nodes[NumNodes]->Protection = IntelProtection;
        NumNodes += 1;
    }
    
    //
    // Remove the old data
    //
    VaDeleteRegion(AllocationStart, AllocationEnd);
    
    //
    // Insert the new nodes
    //
    for (i = 0; i < NumNodes; i++) {
        VaInsertNode(Nodes[i]);
    }
    
    return TRUE;
}

BOOL
VaGetAllocationInformation(
    PUCHAR Address,
    PUCHAR *IntelBase,
    PULONG NumberOfPages,
    PSTATE IntelState,
    PPROT  IntelProtection
    )
/*++

Routine Description:

    This routine returns information about intel allocations.  It finds the
    beginning of a particular region of intel memory, as well as its state

Arguments:

    Address -- Supplies the address the region contains
    IntelBase -- Returns the base of the region
    NumberOfPages -- Returns the number of pages in the region
    IntelState -- Returns the state of the region
    IntelProtection -- Returns the protection of the region
    
Return Value:

    True if the region is in the vm list, false otherwise.
    
--*/
{
    PVANODE Node, PrevNode, NextNode;
    PUCHAR Base;
    ULONG Num;

    Node = VaFindNode(Address);
    
    if (Node == NULL) {
        return FALSE;
    }
    
    Base = Node->Start;
    Num = (ULONG)(((ULONG_PTR)Node->End - (ULONG_PTR)Node->Start + 1) / INTEL_PAGESIZE);
    
    //
    // Find all of the preceding nodes that are part of the allocation
    //
    PrevNode = Node->Prev;
    while (
        (PrevNode) &&
        (PrevNode->End == Node->Start - 1) && 
        (PrevNode->IntelState == Node->IntelState) &&
        (PrevNode->IntelProtection == Node->IntelProtection)
    ) {
        //
        // add this node into the information
        //
        Base = PrevNode->Start;
        Num += (ULONG)(((ULONG_PTR)PrevNode->End - (ULONG_PTR)PrevNode->Start + 1) / INTEL_PAGESIZE);
        PrevNode = PrevNode->Prev;
    }
    
    //
    // Find all of the succeeding nodes that are part of the allocation.
    //
    NextNode = Node->Next;
    while (
        (NextNode) &&
        (NextNode->End == Node->Start - 1) && 
        (NextNode->IntelState == Node->IntelState) &&
        (NextNode->IntelProtection == Node->IntelProtection)
    ) {
        //
        // add this node's size into the information
        //
        Num += (ULONG)(((ULONG_PTR)NextNode->End - (ULONG_PTR)NextNode->Start + 1) / INTEL_PAGESIZE);
        NextNode = NextNode->Next;
    }
    
    *IntelBase = Base;
    *NumberOfPages = Num;
    *IntelState = Node->IntelState;
    *IntelProtection = Node->IntelProtection;
    return TRUE;
}
    
PVANODE
VaFindNode(
    PCHAR Address
    )
/*++

Routine Description:

    This routine finds the node corresponding to the specified address.  It 
    will not return the allocation sentinel.  For that, use VaFindSentinel.

Arguments:

    Address -- Supplies the address to find

Return Value:

    Pointer to the VANODE, or NULL

--*/
{
    PVANODE VaNode;

    VaNode = VaRoot;

    while (VaNode) {
        if (Address < VaNode->Start) {
            return NULL;
        } else if (Address > VaNode->End) {
            VaNode = VaNode->Next;
        } else if (VaNode->IntelState == VA_SENTINEL){
            VaNode = VaNode->Next;
        } else {
        
            //
            // This is the one
            //

            return VaNode;
        }
    }

    //
    // No entry found
    //
    return NULL;
}

PVANODE
VaFindSentinel(
    PCHAR Address
    )
/*++

Routine Description:

    This routine finds the sentinel node corresponding to the specified
    address.

Arguments:

    Address -- Supplies the address to find

Return Value:

    Pointer to the VANODE, or NULL

--*/
{
    PVANODE VaNode;

    VaNode = VaRoot;

    while (VaNode) {
        if (Address < VaNode->Start) {
            return NULL;
        }  else if ((Address == VaNode->Start) && (VaNode->IntelState == VA_SENTINEL)) {
            return VaNode;
        } else if ((Address > VaNode->End)) {
            VaNode = VaNode->Next;
        } else {
            return NULL;
        }
    }

    //
    // No entry found
    //
    return NULL;
}

PVANODE
VaFindContainingSentinel(
    PCHAR Address
    )
/*++

Routine Description:

    This routine finds the node containing the specified address.

Arguments:

    Address -- Supplies the address to find

Return Value:

    Pointer to the VANODE, or NULL

--*/
{
    PVANODE VaNode;

    VaNode = VaRoot;

    while (VaNode) {
        if (Address < VaNode->Start) {
            return NULL;
        }  else if (VaNode->IntelState == VA_SENTINEL) {
            if ((STATE)Address <= VaNode->State) {
                return VaNode;
            } else {
                VaNode = VaNode->Next;
            }
        } else if ((Address > VaNode->End)) {
            VaNode = VaNode->Next;
        } else {
            return NULL;
        }
    }

    //
    // No entry found
    //
    return NULL;
}

PVANODE
VaRemoveNode(
    PVANODE VaNode
    )
/*++

Routine Description:

    This function removes a node from the tree.

Arguments:

    VaNode -- Supplies the node to remove

Return Value:

    VaNode for success, NULL for failure
--*/
{
    PVANODE p;
    #if DBG
    if (VaVerboseLog)
    {
        VaCheckList("VaRemoveNode");
        KdPrint(("Removing : "));
        VaDumpNode(VaNode);
    }
    #endif

    p = VaRoot;

    while (p && (p != VaNode)) {
        p = p->Next;
    }

    if (p) {
        if (p == VaRoot) {
            VaRoot = p->Next;
        }

        if (p->Next) {
            p->Next->Prev = p->Prev;
        }
        if (p->Prev) {
            p->Prev->Next = p->Next;
        }
    }
    #if DBG
    VaCheckList("VaRemoveNode");
    #endif
    return p;
}

PVANODE
VaInsertNode(
    PVANODE VaNode
    )
/*++

Routine Description:

    This function inserts a node into the list.  It is not intended for
    inserting sentinels into the list.  For that, use VaInsertSentinels.
    If there is a sentinel for this address, the description node will
    be placed after it.

Arguments:

    VaNode -- Supplies the node to insert

Return Value:

    VaNode for success, NULL for failure
--*/
{
    PVANODE p;

    WOWASSERT(VaNode->IntelState != VA_SENTINEL);
    
    #if DBG
    if (VaVerboseLog)
    {
        KdPrint(("VaInsertNode : "));
        VaDumpNode(VaNode);
        VaCheckList("VaRemoveNode");
    }
    #endif
    //
    // We assume that overlapping nodes do not get created
    //

    if (!VaRoot) {
        VaRoot = VaNode;
        VaNode->Prev = NULL;
        VaNode->Next = NULL;
        return VaNode;
    }

    p = VaRoot;

    while (p->Next && (p->Start < VaNode->Start)) {
        p = p->Next;
    }

    WOWASSERT((VaNode->Start != p->Start) || (p->IntelState == VA_SENTINEL))
    //
    // This if statement is constructed in this manner so that duplicate
    // nodes get inserted AFTER the node they duplicate.  In general, we
    // don't have duplicate nodes.  The only duplicates we see are the 
    // sentinels, and they go before the actual description.
    //
    if (VaNode->Start >= p->Start) {
        VaNode->Next = p->Next;
        if (p->Next) {
            p->Next->Prev = VaNode;
        }
        VaNode->Prev = p;
        p->Next = VaNode;
    } else {
        VaNode->Next = p;
        VaNode->Prev = p->Prev;
        if (p->Prev) {
            p->Prev->Next = VaNode;
        } else {
            VaRoot = VaNode;
        }
        p->Prev = VaNode;
        
    }
    
    //
    // Coalesce
    //
    if (VaNode->Prev) {
        if (
            (VaNode->Start == VaNode->Prev->End + 1) && 
            (((VaNode->State == VaNode->Prev->State) && (VaNode->State == MEM_RESERVE)) ||
            ((VaNode->State == VaNode->Prev->State) && 
            (VaNode->IntelState == VaNode->Prev->IntelState) &&
            (VaNode->Protection == VaNode->Prev->Protection) && 
            (VaNode->IntelProtection == VaNode->Prev->IntelProtection)))
        ) {
            //
            // Coalesce prev and this one
            //
            VaNode->Prev->End = VaNode->End;
            VaNode->Prev->Next = VaNode->Next;
            if (VaNode->Next) {
                VaNode->Next->Prev = VaNode->Prev;
            }
            p = VaNode->Prev;
            Wow64FreeHeap(VaNode);
            VaNode = p;
        }
    }
    
    //
    // Coalesce
    //
    if (VaNode->Next) {
        if (
            (VaNode->End + 1 == VaNode->Next->Start) && 
            (((VaNode->State == VaNode->Next->State) && (VaNode->State == MEM_RESERVE)) ||
            ((VaNode->State == VaNode->Next->State) && 
            (VaNode->IntelState == VaNode->Next->IntelState) &&
            (VaNode->Protection == VaNode->Next->Protection) && 
            (VaNode->IntelProtection == VaNode->Next->IntelProtection)))
        ) {
            //
            // Coalesce Next and this one
            //
            VaNode->Next->Start = VaNode->Start;
            VaNode->Next->Prev = VaNode->Prev;
            if (VaNode->Prev) {
                VaNode->Prev->Next = VaNode->Next;
            } else {
                VaRoot = VaNode->Next;
            }
            Wow64FreeHeap(VaNode);
        }
    }
    #if DBG
    VaCheckList(("VaRemoveNode"));
    #endif
    return VaNode;
}

PVANODE
VaInsertSentinel(
    PVANODE VaNode
    )
/*++

Routine Description:

    This function inserts a sentinel into the list.  

Arguments:

    VaNode -- Supplies the node to insert

Return Value:

    VaNode for success, NULL for failure
--*/
{
    PVANODE p;

    #if DBG
    if (VaVerboseLog)
    {
        KdPrint(("VaInsertSentinal : "));
        VaDumpNode(VaNode);
    }
    #endif
    //
    // We assume that overlapping nodes do not get created
    //

    if (!VaRoot) {
        VaRoot = VaNode;
        VaNode->Prev = NULL;
        VaNode->Next = NULL;
        return VaNode;
    }

    p = VaRoot;

    while (p->Next && (p->Start < VaNode->Start)) {
        p = p->Next;
    }

    //
    // This if statement is constructed in this manner so that duplicate
    // nodes get inserted BEFORE the node they duplicate.  In general, we
    // don't have duplicate nodes.  The only duplicates we see are the 
    // sentinels, and they go before the actual description.
    //
    if (VaNode->Start > p->Start) {
        VaNode->Next = p->Next;
        if (p->Next) {
            p->Next->Prev = VaNode;
        }
        VaNode->Prev = p;
        p->Next = VaNode;
    } else {
        VaNode->Next = p;
        VaNode->Prev = p->Prev;
        if (p->Prev) {
            p->Prev->Next = VaNode;
        } else {
            VaRoot = VaNode;
        }
        p->Prev = VaNode;
        
    }

    #if DBG
    VaCheckList("VaInsertSentinel");
    #endif

    return VaNode;
}

VOID
VaDeleteRegion(
    PCHAR Start,
    PCHAR End
    )
/*++

Routine Description:

    This routine removes the descriptions from pages in the specified
    range.

Arguments:

    Start -- Supplies the starting address
    End -- Supplies the ending address (inclusive)
    
Return Value:

    None.

--*/
{
    PVANODE VaNode, NewNode;

    WOWASSERT(!(INTEL_PAGEMASK((ULONG_PTR)Start)));
    WOWASSERT(!(INTEL_PAGEMASK((ULONG_PTR)End + 1)));
    #if DBG
    VaCheckList("VaDeleteRegion");
    if (VaVerboseLog)
    {
        KdPrint(("VaDeleteRegion %08p %08p\n", Start, End));
    }
    #endif

    if ( (End + 1) == Start ) { 
        // If the size of the region is zero, there is nothing to delete.
        return;
    }
    
    //
    // Find the first node containing information to remove
    //VaNode
    VaNode = VaRoot;
    while (VaNode && (VaNode->End < Start)) {
        VaNode = VaNextNode(VaNode);
    }
    
    if (!VaNode || (VaNode->Start > End)) {
        //
        // There are no nodes in the list we need to delete
        //
        return;
    }
    
    WOWASSERT(VaNode->IntelState != VA_SENTINEL)
    
    if ((VaNode->Start < Start) && (VaNode->End > End)) {
        //
        // This is the only node to change.  We handle this as a 
        // special case, because this is the only time we need to 
        // allocate an additional node
        //
        NewNode = Wow64AllocateHeap(sizeof(VANODE));
            
        *NewNode = *VaNode;
        NewNode->Start = End + 1;
        VaNode->End = Start - 1;
        VaInsertNode(NewNode);
        return;
    }
    
    //
    // We now know the region is described by one or more nodes, but NOT 
    // contained in a node.  Start whacking.
    //
    if (VaNode->Start < Start) {
        //
        // Trim the beginning of the first node
        //
        VaNode->End = Start - 1;
        VaNode = VaNextNode(VaNode);
    }
    
    //
    // Delete all of the nodes completely contained in the region
    //
    while (VaNode && (VaNode->End <= End) && VaNode->IntelState != VA_SENTINEL) {
        NewNode = VaNode;
        VaNode = VaNextNode(VaNode);
        VaRemoveNode(NewNode);
        Wow64FreeHeap(NewNode);
    }
    
    if (VaNode && (VaNode->Start < End)) {
        //
        // End of the region covers part of a node.  Trim the begnning 
        // of the node
        //
        VaNode->Start = End + 1;
    }
    #if DBG
    VaCheckList("VaDeleteRegion");
    #endif
    
    return;
}

void VaAddMemoryRecords(
    HANDLE ProcessHandle,
    LPVOID lpvAddress)
/*++

Routine Description:

    This function adds records to the page list corresponding to the 
    current status of memory pointed to by lpvAddress

Arguments:

    lpvAddress is address of memory of interest
    
Return Value:

    None.

--*/
{
    MEMORY_BASIC_INFORMATION mbi;
    MEMCHUNK memchunk;
    LPVOID StartAddress, EndAddress;
    STATE State;
    PROT Protection;
    PVANODE Sentinel;
    NTSTATUS status;
        
    //dw = VirtualQuery(lpvAddress, &mbi, sizeof(MEMORY_BASIC_INFORMATION));
    status = NtQueryVirtualMemory(
        ProcessHandle,
        lpvAddress,
        MemoryBasicInformation,
        &mbi,
        sizeof(mbi),
        0
        );
    
    if (NT_SUCCESS(status))
    {
        StartAddress = memchunk.Start = mbi.AllocationBase;
        EndAddress = memchunk.End = (PUCHAR)StartAddress + mbi.RegionSize - 1;
        State = memchunk.State = mbi.State;
        Protection = memchunk.Protection = mbi.Protect;
    
        //
        // Create the allocation sentinels
        //
        Sentinel = Wow64AllocateHeap(sizeof(VANODE));
        memset(Sentinel, 0, sizeof(VANODE));
       
        Sentinel->Start = StartAddress;
        Sentinel->IntelState = VA_SENTINEL;
        Sentinel->State = (STATE)EndAddress;
        Sentinel->Protection = VA_MAPFILE;
        VaInsertSentinel(Sentinel);
    
        VaRecordMemoryOperation(StartAddress,
                            EndAddress,
                            State,
                            Protection,
                            &memchunk,
                            1);
        #ifdef DBG            
        if (VaVerboseLog) {
            KdPrint((
               "VaAddMemoryRecords: Start %lx End %lx \n",
               StartAddress,
               EndAddress
               ));
        }
        #endif    
		    
    }
    #ifdef DBG
    else
    {
        WOWASSERT(0);
    }
    #endif

}




#if DBG
VOID
VaCheckList(
    IN PCHAR Routine
    )
/*++

Routine Description:

    This function verifies the integrity of the page list.

Arguments:

    None
    
Return Value:

    None.

--*/
{
    PVANODE p;
    
    p = VaRoot;
    
    if (VaVerboseLog)
    {
        VaDumpList(Routine);
    }
    

    //
    // Verify that each node's start is less than it's end,
    // and each node's end is less than the start of the next one,
    // or that the node is a sentinel in the correct spot.
    //
    while (p && p->Next) {
        if (p->IntelState == VA_SENTINEL) {
            if (p->Start > p->Next->Start) {
                WOWASSERT(FALSE);
            } else if (
                (p->Start == p->Next->Start) && 
                (p->Next->IntelState == VA_SENTINEL)
            ){
                WOWASSERT(FALSE);
            }
        } else if (
            (p->End <= p->Start) ||
            ((p->End >= p->Next->Start) && (p->Next->IntelState != VA_SENTINEL))
        ) {
            WOWASSERT(FALSE);
        }
        
        if ((p->State == 0xbaadf00d) || (p->Protection == 0xbaadf00d)) {
            WOWASSERT(FALSE);
        }
        
        p = p->Next;
    }
    
    //
    // Check the last node in the list for start < end
    //
    if (p && (p->IntelState != VA_SENTINEL) && (p->End <= p->Start)) {
        WOWASSERT(FALSE);
    }
}


VOID
VaDumpProtection(
    PROT Protection
    )
{
    if (Protection & PAGE_NOACCESS) 
    { 
        KdPrint(("a")); 
    } 
    if (Protection & PAGE_EXECUTE) 
    { 
        KdPrint(("X")); 
    } 
    if (Protection & PAGE_READWRITE) 
    { 
        KdPrint(("RW")); 
    } 
    if (Protection & PAGE_GUARD) 
    { 
        KdPrint(("G")); 
    } 
    if (Protection & PAGE_NOCACHE) 
    { 
        KdPrint(("c")); 
    }
}


VOID 
VaDumpState(
    STATE State
    )
{
    if (State == VA_SENTINEL) {  
        KdPrint(("S")); 
    }   
    else {  
        if (State & MEM_COMMIT)   
        {   
            KdPrint(("C"));    
        }   
        if (State & MEM_FREE)    
        {   
            KdPrint(("F"));    
        }   
        if (State & MEM_RESERVE)     
        {   
            KdPrint(("R"));    
        }   
    }
}

VOID
VaDumpNode(
    PVANODE VaNode)
{
    KdPrint(("@%08x: %08x-%08x %08x St:", VaNode, VaNode->Start, VaNode->End, 
        VaNode->End - VaNode->Start));
    VaDumpState(VaNode->State);
    
    KdPrint((" ISt: "));
    VaDumpState(VaNode->IntelState);

    KdPrint((" P:"));
    VaDumpProtection(VaNode->Protection);

    KdPrint((" IP:"));
    VaDumpProtection(VaNode->IntelProtection);

    KdPrint(("\n"));
}


VOID
VaDumpList(PCHAR Msg)
{
    PVANODE p = VaRoot;
    BOOLEAN AddDelim = FALSE;

    KdPrint(("--%s--\n", Msg));
    while (p) {
        VaDumpNode(p);
        p = p->Next;
    }
}


#endif // DBG

#endif // SOFTWARE_4K_PAGESIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\vaentry.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    vaentry.c

Abstract:

    This module contains the entrypoints called by the thunks for the 
    virtual memory api.

Author:

    Dave Hastings (daveh) creation-date 26-Feb-1996

Revision History:

    Originally "hooked" win32 vm apis, modified to hook native vm apis.

Notes:

    We should think about how to handle calls made on items that were not
    created through AllocateVirtualMemory.  One example would be an
    application decommitting pages of it's image. (daveh 2/26/96)
    
--*/
#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wow64.h"
#include "va.h"

#ifdef SOFTWARE_4K_PAGESIZE

#define MIN(a,b) ((ULONG)(a) < (ULONG)(b) ? (ULONG)(a) : (ULONG)(b))
#define MAX(a,b) ((ULONG)(a) > (ULONG)(b) ? (ULONG)(a) : (ULONG)(b))

LARGE_INTEGER VaDelay;


#if DBG
ULONG VaVerboseLog = 0;
static char szModule[] = "VaEntry";
#endif

HANDLE VaSync;

VOID
VaAllocErrorCleanup(
    HANDLE ProcessHandle,
    PMEMCHUNK Chunks,
    ULONG CurChunk
    );

LONG 
VaFixPermissions(
    HANDLE ProcessHandle,
    DWORD ExceptionCode,
    PMEMCHUNK Chunk
    );

DWORD 
ChoosePermissions(
    PROT Protect1,
    PROT Protect2
    );


VOID
EnterSyncCodeBlock(
    );

VOID
LeaveSyncCodeBlock(
    );


    

BOOLEAN VaInit()
/*++

Routine Description:

    This routine allocates our synchronization event.  All of the virtual 
    memory api have to be synchronized, because the get data from the page
    database, and use it to make descisions about what to do.

Arguments:

    None.
    
Return Value:

    True for success
--*/
{
    NTSTATUS status;


    if (VaSync == NULL) {
         status = NtCreateEvent(
            &VaSync,
            EVENT_ALL_ACCESS, 
            0, 
            SynchronizationEvent,   
            TRUE);

    // autoreset event
    // initially signaled

    }
    
    if (NT_SUCCESS(status)) {
        VaDelay.QuadPart = -5000;
        return TRUE;
    } else {
        return FALSE;
    }
}
    
NTSTATUS
VaAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function is called in place of NtAllocateVirtualMemory on the AX64
    to simulate 4k pages.
    
Notes:

    A second commit of the same intel page should NOT zero the page again.
    The followin transitions are allowed for Virtual alloc.
    
    free -> reserved
    free -> committed
    reserved -> committed
    committed -> committed
    
    An allocation may require a number of steps to take place, each on of
    which must be reversible (i.e. every other intel page on every other
    native page is already committed).
    
--*/
{   
    ULONG Chunks;
    ULONG CurChunk = 0;
    ULONG MaxChunks;
    NTSTATUS status;
    ULONG ProtectionMask;
    PVANODE Sentinel;
    PMEMCHUNK Chunk;
    PUCHAR CurrentVa;
    ULONG Perm;
    ULONG NumberOfPages;
    STATE IntelState, NativeState;
    PROT  IntelProtection, NativeProtection;
    ULONG i;
    PVOID Addr;
    BOOLEAN b;
    SIZE_T LocalRegionSize;

    //
    // We don't support allocations of physical memory
    //
    if (AllocationType & MEM_PHYSICAL)
    {
        return STATUS_INVALID_PARAMETER_5;
    }

    //
    // We only provide 4K virtualization for the current process, and pass write
    // watch allocations through.
    //
    if (!WOW64IsCurrentProcess(ProcessHandle) || 
        (AllocationType & MEM_WRITE_WATCH)) {
        return NtAllocateVirtualMemory(
            ProcessHandle,
            BaseAddress,
            ZeroBits,
            RegionSize,
            AllocationType,
            Protect
            );
    }
    
    //
    // Check the AllocationType for correctness.
    //
    if ((AllocationType & ~(MEM_COMMIT | MEM_RESERVE | MEM_PHYSICAL |
                            MEM_TOP_DOWN | MEM_RESET | MEM_WRITE_WATCH)) != 0) {
        return STATUS_INVALID_PARAMETER_5;
    }

    //
    // One of MEM_COMMIT, MEM_RESET or MEM_RESERVE must be set.
    //
    if ((AllocationType & (MEM_COMMIT | MEM_RESERVE | MEM_RESET)) == 0) {
        return STATUS_INVALID_PARAMETER_5;
    }

    if ((AllocationType & MEM_RESET) && (AllocationType != MEM_RESET)) {

        //
        // MEM_RESET may not be used with any other flag.
        //
        return STATUS_INVALID_PARAMETER_5;
    }

    if (AllocationType & MEM_WRITE_WATCH) {

        //
        // Write watch address spaces can only be created with MEM_RESERVE.
        //

        if ((AllocationType & MEM_RESERVE) == 0) {
            return STATUS_INVALID_PARAMETER_5;
        }
    }

    if (AllocationType & MEM_PHYSICAL) {

        //
        // MEM_PHYSICAL must be used with MEM_RESERVE and no other flags.
        // This memory is always read-write when allocated.
        //
        if (AllocationType != (MEM_RESERVE | MEM_PHYSICAL)) {
            return STATUS_INVALID_PARAMETER_5;
        }

        if (Protect != PAGE_READWRITE) {
            return STATUS_INVALID_PARAMETER_6;
        }
    }

    if (*RegionSize == 0) {

        //
        // Region size cannot be 0.
        //
        return STATUS_INVALID_PARAMETER_4;
    }

    
    //
    // Acquire the page database
    //
    EnterSyncCodeBlock();
    
    
    #ifdef DBG
    if (VaVerboseLog) 
        KdPrint((
            "VaAllocateVirtualMemory: Base:%lx ZeroBits:%lx RegionSize:%lx AllocationType:%lx Protect:%lx\n",
            *BaseAddress,
            ZeroBits,
            *RegionSize,
            AllocationType,
            Protect
            ));
        
    #endif

    //
    // No base address was specified, so there will be no collisions with
    // existing allocations, or the allocation includes a reserve, so 
    // there will be no collision with existing allocations
    //
    if ((*BaseAddress == NULL) || (AllocationType & MEM_RESERVE))  {
        MEMCHUNK Chunk;
        PUCHAR AllocBaseAddress;
        
        Sentinel = Wow64AllocateHeap(sizeof(VANODE));
        if (!Sentinel) {
            LeaveSyncCodeBlock();
            return STATUS_NO_MEMORY;
        }
        
        //
        // Call the system's virtual memory manager, and record the return
        // information
        //
        LocalRegionSize = *RegionSize;
        status = NtAllocateVirtualMemory(
            ProcessHandle,
            BaseAddress,
            ZeroBits,
            &LocalRegionSize,
            AllocationType,
            Protect);
            
        if (!NT_SUCCESS(status)) {
            LeaveSyncCodeBlock();
            return status;
        }

        *RegionSize = INTEL_PAGEROUND(*RegionSize + INTEL_PAGESIZE - 1);
        AllocBaseAddress = *BaseAddress;

        //
        // NtAllocateVirtualMemory returns allocations on native page boundaries
        // so further rounding down is unnecessary.
        //
        Chunk.Start = AllocBaseAddress;
        Chunk.End = (PUCHAR)(AllocBaseAddress + LocalRegionSize - 1);
        
        //
        // Create the allocation sentinels
        //
        memset(Sentinel, 0, sizeof(VANODE));
        Sentinel->Start = AllocBaseAddress;
        Sentinel->IntelState = VA_SENTINEL;
        Sentinel->State = (STATE)Chunk.End;
        VaInsertSentinel(Sentinel);
    
        //
        // Enter the information into our set of data
        //
        VaRecordMemoryOperation(
            AllocBaseAddress,
            Chunk.End,
            AllocationType,
            Protect,
            &Chunk,
            1
            );
        
        #if DBG            
        if (VaVerboseLog) {
            KdPrint((
               "VaAllocateVirtualMemory: %lx \n",
                status
                ));
        }
        #endif    
        
        //
        // return to the caller
        //
        LeaveSyncCodeBlock();
        
        return status;
    }

    //
    // Check to see if the commit is contained entirely within a single
    // memory reserve.  If it isn't, NtAllocateVirtualMemory would have
    // failed with STATUS_CONFLICTING_ADDRESSES.
    //
    Sentinel = VaFindContainingSentinel(*BaseAddress);
    if (!Sentinel) {
        //
        // The reserve containing lpAddress hasn't been tracked, or there
        // is no reserve at the specified address.  Pass the call onto the
        // native memory allocator and let it worry about the details.
        //
        #if DBG
        if (VaVerboseLog) {
            KdPrint((
                "VaAllocateVirtualMemory:  nothing tracked for %x - passing it on to Win32\n",
                *BaseAddress));
        }
        #endif
        
        LeaveSyncCodeBlock();

        status = NtAllocateVirtualMemory(
            ProcessHandle,
            BaseAddress,
            ZeroBits,
            RegionSize,
            AllocationType,
            Protect
            );

        WOWASSERT(status == STATUS_CONFLICTING_ADDRESSES);

        return status;
    }

    if ((ULONG_PTR)*BaseAddress + *RegionSize - 1 > Sentinel->State) {
        // Addresses conflict
        #if DBG
        if (VaVerboseLog) {
            KdPrint((
                "VaAllocateVirtualMemory:  conflict:  original reserve is %x-%x (requested End=%x)\n",
                Sentinel->Start, Sentinel->State, (ULONG_PTR)*BaseAddress + *RegionSize - 1
                ));
        }
        #endif
        
        LeaveSyncCodeBlock();
        
        return STATUS_NO_MEMORY;
    }


    //
    // Allocate some space to describe the chunk of address space 
    // we want to allocate.  We allocate the maximum we will need
    // (total intel pages + partial native page at beginning + 
    // partial native page at end).  This could also be a linked structure
    // built up as we need it.
    //
    MaxChunks = (ULONG)(*RegionSize / INTEL_PAGESIZE) + 2;
    Chunk = Wow64AllocateHeap(MaxChunks * sizeof(MEMCHUNK));
    if (!Chunk) {
        LeaveSyncCodeBlock();
        
        return STATUS_NO_MEMORY;
    }
    memset(Chunk, 0, MaxChunks * sizeof(MEMCHUNK));

    //
    // Take care of the first partial page
    //
    CurChunk = 0;
    *BaseAddress = (PVOID)INTEL_PAGEROUND((ULONG_PTR)*BaseAddress);
    CurrentVa = (PUCHAR)*BaseAddress;
    if (NATIVE_PAGEMASK((ULONG_PTR)CurrentVa)) {

        VaQueryIntelPages(
            CurrentVa - INTEL_PAGESIZE,
            &NumberOfPages,
            &IntelState,
            &IntelProtection,
            &NativeState,
            &NativeProtection
            );
            
        Chunk[CurChunk].Start = CurrentVa - INTEL_PAGESIZE;
        
        if (!(NativeState & MEM_COMMIT)) {
            //
            // Native page is not committed
            //
            Chunk[CurChunk].Action = CallSystem;
            Chunk[CurChunk].Protection = Protect;
            Chunk[CurChunk].State = AllocationType;
            
            //
            // Make this chunk as long as possible
            //
            Chunk[CurChunk].End = (PUCHAR)MIN(
                (INTEL_PAGEROUND((ULONG_PTR)*BaseAddress + *RegionSize + INTEL_PAGESIZE - 1) - 1),
                ((ULONG_PTR)Chunk[CurChunk].Start + (NumberOfPages * INTEL_PAGESIZE) - 1));
            
        } else if (!(IntelState & MEM_COMMIT)) {
            //
            // Native page is committed, but Intel page is not
            //
            Chunk[CurChunk].Action = FillMem;
            Chunk[CurChunk].Protection = Protect;
            Chunk[CurChunk].State = NativeState;
            
            //
            // Make this chunk as long as possible
            //
            Chunk[CurChunk].End = (PUCHAR)MIN(
                (INTEL_PAGEROUND((ULONG_PTR)*BaseAddress + *RegionSize + INTEL_PAGESIZE - 1) - 1),
                ((ULONG_PTR)Chunk[CurChunk].Start + (NumberOfPages * INTEL_PAGESIZE) - 1));
            
        } else {
            Perm = ChoosePermissions(IntelProtection, Protect);
            if (Perm != NativeProtection) {
                //
                // We need to make the restrictions more permissive
                //
                Chunk[CurChunk].Action = CallSystem;
                Chunk[CurChunk].Protection = Perm;
                Chunk[CurChunk].State = NativeState;
            
                //
                // Only do this for two Intel pages (one for the partial native
                // page, one for the beginning of the allocation)
                //
                Chunk[CurChunk].End = Chunk[CurChunk].Start + 2 * INTEL_PAGESIZE
                    - 1;
            
            } else {
                //
                // We need to do nothing for the first Native page
                //
                Chunk[CurChunk].Action = None;
                Chunk[CurChunk].End = Chunk[CurChunk].Start + INTEL_PAGESIZE -1;
                Chunk[CurChunk].State = NativeState;
                Chunk[CurChunk].Protection = NativeProtection;
            }
        }
        
        CurrentVa = Chunk[CurChunk].End + 1;    
        CurChunk += 1;
    }
    
    //
    // handle the rest of the allocation
    //
    while (CurrentVa < (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)*BaseAddress + *RegionSize + INTEL_PAGESIZE - 1)) {

        #if DBG
        if (CurChunk == MaxChunks) {
            KdPrint((
                "VaVirtualAlloc: CurChunk==MaxChunks==0x%x, Chunk=0x%x\n", 
                CurChunk, Chunk));
            DbgBreakPoint();
        }
        #endif

        VaQueryIntelPages(
            CurrentVa,
            &NumberOfPages,
            &IntelState,
            &IntelProtection,
            &NativeState,
            &NativeProtection
            );

        if (NumberOfPages == 0) {
            //
            // App is trying to commit memory when it hasn't been reserved.
            // Seen in Word97.  Open sdktools\imagehlp\pecoff.doc and page
            // down past the table of contents.  On x86 NT, one VirtualAlloc
            // call fails with STATUS_CONFLICTING_ADDRESSES.
            //
            #if DBG
            if (VaVerboseLog) {
                KdPrint(("VaVirtualAlloc: app tried to commit memory not reserved.  Failing the call.\n"));
            }
            #endif
            Wow64FreeHeap(Chunk);
            LeaveSyncCodeBlock();
            
            return STATUS_CONFLICTING_ADDRESSES;
        }

        Chunk[CurChunk].Start = CurrentVa;
        Chunk[CurChunk].Protection = Protect;
        
        //
        // Make this chunk as long as possible
        //
        Chunk[CurChunk].End = (PUCHAR)MIN(
            (INTEL_PAGEROUND((ULONG_PTR)*BaseAddress + *RegionSize + INTEL_PAGESIZE - 1) - 1),
            ((ULONG_PTR)Chunk[CurChunk].Start + (NumberOfPages * INTEL_PAGESIZE) - 1));

        //
        // Pick an appropriate action
        //
        if (!(NativeState & MEM_COMMIT)) {
            // Native memory has not been committed
            Chunk[CurChunk].Action = CallSystem;    
            Chunk[CurChunk].State = AllocationType;
        } else if (!(IntelState & MEM_COMMIT)) {
            // Native memory is already committed, but unused
            Chunk[CurChunk].Action = FillMem;
            Chunk[CurChunk].State = NativeState;
        } else {
            // The intel page description is equivalent to the native description
            // so we avoid a redundant call to VirtualAlloc
            if (Chunk[CurChunk].Protection == NativeProtection) {
                Chunk[CurChunk].Action = None;
                Chunk[CurChunk].State = NativeState;
            }
            // Only the protection on the page is different.
            // The call to VirtualAlloc will return NULL.
            else {
                Chunk[CurChunk].Action = CallSystem;   
                Chunk[CurChunk].State = NativeState;
            }
        }
                
        CurrentVa = Chunk[CurChunk].End + 1;
        CurChunk += 1;

    }
    
    //
    // Handle the last partial page 
    //
    if (NATIVE_PAGEMASK((ULONG_PTR)Chunk[CurChunk - 1].End + 1)) {
        
        VaQueryIntelPages(
            CurrentVa,
            &NumberOfPages,
            &IntelState,
            &IntelProtection,
            &NativeState,
            &NativeProtection
            );
            
        //
        // At this point, we only care if the next page is IntelCommitted
        // In all other case, we don't have to do anything.
        //
        if (IntelState & MEM_COMMIT) {
            //
            // Choose the least restrictive set of permissions
            //
            Perm = ChoosePermissions(
                Chunk[CurChunk - 1].Protection, 
                IntelProtection
                );
                
            if (Perm != Chunk[CurChunk - 1].Protection) {
                //
                // We need change the permissions for the last page of the 
                // last chunk to be more permissive.
                //
                if (Chunk[CurChunk - 1].Start < (CurrentVa - INTEL_PAGESIZE)) {
                    //
                    // Trim the chunk and create a new one for the last page
                    //
                    Chunk[CurChunk - 1].End = CurrentVa - INTEL_PAGESIZE - 1;
                    Chunk[CurChunk].Start = CurrentVa - INTEL_PAGESIZE;
                    Chunk[CurChunk].End = Chunk[CurChunk].Start + NATIVE_PAGESIZE - 1;
                    CurChunk += 1;
                }
                
                Chunk[CurChunk - 1].Action = CallSystem; 
                Chunk[CurChunk - 1].Protection = Perm;
                Chunk[CurChunk - 1].State = NativeState;
            }
        }
    }
    
    //
    // Iterate over the chunks and perform the actions
    //
    
    for (i = 0; i < CurChunk; i++) {
        //
        // We don't have to worry about undoing the memory fills, 
        // because if we are filling memory the page wasn't already
        // committed.
        //
        if (Chunk[i].Action == CallSystem) {
            PVOID ChunkBaseAddress = Chunk[i].Start;
            SIZE_T ChunkRegionSize = Chunk[i].End - Chunk[i].Start + 1;
            
            status = NtAllocateVirtualMemory(
                ProcessHandle,
                &ChunkBaseAddress,
                0,
                &ChunkRegionSize,
                MEM_COMMIT,
                Chunk[i].Protection
                );
                
            WOWASSERT(ChunkBaseAddress == Chunk[i].Start);
            
            //
            // If there was an error, save the information and 
            // return it to the caller
            //
            if (!NT_SUCCESS(status)) {
                VaAllocErrorCleanup(ProcessHandle, Chunk, i - 1);
                #if DBG            
                if (VaVerboseLog) {
                    KdPrint((
                        "VaVirtualAlloc: %lx \n",
                        NULL
                        ));
                }
                #endif    
                Wow64FreeHeap(Chunk);
                LeaveSyncCodeBlock();

                return status;
            }
            
            //
            // At this point, if the memory manager rounded the addresses
            // for us, we have a SERIOUS problem.
            //

            ASSRT(ChunkBaseAddress == Chunk[i].Start);
            
        } else if (Chunk[i].Action == FillMem){
            VOID* ChunkBaseAddress;
            SIZE_T ChunkRegionSize;
            ULONG OldProtection;

            //
            // We use a try/except here, because the page might be
            // read only.
            //
            b = TRUE;
            try {
                memset(Chunk[i].Start, 0, Chunk[i].End - Chunk[i].Start + 1);
            } except (VaFixPermissions(ProcessHandle, GetExceptionCode(), &Chunk[i])) {
                //
                // Indicate an error.  We have attempted to make the page
                // read/write, and that didn't workd.  We will clean up and return
                // after we exit the except clause
                //
                b = FALSE;
            }
            
            //
            // If there was an error, save the information and 
            // return it to the caller
            //
            if (!b) {
                VaAllocErrorCleanup(ProcessHandle, Chunk, i);
                #if DBG            
                if (VaVerboseLog) {
                    KdPrint((
                       "VaVirtualAlloc: %lx \n",
                        NULL
                        ));
                }
                #endif    
                Wow64FreeHeap(Chunk);
                LeaveSyncCodeBlock();

                return STATUS_ACCESS_DENIED;
            }


            ChunkBaseAddress = Chunk[i].Start;
            ChunkRegionSize = Chunk[i].End - Chunk[i].Start + 1;
            

            status = NtProtectVirtualMemory(
                ProcessHandle,
                &ChunkBaseAddress,
                &ChunkRegionSize,
                Chunk[i].Protection,
                &OldProtection);

            //
            // If there was an error, save the information and 
            // return it to the caller
            //
            if (!NT_SUCCESS(status)) {
                VaAllocErrorCleanup(ProcessHandle, Chunk, i);
                
                #if DBG            
                if (VaVerboseLog) {
                    KdPrint(("NtProtectVirtualMemory: %lx \n",
                        status
                        ));
                }
                #endif    
                Wow64FreeHeap(Chunk);
                LeaveSyncCodeBlock();
                
                return status;
            }
            
        }
    }
    
    //
    // record info about allocation
    //
    *RegionSize = INTEL_PAGEROUND(*RegionSize + INTEL_PAGESIZE - 1);
    VaRecordMemoryOperation(
        (PUCHAR)*BaseAddress,
        (PUCHAR)((ULONG_PTR)*BaseAddress + *RegionSize)-1,
        AllocationType,
        Protect,
        Chunk,
        CurChunk
        );
    
    // 
    //
    // Free local information on address space
    //
    Wow64FreeHeap(Chunk);
    
    #if DBG            
    if (VaVerboseLog) {
        KdPrint((
            "VaVirtualAlloc: %lx \n",
            *BaseAddress
            ));
    }
    #endif    
        
   LeaveSyncCodeBlock();
   
   return STATUS_SUCCESS;
}


LONG 
VaFixPermissions(
    HANDLE ProcessHandle,
    DWORD ExceptionCode,
    PMEMCHUNK Chunk
    )
/*++

Routine Description:

    This routine handles access violations trying to zero fill committed
    Intel pages.  If the exception wasn't an access violation, or changing
    the page permissions fails, we cause the except clause of the try
    except to execute.

Arguments:

    ExceptionCode -- Supplies the exception number
    Chunk -- Describes the piece of memory we tried to fill
    
Return Value:

    EXCEPTION_CONTINUE_EXECUTION -- if it was an AV we successfully change 
        the page permissions
    EXCEPTION_EXECUTE_HANDLER -- otherwise
--*/
{
    DWORD OldProtection;
    BOOL Ret;
    PVOID ChunkBaseAddress = Chunk->Start;
    SIZE_T ChunkRegionSize = Chunk->End - Chunk->Start + 1;

    if (ExceptionCode != EXCEPTION_ACCESS_VIOLATION) {
        return EXCEPTION_EXECUTE_HANDLER;
    }
    
    //
    // change permissions to allow write into specified chunk
    //
    Ret = NtProtectVirtualMemory(
        ProcessHandle,
        &ChunkBaseAddress,
        &ChunkRegionSize,
        PAGE_READWRITE,
        &OldProtection
        );

    if (!Ret) {
        return EXCEPTION_EXECUTE_HANDLER;
    }
    
    return EXCEPTION_CONTINUE_EXECUTION;
}



VOID
VaAllocErrorCleanup(
    HANDLE ProcessHandle,
    PMEMCHUNK Chunk,
    ULONG CurChunk
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    Chunks -- Supplies the set of actions performed on the virtual memory
    CurChunk -- Supplies the size of the array

Return Value:

    None.

--*/
{
    ULONG i;
    STATE NativeState, IntelState;
    PROT  NativeProtection,IntelProtection;
    ULONG NumberOfPages;
    ULONG OldProtection;
    NTSTATUS status;
    
    if (CurChunk == 0xFFFFFFFF) {
        //
        // We got the error on the first operation.  Nothing to clean up
        //
        return;
    }
    
    for (i = 0; i < CurChunk; i++) {
        VOID* ChunkBaseAddress;
        SIZE_T ChunkRegionSize;

        //
        // At this point, Chunks describes the state of memory and the info
        // returned by VaQueryIntelPages describes the previous state of memory
        // Chunks describes memory in terms of native pages.  We will restore
        // the pages to the state described by the Native information
        //
        VaQueryIntelPages(
            Chunk[i].Start,
            &NumberOfPages,
            &IntelState,
            &IntelProtection,
            &NativeState,
            &NativeProtection
            );

        ChunkBaseAddress = Chunk[i].Start;
        ChunkRegionSize = Chunk[i].End - Chunk[i].Start + 1;
            
        //
        // We ignore errors from the memory management functions at this point.
        // We are already going to fail the call, and we will hope that we 
        // can get back to a state that will work.
        //
        if (NativeState & MEM_COMMIT) {
            //
            // We will just set the page permissions
            //
            status = NtProtectVirtualMemory(
                ProcessHandle,
                &ChunkBaseAddress,
                &ChunkRegionSize,
                NativeProtection,
                &OldProtection);

            if (!NT_SUCCESS(status))
            {
                DbgBreakPoint();
            }
        } else {
            //
            // We need to decommit the pages
            //
            status = NtFreeVirtualMemory(
                ProcessHandle,
                &ChunkBaseAddress,
                &ChunkRegionSize,
                MEM_DECOMMIT);

            if (!NT_SUCCESS(status))
            {
                DbgBreakPoint();
            }
        }
    }
}


NTSTATUS
VaFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    )
/*++

Routine Description:

    This function is called in place of NtFreeVirtualMemory on platforms whose
    page size is larger than 4K.    
    
--*/
{
    NTSTATUS status;
    MEMCHUNK Chunk[3];
    ULONG NumChunks = 0;
    BOOL b;
    ULONG LastError;
    PUCHAR StartAddress, EndAddress;
    STATE NativeState, IntelState;
    PROT NativeProtection, IntelProtection;
    ULONG NumberOfPages;
    MEMORY_BASIC_INFORMATION mbi;
    PVANODE Sentinel;
    PVOID BaseAddressCopy;
    SIZE_T RegionSizeCopy;

    //
    // We only provide 4K virtualization for the current process.
    //
    if (!WOW64IsCurrentProcess(ProcessHandle)) {
        return NtFreeVirtualMemory(
            ProcessHandle,
            BaseAddress,
            RegionSize,
            FreeType
            );
        }


    #ifdef DBG
    if (VaVerboseLog)
    {
        KdPrint(("VaFreeVirtualMemory BaseAddr=%08x RegionSize=%08x FreeType=",
            *BaseAddress, RegionSize, FreeType));
    }
    #endif

    //
    // Make local copies of the arguments, as the caller only expects us
    // to update them if the call succeeds.
    //
    BaseAddressCopy = *BaseAddress;
    RegionSizeCopy = *RegionSize;

    //
    // Acquire the page database
    //
    EnterSyncCodeBlock();

    //
    // Get the base of the allocation
    //
    status = NtQueryVirtualMemory(
        ProcessHandle,
        BaseAddressCopy,
        MemoryBasicInformation,
        &mbi,
        sizeof(mbi),
        0);

    if (!NT_SUCCESS(status)) {
        //
        // Something inexplicable happened.  Note it and 
        // hope everything will be ok
        //
        #if DBG
        if (VaVerboseLog)
        {
            KdPrint(("VaVirtualFree: VirtualQuery returned wrong number of bytes\n"));
        }
        #endif
    }

    if (RegionSizeCopy == 0 && FreeType == MEM_DECOMMIT) {
        RegionSizeCopy = mbi.RegionSize;
    }

    if (mbi.State == MEM_FREE) {
        #if DBG
        if (VaVerboseLog)
        {
            KdPrint(("VaVirtualFree: VirtualQuery indicates the address isn't reserved.\n"));
        }
        #endif
        Sentinel = NULL;
    } else {
        Sentinel = VaFindSentinel(mbi.AllocationBase);
    }

    if ((Sentinel != NULL) && (Sentinel->Protection & VA_MAPFILE))
    {
        // Apps shouldn't be calling VirtualFree on file mapping memory.
        // Pass the call onto the system for an appropriate error return.

        status = NtFreeVirtualMemory(
            ProcessHandle,
            BaseAddress,
            RegionSize,
            FreeType);
    
        LeaveSyncCodeBlock();
        return status;
    }
    

    if (FreeType & MEM_RELEASE) {
        status = NtFreeVirtualMemory(
            ProcessHandle,
            BaseAddress,
            RegionSize,
            FreeType);

            
        if (NT_SUCCESS(status) && Sentinel) {
            //
            // Delete the sentinels
            //
            ASSRT((Sentinel->Start == mbi.AllocationBase) && (Sentinel->IntelState == VA_SENTINEL));
            VaRemoveNode(Sentinel);
            
            //
            // record the information
            //
            VaDeleteRegion(
                Sentinel->Start,
                (PVOID)Sentinel->State
                );
                
            Wow64FreeHeap(Sentinel);
        }
        LeaveSyncCodeBlock();
        
        return status;
    }
    
    // Startaddress and EndAddress are the respective boundaries of the
    // portion of the allocation which will actually be decommitted in a call
    // to VirtualFree. If the situation is such that a native page will not be
    // decommitted, EndAddress < StartAddress

    StartAddress = (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)BaseAddressCopy);
    EndAddress = (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)BaseAddressCopy + RegionSizeCopy +
        INTEL_PAGESIZE - 1) - 1;
    
    // When an allocation boundary falls on a 4k boundary, but not on an 8k
    // boundary, the relevant native page is described

    if (NATIVE_PAGEMASK((ULONG_PTR)StartAddress)) {
        //
        // Check to see if we free or leave the first page
        //
        VaQueryIntelPages(
            StartAddress - INTEL_PAGESIZE,
            &NumberOfPages,
            &IntelState,
            &IntelProtection,
            &NativeState,
            &NativeProtection
            );
            
        if (IntelState & MEM_COMMIT) {
            Chunk[0].Start = StartAddress - INTEL_PAGESIZE;
            Chunk[0].End = Chunk[0].Start + NATIVE_PAGESIZE - 1;
            Chunk[0].Protection = NativeProtection;
            Chunk[0].State = NativeState;
            StartAddress = StartAddress + INTEL_PAGESIZE;
            NumChunks += 1;
        }
    }
    
    // This description represents the portion of the allocation which is
    // being decommitted. At present, the description is unused

    Chunk[NumChunks].Start = StartAddress;
    Chunk[NumChunks].End = EndAddress;
    Chunk[NumChunks].State = MEM_RESERVE;
    Chunk[NumChunks].Protection = 0;
    NumChunks += 1;
    
    // NATIVE_PAGEROUND() will round the argument down to the nearest
    // native page boundary and return, a value which will nearly always
    // be positive, and causing a page to be described whether it is necessary
    // or not.

    // The intention here is to catch addresses which sit on 4k, but not 8k
    // page boundaries
    //
    if (NATIVE_PAGEMASK((ULONG_PTR)EndAddress + 1)) {
        //
        // Check to see if we free or leave the last page
        //
        VaQueryIntelPages(
            EndAddress + 1,
            &NumberOfPages,
            &IntelState,
            &IntelProtection,
            &NativeState,
            &NativeProtection
            );
            
        if (IntelState & MEM_COMMIT) {
            Chunk[NumChunks].Start = EndAddress + 1 - INTEL_PAGESIZE;
            
            // Describe one native page

            Chunk[NumChunks].End = Chunk[NumChunks].Start + NATIVE_PAGESIZE - 1;
            Chunk[NumChunks].Protection = NativeProtection;
            Chunk[NumChunks].State = NativeState;
            EndAddress = EndAddress - INTEL_PAGESIZE;

            // Though at present unused, update 

            Chunk[NumChunks - 1].End = EndAddress;
            
            NumChunks += 1;
        }
    }
    
    //
    // Free the memory
    //
    if (EndAddress > StartAddress) {
        PVOID BaseAddressTemp = (PVOID)StartAddress;
        SIZE_T RegionSizeTemp = EndAddress - StartAddress + 1;

        status = NtFreeVirtualMemory(
            ProcessHandle,
            &BaseAddressTemp,
            &RegionSizeTemp,
            FreeType);

    } else {
        //
        // We don't actually have any memory to decommit, so pretend we did
        // and it worked
        //
        status = STATUS_SUCCESS;
    }
    

    if (NT_SUCCESS(status)) {
        //
        // record the information
        //
        StartAddress = (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)StartAddress),
        EndAddress = (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)EndAddress + INTEL_PAGESIZE - 1) - 1;
        VaRecordMemoryOperation(
            StartAddress,
            EndAddress,
            MEM_RESERVE,
            0,
            Chunk,
            NumChunks
            );

        // update the OUT parameters.  This can never fault, as the pointers
        // point to local variables allocate in the thunks, not back into
        // the 32-bit app.
        *RegionSize = INTEL_PAGEROUND((ULONG_PTR)*BaseAddress + *RegionSize + INTEL_PAGESIZE - 1) - INTEL_PAGEROUND((UINT_PTR)*BaseAddress);
        *BaseAddress = (VOID *)INTEL_PAGEROUND(((ULONG_PTR)*BaseAddress));
    }
    LeaveSyncCodeBlock();

    return status;
}


NTSTATUS
VaQueryVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN ULONG MemoryInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
/*++

Routine Description:

    This is the 4k virtualization routine for NtQueryVirtualMemory on alpha.  
    It call native NtQueryVirtualMemory, and overwrites some of the fields with data 
    from our own image of memory.

--*/
{
    NTSTATUS status;
    BOOL b;
    PUCHAR IntelBase;
    ULONG NumberOfPages;
    STATE IntelState;
    PROT IntelProtection;
    SIZE_T RealReturnLength;    // BUGBUG - fix the interface to VaQuery...
    
    //
    // We only provide 4K virtualization for the current process and don't mess w/
    // working set, vlm, or memory mapped file information.
    //
    if (!WOW64IsCurrentProcess(ProcessHandle) || 
        MemoryInformationClass != MemoryBasicInformation)  {

        status = NtQueryVirtualMemory(
            ProcessHandle, 
            BaseAddress, 
            MemoryInformationClass,
            MemoryInformation, 
            MemoryInformationLength, 
            &RealReturnLength);

        if (ReturnLength) {
            *ReturnLength = (ULONG)RealReturnLength;
        }
        return status;
    }
    
    //
    // Acquire the page database
    //
    EnterSyncCodeBlock();

    status = NtQueryVirtualMemory(
        ProcessHandle,
        BaseAddress,
        MemoryInformationClass,
        MemoryInformation,
        MemoryInformationLength,
        &RealReturnLength);

    if (ReturnLength) {
        *ReturnLength = (ULONG)RealReturnLength;
    }

    if (!NT_SUCCESS(status))
    {
        LeaveSyncCodeBlock();
        
        return status;
    }

    //
    // We believe we understand what the buffer looks like, so change the 
    // appropriate fields
    //
    b = VaGetAllocationInformation(
            BaseAddress,
            &IntelBase,
            &NumberOfPages,
            &IntelState, 
            &IntelProtection
            );
            
    if (b) {
        PMEMORY_BASIC_INFORMATION mbi = (PMEMORY_BASIC_INFORMATION)MemoryInformation;;

        mbi->BaseAddress = IntelBase;
        mbi->RegionSize = NumberOfPages * INTEL_PAGESIZE;
        mbi->Protect = (IntelProtection & ~PAGE_GUARD) |
            (((PMEMORY_BASIC_INFORMATION)MemoryInformation)->Protect & ~PAGE_GUARD);
        mbi->State = (ULONG)IntelState;
    }

    LeaveSyncCodeBlock();

    
    return status;
}



NTSTATUS 
VaProtectVirtualMemory(
     IN HANDLE ProcessHandle,
     IN OUT PVOID *BaseAddress,
     IN OUT PSIZE_T RegionSize,
     IN ULONG NewProtect,
     OUT PULONG OldProtect
     )
{
    MEMCHUNK Chunk[3];
    ULONG NumberOfPages;
    STATE IntelState, NativeState;
    PROT OldProtection, IntelProtection, NativeProtection;
    BOOL b;
    PUCHAR StartAddress, EndAddress, AllocationStart, AllocationEnd;
    MEMORY_BASIC_INFORMATION mbi;
    NTSTATUS status, VmQueryStatus;
    ULONG NumChunks;
    ULONG i;
    
    //
    // Don't support 4k page size faking for other processes.
    //
    if (!WOW64IsCurrentProcess(ProcessHandle))
    {
        return NtProtectVirtualMemory(
            ProcessHandle,
            BaseAddress,
            RegionSize,
            NewProtect,
            OldProtect);
    }

    EnterSyncCodeBlock();
    
    StartAddress = (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)*BaseAddress);
    EndAddress = (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)*BaseAddress + 
        (ULONG_PTR)*RegionSize + INTEL_PAGESIZE - 1) - 1;

    AllocationStart = (PUCHAR)NATIVE_PAGEROUND((ULONG_PTR)*BaseAddress);
    AllocationEnd = (PUCHAR)NATIVE_PAGEROUND((ULONG_PTR)EndAddress + 1) - 1;

    //
    // Get the Guard page bit for the specified address
    //
    VmQueryStatus = NtQueryVirtualMemory(
        ProcessHandle,
        *BaseAddress,
        MemoryBasicInformation,
        &mbi,
        sizeof(mbi),
        0);
    
    //
    // Get the old protection value
    //
    b = VaQueryIntelPages(
        *BaseAddress,
        &NumberOfPages,
        &IntelState,
        &IntelProtection,
        &NativeState,
        &NativeProtection
        );
        
    if (!b) {
        //
        // We didn't handle this allocation, so just pass it on to the system
        //
        status = NtProtectVirtualMemory(
            ProcessHandle,
            BaseAddress,
            RegionSize,
            NewProtect,
            OldProtect);

        LeaveSyncCodeBlock();

        return status;
    }
    
    OldProtection = IntelProtection;
    
    NumChunks = 0;

    //
    // Take care of first native page
    //
    if (AllocationStart < StartAddress) {
        
        b = VaQueryIntelPages(
            StartAddress,
            &NumberOfPages,
            &IntelState,
            &IntelProtection,
            &NativeState,
            &NativeProtection
            );
            
        Chunk[NumChunks].Start = AllocationStart;
        Chunk[NumChunks].End = AllocationStart + NATIVE_PAGESIZE - 1;
        Chunk[NumChunks].State = NativeState;
        Chunk[NumChunks].Protection = ChoosePermissions(IntelProtection, NewProtect);
            
        StartAddress = Chunk[NumChunks].End + 1;
        NumChunks += 1;
    }
    
    //
    // Take care of last native page
    //
    if ((AllocationEnd > EndAddress) && (StartAddress < AllocationEnd)) {
        
        b = VaQueryIntelPages(
            AllocationEnd,
            &NumberOfPages,
            &IntelState,
            &IntelProtection,
            &NativeState,
            &NativeProtection
            );
            
        Chunk[NumChunks].Start = AllocationEnd - NATIVE_PAGESIZE - 1;
        Chunk[NumChunks].End = AllocationEnd;
        Chunk[NumChunks].State = NativeState;
        Chunk[NumChunks].Protection = ChoosePermissions(IntelProtection, NewProtect);
            
        EndAddress = Chunk[NumChunks].Start - 1;
        NumChunks += 1;
    }
    
    //
    // Handle the middle (if any) of the allocation
    //
    
    if (EndAddress > StartAddress) {
        Chunk[NumChunks].Start = StartAddress;
        Chunk[NumChunks].End = EndAddress;
        Chunk[NumChunks].State = MEM_COMMIT;
        Chunk[NumChunks].Protection = NewProtect;
        NumChunks += 1;
    }
    
    //
    // Apply the changes
    //
    for (i = 0; i < NumChunks; i++) {
        PUCHAR ChunkBaseAddress = Chunk[i].Start;
        SIZE_T ChunkRegionSize = Chunk[i].End - Chunk[i].Start + 1;
        ULONG LastProtection;
        
        status = NtProtectVirtualMemory(
            ProcessHandle,
            &ChunkBaseAddress,
            &ChunkRegionSize,
            NewProtect,
            &LastProtection
            );

        WOWASSERT(ChunkBaseAddress == Chunk[i].Start);
        WOWASSERT(NT_SUCCESS(status));            
        if (!NT_SUCCESS(status)) {
            break;
        }
    }
    
    //
    // If there were errors, undo what we did
    //
    if ((!NT_SUCCESS(status)) && (NumChunks > 1)) {
        for (i = 0; i < NumChunks && NT_SUCCESS(status); i++) {
        
            //
            // get the permissions to change back to 
            //
            b = VaQueryIntelPages(
                Chunk[i].Start,
                &NumberOfPages,
                &IntelState,
                &IntelProtection,
                &NativeState,
                &NativeProtection
                );
                
            if (b) {
                PUCHAR ChunkBaseAddress = Chunk[i].Start;
                SIZE_T ChunkRegionSize = Chunk[i].End - Chunk[i].Start + 1;
                ULONG LastProtection;

                status = NtProtectVirtualMemory(
                    ProcessHandle,
                    &ChunkBaseAddress,
                    &ChunkRegionSize,
                    IntelProtection,
                    &LastProtection
                    );

                WOWASSERT(ChunkBaseAddress == Chunk[i].Start);
                WOWASSERT(ChunkRegionSize == (ULONG_PTR)Chunk[i].End - (ULONG_PTR)Chunk[i].Start + 1);
                WOWASSERT(NT_SUCCESS(status));
            }
            
        }

    } else {
        //
        // Record the operation
        //
        VaRecordMemoryOperation(
            (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)*BaseAddress),
            (PUCHAR)INTEL_PAGEROUND((ULONG_PTR)*BaseAddress + *RegionSize + INTEL_PAGESIZE - 1) - 1,
            MEM_COMMIT,
            NewProtect,
            Chunk,
            NumChunks
            );
            
        //
        // Insert the correct guard page bit 
        //
        if (NT_SUCCESS(VmQueryStatus))
        {
            *OldProtect = (OldProtection & ~PAGE_GUARD) | (mbi.Protect & PAGE_GUARD);
        }
    }
    
    LeaveSyncCodeBlock();
    
    return status;
}




NTSTATUS
VaMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
{
    NTSTATUS status;

    status = NtMapViewOfSection(
        SectionHandle,
        ProcessHandle,
        BaseAddress,
        ZeroBits,
        CommitSize,
        SectionOffset,
        ViewSize,
        InheritDisposition,
        AllocationType,
        Protect
        );

    if (NT_SUCCESS(status) && WOW64IsCurrentProcess(ProcessHandle))
    {
        EnterSyncCodeBlock();

        VaAddMemoryRecords(ProcessHandle, *BaseAddress);

        LeaveSyncCodeBlock();
    }

    return status;
}


NTSTATUS
VaUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    )
{
    NTSTATUS UnmapViewStatus;
    NTSTATUS QueryVMStatus;
    MEMORY_BASIC_INFORMATION mbi;
    PVANODE Sentinel;

    if (!WOW64IsCurrentProcess(ProcessHandle))
    {
        UnmapViewStatus = NtUnmapViewOfSection(
            ProcessHandle,
            BaseAddress
            );

        return UnmapViewStatus;
    }

    
    EnterSyncCodeBlock();

    QueryVMStatus = NtQueryVirtualMemory(
        ProcessHandle,
        BaseAddress,
        MemoryBasicInformation,
        &mbi,
        sizeof(mbi),
        0
        );

    UnmapViewStatus = NtUnmapViewOfSection(
        ProcessHandle,
        BaseAddress
        );

    if (NT_SUCCESS(QueryVMStatus))
    {
        WOWASSERT(mbi.State != MEM_FREE);
        Sentinel = VaFindSentinel(mbi.AllocationBase);
        WOWASSERT((Sentinel) && (Sentinel->Start == mbi.AllocationBase) && (Sentinel->IntelState == VA_SENTINEL));
        VaRemoveNode(Sentinel);
    
        //
        // record the information
        //
        VaDeleteRegion(
            Sentinel->Start,
            (PVOID)Sentinel->State
            );
        
        Wow64FreeHeap(Sentinel);
        #if DBG            
        if (VaVerboseLog) {
            KdPrint((
               "VaUnmapViewOfFile: Allocation Base %lx RegionSize %lx \n",
               mbi.AllocationBase,
               mbi.RegionSize
               ));
        }
        #endif          
    }
        
    LeaveSyncCodeBlock();

    return UnmapViewStatus;
}

DWORD 
ChoosePermissions(
    PROT Protect1,
    PROT Protect2
    )
/*++

Routine Description:

    This routine takes two permissions and returns a permission that is 
    the least restrictive of the two.

Arguments:

    Protect1 -- Specifies one of the page permissions
    Protect2 -- Specifies the other of the page permissions
    
Return Value:

    returns the least restrictive page permission
--*/
{

    return MAX((Protect1 & ~(PAGE_GUARD | PAGE_NOCACHE)), 
        (Protect2 & ~(PAGE_GUARD | PAGE_NOCACHE))) | 
        ((Protect1 | Protect2) & (PAGE_GUARD | PAGE_NOCACHE));
}




VOID
EnterSyncCodeBlock(
    )
{
    NTSTATUS status;
    
    do
    {
        status = NtWaitForSingleObject(
            VaSync,
            FALSE,
            &VaDelay);

        WOWASSERT((status == STATUS_TIMEOUT) ||
            status == STATUS_SUCCESS);
    }
    while (status == STATUS_TIMEOUT);
}
    

VOID
LeaveSyncCodeBlock(
    )
{
    NtSetEvent(VaSync, 0);
}

#endif // SOFTWARE_4K_PAGESIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\wow64.c ===
/*++                 

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64.c

Abstract:
    
    Main entrypoints for wow64.dll

Author:

    11-May-1998 BarryBo

Revision History:
    9-Aug-1999 [askhalid] added WOW64IsCurrentProcess
    

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#include "wow64p.h"
#include "wow64cpu.h"
#include "va.h"

ASSERTNAME;

//
// This structure, Wow64Info, allows 32-bit code running inside a Wow64 process
// to access information regarding the native system which Wow64 is running on.
//
WOW64INFO Wow64SharedInfo;


//
// This array mirror's the kernel's array of data used to decode
// system service call parameters and dispatch.
//
WOW64SERVICE_TABLE_DESCRIPTOR ServiceTables[NUMBER_SERVICE_TABLES];


NTSTATUS
Wow64pInitializeWow64Info(
    VOID
    )

/*++

Routine Description:

    This function initializes Wow64Info, which is accessed from 32-bit modules
    running inside Wow64 to retreive information about the native system.

Arguments:

    None.

Return Value:

    Status.

--*/
{

    Wow64SharedInfo.NativeSystemPageSize = PAGE_SIZE;

    return STATUS_SUCCESS;
}


//
// Number of bytes of memory the CPU wants allocated per-thread
//
SIZE_T CpuThreadSize;

WOW64DLLAPI
VOID
Wow64LdrpInitialize (
    IN PCONTEXT Context
    )
/*++

Routine Description:

    This function is called by the 64-bit loader when the exe is 32-bit.

Arguments:

    Context - Supplies an optional context buffer that will be restore
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

              NOTE:  This Context is 64-bit

Return Value:

    None.  Never returns:  the process is destroyed when this function
    completes.

--*/
{
    NTSTATUS st;
    PVOID pCpuThreadData;
    ULONG InitialIP;
    CONTEXT32 Context32;
    static BOOLEAN InitializationComplete;
    PWSTR ImagePath;
    PIMAGE_NT_HEADERS NtHeaders;
    PPEB Peb64;
    BOOLEAN FirstRun;


    //
    // Let the 32-bit thread points to wow64info.
    //
 
    Wow64TlsSetValue(WOW64_TLS_WOW64INFO, &Wow64SharedInfo);

    FirstRun = !InitializationComplete;
    if (FirstRun) {

        WCHAR ImagePathBuffer [ 264 ];
        #ifdef SOFTWARE_4K_PAGESIZE
        VaInit();
        #endif 

        //
        // First-time call - this is process init.
        //
        st = ProcessInit(&CpuThreadSize);
        if (!NT_SUCCESS(st)) { 
            LOGPRINT((ERRORLOG, "Wow64LdrpInitialize: ProcessInit failed, error %x\n", st));
            LOGPRINT((ERRORLOG, "Wow64LdrpInitialize: Calling NtTerminateProcess.\n"));
            NtTerminateProcess(NtCurrentProcess(), st);
        }
        InitializationComplete = TRUE;

        //
        // Notify the CPU that the image has been loaded.
        //

        ImagePath = L"image";
        Peb64 = NtCurrentPeb();
        if ((ImagePath != NULL) && (Peb64->ProcessParameters->ImagePathName.Length != 0)) {

            ImagePath = Peb64->ProcessParameters->ImagePathName.Buffer;
        }

        NtHeaders = RtlImageNtHeader (Peb64->ImageBaseAddress);
        CpuNotifyDllLoad(ImagePath,
                         Peb64->ImageBaseAddress,
                         NtHeaders->OptionalHeader.SizeOfImage);

        //
        // Notify the CPU that 32-bit ntdll.dll has been loaded.
        //
        ImagePath = ImagePathBuffer;
    
        wcscpy (ImagePath, USER_SHARED_DATA->NtSystemRoot);
        wcscat (ImagePath, L"\\syswow64\\ntdll.dll");

        NtHeaders = RtlImageNtHeader (UlongToPtr (NtDll32Base));
        CpuNotifyDllLoad (ImagePath,
                          UlongToPtr (NtDll32Base),
                          NtHeaders->OptionalHeader.SizeOfImage);
    }

        
    // Determine if the initial context for this process is in 32bit code or 64bit code.
    // If it is in 64bit, jump to it and stay in 64bit land forever.   If the initial
    // context is in 32bit land, finish the cpu initialization.
    // This feature is ment for supporting the breakin feature of debuggers which create a thread 
    // in the debuggeee 
    Run64IfContextIs64(Context, FirstRun);

    //
    // Allocate the CPU's per-thread memory from the 64-bit stack.  This
    // memory will be freed when the stack is freed.  It is passed into the
    // CPU as zero-filled.
    //
    pCpuThreadData = _alloca(CpuThreadSize);
    RtlZeroMemory(pCpuThreadData, CpuThreadSize);
    Wow64TlsSetValue(WOW64_TLS_CPURESERVED, pCpuThreadData);

    LOGPRINT((TRACELOG, "Wow64LdrpInitialize: cpu per thread data allocated at %I64x \n", (ULONGLONG)pCpuThreadData));
    WOWASSERT_PTR32(pCpuThreadData);   
 
    //
    // Perform per-thread init
    //
    st = ThreadInit(pCpuThreadData);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "Wow64LdrpInitialize: ThreadInit failed, error %x\n", st));
        LOGPRINT((ERRORLOG, "Wow64LdrpInitialize: Calling NtTerminateThread.\n"));
        WOWASSERT(FALSE);
        NtTerminateThread(NtCurrentThread(), st);
    }

    //
    // Call 32-bit ntdll.dll LdrInitializeThunk.  This never returns.
    //

    //
    // Fetch the initial 32-bit CONTEXT
    //
    Context32.ContextFlags = CONTEXT32_FULLFLOAT;
#if defined(_AMD64_)
    CpuSetInstructionPointer((ULONG)Context->Rip);
#elif defined(_IA64_)
    CpuSetInstructionPointer((ULONG)Context->StIIP);
#else
#error "No Target Architecture"
#endif

    CpuGetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NULL,
                  &Context32);

    ThunkStartupContext64TO32(&Context32,
                              Context);

    InitialIP = Wow64SetupApcCall(Ntdll32LoaderInitRoutine,
                                  &Context32,
                                  NtDll32Base,
                                  0
                                 );

#if 0
    if (NtCurrentPeb()->BeingDebugged) {
        DbgPrint("WOW64 INITIALIZED!  STARTING EMULATION AT %I64x \n", (ULONGLONG)InitialIP);
        DbgBreakPoint();
    }
#endif

    RunCpuSimulation();
}


VOID
Wow64SetupExceptionDispatch(
    IN PEXCEPTION_RECORD32 pRecord32,
    IN PCONTEXT32 pContext32
    )
/*++

Routine Description:
  
    Copy the 32bit exception record and 32bit continuation context to the 32bit stack
    and sets the 32bit context to run the exception dispatcher in NTDLL32.
    
    pRecord32  - Supplies the 32bit exception record to be raised.
    pContext32 - Supplies the 32bit continuation context. 

Arguments:

    None - If failure occures an exception will be thrown.

--*/
{
    ULONG SP;
    PULONG PtrExcpt;
    PULONG PtrCxt;
    EXCEPTION_RECORD32 ExrCopy32; 
    EXCEPTION_RECORD ExrCopy;
    PEXCEPTION_RECORD32 TmpExcpt;
    PCONTEXT32 TmpCxt;

retry:
    try {    

        SP = CpuGetStackPointer() & (~3);
        SP -= (2*sizeof(ULONG))+sizeof(EXCEPTION_RECORD32)+sizeof(CONTEXT32);

        PtrExcpt = (PULONG) SP;
        PtrCxt = (PULONG) (((UINT_PTR) PtrExcpt) + sizeof(ULONG));
        TmpExcpt = (PEXCEPTION_RECORD32) (((UINT_PTR) PtrCxt) + sizeof(ULONG));
        TmpCxt = (PCONTEXT32) (((UINT_PTR) TmpExcpt) + sizeof(EXCEPTION_RECORD32));


        //
        // Copy on the 32-bit EXCEPTION_RECORD
        //
        *TmpExcpt = *pRecord32;

        //
        // Copy the 32-bit CONTEXT on the stack, too
        //
        *TmpCxt = *pContext32;

        //
        // Change the cpu's Context to point at
        // ntdll32!KiUserExceptionDispatcher and set up the parameters
        // for the call.
        //
        *PtrExcpt = PtrToUlong(TmpExcpt);
        *PtrCxt = PtrToUlong(TmpCxt);
    }

    except((ExrCopy = *(((struct _EXCEPTION_POINTERS *)GetExceptionInformation())->ExceptionRecord)), EXCEPTION_EXECUTE_HANDLER) {
        if(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
            ThunkExceptionRecord64To32(&ExrCopy, &ExrCopy32);
            ExrCopy32.ExceptionAddress = pRecord32->ExceptionAddress;
            pRecord32 = &ExrCopy32;
            goto retry;
        }
        else {
           // Send this exception to the debugger.
           ExrCopy.ExceptionAddress = (PVOID)pRecord32->ExceptionAddress; 
           Wow64NotifyDebugger(&ExrCopy, FALSE);
        }
    }

    //
    // Ok, we have made a copy of the ia32 context on the ia32 stack,
    // now need to set up for the running of the ia32 exception handler
    // so we need to reset the ia32 state to something good... 
    //
    
    CpuSetStackPointer(SP);
    CpuSetInstructionPointer(Ntdll32KiUserExceptionDispatcher);

    //
    // If the exception was floating point related, we need to reset
    // the floating point hardware to make sure we don't take another
    // exceptions from the current status bits
    //
    switch(pRecord32->ExceptionCode) {
        case STATUS_FLOAT_INEXACT_RESULT:
        case STATUS_FLOAT_UNDERFLOW:
        case STATUS_FLOAT_OVERFLOW:
        case STATUS_FLOAT_DIVIDE_BY_ZERO:
        case STATUS_FLOAT_DENORMAL_OPERAND:
        case STATUS_FLOAT_INVALID_OPERATION:
        case STATUS_FLOAT_STACK_CHECK:
            CpuResetFloatingPoint();

        default:
            // Nothing to do
            ;
    }
}


VOID
ThunkExceptionRecord64To32(
    IN  PEXCEPTION_RECORD   pRecord64,
    OUT PEXCEPTION_RECORD32 pRecord32
    )
/*++

Routine Description:

    Thunks an exception record from 64-bit to 32-bit.

Arguments:

    pRecord64   - 64-bit exception record
    pRecord32   - destination 32-bit exception record

Return Value:

    None.

--*/
{
    int i;

    switch (pRecord64->ExceptionCode) {
    case STATUS_WX86_BREAKPOINT:
        pRecord32->ExceptionCode = STATUS_BREAKPOINT;
        break;

    case STATUS_WX86_SINGLE_STEP:
        pRecord32->ExceptionCode = STATUS_SINGLE_STEP;
        break;

#if _AXP64_
    case STATUS_WX86_FLOAT_STACK_CHECK:
        pRecord32->ExceptionCode = STATUS_FLOAT_STACK_CHECK;
        break;
#endif

    default:
        pRecord32->ExceptionCode = pRecord64->ExceptionCode;
        break;
    }
    pRecord32->ExceptionFlags = pRecord64->ExceptionFlags;
    pRecord32->ExceptionRecord = PtrToUlong(pRecord64->ExceptionRecord);
    pRecord32->ExceptionAddress = PtrToUlong(pRecord64->ExceptionAddress);
    pRecord32->NumberParameters = pRecord64->NumberParameters;

    for (i=0; i<EXCEPTION_MAXIMUM_PARAMETERS; ++i) {
        pRecord32->ExceptionInformation[i] =
            (ULONG)pRecord64->ExceptionInformation[i];
    }
}

PEXCEPTION_RECORD 
Wow64AllocThunkExceptionRecordChain32TO64(
    IN PEXCEPTION_RECORD32 Exr32
    )
/*++

Routine Description:

    Copy a 32bit chain of EXCEPTION_RECORD to a new 64bit chain.  Memory is 
    allocated on the temporary thunk memory list.

Arguments:

    Exr32 - supplies a pointer to the 32bit chain to copy.

Return Value:

    A newly created 64bit version of the 32bit list passed in Exr32.

--*/
{

    PEXCEPTION_RECORD Exr64;
    int i;

    if (NULL == Exr32) {
        return NULL;
    }

    Exr64 = Wow64AllocateTemp(sizeof(EXCEPTION_RECORD) );

    // Thunk the 32-bit exception record to 64-bit
    switch (Exr32->ExceptionCode) {
    case STATUS_BREAKPOINT:
        Exr64->ExceptionCode = STATUS_WX86_BREAKPOINT;
        break;

    case STATUS_SINGLE_STEP:
        Exr64->ExceptionCode = STATUS_WX86_SINGLE_STEP;
        break;

#if _AXP64_
    case STATUS_FLOAT_STACK_CHECK:
        Exr64->ExceptionCode = STATUS_WX86_FLOAT_STACK_CHECK;
        break;
#endif

    default:
        Exr64->ExceptionCode = Exr32->ExceptionCode;
    }
    Exr64->ExceptionFlags = Exr32->ExceptionFlags;
    Exr64->ExceptionRecord = Wow64AllocThunkExceptionRecordChain32TO64((PEXCEPTION_RECORD32)Exr32->ExceptionRecord);
    Exr64->ExceptionAddress = (PVOID)Exr32->ExceptionAddress;
    Exr64->NumberParameters = Exr32->NumberParameters;
    for (i=0; i<EXCEPTION_MAXIMUM_PARAMETERS; ++i) {
        Exr64->ExceptionInformation[i] = Exr32->ExceptionInformation[i];
    }      

    return Exr64;

}

LONG
Wow64DispatchExceptionTo32(
    IN struct _EXCEPTION_POINTERS *ExInfo
    )
/*++

Routine Description:

    64-bit exception filter which is responsible for dispatching the
    exception down to 32-bit code.

Arguments:

    ExInfo  - 64-bit exception pointers

Return Value:

    None.  Never returns.

--*/
{
    EXCEPTION_RECORD32 Record32;
    CONTEXT32 Context32;
    

    LOGPRINT((TRACELOG, "Wow64DispatchExceptionTo32(%p) called.\n"
                        "Exception Code: 0x%x, Exception Address: 0x%p, TLS exceptionaddr:0x%p\n",
                         ExInfo,
                         ExInfo->ExceptionRecord->ExceptionCode,
                         ExInfo->ExceptionRecord->ExceptionAddress,
                         Wow64TlsGetValue(WOW64_TLS_EXCEPTIONADDR)));

    if (Wow64TlsGetValue(WOW64_TLS_INCPUSIMULATION)) {
        //
        // INCPUSIMULATION is still set, so the CPU emulator is not using
        // native SP as an alias for simulated ESP.  Therefore,
        // Wow64PrepareForException was a no-op and we need to reset the
        // CPU now.
        //
        CpuResetToConsistentState(ExInfo);
        Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, FALSE);
    }
    
    Context32.ContextFlags = CONTEXT32_FULLFLOAT;
    CpuGetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NULL,
                  &Context32);
    ThunkExceptionRecord64To32(ExInfo->ExceptionRecord, &Record32);

    //
    // Do what the kernel does, when it's about to 
    // dispatch excpetions to user mode. Basically TrapFrame->Eip
    // will be pointing at the instruction following int 3, while
    // Context.Eip that will be dispatched to user mode, will be pointing
    // at the faulting instruction. See (ke\i386\exceptn.c)
    //
    switch (Record32.ExceptionCode)
    {
    case STATUS_BREAKPOINT:
        Context32.Eip--;
        break;
    }

    //
    // Patch in the original 32-bit exception address.  It was patched-out
    // by Wow64PrepareForException since that value is used to seed the
    // stack unwind.
    //
    Record32.ExceptionAddress =
        PtrToUlong(Wow64TlsGetValue(WOW64_TLS_EXCEPTIONADDR));
    WOWASSERT(!ARGUMENT_PRESENT(Record32.ExceptionRecord));

    //
    // Setup architecture dependent call to ntdll32's exception handler.
    Wow64SetupExceptionDispatch(&Record32, &Context32);

    //
    // At this point, the exception is now ready to be handled by the ia32
    // exception handler, so let the ia32 code run...
    //

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOLEAN
Wow64NotifyDebugger(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:

   Notifies the debugger when a 32bit software exception occures.

Arguments:

    ExceptionRecord - supplies a pointer to the 64bit exception record chain to report 
                      to the debugger.

Return Value:

    TRUE - The debugger handled the exception.
    FALSE - The debugger did not handle the exception.

--*/
{
    try {
       Wow64NotifyDebuggerHelper(ExceptionRecord, FirstChance);
       return TRUE;  
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       return FALSE;
    }
    
}

NTSTATUS
Wow64KiRaiseException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:

   Called to raise a 32bit software exception.   This function notifies the debugger
   and then sets the 32bit instruction pointer to point to the exception dispatcher
   in NTDLL32.

Arguments:

    ExceptionRecord - supplies a pointer to the 32bit exception record chain to report 
                      to the debugger.

    ContextRecord - supplies a pointer to the 32bit continuation context record.

    FirstChange - TRUE if this is a first chance exception.

Return Value:

    An NTSTATUS code reporting success or failure.

--*/
{

    NTSTATUS st;
    EXCEPTION_RECORD32 Exr32;
    PEXCEPTION_RECORD Exr64;
    CONTEXT32 Cxt32;    
    BOOLEAN DebuggerHandled;

    // Kernel copies these, lets do what the kernel does.
    try {
       Exr32 = *(PEXCEPTION_RECORD32)ExceptionRecord;
       Exr32.ExceptionCode &= 0xefffffff;
       Cxt32 = *(PCONTEXT32)ContextRecord;
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       return GetExceptionCode();
    }  
    
    //
    // Update the CPU's context. This is similiar to what the kernel
    // does : at the start of ke!KiRaiseException, it does
    // ke!KeContextToKframes
    //
    CpuSetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NULL,
                  &Cxt32);

    // Send the exception to the debugger.
    Exr64 = Wow64AllocThunkExceptionRecordChain32TO64(&Exr32);
    LOGPRINT((TRACELOG, "Wow64KiRaiseException: Notifying debugger, FirstChance %X\n", (ULONG)FirstChance));
    DebuggerHandled = Wow64NotifyDebugger(Exr64, FirstChance);

    if (!DebuggerHandled) {  

        // Debugger did not handle the exception.  Pass it back to the app.
        LOGPRINT((TRACELOG, "Wow64KiRaiseException: Debugger did not handle exception\n"));
        LOGPRINT((TRACELOG, "Wow64KiRaiseException: Dispatching exception to user mode.\n")); 
        WOWASSERT(FirstChance);  // Should not get back here if second chance.
        Wow64SetupExceptionDispatch(&Exr32, &Cxt32);
        return STATUS_SUCCESS; // Context will be set on the return from system service.

    }

    // Debugger did handle the exception.   Set the context to the restoration context.
    // This is effectivly the same as returning EXCEPTION_CONTINUE_EXECUTION from the
    // except block.  The debugger could have set the context, but that would be the 64
    // bit context and the code would probably not execute here.   This will need to
    // be revisited once (Get/Set)ThreadContext and debugging from a 32bit debugger is 
    // working.
    
    LOGPRINT((TRACELOG, "Wow64KiRaiseException: Debugger did handle exception(set context to restoration context)\n"));

    return STATUS_SUCCESS;

}



WOW64DLLAPI
NTSTATUS
Wow64KiRaiseUserExceptionDispatcher(
    IN PVOID ReturnAddress
    )
/*++

Routine Description:

    Dispatches a user mode exception.

Arguments:

    ReturnAddress   - address to return to
    ExceptionCode   - in TIB->ExceptionCode

Return Value:

    None.

--*/
{
    return STATUS_UNSUCCESSFUL;
}



WOW64DLLAPI
PVOID
Wow64AllocateHeap(
    SIZE_T Size
    )
/*++

Routine Description:

    Wrapper for RtlAllocateHeap.

Arguments:

    Size        - number of bytes to allocate

Return Value:

    Pointer, or NULL if no memory.  Memory is not zero-filled.

--*/
{
    return RtlAllocateHeap(RtlProcessHeap(),
                           0,
                           Size);
}


WOW64DLLAPI
VOID
Wow64FreeHeap(
    PVOID BaseAddress
    )
/*++

Routine Description:

    Wrapper for RtlFreeHeap.

Arguments:

    BaseAddress     - Address to free.

Return Value:

    None.

--*/
{
    BOOLEAN b;

    b = RtlFreeHeap(RtlProcessHeap(),
                    0,
                    BaseAddress);
    WOWASSERT(b);
}

#pragma pack(push,8)
typedef struct _TempHeader {
   struct _TempHeader *Next;
} TEMP_HEADER, *PTEMP_HEADER;
#pragma pack(pop)

PVOID
WOW64DLLAPI
Wow64AllocateTemp(
    SIZE_T Size
    )
/*++

Routine Description:

    This function is called from a thunk to allocate temp memory which is
    freed once the thunk exits.

Arguments:

    Size - Supplies the amount of memory to allocate.

Return Value:

    Returns a pointer to the newly allocated memory.
    This function throws an exception if no memory is available.

--*/

{
    PTEMP_HEADER Header;

    if (!Size) {
        return NULL;
    }

    Header = RtlAllocateHeap(RtlProcessHeap(),
                             0,
                             sizeof(TEMP_HEADER) + Size
                             );
    if (!Header) {
        //
        // Throw an out-of-memory exception.  The thunk dispatcher will
        // catch this and clean up for us.  Normally you'd think we
        // could pass HEAP_GENERATE_EXCEPTIONS to RtlAllocateHeap and
        // the right thing would happen, but it doesn't.  NTRAID 413890.
        //
        EXCEPTION_RECORD ExceptionRecord;

        ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
        ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
        ExceptionRecord.NumberParameters = 1;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionInformation[ 0 ] = sizeof(TEMP_HEADER) + Size;

        RtlRaiseException( &ExceptionRecord );
    }

    Header->Next = Wow64TlsGetValue(WOW64_TLS_TEMPLIST);
    Wow64TlsSetValue(WOW64_TLS_TEMPLIST, Header);

    return (PUCHAR)Header + sizeof(TEMP_HEADER);
}

VOID
Wow64FreeTempList(
    VOID
    )
/*++

Routine Description:

    This function is called to free all memory that was allocated in the thunk.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PTEMP_HEADER Header,temp;
    BOOLEAN b;

    Header = Wow64TlsGetValue(WOW64_TLS_TEMPLIST);
    
    while(Header != NULL) {
       temp = Header->Next;
       b = RtlFreeHeap(RtlProcessHeap(),
                       0,
                       Header
                       );
       WOWASSERT(b);
       Header = temp;
    }

}

LONG
Wow64ServiceExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExInfo
    )
/*++

Routine Description:

    This function is called to determine if an exception should be handled
    by returning an error code to the application of the exception should
    be propaged up to the debugger.

    The purpose of this function is to make debugging thunks easier if ACCESS VIOLATIONS
    occure in the thunks.

Arguments:

    ExInfo - Supplies the exception information.

Return Value:

    EXCEPTION_CONTINUE_SEARCH - The exception should be passed to the debugger.
    EXCEPTION_EXECUTE_HANDLER - An error code should be passed to the application.

--*/
{
   
    LOGPRINT((TRACELOG, "Wow64ServiceExceptionFilter: Handling exception %x\n", ExInfo->ExceptionRecord->ExceptionCode));
  
    switch(ExInfo->ExceptionRecord->ExceptionCode) {
       case STATUS_ACCESS_VIOLATION:
       case STATUS_BREAKPOINT:
           return EXCEPTION_CONTINUE_SEARCH;
       default:
           return EXCEPTION_EXECUTE_HANDLER;
    }
}

LONG
Wow64HandleSystemServiceError(
    IN NTSTATUS Status,
    IN ULONG TableNumber,
    IN ULONG ApiNumber
    )
/*++

Routine Description:

    This function is called to determine the correct error number to return to
    the application based on the api called and the exception code.
   
    This function will set any values in the 64bit teb is necessary.

Arguments:

    Status - Supplies the exception code.
    TableNumber - Supplies the table number of the api called.
    ApiNumber - Supplies the number of the api called.

Return Value:

    return value.

--*/
{
   
   //
   // In the future, in may be a good idea to have a data structure to hold the exception cases.
   
   WOW64_API_ERROR_ACTION Action;
   LONG ActionParam;

   if (NULL == ServiceTables[TableNumber].ErrorCases) {
       Action = ServiceTables[TableNumber].DefaultErrorAction;
       ActionParam = ServiceTables[TableNumber].DefaultErrorActionParam;
   }
   else {
       Action = ServiceTables[TableNumber].ErrorCases[ApiNumber].ErrorAction;
       ActionParam = ServiceTables[TableNumber].ErrorCases[ApiNumber].ErrorActionParam;
   }

   switch(Action) {
      case ApiErrorNTSTATUS:
          return Status;
      case ApiErrorNTSTATUSTebCode:
          NtCurrentTeb32()->LastErrorValue = NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(Status);
          return Status;
      case ApiErrorRetval:
          return ActionParam;
      case ApiErrorRetvalTebCode:
          NtCurrentTeb32()->LastErrorValue = NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(Status);
          return ActionParam; 
      default:
          WOWASSERT(FALSE);
          return STATUS_INVALID_PARAMETER;         
   }

}


BOOL
WOW64DLLAPI
WOW64IsCurrentProcess (
    HANDLE hProcess
    )

/*++

Routine Description:

    Determines if hProcess corresponds to the current process.  

Arguments:

    hProcess    - handle to process to compare with the current one.

Return Value:

    If it does return TRUE, FALSE otherwise.
    
--*/
{
   NTSTATUS Status;
   PROCESS_BASIC_INFORMATION pbiProcess;
   PROCESS_BASIC_INFORMATION pbiCurrent;

   if (hProcess == NtCurrentProcess()) {
      return TRUE;
   }

   //
   // The process handle isn't obviously for the current procees - see if it
   // is an alias for the current process
   //
   Status = NtQueryInformationProcess(hProcess,
                                      ProcessBasicInformation,
                                      &pbiProcess,
                                      sizeof(pbiProcess),
                                      NULL
                                     );
   if (!NT_SUCCESS(Status)) {
      // Call failed for some reason - be pessimistic and flush the
      // current process's cache
      return TRUE;
   }

   Status = NtQueryInformationProcess(NtCurrentProcess(),
                                      ProcessBasicInformation,
                                      &pbiCurrent,
                                      sizeof(pbiCurrent),
                                      NULL
                                     );
   if (!NT_SUCCESS(Status)) {
      // Call failed for some reason - be pessimistic and flush the
      // current process's cache
      return TRUE;
   }

   if (pbiProcess.UniqueProcessId == pbiCurrent.UniqueProcessId) {
      return TRUE;
   }

   //
   // The hProcess specified is not the current process.  There
   // is no mechanism for cross-process Translation Cache flushes
   // yet.
   //
   return FALSE;
}

LONG
WOW64DLLAPI
Wow64SystemService(
    IN ULONG ServiceNumber,
    IN PCONTEXT32 Context32 //This is read only!
    )
/*++

Routine Description:

    This function is called by the CPU to dispatch a system call.

Arguments:

    ServiceNumber - Supplies the undecoded service number to call.
    Context32 - Supplies the readonly context used to call this service.

Return Value:

    None.

--*/
{
    ULONG Result;
    PVOID OldTempList;
    ULONG TableNumber, ApiNumber;
    THUNK_LOG_CONTEXT ThunkLogContext;

    // Indicate we're not in the CPU any more
    Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, FALSE);

    // Backup the old temp list.  
    // This is so that recurion into the thunks(APC calls) are handled properly.

    OldTempList = Wow64TlsGetValue(WOW64_TLS_TEMPLIST);
    Wow64TlsSetValue(WOW64_TLS_TEMPLIST, NULL);
   
    TableNumber = (ServiceNumber >> 12) & 0xFF;
    ApiNumber = ServiceNumber & 0xFFF;

    if (TableNumber > NUMBER_SERVICE_TABLES) {
        return STATUS_INVALID_SYSTEM_SERVICE;
    }

    if (ApiNumber > ServiceTables[TableNumber].Limit) {
        return STATUS_INVALID_SYSTEM_SERVICE;
    }
    
    try {

        try {
            pfnWow64SystemService Service;

            // Synchronize the 64bit TEB with the 32bit TEB

            NtCurrentTeb()->LastErrorValue = NtCurrentTeb32()->LastErrorValue;
            Service = (pfnWow64SystemService)ServiceTables[TableNumber].Base[ApiNumber];

            if (pfnWow64LogSystemService)
            {
                ThunkLogContext.Stack32 = (PULONG)Context32->Edx;
                ThunkLogContext.TableNumber = TableNumber;
                ThunkLogContext.ServiceNumber = ApiNumber;
                ThunkLogContext.ServiceReturn = FALSE;

                (*pfnWow64LogSystemService)(&ThunkLogContext);

            }

            Result = (*Service)((PULONG)Context32->Edx);

            if (pfnWow64LogSystemService)
            {
                ThunkLogContext.ServiceReturn = TRUE;
                ThunkLogContext.ReturnResult = Result;
                (*pfnWow64LogSystemService)(&ThunkLogContext);
            }


        } except(Wow64ServiceExceptionFilter(GetExceptionInformation())) {
        
            // Return a predefined error to the application.
            Result = Wow64HandleSystemServiceError(GetExceptionCode(), TableNumber, ApiNumber);

        }
     
    } finally {

        // Synchronize the 32bit TEB with the 64bit TEB
        NtCurrentTeb32()->LastErrorValue  = NtCurrentTeb()->LastErrorValue;

        Wow64FreeTempList();

        // Restore the old templist
        Wow64TlsSetValue(WOW64_TLS_TEMPLIST, OldTempList);
     
    }

    // Indicate we're going back into the CPU now
    Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, (PVOID)TRUE);

    return Result;
}

VOID
RunCpuSimulation(
    VOID
    )
/*++

Routine Description:

    Call the CPU to simulate 32-bit code and handle exeptions if they
    occur.

Arguments:

    None.

Return Value:

    None.  Never returns.

--*/
{
    while (1) {
        try {
            //
            // Indicate we're in the CPU now.  This controls !first in
            // the debugger.
            //
            Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, (PVOID)TRUE);

            //
            // Go run the code.
            // Only way out of CpuSimulate() is an exception...
            //
            CpuSimulate();

        } except (Wow64DispatchExceptionTo32(GetExceptionInformation())) {
            //
            // The exception handler sets things up so we can run the
            // ia32 exception code. Thus, when it returns, we just
            // loop back and start simulating the ia32 cpu...
            //

            // Do nothing...
        }
    }

    //
    // Hey, how did that happen?
    //
    WOWASSERT(FALSE);
}

PWOW64_SYSTEM_INFORMATION
Wow64GetEmulatedSystemInformation(
     VOID
     )
{
    return &EmulatedSysInfo;
}

PWOW64_SYSTEM_INFORMATION
Wow64GetRealSystemInformation(
     VOID
     )
{
    return &RealSysInfo;
}


ULONG 
Wow64SetupApcCall(
    IN ULONG NormalRoutine,
    IN PCONTEXT32 NormalContext,
    IN ULONG Arg1,
    IN ULONG Arg2
    )
/*++

Routine Description:

    This functions initializes a APC call on the 32bit stack and sets the appropriate
    32bit context.

Arguments:

    NormalRoutine - Supplies the 32bit routine that the APC should call.

    NormalContext - Supplies a context that will be restored after
                    the APC is completed. 

    Arg1          - System argument 1.

    Arg2          - System argument 2.

Return Value:

    The address in 32bit code that execution will continue at.

--*/


{
    ULONG SP;
    PULONG Ptr;

    //
    // Build the stack frame for the Apc call.

    SP = CpuGetStackPointer();
    SP = (SP - sizeof(CONTEXT32)) & ~7; // make space for CONTEXT32 and qword-align it
    Ptr = (PULONG)SP;
    RtlCopyMemory(Ptr, NormalContext, sizeof(CONTEXT32));
    Ptr -= 4;
    Ptr[0] = NormalRoutine;              // NormalRoutine
    Ptr[1] = SP;                         // NormalContext
    Ptr[2] = Arg1;                       // SystemArgument1
    Ptr[3] = Arg2;                       // SystemArgument2
    SP = PtrToUlong(Ptr);
    CpuSetStackPointer(SP);
    CpuSetInstructionPointer(Ntdll32KiUserApcDispatcher);

    return Ntdll32KiUserApcDispatcher;    
      
}


NTSTATUS
Wow64SkipOverBreakPoint(
    IN PCLIENT_ID ClientId,
    IN PEXCEPTION_RECORD ExceptionRecord)
/*++

Routine Description:

    Changes a thread's Fir (IP) to point to the next instruction following
    the hard-coded breakpoint. Caller should guarantee that Context.Fir is
    pointing at the hardcoded breakpoint instruction.

Arguments:

    ClientId        - Client Id of the faulting thread by the bp
    ExceptionRedord - Exception record at the time of hitting the breakpoint.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS NtStatus;
    HANDLE ThreadHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    CONTEXT Context;

    
    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

    NtStatus = NtOpenThread(&ThreadHandle,
                            (THREAD_GET_CONTEXT | THREAD_SET_CONTEXT),
                            &ObjectAttributes,
                            ClientId);

    if (NT_SUCCESS(NtStatus))
    {
        Context.ContextFlags = CONTEXT_CONTROL;
        NtStatus = NtGetContextThread(ThreadHandle,
                                      &Context);

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = Wow64pSkipContextBreakPoint(ExceptionRecord,
                                                   &Context);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = NtSetContextThread(ThreadHandle,
                                              &Context);
            }
        }

        NtClose(ThreadHandle);
    }

    return NtStatus;
}


NTSTATUS
Wow64GetThreadSelectorEntry(
    IN HANDLE ThreadHandle,
    IN OUT PVOID DescriptorTableEntry,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL)
/*++

Routine Description:

    Retreives the descriptor entry for the specified selector.

Arguments:

    ThreadHandle            - Thread handle to retreive the descriptor for
    DescriptorTableEntry    - Address of X86_DESCRIPTOR_TABLE_ENTRY
    Length                  - Specified the length of DescriptorTableEntry structure
    ReturnLength (OPTIONAL) - Returns the number of bytes returned

Return Value:

    NTSTATUS

--*/
{
    PTEB32 Teb32;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PX86_DESCRIPTOR_TABLE_ENTRY X86DescriptorEntry = DescriptorTableEntry;

    try 
    {
        if (Length != sizeof(*X86DescriptorEntry))
        {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        switch (X86DescriptorEntry->Selector & (~(WORD)RPL_MASK))
        {
        case KGDT_NULL:
            RtlZeroMemory(&X86DescriptorEntry->Descriptor,
                          sizeof(X86DescriptorEntry->Descriptor));
            break;

        case KGDT_R3_CODE:
            X86DescriptorEntry->Descriptor.LimitLow                  = 0xffff;
            X86DescriptorEntry->Descriptor.BaseLow                   = 0x0000;
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseHi     = 0x0000;
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseMid    = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Type        = 0x1b;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Dpl         = 0x03;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Pres        = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.LimitHi     = 0x0f;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Sys         = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Reserved_0  = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Default_Big = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Granularity = 0x01;
            break;

        case KGDT_R3_DATA:
            X86DescriptorEntry->Descriptor.LimitLow                  = 0xffff;
            X86DescriptorEntry->Descriptor.BaseLow                   = 0x0000;
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseHi     = 0x0000;
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseMid    = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Type        = 0x13;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Dpl         = 0x03;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Pres        = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.LimitHi     = 0x0f;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Sys         = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Reserved_0  = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Default_Big = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Granularity = 0x01;
            break;

        case KGDT_R3_TEB:
            Teb32 = NtCurrentTeb32();
            X86DescriptorEntry->Descriptor.LimitLow                  = 0x0fff;
            X86DescriptorEntry->Descriptor.BaseLow                   = (WORD)(PtrToUlong(Teb32) & 0xffff);
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseHi     = (BYTE)((PtrToUlong(Teb32) >> 24) & 0xff);
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseMid    = (BYTE)((PtrToUlong(Teb32) >> 16) & 0xff);
            X86DescriptorEntry->Descriptor.HighWord.Bits.Type        = 0x13;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Dpl         = 0x03;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Pres        = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.LimitHi     = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Sys         = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Reserved_0  = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Default_Big = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Granularity = 0x00;
            break;

        default:
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        if (NT_SUCCESS(NtStatus))
        {
            if (ARGUMENT_PRESENT(ReturnLength)) 
            {
                *ReturnLength = sizeof(X86_LDT_ENTRY);
            }        
        }
    } 
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\alpha\thunk.s ===
//       TITLE("Win32 Thunks")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    thunk.s
//
// Abstract:
//
//    This module implements Win32 functions that must be written in assembler.
//
// Author:
//
//    Mark Lucovsky (markl) 5-Oct-1990
//
// Revision History:
//
//    Thomas Van Baak (tvb) 21-Jul-1992
//    
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

        SBTTL("Switch Stack Then Terminate")
//++
//
// VOID
// Wow64BaseSwitchStackThenTerminate (
//     IN PVOID StackLimit,
//     IN PVOID NewStack,
//     IN DWORD ExitCode
//     )
//
// Routine Description:
//
//     This API is called during thread termination to delete a thread's
//     stack, switch to a stack in the thread's TEB, and then terminate.
//
// Arguments:
//
//     StackLimit (a0) - Supplies the address of the stack to be freed.
//
//     NewStack (a1) - Supplies an address within the terminating thread's TE
//         that is to be used as its temporary stack while exiting.
//
//     ExitCode (a2) - Supplies the termination status that the thread
//         is to exit with.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(Wow64BaseSwitchStackThenTerminate)

//
// Switch stacks and then jump to Wow64BaseFreeStackAndTerminate.
//

        mov     a1, sp                  // set new stack pointer
        mov     a2, a1                  // set exit code argument
        br      zero, Wow64BaseFreeStackAndTerminate // jump

        .end Wow64BaseSwitchStackThenTerminate
        
//++
//
// VOID
// Wow64pBaseAttachCompleteThunk (
//     VOID
//     )
//
// Routine Description:
//
//     This function is called after a successful debug attach. Its
//     purpose is to call portable code that does a breakpoint, followed
//     by an NtContinue.
//   
//     cloned from ..\base\client\alpha\thunk.s
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(Wow64pBaseAttachCompleteThunk)

        mov     s0, a0                         // set context frame address argument
        br      zero, Wow64pBaseAttachComplete // jump to subroutine

        .end Wow64pBaseAttachCompleteThunk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\alpha\call32.s ===
//
//
// Copyright (c) 1998-2000  Microsoft Corporation
//
// Module Name:
//
//    call32.s
//
// Abstract:
//
//    This module implements calls from 64-bit code to 32-bit.
//
// Author:
//
//    29-May-1998 Barrybo, Created
//
// Revision History:
//
//--
#include "ksalpha.h"

    LEAF_ENTRY(Wow64PrepareForException)
//++
//
//Wow64PrepareForException
//
// Routine Description:
//
//     Called from 64-bit ntdll.dll just before it dispatches an exception.
//     This is a no-op for AXP64 - it is intended to be used for CPU
//     emulators which alias x86 ESP to the native SP.
//
// Arguments:
//
//     s0   - exception record
//     s1   - context record
//
// Return Value:
//
//     none.
//
//--
        ret     zero, (ra)
    .end Wow64PrepareForException
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\alpha\call64.s ===
//
//
// Copyright (c) 1998  Microsoft Corporation
//
// Module Name:
//
//    call64.s
//
// Abstract:
//
//    This module implements calls from 32-bit code to 64-bit.
//
// Author:
//
//    29-May-1998 Barrybo, Created
//
// Revision History:
//
//--
#include "ksalpha.h"

#define FRAMESIZE 0x30
#if (FRAMESIZE & f) != 0
#error FRAMESIZE must be 16-byte aligned
#endif
#define StRa      FRAMESIZE-8
#define StFp      FRAMESIZE-16

    NESTED_ENTRY(Wow64pSystemService, FRAMESIZE, ra)
//++
//
//Wow64SystemService
//
// Routine Description:
//
//     Call from 32-bit code - it is similar to Wx86DispatchBop() in that
//     it decodes some data to determine which API thunk to call, then
//     calls that thunk.  It is very similar to the INT 2E kernel trap
//     handler.
//
// Arguments:
//
//     a0 = Call Context
//     a1 = Function address
//     a2 = Number of arguments in bytes.
// 
// Return Value:
//
//     v0       - return value from the system call
//
//--
        lda     sp, -FRAMESIZE(sp)
        stq     ra, StRa(sp)
        stq     fp, StFp(sp)
        trapb
        mov     sp, fp
        PROLOGUE_END

        mov     a0, t0 //Contains context
        mov     a1, t1 //Contains function address
        mov     a2, t2 //Contains the number of arguments in bytes
        
        // Load up the integer argument registers.
        ldq     a0, CxIntA0(t0)
        ldq     a1, CxIntA1(t0)
        ldq     a2, CxIntA2(t0)
        ldq     a3, CxIntA3(t0)
        ldq     a4, CxIntA4(t0)
        ldq     a5, CxIntA5(t0)
        
        // Load up the floating point argument registers
        ldt     f16, CxFltF16(t0)
        ldt     f17, CxFltF17(t0)
        ldt     f18, CxFltF18(t0)
        ldt     f19, CxFltF19(t0)
        ldt     f20, CxFltF20(t0)
        ldt     f21, CxFltF21(t0)
     
        cmpule  t2, 0x30, t3  //Does the function require memory args?
        bne     t3, DoCall    //Branch if the cmp is true.

        subq    t2, 0x30, t2  //Number of in memory bytes
        addq    t2, 0x1f, t2  //Round up to hexwords.
        bic     t2, 0x1f, t2  //Ensure hexaword alignment
        mov     sp, t10       //Set copy destination end address
        subq    sp, t2, sp    //Allocate space on the stack
        mov     sp, t9        //Set copy destination start address
        ldq     t11, CxIntSp(t0) //Set copy source

CopyLoop:
        ldq     t5, 24(t11)             // get argument from previous stack
        ADDP    t11, 32, t11            // next hexaword on previous stack
        ADDP    t9, 32, t9              // next hexaword on this stack
        cmpeq   t9, t10, t12            // at end address?
        stq     t5, -8(t9)              // store argument on this stack
        ldq     t6, -16(t11)            // argument from previous stack
        ldq     t7, -24(t11)            // argument from previous stack
        ldq     t8, -32(t11)            // argument from previous stack
        stq     t6, -16(t9)             // save argument on this stack
        stq     t7, -24(t9)             // save argument on this stack
        stq     t8, -32(t9)             // save argument on this stack
        beq     t12, CopyLoop           // if eq, get next block 
DoCall:
        jsr     ra, (t1)
   
        mov     fp, sp
        ldq     ra, StRa(sp)
        trapb
        ldq     fp, StFp(sp)
        addq    sp, FRAMESIZE
        ret     zero, (ra)

    .end Wow64SystemService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\alpha\misc.c ===
/*++                 

Copyright (c) 1998 Microsoft Corporation

Module Name:

    misc.c

Abstract:
    
    Random architecture dependent function for wow64.dll

Author:

    13-Aug-1998 mzoran

Revision History:

--*/

#define _WOW64DLLAPI_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <minmax.h>
#include "nt32.h"
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;

VOID
Wow64NotifyDebuggerHelper(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:
  
    This is a copy of RtlRaiseException, except it accepts the FirstChance parameter 
    specifing if this is a first chance exception.

    ExceptionRecord - Supplies the 64bit exception record to be raised.
    FirstChance - TRUE is this is a first chance exception.  

Arguments:

    None - Doesn't return through the normal path.

--*/
{
    ULONG_PTR ControlPc;
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONG_PTR NextPc;

    //
    // Capture the current context, virtually unwind to the caller of this
    // routine, set the fault instruction address to that of the caller, and
    // call the raise exception system service.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = (ULONG_PTR)ContextRecord.IntRa - 4;
    FunctionEntry = RtlLookupFunctionEntry(ControlPc);
    NextPc = RtlVirtualUnwind(ControlPc,
                              FunctionEntry,
                              &ContextRecord,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ContextRecord.Fir = (ULONGLONG)(LONG_PTR)NextPc + 4;
    if (ExceptionRecord->ExceptionAddress == NULL)
    {
        ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.Fir;
    }
    NtRaiseException(ExceptionRecord, &ContextRecord, FirstChance);

    WOWASSERT(FALSE);
}


VOID
ThunkContext32TO64(
    IN PCONTEXT32 Context32,
    OUT PCONTEXT Context64,
    IN ULONGLONG StackBase
    )
/*++

Routine Description:
  
    Thunk a 32-bit CONTEXT record to 64-bit.  This isn't a general-purpose
    routine... it only does the minimum required to support calls to
    NtCreateThread from 32-bit code.  The resulting 64-bit CONTEXT is
    passed to 64-bit NtCreateThread only.

    This routine is loosely based on windows\base\client\*\context.c
    BaseInitializeContext().

Arguments:

    Context32   - IN 32-bit CONTEXT
    Context64   - OUT 64-bit CONTEXT
    StackBase   - IN 64-bit stack base for the new thread

Return:

    None.  Context64 is initialized.

--*/
{
    RtlZeroMemory((PVOID)Context64, sizeof(CONTEXT));
    Context64->IntGp = 1;
    Context64->IntRa = 1;
    Context64->ContextFlags = CONTEXT_FULL;
    Context64->IntSp = StackBase;

    Context64->Fir = (ULONGLONG)Context32->Eip;
    Context64->IntA0 = (ULONGLONG)Context32->Eax;   // InitialPc
    Context64->IntA1 = (ULONGLONG)Context32->Ebx;   // Parameter
}


NTSTATUS
InitJumpToDebugAttach(
    IN OUT PVOID Buffer,
    IN OUT PSIZE_T RegionSize
    )
/*++

Routine Description:
  
    This routine patches in the instruction to jump to
    Wow64pBaseAttachCompleteThunk/
    
Arguments:

    Buffer      - Buffer to receive jmp instruction stream
    RegionSize  - size of buffer on input, and number of bytes written on output

Return:

    NTSTATUS

--*/
{
    PULONG OpCodes = Buffer;


    if (*RegionSize < 0x0000000c) 
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // lets' do this :
    //
    // ldah t0, HIWORD(Wow64pBaseAttachCompleteThunk)
    // lda t0, LOWORD(Wow64pBaseAttachCompleteThunk)
    // jmp zero, (t1), 0

    // ldah t1, address
    OpCodes[0]  = (PtrToUlong(Wow64pBaseAttachCompleteThunk)) >> 16;
    OpCodes[0] |= 0x243f0000L;

    // lda t0, off(t0)
    OpCodes[1]  = (PtrToUlong(Wow64pBaseAttachCompleteThunk)) & 0x0000ffffL;
    if (OpCodes[1] & 0x8000)
    {
        OpCodes[0] += 1;
    }
    OpCodes[1] |= 0x20210000L;

    // jmp zero, (t0), 0
    OpCodes[2]  = 0x6be10000L;

    *RegionSize = 0x0000000c;

    return STATUS_SUCCESS;
}


NTSTATUS
Wow64pSkipContextBreakPoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT Context)
/*++

Routine Description:

    Advances Context->Fir to the instruction following the hard coded bp.

Arguments:

    ExceptionRecord  - Exception record at the time of hitting the bp
    Context          - Context to change

Return:

    NTSTATUS
--*/
{
    Context->Fir = (Context->Fir + 4);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\wow64p.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64p.h

Abstract:

    Private header for wow64.dll

Author:

    11-May-1998 BarryBo

Revision History:

--*/

#ifndef _WOW64P_INCLUDE
#define _WOW64P_INCLUDE

//
// All of this is so ke.h can be included from ntos\inc, to define
// KSERVICE_TABLE_DESCRIPTOR.
//
#include <ntosdef.h>
#include <procpowr.h>
#ifdef _AMD64_
#include <amd64.h>
#endif
#ifdef _IA64_
#include <v86emul.h>
#include <ia64.h>
#endif
#include <arc.h>
#include <ke.h>

#include "wow64.h"
#include "wow64log.h"
#include "wow64warn.h"

#define ROUND_UP(n,size)        (((ULONG)(n) + (size - 1)) & ~(size - 1))
#define WX86_MAX_ALLOCATION_RETRIES 3

#define WOW64_SUSPEND_MUTANT_NAME    L"SuspendThreadMutant"


//
// Data structure to represent relative paths inside system32 that
// shouldn't be redirected by our Object name redirector. Only used
// inside RedirectObjectName(...)
//
typedef struct _PATH_REDIRECT_EXEMPT
{
    WCHAR *Path;
    ULONG CharCount;
    BOOLEAN ThisDirOnly;
} PATH_REDIRECT_EXEMPT ;


//
// Builds a table to thunk environment variables at startup.
//

typedef struct _ENVIRONMENT_THUNK_TABLE
{
    WCHAR *Native;

    WCHAR *X86;

    WCHAR *FakeName;

    ULONG IsX86EnvironmentVar;

} ENVIRONMENT_THUNK_TABLE, *PENVIRONMENT_THUNK_TABLE;


//
// Code, Data and Teb default GDT entries (descriptor offsets)
// extracted from public\sdk\inc\nti386.h
//
#define KGDT_NULL       0
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_R3_TEB     56
#define RPL_MASK        3

// from wow64.c
extern WOW64SERVICE_TABLE_DESCRIPTOR ServiceTables[MAX_TABLE_INDEX];

LONG
Wow64DispatchExceptionTo32(
    IN struct _EXCEPTION_POINTERS *ExInfo
    );

VOID
RunCpuSimulation(
    VOID
    );


// from init.c
extern ULONG Ntdll32LoaderInitRoutine;
extern ULONG Ntdll32KiUserExceptionDispatcher;
extern ULONG Ntdll32KiUserApcDispatcher;
extern ULONG Ntdll32KiUserCallbackDispatcher;
extern ULONG Ntdll32KiRaiseUserExceptionDispatcher;
extern ULONG NtDll32Base;
extern WOW64_SYSTEM_INFORMATION RealSysInfo;
extern WOW64_SYSTEM_INFORMATION EmulatedSysInfo;
extern UNICODE_STRING NtSystem32Path;
extern UNICODE_STRING NtWindowsImePath;
extern UNICODE_STRING RegeditPath;


NTSTATUS
ProcessInit(
    PSIZE_T pCpuThreadSize
    );

NTSTATUS
ThreadInit(
    PVOID pCpuThreadData
    );

NTSTATUS
InitializeContextMapper(
   VOID
   );

NTSTATUS
Wow64pInitializeWow64Info(
    VOID
    );

VOID
ThunkStartupContext64TO32(
   IN OUT PCONTEXT32 Context32,
   IN PCONTEXT Context64
   );

VOID
SetProcessStartupContext64(
    OUT PCONTEXT Context64,
    IN HANDLE ProcessHandle,
    IN PCONTEXT32 Context32,
    IN ULONGLONG InitialSP64,
    IN ULONGLONG TransferAddress64
    );

VOID
Run64IfContextIs64(
    IN PCONTEXT Context,
    IN BOOLEAN IsFirstThread
    );

VOID
Wow64pBaseAttachComplete(
    IN PCONTEXT Context
    );

NTSTATUS
InterceptBaseAttachComplete(
    VOID
    );

// from thread.c
NTSTATUS
Wow64pInitializeSuspendMutant(
    VOID);


//////////////////////////////////
// Debug log startup and shutdown.
//////////////////////////////////

extern PFNWOW64LOGSYSTEMSERVICE pfnWow64LogSystemService;


VOID
InitializeDebug(
    VOID
    );

VOID ShutdownDebug(
     VOID
     );

// from *\call32.asm

// from debug.c
extern UCHAR Wow64LogLevel;

// from *\call64.asm
extern VOID ApiThunkDispatcher(VOID);

typedef LONG (*pfnWow64SystemService)(PULONG pBaseArgs);


// from *\systable.asm
extern ULONG KiServiceLimit;
extern CHAR KiArgumentTable[];
extern UINT_PTR KiServiceTable[];

// from misc.c
NTSTATUS
Wow64InitializeEmulatedSystemInformation(
    VOID
    );

VOID
ThunkContext32TO64(
    IN PCONTEXT32 Context32,
    OUT PCONTEXT Context64,
    IN ULONGLONG StackBase
    );

NTSTATUS
Wow64pSkipContextBreakPoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT Context
    );

NTSTATUS
InitJumpToDebugAttach(
    IN OUT PVOID Buffer,
    IN OUT PSIZE_T RegionSize
    );

// from thunk.s
VOID
Wow64pBaseAttachCompleteThunk (
    VOID
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\amd64\except.asm ===
TITLE   "WOW Prepare For Exception"
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   except.asm
;
; Abstract:
;
;   This module implements the platform specific code to switch from the
;   32-bit stack to the 64-bit stack when an exception occurs.
;
; Author:
;
;   David N. Cutler (davec) 20-Feb-2001
;
; Envirnoment:
;
;   User mode.
;
;--

include ksamd64.inc

;++
;
; VOID
; Wow64PrepareForException (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PCONTEXT ContextRecord
;     )
;
; Routine Description:
;
;    This function is called from the 64-bit exception dispatcher just before
;    it dispatches an exception when the current running program is a 32-bit
;    legacy application.
;
;    N.B. This function uses a nonstandard calling sequence.
;
; Arguments:
;
;    ExceptionRecord (rsi) - Supplies a pointer to an exception record.
;
;    ContextRecord (rdi) - Supplies a pointer to a context record.
;
; Return Value:
;
;    None.
;
;--

    NESTED_ENTRY Wow64PrepareForException, _TEXT$00

    alloc_stack 24                      ; dummy

    END_PROLOGUE

; ****** fixfix ******

    ret                                 ;

    NESTED_END Wow64PrepareForException, _TEXT$00

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\amd64\swstack.asm ===
TITLE   "Swtich Stack and Terminate"
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   swstack.asm
;
; Abstract:
;
;   This module implements the platform specific code to switch stacks and
;   terminate.
;
; Author:
;
;   David N. Cutler (davec) 28-Feb-2001
;
; Envirnoment:
;
;   User mode.
;
;--

include ksamd64.inc

;++
;
; VOID
; Wow64BaseSwitchStackThenTerminate (
;     IN PVOID StackLimit,
;     IN PVOID NewStack,
;     IN DWORD ExitCode
;     )
;
; Routine Description:
;
;    This function is called during thread termination to delete the thread
;    stack, switch to a new stack, then terminate the thread.
;
; Arguments:
;
;    StackLimit (rcx) - Supplies the new stack limit.
;
;    StackBase (rdx) - Supplies the new stack base.
;
;    ExitCode (r8d) - Supplies the exit code.
;
; Return Value:
;
;    None.
;
;--

    NESTED_ENTRY Wow64BaseSwitchStackThenTerminate, _TEXT$00

    alloc_stack 24                      ; dummy

    END_PROLOGUE

; ****** fixfix ******

    ret                                 ;

    NESTED_END Wow64BaseSwitchStackThenTerminate, _TEXT$00

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\amd64\misc.c ===
/*++                 

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    misc.c

Abstract:
    
    Random architecture dependent function for wow64.dll

Author:

    13-Aug-1998 mzoran

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <minmax.h>
#include "nt32.h"
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;


#define GET_IMM7B(x)     (x & 0x7fUI64)
#define GET_IMM9D(x)     ((x >> 7) & 0x1ffUI64)
#define GET_IMM5C(x)     ((x >> 16) & 0x1fUI64)
#define GET_IMMIC(x)     ((x >> 21) & 0x1UI64)
#define GET_IMM41(x)     ((x >> 22) & 0x1fffffUI64)
#define GET_IMMI(x)      ((x >> 63) & 0x1UI64)


VOID
Wow64NotifyDebuggerHelper(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:
  
    This is a copy of RtlRaiseException, except it accepts the FirstChance parameter 
    specifing if this is a first chance exception.

    ExceptionRecord - Supplies the 64bit exception record to be raised.
    FirstChance - TRUE is this is a first chance exception.  

Arguments:

    None - Doesn't return through the normal path.

--*/

{

#if 0

    ULONGLONG ImageBase;
    ULONGLONG TargetGp;
    ULONGLONG ControlPc;
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONGLONG NextPc;

    //
    // Capture the current context, virtually unwind to the caller of this
    // routine, set the fault instruction address to that of the caller, and
    // call the raise exception system service.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, &TargetGp);
    NextPc = RtlVirtualUnwind(ImageBase,
                              ControlPc,
                              FunctionEntry,
                              &ContextRecord,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ContextRecord.StIIP = NextPc + 8;
    ContextRecord.StIPSR &= ~((ULONGLONG) 3 << PSR_RI);
    if (ExceptionRecord->ExceptionAddress == NULL)
    {
        ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.StIIP;
    }
    NtRaiseException(ExceptionRecord, &ContextRecord, FirstChance);

    WOWASSERT(FALSE);

#endif

}


VOID
ThunkContext32TO64(
    IN PCONTEXT32 Context32,
    OUT PCONTEXT Context64,
    IN ULONGLONG StackBase
    )
/*++

Routine Description:
  
    Thunk a 32-bit CONTEXT record to 64-bit.  This isn't a general-purpose
    routine... it only does the minimum required to support calls to
    NtCreateThread from 32-bit code.  The resulting 64-bit CONTEXT is
    passed to 64-bit NtCreateThread only.

Arguments:

    Context32   - IN 32-bit CONTEXT
    Context64   - OUT 64-bit CONTEXT
    StackBase   - IN 64-bit stack base for the new thread

Return:

    None.  Context64 is initialized.

--*/

{

#if 0

    RtlZeroMemory((PVOID)Context64, sizeof(CONTEXT));

    //
    // Setup the stuff that doesn't usually change
    // Need to worry about psr/fpsr or other ia64 control or will
    // default values be used when the kernel SANITIZEs these values?
    // When the kernel thread init code is working again, these 3 constants
    // won't need to be set here.
    //
    Context64->SegCSD = USER_CODE_DESCRIPTOR;
    Context64->SegSSD = USER_DATA_DESCRIPTOR;
    Context64->Cflag = (ULONGLONG)((CR4_VME << 32) | CR0_PE | CFLG_II);

    Context64->StIPSR = USER_PSR_INITIAL;
    Context64->RsPFS = 0;
    Context64->RsBSP = Context64->RsBSPSTORE = Context64->IntSp = StackBase;
    Context64->IntSp -= STACK_SCRATCH_AREA; // scratch area as per convention
    Context64->IntS1 = (ULONG_PTR)Context32->Eax;     // InitialPc
    Context64->IntS2 = (ULONG_PTR)Context32->Ebx;     // Parameter
    Context64->RsRSC = (RSC_MODE_EA<<RSC_MODE)
                   | (RSC_BE_LITTLE<<RSC_BE)
                   | (0x3<<RSC_PL);

    Context64->IntS0 = Context64->StIIP = (ULONG_PTR)Context32->Eip;
    // Set the initial GP to non-zero.  If it is zero, ntos\ps\ia64\psctxi64.c
    // will treat initial IIP as a PLABEL_DESCRIPTOR pointer and dereference it.
    // That's bad if we are using IIP to point to an IA32 address.
    Context64->IntGp = ~0i64;
    Context64->ContextFlags = CONTEXT_CONTROL| CONTEXT_INTEGER;
    Context64->ApUNAT = 0xFFFFFFFFFFFFEDF1ULL;
    Context64->Eflag = 0x00003002ULL;

#endif

}

NTSTATUS
Wow64pSkipContextBreakPoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT Context)
/*++

Routine Description:

    Advances Context->StIIP to the instruction following the hard coded bp.

Arguments:

    ExceptionRecord  - Exception record at the time of hitting the bp
    Context          - Context to change

Return:

    NTSTATUS

--*/

{

#if 0

    PPSR IntPSR;
    ULONGLONG IntIP;

    IntIP  = (ULONGLONG)ExceptionRecord->ExceptionAddress;
    IntPSR = (PPSR)&Context->StIPSR;
    
    if ((IntIP & 0x000000000000000fUI64) != 0x0000000000000008UI64)
    {
        IntPSR->sb.psr_ri = (IntPSR->sb.psr_ri + 1);
    }
    else
    {
        IntPSR->sb.psr_ri = 0x00;
        Context->StIIP = (Context->StIIP + 0x10);
    }

#endif

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\ia64\call32.s ===
//
//
// Copyright (c) 1998-2000  Microsoft Corporation
//
// Module Name:
//
//    call32.s
//
// Abstract:
//
//    This module implements calls from 64-bit code to 32-bit.
//
// Author:
//
//    01-June-1998 Barrybo, Created
//
// Revision History:
//
//--
#include "ksia64.h"

.file   "call32.s"

// This is the offset of the cDispatch field in a CALLBACKFRAGMENT
#define cDispatch       16

//
// Globals imported
//
        .global __imp_CpuResetToConsistentState
        .global __imp_RtlCopyMemory

        NESTED_ENTRY(Wow64PrepareForException)
// called with:
//
//  s0 = ptr to IA64 exception record
//  s1 = ptr to IA64 context record
//
// returns with:
//  none.  stack pointer will be switched to 64-bit stack
//
// This routine needs to make sure all the excpetion stuff is properly
// located on the ia64 stack so the ia64 excpetion handling code
// can do the right thing. Since an exception can happen while running ia32
// code, the excpetion information may be on the ia32 stack instead. Since
// the OS has gone through a lot of work to put it there, we just want to
// copy it (in its entirety) onto the ia64 stack and then update the ia64
// stack pointers appropriately
//
        NESTED_SETUP(0, 5, 3, 0)        // 5 locals, 3 out arg,
                                        // pfs saved in loc0, brp in loc1
        mov loc2 = gp                   // save gp
        PROLOGUE_END

        //
        // Did the exception happen on the ia32 or ia64 stack?
        // The answer is based on the value in TLS (WOW64_TLS_STACKPTR64).
        //
        add     t2 = TeDeallocationStack+8, teb     // Get the TLS address
        ;;

        ld8     t3 = [t2]               // Get WOW64_TLS_STACKPTR64 value
        ;;

        cmp.eq  pt0 = t3, r0            // Was WOW64_TLS_STACKPTR64 zero?
        ;;
        
  (pt0) br.cond.dpnt.few OnIa64Stk      // zero means already on ia64 stack

        //
        // Woops, on the ia32 stack 
        // So, the kernel did a lot of work to put everything it needs on
        // the ia32 stack. So let's copy everything it has done
        // onto the ia64 stack...

        mov     loc4 = sp               // Save the current ia32 sp
        adds    t4 = CxIntSp, s1        // Offset into cntx record for sp
        ;;

        ld8     t2 = [t4]               // Get the ia32 ptr before exception       
        ;;

        sub     t5 = t2, loc4           // Size of exception on ia32 stack
                                        // Remember stack grows down...
        ;;

        sub     loc3 = t3, t5           // Create the same space on ia64 stack
        mov     t6 = 0xf
    
        ;;
        andcm   loc3 = loc3, t6           // start on 16 byte boundaries

        ;;
        add     sp = -10, loc3          // Make ia64 calls on ia64 stack

        mov     out0 = loc3             // Copy to ia64 stack area
        mov     out1 = loc4             // Copy from ia32 stack area
        mov     out2 = t5               // Copy size of exception area

        //
        // call RtlMoveMemory
        //
        add     t1 = @gprel(__imp_RtlCopyMemory), gp
        ;;
        ld8     t1 = [t1]                   // Become a pointer to the plabel
        ;;
        ld8     t2 = [t1], PlGlobalPointer - PlEntryPoint   // Get entry point
        ;;
        ld8     gp = [t1]                   // Get the GP
        mov     bt0 = t2
        ;;
        br.call.sptk.many brp = bt0

        mov     gp = loc2

        //
        // Ok, everything has been copied over... Now update s0 and s1 with
        // the new values on the ia64 stack
        //
        sub     t3 = s0, loc4           // find exceptn frame in ia32 stack
        sub     t4 = s1, loc4           // find context frame in ia32 stack
        ;;

        add     s0 = t3, loc3           // Set exception frame in ia64 stack
        add     s1 = t4, loc3           // Set context frame in ia64 stack
        mov     sp = loc3               // and reset ia64 SP
        ;;

OnIa64Stk:
        //
        // Now, we know sp is an ia64 stack, so put the exception pointers
        // on the stack so we can make a call
        //
        add     t0 = -0x10, sp          // allocate some space from the stack
        add     t3 = -0x10, sp          // keep a copy
        ;;
        add     sp = -0x20, sp          // Calling convention says leave room...
        st8     [t0] = s0,8             // pExceptionRecord (ExceptionPointer[0])
        ;;
        st8     [t0] = s1               // store pContext (ExceptionPointer[1])
        mov     out0 = t3               // argument = PEXCEPTION_POINTERS

        //
        // Now send the exception to CpuResetToConsistantState()
        //
        // CpuResetToConsistantState() needs to:
        // 1) Zero out WOW64_TLS_STACKPTR64
        // 2) Check if the exception was from ia32 or ia64
        //     If exception was ia64, do nothing and return
        //     If exception was ia32, needs to:
        // 3) Needs to copy CONTEXT eip to the TLS (WOW64_TLS_EXCEPTIONADDR)
        // 4) reset CONTEXT ip to a valid ia64 ip (usually
        //      the destination of the jmpe)
        // 5) reset CONTEXT sp to a valid ia64 sp (TLS
        //      entry WOW64_TLS_STACKPTR64)
        
        //
        // call CpuResetToConsistentState(PEXCEPTION_POINTERS)
        //
        add     t1 = @gprel(__imp_CpuResetToConsistentState), gp
        ;;
        ld8     t1 = [t1]                   // Become a pointer to the plabel
        ;;
        ld8     t2 = [t1], PlGlobalPointer - PlEntryPoint   // Get entry point
        ;;
        ld8     gp = [t1]                   // Get the GP
        mov     bt0 = t2
        ;;
        br.call.sptk.many brp = bt0


        add     t2 = TeDeallocationStack+8+2*8, teb // Get the TLS address
        ;;

        st8     [t2] = zero    // WOW64_TLS_INCPUSIMULATION = FALSE


        //
        // Now cleanup and return (leaving ourselves on the ia64
        // stack if we weren't already on it)
        //
        mov     gp = loc2
        add     sp = 0x20, sp

        NESTED_RETURN
        NESTED_EXIT(Wow64PrepareForException)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\ia64\thunk.s ===
//++
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Module Name:
//
//    thunk.s
//
// Abstract:
//
//   This module implements all Win32 thunks. This includes the
//   first level thread starter...
//
// Author:
//
//   12-Oct-1995
//
// Revision History:
//   23-NOV-1998 mzoran - Partial copy from base project.
//
//--

#include "ksia64.h"
        .file    "thunk.s"


//++
//
// VOID
// Wow64BaseSwitchStackThenTerminate(
//     IN PVOID StackLimit,
//     IN PVOID NewStack,
//     IN DWORD ExitCode
//     )
//
//
// Routine Description:
//
//     This API is called during thread termination to delete a thread's
//     stack, switch to a stack in the thread's TEB, and then terminate.
//
// Arguments:
//
//     StackLimit (a0) - Supplies the address of the stack to be freed.
//
//     NewStack (a1) - Supplies an address within the terminating threads TEB
//         that is to be used as its temporary stack while exiting.
//         This is also used as the new RseStackBase
//
//     ExitCode (a2) - Supplies the termination status that the thread
//         is to exit with.
//
// Return Value:
//
//     None.
//
//--
        PublicFunction(Wow64BaseFreeStackAndTerminate)

        RseSIZE   = 320         // reserve 320 bytes RseStack, RseStack should
                                //  be larger than memory stack
        // Input arguments
        StackBase = a0
        NewStack  = a1
        ExitCode  = a2

        OldExitCode = t0
        NewStackBase = t1
        OldStackBase = t2
        SavedRSC = t3
        temp = t4
        Junk=t22

        LEAF_ENTRY(Wow64BaseSwitchStackThenTerminate)

        add     NewStackBase = RseSIZE, NewStack
        mov     t0 = 15                      // align base to 16 byte boundry
        ;;
        andcm   NewStackBase = NewStackBase, t0

        mov     SavedRSC = ar.rsc
        mov     OldStackBase = StackBase     // save the arguments to pass down
        mov     OldExitCode = ExitCode
        ;;

        alloc   t22 = ar.pfs, 0, 0, 0, 0     // throw Stacked registers away
        mov     temp = SavedRSC
        ;;
        dep     temp = 0, temp, RSC_MODE, 2
        ;;
        
        mov     ar.rsc = temp
        ;;
        loadrs
        ;;

        mov     ar.bspstore = NewStackBase
        mov     ar.rsc = SavedRSC
        add     sp = -STACK_SCRATCH_AREA, NewStackBase  // setup new stack
        ;;

        alloc   Junk = ar.pfs, 0, 0, 2, 0    // allocate 2 output registers
        mov     brp = zero
        mov     ar.pfs = zero

        mov     out0 = OldStackBase          // re arrange args
        mov     out1 = OldExitCode
        br.many Wow64BaseFreeStackAndTerminate
        ;;

        // branch to Wow64BaseFreeStackAndTerminate(StackLimit, ExitCode)
        // never comes back here

        LEAF_EXIT(Wow64BaseSwitchStackThenTerminate)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64\ia64\misc.c ===
/*++                 

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    misc.c

Abstract:
    
    Random architecture dependent function for wow64.dll

Author:

    13-Aug-1998 mzoran

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <minmax.h>
#include "nt32.h"
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;


#define GET_IMM7B(x)     (x & 0x7fUI64)
#define GET_IMM9D(x)     ((x >> 7) & 0x1ffUI64)
#define GET_IMM5C(x)     ((x >> 16) & 0x1fUI64)
#define GET_IMMIC(x)     ((x >> 21) & 0x1UI64)
#define GET_IMM41(x)     ((x >> 22) & 0x1fffffUI64)
#define GET_IMMI(x)      ((x >> 63) & 0x1UI64)


VOID
Wow64NotifyDebuggerHelper(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:
  
    This is a copy of RtlRaiseException, except it accepts the FirstChance parameter 
    specifing if this is a first chance exception.

    ExceptionRecord - Supplies the 64bit exception record to be raised.
    FirstChance - TRUE is this is a first chance exception.  

Arguments:

    None - Doesn't return through the normal path.

--*/
{

    ULONGLONG ImageBase;
    ULONGLONG TargetGp;
    ULONGLONG ControlPc;
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONGLONG NextPc;

    //
    // Capture the current context, virtually unwind to the caller of this
    // routine, set the fault instruction address to that of the caller, and
    // call the raise exception system service.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, &TargetGp);
    NextPc = RtlVirtualUnwind(ImageBase,
                              ControlPc,
                              FunctionEntry,
                              &ContextRecord,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ContextRecord.StIIP = NextPc + 8;
    ContextRecord.StIPSR &= ~((ULONGLONG) 3 << PSR_RI);
    if (ExceptionRecord->ExceptionAddress == NULL)
    {
        ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.StIIP;
    }
    NtRaiseException(ExceptionRecord, &ContextRecord, FirstChance);

    WOWASSERT(FALSE);
}


VOID
ThunkContext32TO64(
    IN PCONTEXT32 Context32,
    OUT PCONTEXT Context64,
    IN ULONGLONG StackBase
    )
/*++

Routine Description:
  
    Thunk a 32-bit CONTEXT record to 64-bit.  This isn't a general-purpose
    routine... it only does the minimum required to support calls to
    NtCreateThread from 32-bit code.  The resulting 64-bit CONTEXT is
    passed to 64-bit NtCreateThread only.

Arguments:

    Context32   - IN 32-bit CONTEXT
    Context64   - OUT 64-bit CONTEXT
    StackBase   - IN 64-bit stack base for the new thread

Return:

    None.  Context64 is initialized.

--*/
{
    RtlZeroMemory((PVOID)Context64, sizeof(CONTEXT));

    //
    // Setup the stuff that doesn't usually change
    // Need to worry about psr/fpsr or other ia64 control or will
    // default values be used when the kernel SANITIZEs these values?
    // When the kernel thread init code is working again, these 3 constants
    // won't need to be set here.
    //
    Context64->SegCSD = USER_CODE_DESCRIPTOR;
    Context64->SegSSD = USER_DATA_DESCRIPTOR;
    Context64->Cflag = (ULONGLONG)((CR4_VME << 32) | CR0_PE | CFLG_II);

    Context64->StIPSR = USER_PSR_INITIAL;
    Context64->RsPFS = 0;
    Context64->RsBSP = Context64->RsBSPSTORE = Context64->IntSp = StackBase;
    Context64->IntSp -= STACK_SCRATCH_AREA; // scratch area as per convention
    Context64->IntS1 = (ULONG_PTR)Context32->Eax;     // InitialPc
    Context64->IntS2 = (ULONG_PTR)Context32->Ebx;     // Parameter
    Context64->RsRSC = (RSC_MODE_EA<<RSC_MODE)
                   | (RSC_BE_LITTLE<<RSC_BE)
                   | (0x3<<RSC_PL);

    Context64->IntS0 = Context64->StIIP = (ULONG_PTR)Context32->Eip;
    Context64->IntS3 = Context32->Esp;
    // Set the initial GP to non-zero.  If it is zero, ntos\ps\ia64\psctxi64.c
    // will treat initial IIP as a PLABEL_DESCRIPTOR pointer and dereference it.
    // That's bad if we are using IIP to point to an IA32 address.
    Context64->IntGp = ~0i64;
    Context64->ContextFlags = CONTEXT_CONTROL| CONTEXT_INTEGER;
    Context64->ApUNAT = 0xFFFFFFFFFFFFEDF1ULL;
    Context64->Eflag = 0x00003002ULL;
}



NTSTATUS
Wow64pSkipContextBreakPoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT Context)
/*++

Routine Description:

    Advances Context->StIIP to the instruction following the hard coded bp.

Arguments:

    ExceptionRecord  - Exception record at the time of hitting the bp
    Context          - Context to change

Return:

    NTSTATUS
--*/
{
    PPSR IntPSR;
    ULONGLONG IntIP;

    IntIP  = (ULONGLONG)ExceptionRecord->ExceptionAddress;
    IntPSR = (PPSR)&Context->StIPSR;
    
    if ((IntIP & 0x000000000000000fUI64) != 0x0000000000000008UI64)
    {
        IntPSR->sb.psr_ri = (IntPSR->sb.psr_ri + 1);
    }
    else
    {
        IntPSR->sb.psr_ri = 0x00;
        Context->StIIP = (Context->StIIP + 0x10);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64log\logutil.c ===
/*++                 

Copyright (c) 1999 Microsoft Corporation

Module Name:

    logutil.c

Abstract:
    
    Helper routines for logging data.

Author:

    03-Oct-1999    SamerA

Revision History:

--*/

#include "w64logp.h"




WOW64LOGAPI
NTSTATUS
Wow64LogMessageArgList(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN va_list ArgList)
/*++

Routine Description:

    Logs a message.
    
Arguments:

    Flags  - Determine the output log type
    Format - Formatting string
    ...    - Variable argument

Return Value:

    NTSTATUS
--*/
{
    int BytesWritten;
    CHAR Buffer[ MAX_LOG_BUFFER ];

    //
    // Check trace gate flag
    //
    if (!((Wow64LogFlags & ~(UINT_PTR)LF_CONSOLE) & Flags)) 
    {
        return STATUS_SUCCESS;
    }

    BytesWritten = _vsnprintf(Buffer, 
                              sizeof(Buffer) - 1, 
                              Format, 
                              ArgList);

    if (BytesWritten < 0) 
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Log the results
    //
    LogOut(Buffer, Wow64LogFlags);

    return STATUS_SUCCESS;
}



WOW64LOGAPI
NTSTATUS
Wow64LogMessage(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN ...)
/*++

Routine Description:

    Helper around logs a message that accepts a variable argument list
    
Arguments:

    Flags  - Determine the output log type
    Format - Formatting string
    ...    - Variable argument

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS NtStatus;
    va_list ArgList;
    
    va_start(ArgList, Format);
    NtStatus = Wow64LogMessageArgList(Flags, Format, ArgList);
    va_end(ArgList);

    return NtStatus;
}




NTSTATUS
LogFormat(
    IN OUT PLOGINFO LogInfo,
    IN PSZ Format,
    ...)
/*++

Routine Description:

    Formats a message

Arguments:

    LogInfo    - Logging Information (buffer + available bytes)
    pszFormat  - Format string
    ...        - Optional arguments
    

Return Value:

    NTSTATUS - BufferSize is increment with the amount of bytes
    written if successful.
--*/
{
    va_list ArgList;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    int BytesWritten;

    va_start(ArgList, Format);

    BytesWritten = _vsnprintf(LogInfo->OutputBuffer, LogInfo->BufferSize, Format, ArgList);

    va_end(ArgList);

    if (BytesWritten < 0)
    {
        NtStatus = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        LogInfo->BufferSize -= BytesWritten;
        LogInfo->OutputBuffer += BytesWritten;
    }
    return NtStatus;
}


VOID
LogOut(
    IN PSZ Text,
    UINT_PTR Flags
    )
/*++

Routine Description:

    Logs -outputs- a message
       

Arguments:

    Text  - Formatted string to log
    
    Flags - Control flags

Return Value:

    None
--*/
{
    if ((Flags & LF_CONSOLE) != 0)
    {
        DbgPrint(Text);
    }

    //
    // Check if we need to send the output to a file
    //
    if (Wow64LogFileHandle != INVALID_HANDLE_VALUE)
    {
        LogWriteFile(Wow64LogFileHandle, Text);
    }
}




NTSTATUS
LogWriteFile(
   IN HANDLE FileHandle,
   IN PSZ LogText)
/*++

Routine Description:

   Writes text to a file handle

Arguments:

    FileHandle - Handle to a file object
    LogText    - Text to log to file

Return Value:

    NTSTATUS

--*/
{
   IO_STATUS_BLOCK IoStatus;
   NTSTATUS NtStatus;

   NtStatus = NtWriteFile(FileHandle,
                          NULL,       // event
                          NULL,       // apcroutine
                          NULL,       // apccontext
                          &IoStatus,
                          LogText,
                          strlen(LogText),
                          NULL,       // ByteOffset
                          NULL);      // key

   return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64log\w64logp.h ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    w64logp.h

Abstract:
    
    Private header for wow64log.dll
    
Author:

    03-OCt-1999   SamerA

Revision History:

--*/

#ifndef _W64LOGP_INCLUDE
#define _W64LOGP_INCLUDE

#define _WOW64LOGAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <stdio.h>
#include <stdarg.h>
#include "nt32.h"
#include "wow64.h"
#include "wow64log.h"

//
// bring in INVALID_HANDLE_VALUE
//
#include "winbase.h"  


//
// Max buffer size for output logging
//
#define MAX_LOG_BUFFER  1024

//
// Default logging flags if no reg value is found
//
#define LF_DEFAULT      (LF_ERROR)


//
// Prototype for data type handler log function
//
typedef NTSTATUS (*PFNLOGDATATYPEHANDLER)(PLOGINFO, 
                                          ULONG_PTR, 
                                          PSZ,
                                          BOOLEAN);

typedef struct _LOGDATATYPE
{
    PFNLOGDATATYPEHANDLER Handler;
} LOGDATATYPE, *PLOGDATATYPE;

//
// The layout of each entry in thunk debug info should be as follow :
//
// "ServiceName1", ServiceNumber, NumerOfArgument,
// "ArgName1", ArgType1, ...., ArgNameN, ArgTypeN
// "ServiceName2", ...and so on
//

typedef struct _ArgTypes
{
    char *Name;
    ULONG_PTR Type;
} ArgType, *PArgType;

//
// helper structures to help parsing the thunk debugging info
//
typedef struct _ThunkDebugInfo
{
    char *ApiName;
    UINT_PTR ServiceNumber;
    UINT_PTR NumberOfArg;
    ArgType Arg[0];
} THUNK_DEBUG_INFO, *PTHUNK_DEBUG_INFO;

typedef struct _LOGINFO
{
    PSZ OutputBuffer;
    ULONG_PTR BufferSize;
} LOGINFO, *PLOGINFO;


// from whnt32.c
extern PULONG_PTR NtThunkDebugInfo[];

// from whwin32.c
extern PULONG_PTR Win32ThunkDebugInfo[];

// from whcon.c
extern PULONG_PTR ConsoleThunkDebugInfo[];

// from whbase.c
extern PULONG_PTR BaseThunkDebugInfo[];

// from wow64log.c
extern UINT_PTR Wow64LogFlags;
extern HANDLE Wow64LogFileHandle;


NTSTATUS
LogInitializeFlags(
    IN OUT PUINT_PTR Flags);

ULONG
GetThunkDebugTableSize(
    IN PTHUNK_DEBUG_INFO DebugInfoTable);

NTSTATUS
BuildDebugThunkInfo(
    IN PTHUNK_DEBUG_INFO DebugInfoTable,
    OUT PULONG_PTR *LogTable);

NTSTATUS
LogTypeValue(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypeUnicodeString(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePULongInOut(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePULongOut(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypeObjectAttrbiutes(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypeIoStatusBlock(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePWStr(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePRectIn(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePLargeIntegerIn(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);



// from logutil.c
NTSTATUS
LogFormat(
    IN OUT PLOGINFO LogInfo,
    IN PSZ Format,
    ...);

VOID
LogOut(
    IN PSZ Text,
    UINT_PTR Flags
    );

NTSTATUS
LogWriteFile(
   IN HANDLE FileHandle,
   IN PSZ LogText);

NTSTATUS
Wow64LogMessageInternal(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN ...);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64log\wow64log.c ===
/*++                 

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wow64log.c

Abstract:
    
    Main entrypoints for wow64log.dll. To add a data type handler :
    1- Define a LOGDATATYPE for the data to log in w64logp.h
    2- Implement the data type handler using the standard interface
       NTSTATUS
       LogDataType(IN OUT PLOGINFO LogInfo,
                   IN ULONG_PTR Data,
                   IN PSZ FieldName,
                   IN BOOLEAN ServiceReturn);
    3- Insert the handler into LogDataType[] below.               
                   

Author:

    03-Oct-1999   SamerA

Revision History:

--*/

#include "w64logp.h"


/// Public

//
// Control logging flags 
//
UINT_PTR Wow64LogFlags;
HANDLE Wow64LogFileHandle;



/// Private

//
// Hold an array of pointers to each system service DebugThunkInfo
//
PULONG_PTR *LogNtBase;
PULONG_PTR *LogWin32;
PULONG_PTR *LogConsole;
PULONG_PTR *LogBase;


//
// NOTE : The order entries in this table should match the LOGTYPE enum in
// w64logp.h.
//
LOGDATATYPE LogDataType[] =
{
    {LogTypeValue},            // TypeHex
    {LogTypePULongInOut},      // TypePULongPtrInOut
    {LogTypePULongOut},        // TypePULONGOut
    {LogTypePULongOut},        // TypePHandleOut
    {LogTypeUnicodeString},    // TypeUnicodeStringIn
    {LogTypeObjectAttrbiutes}, // TypeObjectAttributesIn
    {LogTypeIoStatusBlock},    // TypeIoStatusBlockOut
    {LogTypePWStr},            // TypePwstrIn
    {LogTypePRectIn},          // TypePRectIn
    {LogTypePLargeIntegerIn},  // TypePLargeIntegerIn
};






WOW64LOGAPI
NTSTATUS
Wow64LogInitialize(
    VOID)
/*++

Routine Description:

    This function is called by wow64.dll to initialize wow64 logging
    subsystem.

Arguments:

    None

Return Value:

    NTSTATUS
--*/
{
    ULONG NtBaseTableSize, Win32TableSize, ConsoleTableSize, BaseTableSize;
    PULONG_PTR *Win32ThunkDebugInfo;
    PULONG_PTR *ConsoleThunkDebugInfo;
    UNICODE_STRING Log2Name;
    PVOID Log2Handle;
    NTSTATUS st;

    //
    // Initialize the logging file handle
    //
    Wow64LogFileHandle = INVALID_HANDLE_VALUE;

    //
    // Initialize the logging flags
    //
    LogInitializeFlags(&Wow64LogFlags);
    WOW64LOGOUTPUT((LF_TRACE, "Wow64LogInitialize - Wow64LogFlags = %I64x\n", Wow64LogFlags));

    //
    // Load the Win32 logging DLL if available.
    //
    RtlInitUnicodeString(&Log2Name, L"wow64lg2.dll");
    st = LdrLoadDll(NULL, NULL, &Log2Name, &Log2Handle);
    if (NT_SUCCESS(st)) {
        ANSI_STRING ExportName;

        RtlInitAnsiString(&ExportName, "Win32ThunkDebugInfo");
        st = LdrGetProcedureAddress(Log2Handle, &ExportName, 0, &(PVOID)Win32ThunkDebugInfo);
        if (NT_SUCCESS(st)) {
            RtlInitAnsiString(&ExportName, "ConsoleThunkDebugInfo");
            st = LdrGetProcedureAddress(Log2Handle, &ExportName, 0, &(PVOID)ConsoleThunkDebugInfo);
        }
    }
    if (!NT_SUCCESS(st)) {
        Log2Handle = NULL;
        Win32ThunkDebugInfo = NULL;
        ConsoleThunkDebugInfo = NULL;
    }

    //
    // Build pointers to the debug thunk info for each
    // system service
    //
    
    NtBaseTableSize = GetThunkDebugTableSize(
                          (PTHUNK_DEBUG_INFO)NtThunkDebugInfo);
    BaseTableSize = GetThunkDebugTableSize(
                          (PTHUNK_DEBUG_INFO)BaseThunkDebugInfo);
    if (Log2Handle) {
        Win32TableSize = GetThunkDebugTableSize(
                              (PTHUNK_DEBUG_INFO)Win32ThunkDebugInfo);
        ConsoleTableSize = GetThunkDebugTableSize(
                              (PTHUNK_DEBUG_INFO)ConsoleThunkDebugInfo);
    } else {
        Win32TableSize = 0;
        ConsoleTableSize = 0;
    }
    
    LogNtBase = (PULONG_PTR *)Wow64AllocateHeap((NtBaseTableSize + Win32TableSize + ConsoleTableSize + BaseTableSize) *
                                                sizeof(PULONG_PTR) );

    if (!LogNtBase) 
    {
        WOW64LOGOUTPUT((LF_ERROR, "Wow64LogInitialize - Wow64AllocateHeap failed\n"));
        return STATUS_UNSUCCESSFUL;
    }
    
    LogWin32 = LogNtBase + NtBaseTableSize;
    LogConsole = LogWin32 + Win32TableSize;
    LogBase = LogConsole + ConsoleTableSize;

    BuildDebugThunkInfo((PTHUNK_DEBUG_INFO)NtThunkDebugInfo, LogNtBase);
    BuildDebugThunkInfo((PTHUNK_DEBUG_INFO)BaseThunkDebugInfo, LogBase);
    if (Log2Handle) {
        BuildDebugThunkInfo((PTHUNK_DEBUG_INFO)Win32ThunkDebugInfo, LogWin32);
        BuildDebugThunkInfo((PTHUNK_DEBUG_INFO)ConsoleThunkDebugInfo, LogConsole);
    }

    return STATUS_SUCCESS;
}



WOW64LOGAPI
NTSTATUS
Wow64LogTerminate(
    VOID)
/*++

Routine Description:

    This function is called by wow64.dll when the process is exiting.

Arguments:

    None

Return Value:

    NTSTATUS
--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    
    if (Wow64LogFileHandle != INVALID_HANDLE_VALUE) 
    {
        NtFlushBuffersFile(Wow64LogFileHandle, &IoStatusBlock);
        NtClose(Wow64LogFileHandle);
    }

    return STATUS_SUCCESS;
}



NTSTATUS
LogInitializeFlags(
    IN OUT PUINT_PTR Flags)
/*++

Routine Description:

    Reads the logging flags from the registry

Arguments:

    Flags - Pointer to receive logging flags

Return Value:

    NTSTATUS
--*/
{
    HANDLE Key;
    UNICODE_STRING KeyName, ValueName, ResultValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength, RegFlags;
    NTSTATUS NtStatus;


    //
    // Punch in the default
    //
    *Flags = LF_DEFAULT;

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    RtlInitUnicodeString(&KeyName,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager");

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(NtStatus)) 
    {
        RtlInitUnicodeString(&ValueName, L"WOW64LOGFLAGS");
        NtStatus = NtQueryValueKey(Key,
                                   &ValueName,
                                   KeyValuePartialInformation,
                                   KeyValueInformation,
                                   sizeof(KeyValueBuffer),
                                   &ResultLength);

        if (NT_SUCCESS(NtStatus)) 
        {
            if ((KeyValueInformation->Type == REG_DWORD) && 
                (KeyValueInformation->DataLength == sizeof(DWORD)))
            {
                *Flags = *((PULONG)KeyValueInformation->Data);
            }
        }
    }

    return NtStatus;
}


ULONG
GetThunkDebugTableSize(
    IN PTHUNK_DEBUG_INFO DebugInfoTable)
/*++

Routine Description:

    This routine retreives the number of DebugThunkInfo entries
    in the passed table.

Arguments:

    DebugInfoTable - Pointer to services debug info

Return Value:

    Number of entries
--*/
{
    ULONG Count = 0;

    while (DebugInfoTable && DebugInfoTable->ApiName) 
    {
        Count++;
        DebugInfoTable = (PTHUNK_DEBUG_INFO)
                         &DebugInfoTable->Arg[DebugInfoTable->NumberOfArg];
    }

    return Count;
}



NTSTATUS
BuildDebugThunkInfo(
    IN PTHUNK_DEBUG_INFO DebugInfoTable,
    OUT PULONG_PTR *LogTable)
/*++

Routine Description:

    This routine fills a service-table-indexed with pointers
    to the corresponding DebugThunkInfo

Arguments:

    DebugInfoTable - Services debug info
    LogTable       - Table of pointers to fill
    

Return Value:

    NTSTATUS
--*/
{
    ULONG i=0;

    while (DebugInfoTable && DebugInfoTable->ApiName) 
    {
        LogTable[i++] = (PULONG_PTR) DebugInfoTable;

        DebugInfoTable = (PTHUNK_DEBUG_INFO)
                         &DebugInfoTable->Arg[DebugInfoTable->NumberOfArg];
    }

    return STATUS_SUCCESS;
}




NTSTATUS
LogApiHeader(
    PTHUNK_DEBUG_INFO ThunkDebugInfo, 
    PLOGINFO LogInfo,
    BOOLEAN ServiceReturn,
    ULONG_PTR ReturnResult,
    ULONG_PTR ReturnAddress)
/*++

Routine Description:

    Log the Thunked API header

Arguments:

    ThunkDebugInfo - Pointer to service log info
    LogInfo        - Logging Info
    ServiceReturn  - TRUE if called after the thunk API has executed
    ReturnResult   - Result code returned from the API
    ReturnAddress  - Return address of for this thunked call

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        return LogFormat(LogInfo,
                         "wh%s: Ret=%lx-%lx: ",
                         ThunkDebugInfo->ApiName,
                         ReturnResult,
                         ReturnAddress);
    }

    return LogFormat(LogInfo,
                     "%8.8X-wh%s: ",
                     PtrToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                     ThunkDebugInfo->ApiName);
}



NTSTATUS
LogApiParameters(
    IN OUT PLOGINFO LogInfo, 
    IN PULONG Stack32, 
    IN PTHUNK_DEBUG_INFO ThunkDebugInfo, 
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log the Thunked API Parameters

Arguments:

    LogInfo        - Output log buffer
    Stack32        - Pointer to 32-bit arg stack
    ThunkDebugInfo - Pointer to service log info for the API
    ServiceReturn  - TRUE if called after the Thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    UINT_PTR i=0;

    //
    // Loops thru the parameters
    //
    while (i < ThunkDebugInfo->NumberOfArg) 
    {
        _try 
        {
            LogDataType[ThunkDebugInfo->Arg[i].Type].Handler(
                LogInfo,
                Stack32[i],
                ThunkDebugInfo->Arg[i].Name,
                ServiceReturn);
        }
        _except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Log the bad parameters
            //
            LogFormat(LogInfo,
                      "%s=%lx-%ws ",
                      ThunkDebugInfo->Arg[i].Name,
                      Stack32[i],
                      L"(BAD)");
        }
        i++;
    }

    return STATUS_SUCCESS;
}




NTSTATUS
LogThunkApi(
    IN PTHUNK_LOG_CONTEXT ThunkLogContext,
    IN PTHUNK_DEBUG_INFO ThunkDebugInfo,
    IN UINT_PTR LogFullInfo)
/*++

Routine Description:

    Log the Thunked API

Arguments:

    ThunkLogContext - Thunk API log context
    ThunkDebugInfo  - Pointer to service log info for the API
    LogFullInfo     - Flag whther to log all the API info or just the name

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS NtStatus;
    CHAR szBuf[ MAX_LOG_BUFFER ];
    LOGINFO LogInfo;
    PULONG Stack32 = ThunkLogContext->Stack32;
    BOOLEAN ServiceReturn = ThunkLogContext->ServiceReturn;

    
    //
    // Initialize the log buffer
    //
    LogInfo.OutputBuffer = szBuf;
    LogInfo.BufferSize = MAX_LOG_BUFFER - 1;
    
    //
    // Log API header
    //
    NtStatus = LogApiHeader(ThunkDebugInfo, 
                            &LogInfo, 
                            ServiceReturn, 
                            ThunkLogContext->ReturnResult,
                            *(Stack32-1));

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    // Log Parameters
    if (LogFullInfo) 
    {
        NtStatus = LogApiParameters(&LogInfo,
                                    Stack32, 
                                    ThunkDebugInfo, 
                                    ServiceReturn);
        if (!NT_SUCCESS(NtStatus)) 
        {
            return NtStatus;
        }
    }

    //
    // Do actual output
    //
    LogInfo.OutputBuffer[0] = '\0';
    LogOut(szBuf, Wow64LogFlags);
    LogOut("\r\n", Wow64LogFlags);

    return NtStatus;
}




WOW64LOGAPI
NTSTATUS
Wow64LogSystemService(
    IN PTHUNK_LOG_CONTEXT ThunkLogContext)
/*++

Routine Description:

    Logs information for the specified system service.

Arguments:

    LogContext - Thunk API log context

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS NtStatus;
    PTHUNK_DEBUG_INFO ThunkDebugInfo;
    ULONG_PTR TableNumber = ThunkLogContext->TableNumber;
    ULONG_PTR ServiceNumber = ThunkLogContext->ServiceNumber;
    UINT_PTR LogFullInfo;

    //
    // Use try except !!
    //

    _try
    {
        switch(TableNumber)
        {
        case WHNT32_INDEX:
            if (!LF_NTBASE_ENABLED(Wow64LogFlags)) 
            {
                return STATUS_SUCCESS;
            }
            LogFullInfo = (Wow64LogFlags & LF_NTBASE_FULL);
            ThunkDebugInfo = (PTHUNK_DEBUG_INFO)LogNtBase[ServiceNumber];
            break;

        case WHCON_INDEX:
            if (!LF_NTCON_ENABLED(Wow64LogFlags) || LogConsole == NULL)
            {
                return STATUS_SUCCESS;
            }
            LogFullInfo = (Wow64LogFlags & LF_NTCON_FULL);
            ThunkDebugInfo = (PTHUNK_DEBUG_INFO)LogConsole[ServiceNumber];
            break;

        case WHWIN32_INDEX:
            if (!LF_WIN32_ENABLED(Wow64LogFlags) || LogWin32 == NULL)
            {
                return STATUS_SUCCESS;
            }
            LogFullInfo = (Wow64LogFlags & LF_WIN32_FULL);
            ThunkDebugInfo = (PTHUNK_DEBUG_INFO)LogWin32[ServiceNumber];
            break;

        case WHBASE_INDEX:
            if (!LF_BASE_ENABLED(Wow64LogFlags))
            {
                return STATUS_SUCCESS;
            }
            LogFullInfo = (Wow64LogFlags & LF_BASE_FULL);
            ThunkDebugInfo = (PTHUNK_DEBUG_INFO)LogBase[ServiceNumber];
            break;

        default: // invalid service table
            WOW64LOGOUTPUT((LF_ERROR, "Wow64LogSystemService: Not supported table number - %lx\n", TableNumber));
            return STATUS_UNSUCCESSFUL;
            break;
        }

        NtStatus = LogThunkApi(ThunkLogContext,
                               ThunkDebugInfo,
                               LogFullInfo);
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
        WOW64LOGOUTPUT((LF_EXCEPTION, "Wow64LogSystemService : Invalid Service ServiceTable = %lx, ServiceNumber = %lx. Status=%lx\n", 
                        TableNumber, ServiceNumber, GetExceptionCode()));
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}




//////////////////////////////////////////////////////////////////////////
//
//                   DATA TYPE LOGGING ROUTINES
//
///////////////////////////////////////////////////////////////////////////

NTSTATUS
LogTypeValue(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as ULONG

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn)
    {
        return STATUS_SUCCESS;
    }

    return LogFormat(LogInfo,
                     "%s=%lx ",
                     FieldName,
                     (ULONG)Data);
}



NTSTATUS
LogTypeUnicodeString(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as UNICODE_STRING32

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    UNICODE_STRING32 *Name32;
    PWCHAR Buffer = L" ";

    if (ServiceReturn)
    {
        return STATUS_SUCCESS;
    }

    Name32 = (UNICODE_STRING32 *)Data;
    if (Data > 0xffff)
    {
        if (Name32->Buffer)
        {
            Buffer = (PWCHAR)Name32->Buffer;
        }
        if (Name32->Length && Name32->Buffer > 0xffff) {
            return LogFormat(LogInfo,
                             "%s=%ws ",
                             FieldName,
                             Buffer);
        } else {
            return LogFormat(LogInfo,
                             "%s={L=%x,M=%x,B=%x}",
                             FieldName,
                             Name32->Length,
                             Name32->MaximumLength,
                             Name32->Buffer);
        }
    }

    return LogFormat(LogInfo,
                     "%s=%x",
                     FieldName,
                     Name32);
}


NTSTATUS
LogTypePULongInOut(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PULONG

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    return LogFormat(LogInfo,
                     "[%s-%lx]=%lx ",
                     FieldName,
                     (ULONG)Data,
                     ((PULONG)Data ? *((PULONG)Data) : 0));
}



NTSTATUS
LogTypePULongOut(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PULONG (Out field)

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        return LogFormat(LogInfo,
                         "[%s-%lx]=%lx ",
                         FieldName,
                         (PULONG)Data,
                         ((PULONG)Data ? *(PULONG)Data : 0));
    }

    return LogFormat(LogInfo,
                     "%s=%lx ",
                     FieldName,
                     (PULONG)Data);
}


NTSTATUS
LogTypeObjectAttrbiutes(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as POBJECT_ATTRIBUTES

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    NT32OBJECT_ATTRIBUTES *ObjA32;
    UNICODE_STRING32 *ObjectName = NULL;
    PWCHAR Buffer = L"";

    if (ServiceReturn) 
    {
        return STATUS_SUCCESS;
    }

    ObjA32 = (NT32OBJECT_ATTRIBUTES *)Data;
    if (ObjA32) 
    {
        ObjectName = (UNICODE_STRING32 *)ObjA32->ObjectName;
        if (ObjectName) 
        {
            if (ObjectName->Buffer) 
            {
                Buffer = (PWCHAR)ObjectName->Buffer;
            }
        }
    }


    return LogFormat(LogInfo,
                     "%s=%lx {N=%ws,A=%lx} ",
                     FieldName,
                     (PULONG)Data,
                     Buffer,
                     (ObjA32 ? ObjA32->Attributes : 0));
}


NTSTATUS
LogTypeIoStatusBlock(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as IO_STATUS_BLOCK

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        PIO_STATUS_BLOCK32 StatusBlock32 = (PIO_STATUS_BLOCK32)Data;
        
        return LogFormat(LogInfo,
                         "%s={S=%lx,I=%lx} ",
                         FieldName,
                         (PULONG)Data,
                         (StatusBlock32 ? StatusBlock32->Status : 0),
                         (StatusBlock32 ? StatusBlock32->Information : 0));
    }

    return LogFormat(LogInfo,
                     "%s=%lx ",
                     FieldName,
                     (PULONG)Data);
}

NTSTATUS
LogTypePWStr(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PWSTR

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    ULONG_PTR i;
    WCHAR Buffer[ 14 ];
    PWSTR String = (PWSTR) Data;

    if (ServiceReturn) 
    {
        return STATUS_SUCCESS;
    }

    //
    // Sometime this type is treated as a pointer
    // to WCHARs without NULL terminating it, like 
    // how it's used in NtGdiExtTextOutW, so let's dump
    // a minimal string
    //
    if (Data) 
    {        
        i = 0;        
        while((i < ((sizeof(Buffer) / sizeof(WCHAR)) - 4)) && (String[i]))
        {
            Buffer[i] = String[i];
            i++;
        }

        if (i == ((sizeof(Buffer) / sizeof(WCHAR)) - 4))
        {
            Buffer[i++] = L'.';
            Buffer[i++] = L'.';
            Buffer[i++] = L'.';
        }
        Buffer[i++] = UNICODE_NULL;
    }


    return LogFormat(LogInfo,
                     "%s=%ws ",
                     FieldName,
                     (Data > 0xffff) ? Buffer : L"");
}



NTSTATUS
LogTypePRectIn(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PWSTR

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        return STATUS_SUCCESS;
    }

    if (Data) 
    {
        PRECT Rect = (PRECT)Data;
        return LogFormat(LogInfo,
                         "%s={%lx,%lx,%lx,%lx} ",
                         FieldName,
                         Rect->left, Rect->top, Rect->right, Rect->bottom);

    }
    
    return LogTypeValue(LogInfo,
                        Data,
                        FieldName,
                        ServiceReturn);
}



NTSTATUS
LogTypePLargeIntegerIn(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PLARGE_INTEGER

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        return STATUS_SUCCESS;
    }

    if (Data) 
    {
        NT32ULARGE_INTEGER *ULargeInt = (NT32ULARGE_INTEGER *)Data;
        return LogFormat(LogInfo,
                         "%s={H=%lx,L=%lx} ",
                         FieldName,
                         ULargeInt->HighPart, ULargeInt->LowPart);

    }
    
    return LogTypeValue(LogInfo,
                        Data,
                        FieldName,
                        ServiceReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64svc\server\server.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This module contains the code to provide the RPC server.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "wow64svc.h"
#pragma hdrstop


GUID Wow64SvcGuid = { 0xc3a9d640, 0xffff, 0x11d0, { 0x92, 0xbf, 0x0, 0xa0, 0x24, 0xaa, 0x1c, 0x1 } };

CRITICAL_SECTION CsPerfCounters;
DWORD OutboundSeconds;
DWORD InboundSeconds;
DWORD TotalSeconds;

CHAR Buffer[4096];

HANDLE hServiceEndEvent; // signalled by tapiworkerthread after letting clients know fax service is ending
#ifdef DBG
HANDLE hLogFile = INVALID_HANDLE_VALUE;
LIST_ENTRY CritSecListHead;
#endif





DWORD
ServiceStart(
    VOID
    )

/*++

Routine Description:

    Starts the RPC server.  This implementation listens on
    a list of protocols.  Hopefully this list is inclusive
    enough to handle RPC requests from most clients.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    if (StartReflector ())
        return 0;
    return 1;
}

void EndWow64Svc(
    BOOL bEndProcess,
    DWORD SeverityLevel
    )
/*++

Routine Description:

    End the fax service.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ServiceStop();
}



DWORD
ServiceStop(
    void
    )

/*++

Routine Description:

    Stops the RPC server.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (StopReflector ())
        return 0;
    return 1;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\xip\xipdisk\xipdisk.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    XIPDisk.c

Abstract:

    This is the XIP Disk driver for Whistler NT/Embedded.

Author:

    DavePr 18-Sep-2000 -- base one NT4 DDK ramdisk by RobertN 10-Mar-1993.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/


//
// Include files.
//

#include <ntddk.h>
#include "initguid.h"
#include "mountdev.h"

#include <ntdddisk.h>       // Disk device IOCTLs, DiskClassGuid

#include "fat.h"
#include "xip.h"
#include "XIPDisk.h"


//
// ISSUE-2000/10/11-DavePr -- haven't decided how to define DO_XIP appropriately.
//
#ifndef DO_XIP
#define DO_XIP 0x00020000
#endif

#include <string.h>


NTSTATUS
XIPDiskCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system when the XIPDisk is opened or
    closed.

    No action is performed other than completing the request successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_INVALID_PARAMETER if parameters are invalid,
    STATUS_SUCCESS otherwise.

--*/

{
    PXIPDISK_EXTENSION    diskExtension = NULL;   // ptr to device extension
    PBIOS_PARAMETER_BLOCK bios;
    NTSTATUS              status;

    diskExtension = DeviceObject->DeviceExtension;
    status = XIPDispatch(XIPCMD_NOOP, NULL, 0);

    if (!NT_SUCCESS(status) || !diskExtension->BootParameters.BasePage) {
        status = STATUS_DEVICE_NOT_READY;
    } else {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}


NTSTATUS
XIPDiskReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to read or write to a
    device that we control.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_INVALID_PARAMETER if parameters are invalid,
    STATUS_SUCCESS otherwise.

--*/

{
    PXIPDISK_EXTENSION     diskExtension;
    PIO_STACK_LOCATION     irpSp;
    PUCHAR                 bufferAddress, diskByteAddress;
    PUCHAR                 romPageAddress = NULL;
    ULONG_PTR              ioOffset;
    ULONG                  ioLength;
    NTSTATUS               status;

    PHYSICAL_ADDRESS       physicalAddress;
    ULONG                  mappingSize;

    //
    // Set up necessary object and extension pointers.
    //
    diskExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Check for invalid parameters.  It is an error for the starting offset
    // + length to go past the end of the buffer, or for the offset or length
    // not to be a proper multiple of the sector size.
    //
    // Others are possible, but we don't check them since we trust the
    // file system and they aren't deadly.
    //

    if (irpSp->Parameters.Read.ByteOffset.HighPart) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    ioOffset = irpSp->Parameters.Read.ByteOffset.LowPart;
    ioLength = irpSp->Parameters.Read.Length;

    if (ioLength == 0) {
        status = STATUS_SUCCESS;
        goto done;
    }

    if (ioOffset + ioLength < ioOffset) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    if ((ioOffset | ioLength) & (diskExtension->BiosParameters.BytesPerSector - 1)) {
        status = STATUS_INVALID_PARAMETER;
        goto done;

    }

    if ((ioOffset + ioLength) > (diskExtension->BootParameters.PageCount * PAGE_SIZE)) {
        status = STATUS_NONEXISTENT_SECTOR;
        goto done;
    }

    if (irpSp->MajorFunction == IRP_MJ_WRITE && diskExtension->BootParameters.ReadOnly) {
        status = STATUS_MEDIA_WRITE_PROTECTED;
        goto done;
    }

    //
    // Map the pages in the ROM into system space
    //
    mappingSize = ADDRESS_AND_SIZE_TO_SPAN_PAGES (ioOffset, ioLength) * PAGE_SIZE;

    //
    // Get a system-space pointer to the disk region.
    //
    physicalAddress.QuadPart = (diskExtension->BootParameters.BasePage + (ioOffset/PAGE_SIZE)) * PAGE_SIZE;

    romPageAddress = MmMapIoSpace(physicalAddress, mappingSize, MmCached);
    if (! romPageAddress) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    } 

    diskByteAddress = romPageAddress + (ioOffset & (PAGE_SIZE-1));

    //
    // Get a system-space pointer to the user's buffer.  A system
    // address must be used because we may already have left the
    // original caller's address space.
    //

    Irp->IoStatus.Information = irpSp->Parameters.Read.Length;

    ASSERT (Irp->MdlAddress != NULL);

    bufferAddress = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

    if (! bufferAddress) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    status = STATUS_SUCCESS;

    switch (irpSp->MajorFunction) {
    case IRP_MJ_READ:
        RtlCopyMemory( bufferAddress, diskByteAddress, ioLength );
        break;

    case IRP_MJ_WRITE:
        RtlCopyMemory( diskByteAddress, bufferAddress, ioLength );
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_INVALID_PARAMETER;
    }

done:
    if (romPageAddress) {
        MmUnmapIoSpace (romPageAddress, mappingSize);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}


NTSTATUS
XIPDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

Arguments:

    DeviceObject - a pointer to the object that represents the device
        that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PBIOS_PARAMETER_BLOCK bios;
    PXIPDISK_EXTENSION   diskExtension;
    PIO_STACK_LOCATION   irpSp;
    NTSTATUS             status;
    ULONG                info;

    //
    // Set up necessary object and extension pointers.
    //

    diskExtension = DeviceObject->DeviceExtension;
    bios = &diskExtension->BiosParameters;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Assume failure.
    //
    status = STATUS_INVALID_DEVICE_REQUEST;
    info = 0;

    //
    // Determine which I/O control code was specified.
    //
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    
    case IOCTL_DISK_GET_MEDIA_TYPES:
    case IOCTL_STORAGE_GET_MEDIA_TYPES:
    case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        //
        // Return the drive geometry for the virtual disk.  Note that
        // we return values which were made up to suit the disk size.
        //

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(DISK_GEOMETRY)) {

            status = STATUS_INVALID_PARAMETER;
            
        } else {

            PDISK_GEOMETRY outputBuffer;

            outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;

            outputBuffer->MediaType          = FixedMedia;
            outputBuffer->Cylinders.QuadPart = diskExtension->NumberOfCylinders;
            outputBuffer->TracksPerCylinder  = diskExtension->TracksPerCylinder;
            outputBuffer->SectorsPerTrack    = bios->SectorsPerTrack;
            outputBuffer->BytesPerSector     = bios->BytesPerSector;

            status = STATUS_SUCCESS;
            info = sizeof( DISK_GEOMETRY );
        }
        break;

#if 0
    //
    // Ignore these IOCTLs for now.
    //
    case IOCTL_DISK_SET_PARTITION_INFO: 
    case IOCTL_DISK_SET_DRIVE_LAYOUT: 
        status = STATUS_SUCCESS;
        break;
#endif

    case IOCTL_DISK_GET_PARTITION_INFO: 
        //
        // Return the information about the partition.
        //

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARTITION_INFORMATION)) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            PPARTITION_INFORMATION outputBuffer;
        
            outputBuffer = (PPARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
        
            //
            // Fat hardwired here...
            //
            outputBuffer->PartitionType =  PARTITION_FAT_16;
            outputBuffer->BootIndicator = diskExtension->BootParameters.SystemDrive;
            outputBuffer->RecognizedPartition = TRUE;
            outputBuffer->RewritePartition = FALSE;
            outputBuffer->StartingOffset.QuadPart = 0;
            outputBuffer->PartitionLength.QuadPart = diskExtension->BootParameters.PageCount * PAGE_SIZE;
            outputBuffer->HiddenSectors =  diskExtension->BiosParameters.HiddenSectors;
        
            status = STATUS_SUCCESS;
            info = sizeof(PARTITION_INFORMATION);
        }
        break;


    case IOCTL_DISK_VERIFY:
        {
            PVERIFY_INFORMATION	verifyInformation;
            ULONG               buflen;
            ULONG_PTR           ioOffset;
            ULONG               ioLength;

            buflen = irpSp->Parameters.DeviceIoControl.InputBufferLength;

            if ( buflen < sizeof(VERIFY_INFORMATION) ) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            verifyInformation = Irp->AssociatedIrp.SystemBuffer;

            if (verifyInformation->StartingOffset.HighPart) {
                status = STATUS_DISK_CORRUPT_ERROR;
                break;
            }

            ioOffset = verifyInformation->StartingOffset.LowPart;
            ioLength = verifyInformation->Length;

            if (ioLength == 0) {
                status = STATUS_SUCCESS;

            } else if ((ioOffset | ioLength) & (diskExtension->BiosParameters.BytesPerSector - 1)) {
                status = STATUS_INVALID_PARAMETER;

            } else if ((ioOffset + ioLength) > (diskExtension->BootParameters.PageCount * PAGE_SIZE)) {
                status = STATUS_NONEXISTENT_SECTOR;

            } else {
                status = STATUS_SUCCESS;
            }
            break;
        }

    case IOCTL_DISK_IS_WRITABLE:
        status = diskExtension->BootParameters.ReadOnly? STATUS_MEDIA_WRITE_PROTECTED : STATUS_SUCCESS;
        break;

    case IOCTL_DISK_CHECK_VERIFY:
    case IOCTL_STORAGE_CHECK_VERIFY:
    case IOCTL_STORAGE_CHECK_VERIFY2:
        status = STATUS_SUCCESS;
        break;

    default:
        //
        // The specified I/O control code is unrecognized by this driver.
        // The I/O status field in the IRP has already been set so just
        // terminate the switch.
        //

#if DBG
        DbgPrint("XIPDisk:  ERROR:  unrecognized IOCTL %x\n",
                    irpSp->Parameters.DeviceIoControl.IoControlCode);
#endif
        break;

    case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
        {
            PMOUNTDEV_NAME mountName;
            ULONG outlen;

            outlen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            if ( outlen < sizeof(MOUNTDEV_NAME) ) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            mountName = Irp->AssociatedIrp.SystemBuffer;
            mountName->NameLength = diskExtension->DeviceName.Length;

            if ( outlen < mountName->NameLength + sizeof(WCHAR)) {
                status = STATUS_BUFFER_OVERFLOW;
                info = sizeof(MOUNTDEV_NAME);
                break;
            }

            RtlCopyMemory( mountName->Name, diskExtension->DeviceName.Buffer, mountName->NameLength);

            status = STATUS_SUCCESS;
            info = mountName->NameLength + sizeof(WCHAR);
            break;
        }

    case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
        {
            PMOUNTDEV_UNIQUE_ID uniqueId;
            ULONG outlen;

            outlen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            if (outlen < sizeof(MOUNTDEV_UNIQUE_ID)) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            uniqueId = Irp->AssociatedIrp.SystemBuffer;
            uniqueId->UniqueIdLength = sizeof(XIPDISK_DEVICENAME);

            if (outlen < uniqueId->UniqueIdLength) {
                status = STATUS_BUFFER_OVERFLOW;
                info = sizeof(MOUNTDEV_UNIQUE_ID);
                break;
            }

            RtlCopyMemory( uniqueId->UniqueId, XIPDISK_DEVICENAME, uniqueId->UniqueIdLength );

            status = STATUS_SUCCESS;
            info = uniqueId->UniqueIdLength;
            break;
        }

        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    //
    // Finish the I/O operation by simply completing the packet and returning
    // the same status as in the packet itself.
    // Note that IoCompleteRequest may deallocate Irp before returning.
    //
    Irp->IoStatus.Information = info;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

VOID
XIPDiskUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine is called by the I/O system to unload the driver.

    Any resources previously allocated must be freed.

Arguments:

    DriverObject - a pointer to the object that represents our driver.

Return Value:

    None
--*/

{
    PDEVICE_OBJECT      deviceObject = DriverObject->DeviceObject;
    PXIPDISK_EXTENSION  diskExtension = deviceObject->DeviceExtension;

    RtlFreeUnicodeString(&diskExtension->InterfaceString);
    diskExtension->InterfaceString.Buffer = NULL;

    if (deviceObject != NULL) {
        IoDeleteDevice( deviceObject );
    }
}

NTSTATUS
DriverEntry(
    IN OUT PDRIVER_OBJECT   DriverObject,
    IN     PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:
    This routine is called by the Operating System to initialize the driver.

Arguments:
    DriverObject - a pointer to a device extension object for the XIPDisk driver.

    RegistryPath - a pointer to our Services key in the registry.

Return Value:
    STATUS_SUCCESS if this disk is initialized; an error otherwise.

--*/

{
    XIP_BOOT_PARAMETERS   xipbootparameters;
    PBIOS_PARAMETER_BLOCK bios;
    NTSTATUS              status;

//  UNICODE_STRING        deviceName;
    UNICODE_STRING        realDeviceName;
    UNICODE_STRING        dosSymlink;
    UNICODE_STRING        driveLetter;

    PDEVICE_OBJECT        pdo = NULL;
    PDEVICE_OBJECT        deviceObject;

    PXIPDISK_EXTENSION    ext = NULL;   // ptr to device extension

    //
    // Read the parameters from the registry
    //
    status = XIPDispatch(XIPCMD_GETBOOTPARAMETERS, &xipbootparameters, sizeof(xipbootparameters));
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (xipbootparameters.BasePage == 0) {
        return STATUS_NO_SUCH_DEVICE;
    }

    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = XIPDiskCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = XIPDiskCreateClose;
    DriverObject->MajorFunction[IRP_MJ_READ] = XIPDiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = XIPDiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = XIPDiskDeviceControl;

    //
    // Create and initialize a device object for the disk.
    //
    ObReferenceObject(DriverObject);

    status = IoReportDetectedDevice(
                 DriverObject,
                 InterfaceTypeUndefined,
                 -1,
                 -1,
                 NULL,
                 NULL,
                 TRUE,
                 &pdo
             );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Create the XIP root device.
    //

    RtlInitUnicodeString(&realDeviceName,  XIPDISK_DEVICENAME);

    status = IoCreateDevice( DriverObject,
                               sizeof( XIPDISK_EXTENSION ),
                               &realDeviceName,
                               FILE_DEVICE_VIRTUAL_DISK,
                               0,
                               FALSE,
                               &deviceObject );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    // ISSUE-2000/10/14-DavePr -- Hardwiring the driveLetter because I haven't
    // figured out how to get the mountmgr to give out a drive letter. Naming
    // it as a form of floppy (deviceName) was one suggestion that failed (so far).
    // The dosSymlink isn't really necessary, but is another

    //
    // Create symbolic links.  Ignore failures
    //
//  RtlInitUnicodeString(&deviceName,  XIPDISK_FLOPPYNAME);
    RtlInitUnicodeString(&dosSymlink,  XIPDISK_DOSNAME);
    RtlInitUnicodeString(&driveLetter, XIPDISK_DRIVELETTER);

//  (void) IoCreateSymbolicLink(&deviceName,  &realDeviceName);
    (void) IoCreateSymbolicLink(&dosSymlink,  &realDeviceName);
    (void) IoCreateSymbolicLink(&driveLetter, &realDeviceName);

    //
    // Initialize device object and extension.
    //
    deviceObject->Flags |= DO_DIRECT_IO | DO_XIP;
    deviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

    ext = deviceObject->DeviceExtension;

    bios = &ext->BiosParameters;

    //
    // Initialize the newly allocated disk extension from our temporary
    // Get the bios boot parameters from the kernel
    //
    ext->BootParameters = xipbootparameters;
    status = XIPDispatch(XIPCMD_GETBIOSPARAMETERS, bios, sizeof(*bios));

    //
    // Fill in the device objects
    //
    ext->DeviceObject = deviceObject;
//  ext->DeviceName = deviceName;
    ext->DeviceName = realDeviceName;

    ext->TracksPerCylinder = 1;
    ext->BytesPerCylinder  = bios->BytesPerSector * bios->SectorsPerTrack * ext->TracksPerCylinder;
    ext->NumberOfCylinders = ext->BootParameters.PageCount * PAGE_SIZE / ext->BytesPerCylinder;

  
    //
    // Attach the root device
    //
    ext->TargetObject = IoAttachDeviceToDeviceStack(deviceObject, pdo);

    if (!ext->TargetObject) {
//      IoDeleteSymbolicLink(&deviceName);
        IoDeleteSymbolicLink(&dosSymlink);
        IoDeleteSymbolicLink(&driveLetter);
        IoDeleteSymbolicLink(&realDeviceName);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    ext->UnderlyingPDO = pdo;

    status = IoRegisterDeviceInterface(pdo,
                                       (LPGUID)&DiskClassGuid,
                                       NULL,
                                       &ext->InterfaceString );
    if (NT_SUCCESS(status)) {
        status = IoSetDeviceInterfaceState( &ext->InterfaceString, TRUE );
        if (!NT_SUCCESS(status)) {
            DbgPrint("XIP: Warning: ignored failure %x retruned by IoSetDeviceInterface\n", status);
        }
    } else {
        DbgPrint("XIP: Warning: ignored failure %x retruned by IoRegisterDeviceInterface\n", status);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64svc\server\wow64svc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sources

Abstract:

    main file for the wow64svc 

Author:

    ATM Shafiqul Khalid (askhalid) 3-March-2000

Revision History:

--*/

#ifndef __WOW64_SVC_H__
#define __WOW64_SVC_H__

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>
#include "wow64reg.h"



#define WOW64_SERVICE_NAME            TEXT("Wow64")
#define WOW64_DISPLAY_NAME            TEXT("Wow64 Service ")
#define WOW64_DRIVER_NAME             TEXT("Windows NT Wow64 Driver")
#define WOW64_MONITOR_NAME            TEXT("Windows NT Wow64 Monitor")
#define WOW64_IMAGE_NAME              TEXT("%systemroot%\\system32\\Wow64.exe")
#define WOW64_FILE_PREFIX             TEXT("Wow64")
#define WOW64_EXTENSION_NAME          TEXT("Microsoft Routing Extension")



//
// We need to move messages to log file.
//

#if DBG
#define SvcDebugPrint(x) printf x
#else
#define SvcDebugPrint(x) ;
#endif


VOID
Wow64ServiceMain(
    DWORD argc,
    LPTSTR *argv
    );

DWORD
InstallService(
    LPTSTR  Username,
    LPTSTR  Password
    );

DWORD
RemoveService(
    void
    );

VOID
Wow64ServiceCtrlHandler(
    DWORD Opcode
    );

DWORD
ReportServiceStatus(
    DWORD CurrentState,
    DWORD Win32ExitCode,
    DWORD WaitHint
    );
 
DWORD
ServiceStart(
    VOID
    );

void 
EndWow64Svc(
    BOOL bEndProcess,
    DWORD SeverityLevel
    );

DWORD
ServiceStop(
    void
    );

DWORD
StartWow64Service ();

DWORD
StopWow64Service ();

DWORD
QueryWow64Service ();

//should goto wow64reg.h
BOOL
PopulateReflectorTable ();

//_________________________________________

#endif //__WOW64_SVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wow64\wow64svc\server\wow64svc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sources

Abstract:

    main file for the wow64svc 

Author:

    ATM Shafiqul Khalid (askhalid) 3-March-2000

Revision History:

--*/



#include "Wow64svc.h"

BOOL
SetWow64InitialRegistryLayout ();

SERVICE_STATUS          Wow64ServiceStatus;
SERVICE_STATUS_HANDLE   Wow64ServiceStatusHandle;
BOOL                    ServiceDebug;
HANDLE                  Wow64SvcHeapHandle;

SERVICE_TABLE_ENTRY   ServiceDispatchTable[] = {
    { WOW64_SERVICE_NAME,   Wow64ServiceMain    },
    { NULL,               NULL              }
};

LPTSTR NextParam ( 
    LPTSTR lpStr
    )
/*++

Routine Description

    Point to the next parameter in the commandline.

Arguments:

    lpStr - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/
{
	WCHAR ch = L' ';
		

    if (lpStr == NULL ) 
        return NULL;

    if ( *lpStr == 0 ) 
        return lpStr;

    while (  ( *lpStr != 0 ) && ( lpStr[0] != ch )) {

		if ( ( lpStr [0] == L'\"')  || ( lpStr [0] == L'\'') ) 
			ch = lpStr [0];

        lpStr++;
	}

	if ( ch !=L' ' ) lpStr++;

    while ( ( *lpStr != 0 ) && (lpStr[0] == L' ') )
        lpStr++;

    return lpStr;
}

DWORD CopyParam ( 
    LPTSTR lpDestParam, 
    LPTSTR lpCommandParam
    )
/*++

Routine Description

    Copy the current parameter to lpDestParam.

Arguments:

    lpDestParam - that receive current parameter
    lpCommandParam - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{
	DWORD dwLen = 0;
	WCHAR ch = L' ';

	*lpDestParam = 0;
	
	if ( ( lpCommandParam [0] == L'\"')  || ( lpCommandParam [0] == L'\'') ) {
		ch = lpCommandParam [0];
		lpCommandParam++;
	};


    while ( ( lpCommandParam [0] ) != ch && ( lpCommandParam [0] !=0 ) ) {
        *lpDestParam++ = *lpCommandParam++;
		dwLen++;

		if ( dwLen>255 ) return FALSE;
	}

	if ( ch != L' ' && ch != lpCommandParam [0] )
		return FALSE;
	else lpCommandParam++;

    *lpDestParam = 0;

	return TRUE;

}


int __cdecl 
main()

/*++

Routine Description:

    Main entry point for the TIFF image viewer.


Arguments:

    None.

Return Value:

    Return code, zero for success.

--*/

{
    int     rVal;
    HKEY hKey;
    DWORD Ret;

    LPTSTR  p;
    DWORD   Action = 0;
    LPTSTR  Username;
    LPTSTR  Password;

    PWCHAR lptCmdLine = GetCommandLine ();

    SvcDebugPrint(("\nWow64svc module......%S", lptCmdLine));
 
    lptCmdLine = NextParam ( lptCmdLine );

    while (  ( lptCmdLine != NULL ) && ( lptCmdLine[0] != 0 )  ) {

        if ( lptCmdLine[0] != L'-' && lptCmdLine[0] != L'/')  {
            SvcDebugPrint ( ("\nSorry! incorrect parameter....."));
            SvcDebugPrint ( ("\n Uses: wow64svc -[i/r/d]"));
            return FALSE;
        }

        switch ( lptCmdLine[1] ) {

            case L'i':
            case L'I': 
                
                //
                // Temporary heck ignore installing this service
                // You can delete the registry key as well for the initial sync
                //
                      InitializeWow64OnBoot (2);
                      //
                      // write sync value Key.....
                      //
                      hKey = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
                      if (hKey != NULL)
                      {
                          Ret = RegSetValueEx(
                                hKey,
                                L"WOW64_SYNC",
                                0,
                                REG_SZ,
                                (PBYTE)L"wow64.exe -y",
                                sizeof (L"wow64.exe -y")
                                );
                          RegCloseKey (hKey);
                      }

                      return 0;
                      

            case L'r':
            case L'R':Action = 2;
                      break;

            case L'd':
            case L'D':
                Action = 3;
                break;

            case L's':
            case L'S':
                StartWow64Service ();
                return 0;
                break;

            case L'x':
            case L'X':
                StopWow64Service ();
                return 0;
                break;

            case L'q':
            case L'Q':
                QueryWow64Service ();
                return 0;
                break;

            case L'y':
            case L'Y':
                //
                // Initial Sync registry
                //
                Wow64SyncCLSID ();
                return 0;
            
            default:
                SvcDebugPrint ( ("\nSorry! incorrect parameter.....pass2"));
                SvcDebugPrint ( ("\n Uses: wow64svc -[i/r/d]"));
                return FALSE;
        }

        lptCmdLine = NextParam ( lptCmdLine );
    }

    switch( Action ) {
        case 1:
            rVal = InstallService( NULL, NULL );
            if (rVal == 0) {
                //LogMessage( MSG_INSTALL_SUCCESS );
            } else {
                //LogMessage( MSG_INSTALL_FAIL, GetLastErrorText( rVal ) );
            }
            return rVal;

        case 2:
            rVal = RemoveService();
            if (rVal == 0) {
                //LogMessage( MSG_REMOVE_SUCCESS );
            } else {
                //LogMessage( MSG_REMOVE_FAIL, GetLastErrorText( rVal ) );
            }
            return rVal;

        case 3:
            ServiceDebug = TRUE;
            //ConsoleDebugOutput = TRUE;
            return ServiceStart();
    }


    SvcDebugPrint ( ("\nAttempt to run as a survice ......."));

    if (!InitReflector ())
        SvcDebugPrint ( ("\nSorry! couldn't initialize reflector thread, exiting"));

    if (!StartServiceCtrlDispatcher( ServiceDispatchTable)) {

        rVal = GetLastError();
        SvcDebugPrint(( "StartServiceCtrlDispatcher error =%d", rVal ));
        return rVal;
    }
    
    return 0;
}

DWORD
InstallService(
    LPTSTR  Username,
    LPTSTR  Password
    )

/*++

Routine Description:

    Service installation function.  This function just
    calls the service controller to install the Wow64 service.
    It is required that the Wow64 service run in the context
    of a user so that the service can access MAPI, files on
    disk, the network, etc.

Arguments:

    Username    - User name where the service runs.
    Password    - Password for the user name.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD       rVal = 0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    //
    // do the registration for the reflector thread in the registry.
    //
    PopulateReflectorTable ();

    SvcDebugPrint ( ("\nInstalling service........"));
    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not open service manager: error code = %u", rVal ));
        return rVal;
    }

    hService = CreateService(
            hSvcMgr,
            WOW64_SERVICE_NAME,
            WOW64_DISPLAY_NAME,
            SERVICE_ALL_ACCESS,
            SERVICE_WIN32_OWN_PROCESS,
            SERVICE_AUTO_START, //SERVICE_DEMAND_START, //SERVICE_AUTO_START,
            SERVICE_ERROR_NORMAL,
            WOW64_IMAGE_NAME,
            NULL,
            NULL,
            NULL,
            Username,
            Password
            );
    if (!hService) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not create Wow64 service: error code = %u", rVal ));
        return rVal;
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    SvcDebugPrint ( ("\nInstalled services with ret code: %d", rVal));
    return rVal;
}


DWORD
RemoveService(
    void
    )

/*++

Routine Description:

    Service removal function.  This function just
    calls the service controller to remove the Wow64 service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD       rVal = 0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "could not open service manager: error code = %u", rVal ));
        return rVal;
    }

    hService = OpenService(
        hSvcMgr,
        WOW64_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );
    if (!hService) {
        rVal = GetLastError();
        SvcDebugPrint(( "could not open the Wow64 service: error code = %u", rVal ));
        return rVal;
    }

    if (ControlService( hService, SERVICE_CONTROL_STOP, &Wow64ServiceStatus )) {
        //
        // wait for 1 second
        //
        Sleep( 1000 );

        while( QueryServiceStatus( hService, &Wow64ServiceStatus ) ) {
            if ( Wow64ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ) {
                Sleep( 1000 );
            } else {
                break;
            }
        }

        if (Wow64ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
            rVal = GetLastError();
            SvcDebugPrint(("could not stop the Wow64 service: error code = %u", rVal ));
            return rVal;
        }
    }

    if (!DeleteService( hService )) {
        rVal = GetLastError();
        SvcDebugPrint(( "could not delete the Wow64 service: error code = %u", rVal ));
        return rVal;
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


VOID
Wow64ServiceMain(
    DWORD argc,
    LPTSTR *argv
    )

/*++

Routine Description:

    This is the service main that is called by the
    service controller.

Arguments:

    argc        - argument count
    argv        - argument array

Return Value:

    None.

--*/

{
    DWORD Rval;

    //
    // Setup initial registry link and layout for wow64 after boot.
    //
    SetWow64InitialRegistryLayout ();

    Wow64ServiceStatus.dwServiceType        = SERVICE_WIN32;
    Wow64ServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
    Wow64ServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
    Wow64ServiceStatus.dwWin32ExitCode      = 0;
    Wow64ServiceStatus.dwServiceSpecificExitCode = 0;
    Wow64ServiceStatus.dwCheckPoint         = 0;
    Wow64ServiceStatus.dwWaitHint           = 0;

    Wow64ServiceStatusHandle = RegisterServiceCtrlHandler(
        WOW64_SERVICE_NAME,
        Wow64ServiceCtrlHandler
        );

    if (!Wow64ServiceStatusHandle) {
        SvcDebugPrint(( "RegisterServiceCtrlHandler failed %d", GetLastError() ));
        return;
    }

    
    Rval = ServiceStart();
    if (Rval) {
        //
        // the service failed to start correctly
        //
        ReportServiceStatus( SERVICE_RUNNING, 0, 0);
        return;

    }

    ReportServiceStatus( SERVICE_RUNNING, 0, 0);
    return;
}


VOID
Wow64ServiceCtrlHandler(
    DWORD Opcode
    )

/*++

Routine Description:

    This is the Wow64 service control dispatch function.

Arguments:

    Opcode      - requested control code

Return Value:

    None.

--*/

{
    switch(Opcode) {
        case SERVICE_CONTROL_PAUSE:
            ReportServiceStatus( SERVICE_PAUSED, 0, 0 );
            break;

        case SERVICE_CONTROL_CONTINUE:
            ReportServiceStatus( SERVICE_RUNNING, 0, 0 );
            break;

        case SERVICE_CONTROL_STOP:
            if (ServiceStop () == 0)
                ReportServiceStatus( SERVICE_STOPPED, 0, 0 );
            return;

        case SERVICE_CONTROL_INTERROGATE:
            // fall through to send current status
            break;

        default:
            SvcDebugPrint(( "Unrecognized opcode %ld", Opcode ));
            break;
    }

    ReportServiceStatus( 0, 0, 0 );

    return;
}


DWORD
ReportServiceStatus(
    DWORD CurrentState,
    DWORD Win32ExitCode,
    DWORD WaitHint
    )

/*++

Routine Description:

    This function updates the service control manager's status information for the Wow64 service.

Arguments:

    CurrentState    - Indicates the current state of the service
    Win32ExitCode   - Specifies a Win32 error code that the service uses to
                      report an error that occurs when it is starting or stopping.
    WaitHint        - Specifies an estimate of the amount of time, in milliseconds,
                      that the service expects a pending start, stop, or continue
                      operation to take before the service makes its next call to the
                      SetServiceStatus function with either an incremented dwCheckPoint
                      value or a change in dwCurrentState.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    static DWORD CheckPoint = 1;
    BOOL rVal;

    Wow64ServiceStatus.dwCurrentState = CurrentState;

/*
    if (CurrentState == SERVICE_START_PENDING) {
        Wow64ServiceStatus.dwControlsAccepted = 0;
    } else {
        Wow64ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    }

    if (CurrentState) {
        Wow64ServiceStatus.dwCurrentState = CurrentState;
    }
    Wow64ServiceStatus.dwWin32ExitCode = Win32ExitCode;
    Wow64ServiceStatus.dwWaitHint = WaitHint;

    if ((Wow64ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
        (Wow64ServiceStatus.dwCurrentState == SERVICE_STOPPED ) ) {
        Wow64ServiceStatus.dwCheckPoint = 0;
    } else {
        Wow64ServiceStatus.dwCheckPoint = CheckPoint++;
    }
    */

    //
    // Report the status of the service to the service control manager.
    //
    rVal = SetServiceStatus( Wow64ServiceStatusHandle, &Wow64ServiceStatus );
    if (!rVal) {
        SvcDebugPrint(( "SetServiceStatus() failed: ec=%d", GetLastError() ));
    }

    return rVal;
}

DWORD
StartWow64Service ()
/*++

Routine Description:

    This function Start wow64 service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD rVal=0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    SvcDebugPrint ( ("\ntrying to start  service......"));

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not open service manager: error code = %u", rVal ));
        return rVal;
    }

     hService = OpenService( hSvcMgr, WOW64_SERVICE_NAME, SERVICE_ALL_ACCESS );

     if ( !hService ) {

         rVal = GetLastError();
         SvcDebugPrint(( "\ncould not open service:%s error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }

     if (! StartService( hService, 0, NULL) ) {

         rVal = GetLastError();
         SvcDebugPrint(( "\ncould not start service:%s error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }

     SvcDebugPrint(( "\nservice:%s started successfully error code = %u", WOW64_SERVICE_NAME, rVal ));
     return 0;

}

DWORD
StopWow64Service ()
/*++

Routine Description:

    This function Stop wow64 service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/
{
    DWORD rVal=0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    SvcDebugPrint ( ("\ntrying to start  service......"));
    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not open service manager: error code = %u", rVal ));
        return rVal;
    }

     hService = OpenService( hSvcMgr, WOW64_SERVICE_NAME, SERVICE_ALL_ACCESS );

     if ( !hService ) {

         rVal = GetLastError();
         SvcDebugPrint(( "\ncould not open service:%S error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }

     if (!ControlService( hService, SERVICE_CONTROL_PAUSE, &Wow64ServiceStatus )) {

         rVal = GetLastError();
         SvcDebugPrint(( "\nSorry! couldn't stop the service:%S error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }
  

     SvcDebugPrint(( "\nservice:%S stopped successfully error code = %u", WOW64_SERVICE_NAME, rVal ));
     return 0;

}

DWORD
QueryWow64Service ()
/*++

Routine Description:

    This function log the current status of wow64 service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/
{
    DWORD rVal=0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    SvcDebugPrint ( ("\ntrying to start  service......"));
    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not open service manager: error code = %u", rVal ));
        return rVal;
    }

     hService = OpenService( hSvcMgr, WOW64_SERVICE_NAME, SERVICE_ALL_ACCESS );

     if ( !hService ) {

         rVal = GetLastError();
         SvcDebugPrint(( "\ncould not open service:%S error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }
  
     QueryServiceStatus( hService, &Wow64ServiceStatus );
     {
         SvcDebugPrint ( ("\nStatus: %d, [pending %d] [running %d]",Wow64ServiceStatus.dwCurrentState, SERVICE_STOP_PENDING, SERVICE_RUNNING));
     }

     SvcDebugPrint(( "\nservice:%S started successfully error code = %u", WOW64_SERVICE_NAME, rVal ));
     return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\xip\xipdisk\xipdisk.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    XIPDisk.h

Abstract:

    This file includes extension declaration for
    the XIP Disk driver for Whistler NT/Embedded.

Author:

    DavePr 18-Sep-2000 -- base one NT4 DDK ramdisk by RobertN 10-Mar-1993.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

typedef struct  _XIPDISK_EXTENSION {
    PDEVICE_OBJECT        DeviceObject;
    PDEVICE_OBJECT        UnderlyingPDO;
    PDEVICE_OBJECT        TargetObject;

    XIP_BOOT_PARAMETERS   BootParameters;
    BIOS_PARAMETER_BLOCK  BiosParameters;

    ULONG                 NumberOfCylinders;
    ULONG                 TracksPerCylinder;    // hardwired at 1
    ULONG                 BytesPerCylinder;

    UNICODE_STRING        InterfaceString;
    UNICODE_STRING        DeviceName;
}   XIPDISK_EXTENSION, *PXIPDISK_EXTENSION;

#define XIPDISK_DEVICENAME  L"\\Device\\XIPDisk"
#define XIPDISK_FLOPPYNAME  L"\\Device\\Floppy9"
#define XIPDISK_DOSNAME     L"\\DosDevices\\XIPDisk"
#define XIPDISK_DRIVELETTER L"\\DosDevices\\X:"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\adler32.c ===
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

#define BASE 65521L /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
        k = len < NMAX ? len : NMAX;
        len -= k;
        while (k >= 16) {
            DO16(buf);
	    buf += 16;
            k -= 16;
        }
        if (k != 0) do {
            s1 += *buf++;
	    s2 += s1;
        } while (--k);
        s1 %= BASE;
        s2 %= BASE;
    }
    return (s2 << 16) | s1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\deflate.h ===
/* deflate.h -- internal compression state
 * Copyright (C) 1995-2002 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _DEFLATE_H
#define _DEFLATE_H

#include "zutil.h"

/* ===========================================================================
 * Internal compression state.
 */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define INIT_STATE    42
#define BUSY_STATE   113
#define FINISH_STATE 666
/* Stream status */


/* Data structure describing a single value and its code string. */
typedef struct ct_data_s {
    union {
        ush  freq;       /* frequency count */
        ush  code;       /* bit string */
    } fc;
    union {
        ush  dad;        /* father node in Huffman tree */
        ush  len;        /* length of bit string */
    } dl;
} FAR ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

typedef struct static_tree_desc_s  static_tree_desc;

typedef struct tree_desc_s {
    ct_data *dyn_tree;           /* the dynamic tree */
    int     max_code;            /* largest code with non zero frequency */
    static_tree_desc *stat_desc; /* the corresponding static tree */
} FAR tree_desc;

typedef ush Pos;
typedef Pos FAR Posf;
typedef unsigned IPos;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

typedef struct internal_state {
    z_streamp strm;      /* pointer back to this zlib stream */
    int   status;        /* as the name implies */
    Bytef *pending_buf;  /* output still pending */
    ulg   pending_buf_size; /* size of pending_buf */
    Bytef *pending_out;  /* next pending byte to output to the stream */
    int   pending;       /* nb of bytes in the pending buffer */
    int   noheader;      /* suppress zlib header and adler32 */
    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
    Byte  method;        /* STORED (for zip only) or DEFLATED */
    int   last_flush;    /* value of flush param for previous deflate call */

                /* used by deflate.c: */

    uInt  w_size;        /* LZ77 window size (32K by default) */
    uInt  w_bits;        /* log2(w_size)  (8..16) */
    uInt  w_mask;        /* w_size - 1 */

    Bytef *window;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */

    ulg window_size;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    Posf *prev;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    Posf *head; /* Heads of the hash chains or NIL. */

    uInt  ins_h;          /* hash index of string to be inserted */
    uInt  hash_size;      /* number of elements in hash table */
    uInt  hash_bits;      /* log2(hash_size) */
    uInt  hash_mask;      /* hash_size-1 */

    uInt  hash_shift;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    long block_start;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    uInt match_length;           /* length of best match */
    IPos prev_match;             /* previous match */
    int match_available;         /* set if previous match exists */
    uInt strstart;               /* start of string to insert */
    uInt match_start;            /* start of matching string */
    uInt lookahead;              /* number of valid bytes ahead in window */

    uInt prev_length;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    uInt max_chain_length;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    uInt max_lazy_match;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
#   define max_insert_length  max_lazy_match
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    int level;    /* compression level (1..9) */
    int strategy; /* favor or force Huffman coding*/

    uInt good_match;
    /* Use a faster search when the previous match is longer than this */

    int nice_match; /* Stop searching when current match exceeds this */

                /* used by trees.c: */
    /* Didn't use ct_data typedef below to supress compiler warning */
    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    struct tree_desc_s l_desc;               /* desc. for literal tree */
    struct tree_desc_s d_desc;               /* desc. for distance tree */
    struct tree_desc_s bl_desc;              /* desc. for bit length tree */

    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    int heap_len;               /* number of elements in the heap */
    int heap_max;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    uch depth[2*L_CODES+1];
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    uchf *l_buf;          /* buffer for literals or lengths */

    uInt  lit_bufsize;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    uInt last_lit;      /* running index in l_buf */

    ushf *d_buf;
    /* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    ulg opt_len;        /* bit length of current block with optimal trees */
    ulg static_len;     /* bit length of current block with static trees */
    uInt matches;       /* number of string matches in current block */
    int last_eob_len;   /* bit length of EOB code for last block */

#ifdef DEBUG
    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
#endif

    ush bi_buf;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    int bi_valid;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

} FAR deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}


#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

        /* in trees.c */
void _tr_init         OF((deflate_state *s));
int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
			  int eof));
void _tr_align        OF((deflate_state *s));
void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
                          int eof));

#define d_code(dist) \
   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */

#ifndef DEBUG
/* Inline versions of _tr_tally for speed: */

#if defined(GEN_TREES_H) || !defined(STDC)
  extern uch _length_code[];
  extern uch _dist_code[];
#else
  extern const uch _length_code[];
  extern const uch _dist_code[];
#endif

# define _tr_tally_lit(s, c, flush) \
  { uch cc = (c); \
    s->d_buf[s->last_lit] = 0; \
    s->l_buf[s->last_lit++] = cc; \
    s->dyn_ltree[cc].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
   }
# define _tr_tally_dist(s, distance, length, flush) \
  { uch len = (length); \
    ush dist = (distance); \
    s->d_buf[s->last_lit] = dist; \
    s->l_buf[s->last_lit++] = len; \
    dist--; \
    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s->dyn_dtree[d_code(dist)].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
  }
#else
# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
# define _tr_tally_dist(s, distance, length, flush) \
              flush = _tr_tally(s, distance, length) 
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\deflate.c ===
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */

#include "deflate.h"

const char deflate_copyright[] =
   " deflate 1.1.4 Copyright 1995-2002 Jean-loup Gailly ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func) OF((deflate_state *s, int flush));
/* Compression function. Returns the block state after the call. */

local void fill_window    OF((deflate_state *s));
local block_state deflate_stored OF((deflate_state *s, int flush));
local block_state deflate_fast   OF((deflate_state *s, int flush));
local block_state deflate_slow   OF((deflate_state *s, int flush));
local void lm_init        OF((deflate_state *s));
local void putShortMSB    OF((deflate_state *s, uInt b));
local void flush_pending  OF((z_streamp strm));
local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
#ifdef ASMV
      void match_init OF((void)); /* asm code initialization */
      uInt longest_match  OF((deflate_state *s, IPos cur_match));
#else
local uInt longest_match  OF((deflate_state *s, IPos cur_match));
#endif

#ifdef DEBUG
local  void check_match OF((deflate_state *s, IPos start, IPos match,
                            int length));
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   ush good_length; /* reduce lazy search above this match length */
   ush max_lazy;    /* do not perform lazy search above this match length */
   ush nice_length; /* quit search above this match length */
   ush max_chain;
   compress_func func;
} config;

local const config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

struct static_tree_desc_s {int dummy;}; /* for buggy compilers */

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#ifdef FASTEST
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#else
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#endif

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    s->head[s->hash_size-1] = NIL; \
    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));

/* ========================================================================= */
int ZEXPORT deflateInit_(strm, level, version, stream_size)
    z_streamp strm;
    int level;
    const char *version;
    int stream_size;
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
			 Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
		  version, stream_size)
    z_streamp strm;
    int  level;
    int  method;
    int  windowBits;
    int  memLevel;
    int  strategy;
    const char *version;
    int stream_size;
{
    deflate_state *s;
    int noheader = 0;
    static const char* my_version = ZLIB_VERSION;

    ushf *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != my_version[0] ||
        stream_size != sizeof(z_stream)) {
	return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == Z_NULL) {
	strm->zalloc = zcalloc;
	strm->opaque = (voidpf)0;
    }
    if (strm->zfree == Z_NULL) strm->zfree = zcfree;

    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#ifdef FASTEST
    level = 1;
#endif

    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
        noheader = 1;
        windowBits = -windowBits;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||
	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
        return Z_STREAM_ERROR;
    }
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state FAR *)s;
    s->strm = strm;

    s->noheader = noheader;
    s->w_bits = windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;
    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    s->pending_buf = (uchf *) overlay;
    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (Byte)method;

    return deflateReset(strm);
}

/* ========================================================================= */
int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
    z_streamp strm;
    const Bytef *dictionary;
    uInt  dictLength;
{
    deflate_state *s;
    uInt length = dictLength;
    uInt n;
    IPos hash_head = 0;

    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;

    s = strm->state;
    strm->adler = adler32(strm->adler, dictionary, dictLength);

    if (length < MIN_MATCH) return Z_OK;
    if (length > MAX_DIST(s)) {
	length = MAX_DIST(s);
#ifndef USE_DICT_HEAD
	dictionary += dictLength - length; /* use the tail of the dictionary */
#endif
    }
    zmemcpy(s->window, dictionary, length);
    s->strstart = length;
    s->block_start = (long)length;

    /* Insert all strings in the hash table (except for the last two bytes).
     * s->lookahead stays null, so s->ins_h will be recomputed at the next
     * call of fill_window.
     */
    s->ins_h = s->window[0];
    UPDATE_HASH(s, s->ins_h, s->window[1]);
    for (n = 0; n <= length - MIN_MATCH; n++) {
	INSERT_STRING(s, n, hash_head);
    }
    if (hash_head) hash_head = 0;  /* to make compiler happy */
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateReset (strm)
    z_streamp strm;
{
    deflate_state *s;
    
    if (strm == Z_NULL || strm->state == Z_NULL ||
        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->noheader < 0) {
        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
    }
    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
    strm->adler = 1;
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);
    lm_init(s);

    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;

    if (level == Z_DEFAULT_COMPRESSION) {
	level = 6;
    }
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
	return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if (func != configuration_table[level].func && strm->total_in != 0) {
	/* Flush the last buffer: */
	err = deflate(strm, Z_PARTIAL_FLUSH);
    }
    if (s->level != level) {
	s->level = level;
	s->max_lazy_match   = configuration_table[level].max_lazy;
	s->good_match       = configuration_table[level].good_length;
	s->nice_match       = configuration_table[level].nice_length;
	s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
local void putShortMSB (s, b)
    deflate_state *s;
    uInt b;
{
    put_byte(s, (Byte)(b >> 8));
    put_byte(s, (Byte)(b & 0xff));
}   

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
local void flush_pending(strm)
    z_streamp strm;
{
    unsigned len = strm->state->pending;

    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, strm->state->pending_out, len);
    strm->next_out  += len;
    strm->state->pending_out  += len;
    strm->total_out += len;
    strm->avail_out  -= len;
    strm->state->pending -= len;
    if (strm->state->pending == 0) {
        strm->state->pending_out = strm->state->pending_buf;
    }
}

/* ========================================================================= */
int ZEXPORT deflate (strm, flush)
    z_streamp strm;
    int flush;
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
	flush > Z_FINISH || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
	(s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in case */
    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Write the zlib header */
    if (s->status == INIT_STATE) {

        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
        uInt level_flags = (s->level-1) >> 1;

        if (level_flags > 3) level_flags = 3;
        header |= (level_flags << 6);
	if (s->strstart != 0) header |= PRESET_DICT;
        header += 31 - (header % 31);

        s->status = BUSY_STATE;
        putShortMSB(s, header);

	/* Save the adler32 of the preset dictionary: */
	if (s->strstart != 0) {
	    putShortMSB(s, (uInt)(strm->adler >> 16));
	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
	}
	strm->adler = 1L;
    }

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
	    /* Since avail_out is 0, deflate will be called again with
	     * more output space, but possibly with both pending and
	     * avail_in equal to zero. There won't be anything to do,
	     * but this is not an error situation so make sure we
	     * return OK instead of BUF_ERROR at next call of deflate:
             */
	    s->last_flush = -1;
	    return Z_OK;
	}

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
     */
    } else if (strm->avail_in == 0 && flush <= old_flush &&
	       flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

	bstate = (*(configuration_table[s->level].func))(s, flush);

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
	    if (strm->avail_out == 0) {
	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
	    }
	    return Z_OK;
	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	     * of deflate should use the same flush parameter to make sure
	     * that the flush is complete. So we don't have to output an
	     * empty block here, this will be done at next call. This also
	     * ensures that for a very small output buffer, we emit at most
	     * one empty block.
	     */
	}
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (char*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                }
            }
            flush_pending(strm);
	    if (strm->avail_out == 0) {
	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	      return Z_OK;
	    }
        }
    }
    Assert(strm->avail_out > 0, "bug2");

    if (flush != Z_FINISH) return Z_OK;
    if (s->noheader) return Z_STREAM_END;

    /* Write the zlib trailer (adler32) */
    putShortMSB(s, (uInt)(strm->adler >> 16));
    putShortMSB(s, (uInt)(strm->adler & 0xffff));
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    s->noheader = -1; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT deflateEnd (strm)
    z_streamp strm;
{
    int status;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

    status = strm->state->status;
    if (status != INIT_STATE && status != BUSY_STATE &&
	status != FINISH_STATE) {
      return Z_STREAM_ERROR;
    }

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */
int ZEXPORT deflateCopy (dest, source)
    z_streamp dest;
    z_streamp source;
{
#ifdef MAXSEG_64K
    return Z_STREAM_ERROR;
#else
    deflate_state *ds;
    deflate_state *ss;
    ushf *overlay;


    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
        return Z_STREAM_ERROR;
    }

    ss = source->state;

    *dest = *source;

    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
    if (ds == Z_NULL) return Z_MEM_ERROR;
    dest->state = (struct internal_state FAR *) ds;
    *ds = *ss;
    ds->strm = dest;

    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
    ds->pending_buf = (uchf *) overlay;

    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
        ds->pending_buf == Z_NULL) {
        deflateEnd (dest);
        return Z_MEM_ERROR;
    }
    /* following zmemcpy do not work for 16-bit MSDOS */
    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

    ds->l_desc.dyn_tree = ds->dyn_ltree;
    ds->d_desc.dyn_tree = ds->dyn_dtree;
    ds->bl_desc.dyn_tree = ds->bl_tree;

    return Z_OK;
#endif
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
local int read_buf(strm, buf, size)
    z_streamp strm;
    Bytef *buf;
    unsigned size;
{
    unsigned len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    if (!strm->state->noheader) {
        strm->adler = adler32(strm->adler, strm->next_in, len);
    }
    zmemcpy(buf, strm->next_in, len);
    strm->next_in  += len;
    strm->total_in += len;

    return (int)len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
local void lm_init (s)
    deflate_state *s;
{
    s->window_size = (ulg)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
#ifdef ASMV
    match_init(); /* initialize the asm code */
#endif
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
#ifndef ASMV
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */
#ifndef FASTEST
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    int best_len = s->prev_length;              /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
    return s->lookahead;
}

#else /* FASTEST */
/* ---------------------------------------------------------------------------
 * Optimized version for level == 1 only
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    Assert(cur_match < s->strstart, "no future");

    match = s->window + cur_match;

    /* Return failure if the match length is less than 2:
     */
    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2, match += 2;
    Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
    } while (*++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     scan < strend);

    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (int)(strend - scan);

    if (len < MIN_MATCH) return MIN_MATCH - 1;

    s->match_start = cur_match;
    return len <= s->lookahead ? len : s->lookahead;
}
#endif /* FASTEST */
#endif /* ASMV */

#ifdef DEBUG
/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
local void check_match(s, start, match, length)
    deflate_state *s;
    IPos start, match;
    int length;
{
    /* check that the match is indeed a match */
    if (zmemcmp(s->window + match,
                s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
		start, match, length);
        do {
	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
	} while (--length != 0);
        z_error("invalid match");
    }
    if (z_verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
local void fill_window(s)
    deflate_state *s;
{
    register unsigned n, m;
    register Posf *p;
    unsigned more;    /* Amount of free space at the end of the window. */
    uInt wsize = s->w_size;

    do {
        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
            more = wsize;

        } else if (more == (unsigned)(-1)) {
            /* Very unlikely, but possible on 16 bit machine if strstart == 0
             * and lookahead == 1 (input done one byte at time)
             */
            more--;

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        } else if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
            s->block_start -= (long) wsize;

            /* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level > 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */
	    n = s->hash_size;
	    p = &s->head[n];
	    do {
		m = *--p;
		*p = (Pos)(m >= wsize ? m-wsize : NIL);
	    } while (--n);

	    n = wsize;
#ifndef FASTEST
	    p = &s->prev[n];
	    do {
		m = *--p;
		*p = (Pos)(m >= wsize ? m-wsize : NIL);
		/* If n is not on any hash chain, prev[n] is garbage but
		 * its value will never be used.
		 */
	    } while (--n);
#endif
            more += wsize;
        }
        if (s->strm->avail_in == 0) return;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead >= MIN_MATCH) {
            s->ins_h = s->window[s->strstart];
            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
            Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, eof) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (charf *)&s->window[(unsigned)s->block_start] : \
                   (charf *)Z_NULL), \
		(ulg)((long)s->strstart - s->block_start), \
		(eof)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, eof) { \
   FLUSH_BLOCK_ONLY(s, eof); \
   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
local block_state deflate_stored(s, flush)
    deflate_state *s;
    int flush;
{
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */
    ulg max_block_size = 0xffff;
    ulg max_start;

    if (max_block_size > s->pending_buf_size - 5) {
        max_block_size = s->pending_buf_size - 5;
    }

    /* Copy as much as possible from input to output: */
    for (;;) {
        /* Fill the window as much as possible: */
        if (s->lookahead <= 1) {

            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
		   s->block_start >= (long)s->w_size, "slide too late");

            fill_window(s);
            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

            if (s->lookahead == 0) break; /* flush the current block */
        }
	Assert(s->block_start >= 0L, "block gone");

	s->strstart += s->lookahead;
	s->lookahead = 0;

	/* Emit a stored block if pending_buf will be full: */
 	max_start = s->block_start + max_block_size;
        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
	    /* strstart == 0 is possible when wraparound on 16-bit machine */
	    s->lookahead = (uInt)(s->strstart - max_start);
	    s->strstart = (uInt)max_start;
            FLUSH_BLOCK(s, 0);
	}
	/* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
	}
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
local block_state deflate_fast(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head = NIL; /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */
        }
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            _tr_tally_dist(s, s->strstart - s->match_start,
                           s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
#ifndef FASTEST
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= MIN_MATCH) {
                s->match_length--; /* string at strstart already in hash table */
                do {
                    s->strstart++;
                    INSERT_STRING(s, s->strstart, hash_head);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++; 
            } else
#endif
	    {
                s->strstart += s->match_length;
                s->match_length = 0;
                s->ins_h = s->window[s->strstart];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++; 
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
local block_state deflate_slow(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head = NIL;    /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
                 (s->match_length == MIN_MATCH &&
                  s->strstart - s->match_start > TOO_FAR))) {

                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
			   s->prev_length - MIN_MATCH, bflush);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;
            s->prev_length -= 2;
            do {
                if (++s->strstart <= max_insert) {
                    INSERT_STRING(s, s->strstart, hash_head);
                }
            } while (--s->prev_length != 0);
            s->match_available = 0;
            s->match_length = MIN_MATCH-1;
            s->strstart++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    _tr_tally_lit(s, s->window[s->strstart-1], bflush);
	    if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
        s->match_available = 0;
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\compress.c ===
/* compress.c -- compress a memory buffer
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/
int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
    int level;
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
#ifdef MAXSEG_64K
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
#endif
    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = deflateInit(&stream, level);
    if (err != Z_OK) return err;

    err = deflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        deflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = deflateEnd(&stream);
    return err;
}

/* ===========================================================================
 */
int ZEXPORT compress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\crc32.c ===
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);
 
  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}
#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;
}

/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\infblock.c ===
/* infblock.c -- interpret and process block types to last block
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* Table for deflate from PKZIP's appnote.txt. */
local const uInt border[] = { /* Order of the bit length code lengths */
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/*
   Notes beyond the 1.93a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarily, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), whereas to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
      258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */


void inflate_blocks_reset(s, z, c)
inflate_blocks_statef *s;
z_streamp z;
uLongf *c;
{
  if (c != Z_NULL)
    *c = s->check;
  if (s->mode == BTREE || s->mode == DTREE)
    ZFREE(z, s->sub.trees.blens);
  if (s->mode == CODES)
    inflate_codes_free(s->sub.decode.codes, z);
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
  Tracev((stderr, "inflate:   blocks reset\n"));
}


inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_streamp z;
check_func c;
uInt w;
{
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
    return s;
  if ((s->hufts =
       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
  {
    ZFREE(z, s);
    return Z_NULL;
  }
  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
  {
    ZFREE(z, s->hufts);
    ZFREE(z, s);
    return Z_NULL;
  }
  s->end = s->window + w;
  s->checkfn = c;
  s->mode = TYPE;
  Tracev((stderr, "inflate:   blocks allocated\n"));
  inflate_blocks_reset(s, z, Z_NULL);
  return s;
}


int inflate_blocks(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt t;               /* temporary storage */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input based on current state */
  while (1) switch (s->mode)
  {
    case TYPE:
      NEEDBITS(3)
      t = (uInt)b & 7;
      s->last = t & 1;
      switch (t >> 1)
      {
        case 0:                         /* stored */
          Tracev((stderr, "inflate:     stored block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          t = k & 7;                    /* go to byte boundary */
          DUMPBITS(t)
          s->mode = LENS;               /* get length of stored block */
          break;
        case 1:                         /* fixed */
          Tracev((stderr, "inflate:     fixed codes block%s\n",
                 s->last ? " (last)" : ""));
          {
            uInt bl, bd;
            inflate_huft *tl, *td;

            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
            if (s->sub.decode.codes == Z_NULL)
            {
              r = Z_MEM_ERROR;
              LEAVE
            }
          }
          DUMPBITS(3)
          s->mode = CODES;
          break;
        case 2:                         /* dynamic */
          Tracev((stderr, "inflate:     dynamic codes block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          s->mode = TABLE;
          break;
        case 3:                         /* illegal */
          DUMPBITS(3)
          s->mode = BAD;
          z->msg = (char*)"invalid block type";
          r = Z_DATA_ERROR;
          LEAVE
      }
      break;
    case LENS:
      NEEDBITS(32)
      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
      {
        s->mode = BAD;
        z->msg = (char*)"invalid stored block lengths";
        r = Z_DATA_ERROR;
        LEAVE
      }
      s->sub.left = (uInt)b & 0xffff;
      b = k = 0;                      /* dump bits */
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
      break;
    case STORED:
      if (n == 0)
        LEAVE
      NEEDOUT
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
      q += t;  m -= t;
      if ((s->sub.left -= t) != 0)
        break;
      Tracev((stderr, "inflate:       stored end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
      break;
    case TABLE:
      NEEDBITS(14)
      s->sub.trees.table = t = (uInt)b & 0x3fff;
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
      {
        s->mode = BAD;
        z->msg = (char*)"too many length or distance symbols";
        r = Z_DATA_ERROR;
        LEAVE
      }
#endif
      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
      {
        r = Z_MEM_ERROR;
        LEAVE
      }
      DUMPBITS(14)
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
        NEEDBITS(3)
        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
        DUMPBITS(3)
      }
      while (s->sub.trees.index < 19)
        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
      s->sub.trees.bb = 7;
      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
                             &s->sub.trees.tb, s->hufts, z);
      if (t != Z_OK)
      {
        r = t;
        if (r == Z_DATA_ERROR)
        {
          ZFREE(z, s->sub.trees.blens);
          s->mode = BAD;
        }
        LEAVE
      }
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       bits tree ok\n"));
      s->mode = DTREE;
    case DTREE:
      while (t = s->sub.trees.table,
             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
      {
        inflate_huft *h;
        uInt i, j, c;

        t = s->sub.trees.bb;
        NEEDBITS(t)
        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
        t = h->bits;
        c = h->base;
        if (c < 16)
        {
          DUMPBITS(t)
          s->sub.trees.blens[s->sub.trees.index++] = c;
        }
        else /* c == 16..18 */
        {
          i = c == 18 ? 7 : c - 14;
          j = c == 18 ? 11 : 3;
          NEEDBITS(t + i)
          DUMPBITS(t)
          j += (uInt)b & inflate_mask[i];
          DUMPBITS(i)
          i = s->sub.trees.index;
          t = s->sub.trees.table;
          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
              (c == 16 && i < 1))
          {
            ZFREE(z, s->sub.trees.blens);
            s->mode = BAD;
            z->msg = (char*)"invalid bit length repeat";
            r = Z_DATA_ERROR;
            LEAVE
          }
          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
          do {
            s->sub.trees.blens[i++] = c;
          } while (--j);
          s->sub.trees.index = i;
        }
      }
      s->sub.trees.tb = Z_NULL;
      {
        uInt bl, bd;
        inflate_huft *tl, *td;
        inflate_codes_statef *c;

        bl = 9;         /* must be <= 9 for lookahead assumptions */
        bd = 6;         /* must be <= 9 for lookahead assumptions */
        t = s->sub.trees.table;
        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
                                  s->hufts, z);
        if (t != Z_OK)
        {
          if (t == (uInt)Z_DATA_ERROR)
          {
            ZFREE(z, s->sub.trees.blens);
            s->mode = BAD;
          }
          r = t;
          LEAVE
        }
        Tracev((stderr, "inflate:       trees ok\n"));
        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
        {
          r = Z_MEM_ERROR;
          LEAVE
        }
        s->sub.decode.codes = c;
      }
      ZFREE(z, s->sub.trees.blens);
      s->mode = CODES;
    case CODES:
      UPDATE
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
        return inflate_flush(s, z, r);
      r = Z_OK;
      inflate_codes_free(s->sub.decode.codes, z);
      LOAD
      Tracev((stderr, "inflate:       codes end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      if (!s->last)
      {
        s->mode = TYPE;
        break;
      }
      s->mode = DRY;
    case DRY:
      FLUSH
      if (s->read != s->write)
        LEAVE
      s->mode = DONE;
    case DONE:
      r = Z_STREAM_END;
      LEAVE
    case BAD:
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
}


int inflate_blocks_free(s, z)
inflate_blocks_statef *s;
z_streamp z;
{
  inflate_blocks_reset(s, z, Z_NULL);
  ZFREE(z, s->window);
  ZFREE(z, s->hufts);
  ZFREE(z, s);
  Tracev((stderr, "inflate:   blocks freed\n"));
  return Z_OK;
}


void inflate_set_dictionary(s, d, n)
inflate_blocks_statef *s;
const Bytef *d;
uInt  n;
{
  zmemcpy(s->window, d, n);
  s->read = s->write = s->window + n;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
 * IN assertion: s != Z_NULL
 */
int inflate_blocks_sync_point(s)
inflate_blocks_statef *s;
{
  return s->mode == LENS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\example.c ===
/* example.c -- usage example of the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include <stdio.h>
#include "zlib.h"

#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#else
   extern void exit  OF((int));
#endif

#if defined(VMS) || defined(RISCOS)
#  define TESTFILE "foo-gz"
#else
#  define TESTFILE "foo.gz"
#endif

#define CHECK_ERR(err, msg) { \
    if (err != Z_OK) { \
        fprintf(stderr, "%s error: %d\n", msg, err); \
        exit(1); \
    } \
}

const char hello[] = "hello, hello!";
/* "hello world" would be more standard, but the repeated "hello"
 * stresses the compression code better, sorry...
 */

const char dictionary[] = "hello";
uLong dictId; /* Adler32 value of the dictionary */

void test_compress      OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_gzio          OF((const char *out, const char *in, 
		            Byte *uncompr, int uncomprLen));
void test_deflate       OF((Byte *compr, uLong comprLen));
void test_inflate       OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_large_deflate OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_large_inflate OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_flush         OF((Byte *compr, uLong *comprLen));
void test_sync          OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_dict_deflate  OF((Byte *compr, uLong comprLen));
void test_dict_inflate  OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
int  main               OF((int argc, char *argv[]));

/* ===========================================================================
 * Test compress() and uncompress()
 */
void test_compress(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    uLong len = strlen(hello)+1;

    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, "compress");

    strcpy((char*)uncompr, "garbage");

    err = uncompress(uncompr, &uncomprLen, compr, comprLen);
    CHECK_ERR(err, "uncompress");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad uncompress\n");
	exit(1);
    } else {
        printf("uncompress(): %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Test read/write of .gz files
 */
void test_gzio(out, in, uncompr, uncomprLen)
    const char *out; /* compressed output file */
    const char *in;  /* compressed input file */
    Byte *uncompr;
    int  uncomprLen;
{
    int err;
    int len = strlen(hello)+1;
    gzFile file;
    z_off_t pos;

    file = gzopen(out, "wb");
    if (file == NULL) {
        fprintf(stderr, "gzopen error\n");
        exit(1);
    }
    gzputc(file, 'h');
    if (gzputs(file, "ello") != 4) {
        fprintf(stderr, "gzputs err: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (gzprintf(file, ", %s!", "hello") != 8) {
        fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
	exit(1);
    }
    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
    gzclose(file);

    file = gzopen(in, "rb");
    if (file == NULL) {
        fprintf(stderr, "gzopen error\n");
    }
    strcpy((char*)uncompr, "garbage");

    uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);
    if (uncomprLen != len) {
        fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
	exit(1);
    } else {
        printf("gzread(): %s\n", (char *)uncompr);
    }

    pos = gzseek(file, -8L, SEEK_CUR);
    if (pos != 6 || gztell(file) != pos) {
	fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
		(long)pos, (long)gztell(file));
	exit(1);
    }

    if (gzgetc(file) != ' ') {
	fprintf(stderr, "gzgetc error\n");
	exit(1);
    }

    gzgets(file, (char*)uncompr, uncomprLen);
    uncomprLen = strlen((char*)uncompr);
    if (uncomprLen != 6) { /* "hello!" */
        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (strcmp((char*)uncompr, hello+7)) {
        fprintf(stderr, "bad gzgets after gzseek\n");
	exit(1);
    } else {
        printf("gzgets() after gzseek: %s\n", (char *)uncompr);
    }

    gzclose(file);
}

/* ===========================================================================
 * Test deflate() with small buffers
 */
void test_deflate(compr, comprLen)
    Byte *compr;
    uLong comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;
    int len = strlen(hello)+1;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_in  = (Bytef*)hello;
    c_stream.next_out = compr;

    while (c_stream.total_in != (uLong)len && c_stream.total_out < comprLen) {
        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
        err = deflate(&c_stream, Z_NO_FLUSH);
        CHECK_ERR(err, "deflate");
    }
    /* Finish the stream, still forcing small buffers: */
    for (;;) {
        c_stream.avail_out = 1;
        err = deflate(&c_stream, Z_FINISH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "deflate");
    }

    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with small buffers
 */
void test_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = 0;
    d_stream.next_out = uncompr;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "inflate");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad inflate\n");
	exit(1);
    } else {
        printf("inflate(): %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Test deflate() with large buffers and dynamic change of compression level
 */
void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    z_stream c_stream; /* compression stream */
    int err;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_BEST_SPEED);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_out = compr;
    c_stream.avail_out = (uInt)comprLen;

    /* At this point, uncompr is still mostly zeroes, so it should compress
     * very well:
     */
    c_stream.next_in = uncompr;
    c_stream.avail_in = (uInt)uncomprLen;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");
    if (c_stream.avail_in != 0) {
        fprintf(stderr, "deflate not greedy\n");
	exit(1);
    }

    /* Feed in already compressed data and switch to no compression: */
    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
    c_stream.next_in = compr;
    c_stream.avail_in = (uInt)comprLen/2;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");

    /* Switch back to compressing mode: */
    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
    c_stream.next_in = uncompr;
    c_stream.avail_in = (uInt)uncomprLen;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        fprintf(stderr, "deflate should report Z_STREAM_END\n");
	exit(1);
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with large buffers
 */
void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = (uInt)comprLen;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    for (;;) {
        d_stream.next_out = uncompr;            /* discard the output */
	d_stream.avail_out = (uInt)uncomprLen;
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "large inflate");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
        fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
	exit(1);
    } else {
        printf("large_inflate(): OK\n");
    }
}

/* ===========================================================================
 * Test deflate() with full flush
 */
void test_flush(compr, comprLen)
    Byte *compr;
    uLong *comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;
    int len = strlen(hello)+1;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_in  = (Bytef*)hello;
    c_stream.next_out = compr;
    c_stream.avail_in = 3;
    c_stream.avail_out = (uInt)*comprLen;
    err = deflate(&c_stream, Z_FULL_FLUSH);
    CHECK_ERR(err, "deflate");

    compr[3]++; /* force an error in first compressed block */
    c_stream.avail_in = len - 3;

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        CHECK_ERR(err, "deflate");
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");

    *comprLen = c_stream.total_out;
}

/* ===========================================================================
 * Test inflateSync()
 */
void test_sync(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = 2; /* just read the zlib header */

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    d_stream.next_out = uncompr;
    d_stream.avail_out = (uInt)uncomprLen;

    inflate(&d_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "inflate");

    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
    err = inflateSync(&d_stream);           /* but skip the damaged part */
    CHECK_ERR(err, "inflateSync");

    err = inflate(&d_stream, Z_FINISH);
    if (err != Z_DATA_ERROR) {
        fprintf(stderr, "inflate should report DATA_ERROR\n");
        /* Because of incorrect adler32 */
	exit(1);
    }
    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    printf("after inflateSync(): hel%s\n", (char *)uncompr);
}

/* ===========================================================================
 * Test deflate() with preset dictionary
 */
void test_dict_deflate(compr, comprLen)
    Byte *compr;
    uLong comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    err = deflateSetDictionary(&c_stream,
			       (const Bytef*)dictionary, sizeof(dictionary));
    CHECK_ERR(err, "deflateSetDictionary");

    dictId = c_stream.adler;
    c_stream.next_out = compr;
    c_stream.avail_out = (uInt)comprLen;

    c_stream.next_in = (Bytef*)hello;
    c_stream.avail_in = (uInt)strlen(hello)+1;

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        fprintf(stderr, "deflate should report Z_STREAM_END\n");
	exit(1);
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with a preset dictionary
 */
void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = (uInt)comprLen;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    d_stream.next_out = uncompr;
    d_stream.avail_out = (uInt)uncomprLen;

    for (;;) {
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
	if (err == Z_NEED_DICT) {
	    if (d_stream.adler != dictId) {
		fprintf(stderr, "unexpected dictionary");
		exit(1);
	    }
	    err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
				       sizeof(dictionary));
	}
        CHECK_ERR(err, "inflate with dict");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad inflate with dict\n");
	exit(1);
    } else {
        printf("inflate with dictionary: %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Usage:  example [output.gz  [input.gz]]
 */

int main(argc, argv)
    int argc;
    char *argv[];
{
    Byte *compr, *uncompr;
    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
    uLong uncomprLen = comprLen;
    static const char* myVersion = ZLIB_VERSION;

    if (zlibVersion()[0] != myVersion[0]) {
        fprintf(stderr, "incompatible zlib version\n");
        exit(1);

    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
        fprintf(stderr, "warning: different zlib version\n");
    }

    compr    = (Byte*)calloc((uInt)comprLen, 1);
    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
    /* compr and uncompr are cleared to avoid reading uninitialized
     * data and to ensure that uncompr compresses well.
     */
    if (compr == Z_NULL || uncompr == Z_NULL) {
        printf("out of memory\n");
	exit(1);
    }
    test_compress(compr, comprLen, uncompr, uncomprLen);

    test_gzio((argc > 1 ? argv[1] : TESTFILE),
              (argc > 2 ? argv[2] : TESTFILE),
	      uncompr, (int)uncomprLen);

    test_deflate(compr, comprLen);
    test_inflate(compr, comprLen, uncompr, uncomprLen);

    test_large_deflate(compr, comprLen, uncompr, uncomprLen);
    test_large_inflate(compr, comprLen, uncompr, uncomprLen);

    test_flush(compr, &comprLen);
    test_sync(compr, comprLen, uncompr, uncomprLen);
    comprLen = uncomprLen;

    test_dict_deflate(compr, comprLen);
    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);

    exit(0);
    return 0; /* to avoid warning */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\gzio.c ===
/* gzio.c -- IO on .gz files
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Compile this file with -DNO_DEFLATE to avoid the compression code.
 */

/* @(#) $Id$ */

#include <stdio.h>

#include "zutil.h"

struct internal_state {int dummy;}; /* for buggy compilers */

#ifndef Z_BUFSIZE
#  ifdef MAXSEG_64K
#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
#  else
#    define Z_BUFSIZE 16384
#  endif
#endif
#ifndef Z_PRINTF_BUFSIZE
#  define Z_PRINTF_BUFSIZE 4096
#endif

#define ALLOC(size) malloc(size)
#define TRYFREE(p) {if (p) free(p);}

static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

/* gzip flag byte */
#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
#define COMMENT      0x10 /* bit 4 set: file comment present */
#define RESERVED     0xE0 /* bits 5..7: reserved */

typedef struct gz_stream {
    z_stream stream;
    int      z_err;   /* error code for last stream operation */
    int      z_eof;   /* set if end of input file */
    FILE     *file;   /* .gz file */
    Byte     *inbuf;  /* input buffer */
    Byte     *outbuf; /* output buffer */
    uLong    crc;     /* crc32 of uncompressed data */
    char     *msg;    /* error message */
    char     *path;   /* path name for debugging only */
    int      transparent; /* 1 if input file is not a .gz file */
    char     mode;    /* 'w' or 'r' */
    long     startpos; /* start of compressed data in file (header skipped) */
} gz_stream;


local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
local int do_flush        OF((gzFile file, int flush));
local int    get_byte     OF((gz_stream *s));
local void   check_header OF((gz_stream *s));
local int    destroy      OF((gz_stream *s));
local void   putLong      OF((FILE *file, uLong x));
local uLong  getLong      OF((gz_stream *s));

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
   or path name (if fd == -1).
     gz_open return NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/
local gzFile gz_open (path, mode, fd)
    const char *path;
    const char *mode;
    int  fd;
{
    int err;
    int level = Z_DEFAULT_COMPRESSION; /* compression level */
    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
    char *p = (char*)mode;
    gz_stream *s;
    char fmode[80]; /* copy of mode, without the compression level */
    char *m = fmode;

    if (!path || !mode) return Z_NULL;

    s = (gz_stream *)ALLOC(sizeof(gz_stream));
    if (!s) return Z_NULL;

    s->stream.zalloc = (alloc_func)0;
    s->stream.zfree = (free_func)0;
    s->stream.opaque = (voidpf)0;
    s->stream.next_in = s->inbuf = Z_NULL;
    s->stream.next_out = s->outbuf = Z_NULL;
    s->stream.avail_in = s->stream.avail_out = 0;
    s->file = NULL;
    s->z_err = Z_OK;
    s->z_eof = 0;
    s->crc = crc32(0L, Z_NULL, 0);
    s->msg = NULL;
    s->transparent = 0;

    s->path = (char*)ALLOC(strlen(path)+1);
    if (s->path == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    strcpy(s->path, path); /* do this early for debugging */

    s->mode = '\0';
    do {
        if (*p == 'r') s->mode = 'r';
        if (*p == 'w' || *p == 'a') s->mode = 'w';
        if (*p >= '0' && *p <= '9') {
	    level = *p - '0';
	} else if (*p == 'f') {
	  strategy = Z_FILTERED;
	} else if (*p == 'h') {
	  strategy = Z_HUFFMAN_ONLY;
	} else {
	    *m++ = *p; /* copy the mode */
	}
    } while (*p++ && m != fmode + sizeof(fmode));
    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
    
    if (s->mode == 'w') {
#ifdef NO_DEFLATE
        err = Z_STREAM_ERROR;
#else
        err = deflateInit2(&(s->stream), level,
                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
        /* windowBits is passed < 0 to suppress zlib header */

        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
#endif
        if (err != Z_OK || s->outbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    } else {
        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);

        err = inflateInit2(&(s->stream), -MAX_WBITS);
        /* windowBits is passed < 0 to tell that there is no zlib header.
         * Note that in this case inflate *requires* an extra "dummy" byte
         * after the compressed stream in order to complete decompression and
         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
         * present after the compressed stream.
         */
        if (err != Z_OK || s->inbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    }
    s->stream.avail_out = Z_BUFSIZE;

    errno = 0;
    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);

    if (s->file == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    if (s->mode == 'w') {
        /* Write a very simple .gz header:
         */
        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
	s->startpos = 10L;
	/* We use 10L instead of ftell(s->file) to because ftell causes an
         * fflush on some systems. This version of the library doesn't use
         * startpos anyway in write mode, so this initialization is not
         * necessary.
         */
    } else {
	check_header(s); /* skip the .gz header */
	s->startpos = (ftell(s->file) - s->stream.avail_in);
    }
    
    return (gzFile)s;
}

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing.
*/
gzFile ZEXPORT gzopen (path, mode)
    const char *path;
    const char *mode;
{
    return gz_open (path, mode, -1);
}

/* ===========================================================================
     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
   to mimic the behavio(u)r of fdopen.
*/
gzFile ZEXPORT gzdopen (fd, mode)
    int fd;
    const char *mode;
{
    char name[20];

    if (fd < 0) return (gzFile)Z_NULL;
    sprintf(name, "<fd:%d>", fd); /* for debugging */

    return gz_open (name, mode, fd);
}

/* ===========================================================================
 * Update the compression level and strategy
 */
int ZEXPORT gzsetparams (file, level, strategy)
    gzFile file;
    int level;
    int strategy;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    /* Make room to allow flushing */
    if (s->stream.avail_out == 0) {

	s->stream.next_out = s->outbuf;
	if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
	    s->z_err = Z_ERRNO;
	}
	s->stream.avail_out = Z_BUFSIZE;
    }

    return deflateParams (&(s->stream), level, strategy);
}

/* ===========================================================================
     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
   for end of file.
   IN assertion: the stream s has been sucessfully opened for reading.
*/
local int get_byte(s)
    gz_stream *s;
{
    if (s->z_eof) return EOF;
    if (s->stream.avail_in == 0) {
	errno = 0;
	s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
	if (s->stream.avail_in == 0) {
	    s->z_eof = 1;
	    if (ferror(s->file)) s->z_err = Z_ERRNO;
	    return EOF;
	}
	s->stream.next_in = s->inbuf;
    }
    s->stream.avail_in--;
    return *(s->stream.next_in)++;
}

/* ===========================================================================
      Check the gzip header of a gz_stream opened for reading. Set the stream
    mode to transparent if the gzip magic header is not present; set s->err
    to Z_DATA_ERROR if the magic header is present but the rest of the header
    is incorrect.
    IN assertion: the stream s has already been created sucessfully;
       s->stream.avail_in is zero for the first time, but may be non-zero
       for concatenated .gz files.
*/
local void check_header(s)
    gz_stream *s;
{
    int method; /* method byte */
    int flags;  /* flags byte */
    uInt len;
    int c;

    /* Check the gzip magic header */
    for (len = 0; len < 2; len++) {
	c = get_byte(s);
	if (c != gz_magic[len]) {
	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
	    if (c != EOF) {
		s->stream.avail_in++, s->stream.next_in--;
		s->transparent = 1;
	    }
	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
	    return;
	}
    }
    method = get_byte(s);
    flags = get_byte(s);
    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
	s->z_err = Z_DATA_ERROR;
	return;
    }

    /* Discard time, xflags and OS code: */
    for (len = 0; len < 6; len++) (void)get_byte(s);

    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
	len  =  (uInt)get_byte(s);
	len += ((uInt)get_byte(s))<<8;
	/* len is garbage if EOF but the loop below will quit anyway */
	while (len-- != 0 && get_byte(s) != EOF) ;
    }
    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
	for (len = 0; len < 2; len++) (void)get_byte(s);
    }
    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
}

 /* ===========================================================================
 * Cleanup then free the given gz_stream. Return a zlib error code.
   Try freeing in the reverse order of allocations.
 */
local int destroy (s)
    gz_stream *s;
{
    int err = Z_OK;

    if (!s) return Z_STREAM_ERROR;

    TRYFREE(s->msg);

    if (s->stream.state != NULL) {
	if (s->mode == 'w') {
#ifdef NO_DEFLATE
	    err = Z_STREAM_ERROR;
#else
	    err = deflateEnd(&(s->stream));
#endif
	} else if (s->mode == 'r') {
	    err = inflateEnd(&(s->stream));
	}
    }
    if (s->file != NULL && fclose(s->file)) {
#ifdef ESPIPE
	if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
#endif
	    err = Z_ERRNO;
    }
    if (s->z_err < 0) err = s->z_err;

    TRYFREE(s->inbuf);
    TRYFREE(s->outbuf);
    TRYFREE(s->path);
    TRYFREE(s);
    return err;
}

/* ===========================================================================
     Reads the given number of uncompressed bytes from the compressed file.
   gzread returns the number of bytes actually read (0 for end of file).
*/
int ZEXPORT gzread (file, buf, len)
    gzFile file;
    voidp buf;
    unsigned len;
{
    gz_stream *s = (gz_stream*)file;
    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */

    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */

    next_out = (Byte*)buf;
    s->stream.next_out = (Bytef*)buf;
    s->stream.avail_out = len;

    while (s->stream.avail_out != 0) {

	if (s->transparent) {
	    /* Copy first the lookahead bytes: */
	    uInt n = s->stream.avail_in;
	    if (n > s->stream.avail_out) n = s->stream.avail_out;
	    if (n > 0) {
		zmemcpy(s->stream.next_out, s->stream.next_in, n);
		next_out += n;
		s->stream.next_out = next_out;
		s->stream.next_in   += n;
		s->stream.avail_out -= n;
		s->stream.avail_in  -= n;
	    }
	    if (s->stream.avail_out > 0) {
		s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
					     s->file);
	    }
	    len -= s->stream.avail_out;
	    s->stream.total_in  += (uLong)len;
	    s->stream.total_out += (uLong)len;
            if (len == 0) s->z_eof = 1;
	    return (int)len;
	}
        if (s->stream.avail_in == 0 && !s->z_eof) {

            errno = 0;
            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
            if (s->stream.avail_in == 0) {
                s->z_eof = 1;
		if (ferror(s->file)) {
		    s->z_err = Z_ERRNO;
		    break;
		}
            }
            s->stream.next_in = s->inbuf;
        }
        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

	if (s->z_err == Z_STREAM_END) {
	    /* Check CRC and original size */
	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
	    start = s->stream.next_out;

	    if (getLong(s) != s->crc) {
		s->z_err = Z_DATA_ERROR;
	    } else {
	        (void)getLong(s);
                /* The uncompressed length returned by above getlong() may
                 * be different from s->stream.total_out) in case of
		 * concatenated .gz files. Check for such files:
		 */
		check_header(s);
		if (s->z_err == Z_OK) {
		    uLong total_in = s->stream.total_in;
		    uLong total_out = s->stream.total_out;

		    inflateReset(&(s->stream));
		    s->stream.total_in = total_in;
		    s->stream.total_out = total_out;
		    s->crc = crc32(0L, Z_NULL, 0);
		}
	    }
	}
	if (s->z_err != Z_OK || s->z_eof) break;
    }
    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

    return (int)(len - s->stream.avail_out);
}


/* ===========================================================================
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/
int ZEXPORT gzgetc(file)
    gzFile file;
{
    unsigned char c;

    return gzread(file, &c, 1) == 1 ? c : -1;
}


/* ===========================================================================
      Reads bytes from the compressed file until len-1 characters are
   read, or a newline character is read and transferred to buf, or an
   end-of-file condition is encountered.  The string is then terminated
   with a null character.
      gzgets returns buf, or Z_NULL in case of error.

      The current implementation is not optimized at all.
*/
char * ZEXPORT gzgets(file, buf, len)
    gzFile file;
    char *buf;
    int len;
{
    char *b = buf;
    if (buf == Z_NULL || len <= 0) return Z_NULL;

    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
    *buf = '\0';
    return b == buf && len > 0 ? Z_NULL : b;
}


#ifndef NO_DEFLATE
/* ===========================================================================
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of bytes actually written (0 in case of error).
*/
int ZEXPORT gzwrite (file, buf, len)
    gzFile file;
    const voidp buf;
    unsigned len;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.next_in = (Bytef*)buf;
    s->stream.avail_in = len;

    while (s->stream.avail_in != 0) {

        if (s->stream.avail_out == 0) {

            s->stream.next_out = s->outbuf;
            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
                s->z_err = Z_ERRNO;
                break;
            }
            s->stream.avail_out = Z_BUFSIZE;
        }
        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
        if (s->z_err != Z_OK) break;
    }
    s->crc = crc32(s->crc, (const Bytef *)buf, len);

    return (int)(len - s->stream.avail_in);
}

/* ===========================================================================
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/
#ifdef STDC
#include <stdarg.h>

int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
{
    char buf[Z_PRINTF_BUFSIZE];
    va_list va;
    int len;

    va_start(va, format);
#ifdef HAS_vsnprintf
    (void)vsnprintf(buf, sizeof(buf), format, va);
#else
    (void)vsprintf(buf, format, va);
#endif
    va_end(va);
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, (unsigned)len);
}
#else /* not ANSI C */

int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    char buf[Z_PRINTF_BUFSIZE];
    int len;

#ifdef HAS_snprintf
    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
	     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#else
    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
	    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#endif
    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, len);
}
#endif

/* ===========================================================================
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/
int ZEXPORT gzputc(file, c)
    gzFile file;
    int c;
{
    unsigned char cc = (unsigned char) c; /* required for big endian systems */

    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
}


/* ===========================================================================
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/
int ZEXPORT gzputs(file, s)
    gzFile file;
    const char *s;
{
    return gzwrite(file, (char*)s, (unsigned)strlen(s));
}


/* ===========================================================================
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function.
*/
local int do_flush (file, flush)
    gzFile file;
    int flush;
{
    uInt len;
    int done = 0;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.avail_in = 0; /* should be zero already anyway */

    for (;;) {
        len = Z_BUFSIZE - s->stream.avail_out;

        if (len != 0) {
            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
                s->z_err = Z_ERRNO;
                return Z_ERRNO;
            }
            s->stream.next_out = s->outbuf;
            s->stream.avail_out = Z_BUFSIZE;
        }
        if (done) break;
        s->z_err = deflate(&(s->stream), flush);

	/* Ignore the second of two consecutive flushes: */
	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;

        /* deflate has finished flushing only when it hasn't used up
         * all the available space in the output buffer: 
         */
        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
 
        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
    }
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}

int ZEXPORT gzflush (file, flush)
     gzFile file;
     int flush;
{
    gz_stream *s = (gz_stream*)file;
    int err = do_flush (file, flush);

    if (err) return err;
    fflush(s->file);
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}
#endif /* NO_DEFLATE */

/* ===========================================================================
      Sets the starting position for the next gzread or gzwrite on the given
   compressed file. The offset represents a number of bytes in the
      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error.
      SEEK_END is not implemented, returns error.
      In this version of the library, gzseek can be extremely slow.
*/
z_off_t ZEXPORT gzseek (file, offset, whence)
    gzFile file;
    z_off_t offset;
    int whence;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || whence == SEEK_END ||
	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
	return -1L;
    }
    
    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return -1L;
#else
	if (whence == SEEK_SET) {
	    offset -= s->stream.total_in;
	}
	if (offset < 0) return -1L;

	/* At this point, offset is the number of zero bytes to write. */
	if (s->inbuf == Z_NULL) {
	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
	    zmemzero(s->inbuf, Z_BUFSIZE);
	}
	while (offset > 0)  {
	    uInt size = Z_BUFSIZE;
	    if (offset < Z_BUFSIZE) size = (uInt)offset;

	    size = gzwrite(file, s->inbuf, size);
	    if (size == 0) return -1L;

	    offset -= size;
	}
	return (z_off_t)s->stream.total_in;
#endif
    }
    /* Rest of function is for reading only */

    /* compute absolute position */
    if (whence == SEEK_CUR) {
	offset += s->stream.total_out;
    }
    if (offset < 0) return -1L;

    if (s->transparent) {
	/* map to fseek */
	s->stream.avail_in = 0;
	s->stream.next_in = s->inbuf;
        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;

	s->stream.total_in = s->stream.total_out = (uLong)offset;
	return offset;
    }

    /* For a negative seek, rewind and use positive seek */
    if ((uLong)offset >= s->stream.total_out) {
	offset -= s->stream.total_out;
    } else if (gzrewind(file) < 0) {
	return -1L;
    }
    /* offset is now the number of bytes to skip. */

    if (offset != 0 && s->outbuf == Z_NULL) {
	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
    }
    while (offset > 0)  {
	int size = Z_BUFSIZE;
	if (offset < Z_BUFSIZE) size = (int)offset;

	size = gzread(file, s->outbuf, (uInt)size);
	if (size <= 0) return -1L;
	offset -= size;
    }
    return (z_off_t)s->stream.total_out;
}

/* ===========================================================================
     Rewinds input file. 
*/
int ZEXPORT gzrewind (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;
    
    if (s == NULL || s->mode != 'r') return -1;

    s->z_err = Z_OK;
    s->z_eof = 0;
    s->stream.avail_in = 0;
    s->stream.next_in = s->inbuf;
    s->crc = crc32(0L, Z_NULL, 0);
	
    if (s->startpos == 0) { /* not a compressed file */
	rewind(s->file);
	return 0;
    }

    (void) inflateReset(&s->stream);
    return fseek(s->file, s->startpos, SEEK_SET);
}

/* ===========================================================================
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.
*/
z_off_t ZEXPORT gztell (file)
    gzFile file;
{
    return gzseek(file, 0L, SEEK_CUR);
}

/* ===========================================================================
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/
int ZEXPORT gzeof (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;
    
    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
}

/* ===========================================================================
   Outputs a long in LSB order to the given file
*/
local void putLong (file, x)
    FILE *file;
    uLong x;
{
    int n;
    for (n = 0; n < 4; n++) {
        fputc((int)(x & 0xff), file);
        x >>= 8;
    }
}

/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets z_err in case
   of error.
*/
local uLong getLong (s)
    gz_stream *s;
{
    uLong x = (uLong)get_byte(s);
    int c;

    x += ((uLong)get_byte(s))<<8;
    x += ((uLong)get_byte(s))<<16;
    c = get_byte(s);
    if (c == EOF) s->z_err = Z_DATA_ERROR;
    x += ((uLong)c)<<24;
    return x;
}

/* ===========================================================================
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state.
*/
int ZEXPORT gzclose (file)
    gzFile file;
{
    int err;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) return Z_STREAM_ERROR;

    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return Z_STREAM_ERROR;
#else
        err = do_flush (file, Z_FINISH);
        if (err != Z_OK) return destroy((gz_stream*)file);

        putLong (s->file, s->crc);
        putLong (s->file, s->stream.total_in);
#endif
    }
    return destroy((gz_stream*)file);
}

/* ===========================================================================
     Returns the error message for the last error which occured on the
   given compressed file. errnum is set to zlib error number. If an
   error occured in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/
const char*  ZEXPORT gzerror (file, errnum)
    gzFile file;
    int *errnum;
{
    char *m;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) {
        *errnum = Z_STREAM_ERROR;
        return (const char*)ERR_MSG(Z_STREAM_ERROR);
    }
    *errnum = s->z_err;
    if (*errnum == Z_OK) return (const char*)"";

    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

    TRYFREE(s->msg);
    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
    strcpy(s->msg, s->path);
    strcat(s->msg, ": ");
    strcat(s->msg, m);
    return (const char*)s->msg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\inffast.h ===
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

extern int inflate_fast OF((
    uInt,
    uInt,
    inflate_huft *,
    inflate_huft *,
    inflate_blocks_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\infcodes.h ===
/* infcodes.h -- header to use infcodes.c
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_codes_state;
typedef struct inflate_codes_state FAR inflate_codes_statef;

extern inflate_codes_statef *inflate_codes_new OF((
    uInt, uInt,
    inflate_huft *, inflate_huft *,
    z_streamp ));

extern int inflate_codes OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

extern void inflate_codes_free OF((
    inflate_codes_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\infcodes.c ===
/* infcodes.c -- process literals and length/distance pairs
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
      START,    /* x: set up for LEN */
      LEN,      /* i: get length/literal/eob next */
      LENEXT,   /* i: getting length extra (have base) */
      DIST,     /* i: get distance next */
      DISTEXT,  /* i: getting distance extra */
      COPY,     /* o: copying bytes in window, waiting for space */
      LIT,      /* o: got literal, waiting for output space */
      WASH,     /* o: got eob, possibly still output waiting */
      END,      /* x: got eob and all data flushed */
      BADCODE}  /* x: got error */
inflate_codes_mode;

/* inflate codes private state */
struct inflate_codes_state {

  /* mode */
  inflate_codes_mode mode;      /* current inflate_codes mode */

  /* mode dependent information */
  uInt len;
  union {
    struct {
      inflate_huft *tree;       /* pointer into tree */
      uInt need;                /* bits needed */
    } code;             /* if LEN or DIST, where in tree */
    uInt lit;           /* if LIT, literal */
    struct {
      uInt get;                 /* bits to get for extra */
      uInt dist;                /* distance back to copy from */
    } copy;             /* if EXT or COPY, where and how much */
  } sub;                /* submode */

  /* mode independent information */
  Byte lbits;           /* ltree bits decoded per branch */
  Byte dbits;           /* dtree bits decoder per branch */
  inflate_huft *ltree;          /* literal/length/eob tree */
  inflate_huft *dtree;          /* distance tree */

};


inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
uInt bl, bd;
inflate_huft *tl;
inflate_huft *td; /* need separate declaration for Borland C++ */
z_streamp z;
{
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
    c->lbits = (Byte)bl;
    c->dbits = (Byte)bd;
    c->ltree = tl;
    c->dtree = td;
    Tracev((stderr, "inflate:       codes new\n"));
  }
  return c;
}


int inflate_codes(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt j;               /* temporary storage */
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input and output based on current state */
  while (1) switch (c->mode)
  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    case START:         /* x: set up for LEN */
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
        UPDATE
        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
        LOAD
        if (r != Z_OK)
        {
          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
          break;
        }
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
      c->sub.code.tree = c->ltree;
      c->mode = LEN;
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e == 0)               /* literal */
      {
        c->sub.lit = t->base;
        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                 "inflate:         literal '%c'\n" :
                 "inflate:         literal 0x%02x\n", t->base));
        c->mode = LIT;
        break;
      }
      if (e & 16)               /* length */
      {
        c->sub.copy.get = e & 15;
        c->len = t->base;
        c->mode = LENEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      if (e & 32)               /* end of block */
      {
        Tracevv((stderr, "inflate:         end of block\n"));
        c->mode = WASH;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid literal/length code";
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
      c->sub.code.tree = c->dtree;
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e & 16)               /* distance */
      {
        c->sub.copy.get = e & 15;
        c->sub.copy.dist = t->base;
        c->mode = DISTEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid distance code";
      r = Z_DATA_ERROR;
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
    case COPY:          /* o: copying bytes in window, waiting for space */
      f = q - c->sub.copy.dist;
      while (f < s->window)             /* modulo window size-"while" instead */
        f += s->end - s->window;        /* of "if" handles invalid distances */
      while (c->len)
      {
        NEEDOUT
        OUTBYTE(*f++)
        if (f == s->end)
          f = s->window;
        c->len--;
      }
      c->mode = START;
      break;
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
      OUTBYTE(c->sub.lit)
      c->mode = START;
      break;
    case WASH:          /* o: got eob, possibly more output */
      if (k > 7)        /* return unused byte, if any */
      {
        Assert(k < 16, "inflate_codes grabbed too many bytes")
        k -= 8;
        n++;
        p--;            /* can always return one */
      }
      FLUSH
      if (s->read != s->write)
        LEAVE
      c->mode = END;
    case END:
      r = Z_STREAM_END;
      LEAVE
    case BADCODE:       /* x: got error */
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


void inflate_codes_free(c, z)
inflate_codes_statef *c;
z_streamp z;
{
  ZFREE(z, c);
  Tracev((stderr, "inflate:       codes free\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\inffast.c ===
/* inffast.c -- process literals and length/distance pairs fast
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* macros for bit input with no checking and for returning unused bytes */
#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}

/* Called with number of bytes left to write in window at least 258
   (the maximum string length) and number of input bytes available
   at least ten.  The ten bytes are six bytes for the longest length/
   distance pair plus four bytes for overloading the bit buffer. */

int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl;
inflate_huft *td; /* need separate declaration for Borland C++ */
inflate_blocks_statef *s;
z_streamp z;
{
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  uInt ml;              /* mask for literal/length tree */
  uInt md;              /* mask for distance tree */
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD

  /* initialize masks */
  ml = inflate_mask[bl];
  md = inflate_mask[bd];

  /* do until not enough input or output space for fast loop */
  do {                          /* assume called with m >= 258 && n >= 10 */
    /* get literal/length code */
    GRABBITS(20)                /* max bits for literal/length code */
    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
    {
      DUMPBITS(t->bits)
      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                "inflate:         * literal '%c'\n" :
                "inflate:         * literal 0x%02x\n", t->base));
      *q++ = (Byte)t->base;
      m--;
      continue;
    }
    do {
      DUMPBITS(t->bits)
      if (e & 16)
      {
        /* get extra bits for length */
        e &= 15;
        c = t->base + ((uInt)b & inflate_mask[e]);
        DUMPBITS(e)
        Tracevv((stderr, "inflate:         * length %u\n", c));

        /* decode distance base of block to copy */
        GRABBITS(15);           /* max bits for distance code */
        e = (t = td + ((uInt)b & md))->exop;
        do {
          DUMPBITS(t->bits)
          if (e & 16)
          {
            /* get extra bits to add to distance base */
            e &= 15;
            GRABBITS(e)         /* get extra bits (up to 13) */
            d = t->base + ((uInt)b & inflate_mask[e]);
            DUMPBITS(e)
            Tracevv((stderr, "inflate:         * distance %u\n", d));

            /* do the copy */
            m -= c;
            r = q - d;
            if (r < s->window)                  /* wrap if needed */
            {
              do {
                r += s->end - s->window;        /* force pointer in window */
              } while (r < s->window);          /* covers invalid distances */
              e = (uInt)(s->end - r);
              if (c > e)
              {
                c -= e;                         /* wrapped copy */
                do {
                    *q++ = *r++;
                } while (--e);
                r = s->window;
                do {
                    *q++ = *r++;
                } while (--c);
              }
              else                              /* normal copy */
              {
                *q++ = *r++;  c--;
                *q++ = *r++;  c--;
                do {
                    *q++ = *r++;
                } while (--c);
              }
            }
            else                                /* normal copy */
            {
              *q++ = *r++;  c--;
              *q++ = *r++;  c--;
              do {
                *q++ = *r++;
              } while (--c);
            }
            break;
          }
          else if ((e & 64) == 0)
          {
            t += t->base;
            e = (t += ((uInt)b & inflate_mask[e]))->exop;
          }
          else
          {
            z->msg = (char*)"invalid distance code";
            UNGRAB
            UPDATE
            return Z_DATA_ERROR;
          }
        } while (1);
        break;
      }
      if ((e & 64) == 0)
      {
        t += t->base;
        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
        {
          DUMPBITS(t->bits)
          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                    "inflate:         * literal '%c'\n" :
                    "inflate:         * literal 0x%02x\n", t->base));
          *q++ = (Byte)t->base;
          m--;
          break;
        }
      }
      else if (e & 32)
      {
        Tracevv((stderr, "inflate:         * end of block\n"));
        UNGRAB
        UPDATE
        return Z_STREAM_END;
      }
      else
      {
        z->msg = (char*)"invalid literal/length code";
        UNGRAB
        UPDATE
        return Z_DATA_ERROR;
      }
    } while (1);
  } while (m >= 258 && n >= 10);

  /* not enough input or output--restore pointers and return */
  UNGRAB
  UPDATE
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\inffixed.h ===
/* inffixed.h -- table for decoding fixed codes
 * Generated automatically by the maketree.c program
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

local uInt fixed_bl = 9;
local uInt fixed_bd = 5;
local inflate_huft fixed_tl[] = {
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
  };
local inflate_huft fixed_td[] = {
    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\infblock.h ===
/* infblock.h -- header to use infblock.c
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_blocks_state;
typedef struct inflate_blocks_state FAR inflate_blocks_statef;

extern inflate_blocks_statef * inflate_blocks_new OF((
    z_streamp z,
    check_func c,               /* check function */
    uInt w));                   /* window size */

extern int inflate_blocks OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));                      /* initial return code */

extern void inflate_blocks_reset OF((
    inflate_blocks_statef *,
    z_streamp ,
    uLongf *));                  /* check value on output */

extern int inflate_blocks_free OF((
    inflate_blocks_statef *,
    z_streamp));

extern void inflate_set_dictionary OF((
    inflate_blocks_statef *s,
    const Bytef *d,  /* dictionary */
    uInt  n));       /* dictionary length */

extern int inflate_blocks_sync_point OF((
    inflate_blocks_statef *s));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\inflate.c ===
/* inflate.c -- zlib interface to inflate modules
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"

struct inflate_blocks_state {int dummy;}; /* for buggy compilers */

typedef enum {
      METHOD,   /* waiting for method byte */
      FLAG,     /* waiting for flag byte */
      DICT4,    /* four dictionary check bytes to go */
      DICT3,    /* three dictionary check bytes to go */
      DICT2,    /* two dictionary check bytes to go */
      DICT1,    /* one dictionary check byte to go */
      DICT0,    /* waiting for inflateSetDictionary */
      BLOCKS,   /* decompressing blocks */
      CHECK4,   /* four check bytes to go */
      CHECK3,   /* three check bytes to go */
      CHECK2,   /* two check bytes to go */
      CHECK1,   /* one check byte to go */
      DONE,     /* finished check, done */
      BAD}      /* got an error--stay here */
inflate_mode;

/* inflate private state */
struct internal_state {

  /* mode */
  inflate_mode  mode;   /* current inflate mode */

  /* mode dependent information */
  union {
    uInt method;        /* if FLAGS, method byte */
    struct {
      uLong was;                /* computed check value */
      uLong need;               /* stream check value */
    } check;            /* if CHECK, check values to compare */
    uInt marker;        /* if BAD, inflateSync's marker bytes count */
  } sub;        /* submode */

  /* mode independent information */
  int  nowrap;          /* flag for no wrapper */
  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
  inflate_blocks_statef 
    *blocks;            /* current inflate_blocks state */

};


int ZEXPORT inflateReset(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
  z->msg = Z_NULL;
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
  Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}


int ZEXPORT inflateEnd(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
    inflate_blocks_free(z->state->blocks, z);
  ZFREE(z, z->state);
  z->state = Z_NULL;
  Tracev((stderr, "inflate: end\n"));
  return Z_OK;
}


int ZEXPORT inflateInit2_(z, w, version, stream_size)
z_streamp z;
int w;
const char *version;
int stream_size;
{
  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
      stream_size != sizeof(z_stream))
      return Z_VERSION_ERROR;

  /* initialize state */
  if (z == Z_NULL)
    return Z_STREAM_ERROR;
  z->msg = Z_NULL;
  if (z->zalloc == Z_NULL)
  {
    z->zalloc = zcalloc;
    z->opaque = (voidpf)0;
  }
  if (z->zfree == Z_NULL) z->zfree = zcfree;
  if ((z->state = (struct internal_state FAR *)
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
  z->state->blocks = Z_NULL;

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
  if (w < 0)
  {
    w = - w;
    z->state->nowrap = 1;
  }

  /* set window size */
  if (w < 8 || w > 15)
  {
    inflateEnd(z);
    return Z_STREAM_ERROR;
  }
  z->state->wbits = (uInt)w;

  /* create inflate_blocks state */
  if ((z->state->blocks =
      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
      == Z_NULL)
  {
    inflateEnd(z);
    return Z_MEM_ERROR;
  }
  Tracev((stderr, "inflate: allocated\n"));

  /* reset state */
  inflateReset(z);
  return Z_OK;
}


int ZEXPORT inflateInit_(z, version, stream_size)
z_streamp z;
const char *version;
int stream_size;
{
  return inflateInit2_(z, DEF_WBITS, version, stream_size);
}


#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int ZEXPORT inflate(z, f)
z_streamp z;
int f;
{
  int r;
  uInt b;

  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
    return Z_STREAM_ERROR;
  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
  {
    case METHOD:
      NEEDBYTE
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
      {
        z->state->mode = BAD;
        z->msg = (char*)"unknown compression method";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
      {
        z->state->mode = BAD;
        z->msg = (char*)"invalid window size";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
      b = NEXTBYTE;
      if (((z->state->sub.method << 8) + b) % 31)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect header check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib header ok\n"));
      if (!(b & PRESET_DICT))
      {
        z->state->mode = BLOCKS;
        break;
      }
      z->state->mode = DICT4;
    case DICT4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = DICT3;
    case DICT3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = DICT2;
    case DICT2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = DICT1;
    case DICT1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;
      z->adler = z->state->sub.check.need;
      z->state->mode = DICT0;
      return Z_NEED_DICT;
    case DICT0:
      z->state->mode = BAD;
      z->msg = (char*)"need dictionary";
      z->state->sub.marker = 0;       /* can try inflateSync */
      return Z_STREAM_ERROR;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (r == Z_DATA_ERROR)
      {
        z->state->mode = BAD;
        z->state->sub.marker = 0;       /* can try inflateSync */
        break;
      }
      if (r == Z_OK)
        r = f;
      if (r != Z_STREAM_END)
        return r;
      r = f;
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
      if (z->state->nowrap)
      {
        z->state->mode = DONE;
        break;
      }
      z->state->mode = CHECK4;
    case CHECK4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = CHECK3;
    case CHECK3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = CHECK2;
    case CHECK2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = CHECK1;
    case CHECK1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;

      if (z->state->sub.check.was != z->state->sub.check.need)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect data check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib check ok\n"));
      z->state->mode = DONE;
    case DONE:
      return Z_STREAM_END;
    case BAD:
      return Z_DATA_ERROR;
    default:
      return Z_STREAM_ERROR;
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


int ZEXPORT inflateSetDictionary(z, dictionary, dictLength)
z_streamp z;
const Bytef *dictionary;
uInt  dictLength;
{
  uInt length = dictLength;

  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
    return Z_STREAM_ERROR;

  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
  z->adler = 1L;

  if (length >= ((uInt)1<<z->state->wbits))
  {
    length = (1<<z->state->wbits)-1;
    dictionary += dictLength - length;
  }
  inflate_set_dictionary(z->state->blocks, dictionary, length);
  z->state->mode = BLOCKS;
  return Z_OK;
}


int ZEXPORT inflateSync(z)
z_streamp z;
{
  uInt n;       /* number of bytes to look at */
  Bytef *p;     /* pointer to bytes */
  uInt m;       /* number of marker bytes found in a row */
  uLong r, w;   /* temporaries to save total_in and total_out */

  /* set up */
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->mode != BAD)
  {
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
    return Z_BUF_ERROR;
  p = z->next_in;
  m = z->state->sub.marker;

  /* search */
  while (n && m < 4)
  {
    static const Byte mark[4] = {0, 0, 0xff, 0xff};
    if (*p == mark[m])
      m++;
    else if (*p)
      m = 0;
    else
      m = 4 - m;
    p++, n--;
  }

  /* restore */
  z->total_in += (uLong)(p - z->next_in);
  z->next_in = p;
  z->avail_in = n;
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
  inflateReset(z);
  z->total_in = r;  z->total_out = w;
  z->state->mode = BLOCKS;
  return Z_OK;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
 * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
 * but removes the length bytes of the resulting empty stored block. When
 * decompressing, PPP checks that at the end of input packet, inflate is
 * waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
    return Z_STREAM_ERROR;
  return inflate_blocks_sync_point(z->state->blocks);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\infutil.c ===
/* inflate_util.c -- data and routines common to blocks and codes
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* And'ing with mask[n] masks the lower n bits */
uInt inflate_mask[17] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};


/* copy as much as possible from the sliding window to the output area */
int inflate_flush(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt n;
  Bytef *p;
  Bytef *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(s->check, q, n);

  /* copy as far as end of window */
  zmemcpy(p, q, n);
  p += n;
  q += n;

  /* see if more to copy at beginning of window */
  if (q == s->end)
  {
    /* wrap pointers */
    q = s->window;
    if (s->write == s->end)
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
    z->total_out += n;

    /* update check information */
    if (s->checkfn != Z_NULL)
      z->adler = s->check = (*s->checkfn)(s->check, q, n);

    /* copy */
    zmemcpy(p, q, n);
    p += n;
    q += n;
  }

  /* update pointers */
  z->next_out = p;
  s->read = q;

  /* done */
  return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\inftrees.c ===
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"

#if !defined(BUILDFIXED) && !defined(STDC)
#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
#endif

const char inflate_copyright[] =
   " inflate 1.1.4 Copyright 1995-2002 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */
struct internal_state  {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits


local int huft_build OF((
    uIntf *,            /* code lengths in bits */
    uInt,               /* number of codes */
    uInt,               /* number of "simple" codes */
    const uIntf *,      /* list of base values for non-simple codes */
    const uIntf *,      /* list of extra bits for non-simple codes */
    inflate_huft * FAR*,/* result: starting table */
    uIntf *,            /* maximum lookup bits (returns actual) */
    inflate_huft *,     /* space for trees */
    uInt *,             /* hufts used in space */
    uIntf * ));         /* space for values */

/* Tables for deflate from PKZIP's appnote.txt. */
local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        /* see note #13 above about 258 */
local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
local const uInt cpdext[30] = { /* Extra bits for distance codes */
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};

/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
#define BMAX 15         /* maximum bit length of any code */

local int huft_build(b, n, s, d, e, t, m, hp, hn, v)
uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
uInt n;                 /* number of codes (assumed <= 288) */
uInt s;                 /* number of simple-valued codes (0..s-1) */
const uIntf *d;         /* list of base values for non-simple codes */
const uIntf *e;         /* list of extra bits for non-simple codes */
inflate_huft * FAR *t;  /* result: starting table */
uIntf *m;               /* maximum lookup bits, returns actual */
inflate_huft *hp;       /* space for trees */
uInt *hn;               /* hufts used in space */
uIntf *v;               /* working area: values in order of bit length */
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), or Z_DATA_ERROR if the input is invalid. */
{

  uInt a;                       /* counter for codes of length k */
  uInt c[BMAX+1];               /* bit length count table */
  uInt f;                       /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  register uInt i;              /* counter, current code */
  register uInt j;              /* counter */
  register int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
  register uIntf *p;            /* pointer into c[], b[], or v[] */
  inflate_huft *q;              /* points to current table */
  struct inflate_huft_s r;      /* table entry for structure assignment */
  inflate_huft *u[BMAX];        /* table stack */
  register int w;               /* bits before this table == (l * h) */
  uInt x[BMAX+1];               /* bit offsets, then code stack */
  uIntf *xp;                    /* pointer into x */
  int y;                        /* number of dummy codes added */
  uInt z;                       /* number of entries in current table */


  /* Generate counts for each bit length */
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (inflate_huft *)Z_NULL;
    *m = 0;
    return Z_OK;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((uInt)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((uInt)l > i)
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
    return Z_DATA_ERROR;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);
  n = x[g];                     /* set n to length of v */


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
        h++;
        w += l;                 /* previous table always l bits */

        /* compute minimum size table less than or equal to l bits */
        z = g - w;
        z = z > (uInt)l ? l : z;        /* table size upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          if (j < z)
            while (++j < z)     /* try smaller tables up to z bits */
            {
              if ((f <<= 1) <= *++xp)
                break;          /* enough codes to use up j bits */
              f -= *xp;         /* else deduct codes from patterns */
            }
        }
        z = 1 << j;             /* table entries for j-bit table */

        /* allocate new table */
        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
          return Z_DATA_ERROR;  /* overflow of MANY */
        u[h] = q = hp + *hn;
        *hn += z;

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.bits = (Byte)l;     /* bits to dump before this table */
          r.exop = (Byte)j;     /* bits in this table */
          j = i >> (w - l);
          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
          u[h-1][j] = r;        /* connect to last table */
        }
        else
          *t = q;               /* first table is returned result */
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
      if (p >= v + n)
        r.exop = 128 + 64;      /* out of values--invalid code */
      else if (*p < s)
      {
        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
        r.base = *p++;          /* simple code is just the value */
      }
      else
      {
        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
        r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
      while ((i & mask) != x[h])
      {
        h--;                    /* don't need to update q */
        w -= l;
        mask = (1 << w) - 1;
      }
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}


int inflate_trees_bits(c, bb, tb, hp, z)
uIntf *c;               /* 19 code lengths */
uIntf *bb;              /* bits tree desired/actual depth */
inflate_huft * FAR *tb; /* bits tree result */
inflate_huft *hp;       /* space for trees */
z_streamp z;            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;
  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
                 tb, bb, hp, &hn, v);
  if (r == Z_DATA_ERROR)
    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
  else if (r == Z_BUF_ERROR || *bb == 0)
  {
    z->msg = (char*)"incomplete dynamic bit lengths tree";
    r = Z_DATA_ERROR;
  }
  ZFREE(z, v);
  return r;
}


int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)
uInt nl;                /* number of literal/length codes */
uInt nd;                /* number of distance codes */
uIntf *c;               /* that many (total) code lengths */
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
inflate_huft *hp;       /* space for trees */
z_streamp z;            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  /* allocate work area */
  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;

  /* build literal/length tree */
  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
  if (r != Z_OK || *bl == 0)
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed literal/length tree";
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"incomplete literal/length tree";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
  }

  /* build distance tree */
  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
  if (r != Z_OK || (*bd == 0 && nl > 257))
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed distance tree";
    else if (r == Z_BUF_ERROR) {
#ifdef PKZIP_BUG_WORKAROUND
      r = Z_OK;
    }
#else
      z->msg = (char*)"incomplete distance tree";
      r = Z_DATA_ERROR;
    }
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"empty distance tree with lengths";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
#endif
  }

  /* done */
  ZFREE(z, v);
  return Z_OK;
}


/* build fixed tables only once--keep them here */
#ifdef BUILDFIXED
local int fixed_built = 0;
#define FIXEDH 544      /* number of hufts used by fixed tables */
local inflate_huft fixed_mem[FIXEDH];
local uInt fixed_bl;
local uInt fixed_bd;
local inflate_huft *fixed_tl;
local inflate_huft *fixed_td;
#else
#include "inffixed.h"
#endif


int inflate_trees_fixed(bl, bd, tl, td, z)
uIntf *bl;               /* literal desired/actual bit depth */
uIntf *bd;               /* distance desired/actual bit depth */
inflate_huft * FAR *tl;  /* literal/length tree result */
inflate_huft * FAR *td;  /* distance tree result */
z_streamp z;             /* for memory allocation */
{
#ifdef BUILDFIXED
  /* build fixed tables if not already */
  if (!fixed_built)
  {
    int k;              /* temporary variable */
    uInt f = 0;         /* number of hufts used in fixed_mem */
    uIntf *c;           /* length list for huft_build */
    uIntf *v;           /* work area for huft_build */

    /* allocate memory */
    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
      return Z_MEM_ERROR;
    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    {
      ZFREE(z, c);
      return Z_MEM_ERROR;
    }

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
      c[k] = 7;
    for (; k < 288; k++)
      c[k] = 8;
    fixed_bl = 9;
    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
               fixed_mem, &f, v);

    /* distance table */
    for (k = 0; k < 30; k++)
      c[k] = 5;
    fixed_bd = 5;
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
               fixed_mem, &f, v);

    /* done */
    ZFREE(z, v);
    ZFREE(z, c);
    fixed_built = 1;
  }
#endif
  *bl = fixed_bl;
  *bd = fixed_bd;
  *tl = fixed_tl;
  *td = fixed_td;
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\infutil.h ===
/* infutil.h -- types and macros common to blocks and codes
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

#ifndef _INFUTIL_H
#define _INFUTIL_H

typedef enum {
      TYPE,     /* get type bits (3, including end bit) */
      LENS,     /* get lengths for stored */
      STORED,   /* processing stored block */
      TABLE,    /* get table lengths */
      BTREE,    /* get bit lengths tree for a dynamic block */
      DTREE,    /* get length, distance trees for a dynamic block */
      CODES,    /* processing fixed or dynamic block */
      DRY,      /* output remaining window bytes */
      DONE,     /* finished last block, done */
      BAD}      /* got a data error--stuck here */
inflate_block_mode;

/* inflate blocks semi-private state */
struct inflate_blocks_state {

  /* mode */
  inflate_block_mode  mode;     /* current inflate_block mode */

  /* mode dependent information */
  union {
    uInt left;          /* if STORED, bytes left to copy */
    struct {
      uInt table;               /* table lengths (14 bits) */
      uInt index;               /* index into blens (or border) */
      uIntf *blens;             /* bit lengths of codes */
      uInt bb;                  /* bit length tree depth */
      inflate_huft *tb;         /* bit length decoding tree */
    } trees;            /* if DTREE, decoding info for trees */
    struct {
      inflate_codes_statef 
         *codes;
    } decode;           /* if CODES, current state */
  } sub;                /* submode */
  uInt last;            /* true if this block is the last block */

  /* mode independent information */
  uInt bitk;            /* bits in bit buffer */
  uLong bitb;           /* bit buffer */
  inflate_huft *hufts;  /* single malloc for tree space */
  Bytef *window;        /* sliding window */
  Bytef *end;           /* one byte after sliding window */
  Bytef *read;          /* window read pointer */
  Bytef *write;         /* window write pointer */
  check_func checkfn;   /* check function */
  uLong check;          /* check on output */

};


/* defines for inflate input/output */
/*   update pointers and return */
#define UPDBITS {s->bitb=b;s->bitk=k;}
#define UPDIN {z->avail_in=n;z->total_in+=(uLong)(p-z->next_in);z->next_in=p;}
#define UPDOUT {s->write=q;}
#define UPDATE {UPDBITS UPDIN UPDOUT}
#define LEAVE {UPDATE return inflate_flush(s,z,r);}
/*   get bytes and bits */
#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
#define NEXTBYTE (n--,*p++)
#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define DUMPBITS(j) {b>>=(j);k-=(j);}
/*   output bytes */
#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
/*   load local pointers */
#define LOAD {LOADIN LOADOUT}

/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
extern uInt inflate_mask[17];

/* copy as much as possible from the sliding window to the output area */
extern int inflate_flush OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

struct internal_state      {int dummy;}; /* for buggy compilers */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\inftrees.h ===
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model). */

typedef struct inflate_huft_s FAR inflate_huft;

struct inflate_huft_s {
  union {
    struct {
      Byte Exop;        /* number of extra bits or operation */
      Byte Bits;        /* number of bits in this code or subcode */
    } what;
    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
  uInt base;            /* literal, length base, distance base,
                           or table offset */
};

/* Maximum size of dynamic tree.  The maximum found in a long but non-
   exhaustive search was 1004 huft structures (850 for length/literals
   and 154 for distances, the latter actually the result of an
   exhaustive search).  The actual maximum is not known, but the
   value below is more than safe. */
#define MANY 1440

extern int inflate_trees_bits OF((
    uIntf *,                    /* 19 code lengths */
    uIntf *,                    /* bits tree desired/actual depth */
    inflate_huft * FAR *,       /* bits tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_dynamic OF((
    uInt,                       /* number of literal/length codes */
    uInt,                       /* number of distance codes */
    uIntf *,                    /* that many (total) code lengths */
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_fixed OF((
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    z_streamp));                /* for memory allocation */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\maketree.c ===
/* maketree.c -- make inffixed.h table for decoding fixed codes
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* This program is included in the distribution for completeness.
   You do not need to compile or run this program since inffixed.h
   is already included in the distribution.  To use this program
   you need to compile zlib with BUILDFIXED defined and then compile
   and link this program with the zlib library.  Then the output of
   this program can be piped to inffixed.h. */

#include <stdio.h>
#include <stdlib.h>
#include "zutil.h"
#include "inftrees.h"

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* generate initialization table for an inflate_huft structure array */
void maketree(uInt b, inflate_huft *t)
{
  int i, e;

  i = 0;
  while (1)
  {
    e = t[i].exop;
    if (e && (e & (16+64)) == 0)        /* table pointer */
    {
      fprintf(stderr, "maketree: cannot initialize sub-tables!\n");
      exit(1);
    }
    if (i % 4 == 0)
      printf("\n   ");
    printf(" {{{%u,%u}},%u}", t[i].exop, t[i].bits, t[i].base);
    if (++i == (1<<b))
      break;
    putchar(',');
  }
  puts("");
}

/* create the fixed tables in C initialization syntax */
void main(void)
{
  int r;
  uInt bl, bd;
  inflate_huft *tl, *td;
  z_stream z;

  z.zalloc = zcalloc;
  z.opaque = (voidpf)0;
  z.zfree = zcfree;
  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);
  if (r)
  {
    fprintf(stderr, "inflate_trees_fixed error %d\n", r);
    return;
  }
  puts("/* inffixed.h -- table for decoding fixed codes");
  puts(" * Generated automatically by the maketree.c program");
  puts(" */");
  puts("");
  puts("/* WARNING: this file should *not* be used by applications. It is");
  puts("   part of the implementation of the compression library and is");
  puts("   subject to change. Applications should only use zlib.h.");
  puts(" */");
  puts("");
  printf("local uInt fixed_bl = %d;\n", bl);
  printf("local uInt fixed_bd = %d;\n", bd);
  printf("local inflate_huft fixed_tl[] = {");
  maketree(bl, tl);
  puts("  };");
  printf("local inflate_huft fixed_td[] = {");
  maketree(bd, td);
  puts("  };");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\minigzip.c ===
/* minigzip.c -- simulate gzip using the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 * minigzip is a minimal implementation of the gzip utility. This is
 * only an example of using zlib and isn't meant to replace the
 * full-featured gzip. No attempt is made to deal with file systems
 * limiting names to 14 or 8+3 characters, etc... Error checking is
 * very limited. So use minigzip only for testing; use gzip for the
 * real thing. On MSDOS, use only on file names without extension
 * or in pipe mode.
 */

/* @(#) $Id$ */

#include <stdio.h>
#include "zlib.h"

#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#else
   extern void exit  OF((int));
#endif

#ifdef USE_MMAP
#  include <sys/types.h>
#  include <sys/mman.h>
#  include <sys/stat.h>
#endif

#if defined(MSDOS) || defined(OS2) || defined(WIN32)
#  include <fcntl.h>
#  include <io.h>
#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
#else
#  define SET_BINARY_MODE(file)
#endif

#ifdef VMS
#  define unlink delete
#  define GZ_SUFFIX "-gz"
#endif
#ifdef RISCOS
#  define unlink remove
#  define GZ_SUFFIX "-gz"
#  define fileno(file) file->__file
#endif
#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#  include <unix.h> /* for fileno */
#endif

#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
  extern int unlink OF((const char *));
#endif

#ifndef GZ_SUFFIX
#  define GZ_SUFFIX ".gz"
#endif
#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)

#define BUFLEN      16384
#define MAX_NAME_LEN 1024

#ifdef MAXSEG_64K
#  define local static
   /* Needed for systems with limitation on stack size. */
#else
#  define local
#endif

char *prog;

void error            OF((const char *msg));
void gz_compress      OF((FILE   *in, gzFile out));
#ifdef USE_MMAP
int  gz_compress_mmap OF((FILE   *in, gzFile out));
#endif
void gz_uncompress    OF((gzFile in, FILE   *out));
void file_compress    OF((char  *file, char *mode));
void file_uncompress  OF((char  *file));
int  main             OF((int argc, char *argv[]));

/* ===========================================================================
 * Display error message and exit
 */
void error(msg)
    const char *msg;
{
    fprintf(stderr, "%s: %s\n", prog, msg);
    exit(1);
}

/* ===========================================================================
 * Compress input to output then close both files.
 */

void gz_compress(in, out)
    FILE   *in;
    gzFile out;
{
    local char buf[BUFLEN];
    int len;
    int err;

#ifdef USE_MMAP
    /* Try first compressing with mmap. If mmap fails (minigzip used in a
     * pipe), use the normal fread loop.
     */
    if (gz_compress_mmap(in, out) == Z_OK) return;
#endif
    for (;;) {
        len = fread(buf, 1, sizeof(buf), in);
        if (ferror(in)) {
            perror("fread");
            exit(1);
        }
        if (len == 0) break;

        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
    }
    fclose(in);
    if (gzclose(out) != Z_OK) error("failed gzclose");
}

#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */

/* Try compressing the input file at once using mmap. Return Z_OK if
 * if success, Z_ERRNO otherwise.
 */
int gz_compress_mmap(in, out)
    FILE   *in;
    gzFile out;
{
    int len;
    int err;
    int ifd = fileno(in);
    caddr_t buf;    /* mmap'ed buffer for the entire input file */
    off_t buf_len;  /* length of the input file */
    struct stat sb;

    /* Determine the size of the file, needed for mmap: */
    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
    buf_len = sb.st_size;
    if (buf_len <= 0) return Z_ERRNO;

    /* Now do the actual mmap: */
    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0); 
    if (buf == (caddr_t)(-1)) return Z_ERRNO;

    /* Compress the whole file at once: */
    len = gzwrite(out, (char *)buf, (unsigned)buf_len);

    if (len != (int)buf_len) error(gzerror(out, &err));

    munmap(buf, buf_len);
    fclose(in);
    if (gzclose(out) != Z_OK) error("failed gzclose");
    return Z_OK;
}
#endif /* USE_MMAP */

/* ===========================================================================
 * Uncompress input to output then close both files.
 */
void gz_uncompress(in, out)
    gzFile in;
    FILE   *out;
{
    local char buf[BUFLEN];
    int len;
    int err;

    for (;;) {
        len = gzread(in, buf, sizeof(buf));
        if (len < 0) error (gzerror(in, &err));
        if (len == 0) break;

        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
	    error("failed fwrite");
	}
    }
    if (fclose(out)) error("failed fclose");

    if (gzclose(in) != Z_OK) error("failed gzclose");
}


/* ===========================================================================
 * Compress the given file: create a corresponding .gz file and remove the
 * original.
 */
void file_compress(file, mode)
    char  *file;
    char  *mode;
{
    local char outfile[MAX_NAME_LEN];
    FILE  *in;
    gzFile out;

    strcpy(outfile, file);
    strcat(outfile, GZ_SUFFIX);

    in = fopen(file, "rb");
    if (in == NULL) {
        perror(file);
        exit(1);
    }
    out = gzopen(outfile, mode);
    if (out == NULL) {
        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
        exit(1);
    }
    gz_compress(in, out);

    unlink(file);
}


/* ===========================================================================
 * Uncompress the given file and remove the original.
 */
void file_uncompress(file)
    char  *file;
{
    local char buf[MAX_NAME_LEN];
    char *infile, *outfile;
    FILE  *out;
    gzFile in;
    int len = strlen(file);

    strcpy(buf, file);

    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
        infile = file;
        outfile = buf;
        outfile[len-3] = '\0';
    } else {
        outfile = file;
        infile = buf;
        strcat(infile, GZ_SUFFIX);
    }
    in = gzopen(infile, "rb");
    if (in == NULL) {
        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
        exit(1);
    }
    out = fopen(outfile, "wb");
    if (out == NULL) {
        perror(file);
        exit(1);
    }

    gz_uncompress(in, out);

    unlink(infile);
}


/* ===========================================================================
 * Usage:  minigzip [-d] [-f] [-h] [-1 to -9] [files...]
 *   -d : decompress
 *   -f : compress with Z_FILTERED
 *   -h : compress with Z_HUFFMAN_ONLY
 *   -1 to -9 : compression level
 */

int main(argc, argv)
    int argc;
    char *argv[];
{
    int uncompr = 0;
    gzFile file;
    char outmode[20];

    strcpy(outmode, "wb6 ");

    prog = argv[0];
    argc--, argv++;

    while (argc > 0) {
      if (strcmp(*argv, "-d") == 0)
	uncompr = 1;
      else if (strcmp(*argv, "-f") == 0)
	outmode[3] = 'f';
      else if (strcmp(*argv, "-h") == 0)
	outmode[3] = 'h';
      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
	       (*argv)[2] == 0)
	outmode[2] = (*argv)[1];
      else
	break;
      argc--, argv++;
    }
    if (argc == 0) {
        SET_BINARY_MODE(stdin);
        SET_BINARY_MODE(stdout);
        if (uncompr) {
            file = gzdopen(fileno(stdin), "rb");
            if (file == NULL) error("can't gzdopen stdin");
            gz_uncompress(file, stdout);
        } else {
            file = gzdopen(fileno(stdout), outmode);
            if (file == NULL) error("can't gzdopen stdout");
            gz_compress(stdin, file);
        }
    } else {
        do {
            if (uncompr) {
                file_uncompress(*argv);
            } else {
                file_compress(*argv, outmode);
            }
        } while (argv++, --argc);
    }
    exit(0);
    return 0; /* to avoid warning */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\trees.c ===
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2002 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */

#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local const uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

#define Buf_size (8 * 2*sizeof(char))
/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uch _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uch _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
#  include "trees.h"
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const intf *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, ct_data *ltree,
                              ct_data *dtree));
local void set_data_type  OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifdef GEN_TREES_H
local void gen_trees_header OF((void));
#endif

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(s, value, length)
    deflate_state *s;
    int value;  /* value to send */
    int length; /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (value << s->bi_valid);
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (val << s->bi_valid);\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


#define MAX(a,b) (a >= b ? a : b)
/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
local void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef DEBUG
#    include <stdio.h>
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
	    "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
	fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
		static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
	fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
		static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
	fprintf(header, "%2u%s", _dist_code[i],
		SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
	fprintf(header, "%2u%s", _length_code[i],
		SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
	fprintf(header, "%1u%s", base_length[i],
		SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "local const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
	fprintf(header, "%5u%s", base_dist[i],
		SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void _tr_init(s)
    deflate_state *s;
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
    s->last_eob_len = 8; /* enough lookahead for inflate */
#ifdef DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(s)
    deflate_state *s;
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(s, tree, k)
    deflate_state *s;
    ct_data *tree;  /* the tree to restore */
    int k;               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(s, desc)
    deflate_state *s;
    tree_desc *desc;    /* the tree descriptor */
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if (tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (tree, max_code, bl_count)
    ct_data *tree;             /* the tree to decorate */
    int max_code;              /* largest code with non zero frequency */
    ushf *bl_count;            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc; /* the tree descriptor */
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree;   /* the tree to be scanned */
    int max_code;    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += (ush) count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree; /* the tree to be scanned */
    int max_code;       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(s)
    deflate_state *s;
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(s, lcodes, dcodes, blcodes)
    deflate_state *s;
    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void _tr_stored_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
#ifdef DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;
#endif
    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */
void _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
    /* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */
    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
        s->compressed_len += 10L;
#endif
        bi_flush(s);
    }
    s->last_eob_len = 7;
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
void _tr_flush_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block, or NULL if too old */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

	 /* Check if the file is ascii or binary */
	if (s->data_type == Z_UNKNOWN) set_data_type(s);

	/* Construct the literal and distance trees */
	build_tree(s, (tree_desc *)(&(s->l_desc)));
	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));

	build_tree(s, (tree_desc *)(&(s->d_desc)));
	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));
	/* At this point, opt_len and static_len are the total bit lengths of
	 * the compressed block data, excluding the tree representations.
	 */

	/* Build the bit length tree for the above two trees, and get the index
	 * in bl_order of the last bit length code to send.
	 */
	max_blindex = build_bl_tree(s);

	/* Determine the best encoding. Compute first the block length in bytes*/
	opt_lenb = (s->opt_len+3+7)>>3;
	static_lenb = (s->static_len+3+7)>>3;

	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
		s->last_lit));

	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, eof);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+eof, 3);
        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+eof, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (eof) {
        bi_windup(s);
#ifdef DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*eof));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int _tr_tally (s, dist, lc)
    deflate_state *s;
    unsigned dist;  /* distance of matched string */
    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(s, ltree, dtree)
    deflate_state *s;
    ct_data *ltree; /* literal tree */
    ct_data *dtree; /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
    s->last_eob_len = ltree[END_BLOCK].Len;
}

/* ===========================================================================
 * Set the data type to ASCII or BINARY, using a crude approximation:
 * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
 * IN assertion: the fields freq of dyn_ltree are set and the total of all
 * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
 */
local void set_data_type(s)
    deflate_state *s;
{
    int n = 0;
    unsigned ascii_freq = 0;
    unsigned bin_freq = 0;
    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(code, len)
    unsigned code; /* the value to invert */
    int len;       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(s)
    deflate_state *s;
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(s)
    deflate_state *s;
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block(s, buf, len, header)
    deflate_state *s;
    charf    *buf;    /* the input data */
    unsigned len;     /* its length */
    int      header;  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */
    s->last_eob_len = 8; /* enough lookahead for inflate */

    if (header) {
        put_short(s, (ush)len);   
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\uncompr.c ===
/* uncompr.c -- decompress a memory buffer
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/
int ZEXPORT uncompress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = inflateEnd(&stream);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#  