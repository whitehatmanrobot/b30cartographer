    _cbClientRequest    = 0;

    if (fResetPipelineInfo)
    {
        _cbOldData      = 0;
    }
    else if (_cbOldData > 0)
    {
        _cbOldData     -= _cbBytesReceived;
    }

    _cbExtraData        = 0;
    _pchExtraData       = NULL;
    _liModifiedSince.QuadPart = 0;
    _liUnlessModifiedSince.QuadPart = 0;
    _liUnmodifiedSince.QuadPart = 0;
    _dwModifiedSinceLength = 0;

    _status         = NO_ERROR;
    _cbBytesWritten = 0;

    _HeaderList.Reset();

    _Filter.Reset();

    //
    //  Reset our statistics for this request
    //

    _cbTotalBytesSent     += _cbBytesSent;
    _cbTotalBytesReceived += _cbBytesReceived;
    _cbBytesSent          = 0;
    _cbBytesReceived      = 0;

    _fAsyncSendPosted     = FALSE;

    //
    //  Don't log this request unless we're explicity indicated a status
    //

    _dwLogHttpResponse    = HT_DONT_LOG;
    _dwLogWinError        = NO_ERROR;

    _strURL.Reset();
    _strURLPathInfo.Reset();
    _strURLParams.Reset();
    _strLogParams.Reset();
    _strPathInfo.Reset();
    _strRawURL.Reset();
    _strOriginalURL.Reset();
    _strMethod.Reset();
    _strAuthInfo.Reset();
    _strPhysicalPath.Reset();
    _strUnmappedPhysicalPath.Reset();

    _strDenialHdrs.Reset();
    _strRespHdrs.Reset();
    _strRange.Reset();

    _bProcessingCustomError = FALSE;
    _bForceNoCache = FALSE;
    _bSendContentLocation = FALSE;
    _bSendVary = FALSE;

    ClearNoCache();
    ClearSendCL();
    ClearSendVary();

    _fAuthenticationRequested = FALSE;
    _fProxyRequest            = FALSE;
    _fBasicRealm              = FALSE;
    _fIfModifier              = FALSE;
    _fHaveContentLength       = FALSE;
    _fLogRecordWritten        = FALSE;
    _dwExpireInDay            = 0x7fffffff;

    if ( _fSingleRequestAuth )
    {
        LPW3_SERVER_STATISTICS pStatsObj = QueryW3StatsObj();
        pStatsObj->DecrCurrentNonAnonymousUsers();

        ResetAuth( FALSE );
        _fSingleRequestAuth = FALSE;
    }

    //  Accept range variables

    _fProcessByteRange = FALSE;
    _fUnsatisfiableByteRange = FALSE;
    _fAcceptRange      = FALSE;
    _iRangeIdx         = 0;
    _cbMimeMultipart   = 0;
    _fMimeMultipart    = FALSE;

    _acIpAccess = AC_NOT_CHECKED;
    _fNeedDnsCheck = FALSE;

    _fChunked           = FALSE;
#if 0    // Not used anywhere /SAB
    _fIsWrite           = FALSE;
#endif
    _fDiscNoError       = FALSE;
    _fNoDisconnectOnError = FALSE;

    SetState( HTR_READING_CLIENT_REQUEST );


    return TRUE;
}

VOID
HTTP_REQ_BASE::SessionTerminated(
    VOID
    )
/*++

Routine Description:

    This method updates the statistics when the TCP session is closed just
    before this object gets destructed (or placed on the free list).

Arguments:

--*/
{
    //
    //  Notify filters
    //

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_END_OF_NET_SESSION,
                                       IsSecurePort() ))
    {
        _Filter.NotifyEndOfNetSession();
    }

    LPW3_SERVER_STATISTICS pStatsObj = QueryW3StatsObj();
    W3_STATISTICS_1 * pW3Stats = pStatsObj->QueryStatsObj();


    //
    //  Update the statistics
    //

    if ( _fLoggedOn )
    {
        if ( _fAnonymous ) {
            pStatsObj->DecrCurrentAnonymousUsers();
        }
        else {
            pStatsObj->DecrCurrentNonAnonymousUsers();
        }
    }

    pStatsObj->LockStatistics();

    pW3Stats->TotalBytesSent.QuadPart     += _cbTotalBytesSent + _cbBytesSent;
    pW3Stats->TotalBytesReceived.QuadPart += _cbTotalBytesReceived + _cbBytesReceived;
    pW3Stats->TotalFilesSent              += _cFilesSent;
    pW3Stats->TotalFilesReceived          += _cFilesReceived;

    pStatsObj->UnlockStatistics();


    TCP_REQUIRE( _tcpauth.Reset() );

#if defined(CAL_ENABLED)
    if ( m_pCalSslCtxt )
    {
        CalDisconnect( m_pCalSslCtxt );
        m_pCalSslCtxt = NULL;
    }

    if ( m_pCalAuthCtxt )
    {
        CalDisconnect( m_pCalAuthCtxt );
        m_pCalAuthCtxt = NULL;
    }
#endif

    //
    // Cleanup the filter
    //

    _Filter.Cleanup( );

    //
    //  Make sure our input buffer doesn't grow too large.  For example if
    //  somebody just sent 500k of entity data, we want to release the memory
    //  that was used to store that.
    //

    if ( _bufClientRequest.QuerySize() > MAX_CLIENT_SIZE_ALLOWED )
    {
        _bufClientRequest.FreeMemory();
    }
}

BOOL
HTTP_REQ_BASE::OnIfModifiedSince(
    CHAR * pszValue
    )
/*++

Routine Description:

    Extracts the modified date for later use

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{

    if ( StringTimeToFileTime( pszValue,
                               &_liModifiedSince ))
    {
        CHAR        *pszLength;

        _fIfModifier = TRUE;

        pszLength = strchr(pszValue, ';');

        if (pszLength != NULL)
        {
            pszLength++;

            while (isspace((UCHAR)(*pszLength)))
            {
                pszLength++;
            }

            if (!_strnicmp(pszLength, "length", sizeof("length") - 1))
            {
                pszLength += sizeof("length") - 1;

                while (isspace((UCHAR)(*pszLength)))
                {
                    pszLength++;
                }

                if (*pszLength == '=')
                {
                    pszLength++;

                    while (isspace((UCHAR)(*pszLength)))
                    {
                        pszLength++;
                    }

                    _dwModifiedSinceLength = atoi(pszLength);
                }
            }
        }
        return TRUE;
    }

    //
    //  If we couldn't parse the time, then just ignore this field all
    //  together
    //

    DBGPRINTF(( DBG_CONTEXT,
               "[OnIfModifiedSince] Error %d parsing If-Modified-Since time, ignoring field\n",
                GetLastError() ));

    _liModifiedSince.QuadPart = 0;
    _dwModifiedSinceLength = 0;

    return TRUE;
}

BOOL
HTTP_REQ_BASE::OnIfUnmodifiedSince(
    CHAR * pszValue
    )
/*++

Routine Description:

    Extracts the unmodified date for later use

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    if ( StringTimeToFileTime( pszValue,
                               &_liUnmodifiedSince ))
    {
        _fIfModifier = TRUE;
        return TRUE;
    }

    //
    //  If we couldn't parse the time, then just ignore this field all
    //  together
    //

    DBGPRINTF(( DBG_CONTEXT,
               "[OnIfUnmodifiedSince] Error %d parsing If-Modified-Since time, ignoring field\n",
                GetLastError() ));

    _liUnmodifiedSince.QuadPart = 0;

    return TRUE;
}

BOOL
HTTP_REQ_BASE::OnUnlessModifiedSince(
    CHAR * pszValue
    )
/*++

Routine Description:

    Extracts the modified date for later use

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    BOOL fRet;

    if ( StringTimeToFileTime( pszValue,
                               &_liUnlessModifiedSince ))
    {
        return TRUE;
    }

    //
    //  If we couldn't parse the time, then just ignore this field all
    //  together
    //

    DBGPRINTF(( DBG_CONTEXT,
               "[OnIfUnmodifiedSince] Error %d parsing If-Unmodified-Since time, ignoring field\n",
                GetLastError() ));

    _liUnlessModifiedSince.QuadPart = 0;

    return TRUE;
}

BOOL
HTTP_REQ_BASE::OnIfMatch(
    CHAR * pszValue
    )
/*++

Routine Description:

    Handle the If-Match header.

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    _fIfModifier = TRUE;
    return TRUE;
}

BOOL
HTTP_REQ_BASE::OnIfNoneMatch(
    CHAR * pszValue
    )
/*++

Routine Description:

    Handle the If-None-Match header.

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    _fIfModifier = TRUE;
    return TRUE;
}

BOOL
HTTP_REQ_BASE::OnIfRange(
    CHAR * pszValue
    )
/*++

Routine Description:

    Handle the If-Range header.

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    _fIfModifier = TRUE;
    return TRUE;
}

/*******************************************************************

    NAME:       HTTP_REQ_BASE::OnContentLength

    SYNOPSIS:   Pulls out the number of bytes we expect the client to give us

    ENTRY:      pszValue - Pointer to a zero terminated string

    RETURNS:    TRUE if successful, FALSE if the field wasn't found

    HISTORY:
        Johnl       21-Sep-1994 Created

********************************************************************/

BOOL HTTP_REQ_BASE::OnContentLength( CHAR * pszValue )
{
    CHAR        *pszEnd;

    if (!IsChunked())
    {

        // + and - aren't valid as part of a content length.
        if (*pszValue == '-' || *pszValue == '+')
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        errno = 0; // WinSE 16859

        _cbContentLength = strtoul( pszValue, &pszEnd, 10 );

        if (_cbContentLength == ULONG_MAX)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (_cbContentLength == 0 || _cbContentLength == ULONG_MAX)
        {
            // Might possibly have underflow or overflow.

            if (errno == ERANGE || pszEnd == pszValue)
            {
                // Either had an overflow/underflow or no conversion.

                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
        }

        // See what terminated the scan.

        if (*pszEnd != '\0' && !isspace((UCHAR)(*pszEnd)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        _fHaveContentLength = TRUE;
    }

    return TRUE;
}


BOOL
HTTP_REQ_BASE::OnHost (
    CHAR * pszValue
    )
/*++

Routine Description:

        Processes the HTTP "Host: domain name" field

Return Value:

    TRUE if successful, FALSE on error

--*/
{

    if ( !_strHostAddr.Copy( (TCHAR *) pszValue ) )
    {
        return FALSE;
    }

    //
    // remove erroneous port info if present
    // NYI: It will be very useful to get the length information
    //

    PSTR pP = (PSTR) memchr( _strHostAddr.QueryStr(), ':',
                             _strHostAddr.QueryCB() );
    if ( pP != NULL )
    {
        *pP = '\0';
        _strHostAddr.SetLen( DIFF(pP - _strHostAddr.QueryStr()) );
    }


    return TRUE;
}

BOOL
HTTP_REQ_BASE::OnRange (
    CHAR * pszValue
    )
/*++

Routine Description:

        Processes the HTTP "Range" field

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    while ( *pszValue && isspace((UCHAR)(*pszValue)) )
        ++pszValue;

    if ( !_strnicmp( pszValue, "bytes", sizeof("bytes")-1 ) )
    {
        pszValue += sizeof("bytes")-1;
        while ( *pszValue && *pszValue++ != '=' )
            ;
        while ( *pszValue && isspace((UCHAR)(*pszValue)) )
            ++pszValue;
        if ( !_strRange.Copy( (TCHAR *) pszValue ) )
            return FALSE;
    }

    return TRUE;
}


CHAR *
HTTP_REQ_BASE::QueryHostAddr (
    VOID
    )
/*++

Routine Description:

        Returns the local domain name if specified in the request
        or else the local network address

Return Value:

    ASCII representation of the local address

--*/
{
    if ( QueryW3Instance() == NULL )
    {
        return _pClientConn->QueryLocalAddr();
    }

    if ( IsProxyRequest() )
    {
        return ( QueryW3Instance()->QueryDefaultHostName() != NULL ?
                 QueryW3Instance()->QueryDefaultHostName() : 
                 QueryClientConn()->QueryLocalAddr() );
    }
    else
    {
        return 
            (CHAR *) (_strHostAddr.IsEmpty()
                      ? ( (QueryW3Instance()->QueryDefaultHostName() != NULL)
                    ? QueryW3Instance()->QueryDefaultHostName() : _pClientConn->QueryLocalAddr() )
                    : _strHostAddr.QueryStr());
    }
}
 

#if 0

Authorization info now processed after processing is complete

BOOL
HTTP_REQ_BASE::OnAuthorization(
    CHAR * pszValue
    )
/*++

Routine Description:

    Processes the HTTP "Authorization: <type> <authdata>" field

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return TRUE;
}
#endif

BOOL
HTTP_REQ_BASE::ProcessAuthorization(
    CHAR * pszValue
    )
/*++

Routine Description:

    Processes the HTTP "Authorization: <type> <authdata>" field
    at logo time

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    //
    //  If a filter has indicated this is a proxy request, use the
    //  authorization information
    //

    if ( !IsProxyRequest() )
    {
        return ParseAuthorization( pszValue );
    }

    return TRUE;
}


BOOL
HTTP_REQ_BASE::ParseAuthorization (
    CHAR * pszValue
    )
/*++

Routine Description:

    Processes the HTTP "Authorization: <type> <authdata>" field
        or "Proxy-Authorization: <type> <authdata>" field

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *          pchBlob;
    CHAR *          pchSpace = NULL;
    DWORD           dwAuthFlags = QueryAuthentication();

    //
    //  If we've already logged this user and they're specifying authentication
    //  headers, back out the old authentication information and
    //  re-authenticate.
    //

    if ( IsLoggedOn() )
    {
        if ( !QueryW3Instance()->ProcessNtcrIfLoggedOn() )
        {
            //
            //  Ignore the the authorization information if we're logged on with
            //  an NT provider.  Otherwise we authenticate every request with a
            //  full challenge response
            //

            if ( !_fClearTextPass && !_fAnonymous )
            {
                goto NotFound;
            }
        }

        if ( _fAnonymous )
        {
            QueryW3StatsObj()->DecrCurrentAnonymousUsers();
        }
        else
        {
            QueryW3StatsObj()->DecrCurrentNonAnonymousUsers();
        }

        ResetAuth( FALSE );
    }

    //
    //  If only anonymous is checked, ignore all authentication information
    //  (i.e., force all users to the anonymous user).
    //

    if ( !(dwAuthFlags & (~INET_INFO_AUTH_ANONYMOUS) ))
    {
        goto NotFound;
    }

    //
    //  Now break out the authorization type and see if it's an
    //  authorization type we understand
    //

    pchSpace = pchBlob = strchr( pszValue, ' ' );

    if ( pchBlob )
    {
        *pchBlob = '\0';
        pchBlob++;
    }
    else
    {
        pchBlob = "";
    }

    if ( !_strAuthType.Copy( pszValue ) )
    {
        return FALSE;
    }

    //
    //  This processes "user name:password"
    //

    if ( !_stricmp( _strAuthType.QueryStr(), "Basic" ) ||
         !_stricmp( _strAuthType.QueryStr(), "user" ))
    {
        //
        //  If Basic is not enabled, force the user to anonymous if
        //  anon is enabled or kick them out with Access denied
        //

        if ( !(dwAuthFlags & INET_INFO_AUTH_CLEARTEXT) )
        {
            if ( dwAuthFlags & INET_INFO_AUTH_ANONYMOUS )
            {
                _HeaderList.FastMapCancel( HM_AUT );
                _strAuthType.Reset();
                goto NotFound;
            }
            else
            {
                SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_BY_CONFIG );
                SetLastError( ERROR_ACCESS_DENIED );
                return FALSE;
            }
        }

        //
        //  If the type is Basic, then the string has been uuencoded
        //

        if ( !ExtractClearNameAndPswd( pchBlob,
                                       &_strUserName,
                                       &_strPassword,
                                       *_strAuthType.QueryStr() == 'B' || 
                                       *_strAuthType.QueryStr() == 'b' ))
        {
            //
            // If we can't extract the username/pwd from Authorization header for
            // Basic, we'll assume the client sent an invalid blob
            //
            SetDeniedFlags( SF_DENIED_LOGON );
            SetLastError( ERROR_ACCESS_DENIED );
            return FALSE;
        }

       IF_DEBUG( PARSING )
       {
           DBGPRINTF(( DBG_CONTEXT,
                      "[OnAuthorization] User name = %s\n",
                       _strUserName.QueryStr(),
                       _strPassword.QueryStr() ));
       }

       _fClearTextPass = TRUE;

    }
    else if ( !_stricmp( _strAuthType.QueryStr(), "Digest" ) ||
              !_stricmp( _strAuthType.QueryStr(), "NT-Digest" ) )
    {
#if 0
        if ( !(QueryAuthentication()
                & INET_INFO_AUTH_MD5_AUTH) )
        {
            goto non_allowed;
        }

        LPSTR aValueTable[ MD5_AUTH_LAST ];
        STR strNonce;

        if ( !ParseForName( pchBlob,
                            MD5_AUTH_NAMES,
                            MD5_AUTH_LAST,
                            aValueTable ) ||
             aValueTable[MD5_AUTH_USERNAME] == NULL ||
             aValueTable[MD5_AUTH_REALM] == NULL ||
             aValueTable[MD5_AUTH_URI] == NULL ||
             aValueTable[MD5_AUTH_NONCE] == NULL ||
             aValueTable[MD5_AUTH_RESPONSE] == NULL )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if ( GenerateNonce( &strNonce, IISSUBA_MD5 ) )
        {
            if ( _tcpauth.LogonDigestUser(
                        aValueTable[MD5_AUTH_USERNAME],
                        aValueTable[MD5_AUTH_REALM],
                        aValueTable[MD5_AUTH_URI],
                        _strMethod.QueryStr(),
                        aValueTable[MD5_AUTH_NONCE],
                        strNonce.QueryStr(),
                        aValueTable[MD5_AUTH_RESPONSE],
                        IISSUBA_MD5,
                        g_pTsvcInfo ) )
            {
                _fAuthenticating = FALSE;
                _fLoggedOn = TRUE;
            }
            else
            {
                DWORD err = GetLastError();
                if ( err == ERROR_ACCESS_DENIED ||
                     err == ERROR_LOGON_FAILURE )
                {
                    _fAuthenticating = FALSE;
                    SetDeniedFlags( SF_DENIED_LOGON );
                    SetKeepConn( FALSE );
                }

                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
#else
        _fAuthTypeDigest = TRUE;
        _strUserName.Reset();
        _strPassword.Copy ( pchBlob );
#endif
    }
    else
    {
        //
        //  See if it's one of the SSP packages
        //

        BUFFER buff;
        BOOL   fNeedMoreData;
        DWORD  cbOut;

        if ( !QueryMetaData()->CheckSSPPackage( _strAuthType.QueryStr() ) )
        {
            goto NotFound;
        }

        //
        //  If NTLM is not enabled, force the user to anonymous if
        //  anon is enabled or kick them out with Access denied
        //

        if ( !(dwAuthFlags & INET_INFO_AUTH_NT_AUTH) )
        {
            if ( dwAuthFlags & INET_INFO_AUTH_ANONYMOUS )
            {
                goto NotFound;
            }
            else
            {
                SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_BY_CONFIG );
                SetLastError( ERROR_ACCESS_DENIED );
                return FALSE;
            }
        }

        //
        //  Process the authentication blob the client sent
        //  us and build the blob to be returned in _strAuthInfo
        //

        if ( !_tcpauth.Converse( pchBlob,
                                 0,
                                 &buff,
                                 &cbOut,
                                 &fNeedMoreData,
                                 QueryMetaData()->QueryAuthentInfo(),
                                 _strAuthType.QueryStr(),
                                 NULL,
                                 NULL,
                                 QueryW3Instance() ) ||
             !_strAuthInfo.Copy( _strAuthType )           ||
             !_strAuthInfo.Append( " ", 1 )               ||
             !_strAuthInfo.Append( cbOut ? ((CHAR *) buff.QueryPtr()) :
                                           "" ))
        {
            DWORD err = GetLastError();

            //
            //  If the authentication package gives us a denied error, then
            //  we need to reset our authorization info to indicate the client
            //  needs to start from scratch.  We also force a disconnect.
            //

            if ( err == ERROR_ACCESS_DENIED ||
                 err == ERROR_LOGON_FAILURE )
            {
                _fAuthenticating = FALSE;
                SetDeniedFlags( SF_DENIED_LOGON );
                SetKeepConn( FALSE );
            }

            if ( err == ERROR_PASSWORD_EXPIRED ||
                 err == ERROR_PASSWORD_MUST_CHANGE )
            {
                _fAuthenticating = FALSE;
                SetDeniedFlags( SF_DENIED_LOGON );
                SetKeepConn( FALSE );
            }

            return FALSE;
        }

        _fAuthenticating = fNeedMoreData;
        if ( !fNeedMoreData && !cbOut )
        {
            _strAuthInfo.Reset();
        }

        //
        //  If the last server side conversation succeeded and there isn't
        //  any more data, then we've successfully logged the user on
        //

        if ( _fLoggedOn = !fNeedMoreData )
        {
            if ( !CheckValidSSPILogin() )
            {
                return FALSE;
            }
        }

#if 0
        else if ( !IsKeepConnSet() )
        {
            // no point in sending data : connection won't be kept alive
            // assume that auth method is session oriented
            SetDeniedFlags( SF_DENIED_LOGON );
            SetLastError( ERROR_ACCESS_DENIED );
            return FALSE;
        }
#endif
    }

NotFound:

    //
    //  Restore the string
    //

    if ( pchSpace )
    {
        *pchSpace = ' ';
    }

    return TRUE;
}

BOOL
HTTP_REQ_BASE::OnProxyAuthorization(
    CHAR * pszValue
    )
/*++

Routine Description:

    Processes the HTTP "Proxy-Authorization: <type> <authdata>" field

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    //
    //  If a filter has indicated this is a proxy request, use the
    //  authorization information
    //

    if ( IsProxyRequest() )
    {
        return ParseAuthorization( pszValue );
    }

    return TRUE;
}

/*******************************************************************

    NAME:       HTTP_REQ_BASE::BuildStatusLine

    SYNOPSIS:   Formulates the HTTP status line of the server response to
                the client of the form:

                    <http version> <status code> <reason> <CrLf>

    ENTRY:      pbufResp - Receives status string
                dwHTTPError - Response code to load
                dwError2 - Optional reason error

    NOTES:      Optional acceptable authentication information will be
                added if the HTTP error is access denied

    HISTORY:
        Johnl       29-Aug-1994 Created

********************************************************************/

BOOL HTTP_REQ_BASE::BuildStatusLine( BUFFER *       pbufResp,
                                     DWORD          dwHTTPError,
                                     DWORD          dwError2,
                                     LPSTR          pszError2,
                                     STR            *pstrErrorStr)
{
    STACK_STR( strStatus, MAX_PATH );
    STACK_STR( strError2, MAX_PATH );
    LPSTR  pErr2 = NULL;
    LPSTR  pFormatStrBuff = NULL;
    CHAR * pszStatus;
    CHAR   ach[64];
    CHAR * pszTail;

    //
    //  Get the HTTP error string
    //

    switch ( dwHTTPError )
    {
    case HT_OK:
        pszStatus = "OK";
        break;

    case HT_RANGE:
        pszStatus = "Partial content";
        break;

    case HT_NOT_MODIFIED:
        pszStatus = "Not Modified";
        break;

    case HT_REDIRECT:
        pszStatus = "Object Moved";
        break;

    default:
        if ( !g_pInetSvc->LoadStr( strStatus, dwHTTPError + ID_HTTP_ERROR_BASE ))
        {
            DBGPRINTF((DBG_CONTEXT,
                      "BuildErrorResponse: failed to load HTTP status code %d (res=%d), error %d\n",
                       dwHTTPError,
                       dwHTTPError + ID_HTTP_ERROR_BASE,
                       GetLastError() ));

            pszStatus = "Error";
        }
        else
        {
            pszStatus = strStatus.QueryStr();
        }

        break;
    }

    //
    //  If the client wants a secondary error string, get it now
    //

    if ( dwError2 )
    {
        if ( g_pInetSvc->LoadStr( strError2, dwError2 ))
        {
            pErr2 = strError2.QueryStr();
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                      "BuildErrorResponse: failed to load 2nd status code %d (res=%d), error %d\n",
                       dwError2,
                       dwError2,
                       GetLastError() ));

            //
            //  Couldn't load the string, just provide the error number then
            //

                        wsprintf( ach, "%d (0x%08lx)", dwError2, dwError2 );

            if ( !strError2.Copy( ach ))
                return FALSE;

            pErr2 = strError2.QueryStr();
        }

        if ( dwError2 == ERROR_BAD_EXE_FORMAT )
        {
            // format the message to include file name
            DWORD dwL = 0;
            // handle exception that could be generated if this message
            // requires more than the # of param we supply and AV
            __try {
                if ( !FormatMessage( ( FORMAT_MESSAGE_ALLOCATE_BUFFER|
                                       FORMAT_MESSAGE_FROM_STRING|
                                       FORMAT_MESSAGE_ARGUMENT_ARRAY
                                       ),
                                     strError2.QueryStr(),
                                     0,
                                     0,
                                     (LPTSTR)&pFormatStrBuff,
                                     dwL,
                                     (va_list*)&pszError2 )
                     ) {
                    pErr2 = NULL;
                    pFormatStrBuff = NULL;
                }
            }
            __except ( EXCEPTION_EXECUTE_HANDLER )
            {
                pErr2 = NULL;
                pFormatStrBuff = NULL;
            }
        }
    }

    //
    //  Make sure there is room for the wsprintf
    //

    if ( !pbufResp->Resize( strlen(pszStatus) + 1      +
                            (pErr2 ? strlen(pErr2) : 0) +
                            LEN_PSZ_HTTP_VERSION_STR    +
                            20 * sizeof(TCHAR) ))   // status code + space
    {
        if ( pFormatStrBuff )
            LocalFree( pFormatStrBuff );
        return FALSE;
    }

    pszTail = (CHAR *) pbufResp->QueryPtr();

    //
    //  Build "HTTP/1.0 ### <status>\r\n" or "HTTP/1.0 ### <status> h(<Error>)\r\n"
    //

    if (!g_ReplyWith11)
    {
        APPEND_NUMERIC_HEADER( pszTail, "HTTP/1.0 ", dwHTTPError, " " );
    }
    else
    {
        APPEND_NUMERIC_HEADER( pszTail, "HTTP/1.1 ", dwHTTPError, " " );
    }

    APPEND_PSZ_HEADER( pszTail, "", pszStatus, "" );

    if ( pErr2 )
    {
        if (pstrErrorStr != NULL)
        {
            if (!pstrErrorStr->Append(strError2))
            {
                pstrErrorStr->SetLen(0);
            }
        }
    }

    APPEND_STRING( pszTail, "\r\n" );

    if ( pFormatStrBuff )
    {
        LocalFree( pFormatStrBuff );
    }

    return TRUE;
}

BOOL HTTP_REQ_BASE::BuildExtendedStatus(
    STR   *        pstrResp,
    DWORD          dwHTTPError,
    DWORD          dwError2,
    DWORD          dwExplanation,
    LPSTR          pszError2
    )
/*++

Routine Description:

    This static method build a HTTP response string with extended explanation
    information

Arguments:

    pStr - Receives built response
    dwHTTPError - HTTP error response
    dwError2 - Extended error information (win/socket error)
    dwExplanation - String ID of the explanation text

Return Value:

    TRUE if successful, FALSE on error

--*/
{

    // NYI: Who does the resize for the string before calling pstrResp ??
    // How long is the buffer though ??
    //  The code originally assumed that there will be enough space
    //   to append strings after buildStatusLine -- we use assert to check it.
    //

    //
    //  "HTTP/<ver> <status>"
    //

    // NYI:  Do a downlevel cast and send the buffer pointer around :(
    if ( !BuildStatusLine( pstrResp,
                           dwHTTPError,
                           dwError2, pszError2))
    {
        return FALSE;
    }

    // NYI: I need to setlen here because the buffer object was used earlier.
    DBG_REQUIRE( pstrResp->SetLen( strlen(pstrResp->QueryStr())));

    //
    //  "Server: <Server>/<version>
    //  Obtain this fro the global cache.
    //

    DBG_REQUIRE( pstrResp->Append( szServerVersion,
                                   (cbServerVersionString))
                 );

#if 0
    //
    //  If we need to add an explanation, also include a content length
    //

    if ( dwExplanation )
    {
        STR     str;

        if ( !g_pInetSvc->LoadStr( str, dwExplanation ))
        {
            return FALSE;
        }

        DBG_REQUIRE( pstrResp->Append( str));
    }

#endif

    return TRUE;
}


BOOL
HTTP_REQ_BASE::LogonUser(
    BOOL * pfFinished
    )
/*++

Routine Description:

    This method attempts to retrieve an impersonation token based
    on the current request

Arguments:

    pfFinished - Set to TRUE if no further processing is needed

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL fAsGuest;
    BOOL fAsAnonymous;
    BOOL fAsync;
    TCHAR * pszUser;
    DWORD cbUser;
    TCHAR * pszPswd;
    DWORD cbPswd;
    LPSTR pDns = NULL;
    DWORD dwAuth;
    HANDLE hAccessTokenPrimary = NULL;
    HANDLE hAccessTokenImpersonation = NULL;
    LPW3_SERVER_STATISTICS pStatsObj = QueryW3StatsObj();
    W3_STATISTICS_1 * pW3Stats = pStatsObj->QueryStatsObj();
    STACK_STR( strRealm, MAX_PATH); // make a local copy of the realm headers.

    dwAuth = QueryAuthentication();

    if ( _fAuthTypeDigest )
    {
        if ( dwAuth & INET_INFO_AUTH_MD5_AUTH  )
        {
            if ( !_strUserName.Resize( SF_MAX_USERNAME ) ||
                 !_strUnmappedUserName.Resize( SF_MAX_USERNAME ) ||
                 !_strUnmappedUserName.Copy( _strUserName ) ||
                 !_strPassword.Resize( SF_MAX_PASSWORD ) ||
                 !_strUnmappedPassword.Copy( _strPassword ) ||
                 !_strAuthType.Resize(SF_MAX_AUTH_TYPE) )
            {
                return FALSE;
            }

            if ( _Filter.IsNotificationNeeded( SF_NOTIFY_AUTHENTICATIONEX,
                                               IsSecurePort() ) &&
                 !_Filter.NotifyAuthInfoFiltersEx( _strUnmappedUserName.QueryStr(),
                                                   SF_MAX_USERNAME,
                                                   _strUserName.QueryStr(),
                                                   SF_MAX_USERNAME,
                                                   _strPassword.QueryStr(),
                                                   "",
                                                   QueryMetaData()->QueryAuthentInfo()->
                                                   strDefaultLogonDomain.QueryStr(),
                                                   _strAuthType.QueryStr(),
                                                   SF_MAX_AUTH_TYPE,
                                                   &hAccessTokenPrimary,
                                                   &hAccessTokenImpersonation,
                                                   pfFinished ))
            {
                SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_FILTER );
                return FALSE;
            }

            //
            //  The filter may have modified the lengths - reset the lengths.
            //  Note _strPassword doesn't need to be reset here since
            //  NotifyAuthInfoFiltersEx() doesn't modify it.
            //

            _strUnmappedUserName.SetLen( strlen( _strUnmappedUserName.QueryStr()));
            _strUserName.SetLen( strlen( _strUserName.QueryStr() ));
            _strAuthType.SetLen( strlen( _strAuthType.QueryStr() ));

            if ( *pfFinished )
            {
                return TRUE;
            }

            if ( hAccessTokenPrimary != NULL || hAccessTokenImpersonation != NULL )
            {
                _fMappedAcct = TRUE;
                _fSingleRequestAuth = TRUE;
                goto logged_in;
            }
        }

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Access denied based on configuration\n"));
        }
        SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_BY_CONFIG );
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    if ( !_strUnmappedUserName.Copy( _strUserName ) ||
         !_strUnmappedPassword.Copy( _strPassword ))
    {
        return FALSE;
    }

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_AUTHENTICATION,
                                       IsSecurePort() ))
    {
        if ( !_strUserName.Resize( SF_MAX_USERNAME ) ||
             !_strPassword.Resize( SF_MAX_PASSWORD ) )
        {
            return FALSE;
        }

        if ( !_Filter.NotifyAuthInfoFilters( _strUserName.QueryStr(),
                                              SF_MAX_USERNAME,
                                              _strPassword.QueryStr(),
                                              SF_MAX_PASSWORD,
                                              pfFinished ))
        {
            IF_DEBUG(ERROR) {
                DBGPRINTF((DBG_CONTEXT,"Access denied based on filter\n"));
            }
            SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_FILTER );
            return FALSE;
        }

        _strUserName.SetLen( strlen( _strUserName.QueryStr() ));
        _strPassword.SetLen( strlen( _strPassword.QueryStr() ));

        if ( *pfFinished )
        {
            return TRUE;
        }

        if ( strcmp( _strUserName.QueryStr(),
                     _strUnmappedUserName.QueryStr() ) )
        {
            _fMappedAcct = TRUE;
        }
    }

    if ( (dwAuth & INET_INFO_AUTH_MAPBASIC) &&
         _Filter.IsNotificationNeeded( SF_NOTIFY_AUTHENTICATIONEX,
                                       IsSecurePort() ) )
    {
        if ( !_strUserName.Resize( SF_MAX_USERNAME ) ||
             !_strPassword.Resize( SF_MAX_PASSWORD ) ||
             !_strAuthType.Resize( SF_MAX_AUTH_TYPE ) )
        {
            return FALSE;
        }
        //
        // generate the realm information for this request
        //

        strRealm.Copy( QueryMetaData()->QueryRealm()
                       ? QueryMetaData()->QueryRealm()
                       : QueryHostAddr() );

        if ( !_Filter.NotifyAuthInfoFiltersEx( _strUnmappedUserName.QueryStr(),
                                              SF_MAX_USERNAME,
                                              _strUserName.QueryStr(),
                                              SF_MAX_USERNAME,
                                              _strPassword.QueryStr(),
                                              strRealm.QueryStr(),
                                              QueryMetaData()->QueryAuthentInfo()->              
                                              strDefaultLogonDomain.QueryStr(), 
                                              _strAuthType.QueryStr(),
                                              SF_MAX_AUTH_TYPE,
                                              &hAccessTokenPrimary,
                                              &hAccessTokenImpersonation,
                                              pfFinished ))
        {
            IF_DEBUG(ERROR) {
                DBGPRINTF((DBG_CONTEXT,"Access denied based on filter\n"));
            }
            SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_FILTER );
            return FALSE;
        }

        _strUnmappedUserName.SetLen( strlen( _strUnmappedUserName.QueryStr()));
        _strUserName.SetLen( strlen( _strUserName.QueryStr() ));
        _strAuthType.SetLen( strlen( _strAuthType.QueryStr() ));

        if ( *pfFinished )
        {
            return TRUE;
        }
    }

logged_in:
    pszUser = *_strUserName.QueryStr() ?
                           _strUserName.QueryStr():
                           NULL;
    cbUser = _strUserName.QueryCB();

    pszPswd = *_strPassword.QueryStr() ?
                           _strPassword.QueryStr():
                           NULL;
    cbPswd = _strPassword.QueryCB();

    pStatsObj->IncrLogonAttempts();

logged_in2:

    if ( (hAccessTokenPrimary != NULL) || (hAccessTokenImpersonation != NULL) )
    {
        _fMappedAcct = TRUE;
        if ( !_tcpauth.SetAccessToken( hAccessTokenPrimary,
                                       hAccessTokenImpersonation ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[ClearTextLogon] ::LogonUser failed, error %d\n",
                        GetLastError()));

            return FALSE;
        }
        fAsGuest = FALSE;
        fAsAnonymous = FALSE;
        _fClearTextPass = FALSE;
    }
    else
    {
        if ( !(dwAuth & INET_INFO_AUTH_ANONYMOUS ) && (pszUser == NULL) )
        {
            IF_DEBUG(ERROR) {
                DBGPRINTF((DBG_CONTEXT,
                    "Access denied based on configuration[%x]\n",
                    dwAuth));
            }

            SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_BY_CONFIG );
            SetLastError( ERROR_ACCESS_DENIED );
            return FALSE;
        }

        if ( QueryMetaData()->QueryAuthentInfo()->dwLogonMethod == LOGON32_LOGON_NETWORK )
        {
            switch ( QueryW3Instance()->QueryNetLogonWks() )
            {
                case MD_NETLOGON_WKS_DNS:
                    pDns = QueryClientConn()->QueryResolvedDnsName();
                    break;

                case MD_NETLOGON_WKS_IP:
                    pDns = QueryClientConn()->QueryRemoteAddr();
                    break;
            }
        }
        
        if ( ( cbUser > UNLEN ) || ( cbPswd > PWLEN ) )
        {
            SetDeniedFlags( SF_DENIED_LOGON );
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return FALSE;
        }
        
        if ( !_tcpauth.ClearTextLogon( pszUser,
                                       pszPswd,
                                       &fAsGuest,
                                       &fAsAnonymous,
                                       QueryW3Instance(),
                                       QueryMetaData()->QueryAuthentInfo(),
                                       pDns ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[ClearTextLogon] ::LogonUser failed, error %d\n",
                        GetLastError()));

            DWORD dwErr = GetLastError();

            if ( (fAsAnonymous || fAsGuest) &&
                 (dwErr == ERROR_LOGIN_TIME_RESTRICTION ||
                  dwErr == ERROR_INVALID_LOGON_HOURS ||
                  dwErr == ERROR_ACCOUNT_DISABLED ||
                  dwErr == ERROR_ACCOUNT_LOCKED_OUT ||
                  dwErr == ERROR_ACCOUNT_EXPIRED ) )
            {
                dwErr = ERROR_ACCESS_DENIED;
            }

            //
            // If we pass an invalid username/domain to LogonUser, LastError is set
            // to ERROR_INVALID_PARAMETER, so we'll just massage that into returning 
            // "Access Denied"
            //
            if ( (dwErr == ERROR_ACCESS_DENIED) ||
                 (dwErr == ERROR_LOGON_FAILURE) ||
                 (dwErr == ERROR_INVALID_PARAMETER) )
            {
                SetDeniedFlags( SF_DENIED_LOGON );
                dwErr = ERROR_ACCESS_DENIED;
            }

            
            //
            // Query fully qualified name ( including domain )
            // so that we can prompt user for new password
            // with a name suitable for NetUserChangePassword
            //

            _tcpauth.QueryFullyQualifiedUserName( pszUser,
                    &_strUnmappedUserName,
                    QueryW3Instance(),
                    QueryMetaData()->QueryAuthentInfo());

            //
            // set last error here because QueryFullyQualifiedUserName
            // modified last error.
            //

            SetLastError( dwErr );

            return FALSE;
        }
    }

    //
    //  Are anonymous or clear text (basic) logons allowed?  We assume
    //  it's an NT logon if it's neither one of these
    //

    if ( fAsAnonymous &&
        !(dwAuth & INET_INFO_AUTH_ANONYMOUS ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[ClearTextLogon] Denying anonymous logon (not enabled), user %s\n",
                   _strUserName.QueryStr() ));

        SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_BY_CONFIG );
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }
    else if ( _fClearTextPass &&
              !(dwAuth & INET_INFO_AUTH_CLEARTEXT ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[ClearTextLogon] Denying clear text logon (not enabled), user %s\n",
                   _strUserName.QueryStr() ));

        SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_BY_CONFIG );
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    if ( fAsGuest )
    {
        if ( !(dwAuth & INET_INFO_AUTH_ANONYMOUS ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[ClearTextLogon] Denying guest logon (not enabled), user %s\n",
                       _strUserName.QueryStr() ));

            SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_BY_CONFIG );
            SetLastError( ERROR_ACCESS_DENIED );
            return FALSE;
        }
        if ( !fAsAnonymous )
        {
            _tcpauth.Reset();
            _strUserName.Reset();
            _strPassword.Reset();
            pszUser = NULL;
            pszPswd = NULL;
            cbUser = 0;
            cbPswd = 0;
            goto logged_in2;
        }
    }

    _fLoggedOn   = TRUE;
    _fAnonymous  = fAsAnonymous;

    if ( fAsAnonymous )
    {
        pStatsObj->IncrAnonymousUsers();

        _cbLastAnonAcctDesc = QueryMetaData()->QueryAuthentInfo()->cbAnonAcctDesc;

        if (!_bufLastAnonAcctDesc.Resize(_cbLastAnonAcctDesc) )
        {
            // Couldn't resize the buffer properly, set the size to 0 so
            // we'll force a relogon each time to be safe.

            _cbLastAnonAcctDesc = 0;
        }

        memcpy(_bufLastAnonAcctDesc.QueryPtr(),
            QueryMetaData()->QueryAuthentInfo()->bAnonAcctDesc.QueryPtr(),
            _cbLastAnonAcctDesc);
    }
    else
    {
        pStatsObj->IncrNonAnonymousUsers();
        _cbLastAnonAcctDesc = 0;
    }

    return TRUE;
}



# define MAX_ERROR_MESSAGE_LEN   ( 500)
#define EXTRA_LOGGING_BUFFER_SIZE   2048

BOOL
HTTP_REQ_BASE::WriteLogRecord(
    VOID
    )
/*++

Routine Description:

    Writes a transaction log for this request

Return Value:

    TRUE if successful, FALSE on error

--*/
{

    //
    //  HACK ALERT
    //
    //  This function may crash if this request has already written
    //  a log record - bail out now if so.
    //
    //  This HACK must precede the call to EndOfRequest(), which
    //  is the likely cause of the crash.
    //
    //  NOTE we set flag true immediately (even though we still may
    //  not log) to absolutely guarantee that we won't hit the crash,
    //  and to keep code for this hack as localized as possible.
    //
    //  CONSIDER for AFTER we ship IIS 4.0:
    //      clean up cause of crash, and then remove this hack
    //

    if ( _fLogRecordWritten )
    {
        return TRUE;
    }

    _fLogRecordWritten = TRUE;


    INETLOG_INFORMATION  ilRequest;
    HTTP_FILTER_LOG      Log;
    DWORD                dwLog;
    BOOL                 fDontLog = FALSE;
    LPSTR                pszClientHostName = QueryClientConn()->QueryRemoteAddr();

    //
    //  Metadata pointer can be NULL at this point
    //

    if ( QueryMetaData() )
    {
        if ( QueryMetaData()->QueryDoReverseDns() &&
             QueryClientConn()->IsDnsResolved() )
        {
            pszClientHostName = QueryClientConn()->QueryResolvedDnsName();
        }

        fDontLog = QueryMetaData()->DontLog();
    }

    //
    //  Notify filters and close any handles for this request
    //

    EndOfRequest();

    //
    //  Log this request if we actually did anything
    //

    if ( _dwLogHttpResponse == HT_DONT_LOG || IsProxyRequest() )
    {
        if ( !IsProxyRequest() )
        {
            IF_DEBUG(REQUEST) {
                DBGPRINTF(( DBG_CONTEXT,
                            "[WriteLogRecord] not writing log record, status is HT_DONT_LOG\n" ));
            }
        }

        return TRUE;
    }

    //
    //  If no logging is required, get out now
    //

    if ( ((HTTP_REQUEST*)this)->QueryVerb() == HTV_TRACECK ||
         (QueryW3Instance() == NULL) ||
         (!QueryW3Instance()->IsLoggingEnabled()) ||
         (!QueryW3Instance()->IsLogErrors() && (QueryLogWinError() || (QueryLogHttpResponse() >= 400))) ||
         (!QueryW3Instance()->IsLogSuccess() && (QueryLogWinError() == NO_ERROR) && 
            (QueryLogHttpResponse() < 400)) ||
         fDontLog )
    {
        return TRUE;
    }

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_LOG,
                                       IsSecurePort() ))
    {
        //
        //  If we have filters, use the possible filter replacement items
        //

        Log.pszClientHostName     = pszClientHostName;
        Log.pszClientUserName     = _strUserName.QueryStr();
        Log.pszServerName         = QueryClientConn()->QueryLocalAddr();

        Log.pszOperation          = _strMethod.QueryStr();
        Log.pszTarget             = _strURL.QueryStr();

        Log.pszParameters         = _strLogParams.QueryCCH() ?
                                    _strLogParams.QueryStr() :
                                    _strURLParams.QueryStr();

        Log.dwHttpStatus          = QueryLogHttpResponse();
        Log.dwWin32Status         = QueryLogWinError();
        Log.dwBytesSent           = _cbBytesSent;
        Log.dwBytesRecvd          = _cbClientRequest + _cbTotalEntityBody;
        Log.msTimeForProcessing   = GetCurrentTime() - _msStartRequest;

        _Filter.NotifyLogFilters( &Log );

        ilRequest.pszClientHostName  =   (char *)   Log.pszClientHostName;
        ilRequest.pszClientUserName  =   (char *)   Log.pszClientUserName;
        ilRequest.pszServerAddress   =   (char *)   Log.pszServerName;

        ilRequest.pszOperation       =   (char *)   Log.pszOperation;
        ilRequest.pszTarget          =   (char *)   Log.pszTarget;
        ilRequest.pszParameters      =   (char *)   Log.pszParameters;
        ilRequest.dwProtocolStatus   =              Log.dwHttpStatus;
        ilRequest.dwWin32Status      =              Log.dwWin32Status;

        ilRequest.msTimeForProcessing   = Log.msTimeForProcessing;
        ilRequest.dwBytesSent       = Log.dwBytesSent;
        ilRequest.dwBytesRecvd      = Log.dwBytesRecvd;

        ilRequest.cbOperation           = strlen( Log.pszOperation );
        ilRequest.cbTarget              = strlen( Log.pszTarget );
        ilRequest.cbClientHostName      = strlen(ilRequest.pszClientHostName);
    }
    else
    {
        ilRequest.pszClientHostName     = pszClientHostName;
        ilRequest.pszClientUserName     = _strUserName.QueryStr();
        ilRequest.pszServerAddress      = QueryClientConn()->QueryLocalAddr();

        ilRequest.pszOperation          = _strMethod.QueryStr();
        ilRequest.pszTarget             = _strURL.QueryStr();

        ilRequest.pszParameters         = _strLogParams.QueryCCH() ?
                                          _strLogParams.QueryStr() :
                                          _strURLParams.QueryStr();

        ilRequest.dwProtocolStatus      = QueryLogHttpResponse();
        ilRequest.dwWin32Status         = QueryLogWinError();

        ilRequest.msTimeForProcessing   = GetCurrentTime() - _msStartRequest;
        ilRequest.dwBytesSent           = _cbBytesSent;
        ilRequest.dwBytesRecvd          = _cbClientRequest + _cbTotalEntityBody;

        //
        // Get length of some strings
        //

        ilRequest.cbOperation           = _strMethod.QueryCCH();
        ilRequest.cbTarget              = _strURL.QueryCCH();
        ilRequest.cbClientHostName      = strlen(ilRequest.pszClientHostName);
    }

    //
    // write capacity planning trace info.
    //
    
    if (GetIISCapTraceFlag())
    {
        PIIS_CAP_TRACE_INFO pHttpCapTraceInfo;

        pHttpCapTraceInfo = AtqGetCapTraceInfo(QueryClientConn()->QueryAtqContext());

        pHttpCapTraceInfo->IISCapTraceHeader.TraceHeader.Size = sizeof (IIS_CAP_TRACE_INFO);
        pHttpCapTraceInfo->IISCapTraceHeader.TraceHeader.Class.Type = EVENT_TRACE_TYPE_INFO;

        pHttpCapTraceInfo->MofFields[0].Length  = ilRequest.cbOperation+1;
        pHttpCapTraceInfo->MofFields[0].DataPtr = (ULONGLONG) ilRequest.pszOperation;

        pHttpCapTraceInfo->MofFields[1].Length  = ilRequest.cbTarget+1;
        pHttpCapTraceInfo->MofFields[1].DataPtr = (ULONGLONG) ilRequest.pszTarget;
        
        pHttpCapTraceInfo->MofFields[2].Length  = sizeof(DWORD);
        pHttpCapTraceInfo->MofFields[2].DataPtr = (ULONGLONG) &ilRequest.dwBytesSent;
        
        if ( ERROR_INVALID_HANDLE == TraceEvent ( GetIISCapTraceLoggerHandle(),
                                          (PEVENT_TRACE_HEADER) pHttpCapTraceInfo))            
        {
            SetIISCapTraceFlag(0);            
        }
    }

    BYTE  pchTemp[EXTRA_LOGGING_BUFFER_SIZE];
    BUFFER buf( pchTemp, EXTRA_LOGGING_BUFFER_SIZE); // init w/- stack buffer
    ilRequest.pszHTTPHeader= NULL;
    ilRequest.dwPort = QueryClientConn()->QueryPort( );

    ilRequest.pszVersion=(LPSTR)_HeaderList.FastMapQueryValue(HM_VER);

    //
    // Only log extra fields if the request was from a version > 0.9 [which didn't 
    // have headers] and extra logging fields have been requested
    //
    if ( !IsPointNine() &&
         QueryW3Instance()->m_Logging.IsRequiredExtraLoggingFields())
    {
        //
        // reconstruct the buffer
        //

        PCHAR pszFieldName =
            QueryW3Instance()->m_Logging.QueryExtraLoggingFields();

        DWORD cbValueSize=0;
        DWORD cbTotalSize=0;
        DWORD cbActualSize=0;
        DWORD cbCurrentBufferSize = EXTRA_LOGGING_BUFFER_SIZE;
        PCHAR pszValue;
        PCHAR pszBuff = (TCHAR *) buf.QueryPtr();

        while ( *pszFieldName != '\0' )
        {
            //
            // add the string into the buffer
            //

            pszValue = QueryHeaderList()->FindValue(
                                            pszFieldName,
                                            &cbValueSize
                                            );

            if ( pszValue == NULL ) {
                cbValueSize = 0;
                pszValue = "";
            }

            cbTotalSize = cbActualSize + cbValueSize + 2;
            if (cbTotalSize > cbCurrentBufferSize)
            {
                buf.Resize(cbTotalSize);
                cbCurrentBufferSize = cbTotalSize;
                pszBuff=(TCHAR*)buf.QueryPtr();
                pszBuff += cbActualSize;
            }

            CopyMemory( pszBuff, pszValue, strlen(pszValue)+1);
            pszFieldName += strlen(pszFieldName) + 1;
            pszBuff += cbValueSize+1;
            cbActualSize += cbValueSize+1;
            *pszBuff = '\0';
        }

        ilRequest.pszHTTPHeader = (PCHAR)buf.QueryPtr();
        ilRequest.cbHTTPHeaderSize = cbActualSize;
    }

    dwLog = QueryW3Instance()->m_Logging.LogInformation(&ilRequest);

    if ( dwLog != NO_ERROR )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "[WriteLogRecord] - Failed, error %d\n",
                   GetLastError() ));

        //
        //  We should make sure LogInformation will never fail
        //
    }

    return TRUE;
}

BOOL
HTTP_REQ_BASE::AppendLogParameter(
    CHAR * pszParam
    )
/*++

Routine Description:

    Appends data for logging.

Arguments:

    pszParam - The data to be appended

Return Value:

    TRUE if successful, FALSE on error

Notes:

    The way that AppendLogData works is that it just appends
    data to the query string, so that when the query string
    is logged, the new data gets a free ride.

    The problem with this is that anyone who looks at the
    query string after AppendLogParameter will see the additional
    log data.

    To prevent this, we'll create a copy of the query string
    data upon the first call of this function and then append
    the new data to the copy.  When the log is written, the copy
    will be written if it has data, else the original query
    string will be written.

--*/
{
    //
    // If the _strLogParams buffer is empty, copy
    // the query string first.
    //

    if ( _strLogParams.QueryCCH() == 0 )
    {
        BOOL fRet = _strLogParams.Copy( _strURLParams.QueryStr() );

        if ( !fRet )
        {
            return fRet;
        }
    }

    //
    // Append the new data.
    //

    return _strLogParams.Append( pszParam );
}

BOOL
HTTP_REQ_BASE::BuildHttpHeader( OUT BOOL * pfFinished,
                                IN  CHAR * pchStatus OPTIONAL,
                                IN  CHAR * pchAdditionalHeaders OPTIONAL,
                                IN  DWORD  dwOptions)
/*++

Routine Description:

    Builds a full HTTP header reply with an optional status and
    other headers/data

Arguments:

    pchStatus - optional HTTP status string like "401 Access Denied"
    pchAdditionalHeaders - optional additional HTTP or MIME headers and
        data.  Must supply own '\r\n' terminator if this parameter is
        supplied
    pfFinished - Set to TRUE if no further processing is required

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    STR     str;
    BOOL    fFinished = FALSE;

    if ( pchStatus )
    {
        DWORD cbLen = ::strlen( pchStatus);

        // NYI:  Can we compress the calls to string class here
        //  Also make sure enough space is allocated in string object

        if ( !str.Resize( LEN_PSZ_HTTP_VERSION_STR + cbLen + 4) ||
             !str.Copy( (!g_ReplyWith11 ? PSZ_HTTP_VERSION_STR :
                                          PSZ_HTTP_VERSION_STR11),
                        LEN_PSZ_HTTP_VERSION_STR )              ||
             !str.Append( pchStatus, cbLen )
             )
        {
            return FALSE;
        }

        // I am safe to assume space is there, because of resize
        DBG_ASSERT( str.QueryCB() < (str.QuerySize() - 2));
        str.AppendCRLF();
    }

    if ( !BuildBaseResponseHeader( QueryRespBuf(),
                                   pfFinished,
                                   (pchStatus ? &str : NULL ),
                                   dwOptions ))
    {
        return FALSE;
    }

    if ( pchAdditionalHeaders )
    {
        DWORD       dwAddlHdrLength;
        DWORD       dwCurrentLength;


        dwAddlHdrLength = strlen(pchAdditionalHeaders) + 1;
        dwCurrentLength = QueryRespBufCB();

        if (!QueryRespBuf()->Resize(dwCurrentLength + dwAddlHdrLength))
        {
            return FALSE;
        }

        memcpy(QueryRespBufPtr() + dwCurrentLength,
                pchAdditionalHeaders,
                dwAddlHdrLength);

    }

    return TRUE;

} // HTTP_REQ_BASE::BuildHttpHeader()

BOOL
HTTP_REQ_BASE::SendHeader(
    IN  CHAR * pchStatus OPTIONAL,
    IN  CHAR * pchAdditionalHeaders OPTIONAL,
    IN  DWORD  IOFlags,
    OUT BOOL * pfFinished,
    IN  DWORD  dwOptions,
    IN  BOOL   fWriteHeader
    )
/*++

Routine Description:

    Does a synchronous send of an HTTP header with optional status
    and additional headers.

Arguments:

    pchStatus - HTTP Status code (or NULL for "200 Ok")
    pchAdditionalHeaders - Headers to add to the standard response set
    IOFlags - IO_* flags to send the headers with
    pfFinished - Set to TRUE if no further processing is needed for this
        request
    fWriteHeader - Defaults to TRUE; pass FALSE to suppress writing headers
        (designed for callers that want to send header and body together)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD   BytesSent;
    DWORD   cbAddHeaders;
    BOOL    fAnyChanges = FALSE;

    *pfFinished = FALSE;

    if ( pchAdditionalHeaders )
    {
        cbAddHeaders = strlen( pchAdditionalHeaders );

        if ( cbAddHeaders &&
             cbAddHeaders > QueryRespBuf()->QuerySize() / 2)
        {
            if ( !QueryRespBuf()->Resize( QueryRespBuf()->QuerySize() +
                                          cbAddHeaders ))
            {
                return FALSE;
            }
        }
    }

    if ( !BuildHttpHeader( pfFinished,
                           pchStatus,
                           pchAdditionalHeaders,
                           dwOptions))
    {
        return FALSE;
    }

    if ( *pfFinished )
    {
        return TRUE;
    }

    DBG_ASSERT( QueryRespBufCB() <=
                QueryRespBuf()->QuerySize() );

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_SEND_RESPONSE,
                                       IsSecurePort() ))
    {
        if ( !_Filter.NotifySendHeaders( QueryRespBufPtr(),
                                         pfFinished,
                                         &fAnyChanges,
                                         QueryRespBuf() ))
        {
            return FALSE;
        }

        if ( *pfFinished )
        {
            return TRUE;
        }
    }

    if ( fWriteHeader )
    {
        if ( !WriteFile( QueryRespBufPtr(),
                     QueryRespBufCB(),
                     &BytesSent,
                     IOFlags ))
        {
            return FALSE;
        }
    }

    return TRUE;

} // HTTP_REQ_BASE::SendHeader()



BOOL
HTTP_REQ_BASE::SendHeader(
    IN  CHAR * pchHeaders,
    IN  DWORD  cbHeaders,
    IN  DWORD  IOFlags,
    OUT BOOL * pfFinished
    )
/*++

Routine Description:

    Does a send of the HTTP header response where the status is already
    embedded in the header set

    If the pfFinished comes back TRUE and IO_FLAG_ASYNC was specified, then
    an IO completion will be made

Arguments:

    pchHeaders - Pointer to header set
    cbHeaders - Length of headers to send (or -1 if headers are '\0' terminated)
    IOFlags - IO_* flags to send the headers with
    pfFinished - Set to TRUE if no further processing is needed for this
        request

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD   BytesSent;
    DWORD   cbAddHeaders;
    BOOL    fAnyChanges = FALSE;

    *pfFinished = FALSE;

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_SEND_RESPONSE,
                                       IsSecurePort() ))
    {
        if ( !_Filter.NotifySendHeaders( pchHeaders,
                                         pfFinished,
                                         &fAnyChanges,
                                         QueryRespBuf() ))
        {
            return FALSE;
        }

        if ( *pfFinished )
        {
            return TRUE;
        }

        if ( fAnyChanges )
        {
            pchHeaders = QueryRespBufPtr();
            cbHeaders = QueryRespBufCB();
        }
    }

    if ( cbHeaders == -1 )
    {
        cbHeaders = strlen( pchHeaders );
    }

    if ( !WriteFile( pchHeaders,
                     cbHeaders,
                     &BytesSent,
                     IOFlags ))
    {
        return FALSE;
    }

    return TRUE;

} // HTTP_REQ_BASE::SendHeader()


#define NO_CACHE_HEADER_SIZE (sizeof("Cache-Control: no-cache,no-transform\r\n") - 1 +\
                                sizeof("Expires: Mon, 00 Jan 0000 00:00:00 GMT\r\n") - 1)


BOOL
HTTP_REQ_BASE::BuildBaseResponseHeader(
    BUFFER *     pbufResponse,
    BOOL *       pfFinished,
    STR *        pstrStatus,
    DWORD        dwOptions
    )
/*++

Routine Description:

    Builds a set of common server response headers

Arguments:

    pbufResponse - Receives response headers
    pfFinished - Set to TRUE if no further processing is needed
    pstrStatus - Optional HTTP response status (defaults to 200)
    dwOptions - bit field of options.
        HTTPH_SEND_GLOBAL_EXPIRE Indicates whether an
          "Expires: xxx" based on the global expires value
          is include with the headers
        HTTPH_NO_DATE indicates whether to generate a
          "Date:" header.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    FILETIME    ftSysTime;
    CHAR        achTime[64];
    BOOL        fSysTimeValid = FALSE;
    CHAR *      pszResp;
    CHAR *      pszTail;
    DWORD       cb;
    DWORD       cbExpire;
    DWORD       cbCustom;
    DWORD       cbLeft;
    DWORD       dwSizeUsed;


    pszResp = (CHAR *) pbufResponse->QueryPtr();

    //
    //  Add the status line - "HTTP/1.0 nnn sss...\r\n"
    //

    if ( !pstrStatus )
    {

        pszTail = pszResp;
        if ( !_fProcessByteRange )
        {
            if (!g_ReplyWith11)
            {
                APPEND_STRING( pszTail, "HTTP/1.0 200 OK\r\n" );
            }
            else
            {
                APPEND_STRING( pszTail, "HTTP/1.1 200 OK\r\n" );
            }

        } else
        {
            if (!g_ReplyWith11)
            {
                APPEND_STRING( pszTail, "HTTP/1.0 206 Partial content\r\n" );
            }
            else
            {
                APPEND_STRING( pszTail, "HTTP/1.1 206 Partial content\r\n" );
            }
        }
    }
    else
    {
        // ++WinSE 27217
        DWORD dwRequired = pstrStatus->QuerySize()
            + MIN_BUFFER_SIZE_FOR_HEADERS;

        if(pbufResponse->QuerySize() < dwRequired)
        {
            if(!pbufResponse->Resize(dwRequired))
                return FALSE;
            pszResp = (CHAR *) pbufResponse->QueryPtr();
        }
        // --WinSE 27217

        strcpy( pszResp, pstrStatus->QueryStr() );
        pszTail = pszResp + strlen(pszResp);
    }

    //
    //  "Server: Microsoft/xxx
    //

    APPEND_VER_STR( pszTail );

    DBG_ASSERT( pbufResponse->QuerySize() >= MIN_BUFFER_SIZE_FOR_HEADERS );

    //
    //  Fill in the rest of the headers
    //

    //
    //  "Date: <GMT Time>" - Time the response was sent.
    //

    if ( !(dwOptions & HTTPH_NO_DATE ) )
    {
         // build Date: uses Date/Time cache
        pszTail += g_pDateTimeCache->GetFormattedCurrentDateTime( pszTail );
    }

    //
    //  Add an expires header and any custom headers if the feature
    //  is enabled and the caller wants it. Since we could be adding
    //  lots of headers here check for space.
    //
    //  Note for filters that send response headers, _pMetaData may
    //  be NULL at this point
    //

    if (!(dwOptions & HTTPH_NO_CUSTOM))
    {
        cbCustom = _pMetaData ? _pMetaData->QueryHeaders()->QueryCB() : 0;
    }
    else
    {
        cbCustom = 0;
    }

    if ( dwOptions & HTTPH_SEND_GLOBAL_EXPIRE )
    {
        if (!_bForceNoCache)
        {
            cbExpire = _pMetaData->QueryExpireMaxLength() +
                        _pMetaData->QueryCacheControlHeaderLength();
        }
        else
        {
            cbExpire = NO_CACHE_HEADER_SIZE;
        }
    }
    else
    {
        cbExpire = 0;
    }

    if ( (cb = cbCustom + cbExpire) != 0 )
    {
        cb += POST_CUSTOM_HEADERS_SIZE;

        // Find out how many bytes are left in the response buffer.

        cbLeft = pbufResponse->QuerySize() - DIFF(pszTail - pszResp);

        if (cb > cbLeft) {

            // Not enough left, try to resize the buffer.

            if ( !pbufResponse->Resize( pbufResponse->QuerySize() - cbLeft + cb + 1))
            {
                // Couldn't resize, fail.

                return FALSE;
            }

            pszTail = (CHAR *) pbufResponse->QueryPtr() + (pszTail - pszResp);

            // Update pszResp, in case it's used later.
            pszResp = (CHAR *) pbufResponse->QueryPtr();
        }

        if ( cbCustom )
        {
            memcpy( pszTail, _pMetaData->QueryHeaders()->QueryStr(), cbCustom + 1);
            pszTail += cbCustom;
        }

        if ( cbExpire )
        {
            DWORD       dwExpireHeaderLength;
            FILETIME    ftNow;
            DWORD       dwStaticMaxAge;
            DWORD       dwExpireMode;
            DWORD       dwDelta;

            if ( !fSysTimeValid )
            {
                ::IISGetCurrentTimeAsFileTime(&ftSysTime);
                fSysTimeValid = TRUE;
            }

            dwExpireHeaderLength = _pMetaData->QueryExpireHeaderLength();
            if (!_bForceNoCache)
            {
                dwExpireMode = _pMetaData->QueryExpireMode();

                if (_pMetaData->QueryCacheControlHeaderLength() != 0)
                {
                    memcpy( pszTail, _pMetaData->QueryCacheControlHeader(),
                        _pMetaData->QueryCacheControlHeaderLength() + 1 );

                    pszTail += _pMetaData->QueryCacheControlHeaderLength();
                }
            }
            else
            {
                memcpy(pszTail, "Cache-Control: no-cache,no-transform\r\n",
                    sizeof("Cache-Control: no-cache,no-transform\r\n"));
                pszTail += sizeof("Cache-Control: no-cache,no-transform\r\n") - 1;
                dwExpireMode = EXPIRE_MODE_DYNAMIC;
            }

            switch ( dwExpireMode )
            {
                case EXPIRE_MODE_STATIC:

                    if (!_pMetaData->QueryConfigNoCache() &&
                        !_pMetaData->QueryHaveMaxAge())
                    {
                        //
                        // Don't have a pre-configured max-age or no-cache
                        // header. Compute the proper one now.
                        LONGLONG        llNow;

                        llNow = *(LONGLONG *)&ftSysTime;

                        if (llNow < _pMetaData->QueryExpireTime().QuadPart)
                        {
                            llNow = _pMetaData->QueryExpireTime().QuadPart - llNow;
                            
                            llNow /= FILETIME_1_SECOND;      // Convert to seconds.
                            
                            if ( llNow > (LONGLONG)0xffffffff)
                            {
                                dwStaticMaxAge = 0xfffffff;
                            }
                            else
                            {
                                dwStaticMaxAge = (DWORD)llNow;
                            }
                        }
                        else
                        {
                            dwStaticMaxAge = 0;
                        }
                        
                        if (dwStaticMaxAge != 0)
                        {
                            APPEND_NUMERIC_HEADER(pszTail, "max-age=",
                                                  dwStaticMaxAge, "\r\n");
                        }
                        else
                        {
                            APPEND_STRING(pszTail, "no-cache\r\n");
                        }


                    }

                    memcpy( pszTail, _pMetaData->QueryExpireHeader(),
                        dwExpireHeaderLength + 1 );

                    pszTail += dwExpireHeaderLength;
                    break;

                case EXPIRE_MODE_DYNAMIC:
                    if (!_bForceNoCache)
                    {
                        dwDelta = _pMetaData->QueryExpireDelta();
                    }
                    else
                    {
                        dwDelta = 0;
                    }

                    if ( !::FileTimeToGMTEx( ftSysTime,
                                               achTime,
                                               sizeof(achTime),
                                               dwDelta ))
                    {
                        return FALSE;
                    }
                    APPEND_STRING( pszTail, "Expires: " );
                    cb = strlen( achTime );
                    memcpy( pszTail, achTime, cb );
                    pszTail += cb;
                    APPEND_STRING( pszTail, "\r\n" );

                    break;

                default:
                    break;
            }
        }
    }

    //
    //  "Connection: keep-alive" - Indicate if the server accepted the
    //      session modifier by reflecting it back to the client
    //

    if ( IsKeepConnSet() )
    {
        if (!IsOneOne() && !(dwOptions & HTTPH_NO_CONNECTION))
        {
            APPEND_STRING( pszTail, "Connection: keep-alive\r\n" );
        }

    } else
    {
        if (IsOneOne() && !(dwOptions & HTTPH_NO_CONNECTION))
        {
            APPEND_STRING( pszTail, "Connection: close\r\n" );
        }
    }

    if (dwOptions & HTTPH_SEND_GLOBAL_EXPIRE)
    {

        //
        // Check to see if we need to send a Content-Location: or
        // Vary: header.

        if (_bSendContentLocation)
        {
            CHAR        *pszHostName;
            DWORD       cbHostNameLength;

            pszHostName = QueryHostAddr();
            cbHostNameLength = strlen(pszHostName);

            dwSizeUsed = DIFF(pszTail - pszResp);

            if ( !pbufResponse->Resize(dwSizeUsed + POST_CUSTOM_HEADERS_SIZE +
                  sizeof("Content-Location: https:// \r\n") + sizeof(":65536") +
                  cbHostNameLength + _strRawURL.QueryCB()))
            {
                // Couldn't resize, fail.

                return FALSE;
            }
            pszResp = (CHAR *) pbufResponse->QueryPtr();

            pszTail = pszResp + dwSizeUsed;

            // WinSE 5600
            SHORT sPort = QueryClientConn()->QueryPort();
            CHAR szPort[sizeof(":65536")];
            DWORD szPortLen=0;

            if (QueryClientConn()->IsSecurePort())
            {
                if (sPort != 443 )
                {
                    szPortLen=wsprintf( szPort, ":%d", (USHORT) sPort );
                }
            }
            else
            {
                if ( sPort != QueryW3Instance()->QueryDefaultPort() )
                {
                    szPortLen=wsprintf( szPort, ":%d", (USHORT) sPort );
                }
            }

            if ( cbHostNameLength != 0 )
            {
                if (QueryClientConn()->IsSecurePort())
                {
                    APPEND_STRING(pszTail, "Content-Location: https://");
                }
                else
                {
                    APPEND_STRING(pszTail, "Content-Location: http://");
                }
                
                memcpy(pszTail, pszHostName, cbHostNameLength + 1);

                if ( szPortLen )
                {
                    memcpy(pszTail+cbHostNameLength,szPort,szPortLen+1);
                }
                
                pszTail += cbHostNameLength + szPortLen;
            }
            else
            {
                APPEND_STRING(pszTail, "Content-Location: ");
            }

            APPEND_STR_HEADER(pszTail, "", _strRawURL, "\r\n");
        }

        if (_bSendVary)
        {
            dwSizeUsed = DIFF(pszTail - pszResp);

            if ( !pbufResponse->Resize(dwSizeUsed + POST_CUSTOM_HEADERS_SIZE +
                                        sizeof("Vary: *\r\n")) )
            {
                // Couldn't resize, fail.

                return FALSE;
            }

            pszResp = (CHAR *) pbufResponse->QueryPtr();

            pszTail = pszResp + dwSizeUsed;

            APPEND_STRING(pszTail, "Vary: *\r\n");

        }
    }

    // Authentication headers -- indicate the server requests authentication

    if ( IsAuthenticationRequested() )
    {
        STR             strAuthHdrs;

        if ( !AppendAuthenticationHdrs( &strAuthHdrs,
                                        pfFinished ))
        {
            return FALSE;
        }

        if ( *pfFinished )
        {
            return TRUE;
        }
        
        if ( !QueryDenialHeaders()->IsEmpty() )
        {
            if ( !strAuthHdrs.Append( QueryDenialHeaders()->QueryStr() ) )
            {
                return FALSE;
            }
        }
        
        dwSizeUsed = DIFF(pszTail - pszResp);

        if ( !pbufResponse->Resize(dwSizeUsed + strAuthHdrs.QueryCB() + 1 ) )
        {
            // Couldn't resize, fail.

            return FALSE;
        }

        pszResp = (CHAR *) pbufResponse->QueryPtr();
        pszTail = pszResp + dwSizeUsed;

        memcpy( pszTail,
                strAuthHdrs.QueryStr(),
                strAuthHdrs.QueryCB() + 1 );
        
        pszTail += strAuthHdrs.QueryCB();
        
    }
    else if ( !_strAuthInfo.IsEmpty() )
    {
        dwSizeUsed = DIFF(pszTail - pszResp);

        if ( !pbufResponse->Resize(dwSizeUsed +
                                    sizeof("Proxy-Authenticate: \r\n") +
                                    _strAuthInfo.QueryCB()) )
        {
            // Couldn't resize, fail.

            return FALSE;
        }

        pszResp = (CHAR *) pbufResponse->QueryPtr();
        pszTail = pszResp + dwSizeUsed;

        pszTail += wsprintf( pszTail,
                             "%s: %s\r\n",
                             (IsProxyRequest() ? "Proxy-Authenticate" :
                                                 "WWW-Authenticate"),
                             _strAuthInfo.QueryStr() );
    }

    //
    //  Append headers specified by filters
    //

    if ( !QueryAdditionalRespHeaders()->IsEmpty() )
    {
        cb = QueryAdditionalRespHeaders()->QueryCB() + 1;
        cbLeft = pbufResponse->QuerySize() - DIFF(pszTail - pszResp);

        if ( cb > cbLeft )
        {
            if ( !pbufResponse->Resize( pbufResponse->QuerySize() + cb ))
            {
                return FALSE;
            }

            pszTail = (CHAR *) pbufResponse->QueryPtr() + (pszTail - pszResp);
        }

        memcpy( pszTail, QueryAdditionalRespHeaders()->QueryStr(), cb );
    }

    return TRUE;
}

BOOL WINAPI
DeleteFunc(
    CtxtHandle* pH,
    PVOID pF
)
/*++

Routine Description:

    Notification of SSPI security context destruction

Arguments:

    pH - SSPI security context
    pF - HTTP_REQ_BASE to notify

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    return ((HTTP_REQ_BASE*)pF)->NotifyRequestSecurityContextClose( pH );
}


BOOL
HTTP_REQ_BASE::SetCertificateInfo(
    IN PHTTP_FILTER_CERTIFICATE_INFO pData,
    IN CtxtHandle *pCtxt,
    IN HANDLE hPrimaryToken,
    IN HTTP_FILTER_DLL* pFilter
    )
/*++

Routine Description:

    Set SSL/PCT SSPI security context & access token

Arguments:

    pData - ptr to certificate info
    pCtxt - SSPI security context
    hPrimaryToken - access token bound to SSPI security context
    pFilter - calling filter

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( pCtxt != NULL )
    {
        if ( hPrimaryToken == IIS_ACCESS_DENIED_HANDLE )
        {
            _fInvalidAccessToken = TRUE;

            return TRUE;
        }

        _pAuthFilter = NULL;

        W3_SERVER_INSTANCE *pInstance = QueryW3InstanceAggressively();

        if ( hPrimaryToken != NULL )
        {
            ResetAuth( TRUE );

            _pAuthFilter = pFilter;



            if ( !_tcpauth.SetSecurityContextToken( pCtxt,
                                                    hPrimaryToken,
                                                    DeleteFunc,
                                                    (PVOID)this,
                                                    ( pInstance ? 
                                                      pInstance->GetAndReferenceSSLInfoObj() :
                                                      NULL ) ) )
            {
                _pAuthFilter = NULL;
                return FALSE;
            }

            _strAuthType.Copy( "SSL/PCT", (sizeof( "SSL/PCT") - 1) );

            _fLoggedOn        = TRUE;
            _fAuthCert        = TRUE;
            _dwSslNegoFlags   |= SSLNEGO_MAP;

            _strPassword.Reset();

            QueryW3StatsObj()->IncrNonAnonymousUsers();

            //
            //  Get the user name
            //

            if ( !_tcpauth.QueryUserName( &_strUserName ) ||
                (_strUserName.SetLen( strlen(_strUserName.QueryStr()) ),
                 !_strUnmappedUserName.Copy( _strUserName )) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[SetCertificateInfo] Getting username failed, error %d\n",
                            GetLastError() ));

                return FALSE;
            }
        }
        else
        {
            if ( !_tcpauth.SetSecurityContextToken( pCtxt,
                                                    hPrimaryToken,
                                                    DeleteFunc,
                                                    (PVOID)this,
                                                    ( pInstance ? 
                                                      pInstance->GetAndReferenceSSLInfoObj() :
                                                      NULL ) ) )
            {
                return FALSE;
            }
        }

        return TRUE;
    }

    SetLastError( ERROR_INVALID_PARAMETER );

    DBG_ASSERT( FALSE );

    return FALSE;
}


BOOL
HTTP_REQ_BASE::CheckValidSSPILogin(
    VOID
    )
{
    // Check if guest account

    if ( _tcpauth.IsGuest( FALSE ) )
    {
        if ( !(QueryAuthentication() & INET_INFO_AUTH_ANONYMOUS) )
        {
            SetLastError( ERROR_LOGON_FAILURE );
            SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_BY_CONFIG );

            _fAuthenticating = FALSE;
            _fLoggedOn = FALSE;
            SetKeepConn( FALSE );

            return FALSE;
        }

        //
        // cancel current authorization & authentication
        //

        _HeaderList.FastMapCancel( HM_AUT );

        _fLoggedOn        = FALSE;
        _fInvalidAccessToken = FALSE;
        _fClearTextPass   = FALSE;
        _fAnonymous       = FALSE;
        _fAuthenticating  = FALSE;
        _fAuthTypeDigest  = FALSE;
        _fAuthSystem      = FALSE;
        _fAuthCert        = FALSE;
        _tcpauth.Reset();

        _strAuthType.Reset();
        _strUserName.Reset();
        _strPassword.Reset();
        _strUnmappedUserName.Reset();

        // return as if no authorization had been seen

        return TRUE;
    }

    QueryW3StatsObj()->IncrNonAnonymousUsers();

    //
    //  Get the user name
    //

    if ( !_tcpauth.QueryUserName( &_strUserName ) ||
         !_strUnmappedUserName.Copy( _strUserName ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[OnAuthorization] Getting username failed, error %d\n",
                    GetLastError() ));

        return FALSE;
    }

    return TRUE;
}



BOOL
HTTP_REQ_BASE::CheckForBasicAuthenticationHeader(
    LPSTR pszHeaders
    )
/*++

Routine Description:

    Parse header for realm info in Basic authentication scheme

Arguments:

    pszHeaders - headers to parse

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    UINT cHeaders = strlen( pszHeaders );
    UINT cLine;
    UINT cToNext;
    LPSTR pEOL;
    int ch;

    while ( cHeaders )
    {
        if ( (pEOL = (LPSTR)memchr( pszHeaders, '\n', cHeaders)) == NULL )
        {
            cLine = cHeaders;
            cToNext = cHeaders;
        }
        else
        {
            cLine = DIFF(pEOL - pszHeaders);
            cToNext = cLine + 1;
            if ( pEOL != pszHeaders && pEOL[-1] == '\r' )
            {
                --cLine;
            }
        }

        if ( !_strnicmp( pszHeaders,
                    "WWW-Authenticate",
                    sizeof("WWW-Authenticate")-1 ) )
        {
            LPSTR pS = pszHeaders + sizeof("WWW-Authenticate:") - 1;
            UINT cS = cLine - (sizeof("WWW-Authenticate:") - 1);
            while ( cS && isspace( (UCHAR)(*pS) ) )
            {
                ++pS;
                --cS;
            }
            if ( !_strnicmp( pS, "basic", sizeof("basic")-1 ) )
            {
                while ( cS && isalpha( (UCHAR)(*pS) ) )
                {
                    ++pS;
                    --cS;
                }
                while ( cS && !isalpha( (UCHAR)(*pS) ) )
                {
                    ++pS;
                    --cS;
                }

                if ( !_strnicmp( pS, "realm", sizeof("realm")-1 ) )
                {
                    // check if realm value specified

                    while ( cS && *pS != '=' )
                    {
                        ++pS;
                        --cS;
                    }

#if 0
                    if ( cS )
                    {
                        ++pS;
                        --cS;

                        // locate start of realm value

                        while ( cS )
                        {
                            --cS;
                            if ( *pS++ == '"' )
                            {
                                break;
                            }
                        }
                        LPSTR pR = pS;

                        // locate end of realm value

                        while ( cS && *pS != '"' )
                        {
                            ++pS;
                            --cS;
                        }

                        ch = *pS;
                        *pS = '\0';
                        // pR contains zero-delimited realm
                        *pS = ch;
                    }
#endif
                    _fBasicRealm = TRUE;
                }
                return TRUE;
            }
        }

        cHeaders -= cToNext;
        pszHeaders += cToNext;
    }

    return FALSE;
}


BOOL
HTTP_REQ_BASE::LogonAsSystem(
    VOID
    )
/*++

Routine Description:

    Associate the system account with the current request
    AUTH_TYPE and LOGON_USER are set to "SYSTEM" if success

Arguments:

    None

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HANDLE                  hTok;

    if ( _fLoggedOn )
    {
        if ( _fAnonymous ) {

            QueryW3StatsObj()->DecrCurrentAnonymousUsers();
        } else {
            QueryW3StatsObj()->DecrCurrentNonAnonymousUsers();
        }
    }

    ResetAuth( FALSE );

    if ( !IISDuplicateTokenEx( g_hSysAccToken,
            TOKEN_ALL_ACCESS,
            NULL,
            SecurityImpersonation,
            TokenPrimary,
            &hTok ))
    {
        return FALSE;
    }

    if ( _tcpauth.SetAccessToken( hTok, NULL ) )
    {
        _fLoggedOn               = TRUE;
        _fMappedAcct             = TRUE;
        _fAuthSystem             = TRUE;

        _HeaderList.FastMapCancel( HM_AUT );
        _HeaderList.FastMapCancel( HM_CON );
        SetKeepConn( FALSE );

        _strAuthType.Copy( PSZ_KWD_SYSTEM, LEN_PSZ_KWD_SYSTEM);
        _strUserName.Copy( PSZ_KWD_SYSTEM, LEN_PSZ_KWD_SYSTEM);
        _strPassword.Reset();

        QueryW3StatsObj()->IncrNonAnonymousUsers();

        //_strUnmappedUserName will contains real user name

        _fSingleRequestAuth = TRUE;

        return TRUE;
    }
    else
    {
        CloseHandle( hTok );
    }

    return FALSE;
}


GENERIC_MAPPING VrootFileGenericMapping =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};


VOID
HTTP_REQ_BASE::ReleaseCacheInfo(
    VOID
    )
/*++
    Description:

        Release ptr to URI & metadata cache

    Arguments:
        None

    Returns:
        Nothing

--*/
{
    if ( g_fGetBackTraces )
    {
        ULONG            ulHash;
        
        RtlWalkFrameChain( m_ppvFrames,
                           MAX_BACKTRACE_FRAMES,
                           0 );
    } 

    if ( _pURIInfo != NULL)
    {

        if (_pURIInfo->bIsCached)
        {
            TsCheckInCachedBlob( _pURIInfo );
        } else
        {
            TsFree(QueryW3Instance()->GetTsvcCache(), _pURIInfo );
        }

    }
    else
    {
        if (_pMetaData != NULL)
        {
            TsFreeMetaData(_pMetaData->QueryCacheInfo() );
        }
    }

    _pMetaData = NULL;
    _pURIInfo = NULL;
}


BOOL
HTTP_REQ_BASE::VrootAccessCheck(
    PW3_METADATA    pMetaData,
    DWORD           dwDesiredAccess
    )
/*++
    Description:

        Check that the current access token have access to the
        ACL of the current virtual root

    Arguments:
        pMetaData - points to metadata object
        dwDesiredAccess - access right, e.g. FILE_GENERIC_READ

    Returns:
        TRUE if access granted, FALSE if access denied

--*/
{
    DWORD         dwGrantedAccess;
    BYTE          PrivSet[400];
    DWORD         cbPrivilegeSet = sizeof(PrivSet);
    BOOL          fAccessGranted;

    if ( pMetaData && pMetaData->QueryAcl() &&
         (!::AccessCheck( pMetaData->QueryAcl(),
                          QueryImpersonationHandle(),
                          dwDesiredAccess,
                          &VrootFileGenericMapping,
                          (PRIVILEGE_SET *) &PrivSet,
                          &cbPrivilegeSet,
                          &dwGrantedAccess,
                          &fAccessGranted ) ||
          !fAccessGranted) )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    return TRUE;
}

BOOL
ReadEntireFile(
    CHAR        *pszFileName,
    TSVC_CACHE  &Cache,
    HANDLE      User,
    BUFFER      *pBuf,
    DWORD       *pdwBytesRead
    )
/*++
    Description:

        Read an entire file into the specified buffer.

    Arguments:
        pszFileName - File name of file to be read.
        Cache       - Tsunami cache info for file read.
        User        - User token for opening the file.
        pBuf        - Pointer to buffer to be read into.

    Returns:
        TRUE if we read it, FALSE otherwise.

--*/
{
    HANDLE                  hFile;
    SECURITY_ATTRIBUTES     sa;
    DWORD                   dwFileSize, dwFileSizeHigh;
    DWORD                   dwCurrentBufSize;
    BOOL                    bFileReadSuccess;
    DWORD                   dwBytesRead;
    const                   CHAR    *pszFile[2];
    DWORD                   dwError;
    CHAR                    szError[17];

    dwError = NO_ERROR;

    if( !g_fIsWindows95 && !::ImpersonateLoggedOnUser( User ) ) {
        dwError = GetLastError();
        hFile = INVALID_HANDLE_VALUE;
    } else {
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle = FALSE;

        hFile = CreateFile(
                    pszFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    &sa,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

        if( hFile == INVALID_HANDLE_VALUE ) {
            dwError = GetLastError();
        }

        if ( !g_fIsWindows95 ) {
            ::RevertToSelf();
        }
    }

    if( hFile == INVALID_HANDLE_VALUE ) {
        DWORD           dwEventType;
        WORD            dwParamCount;

        ASSERT( dwError != NO_ERROR );

        pszFile[0] = pszFileName;
        dwParamCount = 1;

        // Couldn't read the error file for some reason, so just bail out
        // now.

        if (dwError == ERROR_ACCESS_DENIED)
        {

            // Couldn't read the file due to lack of access. Log an event,
            // and map the error to invalid configuration to prevent
            // us from initiating an HTTP authentication sequence.


            dwEventType = W3_EVENT_CANNOT_READ_FILE_SECURITY;

            dwError = ERROR_INVALID_PARAMETER;


        }
        else
        {
            if ( dwError == ERROR_FILE_NOT_FOUND ||
                 dwError == ERROR_PATH_NOT_FOUND
               )
            {
                dwEventType = W3_EVENT_CANNOT_READ_FILE_EXIST;
            }
            else
            {

                dwEventType = W3_EVENT_CANNOT_READ_FILE;
                _itoa( dwError, szError, 10 );
                pszFile[1] = szError;
                dwParamCount = 2;

            }
        }

        g_pInetSvc->LogEvent(  dwEventType,
                               dwParamCount,
                               pszFile,
                               0 );

        SetLastError(dwError);

        return FALSE;
    }

    // Query the size. If it's too large, fail.

    dwFileSize = ::GetFileSize( hFile, &dwFileSizeHigh );

    if (dwFileSizeHigh != 0 ||
        dwFileSize > MAX_CUSTOM_ERROR_FILE_SIZE)
    {
        CloseHandle( hFile );

        pszFile[0] = pszFileName;
        pszFile[1] = CONST_TO_STRING(MAX_CUSTOM_ERROR_FILE_SIZE);
        g_pInetSvc->LogEvent(  W3_EVENT_CANNOT_READ_FILE_SIZE,
                               2,
                               pszFile,
                               0 );

        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    dwCurrentBufSize = strlen( (CHAR *)pBuf->QueryPtr() );

    if ( !pBuf->Resize(dwCurrentBufSize + dwFileSize + 1) )
    {
        // Couldn't resize the buffer, so fail.

        CloseHandle( hFile );

        pszFile[0] = pszFileName;
        g_pInetSvc->LogEvent(  W3_EVENT_CANNOT_READ_FILE_MEMORY,
                               1,
                               pszFile,
                               0 );

        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    // Now read the file.

    bFileReadSuccess = ::ReadFile( hFile,
                                   (CHAR *)pBuf->QueryPtr() + dwCurrentBufSize,
                                   dwFileSize,
                                   &dwBytesRead,
                                   NULL
                                   );

    dwError = GetLastError();

    // We're done with the file, so close the handle now.

    CloseHandle( hFile );

    if (!bFileReadSuccess || (dwBytesRead != dwFileSize))
    {
        // There was some sort of error in the file read, so bail out.

        _itoa( dwError, szError, 10 );

        pszFile[0] = pszFileName;
        pszFile[1] = szError;

        g_pInetSvc->LogEvent(  W3_EVENT_CANNOT_READ_FILE,
                               2,
                               pszFile,
                               0 );
        return FALSE;
    }

    CHAR *Temp = (CHAR *)pBuf->QueryPtr();
    *(Temp + dwCurrentBufSize + dwBytesRead) = '\0';

    *pdwBytesRead = dwBytesRead;

    return TRUE;
}

BOOL
HTTP_REQ_BASE::CheckCustomError(
    BUFFER  *pBuf,
    DWORD   dwErr,
    DWORD   dwSubError,
    BOOL    *pfFinished,
    DWORD   *pdwMsgSize,
    BOOL    bCheckURL
    )
/*++
    Description:

        Check for a custom error on message or URL for a specific error. If
        we find an custom error message, fill in the buffer with the message.
        If we find a URL, we'll reprocess the URL to handle the error.

    Arguments:
        pBuf        - Pointer to buffer to fill in with error message.
        dwErr       - Error code to be checked.
        pfFinished  - Pointer to boolean. Set to TRUE if no further processing
                        is required, FALSE otherwise. If it's set to FALSE then
                        the caller still needs to send the buffer. Valid iff
                        this function returns TRUE.
        bCheckURL   - TRUE if we are to check for a URL.

    Returns:
        TRUE if there was a custom error for this error, FALSE otherwise.

--*/
{
    PCUSTOM_ERROR_ENTRY     pErrEntry;
    DWORD                   dwLogHttpResponse;
    DWORD                   dwLogWinError;


    // First make sure we're not already processing a custom error.

    if (_bProcessingCustomError)
    {
        return FALSE;
    }

    // Make sure we've got MetaData.
    //
    // CODEWORK - Fix this so we try and find the metadata for the the root VR
    // in this case. We'll need to fix FindAndReferenceInstance etc. We'll
    // still have to fail if we don't have an instance.

    if (QueryMetaData() == NULL)
    {
        return FALSE;
    }

    // Now lookup the error code to see if we have a custom error.

    pErrEntry = QueryMetaData()->LookupCustomError(dwErr, dwSubError);

    if (pErrEntry == NULL)
    {
        // No custom error, return FALSE.

        return FALSE;
    }

    if (pErrEntry->IsFileError())
    {
        STR         strMimeType;
        DWORD       dwCurrentSize;
        DWORD       dwSizeNeeded;
        CHAR        *pszHeader;

        if (!SelectMimeMappingForFileExt(g_pInetSvc,
                                        (const CHAR *)pErrEntry->QueryErrorFileName(),
                                        &strMimeType
                                        ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "CheckCustomError: Unable to get MIME type for %s\n",
                    pErrEntry->QueryErrorFileName()));

            return FALSE;
        }

        dwCurrentSize = strlen((CHAR *)pBuf->QueryPtr());
        dwSizeNeeded = dwCurrentSize + 1 + sizeof("Content-Type: ") - 1 +
            strMimeType.QueryCB() + sizeof("\r\n\r\n") - 1;

        if ((pBuf->QuerySize() < dwSizeNeeded) && !pBuf->Resize(dwSizeNeeded))
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "CheckCustomError: Buffer too small and unable to resize\n"));

            return FALSE;

        }

        pszHeader = (CHAR *)pBuf->QueryPtr() + dwCurrentSize;

        APPEND_PSZ_HEADER(pszHeader, "Content-Type: ", strMimeType.QueryStr(), "\r\n\r\n");

        if (!ReadEntireFile(pErrEntry->QueryErrorFileName(),
                            QueryW3Instance()->GetTsvcCache(),
                            g_hSysAccToken,
                            pBuf,
                            pdwMsgSize))
        {
            // Have to undo the copy in we did.

            pszHeader = (CHAR *)pBuf->QueryPtr() + dwCurrentSize;
            *pszHeader = '\0';

            return FALSE;
        }

        // Otherwise it worked.

        *pfFinished = FALSE;
        return TRUE;


    }
    else
    {
        // This must be a custom URL. Create a new URL from the custom error
        // that includes the error code as a parameter, and reprocess the URL.

        HTTP_REQUEST    *pReq;
        CHAR            *Temp = (CHAR *)pBuf->QueryPtr();
        STR             strNewURL;
        CHAR            szError[20];
        enum CLIENT_CONN_STATE OldConnState;
        CHAR            *pszHostName;
        DWORD           cbHostNameLength;

        if (!bCheckURL)
        {
            return FALSE;
        }

        if (!strNewURL.Copy( (const CHAR *)pErrEntry->QueryErrorURL() ) )
        {
            return FALSE;
        }

        //
        // Remote URLs are not allowed as custom errors.
        //

        if ( !_strnicmp(strNewURL.QueryStr(),"http://",sizeof("http://")-1) ||
             !_strnicmp(strNewURL.QueryStr(),"https://",sizeof("https://") - 1) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "CheckCustomError: URL is not Local. Returnig Failure\n"));
                    
            return FALSE;
        }
        
        if (!strNewURL.Append("?", sizeof("?") - 1))
        {
            return FALSE;
        }

        _itoa(dwErr, szError, 10);

        if (!strNewURL.Append( (const CHAR *)szError) )
        {
            return FALSE;
        }

        if (!strNewURL.Append(";", sizeof(";") - 1))
        {
            return FALSE;
        }

        pszHostName = QueryHostAddr();
        cbHostNameLength = strlen(pszHostName);

        if (cbHostNameLength != 0)
        {
            if (!strNewURL.Append("http://", sizeof("http://") -1) ||
                !strNewURL.Append(pszHostName, cbHostNameLength))
            {
                return FALSE;
            }
        }

        if (!strNewURL.Append(_strRawURL))
        {
            return FALSE;
        }

        *Temp = '\0';

        _bProcessingCustomError = TRUE;

        SetNoCache();
        SetSendVary();

        pReq = (HTTP_REQUEST *)this;

        pReq->CloseGetFile();

        //
        // Need to set the connection state to processing, because we might be
        // disconnecting right now. Save the old state in case the reprocess
        // fails.

        OldConnState = QueryClientConn()->QueryState();

        QueryClientConn()->SetState(CCS_PROCESSING_CLIENT_REQ);

        dwLogHttpResponse = QueryLogHttpResponse();
        dwLogWinError = QueryLogWinError();

        if ( !pReq->ReprocessURL(   strNewURL.QueryStr(),
                                    HTV_GET ))
        {
            //
            // if we failed & state is DOVERB restore to DONE to prevent
            // response from being generated twice (once here and once after doverb
            // processing in DoWork() )
            //

            if ( QueryState() == HTR_DOVERB )
            {
                SetState( HTR_DONE, dwLogHttpResponse, dwLogWinError );
            }

            QueryClientConn()->SetState(OldConnState);
            return FALSE;
        }

        *pfFinished = TRUE;
        return TRUE;
    }

}


BOOL
HTTP_REQ_BASE::IsClientProxy(
    VOID
    )
/*++
    Description:

        Check if request was issued by a proxy, as determined by following rules :
        - "Via:" header is present (HTTP/1.1)
        - "Forwarded:" header is present (some HTTP/1.0 implementations)
        - "User-Agent:" contains "via ..." (CERN proxy)

    Arguments:
        None

    Returns:
        TRUE if client request was issued by proxy

--*/
{
    LPSTR   pUA;
    UINT    cUA;
    LPSTR   pEnd;


    if ( _HeaderList.FastMapQueryValue( HM_VIA ) != NULL ||
         _HeaderList.FastMapQueryValue( HM_FWD ) != NULL )
    {
        return TRUE;
    }

    if ( !IsAtLeastOneOne() &&
         (pUA = (LPSTR)_HeaderList.FastMapQueryValue( HM_UAT )) != NULL )
    {
        cUA = strlen( pUA );
        pEnd = pUA + cUA - (sizeof("ia ")-1);

        //
        // scan for "[Vv]ia[ :]" in User-Agent: header
        //

        while ( pUA < pEnd )
        {
            if ( *pUA == 'V' || *pUA == 'v' )
            {
                if ( pUA[1] == 'i' &&
                     pUA[2] == 'a' &&
                     (pUA[3] == ' ' || pUA[3] == ':') )
                {
                    return TRUE;
                }
            }
            ++pUA;
        }
    }

    return FALSE;
}

W3_SERVER_INSTANCE* HTTP_REQ_BASE::QueryW3InstanceAggressively( VOID ) const
/*++
    Description:

        This tries "aggressively" to find the instance associated with this request.
        If the instance is already set, it returns that; otherwise, it tries to find
        an instance matching the IP/Port # for the connection associated with this
        request. 

        This is useful for requests that won't use Host headers eg SSL requests, where
        it may be necessary to determine the instance for a request before it's been
        set by the URL-parsing code.

        Note that the function -DOES NOT- update the _pW3Instance member.

    Arguments:
        None

    Returns:
       Pointer to associated instance if found, NULL if no instance was found.

--*/
{
    W3_SERVER_INSTANCE *pInstance = NULL;

    if ( _pW3Instance )
    {
        pInstance = _pW3Instance;
    }
    else
    {
        BOOL fExceeded ;
        
        //
        // Try specific (IP, port)  first, then try to wildcard the IP address. 
        // Port # can't be wildcarded.
        //
        
        IIS_ENDPOINT *pEndPoint = g_pInetSvc->FindAndReferenceEndpoint( 
                                                         _pClientConn->QueryPort(),
                                                         _pClientConn->QueryLocalIPAddress(),
                                                         FALSE,
                                                         FALSE );
        
        if ( !pEndPoint )
        {
            pEndPoint = g_pInetSvc->FindAndReferenceEndpoint( _pClientConn->QueryPort(),
                                                              0,
                                                              FALSE,
                                                              FALSE );
        }

        if ( pEndPoint )
        {
            pInstance = (W3_SERVER_INSTANCE *) pEndPoint->FindAndReferenceInstance(       
                                                             NULL,
                                                             _pClientConn->QueryLocalIPAddress(),
                                                             &fExceeded );
            
            //
            // FindAndReferenceInstance increments # of connections, and we're not
            // using up a connection
            //
            if ( pInstance )
            {
                pInstance->DecrementCurrentConnections(); 
                
                pInstance->Dereference();
                

            }
            pEndPoint->Dereference();
        }
    }

    return ( pInstance );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\caldbg.h ===
/*
 *	C A L D B G . H
 *
 *	Debugging support header
 *	Support functions are implemented in CALDBG.C.
 *
 *	Copyright 1986-1997 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _CALDBG_H_
#define _CALDBG_H_

/*
 * Debugging Macros -------------------------------------------------------
 *
 *		IFDBG(x)		Results in the expression x if DEBUG is defined, or
 *						to nothing if DEBUG is not defined
 *
 *		IFNDBG(x)		Results in the expression x if DEBUG is not defined,
 *						or to nothing if DEBUG is defined
 *
 *		Unreferenced(a) Causes a to be referenced so that the compiler
 *						doesn't issue warnings about unused local variables
 *						which exist but are reserved for future use (eg
 *						ulFlags in many cases)
 */
#if defined(DEBUG)
#define IFDBG(x)			x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)			x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN		extern "C" {
#define EXTERN_C_END		}
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

/*
 *	 Assert Macros ------------------------------------------------------------
 *
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.	 OK'ing an assert traps
 *						into the debugger.
 *
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 */
#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))

#define Assert(t)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))

#define SideAssert(t)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)

/*
 *	 Trace Macros -------------------------------------------------------------
 *
 *		DebugTrace			Use for arbitrary formatted output. It
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#define DEBUG_WSZ			__wsz
#define MK_DEBUG_WSZ(_s,_c)												\
	LPWSTR __wsz;														\
	__wsz = static_cast<LPWSTR>(_alloca(((_c) + 1) * sizeof(WCHAR)));	\
	wcsncpy (__wsz, _s, (_c) + 1);										\
	__wsz[_c] = 0														\

#else
#define IFTRACE(x)			0
#define DebugTrace
#define DEBUG_WSZ			NULL
#define MK_DEBUG_WSZ(_s,_c)
#endif

/*	------------------------------------------------------------------------
 *
 *	.INI triggered traces
 */

#ifdef DEBUG
#define DEFINE_TRACE(trace)		int g_fTrace##trace
#define DECLARE_TRACE(trace)	extern DEFINE_TRACE(trace)
#define DO_TRACE(trace)			!g_fTrace##trace ? 0 : DebugTraceFn
#define INIT_TRACE(trace)		g_fTrace##trace = GetPrivateProfileInt( gc_szDbgTraces, #trace, FALSE, gc_szDbgIni )
//	Convenience macro for DEBUG code.  Will cause an error on non-debug builds.
#define DEBUG_TRACE_TEST(trace)	g_fTrace##trace
#else
#define DEFINE_TRACE(trace)
#define DECLARE_TRACE(trace)
#define DO_TRACE(trace)			DebugTrace
#define INIT_TRACE(trace)
//#define DEBUG_TRACETEST(trace)	// Purposefully cause an error on non-debug builds
#endif

/* Debugging Functions ---------------------------------------------------- */

#define EXPORTDBG

EXTERN_C_BEGIN

INT EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...);
VOID EXPORTDBG __cdecl GetCallStack (DWORD *pdwCaller, int cSkip, int cFind);
BOOL EXPORTDBG __cdecl GetSymbolName (DWORD dwAddr, LPSTR szMod, LPSTR szFn, DWORD * pdwDisp);

EXTERN_C_END

//	Symbolic names ------------------------------------------------------------
//
#include <imagehlp.h>
enum { CB_SYM_MAX = 256 };
enum { CB_MOD_MAX = 64 };
enum { NCALLERS	= 10 };

EXTERN_C_BEGIN

typedef BOOL (__stdcall SYMINITIALIZE) (HANDLE hProc, LPSTR lpszSynPath, BOOL fInvadeProc);
typedef BOOL (__stdcall SYMGETMODULE) (HANDLE hProc, DWORD dwAddr, PIMAGEHLP_MODULE pmod);
typedef BOOL (__stdcall SYMGETSYMBOL) (HANDLE hProc, DWORD dwAddr, PDWORD pdwDisp, PIMAGEHLP_SYMBOL psym);
typedef BOOL (__stdcall SYMUNDECORATE) (PIMAGEHLP_SYMBOL psym, LPSTR lpszUnDecName, DWORD cbBuf);

EXTERN_C_END

/* Debugging Strings ------------------------------------------------------ */

EXTERN_C_BEGIN

//	Inifile name -- must be set by calling code!
extern const CHAR gc_szDbgIni[];

//	Strings set in caldbg.c for use in calling code.
extern const CHAR gc_szDbgAssertLeaks[];
extern const CHAR gc_szDbgAssertCloses[];
extern const CHAR gc_szDbgDebugTrace[];
extern const CHAR gc_szDbgEventLog[];
extern const CHAR gc_szDbgGeneral[];
extern const CHAR gc_szDbgLeakLogging[];
extern const CHAR gc_szDbgLogFile[];
extern const CHAR gc_szDbgRecordResources[];
extern const CHAR gc_szDbgSymbolicDumps[];
extern const CHAR gc_szDbgTraces[];
extern const CHAR gc_szDbgUseVirtual[];
extern const CHAR gc_szDbgUseExchmem[];

EXTERN_C_END

/* Virtual Allocations ---------------------------------------------------- */

EXTERN_C_BEGIN

VOID * EXPORTDBG __cdecl VMAlloc(ULONG);
VOID * EXPORTDBG __cdecl VMAllocEx(ULONG, ULONG);
VOID * EXPORTDBG __cdecl VMRealloc(VOID *, ULONG);
VOID * EXPORTDBG __cdecl VMReallocEx(VOID *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl VMGetSize(VOID *);
ULONG EXPORTDBG __cdecl VMGetSizeEx(VOID *, ULONG);
VOID EXPORTDBG __cdecl VMFree(VOID *);
VOID EXPORTDBG __cdecl VMFreeEx(VOID *, ULONG);

EXTERN_C_END

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\scale\iis30\perfdll.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfdll.cxx

    This trivial DLL grabs statistics from the w3 server

    FILE HISTORY:
        t-bilala    04-01-97    Leveraged from perfw3.cxx in \perfmon
*/

#include <windows.h>
#include <lm.h>
#include <string.h>
#include <stdlib.h>
#include <ole2.h>
#include "inetinfo.h"
#include "perfdll.h"

//
//  Public prototypes.
//

PerfFunction        GetPerformanceData;

DWORD
GetStatisticsValue(
    IN LPSTR                pszValue,
    IN W3_STATISTICS_0 *    pW3Stats
);



/*******************************************************************

    NAME:       GetPerformanceData

    SYNOPSIS:   Get performance counter value from web server.

    ENTRY:      pszValue - The name of the value to retrieve
                pszServer - Server name
                
    RETURNS:    DWORD - value of performance counter 

********************************************************************/
DWORD
GetPerformanceData(
    IN LPSTR         pszValue,
    IN LPSTR         pszServer
)
{
    W3_STATISTICS_0         * pW3Stats = NULL;
    NET_API_STATUS          neterr;
    DWORD                   dwValue;
    WCHAR                   achBuffer[ MAX_PATH ];

    if ( pszValue == NULL )
    {
        return 0;
    }

    if ( pszServer != NULL )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszServer,
                                   -1,
                                   achBuffer,
                                   MAX_PATH ) )
        {
            return FALSE;
        }
    }
    
    neterr = W3QueryStatistics(
                            achBuffer,
                            0,
                            (LPBYTE *)&pW3Stats );

    if( neterr != NERR_Success )
    {
        CHAR    achBuffer[ 256 ];
        
        wsprintf( achBuffer,
                  "Error was %d\n",
                  neterr );

        OutputDebugString( achBuffer );

        dwValue = 0;
    }
    else
    {
        dwValue = GetStatisticsValue( pszValue, pW3Stats );
    }

    if ( pW3Stats != NULL )
    {
        MIDL_user_free( pW3Stats );
    }

    return dwValue;
    
}

DWORD
GetStatisticsValue(
    IN LPSTR                pszValue,
    IN W3_STATISTICS_0 *    pW3Stats
)
{
    if ( !_stricmp( pszValue, "TotalUsers" ) )
    {
        return pW3Stats->TotalAnonymousUsers + pW3Stats->TotalNonAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "TotalFilesSent" ) )
    {
        return pW3Stats->TotalFilesSent;
    }
    else if ( !_stricmp( pszValue, "TotalFilesReceived" ) )
    {
        return pW3Stats->TotalFilesReceived;
    }
    else if ( !_stricmp( pszValue, "CurrentAnonymousUsers" ) )
    {
        return pW3Stats->CurrentAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "CurrentNonAnonymousUsers" ) )
    {
        return pW3Stats->CurrentNonAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "TotalAnonymousUsers" ) )
    {
        return pW3Stats->TotalAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "MaxAnonymousUsers" ) )
    {
        return pW3Stats->MaxAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "MaxNonAnonymousUsers" ) )
    {
        return pW3Stats->MaxNonAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "CurrentConnections" ) )
    {
        return pW3Stats->CurrentConnections;
    }
    else if ( !_stricmp( pszValue, "MaxConnections" ) )
    {
        return pW3Stats->MaxConnections;
    }
    else if ( !_stricmp( pszValue, "ConnectionAttempts" ) )
    {
        return pW3Stats->ConnectionAttempts;
    }
    else if ( !_stricmp( pszValue, "LogonAttempts" ) )
    {
        return pW3Stats->LogonAttempts;
    }
    else if ( !_stricmp( pszValue, "TotalGets" ) )
    {
        return pW3Stats->TotalGets;
    }
    else if ( !_stricmp( pszValue, "TotalPosts" ) )
    {
        return pW3Stats->TotalPosts;
    }
    else if ( !_stricmp( pszValue, "TotalHeads" ) )
    {
        return pW3Stats->TotalHeads;
    }
    else if ( !_stricmp( pszValue, "TotalOthers" ) )
    {
        return pW3Stats->TotalOthers;
    }
    else if ( !_stricmp( pszValue, "TotalCGIRequests" ) )
    {
        return pW3Stats->TotalCGIRequests;
    }
    else if ( !_stricmp( pszValue, "TotalBGIRequests" ) )
    {
        return pW3Stats->TotalBGIRequests;
    }
    else if ( !_stricmp( pszValue, "TotalNotFoundErrors" ) )
    {
        return pW3Stats->TotalNotFoundErrors;
    }
    else if ( !_stricmp( pszValue, "CurrentCGIRequests" ) )
    {
        return pW3Stats->CurrentCGIRequests;
    }
    else if ( !_stricmp( pszValue, "CurrentBGIRequests" ) )
    {
        return pW3Stats->CurrentBGIRequests;
    }
    else if ( !_stricmp( pszValue, "MaxCGIRequests" ) )
    {
        return pW3Stats->MaxCGIRequests;
    }
    else if ( !_stricmp( pszValue, "MaxBGIRequests" ) )
    {
        return pW3Stats->MaxBGIRequests;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\connect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    connect.cxx

    This module contains the connection accept routine called by the connection
    thread.


    FILE HISTORY:
        Johnl       08-Aug-1994 Lifted from FTP server

*/


#include "w3p.hxx"

//
//  Private prototypes.
//

BOOL
CreateClient(
        IN PCLIENT_CONN_PARAMS  ClientParam
        );

BOOL
SendError(
    SOCKET socket,
    DWORD  ids
    );

//
//  Private functions.
//

/*******************************************************************

    NAME:       W3OnConnect

    SYNOPSIS:   Handles the incoming connection indication from the
                connection thread


    ENTRY:      sNew - New client socket

    HISTORY:
        KeithMo     09-Mar-1993 Created.
        Johnl       02-Aug-1994 Reworked from FTP server

********************************************************************/

VOID W3OnConnect( SOCKET        sNew,
                  SOCKADDR_IN * psockaddr,       //Should be SOCKADDR *
                  PVOID         pEndpointContext,
                  PVOID         pAtqEndpointObject )
{

    PIIS_ENDPOINT      pEndpoint    = (PIIS_ENDPOINT)pEndpointContext;
    INT                cbAddr       = sizeof( sockaddr );

    CLIENT_CONN_PARAMS clientParams;
    SOCKADDR           sockaddr;

    if ( !((W3_IIS_SERVICE*)g_pInetSvc)->GetReferenceCount() )
    {
        return;
    }
    
    W3_IIS_SERVICE::ReferenceW3Service( g_pInetSvc );

    DBG_ASSERT( sNew != INVALID_SOCKET );

    g_pW3Stats->IncrConnectionAttempts();

    IF_DEBUG( SOCKETS )
    {

        DBGPRINTF(( DBG_CONTEXT,
                   "connect received from %s, socket = %d\n",
                    inet_ntoa( psockaddr->sin_addr ),
                    sNew ));
    }

    if ( getsockname( sNew,
                      &sockaddr,
                      &cbAddr ) != 0 )
    {
        //SendError( sNew, IDS_HTRESP_DENIED );
        goto error_exit;
    }

    //
    //  We've got a new connection.  Add this to the work list
    //

    clientParams.sClient = sNew;
    clientParams.pEndpointObject = pAtqEndpointObject;
    clientParams.pAtqContext = NULL;
    clientParams.pAddrLocal = &sockaddr;
    clientParams.pAddrRemote = (PSOCKADDR)psockaddr;
    clientParams.pvInitialBuff = NULL;
    clientParams.cbInitialBuff = 0;
    clientParams.pEndpoint = (PIIS_ENDPOINT)pEndpointContext;

    if ( CreateClient( &clientParams ) )
    {
        W3_IIS_SERVICE::DereferenceW3Service( g_pInetSvc );
        return;
    }

error_exit:

    W3_IIS_SERVICE::DereferenceW3Service( g_pInetSvc );
    CloseSocket( sNew );

} // W3OnConnect



VOID
W3OnConnectEx(
    VOID *        patqContext,
    DWORD         cbWritten,
    DWORD         err,
    OVERLAPPED *  lpo
    )
{
    BOOL       fAllowConnection    = FALSE;
    PVOID      pvBuff;
    SOCKADDR * psockaddrLocal;
    SOCKADDR * psockaddrRemote;
    SOCKET     sNew;
    PIIS_ENDPOINT pEndpoint;
    PW3_SERVER_INSTANCE pInstance;
    CLIENT_CONN_PARAMS clientParams;

    if ( err || !lpo )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[W3OnConnectEx] Completion failed with error %d, Atq context %lx\n",
                    err,
                    patqContext ));

        AtqCloseSocket( (PATQ_CONTEXT) patqContext, FALSE );
        AtqFreeContext( (PATQ_CONTEXT) patqContext, TRUE );
        return;
    }

    if ( !((W3_IIS_SERVICE*)g_pInetSvc)->GetReferenceCount() )
    {
        return;
    }
    
    W3_IIS_SERVICE::ReferenceW3Service( g_pInetSvc );

    g_pW3Stats->IncrConnectionAttempts();

    IF_DEBUG( SOCKETS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[W3OnConnectEx] connection received\n" ));
    }

    //
    // Get AcceptEx parameters
    //

    AtqGetAcceptExAddrs( (PATQ_CONTEXT) patqContext,
                         &sNew,
                         &pvBuff,
                         (PVOID*)&pEndpoint,
                         &psockaddrLocal,
                         &psockaddrRemote );

    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[W3OnConnectEx] New connection, AtqCont = %lx, buf = %lx, endp %x written = %d\n",
                    patqContext,
                    pvBuff,
                    pEndpoint,
                    cbWritten ));


    }

    //
    //  Set the timeout for future IOs on this context
    //

    AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                       ATQ_INFO_TIMEOUT,
                       W3_DEF_CONNECTION_TIMEOUT );

    //
    //  We've got a new connection.  Add this to the work list
    //

    clientParams.sClient = sNew;
    clientParams.pEndpointObject = NULL;
    clientParams.pAtqContext = (PATQ_CONTEXT)patqContext;
    clientParams.pAddrLocal = psockaddrLocal;
    clientParams.pAddrRemote = psockaddrRemote;
    clientParams.pvInitialBuff = pvBuff;
    clientParams.cbInitialBuff = cbWritten;
    clientParams.pEndpoint = pEndpoint;

    if ( CreateClient( &clientParams ) )
    {
        W3_IIS_SERVICE::DereferenceW3Service( g_pInetSvc );
        return;
    }

    //
    //  This will also close the socket
    //

    DBG_REQUIRE( AtqCloseSocket( (PATQ_CONTEXT) patqContext, FALSE ));
    AtqFreeContext( (PATQ_CONTEXT) patqContext, TRUE );

    W3_IIS_SERVICE::DereferenceW3Service( g_pInetSvc );

    return;

} // W3OnConnectEx


/*******************************************************************

    NAME:       CreateClient

    SYNOPSIS:   Creates a new connection object that manages the
                client requests

    ENTRY:      sNew      - New client socket



    HISTORY:
        KeithMo     09-Mar-1993 Created.
        Johnl       02-Aug-1994 Reworked from FTP server

********************************************************************/

BOOL
CreateClient(
    IN PCLIENT_CONN_PARAMS  ClientParam
    )
{
    APIERR              err = NO_ERROR;
    CLIENT_CONN        * pConn = NULL;
    BOOL                fGranted;
    PATQ_CONTEXT        patqContext = ClientParam->pAtqContext;

    pConn = CLIENT_CONN::Alloc( ClientParam );

    if( pConn == NULL ||
        !pConn->IsValid() )
    {
        err = pConn ? GetLastError() : ERROR_NOT_ENOUGH_MEMORY;

        if ( patqContext )
        {
            DBG_REQUIRE( AtqCloseSocket( patqContext, TRUE ));            
        }
    }
    else
    {
        //
        //  We only have a context at this point if we're using AcceptEx
        //

        if ( patqContext )
        {
            //
            // Associate the Client connection object with this socket handle
            // for future completions
            //

            AtqContextSetInfo( patqContext,
                               ATQ_INFO_COMPLETION_CONTEXT,
                               (ULONG_PTR) pConn );

            IF_DEBUG( CONNECTION )
            {
                DBGPRINTF(( DBG_CONTEXT,
                           "[CreateClient] Setting Atq context %lx context to Conn object %lx\n",
                            patqContext,
                            pConn ));
            }
        }

        //
        //  Kickstart the process.  This will do an async read to get the
        //  client's header or it will start processing the receive buffer
        //  if AcceptEx is being used.
        //

        ReferenceConn( pConn );
        DBG_REQUIRE( pConn->DoWork( 0,
                                    NO_ERROR,
                                    NULL ));
        DereferenceConn( pConn );
        return TRUE;
    }

    const CHAR * apszSubStrings[1];

    DBG_ASSERT( ClientParam->pAddrRemote->sa_family == AF_INET );
    apszSubStrings[0] = inet_ntoa( ((SOCKADDR_IN *)ClientParam->pAddrRemote)->sin_addr );

    g_pInetSvc->LogEvent( W3_EVENT_CANNOT_CREATE_CLIENT_CONN,
                           1,
                           apszSubStrings,
                           err );

    DBGPRINTF(( DBG_CONTEXT,
               "cannot create client object, error %lu\n",
                err ));

    if ( pConn )
    {
        CLIENT_CONN::Free( pConn );
    }

    return FALSE;

}   // CreateClient

#if 0
BOOL
SendError(
    SOCKET socket,
    DWORD  ids
    )
{
    STR strResponse;

    if ( !strResponse.Resize( 512 ) ||
         !HTTP_REQ_BASE::BuildExtendedStatus( &strResponse,
                                              HT_FORBIDDEN,
                                              NO_ERROR,
                                              ids ))
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[SendError] Failed to build status (error %d)\n",
                   GetLastError()));

        return FALSE;
    }

    //
    //  Do a synchronous send
    //

    send( socket,
          strResponse.QueryStr(),
          strResponse.QueryCB(),
          0 );

    return TRUE ;
} // SendError
#endif

/*******************************************************************

    NAME:       CloseSocket

    SYNOPSIS:   Closes the specified socket.  This is just a thin
                wrapper around the "real" closesocket() API.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     26-Apr-1993 Created.

********************************************************************/
SOCKERR CloseSocket( SOCKET sock )
{
    SOCKERR serr = 0;

    //
    //  Close the socket.
    //

#if 0
    shutdown( sock, 1 );    // Davidtr sez not needed
#endif

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    IF_DEBUG( SOCKETS )
    {
        if( serr == 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "closed socket %d\n",
                        sock ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot close socket %d, error %d\n",
                        sock,
                        serr ));
        }
    }

    return serr;

}   // CloseSocket

#ifdef DEBUG
/*******************************************************************

    NAME:   DBG_CHECK_UnbalancedThreadToken    

    SYNOPSIS:   Check for unbalanced Thread Token, this function will
                try to make a open thread token call, it should fail, otherwise,
                somebody forgets to release the thread token.

    ENTRY:      

    RETURNS:    NONE

    HISTORY:
        LeiJin     9/4/1997 Created.

********************************************************************/

VOID DBG_CHECK_UnbalancedThreadToken(
    IN const char *         pszFilePath,
    IN int                  nLineNum
    )
{
    HANDLE hToken = (HANDLE)0;
    BOOL fRet = FALSE;

    fRet = OpenThreadToken(GetCurrentThread(),
                            TOKEN_QUERY,    // the very minimum operation on a thread token
                            FALSE,          // FALSE, the access check is performed using the 
                                            // security context for the calling thread.
                            &hToken);
    if (fRet == TRUE)
        {
        DBGPRINTF((DBG_CONTEXT, "File %s, Line %d, OpenThreadToken() succeeded, found a token.\n",
            pszFilePath,
            nLineNum));
        DBG_ASSERT(FALSE);
        CloseHandle(hToken);
        }
    else
        {
        DWORD err = GetLastError();

        if (err != ERROR_NO_TOKEN)
            {
            DBGPRINTF((DBG_CONTEXT, "File %s, Line %d, OpenThreadToken() failed, err = %lu.\n",
            pszFilePath,
            nLineNum));
            }
        }
 
}
#endif //debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\conn.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    conn.cxx

    This module contains the connection class


    FILE HISTORY:
        Johnl       15-Aug-1994 Created

*/


#include "w3p.hxx"
#include <issched.hxx>

#pragma warning( disable:4355 ) // 'this' used in base member initializer list

//
//  Used for iisprobe
//

extern "C" {
VOID
DumpW3InfoToHTML(
    OUT CHAR * pch,
    IN OUT LPDWORD pcb
    );
};

//
//  Globals
//

#if CC_REF_TRACKING

//
//  Ref count trace log size
//
#define C_CLIENT_CONN_REFTRACES      4000
#define C_LOCAL_CONN_REFTRACES         40

#endif

//
//  Ref trace log for CLIENT_CONN objects
//  NOTE we make this global so other classes can get at it
//

#if DBG
PTRACE_LOG   g_pDbgCCRefTraceLog = NULL;
#endif

//
//  Private constants.
//

//
//  How often to run the free list scavenger (thirty minutes)
//

#define FREE_LIST_SCAVENGE_TIME       (30 * 60 * 1000)

//
//  Private globals.
//

CRITICAL_SECTION CLIENT_CONN::_csBuffList;
LIST_ENTRY       CLIENT_CONN::_BuffListHead;
BOOL             CLIENT_CONN::_fGlobalInit = FALSE;
DWORD            CLIENT_CONN::_cFree = 0; // Number of items on lookaside free list
DWORD            CLIENT_CONN::_FreeListScavengerCookie;

DWORD   ErrorRespTable[] = {IDS_EXECUTE_ACCESS_DENIED,
                            IDS_READ_ACCESS_DENIED,
                            IDS_WRITE_ACCESS_DENIED,
                            IDS_SSL_REQUIRED,
                            IDS_SSL128_REQUIRED,
                            IDS_ADDR_REJECT,
                            IDS_CERT_REQUIRED,
                            IDS_SITE_ACCESS_DENIED,
                            IDS_TOO_MANY_USERS,
                            IDS_INVALID_CNFG,
                            IDS_PWD_CHANGE,
                            IDS_MAPPER_DENY_ACCESS,
#if defined(CAL_ENABLED)
                            IDS_CAL_EXCEEDED,
#endif
                            IDS_CERT_REVOKED,
                            IDS_DIR_LIST_DENIED,
                            IDS_SITE_RESOURCE_BLOCKED,
                            IDS_CERT_BAD,
                            IDS_CERT_TIME_INVALID,
                            IDS_SITE_NOT_FOUND
                            };

DWORD   SubStatusTable[] = {MD_ERROR_SUB403_EXECUTE_ACCESS_DENIED,
                            MD_ERROR_SUB403_READ_ACCESS_DENIED   ,
                            MD_ERROR_SUB403_WRITE_ACCESS_DENIED  ,
                            MD_ERROR_SUB403_SSL_REQUIRED         ,
                            MD_ERROR_SUB403_SSL128_REQUIRED      ,
                            MD_ERROR_SUB403_ADDR_REJECT          ,
                            MD_ERROR_SUB403_CERT_REQUIRED        ,
                            MD_ERROR_SUB403_SITE_ACCESS_DENIED   ,
                            MD_ERROR_SUB403_TOO_MANY_USERS       ,
                            MD_ERROR_SUB403_INVALID_CNFG         ,
                            MD_ERROR_SUB403_PWD_CHANGE           ,
                            MD_ERROR_SUB403_MAPPER_DENY_ACCESS   ,
#if defined(CAL_ENABLED)
                            MD_ERROR_SUB403_CAL_EXCEEDED         ,
#endif
                            MD_ERROR_SUB403_CERT_REVOKED,
                            MD_ERROR_SUB403_DIR_LIST_DENIED,
                            MD_ERROR_SUB503_CPU_LIMIT,
                            MD_ERROR_SUB403_CERT_BAD,
                            MD_ERROR_SUB403_CERT_TIME_INVALID,
                            MD_ERROR_SUB404_SITE_NOT_FOUND
                            };

/*******************************************************************

    Maco support for CLIENT_CONN::Reference/Dereference

    HISTORY:
        DaveK       10-Sep-1997 Added ref trace logging

********************************************************************/

#if CC_REF_TRACKING
#define CC_LOG_REF_COUNT( cRefs )                               \
                                                                \
    SHARED_LOG_REF_COUNT(                                       \
        cRefs                                                   \
        , (PVOID) this                                          \
        , _phttpReq                                             \
        , (_phttpReq)                                           \
          ? ((HTTP_REQUEST *) _phttpReq)->QueryWamRequest()     \
          : NULL                                                \
        , (_phttpReq)                                           \
          ? _phttpReq->QueryState()                             \
          : NULL                                                \
        );                                                      \
    LOCAL_LOG_REF_COUNT(                                        \
        cRefs                                                   \
        , (PVOID) this                                          \
        , _phttpReq                                             \
        , (_phttpReq)                                           \
          ? ((HTTP_REQUEST *) _phttpReq)->QueryWamRequest()     \
          : NULL                                                \
        , (_phttpReq)                                           \
          ? _phttpReq->QueryState()                             \
          : NULL                                                \
        );
#else
#define CC_LOG_REF_COUNT( cRefs )
#endif

#if CC_REF_TRACKING
//
// ATQ notification trace
//
// ATQ notification : stored with context1 set magic value fefefefe
//

#define CCA_LOG_REF_COUNT( cRefs,BytesWritten,CompletionStatus, dwSig)  \
                                                                \
    SHARED_LOG_REF_COUNT(                                       \
        cRefs                                                   \
        , (PVOID) this                                          \
        , (LPVOID)dwSig                                         \
        , (LPVOID)BytesWritten                                  \
        , CompletionStatus                                      \
        );                                                      \
    LOCAL_LOG_REF_COUNT(                                        \
        cRefs                                                   \
        , (PVOID) this                                          \
        , (LPVOID)dwSig                                         \
        , (LPVOID)BytesWritten                                  \
        , CompletionStatus                                      \
        );
#else
#define CCA_LOG_REF_COUNT( Ctx,BytesWritten,CompletionStatus, dwSig)
#endif

//
//  Private prototypes.
//

VOID
WINAPI
ClientConnTrimScavenger(
    PVOID pContext
    );

inline BOOL
FastScanForTerminator(
    const CHAR *  pch,
    UINT    cbData
    )
/*++

Routine Description:

    Check if buffer contains a full HTTP header.
    Can return false negatives.

Arguments:

    pch - request buffer
    cbData - # of bytes in pch, excluding trailing '\0'

Return Value:

    TRUE if buffer contains a full HTTP header
    FALSE if could not insure this, does not mean there is
    no full HTTP header.

--*/
{
    return ( (cbData > 4) &&
             (!memcmp(pch+cbData - sizeof("\r\n\r\n") + 1, "\r\n\r\n",
                      sizeof("\r\n\r\n") - 1  ) ||
              !memcmp(pch+cbData - sizeof("\n\n") + 1, "\n\n",
                      sizeof("\n\n")-1  )
              )
             );
} // FastScanForTerminator()


//
//  Public functions.
//

BYTE *
ScanForTerminator(
    const TCHAR * pch
    )
/*++

Routine Description:

    Returns the first byte of data after the header

Arguments:

    pch - Zero terminated buffer

Return Value:

    Pointer to first byte of data after the header or NULL if the
    header isn't terminated

--*/
{
    while ( *pch )
    {
        if ( !(pch = strchr( pch, '\n' )))
        {
            break;
        }

        //
        //  If we find an EOL, check if the next character is an EOL character
        //

        // NYI: UGLY cast is used ...
        if ( *(pch = SkipWhite( (char * ) (pch + 1) )) == W3_EOL )
        {
            return (BYTE *) pch + 1;
        }
        else if ( *pch )
        {
            pch++;
        }
    }

    return NULL;
}

//
//  Private functions.
//

/*******************************************************************

    NAME:       CLIENT_CONN

    SYNOPSIS:   Constructor for client connection

    ENTRY:      sClient - Client socket
                psockaddrLocal - Optional Addressing info of server socket
                psockaddrRemote - Addressing info for client
                patqContext - Optional ATQ context

    HISTORY:
        Johnl       15-Aug-1994 Created

********************************************************************/

CLIENT_CONN::CLIENT_CONN(
        IN PCLIENT_CONN_PARAMS ClientParams
        ) :
    _phttpReq       ( NULL),
    m_pInstance     ( NULL),
    _fIsValid       ( FALSE )
{
#if CC_REF_TRACKING
    _pDbgCCRefTraceLog = CreateRefTraceLog( C_LOCAL_CONN_REFTRACES, 0 );
#endif

    Initialize( ClientParams );

    //
    // initialize statistics pointer to point to global statistics;
    // it will point to local copy of the instance when instance
    // pointer is set
    //

    m_pW3Stats = g_pW3Stats;
}

VOID
CLIENT_CONN::Initialize(
        IN PCLIENT_CONN_PARAMS ClientParams
        )
/*++

Routine Description:

    This is a pseudo constructor, called just before this object is given to
    somebody who allocated a new client connection

Arguments:

    sClient - Same as for constructor
    psockaddr - Same as for constructor

--*/
{
    CHAR *          pchAddr;
    PSOCKADDR       pAddrLocal = ClientParams->pAddrLocal;

    _Signature     = CLIENT_CONN_SIGNATURE;
    _sClient       = ClientParams->sClient;
    _ccState       = CCS_STARTUP;
    _cRef          = 1;
    _AtqContext    = ClientParams->pAtqContext;
    _fIsValid      = FALSE;
    _fReuseContext = TRUE;
    _fAbortiveClose = FALSE;
    m_atqEndpointObject = ClientParams->pEndpointObject;

    //
    // Get the endpoint and reference it
    //

    m_pW3Endpoint  = ClientParams->pEndpoint;
    //
    // Don't actually reference the endpoint.  The CLIENT_CONN reference is meaningless
    //
//    m_pW3Endpoint->Reference( );

    _fSecurePort   = m_pW3Endpoint->IsSecure( );

    _pvInitial  = ClientParams->pvInitialBuff;
    _cbInitial  = ClientParams->cbInitialBuff;

    g_pW3Stats->IncrCurrentConnections();

    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "Initializing connection object %lx, new user count %d\n",
                   this,
                   g_pW3Stats->QueryCurrentConnections() ));
    }

    LockGlobals();
    InsertHeadList( &listConnections, &ListEntry );
    UnlockGlobals();

    m_remoteIpAddress =
            ((PSOCKADDR_IN)ClientParams->pAddrRemote)->sin_addr.s_addr;

    _sRemotePort =
            ntohs( ((PSOCKADDR_IN)ClientParams->pAddrRemote)->sin_port );


    DBG_ASSERT( ClientParams->pAddrRemote->sa_family == AF_INET );

    InetNtoa( ((SOCKADDR_IN *)ClientParams->pAddrRemote)->sin_addr, _achRemoteAddr );
    _acCheck.BindAddr( ClientParams->pAddrRemote );

    //
    // look at local address
    //

    if (pAddrLocal->sa_family == AF_INET)
    {
        InetNtoa( ((SOCKADDR_IN *)pAddrLocal)->sin_addr, _achLocalAddr );
        _sPort = m_pW3Endpoint->QueryPort( );

        m_localIpAddress =
            ((PSOCKADDR_IN)ClientParams->pAddrLocal)->sin_addr.s_addr;

        DBG_ASSERT(_sPort == ntohs( ((SOCKADDR_IN *)pAddrLocal)->sin_port));
        DBG_ASSERT(_sPort != 0);
    }
    else
    {
        //
        // This should not happen
        // Remote winsock bug returns all zeros
        //

        DBGPRINTF((DBG_CONTEXT,
            "Invalid socket family %d\n",pAddrLocal->sa_family));

        SetLastError( ERROR_INVALID_PARAMETER );
        goto error;
    }

    DBG_ASSERT( (strlen( _achLocalAddr ) + 1) <= sizeof(_achLocalAddr));

    if ( _phttpReq != NULL )
    {
        _phttpReq->InitializeSession( this,
                                      _pvInitial,
                                      _cbInitial );
    }
    else
    {
        _phttpReq = new HTTP_REQUEST( this,
                                      _pvInitial,
                                      _cbInitial );

        if ( (_phttpReq == NULL) || !_phttpReq->IsValid() )
        {
            DBGPRINTF((DBG_CONTEXT,"Cannot allocate HTTP_REQUEST object\n"));

            if (_phttpReq != NULL)
            {
                delete _phttpReq;
                _phttpReq = NULL;
            }
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            goto error;
        }
    }

    CC_LOG_REF_COUNT( _cRef );

    _fIsValid = TRUE;
    return;

error:

    CC_LOG_REF_COUNT( _cRef );

    //
    // Set instance to null so that it will not be dereferenced
    // twice (one on failure, one on cleanup)
    //

    //
    // Set AtqContext to null so that it will not be dereferenced
    // twice (one on failure, one on cleanup)
    // it's like deja vu all over again.
    _AtqContext = NULL;

    return;

} // CLIENT_CONN::Initialize()



CLIENT_CONN::~CLIENT_CONN()
{
    if (_phttpReq != NULL)
    {
        delete _phttpReq;
    }

#if CC_REF_TRACKING
    DestroyRefTraceLog( _pDbgCCRefTraceLog );
#endif

    _Signature = CLIENT_CONN_SIGNATURE_FREE;
}

VOID
CLIENT_CONN::Reset(
    VOID
    )
/*++

Routine Description:

    This is a pseudo destructor, called just before this object is put back
    onto the free list.

Arguments:

--*/
{

    //
    //  before we reset this client-conn:
    //  we assert that httpreq is null (we may have reached here
    //  on a failure path) or that our httpreq was unbound from its wamreq
    //

    DBG_ASSERT(
        ( _phttpReq == NULL )
        ||
        ( ((HTTP_REQUEST *)_phttpReq)->QueryWamRequest() == NULL )
    );

    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "Resetting connection object %lx, AtqCont = %lx new user count %d\n",
                   this,
                   _AtqContext,
                   g_pW3Stats->QueryCurrentConnections() ));
    }

    if ( _phttpReq != NULL )
    {
        _phttpReq->SessionTerminated();
    }

    if ( QueryAtqContext() != NULL )
    {
        AtqFreeContext( QueryAtqContext(), _fReuseContext );
        _AtqContext = NULL;
    }

    _acCheck.UnbindAddr();

    //
    // Dereference the instance
    //

    if ( m_pInstance != NULL ) {
        m_pInstance->DecrementCurrentConnections();
        m_pInstance->Dereference( );
        m_pInstance = NULL;

        //
        // Reset statistics pointer to point to global statistics
        // as the statistic object is associated with the instance.
        //

        m_pW3Stats = g_pW3Stats;
    }

    //
    // Dereference the endpoint
    //

    if ( m_pW3Endpoint != NULL ) {
        //
        // Don't actually dereference.  The CLIENT_CONN references are meaningless anyway.
        //
//        m_pW3Endpoint->Dereference( );
        m_pW3Endpoint = NULL;
    }

    //
    //  Remove ourselves from the connection list and knock down our
    //  connected user count
    //

    LockGlobals();
    RemoveEntryList( &ListEntry );
    DBG_ASSERT( ((LONG ) g_pW3Stats->QueryCurrentConnections()) >= 0 );
    UnlockGlobals();

    g_pW3Stats->DecrCurrentConnections();

    _Signature  = CLIENT_CONN_SIGNATURE_FREE;

} // CLIENT_CONN::Reset

/*******************************************************************

    NAME:       CLIENT_CONN::DoWork

    SYNOPSIS:   Worker method driven by thread pool queue

    RETURNS:    TRUE while processing should continue on this object
                If FALSE is returned, then the object should be deleted
                    (status codes will already have been communicated to
                    the client).

    NOTES:      If an IO request completes with an error, the connection
                is immediately closed and everything is cleaned up.  The
                worker functions will not be called when an error occurs.

    HISTORY:
        Johnl       15-Aug-1994 Created

********************************************************************/

BOOL CLIENT_CONN::DoWork( DWORD        BytesWritten,
                          DWORD        CompletionStatus,
                          BOOL         fIOCompletion )
{
    BOOL fRet      = TRUE;
    BOOL fFinished = FALSE;
    BOOL fAvailableData;
    BOOL fDoAgain;

    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "DoWork: Object %lx Last IO error %lu Bytes = %d State = %d\n"
                   "\tIsIO = %s Ref = %d Sock = %p\n",
                    this,
                    CompletionStatus,
                    BytesWritten,
                    QueryState(),
                    fIOCompletion ? "TRUE" : "FALSE",
                    QueryRefCount(),
                    (QueryAtqContext() ? QueryAtqContext()->hAsyncIO : (PVOID)-1L) ));
    }

    //
    //  If this was a completion generated by an IO request, decrement the
    //  ref count
    //

    if ( fIOCompletion )
    {
        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

        Dereference();
    }

    //
    //  If an IO Request completed with an error and we're not already in the
    //  process of cleaning up, then abort the connection and cleanup.  We
    //  do not send a status code to the client in this instance.
    //

    if (_phttpReq == NULL)
    {
        return FALSE;
    }

    _phttpReq->SetLastCompletionStatus( BytesWritten,
                                        CompletionStatus );

    if ( CompletionStatus && !IsCleaningUp() )
    {
        //
        // We want to log this error iff we've received some bytes
        // on the connection already. Otherwise this could be a
        // 'natural' abort after a successful request.
        //

        if ( _phttpReq->QueryBytesReceived() != 0)
        {
            //Log status may still be set to HT_DONT_LOG; if it is, change it
            //to "bad request" because we always want to log errors.
            DWORD dwLogHttpResponse = _phttpReq->QueryLogHttpResponse();
            _phttpReq->SetLogStatus ( ( dwLogHttpResponse == HT_DONT_LOG ?
                                       HT_BAD_REQUEST :
                                       dwLogHttpResponse ),
                                       CompletionStatus );
        }


#if DBG
        if ( CompletionStatus != ERROR_NETNAME_DELETED &&
             CompletionStatus != ERROR_OPERATION_ABORTED )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "DoWork: Aborting client connection %8lx, error %d\n",
                        this,
                        CompletionStatus ));
        }
#endif

        if ( HTR_GATEWAY_ASYNC_IO == _phttpReq->QueryState()) {

            DBGPRINTF((
                DBG_CONTEXT
                , "CLIENT_CONN[%08x]::DoWork async i/o failed "
                  "_phttpReq[%08x] "
                  "pWamRequest[%08x] "
                  "CompletionStatus(%d) "
                  "\n"
                , this
                , _phttpReq
                , ((HTTP_REQUEST * )_phttpReq)->QueryWamRequest()
                , CompletionStatus
            ));

            // NOTE negative ref count ==> no change to ref count
            CC_LOG_REF_COUNT( -_cRef );

            // Notify the external gateway application
            // NYI:  This is a hack for IIS 2.0 We need to fix state machines
            //       of CLIENT_CONN & HTTP_REQUEST for future extensions
            ((HTTP_REQUEST * )_phttpReq)->ProcessAsyncGatewayIO();
        } else {

            //
            // if this is not a WAM request, cleanup Exec, etc...
            //

            _phttpReq->WriteLogRecord();

        }

        Disconnect( NULL, 0, 0, FALSE );

        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

        goto Exit;
    }

    switch ( QueryState() )
    {
    case CCS_STARTUP:

        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

        //
        //  Do this at the beginning of every request
        //

        fRet = OnSessionStartup( &fDoAgain,
                                _pvInitial,
                                 _cbInitial,
                                 TRUE);

        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

        if ( !fRet || !_pvInitial )
        {
            break;
        }

        //
        //  Fall through
        //

    case CCS_PROCESSING_CLIENT_REQ:

        //
        // Set the start time on this request
        //

        _phttpReq->SetRequestStartTime();

        do
        {

            fDoAgain = FALSE;

            // NOTE negative ref count ==> no change to ref count
            CC_LOG_REF_COUNT( -_cRef );

            fRet = _phttpReq->DoWork( &fFinished );

            // NOTE negative ref count ==> no change to ref count
            CC_LOG_REF_COUNT( -_cRef );

            if ( !fRet )
            {
                //
                //  If we were denied access to the resource, then ask the user
                //  for better authorization.  Unless the user is in the process
                //  of authenticating, we force a disconnect.  This prevents the
                //  case of logging on as anonymous successfully and then failing
                //  to access the resource.
                //

                if ( GetLastError() == ERROR_ACCESS_DENIED )
                {
                    if ( !_phttpReq->IsAuthenticating() )
                    {
                        _phttpReq->SetKeepConn( FALSE );
                    }

                    if ( _phttpReq->IsKeepConnSet() )
                    {
                        //
                        //  Zero out the inital buffer so we don't try and reuse
                        //  it next time around
                        //

                        _pvInitial = NULL;
                        _cbInitial = 0;

                        SetState( CCS_STARTUP );
                    }
                    else
                    {
                        _phttpReq->SetLogStatus( HT_DENIED, ERROR_ACCESS_DENIED );
                        SetState( CCS_DISCONNECTING );
                    }

                    fRet = _phttpReq->SendAuthNeededResp( &fFinished );

                    if ( fRet && fFinished )
                    {
                        goto Disconnecting;
                    }
                }
            }
            else if ( fFinished )
            {
                _phttpReq->WriteLogRecord();

                if ( !IsCleaningUp() )
                {
                    if ( !_phttpReq->IsKeepConnSet() ||
                         !(fRet = OnSessionStartup(&fDoAgain)) )
                    {
                        //
                        //  Either we completed the disconnect so
                        //  close the socket or an error
                        //  occurred setting up for the next request w/ KeepConn set
                        //

                        Disconnect();
                        fDoAgain = FALSE;
                    }

                    fFinished = FALSE;
                }
            }

        } while ( fDoAgain );

        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

        break;

    case CCS_DISCONNECTING:

Disconnecting:
        //
        //  Write the log record for this request
        //

        _phttpReq->WriteLogRecord();

        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

        Disconnect();

        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

        //
        //  Fall-through to async i/o cleanup code ...
        //

    case CCS_SHUTDOWN:

        //
        //  If we are still in async i/o state when shutting down, cancel
        //
        //  NOTE this should only happen in cases like 97842,
        //       where oop isapi submited async i/o and then crashed
        //

        if ( _phttpReq->QueryState() == HTR_GATEWAY_ASYNC_IO ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "CLIENT_CONN::DoWork: calling CancelAsyncGatewayIO "
                  "State = %d, this = %lx, Ref = %d\n"
                , QueryState()
                , this
                , QueryRefCount()
            ));

            // NOTE negative ref count ==> no change to ref count
            CC_LOG_REF_COUNT( -_cRef );

            ((HTTP_REQUEST * )_phttpReq)->CancelAsyncGatewayIO();

            // NOTE negative ref count ==> no change to ref count
            CC_LOG_REF_COUNT( -_cRef );

        }


        break;

    default:
        fRet = FALSE;
        DBG_ASSERT( FALSE );
    }

    //
    //  If an error occurred, disconnect without sending a response
    //

    if ( !fRet )
    {

        //
        // There was a problem with SetLogStatus blowing away the
        // last error, so save it here and assert that it does not
        // get changed.
        //

        DWORD dwTempError = GetLastError();

        _phttpReq->SetLogStatus( HT_SERVER_ERROR, dwTempError );

        _phttpReq->WriteLogRecord();

        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

        _phttpReq->Disconnect( HT_SERVER_ERROR, dwTempError );

        // NOTE negative ref count ==> no change to ref count
        CC_LOG_REF_COUNT( -_cRef );

    }


Exit:
    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "DoWork: Leaving, State = %d, this = %lx, Ref = %d\n",
                   QueryState(),
                   this,
                   QueryRefCount() ));
    }

    //
    //  This connection's reference count should always be at least one
    //  at this point
    //

    DBG_ASSERT( QueryRefCount() > 0 );

    return TRUE;

} // CLIENT_CONN::DoWork

/*******************************************************************

    NAME:       CLIENT_CONN::OnSessionStartup

    SYNOPSIS:   Initiates the first read to get the client request

    PARAMETERS:

    RETURNS:    TRUE if processing should continue, FALSE to abort the
                this connection

    HISTORY:
        Johnl       15-Aug-1994 Created

********************************************************************/

BOOL
CLIENT_CONN::OnSessionStartup(
    BOOL   *pfDoAgain,
    PVOID  pvInitial,
    DWORD  cbInitial,
    BOOL   fFirst
    )
{
    APIERR err = NO_ERROR;

    //
    //  Associate our client socket with Atq if it hasn't already
    //

    if ( !QueryAtqContext() )
    {
        DBG_ASSERT( pvInitial == NULL );
        if ( !AtqAddAsyncHandle( &_AtqContext,
                                 m_atqEndpointObject,
                                 this,
                                 W3Completion,
                                 W3_DEF_CONNECTION_TIMEOUT,
                                 (HANDLE) QuerySocket()))
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "OnSessionStartup: failed to add Atq handle, error %lu\n",
                        GetLastError() ));

            return FALSE;
        }
    }

    SetState( CCS_PROCESSING_CLIENT_REQ );


    return _phttpReq->StartNewRequest( pvInitial,
                                       cbInitial,
                                       fFirst,
                                       pfDoAgain);
}

DWORD
ErrorResponseToSubStatus(
    DWORD   dwErrorResponse
)
/*++

Routine Description:

    Map an 'ErrorResponse' to a substatus for use in custom error lookup.

Arguments:

    dwErrorResponse         - The error response to be mapped.

Return Value:

  The substatus if we can map it, or 0 otherwise.

--*/
{
    int             i;

    DBG_ASSERT((sizeof(ErrorRespTable)/sizeof(DWORD)) == (sizeof(SubStatusTable)/sizeof(DWORD)));

    for (i = 0; i < sizeof(ErrorRespTable)/sizeof(DWORD);i++)
    {
        if (ErrorRespTable[i] == dwErrorResponse)
        {
            return SubStatusTable[i];
        }
    }

    return 0;
}

#define ERROR_HTML_PREFIX "<head><title>Error</title></head><body>"

/*******************************************************************

    NAME:       CLIENT_CONN::Disconnect

    SYNOPSIS:   Initiates a disconnect from the client

    ENTRY:      pRequest - If not NULL and HTResponse is non-zero, send
                    a response status before disconnecting
                HTResponse - HTTP status code to send
                ErrorResponse - Optional information string (system error or
                    string resource ID).

    NOTES:      If a response is sent, then the socket won't be disconnected
                till the send completes (state goes to

    HISTORY:
        Johnl       22-Aug-1994 Created

********************************************************************/

VOID CLIENT_CONN::Disconnect( HTTP_REQ_BASE * pRequest,
                              DWORD           HTResponse,
                              DWORD           ErrorResponse,
                              BOOL            fDoShutdown,
                              LPBOOL          pfFinished )
{
    CHAR    *pszResp;
    BOOL    fDone;
    DWORD   dwSubStatus = 0;
    STACK_STR(strError, 80);
    STACK_STR(strResp, 80);
    CHAR    ach[17];

    //
    //  If Disconnect has already been called, then this is a no-op
    //

    if ( QueryState() == CCS_SHUTDOWN )
    {
        return;
    }

    if ( _fAbortiveClose )
    {
        fDoShutdown = FALSE;
    }

    if ( pRequest && HTResponse )
    {
        STACK_STR(strBody, 200);
        BOOL    bBodyBuilt;
        DWORD   dwRespLength;
        DWORD   dwContentLength;

        if ( HTResponse == HT_NOT_FOUND )
        {
            QueryW3StatsObj()->IncrTotalNotFoundErrors();
        }

        //
        //  Means we have to wait for the status response before closing
        //  the socket
        //

        SetState( CCS_DISCONNECTING );

        IF_DEBUG( CONNECTION )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Disconnect: Going to Disconnecting for %lx, ref = %d, response = %d\n",
                       this,
                       QueryRefCount(),
                       HTResponse ));
        }

        if ( ErrorResponse != 0)
        {
            dwSubStatus = ErrorResponseToSubStatus(ErrorResponse);
        }

        if (pRequest->CheckCustomError(&strError, HTResponse, dwSubStatus, &fDone,
                &dwContentLength))
        {
            // Had at least some custom error processing. If we're done, just return.
            if (fDone)
            {
               return;
            }

            // Otherwise we've got a custom error body. Build up the basic
            // status line that we need, convert the length
            // to ascii for use as a Content-Length, build up what we need in
            // strBody, and keep going.

            if ( !HTTP_REQ_BASE::BuildStatusLine( &strResp,
                                                  HTResponse,
                                                  0, pRequest->QueryURL(),
                                                  NULL))
            {
                DBGPRINTF((DBG_CONTEXT,
                          "Disconnect: Failed to send status (error %d), aborting connecting\n",
                           ::GetLastError()));

                goto DisconnectNow;
            }

            _itoa( dwContentLength, ach, 10 );

            bBodyBuilt = strBody.Copy("Content-Length: ",
                                        sizeof("Content-Length: ") - 1) &&
                        strBody.Append(ach) &&
                        strBody.Append("\r\n", sizeof("\r\n") - 1) &&
                        strBody.Append((CHAR *)strError.QueryPtr());

            strResp.SetLen(strlen((CHAR *)strResp.QueryPtr()));


        }
        else
        {
            //
            // No custom error, build the standard status line and body.
            //
            //  Send the requested status response and after that completes close
            //  the socket
            //

            if (ErrorResponse != 0 && ErrorResponse < STR_RES_ID_BASE)
            {
                if (!strError.Copy(ERROR_HTML_PREFIX,
                    sizeof(ERROR_HTML_PREFIX) - 1))
                {
                    goto DisconnectNow;
                }
            }

            if ( !HTTP_REQ_BASE::BuildStatusLine( &strResp,
                                                  HTResponse,
                                                  ErrorResponse, pRequest->QueryURL(),
                                                  &strError))
            {
                DBGPRINTF((DBG_CONTEXT,
                          "Disconnect: Failed to send status (error %d), aborting connecting\n",
                           ::GetLastError()));

                goto DisconnectNow;
            }

            //
            // Now build up the body.
            strResp.SetLen(strlen((CHAR *)strResp.QueryPtr()));

            dwRespLength = strResp.QueryCB() - CRLF_SIZE;

            if (!strBody.Copy("Content-Type: text/html\r\n",
                    sizeof("Content-Type: text/html\r\n") - 1))
            {
                DBGPRINTF((DBG_CONTEXT,
                          "Disconnect: Failed to build error message for error %d, aborting connecting\n",
                           HTResponse));
                goto DisconnectNow;
            }

            // The body we'll build depends on whether or not there's an
            // error string. If there is, then that's it, we'll just copy it
            // in. If not, we'll fabricate a short HTML document from the
            // status line.
            if (strError.IsEmpty())
            {
                // No error string.
                dwContentLength = (dwRespLength * 2) -
                                    (sizeof("HTTP/1.1 XXX ") - 1) +
                                    sizeof("<head><title>") - 1 +
                                    sizeof("<html></title></head>") - 1 +
                                    sizeof("<body><h1>") - 1 +
                                    sizeof("</h1></body></html>") - 1;

                _itoa( dwContentLength, ach, 10 );

                bBodyBuilt = strBody.Append("Content-Length: ",
                                            sizeof("Content-Length: ") - 1)    &&
                            strBody.Append(ach)                                &&
                            strBody.Append("\r\n\r\n", sizeof("\r\n\r\n") - 1) &&
                            strBody.Append("<html><head><title>",
                                            sizeof("<html><head><title>") - 1)       &&
                            strBody.Append(strResp.QueryStr() +
                                                sizeof("HTTP/1.1 XXX ") - 1,
                                            dwRespLength -
                                                (sizeof("HTTP/1.1 XXX ") - 1)) &&
                            strBody.Append("</title></head>",
                                            sizeof("</title></head>") - 1)     &&
                            strBody.Append("<body><h1>",
                                            sizeof("<body><h1>") - 1)          &&
                            strBody.Append( strResp.QueryStr(), dwRespLength)  &&
                            strBody.Append( "</h1></body></html>",
                                            sizeof("</h1></body></html>") - 1 );
            }
            else
            {
                dwContentLength = strError.QueryCCH() + sizeof("</body>") - 1
                                  + sizeof("<html></html>") - 1;

                _itoa( dwContentLength, ach, 10 );

                bBodyBuilt = strBody.Append("Content-Length: ",
                                            sizeof("Content-Length: ") - 1)    &&
                            strBody.Append(ach)                                &&
                            strBody.Append("\r\n\r\n<html>", sizeof("\r\n\r\n<html>") - 1) &&
                            strBody.Append(strError)                           &&
                            strBody.Append("</body></html>", sizeof("</body></html>") - 1);
            }

        }

        if (!bBodyBuilt)
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Disconnect: Failed to build error message for error %d, aborting connecting\n",
                       HTResponse));
            goto DisconnectNow;

        }


        pRequest->SetKeepConn(FALSE);
        pRequest->SetAuthenticationRequested(FALSE);
        fDone = FALSE;

        if ( !pRequest->BuildBaseResponseHeader( pRequest->QueryRespBuf(),
                                              &fDone,
                                              &strResp,
                                              HTTPH_NO_CUSTOM))
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Disconnect: Failed to send status (error %d), aborting connecting\n",
                       ::GetLastError()));

            goto DisconnectNow;
        }

        DBG_ASSERT(!fDone);

        pszResp = pRequest->QueryRespBufPtr();
        dwRespLength = strlen(pszResp);

        if (HTResponse == HT_SVC_UNAVAILABLE)
        {
            CHAR        *pszRespEnd;

            // Need to append a 'Retry-After' header in this case.

            if ((dwRespLength + 1 + g_dwPutTimeoutStrlen) >
                    pRequest->QueryRespBuf()->QuerySize())
            {
                // Resize the buffer.

                if (!pRequest->QueryRespBuf()->Resize(dwRespLength + 1 + g_dwPutTimeoutStrlen))
                {
                    DBGPRINTF((DBG_CONTEXT,
                              "Disconnect: Unable to resize response buf for status %d, aborting connecting\n",
                               ::GetLastError()));

                    goto DisconnectNow;
                }

                pszResp = pRequest->QueryRespBufPtr();
            }

            pszRespEnd = pszResp + dwRespLength;

            APPEND_STRING(pszRespEnd, "Retry-After: ");
            memcpy(pszRespEnd, g_szPutTimeoutString, g_dwPutTimeoutStrlen);
            pszRespEnd += g_dwPutTimeoutStrlen;
            APPEND_STRING(pszRespEnd, "\r\n");

            dwRespLength = DIFF(pszRespEnd - pszResp);
        }

        if (HTResponse == HT_METHOD_NOT_ALLOWED)
        {

            if ((dwRespLength + 1 + MAX_ALLOW_SIZE) >
                    pRequest->QueryRespBuf()->QuerySize())
            {
                // Resize the buffer.

                if (!pRequest->QueryRespBuf()->Resize(dwRespLength + 1 + MAX_ALLOW_SIZE))
                {
                    DBGPRINTF((DBG_CONTEXT,
                              "Disconnect: Unable to resize response buf for status %d, aborting connecting\n",
                               ::GetLastError()));

                    goto DisconnectNow;
                }

                pszResp = pRequest->QueryRespBufPtr();
            }

            dwRespLength += pRequest->BuildAllowHeader(
                                pRequest->QueryURL(),
                                pszResp + dwRespLength
                                );
        }


        if ((dwRespLength + 1 + strBody.QueryCB()) > pRequest->QueryRespBuf()->QuerySize() )
        {
            if (!pRequest->QueryRespBuf()->Resize(dwRespLength + 1 + strBody.QueryCB()))
            {
                DBGPRINTF((DBG_CONTEXT,
                          "Disconnect: Unable to resize response buf for status %d, aborting connecting\n",
                           ::GetLastError()));

                goto DisconnectNow;
            }

            pszResp = pRequest->QueryRespBufPtr();
        }

        // If this is an error response to a head request, truncate it now.

        if (pRequest->QueryVerb() == HTV_HEAD)
        {
            CHAR        *pszHeaderEnd;
            DWORD       dwBodySize;

            pszHeaderEnd = strstr(strBody.QueryStr(), "\r\n\r\n");

            if (pszHeaderEnd == NULL)
            {
                DBG_ASSERT(FALSE);
                goto DisconnectNow;
            }

            dwBodySize = DIFF(pszHeaderEnd - strBody.QueryStr())
                            + sizeof("\r\n\r\n") - 1;
            strBody.SetLen(dwBodySize);
        }

        memcpy( pszResp + dwRespLength, strBody.QueryStr(),
                strBody.QueryCCH() + 1 );


        if ( !pRequest->SendHeader( pszResp,
                                    dwRespLength + strBody.QueryCCH(),
                                    IO_FLAG_ASYNC,
                                    &fDone ))
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Disconnect: Failed to send status (error %d), aborting connecting\n",
                       ::GetLastError()));

            //
            //  It's possible a filter failed the writefile, cause the
            //  filter code to issue a disconnect by the time we get here,
            //  so recheck the state
            //

            if ( QueryState() != CCS_SHUTDOWN )
            {
                goto DisconnectNow;
            }
        }

        if ( fDone )
        {
            goto DisconnectNow;
        }
    }
    else
    {
DisconnectNow:

        IF_DEBUG( CONNECTION )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Disconnect: Going to Shutdown for %lx, ref count = %d\n",
                       this,
                       QueryRefCount() ));
        }

        if ( pfFinished )
        {
            *pfFinished = TRUE;
        }

        SetState( CCS_SHUTDOWN );

        //
        //  Do a shutdown to avoid a nasty client reset when:
        //
        //  The client sent more entity data then they indicated (very common)
        //  and we may not have received all of it in our initial receive
        //  buffer OR
        //
        //  This was a CGI request.  The exiting process will cause the
        //  socket handle to be deleted but NT will force a reset on the
        //  socket because the process didn't do a close/shutdown (the
        //  process inherited this socket handle).  Atq does the right thing
        //  when using TransmitFile.
        //

#if CC_REF_TRACKING
        CC_LOG_REF_COUNT( -_cRef );
#endif

        AtqCloseSocket( QueryAtqContext(),
                        fDoShutdown );


        //
        //  This removes the last reference count to *this except for
        //  any outstanding IO requests
        //

        Dereference();
    }
}

/*******************************************************************

    NAME:       CLIENT_CONN::DisconnectAllUsers

    SYNOPSIS:   Static method that walks the connection list and disconnects
                each active connection.

    ENTRY:      Instance - Pointer to a server instance. If NULL, then all
                    users are disconnected. If !NULL, then only those users
                    associated with the specified instance are disconnected.

    HISTORY:
        Johnl       02-Sep-1994 Created

********************************************************************/

VOID CLIENT_CONN::DisconnectAllUsers( PIIS_SERVER_INSTANCE Instance )
{
    LIST_ENTRY  * pEntry;
    CLIENT_CONN * pconn;

    DBGPRINTF((DBG_CONTEXT,
              "DisconnectAllUsers entered\n"));
    LockGlobals();

    for ( pEntry  = listConnections.Flink;
          pEntry != &listConnections;
          pEntry  = pEntry->Flink )
    {
        pconn = CONTAINING_RECORD( pEntry, CLIENT_CONN, ListEntry );
        DBG_ASSERT( pconn->CheckSignature() );

        if( Instance == NULL ||
            Instance == (PIIS_SERVER_INSTANCE)pconn->QueryW3Instance() ) {

#if CC_REF_TRACKING
            //
            //  log to our various ref logs
            //
            // NOTE negative indicates no change to ref count
            //

            //
            //  log to local (per-object) CLIENT_CONN log
            //
            LogRefCountCCLocal(
                               - pconn->_cRef
                               , pconn
                               , pconn->_phttpReq
                               , NULL
                               , (pconn->_phttpReq ? pconn->_phttpReq->QueryState() : 0)
                               );
#endif

            //
            // If we've already posted a TransmitFile() for the connection
            // before being asked
            // to shutdown, then AtqCloseSocket() by itself will not close
            // the socket (because by default, we will pass TF_DISCONNECT|
            // TS_REUSE_SOCKET and ATQ will assume WinSock will take care of 
            // it).  The end result is that we will be stuck 
            // waiting for the completion (for 2 minutes).  Let's force the
            // issue
            //

            AtqContextSetInfo( pconn->QueryAtqContext(),
                               ATQ_INFO_FORCE_CLOSE,
                               TRUE );

            AtqCloseSocket( pconn->QueryAtqContext(),
                            FALSE );
        }
    }

    UnlockGlobals();
}

/*******************************************************************

    NAME:       CLIENT_CONN::Reference

    SYNOPSIS:   Increments the reference count.

    HISTORY:
        DaveK       10-Sep-1997 Added ref trace logging

********************************************************************/

UINT CLIENT_CONN::Reference( VOID )
{
    LONG cRefs = InterlockedIncrement( &_cRef );

    CC_LOG_REF_COUNT( cRefs );

    return cRefs;
}

/*******************************************************************

    NAME:       CLIENT_CONN::Dereference

    SYNOPSIS:   Increments the reference count.

    HISTORY:
        DaveK       10-Sep-1997 Added ref trace logging

********************************************************************/

UINT CLIENT_CONN::Dereference( VOID )
{
    //
    // Write the trace log BEFORE the decrement operation :(
    // If we write it after the decrement, we will run into potential
    // race conditions in this object getting freed up accidentally
    // by another thread
    //
    // NOTE we write (_cRef - 1) == ref count AFTER decrement happens
    //

    LONG cRefsAfter = (_cRef - 1);
    CC_LOG_REF_COUNT( cRefsAfter );

    return InterlockedDecrement( &_cRef );
}

/*******************************************************************

    More CLIENT_CONN methods

    SYNOPSIS:   More methods.
.
    HISTORY:
        DaveK       10-Sep-1997 Added this comment

********************************************************************/

DWORD
CLIENT_CONN::Initialize(
    VOID
    )
{
    DWORD   msScavengeTime = ACACHE_REG_DEFAULT_CLEANUP_INTERVAL;
    HKEY     hkey;

    INITIALIZE_CRITICAL_SECTION( &_csBuffList );
    InitializeListHead( &_BuffListHead );

#if CC_REF_TRACKING
    g_pDbgCCRefTraceLog = CreateRefTraceLog( C_CLIENT_CONN_REFTRACES, 0 );
#endif

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       ACACHE_REG_PARAMS_REG_KEY,
                       0,
                       KEY_READ,
                       &hkey ) == NO_ERROR )
    {
        msScavengeTime = ReadRegistryDword( hkey,
                                             ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL,
                                             ACACHE_REG_DEFAULT_CLEANUP_INTERVAL );
        DBG_REQUIRE( !RegCloseKey( hkey ));
    }

    msScavengeTime *= 1000;     // Convert to milliseconds

    _FreeListScavengerCookie = ScheduleWorkItem( ClientConnTrimScavenger,
                                               NULL,
                                               msScavengeTime,
                                               TRUE );

    _fGlobalInit = TRUE;
    return NO_ERROR;
}

VOID
CLIENT_CONN::Terminate(
    VOID
    )
{
    CLIENT_CONN * pConn;

    if ( !_fGlobalInit )
    {
        return;
    }

    RemoveWorkItem( _FreeListScavengerCookie );

    EnterCriticalSection( &_csBuffList );

    while ( !IsListEmpty( &_BuffListHead ))
    {
        pConn = CONTAINING_RECORD( _BuffListHead.Flink,
                                   CLIENT_CONN,
                                   _BuffListEntry );

        DBG_ASSERT( pConn->_Signature == CLIENT_CONN_SIGNATURE_FREE );

        RemoveEntryList( &pConn->_BuffListEntry );

        delete pConn;
    }

    LeaveCriticalSection( &_csBuffList );
    DeleteCriticalSection( &_csBuffList );

#if CC_REF_TRACKING
    DestroyRefTraceLog( g_pDbgCCRefTraceLog );
    g_pDbgCCRefTraceLog = NULL;
#endif

}

CLIENT_CONN *
CLIENT_CONN::Alloc(
    IN PCLIENT_CONN_PARAMS ClientParams
    )
{
    CLIENT_CONN * pConn;

    EnterCriticalSection( &_csBuffList );

    if ( !IsListEmpty( &_BuffListHead ))
    {
        pConn = CONTAINING_RECORD( _BuffListHead.Flink,
                                   CLIENT_CONN,
                                   _BuffListEntry );

        RemoveEntryList( &pConn->_BuffListEntry );

        _cFree--;
        LeaveCriticalSection( &_csBuffList );

        DBG_ASSERT( pConn->_Signature == CLIENT_CONN_SIGNATURE_FREE );
        pConn->Initialize( ClientParams );
        DBG_ASSERT( pConn->CheckSignature() );

        return pConn;
    }

    LeaveCriticalSection( &_csBuffList );

    return new CLIENT_CONN( ClientParams );
}

VOID
CLIENT_CONN::Free(
    CLIENT_CONN * pConn
    )
{
    DBG_ASSERT( pConn->CheckSignature() );

    pConn->Reset();

    EnterCriticalSection( &_csBuffList );
    InsertHeadList( &_BuffListHead,
                    &pConn->_BuffListEntry );

    _cFree++;
    LeaveCriticalSection( &_csBuffList );
    return;
}

VOID
CLIENT_CONN::TrimFreeList(
    VOID
    )
{
    CLIENT_CONN *           pConn;
    LIST_ENTRY              ListEntry;

    // Hold the lock only to reset the list to empty.  Do the actual
    // traversal and deletion out side the lock.

    EnterCriticalSection( &_csBuffList );

    if ( IsListEmpty( &_BuffListHead ) )
    {
        LeaveCriticalSection( &_csBuffList );
        DBG_ASSERT( _cFree == 0 );
        return;
    }
    else
    {
        ListEntry = _BuffListHead;
        ListEntry.Blink->Flink = &ListEntry;
        ListEntry.Flink->Blink = &ListEntry;
        _cFree = 0;
        InitializeListHead( &_BuffListHead );
    }

    LeaveCriticalSection( &_csBuffList );

    while ( !IsListEmpty( &ListEntry ))
    {
        pConn = CONTAINING_RECORD( ListEntry.Flink,
                                   CLIENT_CONN,
                                   _BuffListEntry );

        DBG_ASSERT( pConn->_Signature == CLIENT_CONN_SIGNATURE_FREE );

        RemoveEntryList( &pConn->_BuffListEntry );

        delete pConn;
    }
}

VOID
WINAPI
ClientConnTrimScavenger(
    PVOID pContext
    )
{
    CLIENT_CONN::TrimFreeList();
}


/*******************************************************************

    NAME:       ::W3Completion

    SYNOPSIS:   Completion routine for W3 Atq requests

    HISTORY:
        Johnl       20-Aug-1994 Created

********************************************************************/

VOID W3Completion( PVOID        Context,
                   DWORD        BytesWritten,
                   DWORD        CompletionStatus,
                   OVERLAPPED * lpo )
{
    CLIENT_CONN * pConn = (CLIENT_CONN *) Context;

    DBG_ASSERT( pConn );
    DBG_ASSERT( pConn->CheckSignature() );

#if 0
    DBGPRINTF((DBG_CONTEXT,
              "W3Completion( %08lx ) byteswritten = %d, status = %08lx, lpo = %08lx\n",
               Context, BytesWritten, CompletionStatus, lpo ));
#endif

    if ( !((W3_IIS_SERVICE*)g_pInetSvc)->GetReferenceCount() )
    {
        return;
    }
    
    W3_IIS_SERVICE::ReferenceW3Service( g_pInetSvc );

#if CC_REF_TRACKING
    //
    // ATQ notification trace
    //
    // Check for magic signature of ATQ notification
    // ATQ generates such a notification for all non-oplock completion
    //

    if ( ((DWORD)(LPVOID)lpo & 0xf0f0f0f0) == 0xf0f0f0f0 )
    {
        pConn->NotifyAtqProcessContext( BytesWritten,
                                        CompletionStatus,
                                        (DWORD)(LPVOID)lpo );
        W3_IIS_SERVICE::DereferenceW3Service( g_pInetSvc );
        return;
    }
#endif

    ReferenceConn( pConn );

    if ( lpo != NULL )
    {
        lpo->Offset = 0;
    }

    TCP_REQUIRE( pConn->DoWork( BytesWritten,
                                CompletionStatus,
                                lpo != NULL ));

    DereferenceConn( pConn );

    W3_IIS_SERVICE::DereferenceW3Service( g_pInetSvc );
}


#if CC_REF_TRACKING
VOID
CLIENT_CONN::NotifyAtqProcessContext(
    DWORD BytesWritten,
    DWORD CompletionStatus,
    DWORD dwSig
    )
/*++

Routine Description:

    Store ATQ notification in ref log

Arguments:

    BytesWritten - count of bytes written
    CompletionStatus - completion status

Return Value:

    Nothing

--*/
{
    //
    // Store current ref count as checkpoint
    //

    CCA_LOG_REF_COUNT( -_cRef, BytesWritten, CompletionStatus, dwSig );
}
#endif


/*******************************************************************

    NAME:       ::CheckForTermination

    SYNOPSIS:   Looks in the passed buffer for a line followed by a blank
                line.  If not found, the buffer is resized.

    ENTRY:      pfTerminted - Set to TRUE if this block is terminated
                pbuff - Pointer to buffer data
                cbData - Size of pbuff
                ppbExtraData - Receives a pointer to the first byte
                    of extra data following the header
                pcbExtraData - Number of bytes in data following the header
                cbReallocSize - Increase buffer by this number of bytes
                    if the terminate isn't found

    RETURNS:    TRUE if successful, FALSE otherwise

    HISTORY:
        Johnl       28-Sep-1994 Created

********************************************************************/

BOOL CheckForTermination( BOOL   * pfTerminated,
                          BUFFER * pbuff,
                          UINT     cbData,
                          BYTE * * ppbExtraData,
                          DWORD *  pcbExtraData,
                          UINT     cbReallocSize )
{
    DWORD               cbNewSize;

    cbNewSize = cbData + 1 + cbReallocSize;

    if (  !pbuff->Resize( cbNewSize ) )
    {
        return FALSE;
    }

    //
    //  Terminate the string but make sure it will fit in the
    //  buffer
    //

    CHAR * pchReq = (CHAR *) pbuff->QueryPtr();
    *(pchReq + cbData) = '\0';

    //
    //  Scan for double end of line marker
    //

    //
    // if do not care for ptr info, can use fast method
    //

    if ( ppbExtraData == NULL )
    {
        if ( FastScanForTerminator( pchReq, cbData )
                || ScanForTerminator( pchReq ) )
        {
            *pfTerminated = TRUE;
            return TRUE;
        }
        goto not_term;
    }

    *ppbExtraData = ScanForTerminator( pchReq );

    if ( *ppbExtraData )
    {
        *pcbExtraData = cbData - DIFF(*ppbExtraData - (BYTE *) pchReq);
        *pfTerminated = TRUE;
        return TRUE;
    }

not_term:

    if ( cbNewSize > g_cbMaxClientRequestBuffer )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    *pfTerminated = FALSE;

    return TRUE;
}


BOOL
CLIENT_CONN::RequestAbortiveClose(
    )
/*++

Routine Description:

    Request for abortive close on disconnect

Arguments:

    None

Returns:

    TRUE if successful, else FALSE

--*/
{
    _fAbortiveClose = TRUE;

    AtqContextSetInfo( QueryAtqContext(), ATQ_INFO_ABORTIVE_CLOSE, TRUE );

    return TRUE;
}

BOOL
CLIENT_CONN::CloseConnection(
    )
/*++

Routine Description:

    Cancels any pending async IO by closing the socket

Arguments:

    None

Returns:

    TRUE if successful, else FALSE

--*/
{
    return AtqCloseSocket( QueryAtqContext(), FALSE );
}



#if 0
BOOL
CLIENT_CONN::CheckIpAccess(
    LPBOOL pfGranted,
    LPBOOL pfNeedDns,
    LPBOOL pfComplete
    )
/*++

Routine Description:

    Check IP access granted

Arguments:

    pfGranted - updated with grant status
    pfNeedDns - updated with TRUE if need DNS name for DNS check
    pfComplete - updated with TRUE is check complete

Return Value:

  TRUE if no error, otherwise FALSE

--*/
{
    return _acCheck.CheckIpAccess( pfGranted, pfNeedDns, pfComplete );
}


BOOL
CLIENT_CONN::CheckDnsAccess(
    LPBOOL pfGranted
    )
/*++

Routine Description:

    Check DNS access granted

Arguments:

    pfGranted - updated with grant status

Return Value:

  TRUE if no error, otherwise FALSE

--*/
{
    return _acCheck.CheckDnsAccess( pfGranted );
}
#endif

VOID
DumpW3InfoToHTML(
    OUT CHAR * pch,
    IN OUT LPDWORD pcb
    )
{
    DWORD cb = 0;

    DBG_ASSERT( *pcb > 1024 );

    cb += wsprintf( pch + cb, "<TABLE BORDER>" );
    cb += wsprintf( pch + cb, "<TR><TD>Current Connections:  </TD><TD>%d</TD></TR>", g_pW3Stats->QueryCurrentConnections() );
    cb += wsprintf( pch + cb, "<TR><TD>Connections Attempts: </TD><TD>%d</TD></TR>", g_pW3Stats->QueryConnectionAttempts() );
    cb += wsprintf( pch + cb, "<TR><TD>Current CGIs: </TD><TD>%d</TD></TR>", g_pW3Stats->QueryCurrentCGIRequests() );
    cb += wsprintf( pch + cb, "<TR><TD>Total CGIs: </TD><TD>%d</TD></TR>", g_pW3Stats->QueryTotalCGIRequests() );
    cb += wsprintf( pch + cb, "<TR><TD>Current ISAPI Requests: </TD><TD>%d</TD></TR>", g_pW3Stats->QueryCurrentBGIRequests() );
    cb += wsprintf( pch + cb, "<TR><TD>Total ISAPI Requests: </TD><TD>%d</TD></TR>", g_pW3Stats->QueryTotalBGIRequests() );
    cb += wsprintf( pch + cb, "<TR><TD>Current Connections: </TD><TD>%d</TD></TR>", g_pW3Stats->QueryCurrentConnections() );
    cb += wsprintf( pch + cb, "<TR><TD>Free CLIENT_CONN list: </TD><TD>%d</TD></TR>", CLIENT_CONN::QueryFreeListSize() );
    cb += wsprintf( pch + cb, "</TABLE><p>" );

    DBG_ASSERT( *pcb > cb );

    *pcb = cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\cgi.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    cgi.cxx

    This module contains the gateway interface code for an HTTP request


    FILE HISTORY:
        Johnl       22-Sep-1994     Created
        MuraliK     22-Jan-1996     Use UNC Impersonation/Revert

*/


#include "w3p.hxx"
#include "issched.hxx"

//
//  This is the exit code given to processes that we terminate
//

#define CGI_PREMATURE_DEATH_CODE        0xf1256323

//
// Beyond around this number, CreateProcessXXX return errors
//

#define CGI_COMMAND_LINE_MAXCB          30000


#define ISUNC(a) ((a)[0]=='\\' && (a)[1]=='\\')

//
//  The default minimum number of CGI threads we'll allow to
//  run at once.  This is for compatibility with IIS 3.0 and
//  is based on the default number of ATQ threads in 3.0 (4.0
//  defaults to four).  Note this is only effective if
//  UsePoolThreadForCGI is TRUE (default).
//

#define IIS3_MIN_CGI                                    10

//
//  Prototypes
//

BOOL
IsCmdExe(
    const CHAR * pchPath
    );

//
//  Private globals.
//

BOOL fCGIInitialized = FALSE;

LONG g_cMinCGIs = 0;

//
//  Controls whether special command characters are allowed in cmd.exe
//  requests
//

BOOL fAllowSpecialCharsInShell = FALSE;

typedef struct CgiEnvTableEntry_ {
    TCHAR* m_pszName;
    BOOL   m_fIsProcessEnv;
    UINT   m_cchNameLen;
    UINT   m_cchToCopy;     // will be non zero for var to copy from
                            // process environment. In this case m_pszName
                            // points to the environment entry to copy
                            // ( name + '=' + value + '\0' )
                            // otherwise this entry is to be accessed
                            // using GetInfo()
} CgiEnvTableEntry;


//
//  Environment variable block used for CGI
//
//  best if in alphabetical order ( the env list is easier to read )
//  but not mandatory.
//  Note that the "" ( accessed as HTTP_ALL ) will be expanded to a list
//  of unsorted entries, but this list as a whole will be considered to be
//  named "HTTP_ALL" for sorting order.
//

CgiEnvTableEntry CGIEnvTable[] =
{
    {TEXT("AUTH_TYPE"),FALSE},
    {TEXT("AUTH_PASSWORD"),FALSE},
    {TEXT("AUTH_USER"),FALSE},
    {TEXT("ComSpec"),TRUE},
    {TEXT("CERT_COOKIE"), FALSE},
    {TEXT("CERT_FLAGS"), FALSE},
    {TEXT("CERT_ISSUER"), FALSE},
    {TEXT("CERT_SERIALNUMBER"), FALSE},
    {TEXT("CERT_SUBJECT"), FALSE},
    {TEXT("CONTENT_LENGTH"),FALSE},
    {TEXT("CONTENT_TYPE"),FALSE},
    {TEXT("GATEWAY_INTERFACE"),FALSE},
    {TEXT(""),FALSE},                   // Means insert all HTTP_ headers here
    {TEXT("HTTPS"),FALSE},
    {TEXT("HTTPS_KEYSIZE"),FALSE},
    {TEXT("HTTPS_SECRETKEYSIZE"),FALSE},
    {TEXT("HTTPS_SERVER_ISSUER"),FALSE},
    {TEXT("HTTPS_SERVER_SUBJECT"),FALSE},
    {TEXT("INSTANCE_ID"),FALSE},
    {TEXT("LOCAL_ADDR"),FALSE},
    {TEXT("LOGON_USER"),FALSE},
    {TEXT("PATH"),TRUE},
    {TEXT("PATH_INFO"),FALSE},
    {TEXT("PATH_TRANSLATED"),FALSE},
    {TEXT("QUERY_STRING"),FALSE},
    {TEXT("REMOTE_ADDR"),FALSE},
    {TEXT("REMOTE_HOST"),FALSE},
    {TEXT("REMOTE_USER"),FALSE},
    {TEXT("REQUEST_METHOD"),FALSE},
    {TEXT("SCRIPT_NAME"),FALSE},
    {TEXT("SERVER_NAME"),FALSE},
    {TEXT("SERVER_PORT"),FALSE},
    {TEXT("SERVER_PORT_SECURE"),FALSE},
    {TEXT("SERVER_PROTOCOL"),FALSE},
    {TEXT("SERVER_SOFTWARE"),FALSE},
    {TEXT("SystemRoot"),TRUE},
    {TEXT("UNMAPPED_REMOTE_USER"),FALSE},
    {TEXT("windir"),TRUE},
    {NULL,FALSE}
};

BOOL fForwardServerEnvironmentBlock = TRUE;

//
// Store environment block for IIS process
//

LPSTR  g_pszIisEnv = NULL;
CgiEnvTableEntry *g_pEnvEntries = NULL;

VOID
WINAPI
CGITerminateProcess(
    PVOID pContext
    );

extern "C" int __cdecl
QsortEnvCmp(
    const void *pA,
    const void *pB )
/*++

Routine Description:

    Compare CgiEnvTableEntry using their name entry

Arguments:

    pA - pointer to 1st entry
    pB - pointer to 2nd entry

Returns:

    -1 if 1st entry comes first in sort order,
    0 if identical
    1 if 2nd entry comes first

--*/
{
    LPSTR p1 = ((CgiEnvTableEntry*)pA)->m_pszName;
    LPSTR p2 = ((CgiEnvTableEntry*)pB)->m_pszName;

    if ( ! p1[0] )
    {
        p1 = "HTTP_ALL";
    }

    if ( ! p2[0] )
    {
        p2 = "HTTP_ALL";
    }

    return _stricmp( p1, p2 );
}



/*******************************************************************

    NAME:       CGI_INFO

    SYNOPSIS:   Simple storage class passed to thread

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

class CGI_INFO
{
public:
    CGI_INFO( HTTP_REQUEST * pRequest )
        : _pRequest         ( pRequest ),
          _cbData           ( 0 ),
          _hStdOut          ( NULL ),
          _hStdIn           ( NULL ),
          _hProcess         ( NULL ),
          _dwSchedCookie    ( 0 ),
          _fServerPoolThread( FALSE ),
          _pExec            ( NULL )
    {
    }

    ~CGI_INFO( VOID )
    {

        if ( _hStdOut )
        {
            if ( !::CloseHandle( _hStdOut ))
            {
                DBGPRINTF((DBG_CONTEXT,
                          "[~CGI_INFO] CloseHandle failed on StdOut, %d\n",
                           GetLastError()));
            }
        }

        if ( _hStdIn )
        {
            if ( !::CloseHandle( _hStdIn ))
            {
                DBGPRINTF((DBG_CONTEXT,
                          "[~CGI_INFO] CloseHandle failed on StdIn, %d\n",
                           GetLastError()));
            }
        }

        if ( _hProcess )
        {
            if ( !::CloseHandle( _hProcess ))
            {
                DBGPRINTF((DBG_CONTEXT,
                          "[~CGI_INFO] CloseHandle failed on Process, %d\n",
                           GetLastError()));
            }
        }
        
        DWORD dwCookie = (DWORD) InterlockedExchange( (LPLONG) &_dwSchedCookie, 
                                                      0 );
        if ( dwCookie != 0 )
        {
            RemoveWorkItem( dwCookie );
        }
    }

    HTTP_REQUEST * _pRequest;
    DWORD          _dwSchedCookie;      // Scheduled callback cookie
    BOOL           _fServerPoolThread;  // Are we running in a server pool
                                        // thread?

    //
    //  Child process
    //

    HANDLE _hProcess;

    //
    //  Parent's input and output handles and child's process handle
    //

    HANDLE _hStdOut;
    HANDLE _hStdIn;

    //
    //  Handles input from CGI (headers and additional data)
    //

    BUFFER _Buff;
    UINT   _cbData;

    LIST_ENTRY              _CgiListEntry;
    static LIST_ENTRY       _CgiListHead;
    static CRITICAL_SECTION _csCgiList;

    //
    //  Execution Descriptor block
    //

    EXEC_DESCRIPTOR *       _pExec;
};

//
// Globals
//

CRITICAL_SECTION CGI_INFO::_csCgiList;
LIST_ENTRY       CGI_INFO::_CgiListHead;

//
//  Private prototypes.
//

BOOL ProcessCGIInput( CGI_INFO * pCGIInfo );

BOOL SetupChildEnv( EXEC_DESCRIPTOR * pExec,
                    BUFFER       * pBuff );

BOOL SetupChildPipes( STARTUPINFO * pstartupinfo,
                      HANDLE      * phParentIn,
                      HANDLE      * phParentOut );

BOOL SetupCmdLine( STR * pstrCmdLine,
                   const STR & strParams );

DWORD CGIThread( PVOID Param );

BOOL ProcessCGIInput( CGI_INFO * pCGIInfo,
                      BYTE     * buff,
                      DWORD      cbRead,
                      BOOL     * pfReadHeaders,
                      BOOL     * pfDone,
                      BOOL     * pfSkipDisconnect,
                      DWORD    * pdwHttpStatus  );

/*******************************************************************/


APIERR
InitializeCGI(
    VOID
    )
/*++

Routine Description:

    Initialize CGI


Arguments:

    None

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    LPVOID               pvEnv;
    UINT                 cchStr;
    UINT                 cchIisEnv;
    UINT                 cEnv;
    INT                  chScanEndOfName;
    CgiEnvTableEntry   * pCgiEnv;
    HKEY hkeyParam;


    INITIALIZE_CRITICAL_SECTION( &CGI_INFO::_csCgiList );
    InitializeListHead( &CGI_INFO::_CgiListHead );

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hkeyParam ) == NO_ERROR )
    {
        fAllowSpecialCharsInShell = !!ReadRegistryDword( hkeyParam,
                                                "AllowSpecialCharsInShell",
                                                FALSE );

        fForwardServerEnvironmentBlock = !!ReadRegistryDword(
                hkeyParam,
                "ForwardServerEnvironmentBlock",
                TRUE );

        RegCloseKey( hkeyParam );
    }

    if ( fForwardServerEnvironmentBlock
            && (pvEnv = GetEnvironmentStrings()) )
    {
        //
        // Compute length of environment block and # of variables
        // ( excluding block delimiter )
        //

        cchIisEnv = 0;
        cEnv = 0;

        while ( cchStr = strlen( ((PSTR)pvEnv) + cchIisEnv ) )
        {
            cchIisEnv += cchStr + 1;
            ++cEnv;
        }

        ++cchIisEnv;

        //
        // store it
        //

        if ( (g_pszIisEnv = (LPSTR)LocalAlloc(
                LMEM_FIXED, cchIisEnv * sizeof(TCHAR))) == NULL )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        CopyMemory(
            g_pszIisEnv,
            pvEnv,
            cchIisEnv * sizeof(TCHAR) );

        FreeEnvironmentStrings( (LPTSTR)pvEnv );

        pvEnv = (PVOID)g_pszIisEnv;

        if ( g_pEnvEntries = new CgiEnvTableEntry [
                cEnv + sizeof(CGIEnvTable)/sizeof(CgiEnvTableEntry) ] )
        {
            cchIisEnv = 0;
            cEnv = 0;

            //
            // add process environment to table
            //

            while ( cchStr = strlen( ((PSTR)pvEnv) + cchIisEnv ) )
            {
                g_pEnvEntries[ cEnv ].m_pszName = ((PSTR)pvEnv) + cchIisEnv;
                g_pEnvEntries[ cEnv ].m_fIsProcessEnv = TRUE;

                // compute length of name : up to '=' char

                for ( g_pEnvEntries[ cEnv ].m_cchNameLen = 0 ;
                    ( chScanEndOfName = g_pEnvEntries[ cEnv ].m_pszName
                        [ g_pEnvEntries[ cEnv ].m_cchNameLen ] )
                    && chScanEndOfName != '=' ; )
                {
                    ++g_pEnvEntries[ cEnv ].m_cchNameLen;
                }

                g_pEnvEntries[ cEnv ].m_cchToCopy = cchStr + 1;

                cchIisEnv += cchStr + 1;
                ++cEnv;
            }

            //
            // add CGI environment variables to table
            //

            for ( pCgiEnv = CGIEnvTable ; pCgiEnv->m_pszName ; ++pCgiEnv )
            {
                if ( !pCgiEnv->m_fIsProcessEnv )
                {
                    memcpy( g_pEnvEntries + cEnv, pCgiEnv,
                            sizeof(CgiEnvTableEntry) );
                    g_pEnvEntries[ cEnv ].m_cchNameLen
                            = strlen( pCgiEnv->m_pszName );
                    g_pEnvEntries[ cEnv ].m_cchToCopy = 0;
                    ++cEnv;
                }
            }

            //
            // add delimiter entry
            //

            g_pEnvEntries[ cEnv ].m_pszName = NULL;

            qsort( g_pEnvEntries,
                    cEnv,
                    sizeof(CgiEnvTableEntry),
                    QsortEnvCmp );
        }
        else
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
    }
    else
    {
        g_pEnvEntries = CGIEnvTable;
    }

    fCGIInitialized = TRUE;

    return NO_ERROR;

} // InitializeCGI


VOID
TerminateCGI(
    VOID
    )
/*++

Routine Description:

    Terminate CGI


Arguments:

    None

Return Value:

    Nothing

--*/
{
    if ( fCGIInitialized )
    {
        if (g_pszIisEnv != NULL )
        {
            LocalFree( g_pszIisEnv );
            g_pszIisEnv = NULL;
        }

        if ( g_pEnvEntries && (g_pEnvEntries != CGIEnvTable) )
        {
            delete [] g_pEnvEntries;
        }

        DeleteCriticalSection( &CGI_INFO::_csCgiList );
    }

} // TerminateCGI


VOID
KillCGIProcess(
    VOID
    )
/*++

Routine Description:

    Kill all CGI process


Arguments:

    None

Return Value:

    Nothing

--*/
{
    CGI_INFO*   pCgi;


    if ( fCGIInitialized )
    {
        //
        // Kill all outstanding process
        //

        BOOL bListEmpty = TRUE;

        EnterCriticalSection( &CGI_INFO::_csCgiList );

        LIST_ENTRY*  pEntry;

        for ( pEntry = CGI_INFO::_CgiListHead.Flink;
              pEntry != &CGI_INFO::_CgiListHead ;
              pEntry = pEntry->Flink )
        {
            pCgi = CONTAINING_RECORD( pEntry,
                                      CGI_INFO,
                                      CGI_INFO::_CgiListEntry );

            bListEmpty = FALSE;

            if ( pCgi->_hProcess )
            {
                CGITerminateProcess( pCgi->_hProcess );
            }
        }

        LeaveCriticalSection( &CGI_INFO::_csCgiList );

        for (int i = 0; !bListEmpty && (i < 5); i++)
        {

            //
            // Wait for all threads to complete to avoid
            // shutdown timeout problem.
            //

            Sleep(1000);

            EnterCriticalSection( &CGI_INFO::_csCgiList );

            if (IsListEmpty(&CGI_INFO::_CgiListHead))
            {
                bListEmpty = TRUE;
            }

            LeaveCriticalSection( &CGI_INFO::_csCgiList );
        }

    }
} // KillCGIProcess

VOID
KillCGIInstanceProcs(
    W3_SERVER_INSTANCE *pw3siInstance
    )
/*++

Routine Description:

    Kill all CGI process


Arguments:

    None

Return Value:

    Nothing

--*/
{
    CGI_INFO*   pCgi;


    if ( fCGIInitialized )
    {
        //
        // Kill all outstanding process
        //

        EnterCriticalSection( &CGI_INFO::_csCgiList );

        LIST_ENTRY*  pEntry;

        for ( pEntry = CGI_INFO::_CgiListHead.Flink;
              pEntry != &CGI_INFO::_CgiListHead ;
              pEntry = pEntry->Flink )
        {
            pCgi = CONTAINING_RECORD( pEntry,
                                      CGI_INFO,
                                      CGI_INFO::_CgiListEntry );

            DBG_ASSERT(pCgi->_pExec);
            DBG_ASSERT(pCgi->_pExec->_pRequest);

            if ( (pw3siInstance == pCgi->_pExec->_pRequest->QueryW3Instance()) &&
                pCgi->_hProcess )
            {
                CGITerminateProcess( pCgi->_hProcess );
            }
        }

        LeaveCriticalSection( &CGI_INFO::_csCgiList );

    }
} // KillCGIProcess

BOOL
HTTP_REQUEST::ProcessGateway(
    EXEC_DESCRIPTOR *   pExec,
    BOOL *              pfHandled,
    BOOL *              pfFinished,
    BOOL                fTrusted
    )
/*++

Routine Description:

    Prepares for either a CGI call

    If the .exe or .dll isn't found, then *pfHandled will be set
    to FALSE and the request will be processed again with the
    assumption we just happenned to find a directory with a
    trailing .exe or .dll.

Arguments:

    pExec - Execution descriptor block
    pfHandled - Indicates if the request was a gateway request
    pfFinished - Indicates no further processing is required
    fTrusted - Can this app be trusted to process things on a read only
        vroot

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL     fRet = TRUE;
    TCHAR *  pch;
    CHAR     tmpStr[MAX_PATH];
    STR      strWorkingDir(tmpStr,MAX_PATH);
    DWORD    dwMask;
    INT      cStr;
    BOOL     fChild = pExec->IsChild();
    DWORD    dwAttr;
    DWORD    err;

    *pfHandled = FALSE;
    *pfFinished = FALSE;         // ProcessBGI may reset this

    if ( !VrootAccessCheck( pExec->_pMetaData, FILE_GENERIC_EXECUTE ) )
    {
        DBGPRINTF(( DBG_CONTEXT, "ACESS_DENIED: User \"%s\" doesn't have EXECUTE permissions for CGI %s\n",
                    _strUserName.QueryStr(), pExec->_pstrPhysicalPath->QueryStr()));
                    
        SetDeniedFlags( SF_DENIED_RESOURCE );
        return FALSE;
    }

    if ( !pExec->_pstrPathInfo->Unescape() )
    {
        return FALSE;
    }

    //
    //  If this isn't a trusted app, make sure the user has execute on
    //  this virtual root
    //

    if ( !(fTrusted && IS_ACCESS_ALLOWED2(pExec, SCRIPT))
            &&
         !IS_ACCESS_ALLOWED2(pExec, EXECUTE) )
    {
        *pfHandled = TRUE;
        if ( fChild )
        {
            SetLastError( ERROR_INVALID_FLAGS );
            return FALSE;
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT, "ACCESS_DENIED: No EXECUTE permissions on Vroot \"%s\" for CGI %s\n",
                        pExec->_pMetaData->QueryVrPath()->QueryStr(), pExec->_pstrPhysicalPath->QueryStr()));
                        
            Disconnect( HT_FORBIDDEN, IDS_EXECUTE_ACCESS_DENIED, FALSE, pfFinished );
            return TRUE;
        }
    }

    //
    //  We need to calculate the number of characters that comprise the
    //  working directory for the script path (which is the web root)
    //

    if ( !LookupVirtualRoot( pExec->_pstrPhysicalPath,
                             pExec->_pstrURL->QueryStr(),
                             pExec->_pstrURL->QueryCCH(),
                             NULL,
                             NULL,
                             &dwMask ))
    {
        return FALSE;
    }

    LPSTR pszWorkingDir = strrchr( pExec->_pstrPhysicalPath->QueryStr(), '\\' );
    if ( pszWorkingDir == NULL )
    {
        return FALSE;
    }
    if ( !strWorkingDir.Copy( pExec->_pstrPhysicalPath->QueryStr(),
                              DIFF( pszWorkingDir -
                                    pExec->_pstrPhysicalPath->QueryStr() ) + 1))
    {
        return FALSE;
    }

    //
    //  Keep-alive not supported for CGI
    //

    if ( !fChild )
    {
        SetKeepConn( FALSE );
    }

    //
    //  If this was a mapped script extension expand any parameters
    //

    if ( !pExec->_pstrGatewayImage->IsEmpty() )
    {
        CHAR tmpStr[MAX_PATH];
        CHAR tmpStr2[1024];

        STR strDecodedParams(tmpStr,MAX_PATH);
        STR strCmdLine(tmpStr2,1024);

        if ( !SetupCmdLine( &strDecodedParams,
                            *(pExec->_pstrURLParams) )     ||
             !strCmdLine.Resize( pExec->_pstrGatewayImage->QueryCB() +
                                 pExec->_pstrPhysicalPath->QueryCB() +
                                 strDecodedParams.QueryCB()))
        {
            return FALSE;
        }

        if ( IsCmdExe( pExec->_pstrGatewayImage->QueryStr() ))
        {
            //
            //  Make sure the path to the file exists if we're running
            //  the command interpreter
            //

            if ( !pExec->ImpersonateUser() )
            {
                return FALSE;
            }

            dwAttr = GetFileAttributes( pExec->_pstrPhysicalPath->QueryStr() );
            err = GetLastError();

            pExec->RevertUser();

            if ( dwAttr == 0xffffffff )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[ProcessGateway] Error %d openning batch file %s\n",
                            err,
                            pExec->_pstrPhysicalPath->QueryStr() ) );

                if ( !fChild &&
                    ( (err == ERROR_FILE_NOT_FOUND) ||
                     (err == ERROR_PATH_NOT_FOUND) ||
                     (err == ERROR_INVALID_NAME) ) )
                {
                    SetState( HTR_DONE, HT_NOT_FOUND, GetLastError() );
                    Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                    *pfHandled = TRUE;
                    return TRUE;
                }

                return FALSE;
            }
        }

        cStr = wsprintf( strCmdLine.QueryStr(),
                         pExec->_pstrGatewayImage->QueryStr(),
                         pExec->_pstrPhysicalPath->QueryStr(),
                         strDecodedParams.QueryStr() );

        strCmdLine.SetLen( cStr );

        fRet = ProcessCGI( pExec,
                           NULL,
                           &strWorkingDir,
                           pfHandled,
                           pfFinished,
                           &strCmdLine );
    }
    else
    {
        fRet = ProcessCGI( pExec,
                           pExec->_pstrPhysicalPath,
                           &strWorkingDir,
                           pfHandled,
                           pfFinished );
    }

    return fRet;
}



/********************************************************************/

BOOL
HTTP_REQUEST::ProcessCGI(
    EXEC_DESCRIPTOR *   pExec,
    const STR *         pstrPath,
    const STR *         pstrWorkingDir,
    BOOL      *         pfHandled,
    BOOL      *         pfFinished,
    STR       *         pstrCmdLine
    )
/*++

Routine Description:

    Processes a CGI client request

Arguments:

    pExec - Execution descriptor block
    pstrPath - Fully qualified path to executable (or NULL if the module
        is contained in pstrCmdLine)
    strWorkingDir - Working directory for spawned process
        (generally the web root)
    pfHandled - Set to TRUE if no further processing is needed
    pfFinished - Set to TRUE if no further I/O operation for this request
    pstrCmdLine - Optional command line to use instead of the default

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    STARTUPINFO          startupinfo;
    PROCESS_INFORMATION  processinfo;
    UCHAR                tmpBuffer[1500];
    BUFFER               buffEnv(tmpBuffer,1500);
    BOOL                 fRet = FALSE;
    CGI_INFO           * pCGIInfo = NULL;
    DWORD                dwThreadId;
    HANDLE               hThread;
    CHAR                 tmpStr[MAX_PATH];
    STR                  strCmdLine(tmpStr,MAX_PATH);
    DWORD                dwFlags = DETACHED_PROCESS;
    BOOL                 fChild = pExec->IsChild();
    BOOL                 fIsCmdExe;

    *pfHandled = TRUE;

    //
    //  Note we move the module name to the command line so argv
    //  comes out correctly
    //

    if ( pstrPath != NULL )
    {
        if ( !strCmdLine.Copy( "\"", sizeof("\"")-1 )     ||
             !strCmdLine.Append( pstrPath->QueryStr() )   ||
             !strCmdLine.Append( "\" ", sizeof("\" ")-1 ))
        {
            return FALSE;
        }
    }

    if ( !SetupChildEnv( pExec,
                         &buffEnv ) ||
         !SetupCmdLine( &strCmdLine,
                        *(pExec->_pstrURLParams) ))
    {
        return FALSE;
    }

    pstrPath = NULL;

    //
    //  If a command line wasn't supplied, then use the default command line
    //

    if ( !pstrCmdLine )
        pstrCmdLine = &strCmdLine;

    //
    //  Check to see if we're spawning cmd.exe, if so, refuse the request if
    //  there are any special shell characters.  Note we do the check here
    //  so that the command line has been fully unescaped
    //

    if ( !fAllowSpecialCharsInShell ||
         ISUNC(pstrCmdLine->QueryStr()) )
    {
        if ( fIsCmdExe = IsCmdExe( pstrCmdLine->QueryStr() ) )
        {
            //
            // if invoking cmd.exe for a UNC script then don't set the working directory.
            // otherwise cmd.exe will complains about working dir on UNC being not
            // supported, which will destroy HTTP headers.
            //

            if ( ISUNC(pstrCmdLine->QueryStr()) )
            {
                pstrWorkingDir = NULL;
            }
        }
    }

    if ( !fAllowSpecialCharsInShell )
    {
        DWORD i;

        if ( fIsCmdExe )
        {
            //
            //  We'll either match one of the characters or the '\0'
            //

            i = strcspn( pstrCmdLine->QueryStr(), "&|(,;%<>" );

            if ( pstrCmdLine->QueryStr()[i] )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[ProcessCGI] Refusing request for command shell due "
                            " to special characters\n" ));

                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
        }
    }

    //
    // See if CPU Throttling has this CPU stopped.
    //

    if (_pW3Instance->AreProcsCPUStopped() && pExec->_pMetaData->QueryJobCGIEnabled()) {
        SetLastError(ERROR_NOT_ENOUGH_QUOTA);
        fRet = FALSE;
        goto Exit;
    }

    //
    //  Setup the pipes information
    //

    pCGIInfo = new CGI_INFO( this );

    if ( !pCGIInfo )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto Exit;
    }

    pCGIInfo->_pExec = pExec;

    ZeroMemory( &startupinfo, sizeof(startupinfo) );
    startupinfo.cb = sizeof(startupinfo);

    EnterCriticalSection( &CGI_INFO::_csCgiList );

    InsertHeadList( &CGI_INFO::_CgiListHead,
                    &pCGIInfo->_CgiListEntry );

    LeaveCriticalSection( &CGI_INFO::_csCgiList );

    //
    //  We specify an unnamed desktop so a new windowstation will be created
    //  in the context of the calling user
    //

    startupinfo.lpDesktop = "";

    if ( !SetupChildPipes( &startupinfo,
                           &pCGIInfo->_hStdIn,
                           &pCGIInfo->_hStdOut ) )
    {
        IF_DEBUG( CGI )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[ProcessCGI] Failed to create child pipes, error %d",
                       GetLastError() ));
        }

        goto Exit;
    }

    if ( pExec->_pMetaData->QueryCreateProcessNewConsole() )
    {
        dwFlags = CREATE_NEW_CONSOLE;
    }

    //////////////////////////////////////////////////////////////
    //
    //  Allow control over whether CreateProcess is called instead of
    //  CreateProcessAsUser.  Running the services as a windows app
    //  works around the security problem spawning executables
    //
    //  Note this code block is outside the impersonation block
    //
    //////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////

    //
    //  Spawn the process and close the handles since we don't need them
    //

    IF_DEBUG( CGI )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[ProcessCGI]  Creating process, path = %s, cmdline = %s\n",
                    (pstrPath ? pstrPath->QueryStr() : "NULL"),
                    pstrCmdLine->QueryStr() ));
    }


    if (pExec->_pMetaData->QueryJobCGIEnabled())
    {
        dwFlags |= CREATE_SUSPENDED;
    }

    if ( !pExec->_pMetaData->QueryCreateProcessAsUser() ||
         QuerySingleAccessToken() )
    {
        if ( !pExec->ImpersonateUser() )
        {
            goto Exit;
        }

        fRet = CreateProcess( (pstrPath ? pstrPath->QueryStr() : NULL),
                               pstrCmdLine->QueryStr(),
                               NULL,      // Process security
                               NULL,      // Thread security
                               TRUE,      // Inherit handles
                               dwFlags,
                               buffEnv.QueryPtr(),
                               pstrWorkingDir ? pstrWorkingDir->QueryStr() :
                                                NULL,
                               &startupinfo,
                               &processinfo );

        pExec->RevertUser();

    }
    else
    {
        HANDLE hDelete = NULL;
        HANDLE hToken = pExec->QueryPrimaryHandle( &hDelete );

        if ( !ImpersonateLoggedOnUser( hToken ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[ProcessCGI] ImpersonateLoggedOnUser failed, error %lx\n",
                        GetLastError() ));

            if ( hDelete )
            {
                TCP_REQUIRE( CloseHandle( hDelete ));
            }

            goto Exit;
        }

        fRet = CreateProcessAsUser( hToken,
                                    (pstrPath ? pstrPath->QueryStr() : NULL),
                                    pstrCmdLine->QueryStr(),
                                    NULL,      // Process security
                                    NULL,      // Thread security
                                    TRUE,      // Inherit handles
                                    dwFlags,
                                    buffEnv.QueryPtr(),
                                    pstrWorkingDir ? pstrWorkingDir->QueryStr() :
                                                     NULL,
                                    &startupinfo,
                                    &processinfo );

        TCP_REQUIRE( RevertToSelf() );

        if ( hDelete )
        {
            TCP_REQUIRE( CloseHandle( hDelete ) );
        }
    }

    if ((fRet) && (pExec->_pMetaData->QueryJobCGIEnabled()))
    {

        DBG_ASSERT(_pW3Instance != NULL);
        DBG_REQUIRE(_pW3Instance->AddProcessToJob(processinfo.hProcess, FALSE) == ERROR_SUCCESS);
        if (ResumeThread(processinfo.hThread) == 0xFFFFFFFF)
        {
            fRet = FALSE;
            TerminateProcess(processinfo.hThread,
                             GetLastError());
            TCP_REQUIRE( CloseHandle( processinfo.hProcess ));
        }
    }

    TCP_REQUIRE( CloseHandle( startupinfo.hStdOutput ));
    TCP_REQUIRE( CloseHandle( startupinfo.hStdInput ));

    if ( !fRet )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[ProcessCGI] Create process failed, error %d, exe = %s, cmd line = %s\n",
                   GetLastError(),
                   (pstrPath ? pstrPath->QueryStr() : "null"),
                   (pstrCmdLine ? pstrCmdLine->QueryStr() : "null") ));

        goto Exit;
    }

    QueryW3StatsObj()->IncrTotalCGIRequests();

    TCP_REQUIRE( CloseHandle( processinfo.hThread ));
    DBG_ASSERT( startupinfo.hStdError == startupinfo.hStdOutput);

    //
    //  Save the process handle in case we need to terminate it later on
    //

    pCGIInfo->_hProcess = processinfo.hProcess;

    //
    //  Before we start the CGI thread, set our new state
    //

    SetState( HTR_CGI );

    if ( QueryW3Instance()->IsUsePoolThreadForCGI() )
    {
                BOOL fIncPoolThread = FALSE;

                //
                //  To maintain IIS 3.0 compatible behavior, allow 10 CGI threads
                //  on a single proc machine, since IIS 3.0 by default had 10 ATQ
                //  threads per processor.
                //  Note that on multi-proc machines, you will end up with more
                //  than 10 threads (specifically, you get a boost in the max thread
                //  count of IIS3_MIN_CGI - ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS).
                //

                if ( InterlockedIncrement( &g_cMinCGIs ) <=
                        ( IIS3_MIN_CGI - ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS ) )
                {
                        fIncPoolThread = TRUE;
                        AtqSetInfo( AtqIncMaxPoolThreads, 0 );
                }

        //
        //  Call the CGI processor directly.
        //

        pCGIInfo->_fServerPoolThread = TRUE;

        CGIThread( pCGIInfo );

                if ( fIncPoolThread )
                {
                        AtqSetInfo( AtqDecMaxPoolThreads, 0 );
                }

                InterlockedDecrement( &g_cMinCGIs );
    }
    else
    {

        //
        //  Create a thread to handle IO with the child process
        //

        // Child execs don't need referencing since they are executed
        // synchronously

        if ( !fChild )
        {
            Reference();
        }

        if ( !(hThread = CreateThread( NULL,
                                       0,
                                       (LPTHREAD_START_ROUTINE) CGIThread,
                                       pCGIInfo,
                                       0,
                                       &dwThreadId )))
        {
            if ( !fChild )
            {
                Dereference();
            }
            goto Exit;
        }

        //
        //  If this is a child CGI, we must wait for completion.
        //  Therefore, wait indefinitely on the CGIThread
        //

        if ( fChild )
        {
            TCP_REQUIRE( WaitForSingleObject( hThread, INFINITE ) );
        }

        //
        //  We don't use the thread handle so free the resource
        //

        TCP_REQUIRE( CloseHandle( hThread ));
    }

    fRet = TRUE;

Exit:
    if ( !fRet )
    {
        DWORD err = GetLastError();

        if (pCGIInfo != NULL)
        {
            EnterCriticalSection( &CGI_INFO::_csCgiList );
            RemoveEntryList( &pCGIInfo->_CgiListEntry );
            LeaveCriticalSection( &CGI_INFO::_csCgiList );

        delete pCGIInfo;
        }

        if ( !fChild )
        {
            if ( err == ERROR_ACCESS_DENIED )
            {
                SetDeniedFlags( SF_DENIED_RESOURCE );
            }
            else if ( err == ERROR_FILE_NOT_FOUND ||
                      err == ERROR_PATH_NOT_FOUND )
            {
                SetState( HTR_DONE, HT_NOT_FOUND, err );
                Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );

                fRet = TRUE;
            }
            else if ( err == ERROR_MORE_DATA ||
                      ( err == ERROR_INVALID_PARAMETER &&
                        pstrCmdLine->QueryCB() > CGI_COMMAND_LINE_MAXCB ) )
            {
                // These errors are returned by CreateProcess[AsUser] if
                // the query string is too long

                SetState( HTR_DONE, HT_URL_TOO_LONG, err );
                Disconnect( HT_URL_TOO_LONG, NO_ERROR, FALSE, pfFinished );

                fRet = TRUE;
            }
            else if (err == ERROR_NOT_ENOUGH_QUOTA) {

                SetState( HTR_DONE, HT_SVC_UNAVAILABLE, ERROR_NOT_ENOUGH_QUOTA );
                Disconnect( HT_SVC_UNAVAILABLE, IDS_SITE_RESOURCE_BLOCKED, FALSE, pfFinished );

                fRet = TRUE;
            }
        }
    }

    return fRet;
}

/*******************************************************************

    NAME:       SetupChildPipes

    SYNOPSIS:   Creates/duplicates pipes for redirecting stdin and
                stdout to a child process

    ENTRY:      pstartupinfo - pointer to startup info structure, receives
                    child stdin and stdout handles
                phParentIn - Pipe to use for parent reading
                phParenOut - Pipe to use for parent writing

    RETURNS:    TRUE if successful, FALSE on failure

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

BOOL SetupChildPipes( STARTUPINFO * pstartupinfo,
                      HANDLE      * phParentIn,
                      HANDLE      * phParentOut )

{
    SECURITY_ATTRIBUTES sa;

    *phParentIn  = NULL;
    *phParentOut = NULL;

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = TRUE;

    pstartupinfo->dwFlags = STARTF_USESTDHANDLES;

    //
    //  Create the pipes then mark them as not inheritted in the
    //  DuplicateHandle to prevent handle leaks
    //

    if ( !CreatePipe( phParentIn,
                      &pstartupinfo->hStdOutput,
                      &sa,
                      0 ) ||
         !DuplicateHandle( GetCurrentProcess(),
                           *phParentIn,
                           GetCurrentProcess(),
                           phParentIn,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS |
                           DUPLICATE_CLOSE_SOURCE) ||
         !CreatePipe( &pstartupinfo->hStdInput,
                      phParentOut,
                      &sa,
                      0 ) ||
         !DuplicateHandle( GetCurrentProcess(),
                           *phParentOut,
                           GetCurrentProcess(),
                           phParentOut,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS |
                           DUPLICATE_CLOSE_SOURCE ))
    {
        goto ErrorExit;
    }

    //
    //  Stdout and Stderror will use the same pipe.  If clients tend
    //  to close stderr, then we'll have to duplicate the handle
    //

    pstartupinfo->hStdError = pstartupinfo->hStdOutput;

    IF_DEBUG ( CGI )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[SetupChildPipes] Parent In = %x, Parent Out = %x, Child In = %x, Child Out = %x\n",
                   *phParentIn,
                   *phParentOut,
                   pstartupinfo->hStdInput,
                   pstartupinfo->hStdOutput));

    }

    return TRUE;

ErrorExit:
    IF_DEBUG( CGI )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[SetupChildPipes] Failed with error %d\n",
                   GetLastError()));
    }

    if ( *phParentIn )
    {
        TCP_REQUIRE( CloseHandle( *phParentIn ));
        *phParentIn = NULL;
    }

    if ( *phParentOut )
    {
        TCP_REQUIRE( CloseHandle( *phParentOut ));
        *phParentOut = NULL;
    }

    return FALSE;

}

/*******************************************************************

    NAME:       SetupChildEnv

    SYNOPSIS:   Based on the passed pRequest, builds a CGI environment block

    ENTRY:      pExec - Execution Descriptor Block
                pBuff - Buffer to receive environment block

    RETURNS:    TRUE if successful, FALSE on failure

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

BOOL SetupChildEnv( EXEC_DESCRIPTOR *   pExec,
                    BUFFER *            pBuff )
{
    TCHAR *         pch;
    TCHAR *         pchtmp;
    CHAR            tmpStr[1024];
    STR             strVal(tmpStr,1024);
    UINT            cchCurrentPos = 0;      // Points to '\0' in buffer
    UINT            cchName, cchValue;
    UINT            cbNeeded;
    BOOL            fChild = pExec->IsChild();
    HTTP_REQUEST *  pRequest = pExec->_pRequest;
    int             i = 0;

    //
    //  Build the environment block for CGI
    //

    while ( g_pEnvEntries[i].m_pszName != NULL )
    {
        //
        // Check if this is a copy entry from process environment
        //

        if ( g_pEnvEntries[i].m_cchToCopy )
        {
            if ( !pBuff->Resize( (cchCurrentPos + g_pEnvEntries[i].m_cchToCopy)
                    * sizeof(TCHAR) ) )
            {
                return FALSE;
            }

            pch = (TCHAR *) pBuff->QueryPtr();

            memcpy( pch + cchCurrentPos,
                    g_pEnvEntries[i].m_pszName,
                    g_pEnvEntries[i].m_cchToCopy );

            cchCurrentPos += g_pEnvEntries[i].m_cchToCopy;

            ++i;
            continue;
        }

        //
        //  The NULL string means we're adding all of
        //  the HTTP header fields which requires a little
        //  bit of special processing
        //

        if ( !*g_pEnvEntries[i].m_pszName )
        {
            pch = "ALL_HTTP";
        }
        else
        {
            pch = g_pEnvEntries[i].m_pszName;
        }

        if ( !strcmp( pch, "PATH_INFO" ) )
        {
            if ( !strVal.Copy( pExec->_pstrPathInfo->QueryStr() ) )
            {
                return FALSE;
            }
        }
        else if ( !strcmp( pch, "PATH_TRANSLATED" ) )
        {
            if ( !pRequest->LookupVirtualRoot( &strVal,
                                               pExec->_pstrPathInfo->QueryStr(),
                                               pExec->_pstrPathInfo->QueryCCH(),
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               FALSE,
                                               pExec->_pstrPathInfo->QueryCCH() ?
                                                   &pExec->_pPathInfoMetaData : NULL,
                                               pExec->_pstrPathInfo->QueryCCH() ?
                                                   &pExec->_pPathInfoURIBlob : NULL ) )
            {
                return FALSE;
            }
        }
        else if ( fChild && !strcmp( pch, "QUERY_STRING" ) )
        {
            if ( !strVal.Copy( pExec->_pstrURLParams->QueryStr() ) )
            {
                return FALSE;
            }
        }
        else
        {
            if ( !pRequest->GetInfo( pch, &strVal ) )
            {
                return FALSE;
            }
        }

        cchName = _tcslen( g_pEnvEntries[i].m_pszName );
        cchValue = strVal.QueryCCH();

        //
        //  We need space for the terminating '\0' and the '='
        //

        cbNeeded = ( cchName + cchValue + 1 + 1) * sizeof(TCHAR);

        if ( !pBuff->Resize( cchCurrentPos * sizeof(TCHAR) + cbNeeded,
                             512 ))
        {
            return FALSE;
        }

        //
        //  Replace the '\n' with a '\0' as needed
        //  for the HTTP headers
        //

        if ( !*g_pEnvEntries[i].m_pszName )
        {
            pchtmp = strVal.QueryStr();

            //
            //  Convert the first ':' of each header to to an '=' for the

            //  environment table
            //

            while ( pchtmp = strchr( pchtmp, ':' ))
            {
                *pchtmp = '=';

                if ( !(pchtmp = strchr( pchtmp, '\n' )))
                {
                    break;
                }
            }

            pchtmp = strVal.QueryStr();

            while ( pchtmp = strchr( pchtmp+1, '\n' ))
            {
                *pchtmp = '\0';
            }
        }

        pch = (TCHAR *) pBuff->QueryPtr();

        if ( *g_pEnvEntries[i].m_pszName )
        {
            if ( strVal.QueryStr()[0] )
            {
                memcpy( pch + cchCurrentPos,
                        g_pEnvEntries[i].m_pszName,
                        cchName * sizeof(TCHAR));

                *(pch + cchCurrentPos + cchName) = '=';

                memcpy( pch + cchCurrentPos + cchName + 1,
                        strVal.QueryStr(),
                        (cchValue + 1) * sizeof(TCHAR));

                cchCurrentPos += cchName + cchValue + 1 + 1;
            }
        }
        else
        {
            CopyMemory(
                    pch + cchCurrentPos + cchName,
                    strVal.QueryStr(),
                    (cchValue + 1) * sizeof(TCHAR));

            cchCurrentPos += cchName + cchValue;
        }

        i++;
    }

    //
    //  Add a '\0' terminator to the environment list
    //

    if ( !pBuff->Resize( (cchCurrentPos + 1) * sizeof(TCHAR)))
    {
        return FALSE;
    }

    *((TCHAR *) pBuff->QueryPtr() + cchCurrentPos) = TEXT('\0');

    return TRUE;
}

/*******************************************************************

    NAME:       SetupCmdLine

    SYNOPSIS:   Sets up a CGI command line

    ENTRY:      pstrCmdLine - Receives command line
                strParams - Parameters following "?" in URL

    HISTORY:
        Johnl       04-Oct-1994 Created

********************************************************************/

BOOL
SetupCmdLine(
    STR * pstrCmdLine,
    const STR & strParams
    )
{
    TCHAR * pch;

    //
    //  If an unencoded "=" is found, don't use the command line
    //  (some weird CGI rule)
    //

    if ( _tcschr( strParams.QueryStr(),
                  TEXT('=') ))
    {
        return TRUE;
    }

    STACK_STR (strDecodedParams, 256);

    //
    //  Replace "+" with spaces and decode any hex escapes
    //

    if ( !strDecodedParams.Copy( strParams ) )
    {
        return FALSE;
    }

    while ( pch = _tcschr( strDecodedParams.QueryStr(),
                           TEXT('+') ))
    {
        *pch = TEXT(' ');
        pch++;
    }

    if (!strDecodedParams.Unescape() ||
        !pstrCmdLine->Append(strDecodedParams))
    {
        return FALSE;
    }

    return TRUE;

} // SetupCmdLine

/*******************************************************************

    NAME:       CGIThread

    SYNOPSIS:   Sends any gateway data to the scripts stdin and forwards
                the script's stdout to the client's socket

    ENTRY:      Param - Pointer to CGI_INFO structure

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

DWORD CGIThread( PVOID Param )
{
    CGI_INFO     * pCGIInfo = (CGI_INFO *) Param;
    HTTP_REQUEST * pRequest = pCGIInfo->_pRequest;
    EXEC_DESCRIPTOR *   pExec = pCGIInfo->_pExec;
    BYTE           buff[2048];
    DWORD          cbWritten;
    DWORD          cbRead;
    DWORD          cbSent;
    DWORD          dwExitCode;
    DWORD          err;
    BOOL           fReadHeaders = FALSE;
    BOOL           fChild = pExec->IsChild();
    BOOL           fNoHeaders = pExec->NoHeaders();
    BOOL           fRedirectOnly = pExec->RedirectOnly();
    BOOL           fDone = FALSE;
    BOOL           fSkipDisconnect;
    BOOL           fRet = TRUE;
    DWORD          dwHttpStatus = HT_OK;
    DWORD          msScriptTimeout = pRequest->QueryMetaData()->QueryScriptTimeout()
                                     * 1000;
    STACK_STR(strTemp, 128);
    STACK_STR(strResponse, 512);
    CHAR            ach[17];
    CHAR            *pszCRLF;
    DWORD           dwCRLFSize;
    BOOL            fExitCodeProcess;
    DWORD           dwCookie = 0;

    IF_DEBUG( CGI )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[CGIThread] Entered, hstdin  %x, hstdout = %x\n",
                   pCGIInfo->_hStdIn,
                   pCGIInfo->_hStdOut));
    }

    pRequest->SetLogStatus( HT_OK, NO_ERROR );

    //
    //  Update the statistics counters
    //

    pRequest->QueryW3StatsObj()->IncrCGIRequests();

    //
    //  Schedule a callback to kill the process if he doesn't die
    //  in a timely manner
    //

    pCGIInfo->_dwSchedCookie = ScheduleWorkItem( CGITerminateProcess,
                                                 pCGIInfo->_hProcess,
                                                 msScriptTimeout );

    if ( !pCGIInfo->_dwSchedCookie )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[CGI_THREAD] ScheduleWorkItem failed, error %d\n",
                   GetLastError() ));
    }

    //
    // First we have to write any additional data to the program's stdin
    //

    if ( pRequest->QueryEntityBodyCB() )
    {
        DWORD cbNextRead;
        DWORD cbLeft = 0;

        IF_DEBUG( CGI )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[CGIThread] Writing %d bytes to child's stdin\n",
                       pRequest->QueryEntityBodyCB()));
        }

        if ( !::WriteFile( pCGIInfo->_hStdOut,
                           pRequest->QueryEntityBody(),
                           pRequest->QueryEntityBodyCB(),
                           &cbWritten,
                           NULL ))
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[CGI_THREAD] WriteFile failed, error %d\n",
                       GetLastError()));
        }

        if ( cbWritten != pRequest->QueryEntityBodyCB() )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[CGI_THREAD] %d bytes written of %d bytes\n",
                       cbWritten,
                       pRequest->QueryEntityBodyCB()));
        }

         //
         //  Now stream any unread data to the CGI application but
         //  watch out for the case where we get more data then is
         //  indicated by the Content-Length
         //

        if ( pRequest->QueryEntityBodyCB() < pRequest->QueryClientContentLength())
        {
            cbLeft = pRequest->QueryClientContentLength() -
                     pRequest->QueryEntityBodyCB();
        }

         while ( cbLeft )
         {

             cbNextRead = min( cbLeft,
                               pRequest->QueryClientReqBuff()->QuerySize() );

             if ( !pRequest->ReadFile( pRequest->QueryClientRequest(),
                                       cbNextRead,
                                       &cbRead,
                                       IO_FLAG_SYNC ) ||
                  !cbRead )
             {
                 DBGPRINTF(( DBG_CONTEXT,
                             "[CGI_THREAD] Error reading gateway data (%d)\n",
                             GetLastError() ));
                 fRet = FALSE;
                 break;
             }

             cbLeft -= cbRead;
             pRequest->AddTotalEntityBodyCB( cbRead );

             if ( !::WriteFile( pCGIInfo->_hStdOut,
                                pRequest->QueryClientRequest(),
                                cbRead,
                                &cbWritten,
                                NULL ))
             {
                 fRet = FALSE;
                 break;
             }
         }
    }

    if ( !fRet )
    {
        //
        //  If an error occurred during the client read or write, we let the CGI
        //  application continue
        //

        DBGPRINTF((DBG_CONTEXT,
                  "[CGI_THREAD] Gateway ReadFile or CGI WriteFile failed, error %d\n",
                   GetLastError()));
    }

    //
    //  Now wait for any data the child sends to its stdout or for the
    //  process to exit
    //

    //
    //  Handle input from child
    //

    while (TRUE)
    {

        fRet = ::ReadFile( pCGIInfo->_hStdIn,
                           buff,
                           sizeof(buff),
                           &cbRead,
                           NULL );

        if ( !fRet )
        {
            err = GetLastError();

            if ( err == ERROR_BROKEN_PIPE )
            {
                break;
            }

            IF_DEBUG( CGI )
            {
                DBGPRINTF((DBG_CONTEXT,
                          "[CGI_THREAD] ReadFile from child stdout failed, error %d, _hStdIn = %x\n",
                           GetLastError(),
                           pCGIInfo->_hStdIn));
            }

            pRequest->SetLogStatus( 500, err );


            break;
        }

        IF_DEBUG( CGI )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[CGI_THREAD] ReadFile read %d bytes\n",
                       cbRead));
        }

        //
        //  If no bytes were read, assume the file has been closed so
        //  get out
        //

        if ( !cbRead )
        {
            break;
        }

        //
        //  The CGI script can specify headers to include in the
        //  response.  Wait till we receive all of the headers.
        //

        if ( !fReadHeaders && !pExec->IsNPH() )
        {
            if ( !fNoHeaders)
            {
                if ( !ProcessCGIInput( pCGIInfo,
                                       buff,
                                       cbRead,
                                       &fReadHeaders,
                                       &fDone,
                                       &fSkipDisconnect,
                                       &dwHttpStatus ))
                {
                    DBGPRINTF((DBG_CONTEXT,
                              "[CGIThread] ProcessCGIInput failed with error %d\n",
                               GetLastError()));

                    if ( fChild )
                    {
                        goto SkipDisconnect;
                    }
                    else
                    {
                        goto Disconnect;
                    }
                }
    
                if ( fSkipDisconnect )
                {
                    goto SkipDisconnect;
                }

                if ( fDone )
                {
                    if ( fChild )
                    {
                        goto SkipDisconnect;
                    }
                    else
                    {
                        goto Disconnect;
                    }
                }
            }
            else
            {
                BYTE *              pbExtraData;
                DWORD               cbRemainingData;
                
                pbExtraData = ScanForTerminator( (CHAR*) buff );
                if ( pbExtraData != NULL )
                {
                    fReadHeaders = TRUE;
                    
                    cbRemainingData = cbRead - DIFF( pbExtraData - buff );
                    
                    if ( HTV_HEAD != pRequest->QueryVerb() &&
                         !pRequest->WriteFile( pbExtraData,
                                               cbRemainingData,
                                               &cbSent,
                                               IO_FLAG_SYNC ) )
                    {
                        pRequest->SetLogStatus( HT_SERVER_ERROR,
                                                GetLastError() );
                        break;
                    }
                }
            }
            
            //
            //  Either we are waiting for the rest of the header or
            //  we've sent the header and any residual data so wait
            //  for more data
            //

            continue;
        }

        if ( (HTV_HEAD != pRequest->QueryVerb()) &&
             !pRequest->WriteFile( buff,
                                   cbRead,
                                   &cbSent,
                                   IO_FLAG_SYNC ))
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[CGI_THREAD] WriteFile to socket failed, error %d\n",
                       GetLastError()));

            pRequest->SetLogStatus( 500,
                                    GetLastError() );
            break;
        }
    }

    //
    //  Remove the scheduled timeout callback
    //
    
    dwCookie = (DWORD) InterlockedExchange( (LPLONG) &(pCGIInfo->_dwSchedCookie), 
                                            0 ); 
    if ( dwCookie != 0 )
    {
        if ( !RemoveWorkItem( dwCookie ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[CGI_THREAD] Failed to remove scheduled item\n" ));
        }
    }

    //
    //  If we had to kill the process, or the Job Object killed the process,
    //  log an event
    //

    fExitCodeProcess = GetExitCodeProcess( pCGIInfo->_hProcess,
                                                &dwExitCode );

    if ( (fExitCodeProcess)  &&
         (( dwExitCode == CGI_PREMATURE_DEATH_CODE ) ||
          ( dwExitCode == ERROR_NOT_ENOUGH_QUOTA )))
    {
        const CHAR * apsz[2];

        //
        //  Log an event and terminate the process
        //

        DBGPRINTF((DBG_CONTEXT,
                  "[CGI_THREAD] - CGI Script %s, params %s was killed\n",
                   pExec->_pstrURL->QueryStr(),
                   pExec->_pstrURLParams->QueryStr()));

        apsz[0] = pExec->_pstrURL->QueryStr();
        apsz[1] = pExec->_pstrURLParams->QueryStr();

        //
        // As it happens, this message is appropriate for Job Object
        // CGI Timeout as well as the original timeout
        //

        g_pInetSvc->LogEvent( W3_EVENT_KILLING_SCRIPT,
                               2,
                               apsz,
                               0 );

        dwHttpStatus = HT_BAD_GATEWAY;

        //
        //  If we haven't sent the headers, build up a full response, otherwise
        //  tack on the message to the end of the current output
        //

        if ( !fNoHeaders && !fRedirectOnly )
        {
            DWORD       dwTemp;

            pRequest->SetLogStatus( HT_BAD_GATEWAY,
                                    ERROR_SERVICE_REQUEST_TIMEOUT );

            if ( HTTP_REQ_BASE::BuildStatusLine(  &strTemp,
                                                  HT_BAD_GATEWAY,
                                                  0,
                                                  pRequest->QueryURL(),
                                                  NULL))
            {

                if ( pRequest->BuildBaseResponseHeader( &strResponse,
                                                      &fDone,
                                                      &strTemp,
                                                      HTTPH_NO_CUSTOM))
                {
                    strResponse.SetLen( strlen(strResponse.QueryStr()) );
                    strTemp.SetLen(0);

                    if (pRequest->CheckCustomError(&strTemp, HT_BAD_GATEWAY,
                                                    MD_ERROR_SUB502_TIMEOUT,
                                                    &fDone,
                                                    &dwTemp))
                    {

                        if (fDone)
                        {
                            goto SkipDisconnect;
                        }

                        pszCRLF = "\r\n";
                        dwCRLFSize = CRLF_SIZE;

                        DBG_REQUIRE(strTemp.SetLen(strlen(strTemp.QueryStr())) );

                     }
                     else
                     {

                         if ( !g_pInetSvc->LoadStr( strTemp,
                                                    IDS_CGI_APP_TIMEOUT ))
                         {
                             goto Disconnect;
                         }

                         dwTemp = strTemp.QueryCB();

                         pszCRLF = "\r\nContent-Type: text/html\r\n\r\n";
                         dwCRLFSize = sizeof("\r\nContent-Type: text/html\r\n\r\n") - 1;
                     }

                     _itoa( dwTemp, ach, 10 );

                     DBG_REQUIRE(strResponse.Append("Content-Length: ",
                                 sizeof("Content-Length: ") - 1));

                     DBG_REQUIRE(strResponse.Append(ach));

                     DBG_REQUIRE(strResponse.Append(pszCRLF, dwCRLFSize));

                     if (HTV_HEAD != pRequest->QueryVerb())
                     {
                        DBG_REQUIRE( strResponse.Append( strTemp));
                     }

                     pRequest->SendHeader( strResponse.QueryStr(),
                                           strResponse.QueryCB(),
                                           IO_FLAG_SYNC,
                                           &fDone );
                }
            }

        }
        else
        {
            if ( g_pInetSvc->LoadStr( strResponse, IDS_CGI_APP_TIMEOUT ))
            {
                pRequest->WriteFile( strResponse.QueryStr(),
                                     strResponse.QueryCB(),
                                     &cbSent,
                                     IO_FLAG_SYNC );
            }
        }

    }
    else if ( !fReadHeaders )
    {
        //
        //  If we never finished reading the headers, send a nice message
        //  to the client
        //

        if ( !fNoHeaders && !fRedirectOnly && !pExec->IsNPH() )
        {
            DWORD       dwTemp;
            CHAR        *pszTemp;

            dwHttpStatus = HT_BAD_GATEWAY;
            pRequest->SetLogStatus( HT_BAD_GATEWAY,
                                    ERROR_SERVICE_REQUEST_TIMEOUT );

            if ( HTTP_REQ_BASE::BuildStatusLine(  &strTemp,
                                                  HT_BAD_GATEWAY,
                                                  0,
                                                  pRequest->QueryURL(),
                                                  NULL))
            {
                CHAR        ach[17];
                CHAR        *pszCRLF;
                DWORD       dwCRLFSize;
                DWORD       dwExtraSize;

                if ( pRequest->BuildBaseResponseHeader( &strResponse,
                                                      &fDone,
                                                      &strTemp,
                                                      HTTPH_NO_CUSTOM))
                {
                    DWORD      dwCGIHeaderLength;

                    strResponse.SetLen( strlen(strResponse.QueryStr()) );
                    strTemp.SetLen(0);

                    if (pRequest->CheckCustomError(&strTemp, HT_BAD_GATEWAY,
                                                    MD_ERROR_SUB502_PREMATURE_EXIT,
                                                    &fDone,
                                                    &dwTemp))
                    {
                       if (fDone)
                       {
                           goto SkipDisconnect;
                       }

                       pszCRLF = "\r\n";
                       dwCRLFSize = CRLF_SIZE;

                       DBG_REQUIRE(strTemp.SetLen(strlen(strTemp.QueryStr())) );

                       dwExtraSize = strTemp.QueryCB() - dwTemp;
                    }
                    else
                    {

                       if ( !g_pInetSvc->LoadStr( strTemp, IDS_BAD_CGI_APP ))
                       {
                           goto Disconnect;
                       }

                       dwTemp = strTemp.QueryCB();
                       dwExtraSize = 0;

                       pszCRLF = "\r\nContent-Type: text/html\r\n\r\n";

                       dwCRLFSize = sizeof("\r\nContent-Type: text/html\r\n\r\n") - 1;

                    }

                    dwCGIHeaderLength = strlen((CHAR *)pCGIInfo->_Buff.QueryPtr() );

                    if (strstr(strTemp.QueryStr(), "%s") != NULL)
                    {
                        dwTemp += dwCGIHeaderLength;
                        dwTemp -= (sizeof("%s") - 1);
                    }

                    // Truncate the buffer to 1024, since wsprintf won't do more than that.

                    if (dwTemp > 1024)
                    {
                        dwTemp = 1024;
                    }

                    _itoa( dwTemp, ach, 10 );

                    DBG_REQUIRE(strResponse.Append("Content-Length: ",
                                sizeof("Content-Length: ") - 1));

                    DBG_REQUIRE(strResponse.Append(ach));

                    DBG_REQUIRE(strResponse.Append(pszCRLF, dwCRLFSize));

                    if (HTV_HEAD != pRequest->QueryVerb())
                    {
                        //
                        // There might be a string substitute pattern in the error
                        // message. Resize the buffer to handle it, and substitue
                        // the headers.
                        //

                        if (!strResponse.Resize(strResponse.QueryCB() +
                                                dwTemp + dwExtraSize + 1))
                        {
                            goto Disconnect;
                        }

                        if (!pCGIInfo->_Buff.Resize(dwCGIHeaderLength + 1))
                        {
                            goto Disconnect;
                        }

                        pszTemp = (CHAR *)pCGIInfo->_Buff.QueryPtr();

                        pszTemp[dwCGIHeaderLength] = '\0';
    
                        wsprintf(strResponse.QueryStr() + strResponse.QueryCB(),
                                    strTemp.QueryStr(), pszTemp);

    
                        DBG_REQUIRE(strResponse.SetLen(strResponse.QueryCB() +
                                        dwTemp + dwExtraSize));
                    }
                    
                    pRequest->SendHeader( strResponse.QueryStr(),
                                          strResponse.QueryCB(),
                                          IO_FLAG_SYNC,
                                          &fDone );
                }
            }
        }
        else
        {
            //
            // We don't want headers and none were found.
            // Send whatever CGI output was 'as is'.
            //

            if ( pCGIInfo->_cbData )
            {
                pRequest->WriteFile( pCGIInfo->_Buff.QueryPtr(),
                                     pCGIInfo->_cbData,
                                     &cbSent,
                                     IO_FLAG_SYNC );
            }
        }
    }

    if ( fChild )
    {
        goto SkipDisconnect;
    }

Disconnect:

    DBG_ASSERT( !fChild );

    IF_DEBUG ( CGI )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[CGIThread] Exiting thread, Current State = %d, Ref = %d\n",
                   pRequest->QueryState(),
                   pRequest->QueryRefCount()));
    }

    //
    //  Make sure this request gets logged
    //

    pRequest->SetState( pRequest->QueryState(),
                        dwHttpStatus,
                        NO_ERROR );  // Don't have a good Win32 mapping here

    pRequest->WriteLogRecord();


    //
    //  Force a shutdown here so the CGI process exit doesn't cause a
    //  reset on this socket
    //

    pRequest->Disconnect( 0, NO_ERROR, TRUE );

SkipDisconnect:         //  The only time the disconnect is skipped is when
                        //  a CGI app sends a redirect

    if ( !pCGIInfo->_fServerPoolThread )
    {
        //
        //  Indicate that this Atq context should not be used because this thread
        //  is about to go away which will cause the AcceptEx IO to be cancelled
        //

        pRequest->QueryClientConn()->SetAtqReuseContextFlag( FALSE );

        //
        //  Reference is only done if we've created a new thread
        //

        if ( !fChild )
        {
            DereferenceConn( pRequest->QueryClientConn() );
        }
    }

    EnterCriticalSection( &CGI_INFO::_csCgiList );
    RemoveEntryList( &pCGIInfo->_CgiListEntry );
    LeaveCriticalSection( &CGI_INFO::_csCgiList );

    delete pCGIInfo;

    pRequest->QueryW3StatsObj()->DecrCurrentCGIRequests();

    return 0;
}

/*******************************************************************

    NAME:       ProcessCGIInput

    SYNOPSIS:   Handles headers the CGI program hands back to the server

    ENTRY:      pCGIInfo - Pointer to CGI structure
                buff - Pointer to data just read
                cbRead - Number of bytes read into buff
                pfReadHeaders - Set to TRUE after we've finished processing
                    all of the HTTP headers the CGI script gave us
                pfDone - Set to TRUE to indicate no further processing is
                    needed
                pfSkipDisconnect - Set to TRUE to indicate no further
                    processing is needed and the caller should not call
                    disconnect

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

BOOL
ProcessCGIInput(
        CGI_INFO * pCGIInfo,
        BYTE     * buff,
        DWORD      cbRead,
        BOOL     * pfReadHeaders,
        BOOL     * pfDone,
        BOOL     * pfSkipDisconnect,
        DWORD    * pdwHttpStatus
        )
{
    PCHAR       pchValue;
    PCHAR       pchField;
    BYTE *      pbData;
    PCHAR       pszTail;
    DWORD       cbData;
    DWORD       cbSent;
    STACK_STR(  strContentType, 64 );
    STACK_STR(  strStatus, 32 );
    STACK_STR(  strCGIResp, MAX_PATH );          // Contains CGI client headers
    BOOL        fFoundContentType = FALSE;
    BOOL        fFoundStatus = FALSE;
    HTTP_REQUEST * pRequest = pCGIInfo->_pRequest;
    DWORD       cbNeeded, cbBaseResp;
    BOOL        fNoHeaders = pCGIInfo->_pExec->NoHeaders();
    BOOL        fRedirectOnly = pCGIInfo->_pExec->RedirectOnly();
    STACK_STR(  strError, 80);
    DWORD       dwContentLength;
    CHAR        ach[17];
    DWORD       dwCLLength;


    DBG_ASSERT( cbRead > 0 );

    *pfDone = FALSE;

    *pfSkipDisconnect = FALSE;

    if ( !pCGIInfo->_Buff.Resize( pCGIInfo->_cbData + cbRead,
                                  256 ))
    {
        return FALSE;
    }

    CopyMemory( (BYTE *)pCGIInfo->_Buff.QueryPtr() + pCGIInfo->_cbData,
                buff,
                cbRead );

    pCGIInfo->_cbData += cbRead;

    //
    //  The end of CGI headers are marked by a blank line, check to see if
    //  we've hit that line
    //

    if ( !CheckForTermination( pfReadHeaders,
                               &pCGIInfo->_Buff,
                               pCGIInfo->_cbData,
                               &pbData,
                               &cbData,
                               256 ))
    {
        return FALSE;
    }

    if ( !*pfReadHeaders )
    {
        return TRUE;
    }

    //
    //  We've found the end of the headers, process them
    //
    //  if request header contains:
    //
    //     Content-Type: xxxx  - Send as the content type
    //     Location: xxxx - if starts with /, send doc, otherwise send redirect message
    //     URI: preferred synonym to Location:
    //     Status: nnn xxx - Send as status code (HTTP/1.0 nnn xxx)
    //
    //     Send other request headers (server, message date, mime version)
    //

    CHAR pszOutputString[512];
    BOOL fDidRedirect = FALSE;

    INET_PARSER Parser( (CHAR *) pCGIInfo->_Buff.QueryPtr() );

    while ( *(pchField = Parser.QueryToken()) )
    {
        Parser.SkipTo( ':' );
        Parser += 1;
        pchValue = Parser.QueryToken();

        if ( !fRedirectOnly &&
             !::_strnicmp( "Status", pchField, 6 ) )
        {
            DWORD cbLine = strlen( Parser.QueryLine());
            fFoundStatus = TRUE;

            *pdwHttpStatus = atoi( pchValue );

            if ( !strStatus.Resize( LEN_PSZ_HTTP_VERSION_STR +
                                    cbLine + 4) ||
                 !strStatus.Copy( !g_ReplyWith11 ? PSZ_HTTP_VERSION_STR :
                                  PSZ_HTTP_VERSION_STR11,
                                  LEN_PSZ_HTTP_VERSION_STR ) ||
                 !strStatus.Append( Parser.QueryLine(), cbLine ) )
            {
                return FALSE;
            }

            // I am safe to assume space is there, because of resize
            DBG_ASSERT( strStatus.QueryCB() < (strStatus.QuerySize() - 2));
            strStatus.AppendCRLF();
        }
        else if ( !_strnicmp( "Location", pchField, 8 ) ||
                  !_strnicmp( "URI", pchField, 3 ))
        {

            //
            //  The CGI script is redirecting us to another URL.
            //  If it begins with a '/', then send it, otherwise
            //  send a redirect message
            //

            if ( *pchValue == TEXT('/') && !fRedirectOnly )
            {
                if ( !pRequest->ReprocessURL( pchValue,
                                              HTV_GET ))
                {
                    return FALSE;
                }

                *pfSkipDisconnect = TRUE;

                *pfDone = TRUE;
                return TRUE;
            }

            DWORD cbLen;
            CHAR pszMessageString[256];

            cbLen = LoadString( GetModuleHandle( W3_MODULE_NAME ),
                                IDS_URL_MOVED,
                                pszMessageString,
                                256 );
            if ( !cbLen )
            {
                return FALSE;
            }

            wsprintf( pszOutputString,
                      pszMessageString,
                      pchValue );

            if ( fRedirectOnly )
            {
                if ( !pRequest->WriteFile( pszOutputString,
                                           strlen(pszOutputString),
                                           &cbLen,
                                           IO_FLAG_SYNC ) )
                {
                    return FALSE;
                }
            }
            else if ( !strCGIResp.Append( "Location: ", 10 ) ||
                      !strCGIResp.Append( pchValue ) ||
                      !strCGIResp.Append( "\r\n", 2 ) ||
                      !strStatus.Copy( !g_ReplyWith11 ? PSZ_HTTP_VERSION_STR :
                                       PSZ_HTTP_VERSION_STR11,
                                       LEN_PSZ_HTTP_VERSION_STR ) ||
                      !strStatus.Append( "302 Object Moved\r\n", 18 ) )
            {
                return FALSE;
            }

            fDidRedirect = TRUE;
        }
        else if ( !fRedirectOnly )
        {
            //
            //  Copy any other fields the script specified
            //

            Parser.QueryLine();

            if ( !::_strnicmp( "Content-Type", pchField, 12 ))
            {
                fFoundContentType = TRUE;

                if ( !strContentType.Append( pchField ) ||
                     !strContentType.Append( "\r\n", 2 ))
                {
                    return FALSE;
                }
            }
            else
            {
                //
                //  Terminate line
                //

                if ( !strCGIResp.Append( pchField ) ||
                     !strCGIResp.Append( "\r\n", 2 ))
                {
                    return FALSE;
                }
            }
        }

        Parser.NextLine();
    }

    //
    // If we're ignoring all but redirects, then simply sent the data
    // past the headers and we're done.
    //

    if ( fRedirectOnly )
    {
        goto SendRemainder;
    }

    //
    //  If the CGI script didn't specify a content type, then use
    //  the default
    //

    if ( fDidRedirect )
    {
        if ( !strContentType.Copy( "Content-Type: text/html\r\n", 25 ) )
        {
            return FALSE;
        }
    }
    else if ( !fFoundContentType )
    {
        STR str;

        // NYI:  SelectMimeMapping will yield a string with allocation
        //     this is a temp string - try to avoid allocs

        if ( !strContentType.Append( PSZ_KWD_CONTENT_TYPE,
                                     LEN_PSZ_KWD_CONTENT_TYPE )||
             !SelectMimeMapping( &str,
                                 NULL,
                                 pCGIInfo->_pExec->_pMetaData )||
             !strContentType.Append( str )             ||
             !strContentType.Append( "\r\n", 2 ))
        {
            return FALSE;
        }
    }

    //
    //  Combine the CGI specified headers with the regular headers
    //  the server would send (message date, server ver. etc)
    //

    if ( !*pdwHttpStatus && !fDidRedirect )
    {
        *pdwHttpStatus = HT_OK;
    }
    else
    {
        if ( *pdwHttpStatus == HT_DENIED )
        {
            pRequest->SetDeniedFlags( SF_DENIED_APPLICATION );
            pRequest->SetAuthenticationRequested( TRUE );
        }
    }

    if ( !pRequest->BuildBaseResponseHeader( pRequest->QueryRespBuf(),
                                             pfDone,
                                             (fFoundStatus || fDidRedirect) ?
                                                 &strStatus : NULL,
                                             (*pdwHttpStatus == HT_OK) ?
                                                0 : HTTPH_NO_CUSTOM
                                            ))
    {
        return FALSE;
    }

    if ( *pfDone )
    {
        return TRUE;
    }

    if ( *pdwHttpStatus != HT_OK && !fDidRedirect )
    {
        DWORD       dwSubStatus;
        BOOL        fErrorDone;

        // Some sort of error status, check for a custom error.


        fErrorDone = FALSE;

        dwSubStatus = pRequest->IsAuthenticationRequested() ?
                        MD_ERROR_SUB401_APPLICATION : 0;

        if (pRequest->CheckCustomError(&strError, *pdwHttpStatus,
                                        dwSubStatus, &fErrorDone,
                                        &dwContentLength,
                                        dwSubStatus == 0 ? TRUE : FALSE))
        {

            // Had some sort of a custom error. If it's being completely
            // handled, bail out now.

            if (fErrorDone)
            {
                *pfSkipDisconnect = TRUE;
                return TRUE;
            }

            // We had a custom error, but it wasn't completely handled. This
            // overrides a content-type and any content sent by the CGI script
            // itself.

            strError.SetLen(strlen(strError.QueryStr()));

            cbData = 0;

        }
    }

    cbBaseResp = pRequest->QueryRespBufCB();

    if (strError.QueryCB() != 0)
    {
        _itoa( dwContentLength, ach, 10 );

        dwCLLength = strlen(ach);

        cbNeeded = cbBaseResp +
                   strError.QueryCB() +
                   sizeof("Content-Length: \r\n") - 1 +
                   dwCLLength +
                   1;           // For trailing NULL.

       if ( !pRequest->QueryRespBuf()->Resize( cbNeeded ))
       {
           return FALSE;
       }

       pszTail = pRequest->QueryRespBufPtr() + cbBaseResp;

       memcpy(pszTail, "Content-Length: ", sizeof("Content-Length: ") - 1);
       pszTail += sizeof("Content-Length: ") - 1;
       memcpy(pszTail, ach, dwCLLength);
       pszTail += dwCLLength;
       memcpy(pszTail, "\r\n", CRLF_SIZE);
       pszTail += CRLF_SIZE;

       memcpy(pszTail, strError.QueryStr(), strError.QueryCB() + 1);

       pszTail += strError.QueryCB();

    }
    else
    {

        cbNeeded = cbBaseResp +
                   strContentType.QueryCB() +
                   strCGIResp.QueryCB() +
                   sizeof( "\r\n" );        // Include the '\0' in the count

        if ( fDidRedirect )
        {
            cbNeeded += strlen(pszOutputString);
        }

        if ( !pRequest->QueryRespBuf()->Resize( cbNeeded ))
        {
            return FALSE;
        }

        pszTail = pRequest->QueryRespBufPtr() + cbBaseResp;

        memcpy( pszTail, strContentType.QueryStr(), strContentType.QueryCB() );
        pszTail += strContentType.QueryCB();

        memcpy(pszTail, strCGIResp.QueryStr(), strCGIResp.QueryCB());
        pszTail += strCGIResp.QueryCB();

        memcpy(pszTail, "\r\n", CRLF_SIZE+1);
        pszTail += CRLF_SIZE;

        if ( fDidRedirect )
        {
            memcpy(pszTail, pszOutputString, strlen(pszOutputString));
            pszTail += strlen(pszOutputString);
        }
    }


    if ( !pRequest->SendHeader( pRequest->QueryRespBufPtr(),
                                DIFF(pszTail - pRequest->QueryRespBufPtr()),
                                IO_FLAG_SYNC,
                                pfDone ))
    {
        return FALSE;
    }

    //
    // If we had a custom error message, make sure we set the done flag now.
    //

    if (strError.QueryCB() != 0)
    {
        *pfDone = TRUE;
    }

    if ( fDidRedirect )
    {
        *pfDone = TRUE;
        return TRUE;
    }

    //
    //  If there was additional data in the buffer, send that out now
    //

SendRemainder:

    if ( cbData )
    {
        if ( !pRequest->WriteFile( pbData,
                                   cbData,
                                   &cbSent,
                                   IO_FLAG_SYNC ))
        {
            return FALSE;
        }
    }

    return TRUE;
}

VOID
WINAPI
CGITerminateProcess(
    PVOID pContext
    )
/*++

Routine Description:

    This function is the callback called by the scheduler thread after the
    specified timeout period has elapsed.

Arguments:

    pContext - Handle of process to kill

--*/
{
    IF_DEBUG( CGI )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[CGITerminateProcess] - Terminating process handle %x\n",
                   pContext ));
    }

    if ( !TerminateProcess( (HANDLE) pContext, CGI_PREMATURE_DEATH_CODE ))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "[CGITerminateProcess] - TerminateProcess returned %d\n",
                   GetLastError()));
    }

} // CGITerminateProcess


BOOL
IsCmdExe(
    const CHAR * pchPath
    )
{
    while ( *pchPath )
    {
        if ( (*pchPath == 'c') || (*pchPath == 'C') )
        {
            if ( !_strnicmp(pchPath,"cmd.exe",sizeof("cmd.exe") - 1)
            ||  !_strnicmp(pchPath,"command.com",sizeof("command.com") - 1)
                )
            {
                return TRUE;
            }
        }

        pchPath++;
    }

    return FALSE;

} // IsCmdExe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll/obj is used.

   Author:

        Murali R. Krishnan    ( MuraliK )    21-Feb-1995

   Project:
        W3 Server DLL

   Revision History:
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb | DbgOutputLogFile )


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

#ifdef __cplusplus
 extern "C" {
#endif

 # include <nt.h>
 # include <ntrtl.h>
 # include <nturtl.h>

 # include <windows.h>

 #ifdef __cplusplus
 };
#endif // __cplusplus


# include <pudebug.h>

//
//  Define the debugging constants
//



# define DEBUG_CONNECTION              0x00001000L
# define DEBUG_SOCKETS                 0x00002000L
# define DEBUG_RPC                     0x00004000L

# define DEBUG_JOB_OBJECTS             0x00010000L
# define DEBUG_INSTANCE                0x00020000L
# define DEBUG_ENDPOINT                0x00040000L
# define DEBUG_METABASE                0x00080000L

# define DEBUG_CGI                     0x00100000L
# define DEBUG_BGI                     0x00200000L
# define DEBUG_SSI                     0x00400000L
# define DEBUG_SERVICE_CTRL            0x00800000L

# define DEBUG_PARSING                 0x01000000L
# define DEBUG_REQUEST                 0x02000000L
# define DEBUG_OPLOCKS                 0x04000000L

# define DEBUG_MODULEINIT              (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP                 (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT                  0x10000000
# define DEBUG_IID                     0x20000000
# define DEBUG_MISC                    0x40000000

# define DEBUG_WAM_ISA_CALLS           0x80000000

//
// Specific macros for W3 svcs module
//
# define  TCP_PRINT              DBGPRINTF
# define  TCP_REQUIRE( exp)      DBG_REQUIRE( exp)


//
// Following macros are useful for formatting and printing out GUIDs
//

# define GUID_FORMAT   "{%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])

    // Usage:  DBGPRINTF(( DBG_CONTEXT, " My Guid: " GUID_FORMAT " \n",
    //                     GUID_EXPAND( pMyGuid)));

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\cal.cxx ===
/*++


   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
       cal.cxx

   Abstract:
       Control licensing policy enforcement for W3 server

   Author:

       Philippe Choquier (Phillich)

   Environment:
       Win32 - User Mode

   Project:
   
       Internet Server DLL

--*/

#include "w3p.hxx"
#include <stdio.h>
#include <limits.h>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <inetinfo.h>
#include <issched.hxx>
#include <acache.hxx>
#include <mbstring.h>
extern "C" {
#include <ntlsapi.h>
#include <gntlsapi.h>
#include <llsapi.h>
}

#define NO_CAL_FOR_LOCAL_ACCESS
#define MULTI_CAL_PER_USER

typedef LS_STATUS_CODE
    (LS_API_ENTRY * IISPNT_LICENSE_REQUEST_A)(
    LPSTR       ProductName,
    LPSTR       Version,
    LS_HANDLE   *LicenseHandle,
    NT_LS_DATA  *NtData);

typedef NTSTATUS
    (NTAPI *IISPNT_LLS_PRODUCT_ENUM_W)(
    IN     LLS_HANDLE Handle,
    IN     DWORD      Level,     // Levels 0,1 supported
    OUT    LPBYTE*    bufptr,
    IN     DWORD      prefmaxlen,
    OUT    LPDWORD    EntriesRead,
    OUT    LPDWORD    TotalEntries,
    IN OUT LPDWORD    ResumeHandle
    );

typedef NTSTATUS
    (NTAPI *IISPNT_LLS_LOCAL_SERVICE_ENUM_W)(
    LLS_HANDLE Handle,
    DWORD      Level,
    LPBYTE*    bufptr,
    DWORD      PrefMaxLen,
    LPDWORD    EntriesRead,
    LPDWORD    TotalEntries,
    LPDWORD    ResumeHandle
    );

#define CAL_NB_PERIOD               5

#define BUFSTR_DEFAULT_SIZE         40

#define CAL_MAX_KEY_SIZE            256
#define IIS_LSAPI_NAME              "IIS"
#define IIS_LSAPI_VERSION           "5.0"
#define CAL_MIN_PERIOD              (1000)      // in ms
#define CAL_PRODUCT                 L"Windows NT Server"
#define CAL_KEYNAME                 L"FilePrint"
#define CAL_DEFAULT_MAX_LICENSES    10

typedef struct _CAL_ITERATOR {
    LIST_ENTRY* m_pNextEntry;
    LIST_ENTRY* m_pHeadEntry;
} CAL_ITERATOR;

BOOL
CalExemptAddRef(
    LPSTR       ProductName,
    LPSTR       Version,
    DWORD       *LicenseHandle,
    NT_LS_DATA  *NtData
    );

class CBufStr {

public:
    CBufStr() { m_pDynStr = 0; m_dwSize = 0; m_achFixedSize[0] = '\0'; }
    ~CBufStr() { if ( m_pDynStr ) LocalFree( m_pDynStr ); }
    BOOL Copy( LPSTR pS, DWORD dwL );
    VOID Reset() { m_dwSize = 0 ; if ( m_pDynStr ) m_pDynStr[0] = '\0'; else m_achFixedSize[0]='\0'; }
    LPCSTR QueryStr() const { return m_pDynStr ? (LPCSTR)m_pDynStr : (LPCSTR)m_achFixedSize; }
    UINT QueryCCH() const { return m_dwSize; }

private:
    CHAR    m_achFixedSize[BUFSTR_DEFAULT_SIZE];
    DWORD   m_dwMaxDynSize;
    DWORD   m_dwSize;
    LPSTR   m_pDynStr;
} ;
 

class CCalEntry : public HT_ELEMENT {

public:

    CCalEntry() { m_cRefs = 1; }
    ~CCalEntry( VOID) { if ( m_fAcquireLicenses ) AdjustLicences( 0 ); }
    LPCSTR QueryKey(VOID) const
        { return m_strKey.QueryStr(); }
    DWORD QueryKeyLen(VOID) const
        { return m_strKey.QueryCCH(); }

    LONG Reference( VOID)
        { return InterlockedIncrement( &m_cRefs); }
    LONG Dereference( VOID)
        { return InterlockedDecrement( &m_cRefs); }

    BOOL IsMatch( IN LPCSTR pszKey, IN DWORD cchKey) const
        { return cchKey == m_strKey.QueryCCH() ? !memcmp( pszKey, m_strKey.QueryStr(), cchKey) : FALSE; }
    VOID Print( VOID) const;

    VOID IncrCnx() { if ( ++m_cCurrentCnx > m_acMaxCnxPerPeriod[m_iPeriod] ) m_acMaxCnxPerPeriod[m_iPeriod] = m_cCurrentCnx; }
    VOID DecrCnx() { InterlockedDecrement( &m_cCurrentCnx ); }
    BOOL Init( LPSTR pszKey, UINT cKey, UINT cPrefix, BOOL fSsl );
    DWORD NeedLicenses();
    BOOL AcquireLicenses( HANDLE hAccessToken, DWORD dwN );
    BOOL AdvancePeriod();
    VOID AdjustLicences( LONG cNew );

public:
    static VOID InitCache( VOID );
    static VOID FreeCache( VOID );
    static CCalEntry * Alloc( VOID );
    static VOID Free( CCalEntry * pssc );
    LIST_ENTRY        m_ListEntry;
    LIST_ENTRY        m_FreeListEntry;
    static LIST_ENTRY m_FreeListHead;

private:
    LONG        m_cRefs;
    CBufStr     m_strKey;
    UINT        m_cKeyPrefix;       // size of string before UserName in m_strKey
    BOOL        m_fAcquireLicenses; // FALSE if (SSL or Admin) and do not call LCM to get licenses
    LONG        m_acMaxCnxPerPeriod[CAL_NB_PERIOD];
    UINT        m_iPeriod;
    LONG        m_cCurrentCnx;
    LONG        m_cCurrentLicenses;
#if defined(MULTI_CAL_PER_USER)
    BUFFER      m_bufLicenseHandles;
#else
    LS_HANDLE   m_hLicenseHandle;
#endif
    DWORD       m_dwExemptHandle;
} ;


class CCalHashTable : public HASH_TABLE {

public:
    CCalHashTable( IN DWORD   nBuckets, 
                   IN LPCSTR  pszIdentifier,
                   IN DWORD   dwHashTableFlags
                 ) : HASH_TABLE( nBuckets, pszIdentifier, dwHashTableFlags )
    {
        INITIALIZE_CRITICAL_SECTION( &cs );
        InitializeListHead( &m_ListHead );
    }
    ~CCalHashTable()
    {
        CCalEntry* pE;
        while ( !IsListEmpty( &m_ListHead ))
        {
            pE = CONTAINING_RECORD( m_ListHead.Flink,
                                    CCalEntry,
                                    m_ListEntry );

            RemoveEntryList( &pE->m_ListEntry );

            //
            // Make sure that the base class hash table object has the last remaining 
            // reference to this CCalEntry, so that when the destructor for the base class
            // object is called, the CCalEntry object will get cleaned up
            // 
            DBG_REQUIRE( pE->Dereference() == 1 );

        }
        DeleteCriticalSection( &cs );
    }
    VOID Lock()
    {
        EnterCriticalSection( &cs );
    }
    VOID Unlock()
    {
        LeaveCriticalSection( &cs );
    }
    BOOL Insert( CCalEntry* pE )
    {
        if ( HASH_TABLE::Insert( (HT_ELEMENT*)pE, FALSE ) )
        {
            InsertTailList( &m_ListHead, &pE->m_ListEntry );
            return TRUE;
        }
        return FALSE;
    }
    BOOL Delete( CCalEntry* pE )
    {
        RemoveEntryList( &pE->m_ListEntry );
        return HASH_TABLE::Delete( (HT_ELEMENT*)pE );
    }
    DWORD InitializeIter( CAL_ITERATOR* pI )
    {
        pI->m_pHeadEntry = &m_ListHead;
        pI->m_pNextEntry = m_ListHead.Flink;
        return 0;
    }
    DWORD NextIter( CAL_ITERATOR* pI, CCalEntry** pE )
    {
        if ( pI->m_pHeadEntry != pI->m_pNextEntry )
        {
            *pE = CONTAINING_RECORD( pI->m_pNextEntry,
                                     CCalEntry,
                                     m_ListEntry );
            pI->m_pNextEntry = pI->m_pNextEntry->Flink;
            return 0;
        }
        return ERROR_NO_MORE_ITEMS;
    }  
    DWORD TerminateIter( CAL_ITERATOR* )
    {
        return 0;
    }
private:
    CRITICAL_SECTION    cs;
    LIST_ENTRY          m_ListHead;
} ;


VOID
WINAPI
CalScavenger(
    LPVOID
    );

//
// Globals
//

CCalHashTable*          phtAuth;
CCalHashTable*          phtSsl;
DWORD                   g_dwAuthScavengerWorkItem = NULL;
DWORD                   g_dwSslScavengerWorkItem = NULL;
PSID                    psidAdmins;
DWORD                   g_cSslLicences = 0;     // current count of SSL licences
DWORD                   g_cMaxLicenses = 0;     // max count of licenses
W3_SERVER_STATISTICS*   g_pStats;
DWORD                   g_CnxPerLicense;
LIST_ENTRY              CCalEntry::m_FreeListHead;

IISPNT_LICENSE_REQUEST_A    pfnNtLicenseRequestA = NULL;
PNT_LS_FREE_HANDLE          pfnNtLSFreeHandle = NULL;
HINSTANCE                   g_hLSAPI = NULL;
PGNT_LICENSE_EXEMPTION_A    pfnGntLicenseExemptionA = NULL;
PGNT_LS_FREE_HANDLE         pfnGntLsFreeHandle = NULL;
PGNT_LICENSE_REQUEST_A      pfnGntLicenseRequestA = NULL;
HINSTANCE                   g_hGNTLSAPI = NULL;
BOOL                        g_fEnableCal;
BOOL                        g_fEnableMtsNotification;
BOOL                        g_fUseMtsLicense;

////////////////


VOID
CCalEntry::Print(
    ) const
/*++

Routine Description:

    Print content of entry for debugging purpose

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


DWORD
InitializeCal(
    W3_SERVER_STATISTICS*   pStats,
    DWORD                   dwVcPerLicense,
    DWORD                   dwAuthReserve,
    DWORD                   dwSslReserve
    )
/*++

Routine Description:

    Initialize Cal operations

Arguments:

    pStats - ptr to stat object to update for Cal counters

Return Value:

    NT Status - 0 if no error otherwise error code

--*/
{
    SID_IDENTIFIER_AUTHORITY    siaNt    = SECURITY_NT_AUTHORITY;
    DWORD                       dwStatus = 0;
    DWORD                       dwAuthPeriod;
    DWORD                       dwSslPeriod;
    HKEY                        hkey;
 
    CCalEntry::InitCache();
    phtAuth = NULL;
    phtSsl = NULL;
    g_dwAuthScavengerWorkItem = NULL;
    g_dwSslScavengerWorkItem = NULL;
    g_hLSAPI = NULL;
    psidAdmins = NULL;
    pfnGntLicenseExemptionA = NULL;
    pfnGntLsFreeHandle = NULL;
    g_hGNTLSAPI = NULL;
    g_fEnableCal = FALSE;
    g_fEnableMtsNotification = FALSE;
    g_fUseMtsLicense = FALSE;

    //
    // If not on server, returns status OK but all cal requests will return
    // immediatly w/o license checking.
    //

    if ( !InetIsNtServer( IISGetPlatformType() ) )
    {
        return 0;
    }

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hkey ) == NO_ERROR )
    {
        g_fEnableCal  = !!ReadRegistryDword( hkey,
                                             "EnableCal",
                                             TRUE );

        g_fEnableMtsNotification  = !!ReadRegistryDword( hkey,
                                             "EnableMtsNotification",
                                             FALSE );

        g_fUseMtsLicense  = !!ReadRegistryDword( hkey,
                                             "UseMtsLicense",
                                             FALSE );

        RegCloseKey( hkey );
    }

    if ( !g_fEnableCal )
    {
        return 0;
    }        

    if ( g_hLSAPI = LoadLibrary( "NTLSAPI.DLL") )
    {
        pfnNtLicenseRequestA = (IISPNT_LICENSE_REQUEST_A)GetProcAddress( g_hLSAPI, "NtLicenseRequestA" );
        pfnNtLSFreeHandle = (PNT_LS_FREE_HANDLE)GetProcAddress( g_hLSAPI, "NtLSFreeHandle" );
        if ( !pfnNtLicenseRequestA ||
             !pfnNtLSFreeHandle )
        {
            dwStatus = GetLastError();
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    if ( dwStatus == 0 )
    {
        // optional MTX ( Viper ) DLL

        if ( g_fEnableMtsNotification &&
             (g_hGNTLSAPI = LoadLibrary( "NTLSAPIX.DLL")) )
        {
            pfnGntLicenseExemptionA = (PGNT_LICENSE_EXEMPTION_A)GetProcAddress( g_hGNTLSAPI, "NtLicenseExemptionA" );
            pfnGntLicenseRequestA = (PGNT_LICENSE_REQUEST_A)GetProcAddress( g_hGNTLSAPI, "NtLicenseRequestA" );
            pfnGntLsFreeHandle = (PGNT_LS_FREE_HANDLE)GetProcAddress( g_hGNTLSAPI, "NtLSFreeHandle" );
            if ( !pfnGntLicenseExemptionA ||
                 !pfnGntLicenseRequestA ||
                 !pfnGntLsFreeHandle )
            {
                pfnGntLicenseExemptionA = NULL;
                pfnGntLsFreeHandle = NULL;
                pfnGntLicenseRequestA = NULL;
                FreeLibrary( g_hGNTLSAPI );
                g_hGNTLSAPI = NULL;
            }

            if ( g_hGNTLSAPI && g_fUseMtsLicense )
            {
                pfnNtLicenseRequestA = pfnGntLicenseRequestA;
                pfnNtLSFreeHandle = pfnGntLsFreeHandle;
            }
        }
    }

    if ( dwStatus == 0 )
    {
        phtAuth = new CCalHashTable( 253, "IIS AUTH CAL", 0 );
        phtSsl = new CCalHashTable( 253, "IIS SSL CAL", 0 );

        if ( !phtAuth || !phtSsl )
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( dwStatus == 0 )
    {
        if ( (dwAuthPeriod = (1000 * dwAuthReserve) / (CAL_NB_PERIOD)) < CAL_MIN_PERIOD ) 
        {
            dwAuthPeriod = CAL_MIN_PERIOD;
        }

        if ( (dwSslPeriod = (1000 * dwSslReserve) / (CAL_NB_PERIOD)) < CAL_MIN_PERIOD )
        {
            dwSslPeriod = CAL_MIN_PERIOD;
        }
    }

    // initialize scavenger

    if ( dwStatus == 0 )
    {
        if ( !(g_dwAuthScavengerWorkItem = ScheduleWorkItem( CalScavenger,
                                                             phtAuth,
                                                             dwAuthPeriod,
                                                             TRUE )) )
        {
            dwStatus = GetLastError();
        }
    }

    if ( dwStatus == 0 )
    {
        if ( !(g_dwSslScavengerWorkItem = ScheduleWorkItem( CalScavenger,
                                                            phtSsl,
                                                            dwSslPeriod,
                                                            TRUE )) )
        {
            dwStatus = GetLastError();
        }
    }

    if ( dwStatus == 0 )
    {
        if ( !AllocateAndInitializeSid( &siaNt,
                                        2,
                                        SECURITY_BUILTIN_DOMAIN_RID,
                                        DOMAIN_ALIAS_RID_ADMINS,
                                        0,0,0,0,0,0,
                                        &psidAdmins ) )
        {
            dwStatus = GetLastError();
        }
    }

    if ( dwStatus == 0 )
    {
        // g_pStats = pStats;
        g_pStats = g_pW3Stats;  //  input parameter is wrong

        g_CnxPerLicense = dwVcPerLicense;

        // get #licenses from lsapi

        g_cMaxLicenses = CAL_DEFAULT_MAX_LICENSES;
        g_cSslLicences = 0;

        //
        // sample code for LLSAPI in net\svcdlls\lls\test\llscmd
        //

        LLS_HANDLE                      lsh;
        PLLS_CONNECT_INFO_0             pllsConnectInfo0;
        DWORD                           dwEntries;
        DWORD                           dwTotalEntries;
        DWORD                           dwResumeHandle = 0;
        HINSTANCE                       hLLS;
        PLLS_CONNECT_W                  pfnLlsConnectW = NULL;
        PLLS_CLOSE                      pfnLlsClose = NULL;
        PLLS_FREE_MEMORY                pfnLlsFreeMemory = NULL;
        IISPNT_LLS_PRODUCT_ENUM_W       pfnLlsProductEnumW = NULL;
        IISPNT_LLS_LOCAL_SERVICE_ENUM_W pfnLlsLocalServiceEnumW = NULL;
        LPBYTE                          pBuff;

        if ( hLLS = LoadLibrary( "LLSRPC.DLL") )
        {
            pfnLlsConnectW = (PLLS_CONNECT_W)GetProcAddress( hLLS, "LlsConnectW" );
            pfnLlsProductEnumW = (IISPNT_LLS_PRODUCT_ENUM_W)GetProcAddress( hLLS, "LlsProductEnumW" );
            pfnLlsLocalServiceEnumW = (IISPNT_LLS_LOCAL_SERVICE_ENUM_W)GetProcAddress( hLLS, "LlsLocalServiceEnumW" );
            pfnLlsFreeMemory = (PLLS_FREE_MEMORY)GetProcAddress( hLLS, "LlsFreeMemory" );
            pfnLlsClose = (PLLS_CLOSE)GetProcAddress( hLLS, "LlsClose" );

            if ( pfnLlsConnectW &&
                 pfnLlsLocalServiceEnumW &&
                 pfnLlsFreeMemory &&
                 pfnLlsClose &&
                 pfnLlsConnectW( NULL, 
                                 &lsh ) == STATUS_SUCCESS )
            {
                if ( pfnLlsLocalServiceEnumW( lsh, 
                                              0, 
                                              &pBuff,
                                              4096,
                                              &dwEntries,
                                              &dwTotalEntries,
                                              &dwResumeHandle ) == STATUS_SUCCESS )
                {
                    PLLS_LOCAL_SERVICE_INFO_0       pllsLocalServiceInfo0;
                    UINT    i;

                    pllsLocalServiceInfo0 = (PLLS_LOCAL_SERVICE_INFO_0)pBuff;

                    for ( i = 0 ; i < dwEntries ; ++i, ++pllsLocalServiceInfo0 )
                    {
                        if ( !memcmp( pllsLocalServiceInfo0->KeyName, 
                                      CAL_KEYNAME, 
                                      sizeof(CAL_KEYNAME)-sizeof(WCHAR) ) )
                        {
                            if ( pllsLocalServiceInfo0->Mode == LLS_LICENSE_MODE_PER_SEAT )
                            {
                                g_cMaxLicenses = INT_MAX - 1;
                            }
                            else
                            {
                                g_cMaxLicenses = pllsLocalServiceInfo0->ConcurrentLimit;
                            }
                            break;
                        }
                    }

                    if ( i == dwEntries )
                    {
                        dwStatus = ERROR_MOD_NOT_FOUND;
                    }

                    pfnLlsFreeMemory( pBuff );
                }

                pfnLlsClose( lsh );
            }

            FreeLibrary( hLLS );
        }
        else
        {
            dwStatus = GetLastError();
        }
    }

    if ( dwStatus )
    {
        TerminateCal();
    }

    return dwStatus;
}


VOID
TerminateCal(
    VOID
    )
/*++

Routine Description:

    Terminate Cal operations

Arguments:

    None

Return Value:

    Nothing

--*/
{
    if ( g_dwAuthScavengerWorkItem != NULL )
    {
        RemoveWorkItem( g_dwAuthScavengerWorkItem );
        g_dwAuthScavengerWorkItem = NULL;
    }

    if ( g_dwSslScavengerWorkItem != NULL )
    {
        RemoveWorkItem( g_dwSslScavengerWorkItem );
        g_dwSslScavengerWorkItem = NULL;
    }

    CCalEntry::FreeCache();

    if( psidAdmins != NULL )
    {
        FreeSid( psidAdmins );
        psidAdmins = NULL;
    }

    if ( phtAuth != NULL )
    {
        delete phtAuth;
        phtAuth = NULL;
    }

    if ( phtSsl != NULL )
    {
        delete phtSsl;
        phtSsl = NULL;
    }

    if ( g_hLSAPI )
    {
        FreeLibrary( g_hLSAPI );
    }

    if ( g_hGNTLSAPI )
    {
        FreeLibrary( g_hGNTLSAPI );
    }
}


// can SetLastError( ERROR_ACCESS_DENIED )

BOOL 
CalConnect( 
    LPSTR   pszIpAddr,
    UINT    cIpAddr,
    BOOL    fSsl, 
    LPSTR   pszUserName, 
    UINT    cUserName,
    HANDLE  hAccessToken,
    LPVOID* ppCtx 
    )
/*++

Routine Description:

    Grant or deny access to server.
    Return a license context to be destroyed by CalDisconnect

Arguments:

    psIpAddr - IP address
    cIpAddr - length of IP address ( w/o '\0' )
    fSsl - TRUE if SSL connection, otherwise FALSE
    pszUserName - user name, can be empty for SSL connection
    cUserName - length of pszUserName
    hAccessToken - impersonation access token for user, can be NULL for SSL connection
    ppCtx - updated with ptr to license context, to e destroyed by CalDisconnect

Return Value:

    TRUE if acces granted, otherwise FALSE

--*/
{
    CHAR            achKey[CAL_MAX_KEY_SIZE];
    CCalEntry*      pCal;
    DWORD           dwL;
    BOOL            fSt = TRUE;
    CCalHashTable*  pht;
    CHAR *         pchUser;


    if ( g_hLSAPI == NULL 
         || ( cIpAddr == sizeof("127.0.0.1")-1 &&
              !memcmp( "127.0.0.1", pszIpAddr, cIpAddr ) )
       )
    {
        *ppCtx = NULL;
        return TRUE;
    }

    // build key

    memcpy( achKey, pszIpAddr, cIpAddr );
    achKey[ cIpAddr++ ] = '|';
    achKey[ cIpAddr++ ] = fSsl ? 'S' : ' ';
    achKey[ cIpAddr++ ] = '|';

    //
    //  If there's a domain, strip it and just use the username - this
    //  allows users with the same name from different domains access
    //  to the same CAL but that's such a corner case we'll live with it
    //
    
    if ( pchUser = strchr( pszUserName, '\\' ))
    {
        pchUser++;
        cUserName -= DIFF( pchUser - pszUserName );
    }
    else
    {
        pchUser = pszUserName;
    }
    
    memcpy( achKey + cIpAddr, pchUser, cUserName + 1 );

    //
    //  Convert the name to lower case for later equivalency checking
    //  Note we don't handle the corner case of users with the same
    //  name but in different domains
    //
    
    IISstrlwr( (PUCHAR) achKey + cIpAddr );

    pht = fSsl ? phtSsl : phtAuth;

    // find or create entry

    pht->Lock();

    if ( !(pCal = (CCalEntry*)pht->Lookup( achKey, cIpAddr + cUserName )) )
    {
        pCal = CCalEntry::Alloc();

        if (pCal == NULL)
        {
            pht->Unlock();
            return FALSE;
        }

        pCal->Init( achKey, cIpAddr + cUserName, cIpAddr, fSsl );
        if ( !pht->Insert( pCal ) )
        {
            CCalEntry::Free( pCal );
            pht->Unlock();
            return FALSE;
        }
    }
    else
    {
        //
        // CCalHashTable::Lookup() calls CCalEntry::Reference()
        //
        pCal->Dereference(); 
    }

    // check if license necessary

    if ( dwL = pCal->NeedLicenses() )
    {
        fSt = pCal->AcquireLicenses( hAccessToken, dwL );
    }
    if ( fSt )
    {
        pCal->IncrCnx();
        *ppCtx = pCal;
    }
    else
    {
        *ppCtx = NULL;
    }

    pht->Unlock();

    return fSt;
}


BOOL 
CalDisconnect( 
    LPVOID pCtx 
    )
/*++

Routine Description:

    Destroy a license context created by CalConnect

Arguments:

    pCtx - ptr to license context created by CalConnect

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( g_hLSAPI != NULL && pCtx )
    {
        CCalEntry*  pCal = (CCalEntry*)pCtx;

        // decr #cnx

        pCal->DecrCnx();
    }

    return TRUE;
}


VOID
WINAPI
CalScavenger(
    LPVOID  pV
    )
/*++

Routine Description:

    Ages licence contexts, reclaiming licenses as no longer necessary

Arguments:

    pV - ptr to CCalHashTable to process

Return Value:

    Nothing

--*/
{
    CAL_ITERATOR    it;
    CCalEntry*      pCal;
    CCalHashTable*  pH = (CCalHashTable*)pV;

    // iterate through list of entries

    pH->Lock();

    // update # of licenses, free license & entry if necessary

    if ( pH->InitializeIter( &it ) == 0 )
    {
        while ( pH->NextIter( &it, &pCal) == 0 )
        {
            if ( !pCal->AdvancePeriod() )
            {
                pH->Delete( pCal );
                CCalEntry::Free( pCal );
            }
        }

        pH->TerminateIter( &it );
    }

    pH->Unlock();
}



VOID 
CCalEntry::InitCache( 
    VOID 
    )
/*++

Routine Description:

    Initialize allocation cache for CCalEntry

Arguments:

    None

Return Value:

    Nothing

--*/
{ 
    InitializeListHead( &m_FreeListHead ); 
}


VOID 
CCalEntry::FreeCache( 
    VOID 
    )
/*++

Routine Description:

    Free all entries in allocation cache for CCalEntry

Arguments:

    None

Return Value:

    Nothing

--*/
{
    LIST_ENTRY *    pEntry;
    CCalEntry *     pssc;

    while ( !IsListEmpty( &m_FreeListHead ))
    {
        pssc = CONTAINING_RECORD( m_FreeListHead.Flink,
                                  CCalEntry,
                                  m_FreeListEntry );

        RemoveEntryList( &pssc->m_FreeListEntry );

        delete pssc;
    }
}

//
//  Allocates or frees a context from cache, creating as necessary.  The
//  lock needs to be taken before calling these
//


CCalEntry * 
CCalEntry::Alloc( 
    VOID 
    )
/*++

Routine Description:

    Allocate CCalEntry using allocation cache if not empty

Arguments:

    None

Return Value:

    CCalEntry or NULL if error

--*/
{
    CCalEntry * pssc = NULL;

    if ( !IsListEmpty( &m_FreeListHead ))
    {
        LIST_ENTRY * pEntry = m_FreeListHead.Flink;

        RemoveEntryList( pEntry );

        pssc = CONTAINING_RECORD( pEntry, CCalEntry, m_FreeListEntry );
    }
    else
    {
        pssc = new CCalEntry;
    }

    if ( pssc )
    {
        pssc->Reference();
    }

    return pssc;
}


VOID 
CCalEntry::Free( 
    CCalEntry * pssc 
    )
/*++

Routine Description:

    Put a CCalEntry on the allocation cache

Arguments:

    pssc - CCalEntry to put on allocation cache

Return Value:

    Nothing

--*/
{
    if ( pssc )
    {
        InsertHeadList( &m_FreeListHead,
                        &pssc->m_FreeListEntry );
    }
}


BOOL 
CBufStr::Copy( 
    LPSTR pS, 
    DWORD dwL 
    )
/*++

Routine Description:

    Copy a buffer to a buffered string

Arguments:

    pS - ptr to string
    dwL - length of string ( w/o '\0' )

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( !m_pDynStr )
    {
        if ( dwL >= BUFSTR_DEFAULT_SIZE )
        {
alloc_dyn:
            if ( !(m_pDynStr = (LPSTR)LocalAlloc( LMEM_FIXED, dwL + 1 )) )
            {
                return FALSE;
            }
            memcpy( m_pDynStr, pS, dwL + 1 );
            m_dwMaxDynSize = dwL;
        }
        else
        {
           memcpy( m_achFixedSize, pS, dwL + 1 );
        }
    }
    else
    {
        if ( dwL > m_dwMaxDynSize )
        {
            LocalFree( m_pDynStr );
            goto alloc_dyn;
        }
        memcpy( m_pDynStr, pS, dwL + 1 );
    }

    m_dwSize = dwL;
    return TRUE;
}


BOOL 
CCalEntry::Init( 
    LPSTR pszKey, 
    UINT cKey, 
    UINT cPrefix, 
    BOOL fSsl 
    )
/*++

Routine Description:

    Initialize a CCalEntry

Arguments:

    pszKey - key for hash table insertion
    cKey - length of pszKey ( w/o '\0' )
    cPrefix - # of chars in pszKey before user name
    fSsl - TRUE if SSL connection, otherwise FALSE

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    m_cKeyPrefix = cPrefix;
    m_fAcquireLicenses = !fSsl;
    m_iPeriod = 0;
    m_cCurrentCnx = 0;
    m_cCurrentLicenses = 0;
    memset( m_acMaxCnxPerPeriod, '\0', sizeof(m_acMaxCnxPerPeriod) );
    m_dwExemptHandle = INVALID_CAL_EXEMPT_HANDLE;

    return m_strKey.Copy( pszKey, cKey );
}


DWORD 
CCalEntry::NeedLicenses(
    )
/*++

Routine Description:

    Check if new connection on this entry will require a license

Arguments:

    None

Return Value:

    Number of licenses to acquire to accept new connection

--*/
{
    if ( m_fAcquireLicenses )
    {
#if defined(MULTI_CAL_PER_USER)
        LONG cN = (m_cCurrentCnx+g_CnxPerLicense)/g_CnxPerLicense;
        return  cN > m_cCurrentLicenses ? cN - m_cCurrentLicenses : 0;
#else
        return m_cCurrentLicenses ? 0 : 1;
#endif
    }
    else
    {
        LONG cN = (m_cCurrentCnx+g_CnxPerLicense)/g_CnxPerLicense;
        return  cN > m_cCurrentLicenses ? cN - m_cCurrentLicenses : 0;
    }
}


BOOL 
CCalEntry::AcquireLicenses( 
    HANDLE  hAccessToken, 
    DWORD   dwN 
    )
/*++

Routine Description:

    Acquire licenses for this entry

Arguments:

    hAccessToken - access token associated with the user name for authenticated cnx
      can be NULL for SSL connection.
    dwN - # of licenses to acquire

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LS_HANDLE   hLicense;
    LS_STATUS_CODE dwLsStatus = 0;

    if ( m_fAcquireLicenses )
    {
        dwN = 1;

        NT_LS_DATA  ls;

        ls.DataType = NT_LS_USER_NAME;
        ls.Data = (LPVOID)(m_strKey.QueryStr() + m_cKeyPrefix);
        ls.IsAdmin = FALSE;
ckagain:
        if ( ( dwLsStatus = pfnNtLicenseRequestA(  IIS_LSAPI_NAME,
                                                 IIS_LSAPI_VERSION,
                                                 &hLicense,
                                                 &ls ) ) )
        {
            // check if admin

            if ( ls.IsAdmin == FALSE &&
                 CheckTokenMembership( hAccessToken,
                                      psidAdmins,
                                      &ls.IsAdmin ))
            {
                if ( ls.IsAdmin )
                {
                    goto ckagain;
                }
            }

            g_pStats->IncrTotalFailedCalAuth();
            SetLastError( ERROR_ACCESS_DENIED );

            return FALSE;
        }
        
#if defined(MULTI_CAL_PER_USER)
        if ( m_bufLicenseHandles.Resize( (m_cCurrentLicenses+dwN)*sizeof(LS_HANDLE) ) )
        {
            *(LS_HANDLE*)((LPBYTE)m_bufLicenseHandles.QueryPtr()+m_cCurrentLicenses*sizeof(LS_HANDLE))
                = hLicense;
        }
        else
        {
            if ( dwLsStatus = pfnNtLSFreeHandle( hLicense ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Status 0x%x returned from releasing license associated with CCalEntry 0x%p\n", dwLsStatus, this));
            }

            return FALSE;
        }
#else
        m_hLicenseHandle = hLicense;
#endif

        //
        // If this is the 1st license for this entry, 
        // signal to MTX this user name is exempt of further licensing checks
        // if we are using MTS license service then no need to call CalExemptAddRef

        if ( !m_cCurrentLicenses && !g_fUseMtsLicense )
        {
            CalExemptAddRef( IIS_LSAPI_NAME, 
                             IIS_LSAPI_VERSION,
                             &m_dwExemptHandle,
                             &ls );
        }

        m_cCurrentLicenses += dwN;
        while ( dwN-- )
        {
            g_pStats->IncrCurrentCalAuth();
        }
                   
    }
    else
    {
        if ( g_cSslLicences + dwN > g_cMaxLicenses )
        {
            g_pStats->IncrTotalFailedCalSsl();
            SetLastError( ERROR_ACCESS_DENIED );
            return FALSE;
        }
        g_cSslLicences += dwN;
        m_cCurrentLicenses += dwN;
        while ( dwN-- )
        {
            g_pStats->IncrCurrentCalSsl();
        }
    }
    return TRUE;
}


BOOL 
CCalEntry::AdvancePeriod(
    )
/*++

Routine Description:

    Adjust number of licenses by aging # of connections in cache

Arguments:

    None

Return Value:

    TRUE if entry still needed ( license to be held in cache ), 
    FALSE if entry can be deleted.

--*/
{
    LONG    iM = 0;
    UINT    i;

    for ( i = 0 ; i < CAL_NB_PERIOD ; ++i )
    {
        if ( m_acMaxCnxPerPeriod[i] > iM )
        {
            iM = m_acMaxCnxPerPeriod[i];
        }
    }
    if ( ++m_iPeriod == CAL_NB_PERIOD )
    {
        m_iPeriod = 0;
    }
    m_acMaxCnxPerPeriod[m_iPeriod] = m_cCurrentCnx;

    if ( m_fAcquireLicenses )
    {
        AdjustLicences( (iM+g_CnxPerLicense-1)/g_CnxPerLicense );
    }
    else
    {
        LONG cNewLicenses = (iM+g_CnxPerLicense-1)/g_CnxPerLicense;
        // update global ssl count
        while ( cNewLicenses < m_cCurrentLicenses )
        {
            g_pStats->DecrCurrentCalSsl();
            --m_cCurrentLicenses;
            --g_cSslLicences;
        }
    }

    return iM;
}


VOID
CCalEntry::AdjustLicences(
    LONG    cNew
    )
/*++

Routine Description:

    Adjust number of licenses in this entry

Arguments:

    cNew - new number of licenses

Return Value:

    None

--*/
{
    LS_STATUS_CODE dwLSStatus;

#if defined(MULTI_CAL_PER_USER)
    while ( m_cCurrentLicenses > cNew )
    {
        if ( dwLSStatus = pfnNtLSFreeHandle( 
                                             *(LS_HANDLE*)((LPBYTE)m_bufLicenseHandles.QueryPtr()+
                                              (m_cCurrentLicenses-1)*sizeof(LS_HANDLE)) ) )
        {
            DBGPRINTF((DBG_CONTEXT,"Status 0x%x returned from releasing license associated with CAL 0x%p\n", dwLSStatus, this));
        }

        g_pStats->DecrCurrentCalAuth();
        --m_cCurrentLicenses;
    }
#else
    if ( !iM && m_cCurrentLicenses )
    {
        if ( dwLSStatus = pfnNtLSFreeHandle( m_hLicenseHandle ) )
        {
            DBGPRINTF((DBG_CONTEXT,"Status 0x%x returned from releasing license associated with CAL 0x%p\n", dwLSStatus, this));
        }

        g_pStats->DecrCurrentCalAuth();
        m_cCurrentLicenses = 0;
    }
#endif
    //
    // We don't hold any license, so if we called CalExemptAddRef
    // then call release now.
    //

    if ( !m_cCurrentLicenses && 
         m_dwExemptHandle != INVALID_CAL_EXEMPT_HANDLE )
    {
        CalExemptRelease( m_dwExemptHandle );
        m_dwExemptHandle = INVALID_CAL_EXEMPT_HANDLE;
    }
}


BOOL
CalExemptAddRef(
    LPSTR   pszAcct,
    LPDWORD pdwHnd
    )
/*++

Routine Description:

    Flag an account name as exempt of further license check
    for the MTX licensing package.

Arguments:

    pszAcct - account name to be exempted
    pdwHnd - updated with handle to exempted context, to be released with CalExemptRelease

Return Value:

    TRUE if success, otherwise FALSE
    LastError can be set to ERROR_MOD_NOT_FOUND if MTX licensing package not found

--*/
{
    NT_LS_DATA  ls;

    ls.DataType = NT_LS_USER_NAME;
    ls.Data = pszAcct;
    ls.IsAdmin = FALSE;

    return CalExemptAddRef( IIS_LSAPI_NAME, IIS_LSAPI_VERSION, pdwHnd, &ls );
}


BOOL
CalExemptAddRef(
    LPSTR       ProductName,
    LPSTR       Version,
    DWORD       *LicenseHandle,
    NT_LS_DATA  *NtData
    )
/*++

Routine Description:

    Flag an account name as exempt of further license check
    for the MTX licensing package.

Arguments:

    ProductName - product name for license usage tracking purpose
    Version - product version for license usage tracking purpose
    LicenseHandle - updated with handle to exempted context, to be released with CalExemptRelease
    NtData - ptr to license data ( user name )

Return Value:

    TRUE if success, otherwise FALSE
    LastError can be set to ERROR_MOD_NOT_FOUND if MTX licensing package not found

--*/
{
    if ( pfnGntLicenseExemptionA )
    {
        DWORD dwS = pfnGntLicenseExemptionA( ProductName,
                                             Version,
                                             (LS_HANDLE*)LicenseHandle,
                                             NtData );
        if ( dwS )
        {
            SetLastError( dwS );
            return FALSE;
        }

        return TRUE;
    }

    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}


BOOL
CalExemptRelease(
    DWORD   dwHnd
    )
/*++

Routine Description:

    Release a reference returned by CalExemptAddRef

Arguments:

    dwHnd - handle to exempted context as returned by CalExemptAddRef

Return Value:

    TRUE if success, otherwise FALSE
    LastError can be set to ERROR_MOD_NOT_FOUND if MTX licensing package not found

--*/
{
    if ( pfnGntLsFreeHandle )
    {
        DWORD dwS = pfnGntLsFreeHandle( (LS_HANDLE)dwHnd );
        if ( dwS )
        {
            SetLastError( dwS );
            return FALSE;
        }

        return TRUE;
    }

    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\doget.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    doget.cxx

    This module contains the code for the GET and HEAD verb


    FILE HISTORY:
        Johnl       23-Aug-1994     Created
        Phillich    24-Jan-1996     Added support for NCSA map files
        Phillich    20-Feb-1996     Added support for byte ranges

*/

#include "w3p.hxx"

//
//  Private constants.
//

//
//  Computes the square of a number. Used for circle image maps
//

#define SQR(x)      ((x) * (x))

//
//  Maximum number of vertices in image map polygon
//

#define MAXVERTS    160

//
//  Point offset of x and y
//

#define X           0
#define Y           1

//
//  Private globals.
//

#define BOUNDARY_STRING_DEFINITION  "[lka9uw3et5vxybtp87ghq23dpu7djv84nhls9p]"

// The boundary string is preceded by a line delimiter ( cf RFC 1521 )
// This can be set to "\n" instead of "\r\n" as Navigator 2.0 apparently handles
// all bytes before the "\n" as part of the reply body.

#define BOUNDARY_STRING             "\r\n--" BOUNDARY_STRING_DEFINITION "\r\n"
#define LAST_BOUNDARY_STRING        "\r\n--" BOUNDARY_STRING_DEFINITION "--\r\n\r\n"

// addition to 1st delimiter of boundary string ( can be "\r" if not included
// in BOUNDARY_STRING )

#define DELIMIT_FIRST               ""
#define ADJ_FIRST                   (2-(sizeof(DELIMIT_FIRST)-1))

#define MMIME_TYPE_1                "Content-Type: "
#define MMIME_TYPE_2                "\r\n"
#define MMIME_TYPE                  MMIME_TYPE_1 \
                                    "%s" \
                                    MMIME_TYPE_2
char g_achMMimeTypeFmt[] =          MMIME_TYPE_1 MMIME_TYPE_2;

#define MMIME_RANGE_1               "Content-Range: bytes "
#define MMIME_RANGE_2               "-"
#define MMIME_RANGE_3               "/"
#define MMIME_RANGE_4               "\r\n\r\n"
#define MMIME_RANGE                 MMIME_RANGE_1 \
                                    "%u" \
                                    MMIME_RANGE_2 \
                                    "%u" \
                                    MMIME_RANGE_3 \
                                    "%u" \
                                    MMIME_RANGE_4

char g_achMMimeRangeFmt[] =         MMIME_RANGE_1
                                    MMIME_RANGE_2
                                    MMIME_RANGE_3
                                    MMIME_RANGE_4;


#define MIN_ADDL_BUF_HDR_SIZE_CACHED    (sizeof("Date: ") - 1 + \
                                   sizeof("Mon, 00 Jan 0000 00:00:00 GMT\r\n") - 1 +\
                                   MAX_SIZE_HTTP_INFO)

#define MIN_ADDL_BUF_HDR_SIZE       (sizeof("Content-Type: \r\n") - 1 + \
                                    sizeof("Accept-Ranges: bytes\r\n") - 1 + \
                                    sizeof("Last-Modified: ") - 1 +\
                                    sizeof("Mon, 00 Jan 0000 00:00:00 GMT\r\n") - 1 +\
                                    sizeof("ETag: W/\r\n") - 1 + \
                                    MAX_ETAG_BUFFER_LENGTH + \
                                    sizeof("Content-Length: 4294967295\r\n\r\n") - 1)


#define RANGE_ADDL_BUF_HDR_SIZE     (sizeof("Content-Type: multipart/x-byteranges; boundary=")\
                                    - 1 + sizeof(BOUNDARY_STRING) - 1 + \
                                    sizeof("Date: ") - 1 + \
                                    sizeof("Mon, 00 Jan 0000 00:00:00 GMT\r\n") - 1 +\
                                    sizeof("Accept-Ranges: bytes\r\n") - 1 + \
                                    sizeof("Last-Modified: ") - 1 +\
                                    sizeof("Mon, 00 Jan 0000 00:00:00 GMT\r\n") - 1 +\
                                    sizeof("ETag: W/\r\n") - 1 + \
                                    MAX_ETAG_BUFFER_LENGTH + \
                                    sizeof("Content-Length: 4294967295\r\n\r\n") - 1)

//
//  Private prototypes.
//

BOOL SearchMapFile( LPTS_OPEN_FILE_INFO gFile,
                    CHAR *              pchFile,
                    TSVC_CACHE *        pTsvcCache,
                    HANDLE              hToken,
                    INT                 x,
                    INT                 y,
                    STR *               pstrURL,
                    BOOL *              pfFound,
                    BOOL                fmayCacheAccessToken );

int pointinpoly(int x, int y, double pgon[MAXVERTS][2]);

INT GetNumber( CHAR * * ppch );

DWORD NbDigit( DWORD dw );

//
//  Public functions.
//


//
//  Private functions.
//


// Forward references.
extern BOOL DisposeOpenURIFileInfo(IN  PVOID   pvOldBlock);



DWORD NbDigit( DWORD dw )
{
    if ( dw < 10 )
    {
        return 1;
    }
    else if ( dw < 100 )
    {
        return 2;
    }
    else if ( dw < 1000 )
    {
        return 3;
    }
    else if ( dw < 10000 )
    {
        return 4;
    }
    else if ( dw < 100000 )
    {
        return 5;
    }
    else if ( dw < 1000000 )
    {
        return 6;
    }

    DWORD cD = 7;
    for ( dw /= 10000000 ; dw ; ++cD )
    {
        dw /= 10;
    }

    return cD;
}

LPSYSTEMTIME
MinSystemTime(
    LPSYSTEMTIME Now,
    LPSYSTEMTIME Other
    )

/*++

Routine Descriptions:

    Compare to systemtime dates, and return a pointer to the earlier one.

Arguments:

    Now     - The current date.
    Other   - Other date to compare.

Return Value:

    Pointer to the earlier of Now and Other.

--*/
{
    if (Now->wYear > Other->wYear)
    {
        return Other;
    }
    else
    {
        if (Now->wYear == Other->wYear)
        {
            if (Now->wMonth > Other->wMonth)
            {
                return Other;
            }
            else
            {
                if (Now->wMonth == Other->wMonth)
                {
                    if (Now->wDay > Other->wDay)
                    {
                        return Other;
                    }
                    else
                    {
                        if (Now->wDay == Other->wDay)
                        {
                            if (Now->wHour > Other->wHour)
                            {
                                return Other;
                            }
                            else
                            {
                                if (Now->wHour == Other->wHour)
                                {
                                    if (Now->wMinute > Other->wMinute)
                                    {
                                        return Other;
                                    }
                                    else
                                    {
                                        if (Now->wMinute == Other->wMinute)
                                        {
                                            if (Now->wSecond > Other->wSecond)
                                            {
                                                return Other;
                                            }
                                            else
                                            {
                                                if (Now->wSecond == Other->wSecond)
                                                {
                                                    if (Now->wMilliseconds >= Other->wMilliseconds)
                                                    {
                                                        return Other;
                                                    }
                                                    else
                                                    {
                                                        return Now;
                                                    }
                                                }
                                                else
                                                {
                                                    return Now;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            return Now;
                                        }
                                    }
                                }
                                else
                                {
                                return Now;
                                }
                            }
                        }
                        else
                        {
                            return Now;
                        }
                    }
                }
                else
                {
                    return Now;
                }
            }
        }
        else
        {
            return Now;
        }
    }

}


BOOL
HTTP_REQUEST::DoTraceCk(
    BOOL * pfFinished
    )
/*++

Routine Description:

    Handle a TRACECK request ( used by WolfPack as non-logged TRACE request )
    Basically echo the client request as a message body

Arguments:

    None

Return Value:

    TRUE if success, else FALSE

--*/
{
    return DoTrace( pfFinished );
}


BOOL
HTTP_REQUEST::DoTrace(
    BOOL * pfFinished
    )
/*++

Routine Description:

    Handle a TRACE request ( cf HTTP 1.1 spec )
    Basically echo the client request as a message body

Arguments:

    None

Return Value:

    TRUE if success, else FALSE

--*/
{
    BUFFER buHeader;
    BOOL fHandled = FALSE;
    LPSTR pszResp;
    LPSTR pszTail;
    UINT cHeaderSize;
    UINT cMsgSize;
    DWORD dwWrt;
    DWORD cbContentLength;


    //
    // build response header
    //

    if ( !buHeader.Resize( MIN_BUFFER_SIZE_FOR_HEADERS ) )
    {
        return FALSE;
    }

    if ( !BuildBaseResponseHeader( &buHeader,
                                   &fHandled,
                                   NULL,
                                   0 ))
    {
        return FALSE;
    }

    if ( fHandled )
    {
        return TRUE;
    }

    cHeaderSize = strlen( (PSTR)buHeader.QueryPtr() );

    if (!buHeader.Resize(cHeaderSize + sizeof("Content-Type: message/http\r\n")
                        - 1 + sizeof("Content-Length:  4294967295\r\n\r\n") - 1))
    {
        return FALSE;
    }

    pszResp = (PSTR) buHeader.QueryPtr();
    pszTail = pszResp + cHeaderSize;
    cMsgSize = _cbClientRequest + _cbContentLength;

    APPEND_STRING( pszTail, "Content-Type: message/http\r\n" );
    pszTail += wsprintf( pszTail,
             "Content-Length: %lu\r\n\r\n",
              cMsgSize );

    SetState( HTR_DONE, HT_OK, NO_ERROR );

    //
    // send response header
    //

    if ( !SendHeader( (CHAR *) buHeader.QueryPtr(),
                      (DWORD) (pszTail - (PSTR)buHeader.QueryPtr()),
                      IO_FLAG_SYNC,
                      pfFinished ))
    {
        return FALSE;
    }

    if ( *pfFinished )
        return TRUE;

    //
    // send echo of request headers
    // NOTE : we're using the original client buffer because a filter may have
    // modified the server response buffer
    //
    
    cbContentLength = _cbContentLength;

    if (! WriteFile( (PSTR) _bufClientRequest.QueryPtr(),
                     _cbClientRequest,
                     &dwWrt,
                     cbContentLength ? IO_FLAG_SYNC : IO_FLAG_ASYNC ) )
    {
        return FALSE;
    }

    //
    // send echo of request message body
    //

    if ( cbContentLength &&
        !WriteFile( (PSTR)_bufClientRequest.QueryPtr()
                        + _cbClientRequest,
                    cbContentLength,
                    NULL,
                    IO_FLAG_ASYNC ) )
    {
        return FALSE;
    }

    return TRUE;
}

/*******************************************************************

    NAME:       HTTP_REQUEST::DoGet

    SYNOPSIS:   Transmits a the specified file or directory in response
                to a Get or Head request

    RETURNS:    TRUE if successful, FALSE on error

                FALSE should be returned for fatal errors (memory etc),
                a server error response will be sent with error text from
                GetLastError()

                For other errors (access denied, path not found etc)
                disconnect with status should be called and TRUE should be
                returned.

                If no further processing is needed (and the caller needs to
                setup for the next request), set *pfFinished to TRUE

    NOTES:      The file handle gets closed during destruction

                We never retrieve a hidden file or directory.  We will process
                hidden map files however.

    HISTORY:
        Johnl       29-Aug-1994 Created

********************************************************************/

BOOL
HTTP_REQUEST::DoGet(
    BOOL * pfFinished
    )
{
    BOOL                        fHandled = FALSE;
    DWORD                       cbSizeLow;
    DWORD                       cbSizeHigh;
    BOOL                        fHidden;
    BOOL                        fMatches;
    DWORD                       dwMask;
    BOOL                        fSendFile = (QueryVerb() == HTV_GET);
    PW3_SERVER_INSTANCE         pInstance = QueryW3Instance();
    DWORD                       err;

    //
    //  Open the file (or directory)
    //

    IF_DEBUG( REQUEST )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "SendFileOrDir: Opening %s\n",
                   _strPhysicalPath.QueryStr()));
    }

    if ( !IS_ACCESS_ALLOWED(READ) && !_fPossibleDefaultExecute )
    {
        DBGPRINTF((DBG_CONTEXT,
                    "ACCESS_DENIED. No Read Permission for URL %s (Physical Path: %s)\n",
                   _strURL.QueryStr(),
                   _strPhysicalPath.QueryStr()));

        SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );

        Disconnect( HT_FORBIDDEN,
                    IDS_READ_ACCESS_DENIED,
                    FALSE,
                    pfFinished );

        return TRUE;
    }

    if (*_strURL.QueryStr() == '*')
    {
        // Don't allow GETs on the server URL.
        SetState( HTR_DONE, HT_BAD_REQUEST, ERROR_INVALID_PARAMETER );

        Disconnect( HT_BAD_REQUEST,
                    NULL,
                    FALSE,
                    pfFinished );

        return TRUE;
    }

    if( _strURL.QueryCCH() > MAX_URI_LENGTH )
    {
        SetState( HTR_DONE, HT_URL_TOO_LONG, ERROR_INSUFFICIENT_BUFFER);
        Disconnect( HT_URL_TOO_LONG, IDS_URL_TOO_LONG, FALSE, pfFinished);
        return TRUE;
    }
        
    if ( _pURIInfo == NULL )
    {
        if ( !CacheUri( QueryW3Instance(),
                        &_pURIInfo,
                        _pMetaData,
                        _strURL.QueryStr(),
                        _strURL.QueryCCH(),
                        &_strPhysicalPath,
                        &_strUnmappedPhysicalPath ) )
        {
            return FALSE;
        }
    }
    
    if ( _pMetaData->QueryDoCache() && !_pMetaData->QueryVrError() )
    {
        _pGetFile = TsCreateFileFromURI(pInstance->GetTsvcCache(),
                                        _pURIInfo,
                                        QueryImpersonationHandle( FALSE ),
                                        TS_NOT_IMPERSONATED
                                        | ((_fClearTextPass || _fAnonymous) ? 0 :
                                            TS_DONT_CACHE_ACCESS_TOKEN)
                                        | (DoAccessCheckOnUrl()
                                            ? 0 : TS_NO_ACCESS_CHECK ),
                                        &err
                                        );
    }
    else
    {
        _pGetFile = TsCreateFile( pInstance->GetTsvcCache(),
                                  _strPhysicalPath.QueryStr(),
                                  QueryImpersonationHandle(),
                                  TS_NOT_IMPERSONATED );

        if (_pGetFile == NULL) {
            err = GetLastError();
        }
    }

    if ( _pGetFile == NULL ) {

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,
                  "DoGetHeadAux: Failed to open %s, error %d\n",
                   _strURL.QueryStr(),
                   err ));
        }

        if ( err == ERROR_FILE_NOT_FOUND ||
             err == ERROR_PATH_NOT_FOUND ||
             err == ERROR_INVALID_NAME )
        {
            SetState( HTR_DONE, HT_NOT_FOUND, err );
            Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
            return TRUE;
        }

        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            // Really means the file name was too long.

            SetState(HTR_DONE, HT_URL_TOO_LONG, err);
            Disconnect(HT_URL_TOO_LONG, IDS_URL_TOO_LONG, FALSE, pfFinished );
            return TRUE;
        }

        if ( err == ERROR_ACCESS_DENIED )
        {
            DBGPRINTF((DBG_CONTEXT,
                        "ACCESS_DENIED. ACLs restricting acess to URL %s (Physical Path: %s)\n",
                        _strURL.QueryStr(), _strPhysicalPath.QueryStr()));

            DBGPRINTF((DBG_CONTEXT,
                        "User: %s, AuthorizationType: %s\n",
                        _strUserName.QueryStr(), _strAuthType.QueryStr()));

            SetDeniedFlags( SF_DENIED_RESOURCE );
        }

        return FALSE;
    }


    fHidden = ((_pGetFile->QueryAttributes() & FILE_ATTRIBUTE_HIDDEN) != 0);


    //
    //  If the file is a directory, then we may need to do a directory listing
    //

    if ( _pGetFile->QueryAttributes() & FILE_ATTRIBUTE_DIRECTORY &&
         (QueryVerb() == HTV_GET || QueryVerb() == HTV_HEAD) )
    {
        DWORD dirBrowFlags;

        if ( fHidden )
        {
            SetState( HTR_DONE, HT_NOT_FOUND, ERROR_PATH_NOT_FOUND );
            Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
            return TRUE;
        }

        //
        //  If a default file is in the directory and the feature is enabled,
        //  then return the default file to the user
        //

        dirBrowFlags = QueryDirBrowseFlags();

        if ( dirBrowFlags & DIRBROW_LOADDEFAULT )
        {
            if ( !CheckDefaultLoad( &_strPhysicalPath, &fHandled, pfFinished ))
            {
                if ( GetLastError() == ERROR_ACCESS_DENIED )
                {
                    SetDeniedFlags( SF_DENIED_RESOURCE );
                }

                return FALSE;
            }

            if ( fHandled || *pfFinished )
            {
                return TRUE;
            }
        }

        //
        //  We're doing a directory listing, so send the directory list
        //  with the response headers.  The request is finished at that
        //  point.
        //

        SetState( HTR_DONE, HT_OK, NO_ERROR );

        if ( dirBrowFlags & DIRBROW_ENABLED )
        {
            return DoDirList( _strPhysicalPath, QueryRespBuf(), pfFinished );
        }

        DBGPRINTF((DBG_CONTEXT,
                  "[DoDirList] Denying request for directory browsing\n"));

        SetLogStatus( HT_FORBIDDEN, ERROR_ACCESS_DENIED );

        Disconnect( HT_FORBIDDEN, IDS_DIR_LIST_DENIED, FALSE, pfFinished );
        return TRUE;
    }

    //
    //  We're dealing with a file.  Is it an ismap request?
    //

    if ( _GatewayType == GATEWAY_MAP )
    {
        BOOL fFound = FALSE;

        //
        //  This may be an ISMAP request so check the parameters and process
        //  the map file if it is.  _hGetFile is a map file if it is.
        //

        if ( !ProcessISMAP( _pGetFile,
                            _strPhysicalPath.QueryStr(),
                            QueryRespBuf(),
                            &fFound,
                            &fHandled ))
        {
            return FALSE;
        }

        if ( fHandled )
        {
            return TRUE;
        }

        if ( fFound )
        {
            SetState( HTR_DONE, HT_OK, NO_ERROR );

            return SendHeader( QueryRespBufPtr(),
                               (DWORD) -1,
                               IsKeepConnSet() ?
                               (IO_FLAG_ASYNC | IO_FLAG_AND_RECV) :
                               IO_FLAG_ASYNC,
                               pfFinished );
        }
    }

    if ( fHidden )
    {
        SetState( HTR_DONE, HT_NOT_FOUND, ERROR_FILE_NOT_FOUND );
        Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
        return TRUE;
    }

    //
    //  At this point we know the user wants to retrieve the file
    //


    // If we're currently using a weak ETag for this file, try to make it
    // strong.
    if (_pGetFile->WeakETag())
    {
        _pGetFile->MakeStrongETag();
    }

    //
    //  If the client sent an If-* modifier, check it now. Skip if Custom Error
    //

    if ( _fIfModifier && !_bProcessingCustomError)
    {
        BOOL    bReturn;

        if (CheckPreconditions(_pGetFile, pfFinished, &bReturn))
        {
            return bReturn;

        }
    }

    TCP_REQUIRE( _pGetFile->QuerySize( &cbSizeLow,
                                       &cbSizeHigh ));

    // check if range requested

    DWORD dwOffset;
    DWORD dwSizeToSend;
    BOOL fIsNxRange;


    _fAcceptRange = pInstance->IsAcceptByteRanges();

    if ( _fAcceptRange && !_strRange.IsEmpty() && fSendFile )
    {
        ProcessRangeRequest( &_strPhysicalPath,
                &dwOffset,
                &dwSizeToSend,
                &fIsNxRange );

        //
        // Error HT_RANGE_NOT_SATISFIABLE if we saw no valid ranges and we saw an
        // unsatisfiable byte range and no If-Range header was sent.
        //

        if ( (!_fProcessByteRange) &&  _fUnsatisfiableByteRange &&
             ( NULL == _HeaderList.FastMapQueryValue(HM_IFR)))
        {
            CHAR    ach[17];

            STR * pstrAdditionalHeader = QueryAdditionalRespHeaders();

            _itoa( cbSizeLow, ach, 10 );

            pstrAdditionalHeader->Append("Content-Range: bytes */");
            pstrAdditionalHeader->Append(ach);
            pstrAdditionalHeader->Append("\r\n");

            SetState( HTR_DONE, HT_RANGE_NOT_SATISFIABLE, NO_ERROR );
            Disconnect( HT_RANGE_NOT_SATISFIABLE, NO_ERROR, FALSE, pfFinished );
            return TRUE;
        }

        if ( !BuildResponseHeader( QueryRespBuf(),
                                   &_strPhysicalPath,
                                   _pGetFile,
                                   &fHandled,
                                   NULL,
                                   pfFinished ))
        {
            return FALSE;
        }
    }

    //
    //  Build the header response based on file type and client
    //  requests
    //
    //  It's possible we may not want to send the file (if the client
    //  doesn't have a needed MIME type for example)
    //

    else if ( !BuildFileResponseHeader( QueryRespBuf(),
                               &_strPhysicalPath,
                               _pGetFile,
                               &fHandled,
                               pfFinished ))
    {
        return FALSE;
    }

    if ( fHandled )
    {
        return TRUE;
    }

    //
    //  Send the header response and file and cleanup the request
    //

    if ( !fSendFile )
    {
        SetState( HTR_DONE, HT_OK, NO_ERROR );

        return SendHeader( QueryRespBufPtr(),
                           QueryRespBufCB(),
                           (IsKeepConnSet() &&
                            (_cbBytesReceived == _cbClientRequest)) ?
                           (IO_FLAG_ASYNC | IO_FLAG_AND_RECV) :
                           IO_FLAG_ASYNC,
                           pfFinished );
    }

    //
    //  Refuse requests for files greater then four gigs
    //

    if ( cbSizeHigh )
    {
        SetState( HTR_DONE, HT_NOT_SUPPORTED, ERROR_NOT_SUPPORTED );
        Disconnect( HT_NOT_SUPPORTED, NO_ERROR, FALSE, pfFinished );
        return TRUE;
    }

    //
    //  Notify filters of the headers we're about to send
    //

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_SEND_RESPONSE,
                                       IsSecurePort() ))
    {
        if ( !_Filter.NotifySendHeaders( QueryRespBufPtr(),
                                         pfFinished,
                                         NULL,
                                         QueryRespBuf() ))
        {
            return FALSE;
        }

        if ( *pfFinished )
        {
            return TRUE;
        }
    }


    if ( _fProcessByteRange )
    {
        if ( fIsNxRange )
        {
            SetState( HTR_RANGE, HT_RANGE, NO_ERROR );
        }
        return SendRange( QueryRespBufCB(), dwOffset, dwSizeToSend, !fIsNxRange );
    }
    else
    {
        DWORD dwIOFlags = IO_FLAG_ASYNC;

        //
        //  If a filter needs a send response notification, keep the socket open
        //  and make sure we receive the TransmitFile completion
        //  otherwise if this is not a keep-alive connection, tell ATQ to
        //  disconnect after sending the file
        //

        if ( _Filter.IsNotificationNeeded( SF_NOTIFY_END_OF_REQUEST,
                                           IsSecurePort() ))
        {
            dwIOFlags |= IO_FLAG_NO_RECV;
        }
        else if ( !IsKeepConnSet() )
        {
            dwIOFlags |= TF_DISCONNECT | TF_REUSE_SOCKET;
        }

        SetState( HTR_DONE, HT_OK, NO_ERROR );

        //
        // If we've still got unprocessed data left in the buffer, don't
        // allow a receive after the transmit file.
        //
        if (_cbBytesReceived > _cbClientRequest)
        {
            dwIOFlags |= IO_FLAG_NO_RECV;
        }

        if ( !TransmitFile( _pGetFile,
                            NULL,
                            0,
                            cbSizeLow,
                            dwIOFlags,
                            QueryRespBufPtr(),
                            QueryRespBufCB() ,
                            QueryMetaData()->QueryFooter(),
                            QueryMetaData()->QueryFooterLength())
                            )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "DoGetHeadAux: TransmitFile failed sending header, error %d\n",
                       GetLastError() ));

            return FALSE;
        }

    }

    return TRUE;
}


DWORD AToDW(
    LPSTR *ppRng,
    BOOL *pfIsB
    )
/*++

  Routine Description:

    Convert ASCII to DWORD, set flag stating presence
    of a numeric value, update pointer to character stream

  Returns:
    DWORD value converted from ASCII

  Arguments:

    ppRng       PSTR to numeric value, updated on return
    pfIsB       flag set to TRUE if numeric value present on return

  History:
    Phillich    08-Feb-1996 Created

--*/
{
    LPSTR pRng = *ppRng;
    DWORD dwV = 0;

    if ( isdigit( (UCHAR)(*pRng) ) )
    {
        int c;
        while ( (c = *pRng) && isdigit( (UCHAR)c ) )
        {
            dwV = dwV * 10 + c - '0';
            ++pRng;
        }
        *pfIsB = TRUE;
        *ppRng = pRng;
    }
    else
    {
        *pfIsB = FALSE;
    }

    return dwV;
}


void
HTTP_REQUEST::ProcessRangeRequest(
    STR *       pstrPath,
    DWORD *     pdwOffset,
    DWORD *     pdwSizeToSend,
    BOOL *      pfIsNxRange )
/*++

  Routine Description:

    Process a range request, updating member variables

  Returns:

    VOID

  Arguments:

    pstrPath        File being requested
    pdwOffset       Range offset
    pdwSizeToSend   Range size
    pfIsNxRange     TRUE if valid next range exists

  History:
    Phillich    08-Feb-1996 Created

--*/
{

    DWORD       cbSizeLow;
    DWORD       cbSizeHigh;

    FILETIME    tm;

    BOOL        fEntireFile;        // Indicates: Skip all Range headers. Send Entire File
    BOOL        fIsLastRange;       // Indicates: No valid range after this.

    //
    // Check range specified & optional UnlessModifiedSince
    //

    TCP_REQUIRE( _pGetFile->QueryLastWriteTime( &tm ));

    TCP_REQUIRE( _pGetFile->QuerySize( &cbSizeLow,
                                       &cbSizeHigh ));

    if ( !_liUnlessModifiedSince.QuadPart ||
         *(LONGLONG*)&tm <= _liUnlessModifiedSince.QuadPart )
    {
        //
        // Run through all valid ranges
        //

        DWORD cRanges           = 0;
        DWORD dwContentLength   = 0;
        DWORD dwFirstRangeEnd   = 0;
        DWORD dwFx              = 0;

        while ( ScanRange(  &_dwRgNxOffset,
                            &_dwRgNxSizeToSend,
                            &fEntireFile,
                            &fIsLastRange ))
        {
            _fProcessByteRange = TRUE;              // At least one range to process

            if (fEntireFile)
            {
                //
                // Ignore Range headers. Send Full File.
                //

                _fUnsatisfiableByteRange  = FALSE;
                _fProcessByteRange        = FALSE;
                return;
            }

            cRanges++;

            if ( 1 == cRanges)
            {
                //
                // First valid range. Special processing
                //

                *pdwOffset      = _dwRgNxOffset;
                *pdwSizeToSend  =  _cbMimeMultipart = _dwRgNxSizeToSend;

                if (!fIsLastRange)
                {
                    //
                    // There are more ranges left in the header. However they may or
                    // may not be syntactically valid or satisfiable.
                    //

                    SelectMimeMapping( &_strReturnMimeType,
                                       pstrPath->QueryStr(),
                                       _pMetaData);

                    dwFirstRangeEnd = _iRangeIdx;         // Save this for restoring later.

                    //
                    // For each segment in the MIME multipart message the size of the MIME type
                    // and the number of digits in document total size will be constant,
                    // so compute them now.
                    //

                    dwFx = strlen( _strReturnMimeType.QueryStr() ) + NbDigit( cbSizeLow );

                    dwContentLength =  sizeof(BOUNDARY_STRING) - 1
                                        + _dwRgNxSizeToSend
                                        + sizeof(g_achMMimeTypeFmt) - 1
                                        + sizeof(g_achMMimeRangeFmt) - 1
                                        + NbDigit( _dwRgNxOffset )
                                        + NbDigit( _dwRgNxOffset + _dwRgNxSizeToSend - 1 )
                                        + dwFx;
                }
                else
                {
                    break;
                }
            }
            else
            {
                //
                // We need to send a multipart response.
                //

                dwContentLength +=  sizeof(BOUNDARY_STRING) - 1
                                        + _dwRgNxSizeToSend
                                        + sizeof(g_achMMimeTypeFmt) - 1
                                        + sizeof(g_achMMimeRangeFmt) - 1
                                        + NbDigit( _dwRgNxOffset )
                                        + NbDigit( _dwRgNxOffset + _dwRgNxSizeToSend - 1 )
                                        + dwFx;

            }
        }

        if (cRanges > 1)
        {
            //
            // adjust Content-Length because initial delimiter is part of the header delimiter
            //

            dwContentLength += sizeof(LAST_BOUNDARY_STRING) - ADJ_FIRST - 1;
            _fMimeMultipart = TRUE;
            _cbMimeMultipart = dwContentLength;

            *pfIsNxRange = TRUE;

            //
            // Restore the end of Range for subsequent processing
            //

            _iRangeIdx = dwFirstRangeEnd;

        }
        else
        {
            *pfIsNxRange = FALSE;
        }
    }
}

BOOL
HTTP_REQUEST::ScanRange(
    LPDWORD     pdwOffset,
    LPDWORD     pdwSizeToSend,
    BOOL        *pfEntireFile,
    BOOL        *pfIsLastRange
    )
/*++

  Routine Description:

    Scan the next range in strRange

  Returns:
    TRUE if a range was found, else FALSE

  Arguments:

    pdwOffset       update range offset on return
    pdwSizeToSend   update range size on return
    pfEntireFile    set to TRUE on return if entire file to be send
    pfIsLastRange   set to TRUE on return if this is the last range

  History:
    Phillich    08-Feb-1996 Created

--*/
{
    DWORD      cbSizeLow;
    DWORD      cbSizeHigh;
    DWORD      dwOffset     = 0;
    DWORD      cbSizeToSend = 0;
    BOOL       fEndOfRange  = FALSE;
    BOOL       fInvalidRange;
    BOOL       fEntireFile  = FALSE;
    int        c;

    TCP_REQUIRE( _pGetFile->QuerySize( &cbSizeLow,
                                       &cbSizeHigh ));
    LPSTR pRng = _strRange.QueryStr() + _iRangeIdx;

    //
    // Rules for processing ranges
    //
    // If there is any Syntactically Invalid Byte-Range in the request, then the header
    // must be ignored. Return code is 200 with entire body (i.e. *pfEntireFile = TRUE).
    //
    // If the request is Syntactically Valid & any element is satisfiable, the partial
    // data for the satisfiable portions should be sent with return code HT_PARTIAL_CONTENT.
    //
    // If the request is Syntactically Valid & all elements are unsatisfiable and there
    // is no If-Range header the return error code is HT_RANGE_NOT_SATISFIABLE (416)

    do
    {
        fInvalidRange = FALSE;

        //
        // Skip to begining of next range
        //

        while ( (c=*pRng) && (' '==c) )
        {
            ++pRng;
        }

        //
        // Test for no range
        //

        if ( *pRng == '\0' )
        {
            _iRangeIdx      = (DWORD)(pRng - _strRange.QueryStr());
            *pfEntireFile   = fEntireFile;
            *pfIsLastRange  = TRUE;

            return FALSE;
        }

        // determine Offset & Size to send

        DWORD   dwB, dwE;
        BOOL    fIsB, fIsE;

        dwB = AToDW( &pRng, &fIsB );

        if ( *pRng == '-' )
        {
            ++pRng;

            dwE = AToDW( &pRng, &fIsE );

            if ( *pRng == '-' || (!fIsB && !fIsE) )
            {
                //
                // Syntactically Invalid Range. Skip RANGE Header
                //

                fEntireFile = TRUE;
                break;
            }

            if ( fIsB )
            {
                if ( fIsE )
                {
                    if ( dwB <= dwE )
                    {
                        if ( dwE < cbSizeLow )
                        {
                            dwOffset = dwB;
                            cbSizeToSend = dwE - dwB + 1;
                        }
                        else if (dwE < (cbSizeLow + QueryMetaData()->QueryFooterLength()) )
                        {
                            //
                            // Asking for part of footer, send entire file.
                            //

                            dwOffset = 0;
                            cbSizeToSend = cbSizeLow;
                        }
                        else
                        {
                            if ( dwB < cbSizeLow )
                            {
                                dwOffset = dwB;
                                cbSizeToSend = cbSizeLow - dwB;
                            }
                            else if (dwB < (cbSizeLow + QueryMetaData()->QueryFooterLength()) )
                            {
                                //
                                // Asking for part of footer,send entire file.
                                //

                                dwOffset = 0;
                                cbSizeToSend = cbSizeLow;
                            }
                            else
                            {
                                //
                                // Syntactically Valid but Unsatisfiable range. Zap this range and
                                // skip to the next range.
                                //

                                _fUnsatisfiableByteRange  = TRUE;
                                fInvalidRange             = TRUE;

                                memmove( _strRange.QueryStr()+_iRangeIdx, pRng,
                                 _strRange.QueryCCH() - (size_t)(pRng - _strRange.QueryStr())+1);

                                pRng = _strRange.QueryStr()+_iRangeIdx;
                            }
                        }
                    }
                    else
                    {
                        //
                        // E < B : Syntactically Invalid Range. Skip RANGE Header
                        //

                        fEntireFile = TRUE;
                        break;
                    }
                }
                else
                {
                    //
                    // Starting at B until end.
                    //

                    DWORD dwFooter = QueryMetaData()->QueryFooterLength() ;

                    if ( dwB < cbSizeLow + dwFooter)
                    {
                        if ( 0 != dwFooter)
                        {
                            //
                            // There's a footer on the file, send the whole thing.
                            //

                            dwOffset = 0;
                            cbSizeToSend = cbSizeLow;
                        }
                        else
                        {
                            dwOffset = dwB;
                            cbSizeToSend = cbSizeLow - dwB;
                        }
                    }
                    else
                    {
                        //
                        // Syntactically Valid but Unsatisfiable range. Zap this range and
                        // skip to the next range.
                        //

                        _fUnsatisfiableByteRange  = TRUE;
                        fInvalidRange             = TRUE;

                        memmove( _strRange.QueryStr()+_iRangeIdx, pRng,
                                 _strRange.QueryCCH() - (size_t)(pRng - _strRange.QueryStr())+1);

                        pRng = _strRange.QueryStr()+_iRangeIdx;
                    }
                }
            }
            else
            {
                //
                // E last bytes
                //

                if (    0   != dwE      &&
                        dwE < cbSizeLow &&
                        QueryMetaData()->QueryFooterLength() == 0)
                {
                    dwOffset = cbSizeLow - dwE;
                    cbSizeToSend = dwE;
                }
                else if ( 0 == dwE )
                {
                    //
                    // Syntactically Valid but Unsatisfiable range. Zap this range and
                    // skip to the next range.
                    //

                    _fUnsatisfiableByteRange  = TRUE;
                    fInvalidRange             = TRUE;

                    memmove( _strRange.QueryStr()+_iRangeIdx, pRng,
                             _strRange.QueryCCH() - (size_t)(pRng - _strRange.QueryStr())+1);

                    pRng = _strRange.QueryStr()+_iRangeIdx;
                }
                else
                {
                    //
                    // Return entire file
                    //

                    dwOffset = 0;
                    cbSizeToSend = cbSizeLow;
                }
            }
        }
        else
        {
            //
            // Syntactically Invalid Range. Skip RANGE Header
            //

            fEntireFile = TRUE;
            break;
        }

        //
        // Skip to begining of next range
        //

        while ( (c=*pRng) && c!=',' )
        {
            ++pRng;
        }
        if ( c == ',' )
        {
            ++pRng;
        }
    }
    while ( fInvalidRange );

    _iRangeIdx      = (DWORD)(pRng - _strRange.QueryStr());
    *pfEntireFile   = fEntireFile;
    *pfIsLastRange  = (*pRng == '\0');
    *pdwOffset      = dwOffset;
    *pdwSizeToSend  = cbSizeToSend;

    return TRUE;
}


BOOL
HTTP_REQUEST::SendRange(
    DWORD dwBufLen,
    DWORD dwOffset,
    DWORD dwSizeToSend,
    BOOL  fIsLast
    )
/*++

  Routine Description:

    Send a byte range to the client

  Returns:
    TRUE if TransmitFile OK, FALSE on error

  Arguments:

    dwBufLen        length of the header already created in pbufResponse
    dwOffset        range offset in file
    dwSizeToSend    range size
    fIsLast         TRUE if this is the last range to send

  History:
    Phillich    08-Feb-1996 Created

--*/
{
    CHAR *     pszResp;
    CHAR *     pszTail;
    BUFFER *   pbufResponse = QueryRespBuf();
    DWORD      cbSizeLow;
    DWORD      cbSizeHigh;
    DWORD      dwFlags = IO_FLAG_ASYNC | (fIsLast ? 0 : IO_FLAG_NO_RECV);

    pszTail = pszResp = (CHAR *) pbufResponse->QueryPtr() + dwBufLen;

    if ( _fMimeMultipart )
    {
        pszTail += wsprintf( pszTail,
                             MMIME_TYPE,
                             _strReturnMimeType.QueryStr() );
    }

    if ( fIsLast )
    {
        SetState( HTR_DONE, HT_RANGE, NO_ERROR );

        if (_cbBytesReceived > _cbClientRequest)
        {
            dwFlags |= IO_FLAG_NO_RECV;
        }
    }

    TCP_REQUIRE( _pGetFile->QuerySize( &cbSizeLow,
                                       &cbSizeHigh ));
    pszTail += wsprintf( pszTail,
                         MMIME_RANGE,
                         dwOffset, dwOffset + dwSizeToSend - 1,
                         cbSizeLow
                         );

    if ( fIsLast && (!IsKeepConnSet() &&
                     !_Filter.IsNotificationNeeded( SF_NOTIFY_END_OF_REQUEST,
                                                    IsSecurePort() )))
    {
        dwFlags |= TF_DISCONNECT | TF_REUSE_SOCKET;

    }

    if ( !TransmitFile( _pGetFile,
                        NULL,
                        dwOffset,
                        dwSizeToSend,
                        dwFlags,
                        QueryRespBufPtr(),
                        QueryRespBufCB(),
                        _fMimeMultipart ? (fIsLast ? LAST_BOUNDARY_STRING : BOUNDARY_STRING) : NULL,
                        (DWORD)(_fMimeMultipart ? (fIsLast ? sizeof(LAST_BOUNDARY_STRING)-1 : sizeof(BOUNDARY_STRING)-1 ) : 0 ) ) )
    {
        SetState( HTR_DONE );
        return FALSE;
    }
    
    return TRUE;
}



/*******************************************************************

    NAME:       HTTP_REQ_BASE::BuildResponseHeader

    SYNOPSIS:   Builds a successful response header

    ENTRY:      pstrResponse - Receives reply headers
                pstrPath - Fully qualified path to file, may be NULL
                pFile - File information about pstrPath, may be NULL
                pfHandled - Does processing need to continue?  Will be
                    set to TRUE if no further processing is needed by
                    the caller
                pstrStatus - Alternate status string to use

    RETURNS:    TRUE if successful, FALSE on error

    NOTES:      if pstrPath is NULL, then the base header is put into
                pstrResponse without the header termination or file
                information

    HISTORY:
        Johnl       30-Aug-1994 Created

********************************************************************/

BOOL
HTTP_REQUEST::BuildResponseHeader(
    BUFFER *            pbufResponse,
    STR  *              pstrPath,
    TS_OPEN_FILE_INFO * pFile,
    BOOL *              pfHandled,
    STR  *              pstrStatus,
    LPBOOL              pfFinished
    )
{
    FILETIME   FileTime;
    DWORD      cbSizeLow;
    SYSTEMTIME SysTime;
    SYSTEMTIME SysFileTime;
    LPSYSTEMTIME pMinSysTime;
    CHAR *     pszResp;
    CHAR *     pszTail;
    CHAR       ach[64];
    DWORD      cb;
    DWORD      dwHdrLength;

    if ( pfHandled )
    {
        *pfHandled = FALSE;
    }

    //
    //  HTTP 0.9 clients don't use MIME headers, they just expect the data
    //

    if ( IsPointNine() )
    {
        IF_DEBUG( PARSING )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[BuildResponseHeader] Skipping headers, 0.9 client\n"));
        }

        *((CHAR *)pbufResponse->QueryPtr()) = '\0';
        return TRUE;
    }

    if ( !BuildBaseResponseHeader( pbufResponse,
                                   pfHandled,
                                   pstrStatus,
                                   (HTTPH_SEND_GLOBAL_EXPIRE |
                                    HTTPH_NO_DATE) ))
    {
        return FALSE;
    }

    //
    //  If no file, then don't add the content type headers
    //

    if ( !pstrPath )
    {
        return TRUE;
    }


    //
    //  "Content-Type: xxx/xxx"
    //
    //  We check to make sure the client can accept the type we
    //  want to send
    //

    if ( !::SelectMimeMapping( &_strReturnMimeType,
                                pstrPath->QueryStr(),
                                _pMetaData) )
    {
        return FALSE;
    }

    dwHdrLength = strlen((CHAR *) pbufResponse->QueryPtr());

    if (!pbufResponse->Resize(dwHdrLength + RANGE_ADDL_BUF_HDR_SIZE +
                                _strReturnMimeType.QueryCB()))
    {
        return FALSE;
    }

    pszResp = (CHAR *) pbufResponse->QueryPtr();

     // build Date: uses Date/Time cache
    dwHdrLength += g_pDateTimeCache->GetFormattedCurrentDateTime(
                                    pszResp + dwHdrLength );

    pszTail = pszResp + dwHdrLength;

    if ( !DoesClientAccept( _strReturnMimeType.QueryStr() ) )
    {
        IF_DEBUG( PARSING )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[BuildResponseHeader] Client doesn't accept %s\n",
                       _strReturnMimeType.QueryStr() ));
        }

        SetState( HTR_DONE, HT_NONE_ACCEPTABLE, NO_ERROR );
        Disconnect( HT_NONE_ACCEPTABLE, NO_ERROR, FALSE, pfFinished );

        //
        //  No further processing is needed
        //

        if ( pfHandled )
        {
            *pfHandled = TRUE;
        }

        return TRUE;
    }

    if ( _fMimeMultipart && _fProcessByteRange )
    {
        if ( _VersionMajor > 1 || (_VersionMajor == 1 && _VersionMinor > 0) )
        {
            APPEND_STRING( pszTail, "Content-Type: multipart/byteranges; boundary="
                    BOUNDARY_STRING_DEFINITION "\r\n" );
        }
        else
        {
            APPEND_STRING( pszTail, "Content-Type: multipart/x-byteranges; boundary="
                    BOUNDARY_STRING_DEFINITION "\r\n" );
        }
    }
    else
    {
        if ( _fAcceptRange && !_fProcessByteRange )
        {
            APPEND_STRING( pszTail, "Accept-Ranges: bytes\r\n" );
        }

        APPEND_STR_HEADER( pszTail, "Content-Type: ", _strReturnMimeType, "\r\n" );
    }

    if ( !pFile )
    {
        return TRUE;
    }

    if ( !QueryNoCache() )
    {
        //
        //  "Last-Modified: <GMT time>". Only do this if we're not
        //   satisfying an If-Range: request.
        //

        if (!_fProcessByteRange ||
            (_HeaderList.FastMapQueryValue(HM_IFR) == NULL) )
        {
            if ( !pFile->QueryLastWriteTime( &FileTime )          ||
                 !::FileTimeToSystemTime( &FileTime, &SysFileTime ))
            {
                return FALSE;
            }

            IISGetCurrentTimeAsSystemTime(&SysTime);
            pMinSysTime = MinSystemTime(&SysTime, &SysFileTime);

            if (!::SystemTimeToGMT( *pMinSysTime, ach, sizeof(ach) ))
            {
                return FALSE;
            }

            APPEND_PSZ_HEADER( pszTail, "Last-Modified: ", ach, "\r\n" );

        }

        //
        // ETag: <Etag>
        //

        if (pFile->WeakETag())
        {
            APPEND_PSZ_HEADER(pszTail, "ETag: W/", pFile->QueryETag(), "\r\n");
        } else
        {
            APPEND_PSZ_HEADER(pszTail, "ETag: ", pFile->QueryETag(), "\r\n");
        }

    }

    //
    //  "Content-Length: nnnn" and end of headers
    //


    if ( _fMimeMultipart )
    {
        if ( _cbMimeMultipart )
        {
            APPEND_NUMERIC_HEADER( pszTail,
                                   "Content-Length: ",
                                   _cbMimeMultipart,
                                   "\r\n" );
        }


        //
        // first boundary string
        //

        APPEND_STRING( pszTail, DELIMIT_FIRST BOUNDARY_STRING );
    }
    else
    {
        if ( _fProcessByteRange )
        {
            cbSizeLow = _cbMimeMultipart;
        }
        else
        {
            TCP_REQUIRE( pFile->QuerySize( &cbSizeLow ));
            cbSizeLow += QueryMetaData()->QueryFooterLength();
        }

        APPEND_NUMERIC_HEADER_TAILVAR( pszTail,
                               "Content-Length: ",
                               cbSizeLow,
                               (_fProcessByteRange ? "\r\n" : "\r\n\r\n") );
    }

    IF_DEBUG( REQUEST )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "BuildResponseHeader: Built the following header:\n%s",
                   pszResp ));
    }

    return TRUE;
}


BOOL
HTTP_REQUEST::BuildFileResponseHeader(
    BUFFER *            pbufResponse,
    STR  *              pstrPath,
    TS_OPEN_FILE_INFO * pFile,
    BOOL *              pfHandled,
    LPBOOL              pfFinished
    )
/*++

  Routine Description:

    Builds a successful response header for a file request
    without byte ranges.

  Returns:
    TRUE if successful, FALSE on error

  Arguments:

    pstrResponse - Receives reply headers
    pstrPath - Fully qualified path to file, may be NULL
    pFile - File information about pstrPath, may be NULL
    pfHandled - Does processing need to continue?  Will be
      set to TRUE if no further processing is needed by
      the caller

  History:
    Phillich    26-Feb-1996 Created

--*/
{
    FILETIME   FileTime;
    DWORD      cbSizeLow;
    SYSTEMTIME SysTime;
    SYSTEMTIME SysFileTime;
    LPSYSTEMTIME pMinSysTime;
    CHAR *     pszResp;
    CHAR *     pszTail;
    CHAR *     pszVariant;
    CHAR       ach[64];
    int        cMod;
    DWORD      dwCurrentHeaderLength;

    if ( pfHandled )
    {
        *pfHandled = FALSE;
    }

    //
    //  HTTP 0.9 clients don't use MIME headers, they just expect the data
    //

    if ( IsPointNine() )
    {
        IF_DEBUG( PARSING )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[BuildResponseHeader] Skipping headers, 0.9 client\n"));
        }

        *((CHAR *)pbufResponse->QueryPtr()) = '\0';
        return TRUE;
    }


    if ( !BuildBaseResponseHeader( pbufResponse,
                                   pfHandled,
                                   NULL,
                                   HTTPH_SEND_GLOBAL_EXPIRE
                                        |HTTPH_NO_DATE ))
    {
        return FALSE;
    }

    //
    // Make sure that we have enough room left in the buffer. Note
    // that right here we only account for enough space for the Date:
    // header and the max. amount of cached info. If there is more
    // uncached info that may be inserted here, make sure to change the
    // MIN_ADDL_BUF_HDR_SIZE_CACHED define above.
    //

    dwCurrentHeaderLength = strlen((CHAR *) pbufResponse->QueryPtr());

    if (!pbufResponse->Resize(dwCurrentHeaderLength +
                                MIN_ADDL_BUF_HDR_SIZE_CACHED) )
    {
        return FALSE;
    }

    pszResp = (CHAR *) pbufResponse->QueryPtr();

     // build Date: uses Date/Time cache
    dwCurrentHeaderLength += g_pDateTimeCache->GetFormattedCurrentDateTime(
                                    pszResp + dwCurrentHeaderLength );

    pszTail = pszResp + dwCurrentHeaderLength;

    if ( !QueryNoCache() && pFile->RetrieveHttpInfo( pszTail, &cMod ) )
    {
        // 1st line is Content-Type:, check client accepts it

        PSTR pDelim = strchr( pszTail, '\r' );

        if ( pDelim )
        {
            *pDelim = '\0';
        }

        if ( !DoesClientAccept( pszTail + sizeof( "Content-Type: " ) - sizeof(CHAR) ) )
        {
            goto no_match_type;
        }

        if ( pDelim )
        {
            *pDelim = '\r';
        }

        return TRUE;
    }

    //
    //  "Content-Type: xxx/xxx"
    //
    //  We check to make sure the client can accept the type we
    //  want to send
    //

    if ( !::SelectMimeMapping( &_strReturnMimeType,
                                pstrPath->QueryStr(),
                                _pMetaData) )
    {
        return FALSE;
    }

    if (!pbufResponse->Resize(dwCurrentHeaderLength +
                                _strReturnMimeType.QueryCB() +
                                MIN_ADDL_BUF_HDR_SIZE))
    {
        return FALSE;
    }

    pszResp = (CHAR *) pbufResponse->QueryPtr();
    pszTail = pszResp + dwCurrentHeaderLength;

    pszVariant = pszTail;


    if ( !DoesClientAccept( _strReturnMimeType.QueryStr() ) )
    {
no_match_type:
        IF_DEBUG( PARSING )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[BuildResponseHeader] Client doesn't accept %s\n",
                       _strReturnMimeType.QueryStr() ));
        }

        SetState( HTR_DONE, HT_NONE_ACCEPTABLE, NO_ERROR );
        Disconnect( HT_NONE_ACCEPTABLE, NO_ERROR, FALSE, pfFinished );

        //
        //  No further processing is needed
        //

        if ( pfHandled )
        {
            *pfHandled = TRUE;
        }

        return TRUE;
    }


    //
    // Content-Type: MUST be the 1st header, or we get messed up when
    // we use the cached headers and try to pass the mime type to
    // DoesClientAccept().
    //

    APPEND_STR_HEADER( pszTail, "Content-Type: ", _strReturnMimeType, "\r\n" );

    if ( _fAcceptRange )
    {
        APPEND_STRING( pszTail, "Accept-Ranges: bytes\r\n" );
    }

    if ( !QueryNoCache() )
    {
        //
        //  "Last-Modified: <GMT time>"
        //

        if ( !pFile->QueryLastWriteTime( &FileTime )          ||
             !::FileTimeToSystemTime( &FileTime, &SysFileTime ))
        {
            return FALSE;
        }

        IISGetCurrentTimeAsSystemTime(&SysTime);
        pMinSysTime = MinSystemTime(&SysTime, &SysFileTime);

        if (!::SystemTimeToGMT( *pMinSysTime, ach, sizeof(ach) ))
        {
            return FALSE;
        }

        APPEND_PSZ_HEADER( pszTail, "Last-Modified: ", ach, "\r\n" );

        //
        // ETag: <Etag>
        //

        if (pFile->WeakETag())
        {
            APPEND_PSZ_HEADER(pszTail, "ETag: W/", pFile->QueryETag(), "\r\n");
        } else
        {
            APPEND_PSZ_HEADER(pszTail, "ETag: ", pFile->QueryETag(), "\r\n");
        }

    }

    //
    //  "Content-Length: nnnn" and end of headers
    //


    TCP_REQUIRE( pFile->QuerySize( &cbSizeLow ));
    cbSizeLow += QueryMetaData()->QueryFooterLength();

    APPEND_NUMERIC_HEADER( pszTail,
                           "Content-Length: ",
                           cbSizeLow,
                           "\r\n\r\n" );

    if ( !QueryNoCache() )
    {
        pFile->SetHttpInfo( pszVariant, DIFF(pszTail - pszVariant) );
    }

    IF_DEBUG( REQUEST )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "BuildResponseHeader: Built the following header:\n%s",
                   pszResp ));
    }

    return TRUE;
}


/*******************************************************************

    NAME:       HTTP_REQUEST::ProcessISMAP

    SYNOPSIS:   Checks of the URL and passed parameters specify an
                image mapping file

    RETURNS:    TRUE if successful, FALSE on error

    NOTES:      gFile - Opened file Info
                pchFile - Fully qualified name of file
                pstrResp - Response to send if *pfHandled is FALSE
                pfFound - TRUE if a mapping was found
                pfHandled - Set to TRUE if no further processing is needed,
                    FALSE if pstrResp should be sent to the client

    HISTORY:
        Johnl       17-Sep-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::ProcessISMAP( LPTS_OPEN_FILE_INFO gFile,
                                 CHAR *   pchFile,
                                 BUFFER * pbufResp,
                                 BOOL *   pfFound,
                                 BOOL *   pfHandled )
{
    INT                 x, y;
    TCHAR *             pch = _strURLParams.QueryStr();
    PW3_SERVER_INSTANCE pInstance = QueryW3Instance();
    STACK_STR( strURL, MAX_PATH);

    *pfHandled = FALSE;
    *pfFound   = FALSE;

    //
    //  Get the x and y cooridinates of the mouse click on the image
    //

    x = _tcstoul( pch,
                  NULL,
                  10 );

    //
    //  Move past x and any intervening delimiters
    //

    while ( isdigit( (UCHAR)(*pch) ))
        pch++;

    while ( *pch && !isdigit( (UCHAR)(*pch) ))
        pch++;

    y = _tcstoul( pch,
                  NULL,
                  10 );

    if ( !ImpersonateUser() )
    {
        return FALSE;
    }

    if ( !SearchMapFile( gFile,
                         pchFile,
                         &pInstance->GetTsvcCache(),
                         QueryImpersonationHandle(),
                         x,
                         y,
                         &strURL,
                         pfFound,
                         IsAnonymous()||IsClearTextPassword() ))
    {
        RevertUser();
        return FALSE;
    }

    RevertUser();

    if ( !*pfFound )
    {
        if ( (pch = (TCHAR * ) _HeaderList.FastMapQueryValue( HM_REF )) )
        {
#if 0
            // handle relative URL ( i.e. not fully qualified
            // and not specifying an absolute path ).
            // disabled for now.
            PSTR pColon = strchr( pch, ':' );
            PSTR pDelim = strchr( pch, '/' );
            BOOL fValid;

            // check for relative URL

            if ( *pch != '/' && (pColon == NULL || pDelim < pColon) )
            {
                strURL.Copy( _strURL.QueryStr() );
                PSTR pL = strURL.QueryStr();

                // look for last '/'
                int iL = strlen( pL );
                while ( iL && pL[iL-1] != '/' )
                    --iL;

                // combine request URL & relative referer URL
                strURL.Resize( iL + strlen( pch ) + 1 );
                strcpy( strURL.QueryStr() + iL, pch );
                fValid = TRUE;
                CanonURL( strURL.QueryStr());
                CanonURL.SetLen( strlen( strURL.QueryStr() ));
            }
            else
#endif
                strURL.Copy( (TCHAR *) pch );
        }
        else
            return TRUE;
    }

    CloseGetFile();
    
    //
    //  If the found URL starts with a forward slash ("/foo/bar/doc.htm")
    //  and it doesn't contain a bookmark ('#')
    //  then the URL is local and we build a fully qualified URL to send
    //  back to the client.
    //  we assume it's a fully qualified URL ("http://foo/bar/doc.htm")
    //  and send the client a redirection notice to the mapped URL
    //

    if ( *strURL.QueryStr() == TEXT('/') )
    {
#if 0
        // disabled :
        // we now always send a redirect

        TCHAR * pch = strURL.QueryStr();

        //
        //  Make sure there's no bookmark
        //
        if ( !(strchr( strURL.QueryStr(), '#' )) )
        {
            //
            //  Call OnURL to reparse the URL and set the members then
            //  call the verb again
            //

            if ( !ReprocessURL( pch ) )
            {
                return FALSE;
            }

            *pfHandled = TRUE;
        }
        else
#endif
        {
            CHAR achPort[32];
            STACK_STR( strOldURL, MAX_PATH );

            //
            //  fully qualify the URL and send a
            //  redirect.  Some browsers (emosaic) don't like doc relative
            //  URLs with bookmarks
            //

            if ( !strOldURL.Copy( strURL ) ||
                 !strURL.Resize( strOldURL.QueryCB() + 128 ))
            {
                return FALSE;
            }

            //
            //  NOTE: We fully qualify the URL with the protocol (http or
            //  https) based on the port this request came in on.  This means
            //  you cannot have a partial URL with a bookmark (which is how
            //  we got here) go from a secure part of the server to a
            //  nonsecure part of the server.
            //

            strURL.Copy( (IsSecurePort() ? "https://" : "http://" ));
            strURL.Append( QueryHostAddr() );

            if ( IsSecurePort() ? (INT) QueryClientConn()->QueryPort()
                    != HTTP_SSL_PORT
                    : (INT) QueryClientConn()->QueryPort() != 80 )
            {
                strURL.Append( ":" );
                _itoa( (INT) QueryClientConn()->QueryPort(), achPort, 10 );
                strURL.Append( achPort );
            }

            strURL.Append( strOldURL );

            if ( !BuildURLMovedResponse( pbufResp, &strURL, HT_REDIRECT, FALSE ))
                return FALSE;
        }
    }
    else
    {
        if ( !BuildURLMovedResponse( pbufResp, &strURL, HT_REDIRECT, FALSE ))
            return FALSE;
    }

    *pfFound = TRUE;
    return TRUE;
}

/*******************************************************************

    NAME:       EncodeStringToHTML

    SYNOPSIS:   Enode string in HTML format

    ENTRY:      szSrc - Source string to be encoded, in system codepage
                szDest - Space to output HTML (in system codepage)
                cbDest - Size of space in szDest (number of bytes)

    RETURNS:    number of bytes required for HTML text

    NOTES:      If cbDest is less than target HTML, then we fit
                as much characters as possible into szDest. But the
                return value remains the same and is greater than
                cbDest. szDest is not zero terminated in this case.

    HISTORY:
        markzh       17-Jan-2002 Created

********************************************************************/
UINT EncodeStringToHTML(CHAR *szSrc, CHAR *szDest, UINT cbDest)
{
    CHAR *pSrc = szSrc;
    CHAR *pDest = szDest;
    BOOL isSecondByte=FALSE;
    
    do {
        CHAR *szAppend = pSrc;
        UINT cbAppend = 1;

        // We may be running on DBCS. Ideally we should encode them to &#nnnnn
        // but we dont want that many code here

        if (isSecondByte)
        {
            isSecondByte = FALSE;
        }
        else if (IsDBCSLeadByte(*pSrc))
        {
            isSecondByte = TRUE;
        }
        else switch (*pSrc)
        {
        #define SetAppend(s)  (szAppend=(s), cbAppend=sizeof(s)-1)
            case '&': SetAppend("&amp;");
                break;
            case '"': SetAppend("&quot;");
                break;
            case '<': SetAppend("&lt;");
                break;
            case '>': SetAppend("&gt;");
                break;
            default:
                break;
        #undef SetAppend
        }

        if (pDest - szDest + cbAppend <= cbDest)
        {
            memcpy(pDest, szAppend, cbAppend);
        }

        pDest += cbAppend;

    }while (*pSrc++);

    return DIFF(pDest - szDest);
}


/*******************************************************************

    NAME:       HTTP_REQ_BASE::BuildURLMovedResponse

    SYNOPSIS:   Builds a full request indicating an object has moved to
                the location specified by URL

    ENTRY:      pbufResp - String to receive built response
                pstrURL   - New location of object, gets escaped
                dwServerCode - Server response code
                               (either HT_REDIRECT or HT_MOVED)
                fIncludeParams - TRUE to include params from original request
                                 in redirect

    RETURNS:    TRUE if successful, FALSE on error

    NOTES:      This routine doesn't support sending a Unicode doc moved
                message

    HISTORY:
        Johnl       17-Sep-1994 Created

********************************************************************/

BOOL HTTP_REQ_BASE::BuildURLMovedResponse( BUFFER *    pbufResp,
                                           STR *       pstrURL,
                                           DWORD       dwServerCode,
                                           BOOL        fIncludeParams )
{
    STACK_STR(strMovedMessage, 512);
    STR*    pstrMovedMessage;
    STACK_STR(strUrlWithParams, 512);
    UINT    cb;
    UINT    cbA;
    CHAR *  pszTail;
    CHAR *  pszResp;
    DWORD   cbURL;
    BOOL    fDone;
    BOOL    bHaveCustom;
    DWORD   dwMsgSize;
    DWORD   dwRedirHeaderSize;

    DBG_ASSERT(dwServerCode == HT_REDIRECT || dwServerCode == HT_MOVED);

    if (CheckCustomError(&strMovedMessage, HT_REDIRECT, 0, &fDone, &dwMsgSize, FALSE))
    {
        DBG_ASSERT(!fDone);
        strMovedMessage.SetLen(strlen((CHAR *)strMovedMessage.QueryPtr()));
        bHaveCustom = TRUE;
        pstrMovedMessage = &strMovedMessage;
    }
    else
    {
        pstrMovedMessage = g_pstrMovedMessage;

        DBG_ASSERT( pstrMovedMessage->QueryCB() );

        bHaveCustom = FALSE;
    }

    //
    //  Make sure the response buffer is large enough
    //

#define CB_FIXED_RESP           500

    //
    //  Technically we should escape more characters then just the spaces but
    //  that would probably break some number of client apps
    //

    if ( !pstrURL->EscapeSpaces() )
    {
        return FALSE;
    }

    if ( fIncludeParams &&
         !_strURLParams.IsEmpty() )
    {
        if ( !strUrlWithParams.Copy( *pstrURL ) ||
             !strUrlWithParams.Append( "?" ) ||
             !strUrlWithParams.Append( _strURLParams ) )
        {
            return FALSE;
        }

        pstrURL = &strUrlWithParams;
    }

    cbURL = pstrURL->QueryCB();

    // WinSE 24915
    // Enode string in HTML format
    
    STACK_STR(strUrlInHTML, 512);
    UINT     cbUrlInHTML;
    
    cbUrlInHTML = EncodeStringToHTML(pstrURL->QueryStr(),
                        strUrlInHTML.QueryStr(),
                        strUrlInHTML.QuerySize());
    
    if ( cbUrlInHTML > strUrlInHTML.QuerySize() )
    {
        if (! strUrlInHTML.Resize(cbUrlInHTML))
        {
            return FALSE;
        }

        cbUrlInHTML = EncodeStringToHTML(pstrURL->QueryStr(),
                        strUrlInHTML.QueryStr(),
                        strUrlInHTML.QuerySize());
    }

    if ( (cbUrlInHTML + cbURL + CB_FIXED_RESP) > pbufResp->QuerySize() )
    {
        if ( !pbufResp->Resize( cbUrlInHTML + cbURL + CB_FIXED_RESP ))
            return FALSE;
    }

    //
    //  "HTTP/<ver> 302 Redirect" or
    //  "HTTP/<ver> 301 Redirect"
    //

    if ( !BuildStatusLine( pbufResp,
                           dwServerCode,
                           NO_ERROR ))
    {
        return FALSE;
    }

    //
    //  Set the status to log here
    //

    SetLogStatus( dwServerCode, NO_ERROR );

    pszResp = (CHAR *) pbufResp->QueryPtr();
    pszTail = pszResp + strlen( pszResp );

    //
    //  "Location: <URL>"
    //

    APPEND_STR_HEADER( pszTail, "Location: ", *pstrURL, "\r\n" );

    //
    //  "Server: <Server>/<version>
    //

    APPEND_VER_STR( pszTail );

    //
    //  Content-Type,  it's OK to assume all clients accept text/html
    //

    if (!bHaveCustom)
    {
        APPEND_STRING( pszTail, "Content-Type: text/html\r\n" );
    }

    //
    //  Calculate the bytes in the body of the message for Content-Length
    //
    //  cbUrlInHTML is total bytes in the string (-1 for the null)
    //
    //  pstrMovedMessage->QueryCB does not include the null, but
    //  it may be a format string that will contain the url, so -2 for %s
    //
    //  Wait to subtract the %s away, though since pstrMovedMessage
    //  my be custom error file data - This code is so @#$#%@%$.
    //  Of course none of these calculations are right if %s is actually
    //  in the custom error file, and if it isn't then the error is
    //  useless. Whoever wrote this deserves a beating.
    //

    cb = ( cbUrlInHTML - 1 ) +
         ( pstrMovedMessage->QueryCB() );


    if (!bHaveCustom)
    {
        //
        // Now compensate for %s. It is okay that cb is a little too
        // big in this case dwMsgSize will be what determines the value
        // of the content length header.
        //
        dwMsgSize = cb - 2;
    }

    if ( IsKeepConnSet() )
    {
        if (!IsOneOne())
        {
            APPEND_STRING( pszTail, "Connection: keep-alive\r\n" );
        }
    } else
    {
        if (IsOneOne())
        {
            APPEND_STRING( pszTail, "Connection: close\r\n" );
        }
    }

    //
    // If we have any redirection specific headers, copy them in now.
    //

    dwRedirHeaderSize = QueryMetaData()->QueryRedirectHeaders()->QueryCCH();

    if (dwRedirHeaderSize != 0)
    {
        if (!pbufResp->Resize(DIFF(pszTail - pszResp) + dwRedirHeaderSize ))
        {
            return FALSE;
        }
        pszTail = (CHAR *) pbufResp->QueryPtr() + (pszTail - pszResp);
        pszResp = (CHAR *) pbufResp->QueryPtr();

        memcpy(pszTail, QueryMetaData()->QueryRedirectHeaders()->QueryStr(),
                dwRedirHeaderSize);

        pszTail += dwRedirHeaderSize;
    }

    //
    //  Append any headers specified by filters
    //

    if ( cbA = QueryAdditionalRespHeaders()->QueryCB() )
    {
        if (!pbufResp->Resize(DIFF(pszTail - pszResp) + cbA ))
        {
            return FALSE;
        }
        pszTail = (CHAR *) pbufResp->QueryPtr() + (pszTail - pszResp);
        pszResp = (CHAR *) pbufResp->QueryPtr();

        memcpy( pszTail, QueryAdditionalRespHeaders()->QueryStr(), cbA );

        pszTail += cbA;
    }

    //
    //  Figure out the total length to see if we have enough room for the "Content-Length"
    //  header
    //
    cb += DIFF(pszTail - pszResp) +
        sizeof("Content-Length: ") - 1 +
        30 + // [magic #] max length of string containing numeric value of Content-Length
        ( bHaveCustom ? sizeof("\r\n") - 1 : sizeof("\r\n\r\n") - 1 ) +
        sizeof(TCHAR);

    if ( !pbufResp->Resize( cb ))
    {
        return FALSE;
    }

    if ( pbufResp->QueryPtr() != pszResp )
    {
        pszTail = (CHAR *) pbufResp->QueryPtr() + (pszTail - pszResp);
        pszResp = (CHAR *) pbufResp->QueryPtr();
    }

    //
    //  "Content-Length: <length>"
    //

    APPEND_NUMERIC_HEADER_TAILVAR( pszTail, "Content-Length: ", dwMsgSize, bHaveCustom ? "\r\n" : "\r\n\r\n" );

    //
    // pstrMovedMessage is something along the lines of "This object can be found at %s" and
    // pstrURL is the URL that replaces the %s in pstrMovedMessage, so the max length of the
    // actual HTML doc is the sum of the lengths of pstrMovedMessage and pstrURL
    //

    if (HTV_HEAD != QueryVerb())
    {
        DWORD cbMaxMsg = pstrMovedMessage->QueryCB() + strUrlInHTML.QueryCB();

        if ( !pbufResp->Resize( DIFF(pszTail - pszResp) + cbMaxMsg ) )
        {
            return FALSE;
        }

        //
        // Watch for pointer shift
        //
        if ( pbufResp->QueryPtr() != pszResp )
        {
            pszTail = (CHAR*) pbufResp->QueryPtr() + (pszTail - pszResp);
            pszResp = (CHAR *) pbufResp->QueryPtr();
        }

        //
        // Add the short HTML doc indicating the new location of the URL,
        // making sure we have enough space for it
        // Note we've already added the message body length.  Add in the terminator.
        //

    
        ::sprintf( pszTail,
                   pstrMovedMessage->QueryStr(),
                   strUrlInHTML.QueryStr() );

    }
    
    return TRUE;
}

/*******************************************************************

    NAME:       SearchMapFile

    SYNOPSIS:   Searches the given mapfile for a shape that contains
                the passed cooridinates

    ENTRY:      gFile - Open file Info
                pchFile - Fully qualified path to file
                pTsvcCache - Cache ID
                hToken - Impersonation token
                x        - x cooridinate
                y        - y cooridinate
                pstrURL  - receives URL indicated in the map file
                pfFound  - Set to TRUE if a mapping was found
                fMayCacheAccessToken  - TRUE access token may be cached

    RETURNS:    TRUE if successful, FALSE on error

    NOTES:      This routine will attempt to cache the file.  You must call
                this function while impersonating the appropriate user

    HISTORY:
        Johnl       19-Sep-1994 Created

********************************************************************/

#define SKIPNONWHITE( pch ) while ( *pch &&             \
                                    !ISWHITEA( *pch ))  \
                                        pch++;

#define SKIPWHITE( pch ) while ( ISWHITE( *pch ) ||     \
                                 *pch == ')'     ||     \
                                 *pch == '(' )          \
                                     pch++;

BOOL SearchMapFile( LPTS_OPEN_FILE_INFO gFile,
                    CHAR *              pchFile,
                    TSVC_CACHE *        pTsvcCache,
                    HANDLE              hToken,
                    INT                 x,
                    INT                 y,
                    STR *               pstrURL,
                    BOOL *              pfFound,
                    BOOL                fMayCacheAccessToken )
{
    DWORD                       BytesRead;
    CHAR *                      pch;
    CACHE_FILE_INFO             CacheFileInfo;
    CHAR *                      pchDefault = NULL;
    CHAR *                      pchPoint = NULL;
    CHAR *                      pchStart;
    BOOL                        fRet = TRUE;
    DWORD                       cchUrl;
    UINT                        dis;
    UINT                        bdis = UINT(-1);
    STACK_STR( strDefaultURL, MAX_PATH );

    *pfFound = FALSE;

    //
    //  Retrieve the '\0' terminated map file
    //

    if ( !CheckOutCachedFileFromURI( (PVOID)gFile,
                                     pchFile,
                                     pTsvcCache,
                                     hToken,
                                     (BYTE **) &pch,
                                     &BytesRead,
                                     fMayCacheAccessToken,
                                     &CacheFileInfo,
                                     0 ))   // no code conversion
    {
        if ( !CheckOutCachedFile( pchFile,
                                  pTsvcCache,
                                  hToken,
                                  (BYTE **) &pch,
                                  &BytesRead,
                                  fMayCacheAccessToken,
                                  &CacheFileInfo,
                                  0 ))   // no code conversion
        {
            return FALSE;
        }
    }

    //
    //  Loop through the contents of the buffer and see what we've got
    //

    BOOL fComment = FALSE;
    BOOL fIsNCSA = FALSE;
    LPSTR pURL;     // valid only if fIsNCSA is TRUE

    while ( *pch )
    {
        fIsNCSA = FALSE;

        //
        //  note: _tolower doesn't check case (tolower does)
        //

        switch ( (*pch >= 'A' && *pch <= 'Z') ? _tolower( *pch ) : *pch )
        {
        case '#':
            fComment = TRUE;
            break;

        case '\r':
        case '\n':
            fComment = FALSE;
            break;

        //
        //  Rectangle
        //

        case 'r':
        case 'o':
            if ( !fComment &&
                 (!_strnicmp( "rect", pch, 4 )
                 // handles oval as a rect, as they are using
                 // the same specification format. Should do better.
                 || !_strnicmp( "oval", pch, 4 )) )
            {
                INT x1, y1, x2, y2;

                SKIPNONWHITE( pch );
                pURL = pch;
                SKIPWHITE( pch );

                if ( !isdigit((UCHAR)(*pch)) && *pch!='(' )
                {
                    fIsNCSA = TRUE;
                    SKIPNONWHITE( pch );
                }

                x1 = GetNumber( &pch );
                y1 = GetNumber( &pch );
                x2 = GetNumber( &pch );
                y2 = GetNumber( &pch );

                if ( x >= x1 && x < x2 &&
                     y >= y1 && y < y2   )
                {
                    if ( fIsNCSA )
                        pch = pURL;
                    goto Found;
                }

                //
                //  Skip the URL
                //

                if ( !fIsNCSA )
                {
                    SKIPWHITE( pch );
                    SKIPNONWHITE( pch );
                }
                continue;
            }
            break;

        //
        //  Circle
        //

        case 'c':
            if ( !fComment &&
                 !_strnicmp( "circ", pch, 4 ))
            {
                INT xCenter, yCenter, xEdge, yEdge;
                INT r1, r2;

                SKIPNONWHITE( pch );
                pURL = pch;
                SKIPWHITE( pch );

                if ( !isdigit((UCHAR)(*pch)) && *pch!='(' )
                {
                    fIsNCSA = TRUE;
                    SKIPNONWHITE( pch );
                }

                //
                //  Get the center and edge of the circle
                //

                xCenter = GetNumber( &pch );
                yCenter = GetNumber( &pch );

                xEdge = GetNumber( &pch );
                yEdge = GetNumber( &pch );

                //
                //  If there's a yEdge, then we have the NCSA format, otherwise
                //  we have the CERN format, which specifies a radius
                //

                if ( yEdge != -1 )
                {
                    r1 = ((yCenter - yEdge) * (yCenter - yEdge)) +
                         ((xCenter - xEdge) * (xCenter - xEdge));

                    r2 = ((yCenter - y) * (yCenter - y)) +
                         ((xCenter - x) * (xCenter - x));

                    if ( r2 <= r1 )
                    {
                        if ( fIsNCSA )
                            pch = pURL;
                        goto Found;
                    }
                }
                else
                {
                    INT radius;

                    //
                    //  CERN format, third param is the radius
                    //

                    radius = xEdge;

                    if ( SQR( xCenter - x ) + SQR( yCenter - y ) <=
                         SQR( radius ))
                    {
                        if ( fIsNCSA )
                            pch = pURL;
                        goto Found;
                    }
                }

                //
                //  Skip the URL
                //

                if ( !fIsNCSA )
                {
                    SKIPWHITE( pch );
                    SKIPNONWHITE( pch );
                }
                continue;
            }
            break;

        //
        //  Polygon
        //

        case 'p':
            if ( !fComment &&
                 !_strnicmp( "poly", pch, 4 ))
            {
                double pgon[MAXVERTS][2];
                DWORD  i = 0;
                CHAR * pchLast;
                BOOL fOverflow = FALSE;

                SKIPNONWHITE( pch );
                pURL = pch;
                SKIPWHITE( pch );

                if ( !isdigit((UCHAR)(*pch)) && *pch!='(' )
                {
                    fIsNCSA = TRUE;
                    SKIPNONWHITE( pch );
                }

                //
                //  Build the array of points
                //

                while ( *pch && *pch != '\r' && *pch != '\n' )
                {
                    pgon[i][0] = GetNumber( &pch );

                    //
                    //  Did we hit the end of the line (and go past the URL)?
                    //

                    if ( pgon[i][0] != -1 )
                    {
                        pgon[i][1] = GetNumber( &pch );
                    }
                    else
                    {
                        break;
                    }

                    if ( i < MAXVERTS-1 )
                    {
                        i++;
                    }
                    else
                    {
                        fOverflow = TRUE;
                    }
                }

                pgon[i][X] = -1;

                if ( !fOverflow && pointinpoly( x, y, pgon ))
                {
                    if ( fIsNCSA )
                        pch = pURL;
                    goto Found;
                }

                //
                //  Skip the URL
                //

                if ( !fIsNCSA )
                {
                    SKIPWHITE( pch );
                    SKIPNONWHITE( pch );
                }
                continue;
            }
            else if ( !fComment &&
                 !_strnicmp( "point", pch, 5 ))
            {
                INT x1,y1;

                SKIPNONWHITE( pch );
                pURL = pch;
                SKIPWHITE( pch );
                SKIPNONWHITE( pch );

                x1 = GetNumber( &pch );
                y1 = GetNumber( &pch );

                x1 -= x;
                y1 -= y;
                dis = x1*x1 + y1*y1;
                if ( dis < bdis )
                {
                    pchPoint = pURL;
                    bdis = dis;
                }
            }
            break;

        //
        //  Default URL
        //

        case 'd':
            if ( !fComment &&
                 !_strnicmp( "def", pch, 3 ) )
            {
                //
                //  Skip "default" (don't skip white space)
                //

                SKIPNONWHITE( pch );

                pchDefault = pch;

                //
                //  Skip URL
                //

                SKIPWHITE( pch );
                SKIPNONWHITE( pch );
                continue;
            }
            break;
        }

        pch++;
        SKIPWHITE( pch );
    }

    //
    //  If we didn't find a mapping and a default was specified, use
    //  the default URL
    //

    if ( pchPoint )
    {
        pch = pchPoint;
        goto Found;
    }

    if ( pchDefault )
    {
        pch = pchDefault;
        goto Found;
    }

    IF_DEBUG( PARSING )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[SearchMapFile] No mapping found for (%d,%d)\n",
                    x,
                    y ));
    }

    goto Exit;

Found:

    //
    //  pch should point to the white space immediately before the URL
    //

    SKIPWHITE( pch );

    pchStart = pch;

    SKIPNONWHITE( pch );

    //
    //  Determine the length of the URL and copy it out
    //

    cchUrl = DIFF(pch - pchStart);

    if ( !pstrURL->Resize( cchUrl + 1 ))
    {
        fRet = FALSE;

        goto Exit;
    }

    memcpy( pstrURL->QueryStr(),
            pchStart,
            cchUrl );

    pstrURL->SetLen(cchUrl);

    if ( !pstrURL->Unescape() )
    {
        fRet = FALSE;
        goto Exit;
    }

    IF_DEBUG( PARSING )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[SearchMapFile] Mapping for (%d,%d) is %s\n",
                   x,
                   y,
                   pstrURL->QueryStr() ));
    }

    *pfFound = TRUE;

Exit:
    TCP_REQUIRE( CheckInCachedFile( pTsvcCache,
                                    &CacheFileInfo ));


    return fRet;
}


int pointinpoly(int point_x, int point_y, double pgon[MAXVERTS][2])
{
    int i, numverts, inside_flag, xflag0;
    int crossings;
    double *p, *stop;
    double tx, ty, y;

    for (i = 0; pgon[i][X] != -1 && i < MAXVERTS; i++)
        ;

    numverts = i;
    crossings = 0;

    tx = (double) point_x;
    ty = (double) point_y;
    y = pgon[numverts - 1][Y];

    p = (double *) pgon + 1;

    if ((y >= ty) != (*p >= ty))
    {
        if ((xflag0 = (pgon[numverts - 1][X] >= tx)) == (*(double *) pgon >= tx))
        {
            if (xflag0)
                crossings++;
        }
        else
        {
            crossings += (pgon[numverts - 1][X] - (y - ty) *
            (*(double *) pgon - pgon[numverts - 1][X]) /
            (*p - y)) >= tx;
        }
    }

    stop = pgon[numverts];

    for (y = *p, p += 2; p < stop; y = *p, p += 2)
    {
        if (y >= ty)
        {
            while ((p < stop) && (*p >= ty))
                p += 2;

            if (p >= stop)
                break;

            if ((xflag0 = (*(p - 3) >= tx)) == (*(p - 1) >= tx))
            {
                if (xflag0)
                    crossings++;
            }
            else
            {
                crossings += (*(p - 3) - (*(p - 2) - ty) *
                    (*(p - 1) - *(p - 3)) / (*p - *(p - 2))) >= tx;
            }
        }
        else
        {
            while ((p < stop) && (*p < ty))
                p += 2;

            if (p >= stop)
                break;

            if ((xflag0 = (*(p - 3) >= tx)) == (*(p - 1) >= tx))
            {
                if (xflag0)
                    crossings++;

            }
            else
            {
                crossings += (*(p - 3) - (*(p - 2) - ty) *
                    (*(p - 1) - *(p - 3)) / (*p - *(p - 2))) >= tx;
            }
        }
    }

    inside_flag = crossings & 0x01;
    return (inside_flag);
}

/*******************************************************************

    NAME:       GetNumber

    SYNOPSIS:   Scans for the beginning of a number and places the
                pointer after the found number


    ENTRY:      ppch - Place to begin.  Will be set to character after
                    the last digit of the found number

    RETURNS:    Integer value of found number (or -1 if not found)

    HISTORY:
        Johnl       19-Sep-1994 Created

********************************************************************/

INT GetNumber( CHAR * * ppch )
{
    CHAR * pch = *ppch;
    INT    n;

    //
    //  Make sure we don't get into the URL
    //

    while ( *pch &&
            !isdigit( (UCHAR)(*pch) ) &&
            !isalpha( (UCHAR)(*pch) ) &&
            *pch != '/'      &&
            *pch != '\r'     &&
            *pch != '\n' )
    {
        pch++;
    }

    if ( !isdigit( (UCHAR)(*pch) ) )
        return -1;

    n = atoi( pch );

    while ( isdigit( (UCHAR)(*pch) ))
        pch++;

    *ppch = pch;

    return n;
}



BOOL
DisposeOpenURIFileInfo(
    IN  PVOID   pvOldBlock
    )
/*++

    Routine Description

        Close an open URI file information block. This involves closing the
        handle if the file information is valid and freeing and associated
        structures.

    Arguments

        pvOldBlock - pointer to the URI file information block.

    Returns

        TRUE if operation successful.

--*/
{

    PW3_URI_INFO        pURIInfo;
    PVOID pvBlob;
    BOOL bSuccess;

    pURIInfo = (PW3_URI_INFO ) pvOldBlock;

    if (pURIInfo->pszName != NULL) {
        LocalFree(pURIInfo->pszName);
    }

    if (pURIInfo->pszUnmappedName != NULL) {
        LocalFree(pURIInfo->pszUnmappedName);
    }

    if( pURIInfo->pMetaData != NULL ) {
        TsFreeMetaData(pURIInfo->pMetaData->QueryCacheInfo() );
    }

    if ( pURIInfo->pOpenFileInfo != NULL ) {
        TsDerefURIFile(pURIInfo->pOpenFileInfo);
    }

    return( TRUE );

} // DisposeOpenURIFileInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\extmap.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    extmap.cxx

    This module contains the extension mapping to CGI or BGI scripts.


    FILE HISTORY:
        Johnl        22-Sep-1995     Created

*/

#include "w3p.hxx"
#include <rpc.h>
#include <rpcndr.h>
#include <mbstring.h>

//
//  Name of the value under the parameters key containing the list of
//  script extension to BGI/CGI binaries.
//

#define HTTP_EXT_MAPS    "Script Map"

char    Get[] = "GET";

#define GET_SIZE (sizeof("GET"))

//
// This is the maximum size for a script map extension
//
#define MAX_EXT_LEN 128

//
//  This list is the extension maps found in the registry - they always get
//  appended to the end of all extension mappings that are added to a particular
//  URI.
//

static BOOL fInitialized = FALSE;

class EXT_MAP_ITEM
{
public:

    EXT_MAP_ITEM( const char * pszExtension,
                  const char * pszImage,
                  const DWORD dwFlags,
                  const CHAR * pszExclusions,
                  const DWORD dwExclusionLength)
    : _strExt     ( pszExtension ),
      _strImage   ( pszImage ),
      _GatewayType( GATEWAY_UNKNOWN ),
      _cchExt     ( 0 ),
      _dwFlags    ( dwFlags ),
      _fGetValid  (0),
      _dwInclusionCount   ( 0 ),
      _ppszInclusionTable ( NULL ),
      _pszInclusions      ( NULL )
    {
        DWORD cch;
        _fValid = _strExt.IsValid() && _strImage.IsValid() && ExpandImage();

        if ( _fValid )
        {
            const CHAR * pchtmp = pszImage;

            _cchExt = _strExt.QueryCCH();

            //
            //  Determine if this is a CGI or BGI gateway
            //

            while ( pchtmp = strchr( pchtmp + 1, '.' ))
            {
                if ( !_strnicmp( pchtmp, ".exe", 4 ))
                {
                    _GatewayType = GATEWAY_CGI;
                }
                else if ( !_strnicmp( pchtmp, ".dll", 4 ))
                {
                    _GatewayType = GATEWAY_BGI;
                }
            }

            if (!strcmp(pszExtension, "*"))
            {
                _fWildcard = TRUE;
                _dwFlags |= MD_SCRIPTMAPFLAG_WILDCARD;
            }
            else
            {
                _fWildcard = FALSE;
                _dwFlags &= ~MD_SCRIPTMAPFLAG_WILDCARD;
            }

            if (pszExclusions != NULL)
            {
                const CHAR      *pszTemp;
                char            *pszDest;

                _pszInclusions = new char[dwExclusionLength];

                if (_pszInclusions == NULL)
                {
                    _fValid = FALSE;
                    return;
                }

                _dwInclusionCount = 1;
                pszTemp = pszExclusions;
                pszDest = _pszInclusions;

                while (*pszTemp != '\0')
                {
                    CHAR        ch;

                    ch = *pszTemp;
                    pszTemp++;

                    if (ch != ',')
                    {
                        *pszDest = ch;
                    }
                    else
                    {
                        *pszDest = '\0';

                        _dwInclusionCount++;
                    }

                    pszDest++;

                }

                *pszDest = '\0';

                _ppszInclusionTable = new char *[_dwInclusionCount];

                if (_ppszInclusionTable == NULL)
                {
                    _fValid = FALSE;
                    return;
                }
                else
                {
                    DWORD       i;
                    DWORD       dwPos;

                    pszTemp = _pszInclusions;

                    i = 0;

                    do {

                        _ppszInclusionTable[i] = (CHAR *)pszTemp;

                        if ( _fGetValid )
                        {
                            dwPos = 0;
                        }

                        while (*pszTemp != '\0')
                        {
                            if (dwPos < GET_SIZE)
                            {
                                if (*pszTemp == Get[dwPos])
                                {
                                    dwPos++;

                                    if (dwPos == (GET_SIZE - 1))
                                    {
                                        if (*(pszTemp+1) == '\0')
                                        {
                                            _fGetValid = TRUE;
                                        }
                                        else
                                        {
                                            dwPos = GET_SIZE;
                                        }
                                    }
                                }
                                else
                                {
                                    dwPos = GET_SIZE;
                                }
                            }

                            pszTemp++;
                        }

                        DBG_ASSERT(*pszTemp == '\0');

                        pszTemp++;

                        i++;

                    } while (i < _dwInclusionCount  );
                }
            }
            else
            {
                _dwInclusionCount = 0;
                _ppszInclusionTable = NULL;
                _pszInclusions = NULL;
            }
        }
    }

    ~EXT_MAP_ITEM( )
    {
        delete _ppszInclusionTable;
        delete _pszInclusions;
    }


    GATEWAY_TYPE QueryGatewayType( VOID ) const
        { return _GatewayType; }

    const CHAR * QueryScript( VOID ) const
        { return _strImage.QueryStr(); }

    const CHAR * QueryExtension( VOID ) const
        { return _strExt.QueryStr(); }

    const BOOL AllowedOnReadDir()
        { return _dwFlags & MD_SCRIPTMAPFLAG_SCRIPT; }

    const DWORD QueryFlags()
        { return _dwFlags; }

    DWORD QueryCCHExt( VOID ) const
        { return _cchExt; }

    BOOL IsValid( VOID ) const
        { return _fValid; }

    BOOL IsWildCard( VOID ) const
        { return _fWildcard; }

    BOOL IsGetValid( VOID ) const
        { return _fGetValid; }

    BOOL ExpandImage( VOID );

    BOOL CheckInclusions(
                        const CHAR      *pszVerb
                        );

    LIST_ENTRY   _ListEntry;

private:

    STR          _strExt;
    STR          _strImage;
    DWORD        _cchExt;
    GATEWAY_TYPE _GatewayType;
    DWORD        _fValid:1;
    DWORD        _fWildcard:1;
    DWORD        _fGetValid:1;
    DWORD        _dwFlags;
    DWORD        _dwInclusionCount;
    CHAR         **_ppszInclusionTable;
    CHAR         *_pszInclusions;
};


BOOL
EXT_MAP_ITEM::ExpandImage( VOID )
/*++

Routine Description:

    Expand any embedded environment variables in the image.

Return Value:

    TRUE if successful, FALSE if not.

--*/
{
    DWORD               cbRet = 0;
    TCHAR               achBuffer[ MAX_PATH + 1 ];
    DWORD               cbBufLen = sizeof( achBuffer );

    cbRet = ExpandEnvironmentStringsA( _strImage.QueryStr(),
                                       achBuffer,
                                       cbBufLen );
    if ( !cbRet || ( cbRet > cbBufLen ) )
    {
        return FALSE;
    }
    else
    {
        return _strImage.Copy( achBuffer );
    }
}

//
//  Private globals.
//

BOOL
W3_METADATA::BuildExtMap(
    CHAR            *pszExtMapList
    )
/*++

Routine Description:

    Builds the extension mapping into the metadata. The input string is
    a multi-sz of comma seperated ext, image name strings.

Return Value:

    TRUE if successfull, FALSE if not.

--*/
{
    EXT_MAP_ITEM *     pExtMap;
    EXT_MAP_ITEM *     pWCExtMapItem;
    LIST_ENTRY *       pEntry;

    m_fAnyExtAllowedOnReadDir = FALSE;

    m_dwMaxExtLen = 0;

    do
    {

        CHAR        *pszExt;
        CHAR        *pszImage;
        CHAR        *pszFlags;
        CHAR        *pszExclusions;
        CHAR        *pszTemp;
        CHAR        *pszTemp2;
        CHAR        *pszTemp3;
        DWORD       dwExclusionSize;
        DWORD       dwExtSize;

        pszExt = pszExtMapList;

        // Find the end of the extension, and temporarily NULL terminate it.

        pszImage = strchr(pszExt, ',');

        if (pszImage == NULL) {
            // Bad script map entry
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        pszTemp = pszImage++;
        *pszTemp = '\0';

        pszFlags = strchr(pszImage, ',');

        if (pszFlags == NULL) {
            // Bad script map entry
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        pszTemp2 = pszFlags++;
        *pszTemp2 = '\0';

        //
        // HOTFIX: make sure the extension is not too long to be copied to
        // our static buffer.
        //
        dwExtSize = strlen(pszExt);
        if (dwExtSize > MAX_EXT_LEN) {
            // Bad script map entry
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        } else if (dwExtSize > m_dwMaxExtLen) {
            m_dwMaxExtLen = dwExtSize;
        }

        //
        // See if there's any excluded methods. If there are, break them out.
        //

        pszExclusions = strchr(pszFlags, ',');

        if (pszExclusions != NULL)
        {
            pszTemp3 = pszExclusions++;
            *pszTemp3 = '\0';
            dwExclusionSize = strlen(pszExclusions) + 1;
            pszExtMapList = pszExclusions + dwExclusionSize;
        }
        else
        {
            pszExtMapList = pszFlags + strlen(pszFlags) + 1;
            dwExclusionSize = 0;
        }

        //
        // HOTFIX: Now convert extension to lower case so we can avoid
        // multi-byte string compares that cause lock contention.
        //

        IISstrlwr( (PUCHAR) pszExt );
        
        //
        //  Note we OR in the notransmit flag on *all* script mappings!
        //

        pExtMap = new EXT_MAP_ITEM( pszExt,
                                    pszImage,
                                    ((DWORD) atoi( pszFlags )),
                                    pszExclusions,
                                    dwExclusionSize);

        *pszTemp = ',';
        *pszTemp2 = ',';

        if (pszExclusions != NULL)
        {
            *pszTemp3 = '\0';
        }

        if ( !pExtMap ||
             !pExtMap->IsValid() )
        {
            delete pExtMap;

            return FALSE;
        }

        if (!pExtMap->IsWildCard())
        {
            InsertTailList( &m_ExtMapHead, &pExtMap->_ListEntry );
        }
        else
        {

            pWCExtMapItem = (EXT_MAP_ITEM *)QueryWildcardMapping();

            if (pWCExtMapItem != NULL)
            {
                delete pWCExtMapItem;
            }

            SetWildcardMapping( pExtMap );
        }

        if ( pExtMap->QueryFlags() )
        {
            m_fAnyExtAllowedOnReadDir = TRUE;
        }

    } while ( *pszExtMapList != '\0');

    return TRUE;

} // W3_METADATA::BuildExtMap



VOID
W3_METADATA::TerminateExtMap(
    VOID
    )
/*++

Routine Description:

    Cleans up the extension map list

--*/
{
    LIST_ENTRY *   pEntry;
    EXT_MAP_ITEM * pExtMap;

    while ( !IsListEmpty( &m_ExtMapHead ))
    {
        pExtMap = CONTAINING_RECORD(  m_ExtMapHead.Flink,
                                      EXT_MAP_ITEM,
                                      _ListEntry );

        RemoveEntryList( &pExtMap->_ListEntry );

        delete pExtMap;
    }

    pExtMap = (EXT_MAP_ITEM *)QueryWildcardMapping();

    if (pExtMap != NULL)
    {
        delete pExtMap;
    }


} // W3_METADATA::TerminateExtMap

BOOL
EXT_MAP_ITEM::CheckInclusions(
    const CHAR      *pszVerb
    )
/*++

Routine Description:

    Check the extension map list to see if the input verb is included.
    If it is, we return TRUE, otherwise we return FALSE.
--*/
{
    DWORD           i;

    //
    // Special case for EMPTY script map. Allow all verbs
    //

    if (0 == _dwInclusionCount)
    {
        return TRUE;
    }
    
    for (i = 0; i < _dwInclusionCount; i++)
    {
        if (!_stricmp(pszVerb, _ppszInclusionTable[i]))
        {
            return TRUE;
        }
    }

    return FALSE;

} // EXT_MAP_ITEM::CheckInclusions

BOOL
W3_METADATA::LookupExtMap(
    IN  const CHAR *   pchExt,
    IN  BOOL           fNoWildcards,
    OUT STR *          pstrGatewayImage,
    OUT GATEWAY_TYPE * pGatewayType,
    OUT DWORD *        pcchExt,
    OUT BOOL *         pfImageInURL,
    OUT BOOL *         pfVerbExcluded,
    OUT DWORD *        pdwFlags,
    IN  const CHAR     *pszVerb,
    IN  enum HTTP_VERB Verb,
    IN OUT PVOID *     ppvExtMapInfo
    )
/*++

Routine Description:

    Finds the admin specified mapping between a script extension and the
    associated CGI or BGI binary to run (or load).

Arguments:

    pchExt - Pointer to possible extension to be mapped (i.e., '.pl')
    pstrGatewayImage - Receives the mapped binary image name
    pGatewayType - Specifies whether this is a BGI, CGI or MAP extension type
    pcchExt - Returns length of extension (including dot)
    pfImageInURL - Indicates an image was found encoded in the URL and not
        from a script extension mapping
    pdwFlags - Returns extension flags
    ppvExtMapInfo - Cached extension map info.  If *ppvExtMapInfo is NULL on
                    input, then set to the matched PEXT_MAP_ITEM.  If not NULL
                    on input, then it is used instead of doing lookup.

--*/
{
    EXT_MAP_ITEM * pExtMapItem;
    DWORD          cchTillEOS;
    BOOL           fRet;
    LIST_ENTRY *   pEntry;
    BOOL           bFoundMatch = FALSE;
    BOOL           fUseExtMapInfo = *ppvExtMapInfo != NULL;

    *pGatewayType = GATEWAY_UNKNOWN;
    *pfVerbExcluded = FALSE;

    //
    //  Check for wildcard mapping first
    //

    if (!fNoWildcards)
    {
        pExtMapItem = (EXT_MAP_ITEM *)QueryWildcardMapping();

        if (pExtMapItem != NULL)
        {
            if (Verb == HTV_GET && pExtMapItem->IsGetValid())
            {
                bFoundMatch = TRUE;
            }
            else
            {
                // If verb is not included, don't return the * script map.
                // Instead, continue to look for a script map match.
                
                bFoundMatch = pExtMapItem->CheckInclusions( pszVerb );
            }
        }
    }

    //
    //  Look for the exact extension mapping if there's no wildcard
    //

    if (!bFoundMatch && pchExt != NULL)
    {
        if ( fUseExtMapInfo )
        {
            //
            // If caller passed in a non-NULL pExtMapInfo, then use it 
            // instead of doing a manual lookup
            //
            
            if ( *ppvExtMapInfo != EXTMAP_UNKNOWN_PTR )
            {
                pExtMapItem = (EXT_MAP_ITEM*) *ppvExtMapInfo;
                bFoundMatch = TRUE;
            }
        }
        else
        {
            //
            // This buffer, rgchExtBuffer, holds a copy of a portion of a URL
            // which we are testing to see if it's a known extension.  We copy
            // into this buffer so we can convert the extension to lower case
            // without disrupting the original.
            //
            CHAR  rgchExtBuffer[MAX_EXT_LEN + 4];
            DWORD dwLength;
    
            DBG_ASSERT( *pchExt == '.' );
        
            //
            // HOTFIX: Now convert extension to lower case so we can avoid
            // multi-byte string compares that cause lock contention.
            //
            // Since we don't want to risk modifying the orignal URL, we
            // copy it into another buffer first.
            //

            cchTillEOS = strlen( pchExt );

            dwLength = min(cchTillEOS, m_dwMaxExtLen + 1);
            memcpy(rgchExtBuffer, pchExt, dwLength);
            rgchExtBuffer[ dwLength ] = 0;
        
            IISstrlwr( (PUCHAR) rgchExtBuffer );

            //
            //  Look through the list of mappings
            //

            for ( pEntry  = m_ExtMapHead.Flink;
                  !bFoundMatch && pEntry != &m_ExtMapHead;
                  pEntry  = pEntry->Flink )
            {
                pExtMapItem = CONTAINING_RECORD( pEntry, EXT_MAP_ITEM, _ListEntry );

                if ( cchTillEOS >= pExtMapItem->QueryCCHExt() &&
                     (pchExt[pExtMapItem->QueryCCHExt()] == '/' ||
                      pchExt[pExtMapItem->QueryCCHExt()] == '\0' ) &&
                     !memcmp( rgchExtBuffer,
                              pExtMapItem->QueryExtension(),
                              pExtMapItem->QueryCCHExt())
                    )
                {
                    bFoundMatch = TRUE;
                    *ppvExtMapInfo = pExtMapItem;
                }
            }
        }
    }

    if (bFoundMatch)
    {
        *pGatewayType = pExtMapItem->QueryGatewayType();
        *pcchExt      = pExtMapItem->QueryCCHExt();
        *pfImageInURL = FALSE;
        *pdwFlags     = pExtMapItem->QueryFlags();

        //
        // Check that verb is included. If it isn't, we're still going to return
        // this item.  Just indicate that the verb was excluded.
        //
        
        if (Verb != HTV_GET || !pExtMapItem->IsGetValid())
        {
            *pfVerbExcluded = !pExtMapItem->CheckInclusions(pszVerb);
        }

        fRet = pstrGatewayImage->Copy( pExtMapItem->QueryScript() );
        
        if ( !_stricmp( pExtMapItem->QueryScript(), "nogateway" ) )
        {
            *pGatewayType = GATEWAY_NONE;
        }

        return fRet;
    }

    if ( !pchExt || fUseExtMapInfo )
    {
        if ( !fUseExtMapInfo )
        {
            *ppvExtMapInfo = EXTMAP_UNKNOWN_PTR;
        }
        
        return TRUE;
    }

    //
    //  Either the image will be specified in the URL or not found, so
    //  just indicate it's in the URL.  Not found has precedence.
    //

    *pfImageInURL = TRUE;
    *pdwFlags = 0;

    //
    //  Look for CGI or BGI scripts in the URL itself
    //
    
    if ( cchTillEOS >= 4 &&
         (*(pchExt+4) == TEXT('/') ||
          *(pchExt+4) == TEXT('\0')) )
    {
        *pcchExt = 4;

        //
        //  Don't confuse a menu map request with a gateway request
        //

        if ( !::_tcsnicmp( TEXT(".MAP"), pchExt, 4 ))
        {
            *pGatewayType = GATEWAY_MAP;
            return TRUE;
        }

        if ( !::_tcsnicmp( TEXT(".EXE"), pchExt, 4 ) ||
             !::_tcsnicmp( TEXT(".CGI"), pchExt, 4 ) ||
             !::_tcsnicmp( TEXT(".COM"), pchExt, 4 ))
        {
            *pGatewayType = GATEWAY_CGI;
            return TRUE;
        }
        else if (!::_tcsnicmp( TEXT(".DLL"), pchExt, 4 ) ||
                 !::_tcsnicmp( TEXT(".ISA"), pchExt, 4 ) )
        {
            *pGatewayType = GATEWAY_BGI;
            return TRUE;
        }
    }
    
    *ppvExtMapInfo = EXTMAP_UNKNOWN_PTR;

    return TRUE;
} // W3_METADATA::LookupExtMap


APIERR
ReadRegistryExtMap(
    VOID
    )
/*++

Routine Description:

    Builds the extension mapping from the registry

Return Value:

    NO_ERROR if successful, win32 error code on failure

--*/
{
    HKEY               hkeyParam;
    DWORD              dwDisposition;
    LIST_ENTRY         pEntry;
    APIERR             err;
    DWORD              i = 0;
    DWORD              dwRegType;
    MB                 mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    MULTISZ            msz;
    BOOL               fNeedToWrite = FALSE;

    if ( !fInitialized )
    {
        fInitialized = TRUE;
    }

    //
    //  Get the list
    //

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          W3_PARAMETERS_KEY "\\" HTTP_EXT_MAPS,
                          0,
                          0,
                          0,
                          KEY_READ,
                          NULL,
                          &hkeyParam,
                          &dwDisposition );

    if( err != NO_ERROR )
    {
        TCP_PRINT(( DBG_CONTEXT,
                   "cannot open registry key, error %lu\n",
                    err ));

        return NO_ERROR;
    }


    if ( !mb.Open( "/LM/W3SVC/",
                   METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) ||
         !mb.GetMultisz( "",
                         MD_SCRIPT_MAPS,
                         IIS_MD_UT_FILE,
                         &msz ))
    {
        TCP_PRINT(( DBG_CONTEXT,
                    "cannot get the script maps from the metabase, error %d\n",
                    GetLastError() ));

        return NO_ERROR;
    }

    while ( TRUE )
    {
        CHAR  achExt[MAX_PATH+1];
        CHAR  achImage[MAX_PATH+1];
        DWORD cchExt   = sizeof( achExt );
        DWORD cchImage = sizeof( achImage );

        err = RegEnumValue( hkeyParam,
                            i++,
                            achExt,
                            &cchExt,
                            NULL,
                            &dwRegType,
                            (LPBYTE) achImage,
                            &cchImage );

        if ( err == ERROR_NO_MORE_ITEMS )
        {
            err = NO_ERROR;
            break;
        }

        if ( dwRegType == REG_SZ )
        {
            const CHAR * psz;
            BOOL  fFound = FALSE;

            //
            //  Look for this script map in the metabase, if not found, add it
            //

            for ( psz = msz.First(); psz != NULL; psz = msz.Next( psz ) )
            {
                if ( !IISstrnicmp( (PUCHAR)achExt, (PUCHAR)psz, cchExt ))
                {
                    fFound = TRUE;
                    break;
                }
            }

            if ( !fFound )
            {
                STR str;
                CHAR achFlags[32];

                //
                //  Note these scripts are added w/o the Script bit and with
                //  the "never download" bit.  In addition, we leave the
                //  method exclusion list blank.
                //

                _itoa( 0, achFlags, 10 );

                if ( !str.Append( achExt )   ||
                     !str.Append( "," )      ||
                     !str.Append( achImage ) ||
                     !str.Append( "," )      ||
                     !str.Append( achFlags ) ||
                     !msz.Append( str.QueryStr() ))
                {
                    return err = GetLastError();
                    break;
                }

                TCP_PRINT(( DBG_CONTEXT,
                            "Added \"%s\" from registry as script map\n",
                            str.QueryStr() ));

                fNeedToWrite = TRUE;
            }
       }
    }

    if ( fNeedToWrite )
    {
        if ( !mb.SetMultiSZ( "",
                             MD_SCRIPT_MAPS,
                             IIS_MD_UT_FILE,
                             msz.QueryStr() ))
        {
            TCP_PRINT(( DBG_CONTEXT,
                        "Failed to write MD_SCRIPT_MAPS back to metabase, error %d\n",
                        GetLastError() ));
        }
    }

    RegCloseKey( hkeyParam );

    return err;
}

VOID
FreeRegistryExtMap(
    VOID
    )
{
    if ( !fInitialized )
    {
        return;
    }

    fInitialized = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\dllreg.cxx ===
/*++

   Copyright    (c)    1998        Microsoft Corporation

   Module Name:

        dllreg.cxx

   Abstract:

        This module implements the dll registration for w3svc.dll

   Author:

        Michael Thomas    (michth)      Feb-17-1998

--*/
#include "w3p.hxx"
#include "iadmw.h"
#include "w3subs.hxx"

//
// Headers for logging fields
//

#define CPU_LOGGING_HEADER_EVENT            L"s-event"
#define CPU_LOGGING_HEADER_ACTIVE_PROCS     L"s-active-procs"
#define CPU_LOGGING_HEADER_KERNEL_TIME      L"s-kernel-time"
#define CPU_LOGGING_HEADER_PAGE_FAULTS      L"s-page-faults"
#define CPU_LOGGING_HEADER_PROC_TYPE        L"s-process-type"
#define CPU_LOGGING_HEADER_TERMINATED_PROCS L"s-stopped-procs"
#define CPU_LOGGING_HEADER_TOTAL_PROCS      L"s-total-procs"
#define CPU_LOGGING_HEADER_USER_TIME        L"s-user-time"

#define MAX_RESOURCE_LOG_NAME_LEN           256

#define CUSTOM_LOGGING_PATH_W               L"/LM/Logging/Custom Logging"
#define WEB_SERVER_PATH_W                   L"/LM/W3SVC"
#define W3_SERVICE_NAME_W                   L"W3SVC"

HRESULT
SetFieldData(IMSAdminBaseW * pcCom,
             METADATA_HANDLE mhCustomLogging,
             HINSTANCE hInstance,
             DWORD   dwNameResourceId,
             LPCWSTR pszwcPath,
             LPCWSTR pszwcHeader,
             DWORD   dwHeaderSize,
             DWORD   dwMask,
             DWORD   dwDataType = MD_LOGCUSTOM_DATATYPE_ULONG);


/*++

Routine Description:

    Write all custom logging info for a field to the netabase,

Arguments:

    pcCom   Metabase interface
    mhCustomLogging Metabase Handle to CUSTOM_LOGGING_PATH_W
    hInstance  Instance handle to w3svc.dll
    dwNameResourceId  The id of the logging field name resource.
    pszwcPath  The metabase subpath of this field
    pszwcHeader The logging field header
    dwHeaderSize Length of the logging field header in bytes include the trailing 0
    dwMask       The logging mask bit for the field
    dwDataType   The logging type of this field


Return Value:

Notes:
--*/

HRESULT
SetFieldData(IMSAdminBaseW * pcCom,
             METADATA_HANDLE mhCustomLogging,
             HINSTANCE hInstance,
             DWORD   dwNameResourceId,
             LPCWSTR pszwcPath,
             LPCWSTR pszwcHeader,
             DWORD   dwHeaderSize,
             DWORD   dwMask,
             DWORD   dwDataType)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    WCHAR pszwBuffer[MAX_RESOURCE_LOG_NAME_LEN ];

    //
    // Create the key
    //

    hresReturn = pcCom->AddKey( mhCustomLogging,
                                pszwcPath );

    //
    // OK if it already exists
    //

    if (hresReturn == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) {
        hresReturn = ERROR_SUCCESS;
    }

    if (SUCCEEDED(hresReturn)) {

        //
        // Set field name
        //

        hresReturn = GetUnicodeResourceString(hInstance,
                                              dwNameResourceId,
                                              pszwBuffer,
                                              MAX_RESOURCE_LOG_NAME_LEN);

        if (SUCCEEDED(hresReturn)) {
            MD_SET_DATA_RECORD(&mdrData,
                               MD_LOGCUSTOM_PROPERTY_NAME,
                               METADATA_NO_ATTRIBUTES,
                               IIS_MD_UT_SERVER,
                               STRING_METADATA,
                               (wcslen(pszwBuffer) + 1) * 2,
                               (PBYTE)pszwBuffer);

            hresReturn = pcCom->SetData(mhCustomLogging,
                                        pszwcPath,
                                        &mdrData);

        }

        //
        // Set field header
        //

        if (SUCCEEDED(hresReturn)) {

            MD_SET_DATA_RECORD(&mdrData,
                               MD_LOGCUSTOM_PROPERTY_HEADER,
                               METADATA_NO_ATTRIBUTES,
                               IIS_MD_UT_SERVER,
                               STRING_METADATA,
                               dwHeaderSize,
                               (PBYTE)pszwcHeader);

            hresReturn = pcCom->SetData(mhCustomLogging,
                                        pszwcPath,
                                        &mdrData);

        }

        //
        // Set field mask
        //

        if (SUCCEEDED(hresReturn)) {

            MD_SET_DATA_RECORD(&mdrData,
                               MD_LOGCUSTOM_PROPERTY_MASK,
                               METADATA_NO_ATTRIBUTES,
                               IIS_MD_UT_SERVER,
                               DWORD_METADATA,
                               sizeof(DWORD),
                               (PBYTE)&dwMask);

            hresReturn = pcCom->SetData(mhCustomLogging,
                                        pszwcPath,
                                        &mdrData);
        }

        //
        // Set field data type
        //

        if (SUCCEEDED(hresReturn)) {
            if (dwDataType != MD_LOGCUSTOM_DATATYPE_ULONG) {

                MD_SET_DATA_RECORD(&mdrData,
                                   MD_LOGCUSTOM_PROPERTY_DATATYPE,
                                   METADATA_NO_ATTRIBUTES,
                                   IIS_MD_UT_SERVER,
                                   DWORD_METADATA,
                                   sizeof(DWORD),
                                   (PBYTE)&dwDataType);

                hresReturn = pcCom->SetData(mhCustomLogging,
                                            pszwcPath,
                                            &mdrData);

            }
        }
    }
    return hresReturn;
}

/*++

Routine Description:

    Register w3svc.
    Write CPU Logging and Limits defaults
    Write CPU Logging custom logging info.

Return Value:
    error code

--*/

STDAPI DllRegisterServer(void)
{
    METADATA_RECORD mdrData;
    IMSAdminBaseW * pcCom = NULL;
    METADATA_HANDLE mhCustomLogging;
    METADATA_HANDLE mhWebServer;
    DWORD dwData;
    WCHAR pszwData[256];
    HRESULT hresReturn;
    HINSTANCE hInstance;
    WCHAR pszwBuffer[MAX_RESOURCE_LOG_NAME_LEN ];

    //
    // Get module handle for w3svc.dll, to pass to GetUnicodeResourceString.
    //

    hInstance = GetModuleHandle("W3SVC.DLL");

    if (hInstance == NULL) {
        hresReturn = HRESULT_FROM_WIN32(GetLastError());
    }
    else {

        //
        // Get the metabase interface
        //

        hresReturn = CoInitializeEx(NULL, COINIT_MULTITHREADED);

        if (hresReturn == RPC_E_CHANGED_MODE) {
            hresReturn = CoInitialize(NULL);
        }

        if (SUCCEEDED(hresReturn)) {
            hresReturn = CoCreateInstance(CLSID_MSAdminBase_W,
                                          NULL,
                                          CLSCTX_SERVER,
                                          IID_IMSAdminBase_W,
                                          (void**) &pcCom);
            if (SUCCEEDED(hresReturn)) {

                //
                // Open custom logging node
                //

                hresReturn = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                      CUSTOM_LOGGING_PATH_W,
                                      METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                      40000,
                                      &mhCustomLogging);
                if (SUCCEEDED(hresReturn)) {

                    /* 
                    removed for iis51/iis60
                    -----------------------
                    //
                    // Add CPU Logging key
                    //

                    hresReturn = pcCom->AddKey( mhCustomLogging,
                                                W3_CPU_LOG_PATH_W );

                    if (hresReturn == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) {
                        hresReturn = ERROR_SUCCESS;
                    }
                    */

                    if (SUCCEEDED(hresReturn)) {


                        /* 
                        removed for iis51/iis60
                        -----------------------
                        //
                        // Set field name
                        //

                        hresReturn = GetUnicodeResourceString(hInstance,
                                                              IDS_CPU_LOGGING_NAME,
                                                              pszwBuffer,
                                                              MAX_RESOURCE_LOG_NAME_LEN);

                        if (SUCCEEDED(hresReturn)) {
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_LOGCUSTOM_PROPERTY_NAME,
                                               METADATA_NO_ATTRIBUTES,
                                               IIS_MD_UT_SERVER,
                                               STRING_METADATA,
                                               (wcslen(pszwBuffer) + 1) * 2,
                                               (PBYTE)pszwBuffer);

                            hresReturn = pcCom->SetData(mhCustomLogging,
                                                        W3_CPU_LOG_PATH_W,
                                                        &mdrData);

                        }

                        if (SUCCEEDED(hresReturn)) {

                            //
                            // Logging Property id is the same for all fields, so set it here
                            // Also needed here for the UI
                            //

                            dwData = MD_CPU_LOGGING_MASK;

                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_LOGCUSTOM_PROPERTY_ID,
                                               METADATA_INHERIT,
                                               IIS_MD_UT_SERVER,
                                               DWORD_METADATA,
                                               sizeof(DWORD),
                                               (PBYTE)&dwData);

                            hresReturn = pcCom->SetData(mhCustomLogging,
                                                        W3_CPU_LOG_PATH_W,
                                                        &mdrData);

                        }

                        removed for iis51/iis60
                        -----------------------

                        if (SUCCEEDED(hresReturn)) {

                            //
                            // Set mask bit for enable flag
                            //

                            dwData = MD_CPU_ENABLE_LOGGING;
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_LOGCUSTOM_PROPERTY_MASK,
                                               METADATA_NO_ATTRIBUTES,
                                               IIS_MD_UT_SERVER,
                                               DWORD_METADATA,
                                               sizeof(DWORD),
                                               (PBYTE)&dwData);
                            hresReturn = pcCom->SetData(mhCustomLogging,
                                                        W3_CPU_LOG_PATH_W,
                                                        &mdrData);
                        }

                        if (SUCCEEDED(hresReturn)) {

                            //
                            // Most fields are dwords, so set that here and override if different
                            //

                            dwData = MD_LOGCUSTOM_DATATYPE_ULONG;
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_LOGCUSTOM_PROPERTY_DATATYPE,
                                               METADATA_INHERIT,
                                               IIS_MD_UT_SERVER,
                                               DWORD_METADATA,
                                               sizeof(DWORD),
                                               (PBYTE)&dwData);
                            hresReturn = pcCom->SetData(mhCustomLogging,
                                                        W3_CPU_LOG_PATH_W,
                                                        &mdrData);
                        }

                        if (SUCCEEDED(hresReturn)) {

                            //
                            // Set the services string
                            //

                            memcpy(pszwData, W3_SERVICE_NAME_W, sizeof(W3_SERVICE_NAME_W));
                            pszwData[sizeof(W3_SERVICE_NAME_W)/2] = 0;
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_LOGCUSTOM_SERVICES_STRING,
                                               METADATA_INHERIT,
                                               IIS_MD_UT_SERVER,
                                               MULTISZ_METADATA,
                                               sizeof(W3_SERVICE_NAME_W) + 2,
                                               (PBYTE)pszwData);
                            hresReturn = pcCom->SetData(mhCustomLogging,
                                                        W3_CPU_LOG_PATH_W,
                                                        &mdrData);
                        }

                        //
                        // Set up all of the fields
                        //

                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetFieldData(pcCom,
                                                      mhCustomLogging,
                                                      hInstance,
                                                      IDS_CPU_LOGGING_NAME_EVENT,
                                                      W3_CPU_LOG_PATH_W W3_CPU_LOG_EVENT_PATH_W,
                                                      CPU_LOGGING_HEADER_EVENT,
                                                      sizeof(CPU_LOGGING_HEADER_EVENT),
                                                      MD_CPU_ENABLE_EVENT,
                                                      MD_LOGCUSTOM_DATATYPE_LPSTR);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetFieldData(pcCom,
                                                      mhCustomLogging,
                                                      hInstance,
                                                      IDS_CPU_LOGGING_NAME_PROC_TYPE,
                                                      W3_CPU_LOG_PATH_W W3_CPU_LOG_PROCESS_TYPE_PATH_W,
                                                      CPU_LOGGING_HEADER_PROC_TYPE,
                                                      sizeof(CPU_LOGGING_HEADER_PROC_TYPE),
                                                      MD_CPU_ENABLE_PROC_TYPE,
                                                      MD_LOGCUSTOM_DATATYPE_LPSTR);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetFieldData(pcCom,
                                                      mhCustomLogging,
                                                      hInstance,
                                                      IDS_CPU_LOGGING_NAME_USER_TIME,
                                                      W3_CPU_LOG_PATH_W W3_CPU_LOG_USER_TIME_PATH_W,
                                                      CPU_LOGGING_HEADER_USER_TIME,
                                                      sizeof(CPU_LOGGING_HEADER_USER_TIME),
                                                      MD_CPU_ENABLE_USER_TIME,
                                                      MD_LOGCUSTOM_DATATYPE_LPSTR);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetFieldData(pcCom,
                                                      mhCustomLogging,
                                                      hInstance,
                                                      IDS_CPU_LOGGING_NAME_KERNEL_TIME,
                                                      W3_CPU_LOG_PATH_W W3_CPU_LOG_KERNEL_TIME_PATH_W,
                                                      CPU_LOGGING_HEADER_KERNEL_TIME,
                                                      sizeof(CPU_LOGGING_HEADER_KERNEL_TIME),
                                                      MD_CPU_ENABLE_KERNEL_TIME,
                                                      MD_LOGCUSTOM_DATATYPE_LPSTR);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetFieldData(pcCom,
                                                      mhCustomLogging,
                                                      hInstance,
                                                      IDS_CPU_LOGGING_NAME_PAGE_FAULTS,
                                                      W3_CPU_LOG_PATH_W W3_CPU_LOG_PAGE_FAULT_PATH_W,
                                                      CPU_LOGGING_HEADER_PAGE_FAULTS,
                                                      sizeof(CPU_LOGGING_HEADER_PAGE_FAULTS),
                                                      MD_CPU_ENABLE_PAGE_FAULTS);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetFieldData(pcCom,
                                                      mhCustomLogging,
                                                      hInstance,
                                                      IDS_CPU_LOGGING_NAME_TOTAL_PROCS,
                                                      W3_CPU_LOG_PATH_W W3_CPU_LOG_TOTAL_PROCS_PATH_W,
                                                      CPU_LOGGING_HEADER_TOTAL_PROCS,
                                                      sizeof(CPU_LOGGING_HEADER_TOTAL_PROCS),
                                                      MD_CPU_ENABLE_TOTAL_PROCS);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetFieldData(pcCom,
                                                      mhCustomLogging,
                                                      hInstance,
                                                      IDS_CPU_LOGGING_NAME_ACTIVE_PROCS,
                                                      W3_CPU_LOG_PATH_W W3_CPU_LOG_ACTIVE_PROCS_PATH_W,
                                                      CPU_LOGGING_HEADER_ACTIVE_PROCS,
                                                      sizeof(CPU_LOGGING_HEADER_ACTIVE_PROCS),
                                                      MD_CPU_ENABLE_ACTIVE_PROCS);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            hresReturn = SetFieldData(pcCom,
                                                      mhCustomLogging,
                                                      hInstance,
                                                      IDS_CPU_LOGGING_NAME_TERMINATED_PROCS,
                                                      W3_CPU_LOG_PATH_W W3_CPU_LOG_TERMINATED_PROCS_PATH_W,
                                                      CPU_LOGGING_HEADER_TERMINATED_PROCS,
                                                      sizeof(CPU_LOGGING_HEADER_TERMINATED_PROCS),
                                                      MD_CPU_ENABLE_TERMINATED_PROCS);
                        }
                        */
                    }
                    pcCom->CloseKey(mhCustomLogging);
                }

                if (SUCCEEDED(hresReturn)) {

                    //
                    // Set up service level CPU Logging and Limit defaults
                    // at "/lm/w3svc"
                    // Default values include reset interval, logging interval,
                    // logging options, logging mask, cgi enabled, and app enabled.
                    //

                    hresReturn = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                                WEB_SERVER_PATH_W,
                                                METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                                40000,
                                                &mhWebServer);

                    if (SUCCEEDED(hresReturn)) {
                        dwData = DEFAULT_W3_CPU_RESET_INTERVAL;
                        MD_SET_DATA_RECORD(&mdrData,
                                           MD_CPU_RESET_INTERVAL,
                                           METADATA_INHERIT,
                                           IIS_MD_UT_SERVER,
                                           DWORD_METADATA,
                                           sizeof(DWORD),
                                           (PBYTE)&dwData);
                        hresReturn = pcCom->SetData(mhWebServer,
                                                    NULL,
                                                    &mdrData);

                        if (SUCCEEDED(hresReturn)) {
                            dwData = DEFAULT_W3_CPU_QUERY_INTERVAL;
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_CPU_LOGGING_INTERVAL,
                                               METADATA_INHERIT,
                                               IIS_MD_UT_SERVER,
                                               DWORD_METADATA,
                                               sizeof(DWORD),
                                               (PBYTE)&dwData);
                            hresReturn = pcCom->SetData(mhWebServer,
                                                        NULL,
                                                        &mdrData);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            dwData = DEFAULT_W3_CPU_LOGGING_OPTIONS;
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_CPU_LOGGING_OPTIONS,
                                               METADATA_INHERIT,
                                               IIS_MD_UT_SERVER,
                                               DWORD_METADATA,
                                               sizeof(DWORD),
                                               (PBYTE)&dwData);

                            hresReturn = pcCom->SetData(mhWebServer,
                                                        NULL,
                                                        &mdrData);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            dwData = DEFAULT_W3_CPU_LOGGING_MASK;
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_CPU_LOGGING_MASK,
                                               METADATA_INHERIT,
                                               IIS_MD_UT_SERVER,
                                               DWORD_METADATA,
                                               sizeof(DWORD),
                                               (PBYTE)&dwData);

                            hresReturn = pcCom->SetData(mhWebServer,
                                                        NULL,
                                                        &mdrData);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            dwData = TRUE;
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_CPU_CGI_ENABLED,
                                               METADATA_INHERIT,
                                               IIS_MD_UT_FILE,
                                               DWORD_METADATA,
                                               sizeof(DWORD),
                                               (PBYTE)&dwData);

                            hresReturn = pcCom->SetData(mhWebServer,
                                                        NULL,
                                                        &mdrData);
                        }

                        if (SUCCEEDED(hresReturn)) {
                            dwData = TRUE;
                            MD_SET_DATA_RECORD(&mdrData,
                                               MD_CPU_APP_ENABLED,
                                               METADATA_INHERIT,
                                               IIS_MD_UT_FILE,
                                               DWORD_METADATA,
                                               sizeof(DWORD),
                                               (PBYTE)&dwData);

                            hresReturn = pcCom->SetData(mhWebServer,
                                                        NULL,
                                                        &mdrData);
                        }

                        pcCom->CloseKey(mhWebServer);

                    }
                }


                pcCom->Release();
            }
            CoUninitialize();
        }
    }

    return hresReturn;
}

/*++

Routine Description:

    Unregister w3svc.
    Delete CPU Logging custom logging info.

Return Value:
    error code

--*/
STDAPI DllUnregisterServer(void)
{
    IMSAdminBaseW * pcCom = NULL;
    METADATA_HANDLE mhCustomLogging;
    HRESULT hresReturn;

    hresReturn = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (hresReturn == RPC_E_CHANGED_MODE) {
        hresReturn = CoInitialize(NULL);
    }

    if (SUCCEEDED(hresReturn)) {
        hresReturn = CoCreateInstance(CLSID_MSAdminBase_W,
                                      NULL,
                                      CLSCTX_SERVER,
                                      IID_IMSAdminBase_W,
                                      (void**) &pcCom);
        if (SUCCEEDED(hresReturn)) {
            hresReturn = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                  L"/LM/Logging/Custom Logging" ,
                                  METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                  40000,
                                  &mhCustomLogging);
            if (SUCCEEDED(hresReturn)) {
                hresReturn = pcCom->DeleteKey(mhCustomLogging,
                                              W3_CPU_LOG_PATH_W);
                pcCom->CloseKey(mhCustomLogging);
            }
            pcCom->Release();
        }
        CoUninitialize();
    }

    //
    // OpenKey and DeleteKey can return path not found. This is ok,
    // don't need to do anything.
    //

    if (hresReturn == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
        hresReturn = ERROR_SUCCESS;
    }

    return hresReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\dirlist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    dirlist.cxx

    This module contains the code for producing an HTML directory listing

    FILE HISTORY:
        Johnl       09-Sep-1994     Created
        MuraliK     06-Dec-1995     Added support to use WIN32_FIND_DATA

*/

#include "w3p.hxx"

#include <mbstring.h>

//
//  Private constants.
//

//
//  Private globals.
//

CHAR g_achToParentText[100];

DWORD   g_fDirFlagsSet = FALSE;

//
//  Private Manifests
//

//
//  The first part of the HTML document, %s is the URL
//

#define HTML_DIR_HEADER             "<head><title>%s - %s</title></head>"     \
                                    "<body><H1>%s - %s</H1>"                  \
                                    "<hr>\r\n\r\n<pre>"

//
//  The footer for an HTML document
//

#define HORZ_RULE                   "</pre><hr></body>"

//
//  These constants define the field width for the directory listing
//

#define PAD_LONG_DATE           29
#define PAD_SHORT_DATE          10
#define PAD_TIME                 8
#define PAD_FILESIZE            12

//
//  Space between columns
//

#define COL_SPACE             " "
#define PAD_COL_SPACING       (sizeof(COL_SPACE) - 1)

//
//  A wsprintf format string that prints the file format like:
//
//  <date><time><size><anchor><file name>
//

#define DIR_FORMAT_STR        "%s%s%s<A HREF=\"%s\">%s</A><br>"

//
//  We assume a formatted directory entry will fit in this size
//

#define MIN_BUFF_FREE               350
#define CHUNK_OFFSET                10

VOID PadDirField( TCHAR * pch,
                  INT     pad );

//
//  Global data
//

//
//  Private prototypes.
//

BOOL
AddDirHeaders(
    IN     CHAR *              pszServer,
    IN OUT CHAR *              pszPath,
    IN     BOOL                fModifyPath,
    OUT    CHAR *              pchBuf,
    IN     DWORD               cbBuf,
    OUT    DWORD *             pcbWritten,
    IN     CHAR *              pszToParentText
    );

BOOL FormatDirEntry(
    OUT CHAR *              pchBuf,
    IN  DWORD               cbBuf,
    OUT DWORD *             pcbWritten,
    IN  CHAR *              pchFile,
    IN  CHAR *              pchLink,
    IN  DWORD               dwAttributes,
    IN  LARGE_INTEGER *     pliSize,
    IN  LARGE_INTEGER *     pliLastMod,
    IN  DWORD               fDirBrowseFlags,
    IN  BOOL                bLocalizeDateAndTime
    );

BOOL
UrlEscape( CHAR * pchSrc,
           CHAR * pchDest,
           DWORD  cbDest
           );

DWORD
AddChunkStuff(
    BUFFER      *pBuff,
    DWORD       cbBuff,
    CHAR        *FooterString,
    DWORD       FooterLength,
    BOOL        fLastChunk
    )
/*++

    AddChunkStuff

    Routine Description - Add a chunk header and footer to some stuff we're
    about to send. It's assumed CHUNK_OFFSET bytes at the start of the buffer
    are reserved for us. We also append at least a CRLF to the end, and maybe
    more, that the caller needs to be aware of.

    Arguments:

        pBuff           - Pointer to buffer to add to.
        cbBuff          - Bytes currently in buffer.
        FooterString    - Pointer to footer string to add.
        FooterLength    - Length of FooterString
        fLastChunk      - TRUE if this is the last chunk of the response.

    Returns:
        Number of bytes added, not including FooterLength, or 0
        if we fail.

--*/
{
    DWORD       dwChunkLength;
    CHAR        cChunkSize[10];
    CHAR        *pszFooter;
    DWORD       dwExtraBytes;


    dwChunkLength = wsprintf(cChunkSize, "%x\r\n", cbBuff + FooterLength);

    memcpy((CHAR *)pBuff->QueryPtr() + CHUNK_OFFSET - dwChunkLength,
            cChunkSize,
            dwChunkLength);

    dwExtraBytes = (DWORD)(CRLF_SIZE + FooterLength +
                    (fLastChunk ? sizeof("0\r\n\r\n") - 1 : 0));

    if ( (pBuff->QuerySize() - cbBuff - CHUNK_OFFSET) < dwExtraBytes)
    {
        if (!pBuff->Resize(pBuff->QuerySize() + dwExtraBytes))
        {
            return 0;
        }
    }

    pszFooter = (CHAR *)pBuff->QueryPtr() + CHUNK_OFFSET + cbBuff;

    memcpy(pszFooter, FooterString, FooterLength);
    pszFooter += FooterLength;

    APPEND_STRING(pszFooter, "\r\n");

    if (fLastChunk)
    {
        APPEND_STRING(pszFooter, "0\r\n\r\n");

    }

    return dwChunkLength;

}

/*******************************************************************

    NAME:       HTTP_REQUEST::DoDirList

    SYNOPSIS:   Produces an HTML doc from a directory enumeration


    ENTRY:      strPath - Directory to enumerate
                pbufResp - where to put append formatted string to


    RETURNS:    TRUE if successful, FALSE on error

    NOTES:      We temporarily escape the directory URL so the anchors
                are built correctly (no spaces etc).

    HISTORY:
        Johnl       12-Sep-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::DoDirList( const STR & strPath,
                              BUFFER *    pbufResp,
                              BOOL *      pfFinished )
{
    STACK_STR(        str, 3*MAX_PATH);
    BOOL              fRet = FALSE;
    UINT              cch;
    BOOL              fAppendSlash = FALSE;
    DWORD             cbBuff = 0;
    DWORD             cbFree;
    DWORD             cb;
    DWORD             cbSent;
    BOOL              fSentHeaders = FALSE;
    int               i;
    DWORD             cbOffset;
    DWORD             dwChunkOffset;
    HTTP_VERB         Verb;

    TS_DIRECTORY_INFO DirInfo( QueryW3Instance()->GetTsvcCache() );
    const WIN32_FIND_DATA * pFile;
    BUFFER *          pbuff = pbufResp;

    IF_DEBUG( PARSING )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[DoDirList] Doing directory list on %s\n",
                   strPath.QueryStr()));
    }

    if ( !str.Resize( 3 * MAX_PATH ) ||
         !str.Copy( strPath )        ||
         !pbufResp->Resize( 8192 ) )
    {
        return FALSE;
    }

    //
    //  Make sure the directory ends in a backslash
    //

    fAppendSlash = *CharPrev( str.QueryStr(),
                              str.QueryStr() + str.QueryCCH() ) != TEXT('\\');

    if ( (fAppendSlash && !str.Append( TEXT("\\"), 1 )) )
    {
        return FALSE;
    }

    if ( (*(_strURL.QueryStr() + _strURL.QueryCCH() - 1) != TEXT('/') ) &&
         !_strURL.Append( TEXT("/"), 1) )
    {
        return FALSE;
    }

    //
    //  Don't currently support Keep-connection on directory listings
    //

    if (IsAtLeastOneOne())
    {
        cbOffset = 10;
    }
    else
    {
        SetKeepConn( FALSE );
        cbOffset = 0;
        dwChunkOffset = 0;
    }

    //
    //  Add the protocol headers, the "To Parent" anchor and directory
    //  name at the top
    //

    cbFree = pbuff->QuerySize();

    if ( !ImpersonateUser()     ||
         !DirInfo.GetDirectoryListingA( str.QueryStr(),
                                        QueryImpersonationHandle() ))
    {
        RevertUser();

        DWORD err = GetLastError();
        
        if (err == ERROR_FILE_NOT_FOUND ||
            err == ERROR_PATH_NOT_FOUND ||
            err == ERROR_INVALID_NAME || 
            err == ERROR_FILENAME_EXCED_RANGE )
        {
            SetState( HTR_DONE, HT_NOT_FOUND, err );
            Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
            return TRUE;
        }
        return FALSE;
    }

    RevertUser();

    Verb = QueryVerb();
    
    if ( !SendHeader( "200 Ok",
                      IsAtLeastOneOne() ?
                        "Transfer-Encoding: chunked\r\nContent-Type: text/html\r\n\r\n" :
                        "Content-Type: text/html\r\n\r\n" ,
                      Verb != HTV_HEAD ? IO_FLAG_SYNC : IO_FLAG_ASYNC,
                      pfFinished ))
    {
        return FALSE;
    }

    if ( *pfFinished || Verb == HTV_HEAD)
        return TRUE;

    if ( !AddDirHeaders( QueryHostAddr(),
                         _strURL.QueryStr(),
                         FALSE,
                         (CHAR *) pbuff->QueryPtr() + cbOffset,
                         cbFree - cbOffset,
                         &cb,
                         g_achToParentText ))
    {
        goto Exit;
    }

    cbFree -= cb;
    cbBuff += cb;

    //
    //  For each subsequent file/directory, display it
    //

    for ( i = 0; i < DirInfo.QueryFilesCount(); i++ )
    {
        pFile = DirInfo[i];

        //
        //  Ignore the "." and ".." and hidden directory entries
        //

        if ( (pFile->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) == 0 &&
             _tcscmp( pFile->cFileName, TEXT(".")) &&
             _tcscmp( pFile->cFileName, TEXT(".."))  )
        {
            LARGE_INTEGER  liSize;
            LARGE_INTEGER  liTime;

            //
            //  Do we need to send this chunk of our
            //  directory listing response?
            //

            if ( (cbFree - cbOffset) < MIN_BUFF_FREE )
            {

                if (IsAtLeastOneOne())
                {

                    DWORD       dwChunkLength;

                    dwChunkLength = AddChunkStuff(pbuff, cbBuff, NULL, 0, FALSE);

                    if (dwChunkLength == 0)
                    {
                        return FALSE;
                    }

                    dwChunkOffset = cbOffset - dwChunkLength;
                    cbBuff += (dwChunkLength + CRLF_SIZE);

                }

                if ( !WriteFile( (CHAR *)pbuff->QueryPtr() + dwChunkOffset,
                                 cbBuff,
                                 &cbSent,
                                 IO_FLAG_SYNC ))

                {
                    goto Exit;
                }

                if ( !fSentHeaders )
                    fSentHeaders = TRUE;

                cbBuff = 0;
                cbFree = pbuff->QuerySize();
            }

            //
            //  Make the link
            //

            wsprintf( str.QueryStr(),
                      ((pFile->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ?
                          "%s%s/" : "%s%s"),
                      _strURL.QueryStr(),
                      pFile->cFileName );

            //
            // The liTime is a hack, since FormatDirEntry() does not
            //  take FILETIMEs. It should probably be modified.
            //
            liTime.HighPart = pFile->ftLastWriteTime.dwHighDateTime;
            liTime.LowPart  = pFile->ftLastWriteTime.dwLowDateTime;
            liSize.HighPart = pFile->nFileSizeHigh;
            liSize.LowPart  = pFile->nFileSizeLow;

            if ( !FormatDirEntry( (CHAR *) pbuff->QueryPtr() + cbBuff + cbOffset,
                                  cbFree - cbOffset,
                                  &cb,
                                  (char * ) pFile->cFileName,
                                  str.QueryStr(),
                                  pFile->dwFileAttributes,
                                  (LARGE_INTEGER *) &liSize,
                                  (LARGE_INTEGER *) &liTime,
                                  _pMetaData->QueryDirBrowseFlags(),
                                  TRUE ))
            {
                goto Exit;
            }

            //
            //  Track how much was just added for this directory entry
            //

            cbFree -= cb;
            cbBuff += cb;
        }
    }

    //
    //  Add a nice horizontal line at the end of the listing
    //

#define HORZ_RULE       "</pre><hr></body>"

    if (IsAtLeastOneOne())
    {
        DWORD       dwChunkLength;

        dwChunkLength = AddChunkStuff(pbuff, cbBuff,
                                        HORZ_RULE,
                                        sizeof(HORZ_RULE) - 1,
                                        TRUE);

        dwChunkOffset = cbOffset - dwChunkLength;
        cbBuff += (dwChunkLength + sizeof(HORZ_RULE"\r\n0\r\n\r\n") - 1);
    }
    else
    {
        strcat( (CHAR *) pbuff->QueryPtr() + cbBuff,
                HORZ_RULE );

        cbFree -= sizeof(HORZ_RULE) - sizeof(CHAR);
        cbBuff += sizeof(HORZ_RULE) - sizeof(CHAR);

    }
    fRet = TRUE;

Exit:
    TCP_REQUIRE( _strURL.Unescape() );

    //
    //  The last send we do async to drive the request to the next
    //  state
    //

    if ( fRet )
    {
        fRet = WriteFile( (CHAR *) pbuff->QueryPtr() + dwChunkOffset,
                          cbBuff,
                          &cbSent,
                          IO_FLAG_ASYNC );

    }

    return fRet;

}

/*******************************************************************

    NAME:       HTTP_REQUEST::CheckDefaultLoad

    SYNOPSIS:   Gets the default load file and builds the URL to
                reprocess.  We also send a redirect to the base
                directory if the URL doesn't end in a '/'

    ENTRY:      strPath - Physical path being searched
                pfHandled - Set to TRUE if the request has been processed
                    (and an async IO completion has been performed)
                pfFinished - Set to TRUE if the no further processing is needed
                    and the next request should be made

    HISTORY:
        Johnl       06-Sep-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::CheckDefaultLoad(
    STR  *         pstrPath,
    BOOL *         pfHandled,
    BOOL *         pfFinished
    )
{
    TS_OPEN_FILE_INFO * pFile;
    DWORD               dwAttr = 0;
    LPSTR               pszArg;
    CHAR                achPort[32];
    STACK_STR(          strNewURL, MAX_PATH );
    STACK_STR(          strDefaultFile, 64 );
    STACK_STR(          strPath, MAX_PATH + 1);
    DWORD               cbBasePath;
    CHAR *              pszTerm = NULL;
    CHAR *              pszFile;

    *pfHandled = FALSE;

    //
    //  Get the default load string
    //

    if ( !strDefaultFile.Copy( *QueryDefaultFiles() ))
    {
        return FALSE;
    }

    //
    //  We know pstrPath is a valid directory at this point
    //

    //
    //  Make sure the URL ended in a slash, if it doesn't,
    //  send a redirect to the name with a slash, otherwise some browsers
    //  don't build their doc relative urls correctly
    //

    if ( *(_strURL.QueryStr() + _strURL.QueryCCH() - 1) != TEXT('/') ||
         _strURL.IsEmpty())
    {
        STACK_STR( strURI, 2 * MAX_PATH );

        if ( !strURI.Resize( _strURL.QueryCB() + MAX_PATH ) ||
             !_strURL.Append( "/", 1 ))
        {
            return FALSE;
        }

        //
        //  We have to fully qualify the URL as Emosaic won't accept
        //  a relative qualification
        //

        strURI.Append( (IsSecurePort() ? "https://" : "http://" ));
        strURI.Append( QueryHostAddr() );

        if ( IsSecurePort() ? (INT) QueryClientConn()->QueryPort()
                != HTTP_SSL_PORT
                : (INT) QueryClientConn()->QueryPort() != 80 )
        {
            strURI.Append( ":", 1 );
            _itoa( (INT) QueryClientConn()->QueryPort(), achPort, 10 );
            strURI.Append( achPort );
        }

        strURI.Append( _strURL );

        DBG_ASSERT( strURI.QueryCB() < strURI.QuerySize() );

        SetState( HTR_DONE, HT_REDIRECT, NO_ERROR );

        if ( !BuildURLMovedResponse( QueryRespBuf(),
                                     &strURI,
                                     HT_REDIRECT,
                                     TRUE ) ||
             !SendHeader( QueryRespBufPtr(),
                          QueryRespBufCB(),
                          IO_FLAG_ASYNC,
                          pfFinished ))
        {
            return FALSE;
        }

        *pfHandled = TRUE;

        return TRUE;
    }

    //
    //  Try and process the default file
    //

    DBG_ASSERT( pstrPath->QueryCB() < MAX_PATH );

    DBG_REQUIRE( strPath.Copy( *pstrPath ));

    if ( *CharPrev( strPath.QueryStr(), strPath.QueryStr() + strPath.QueryCCH() ) != '\\' )
    {
        strPath.Append( '\\' );
    }

    cbBasePath = strPath.QueryCB();

    pszFile = strDefaultFile.QueryStr();

NextFile:

    //
    //  Remember if the file was terminated by a comma
    //

    pszTerm = strchr( pszFile, ',' );

    if ( pszTerm )
    {
        *pszTerm = '\0';
    }

    while ( isspace( (UCHAR)(*pszFile) ))
    {
        pszFile++;
    }

    DBG_REQUIRE( strPath.Append( pszFile ));

    //
    // remove potential args specified in the URL
    //

    if ( ( pszArg = (LPSTR) memchr( strPath.QueryStr(), '?', strPath.QueryCB())) != NULL )
    {
        strPath.SetLen( DIFF(pszArg - strPath.QueryStr()) );
    }

    //
    // before trying to open path, FlipSlashes() since we bypass NT's
    // canonicalization
    //

    FlipSlashes( strPath.QueryStr() + cbBasePath );

    //
    //  Check to see if the file doesn't exist or if there happens to be
    //  a directory with the same name
    //

    if ( !ImpersonateUser() )
    {
        return FALSE;
    }

    pFile = TsCreateFile( QueryW3Instance()->GetTsvcCache(),
                          strPath.QueryStr(),
                          QueryImpersonationHandle(),
                          (_fClearTextPass || _fAnonymous) ? TS_CACHING_DESIRED : 0 );

    RevertUser();

    if ( pFile )
    {
        dwAttr = pFile->QueryAttributes();
        TCP_REQUIRE( TsCloseHandle( QueryW3Instance()->GetTsvcCache(),
                                    pFile ));
    }

    if ( !pFile               ||
         dwAttr == 0xffffffff )
    {
    DWORD dwLastError = GetLastError();
        if ( dwLastError == ERROR_FILE_NOT_FOUND ||
         dwLastError == ERROR_PATH_NOT_FOUND )
        {
            if ( pszTerm )
            {
                strPath.SetLen( cbBasePath );
                pszFile = pszTerm + 1;
                goto NextFile;
            }

            return TRUE;
        }

        return FALSE;
    }

    //
    //  If the file doesn't exist or is a directory, then indicate there
    //  is no default file to load in this directory
    //

    if ( dwAttr & FILE_ATTRIBUTE_DIRECTORY )
    {
        return TRUE;
    }

    *pfHandled = TRUE;

    //
    //  We reprocess the URL as opposed to just sending the default file
    //  so gateways can have a crack.  This is useful if your default.htm
    //  is also an isindex document or a gateway application
    //

    if ( !strNewURL.Copy( _strURL ) ||
         !strNewURL.Append( pszFile ))
    {
        return FALSE;
    }

    IF_DEBUG( PARSING )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[CheckDefaultLoad] Reprocessing %s to %s\n",
                    _strURL.QueryStr(),
                    strNewURL.QueryStr() ));
    }

    CloseGetFile();

    if (_pURIInfo->bIsCached)
    {
        TsCheckInCachedBlob( _pURIInfo );
    } else
    {
        TsFree(QueryW3Instance()->GetTsvcCache(), _pURIInfo );
    }
    _pURIInfo = NULL;

    _pMetaData = NULL;


    //
    // Make sure we add any parameters in the original URL to the default URL, taking
    // into account the fact that the default URL may already have arguments attached to
    // it 
    //
    if ( *QueryURLParams() )
    {
        //
        // If pszArg != NULL, the default URL already has args
        // 
        if ( !strNewURL.Append( ( pszArg ? "&" : "?" ) ) ||
             !strNewURL.Append( QueryURLParams() ) )
        {
            return FALSE;
        }
    }

    if ( !ReprocessURL( strNewURL.QueryStr(),
                        HTV_UNKNOWN ))
    {
        return FALSE;
    }


    return TRUE;
}

/*******************************************************************

    NAME:       InitializeDirBrowsing

    SYNOPSIS:   Reads the registry parameters for directory browsing
                control

    NOTE:       This routine is also safe to call as a server side RPC API

    HISTORY:
        Johnl       12-Sep-1994 Created

********************************************************************/

APIERR
W3_SERVER_INSTANCE::InitializeDirBrowsing(
                        VOID
                        )
{

    if ( !g_fDirFlagsSet ) {

        g_fDirFlagsSet = TRUE;

        if ( !LoadString( GetModuleHandle( W3_MODULE_NAME ),
                          IDS_DIRBROW_TOPARENT,
                          g_achToParentText,
                          sizeof( g_achToParentText )))
        {
            return GetLastError();
        }
    }

    return NO_ERROR;

} // W3_SERVER_INSTANCE::InitializeDirBrowsing


BOOL
AddDirHeaders(
    IN     CHAR *              pszServer,
    IN OUT CHAR *              pszPath,
    IN     BOOL                fModifyPath,
    OUT    CHAR *              pchBuf,
    IN     DWORD               cbBuf,
    OUT    DWORD *             pcbWritten,
    IN     CHAR *              pszToParentText
    )
/*++

Routine Description:

    Provides the initial HTML needed for a directory listing.

Arguments:

    pszServer - Server name
    pszPath - Path portion of URL
    fModifyPath - Set to TRUE if the last segment of the pszPath
        parameter should be removed
    pchBuf - Buffer to place text into
    cbBuf - size of pchBuf
    pcbWritten - Number of bytes written to pchBuf
    pszToParentText - The text to use for the "To Parent"

Returns:

    TRUE if successful, FALSE on error.  Call GetLastError for more info

--*/
{
    DWORD  cch;
    DWORD  cchUrl;
    DWORD  cchServer;
    DWORD  cbNeeded;
    CHAR * pch;
    CHAR * GfrPath = pszPath;
    DWORD  cbInBuf = cbBuf;
    CHAR * pchSlash = NULL;
    CHAR * pch1 = NULL;
    CHAR * pch2 = NULL;
    CHAR   ch2;

    //
    //  Add the HTML document header
    //

    cchServer = strlen( pszServer );
    cchUrl    = strlen( pszPath );

    cbNeeded = sizeof( HTML_DIR_HEADER ) - 1 +
               2 * (cchServer + cchUrl) * sizeof(CHAR);

    if ( cbBuf < cbNeeded )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    cch = wsprintf( pchBuf,
                    HTML_DIR_HEADER,
                    pszServer,
                    pszPath,
                    pszServer,
                    pszPath );

    cbBuf  -= cch;
    pchBuf += cch;

    //
    //  If there's no slash, then we assume we're at the root so we're done
    //

    if ( !strchr( pszPath, '/' ) )
    {
        goto Exit;
    }

    //
    //  If we're not at the root, add a "to parent", but first remove the
    //  last segment of the path
    //

    pch1 = strrchr( pszPath, '/' );

    if ( !pch1 )
    {
        goto Exit;
    }

    //
    //  If the URL ended in a slash, then go to the previous
    //  one and truncate one character after it.
    //

    if ( *(pch1+1) == TEXT('\0') )
    {
        *pch1 = '\0';

        pch2 = strrchr( pszPath, '/' );

        if ( !pch2 )
        {
            goto Exit;
        }
    }
    else
    {
        pch2 = pch1;
        pch1 = NULL;
    }

    ch2   = *(++pch2);
    *pch2 = TEXT('\0');

    //
    //  Do we have enough room in the buffer?
    //

#define HTML_TO_PARENT       "<A HREF=\"%s\">%s</A><br><br>"

     cbNeeded = sizeof( HTML_TO_PARENT ) +
                strlen( pszPath )        +
                strlen( pszToParentText );

     if ( cbBuf < cbNeeded )
     {
         SetLastError( ERROR_INSUFFICIENT_BUFFER );
         return FALSE;
     }

     cch = wsprintf( pchBuf,
                     HTML_TO_PARENT,
                     pszPath,
                     pszToParentText );

    cbBuf  -= cch;
    pchBuf += cch;

Exit:
    *pcbWritten = cbInBuf - cbBuf;

    //
    //  Restore the path if we shouldn't remove the last segment
    //

    if ( !fModifyPath )
    {
        if ( pch1 )
            *pch1 = '/';

        if ( pch2 )
            *pch2 = ch2;
    }

    return TRUE;
}

BOOL FormatDirEntry(
    OUT CHAR *              pchBuf,
    IN  DWORD               cbBuf,
    OUT DWORD *             pcbWritten,
    IN  CHAR *              pchFile,
    IN  CHAR *              pchLink,
    IN  DWORD               dwAttributes,
    IN  LARGE_INTEGER *     pliSize,
    IN  LARGE_INTEGER *     pliLastMod,
    IN  DWORD               fDirBrowseFlags,
    IN  BOOL                bLocalizeDateAndTime
    )
/*++

Routine Description:

    Formats an individual directory entry

Arguments:

    pchBuf - Buffer to place text into
    cbBuf - size of pchBuf
    pcbWritten - Number of bytes written to pchBuf
    pchFile - Display name of directory entry
    pchLink - HTML Anchor for pchFile
    dwAttributes - File attributes
    pliSize - File size, if NULL, then the file size isn't displayed
    pliLastMod - Last modified time
    bLocalizeDateAndTime - TRUE if pliLastMod must be converted to local time

Returns:

    TRUE if successful, FALSE on error.  Call GetLastError for more info

--*/
{
    UINT        cchTime;
    TCHAR       achDate[50];
    TCHAR       achTime[15];
    TCHAR       achSize[30];
    TCHAR       achLink[MAX_PATH * 2 + 1];
    SYSTEMTIME  systime;
    SYSTEMTIME  systimeUTCFile;
    TCHAR *     pch;

    *achDate = *achTime = *achSize = TEXT('\0');

    //
    //  Add optional date and time of this file.  We use the locale
    //  and timezone of the server
    //

    if ( fDirBrowseFlags & (DIRBROW_SHOW_DATE | DIRBROW_SHOW_TIME) &&
         (pliLastMod->HighPart != 0 && pliLastMod->LowPart != 0))
    {
        BOOL fLongDate = (fDirBrowseFlags & DIRBROW_LONG_DATE) != 0;
        LCID lcid;

        if (bLocalizeDateAndTime) {

            FILETIME ftLocal;
            SYSTEMTIME tmpTime;

            if ( !FileTimeToLocalFileTime( (PFILETIME)pliLastMod,
                                           &ftLocal ) ||
                 !FileTimeToSystemTime( &ftLocal, &systime ))
            {
                return(FALSE);
            }

#if 0
            //
            // old way.  not win95 compliant.  behaviour is diff
            // from the one above because this one maintains the
            // active timezone information.
            //

            if ( !FileTimeToSystemTime( (FILETIME *) pliLastMod,
                                         &systimeUTCFile ) ||
                 !SystemTimeToTzSpecificLocalTime( NULL,
                                                   &systimeUTCFile,
                                                   &tmpTime ))
            {
                return FALSE;
            }
#endif
        } else if ( !FileTimeToSystemTime( (FILETIME *) pliLastMod,
                                            &systime )) {
            return FALSE;
        }

        lcid = GetSystemDefaultLCID();

        if ( fDirBrowseFlags & DIRBROW_SHOW_DATE )
        {
            cchTime = GetDateFormat( lcid,
                                     LOCALE_NOUSEROVERRIDE |
                                     (fLongDate ? DATE_LONGDATE :
                                                  DATE_SHORTDATE),
                                     &systime,
                                     NULL,
                                     achDate,
                                     sizeof(achDate) / sizeof(TCHAR));

            PadDirField( achDate,
                         fLongDate ? PAD_LONG_DATE : PAD_SHORT_DATE );
        }

        if ( fDirBrowseFlags & DIRBROW_SHOW_TIME )
        {
            cchTime = GetTimeFormat( lcid,
                                     LOCALE_NOUSEROVERRIDE |
                                     TIME_NOSECONDS,
                                     &systime,
                                     NULL,
                                     achTime,
                                     sizeof(achTime) / sizeof(TCHAR));

            PadDirField( achTime,
                         PAD_TIME );
        }
    }

    //
    //  Add the optional file size
    //

    if ( fDirBrowseFlags & DIRBROW_SHOW_SIZE &&
         pliSize )
    {
        INT pad = PAD_FILESIZE;

        if ( dwAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            strcpy( achSize,
                    "&lt;dir&gt;" );

            //
            //  Need to adjust for using "&lt;" instead of "<"
            //

            pad += 6;
        }
        else
        {
            if ( RtlLargeIntegerToChar( (LARGE_INTEGER *) pliSize,
                                        10,
                                        sizeof(achSize),
                                        achSize ))
            {
                *achSize = '\0';
            }
        }

        PadDirField( achSize,
                     pad );
    }

    //
    //  We have to escape the link name that is used in the URL anchor
    //

    UrlEscape( pchLink,
               achLink,
               sizeof(achLink) );

    //
    //  If the show extension flag is not set, then strip it.  If the
    //  file name begins with a dot, then don't strip it.
    //

    if ( !(fDirBrowseFlags & DIRBROW_SHOW_EXTENSION) )
    {
        pch = (char *) pchFile + strlen( pchFile );

        while ( *pch != '.'  &&
                pch > (pchFile + 1) )
        {
            pch--;
        }

        if ( *pch == '.' )
            *pch = '\0';
    }

    //
    //  Make sure there's enough room at the end of the string for the sprintf
    //

    UINT cbTotal = (strlen( achDate ) +
                    strlen( achTime ) +
                    strlen( achSize ) +
                    strlen( achLink ) +
                    strlen( pchFile )) * sizeof(TCHAR) +
                    sizeof( TEXT( DIR_FORMAT_STR ) );

    if ( cbTotal > cbBuf )
    {
        //
        //  Note we will lose this directory entry if we fail here
        //

        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    *pcbWritten = wsprintf( pchBuf,
                            DIR_FORMAT_STR,
                            achDate,
                            achTime,
                            achSize,
                            achLink,    // Escaped link
                            pchFile );  // Unescaped file name

    return TRUE;
}

/*******************************************************************

    NAME:       PadDirField

    SYNOPSIS:   Right Justifies and pads the passed string and appends
                a column spacing

    ENTRY:      pch - String to pad
                pad - Size of field to pad to

    HISTORY:
        Johnl       12-Sep-1994 Created

********************************************************************/

VOID PadDirField( TCHAR * pch,
                  INT    pad )
{
    INT   cch ;
    INT   diff;
    INT   i;

    cch = strlen( pch );

    if ( cch > pad )
        pad = cch;

    diff = pad-cch;

    //
    //  Insert spaces in front of the text to pad it out
    //

    memmove( pch + diff, pch, (cch + 1) * sizeof(TCHAR) );

    for ( i = 0; i < diff; i++, pch++ )
        *pch = TEXT(' ');

    //
    //  Append a column spacer at the end
    //

    pch += cch;

    for ( i = 0; i < PAD_COL_SPACING; i++, pch++ )
        *pch = TEXT(' ');

    *pch = TEXT('\0');
}

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//

#define HEXDIGIT( nDigit )                              \
    (TCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')

//
//  Converts a single hex digit to its decimal equivalent
//

#define TOHEX( ch )                                     \
    ((ch) > '9' ?                                       \
        (ch) >= 'a' ?                                   \
            (ch) - 'a' + 10 :                           \
            (ch) - 'A' + 10                             \
        : (ch) - '0')



BOOL
UrlEscape( CHAR * pchSrc,
           CHAR * pchDest,
           DWORD  cbDest
           )
/*++

Routine Description:

    Replaces all "bad" characters with their ascii hex equivalent

Arguments:

    pchSrc - Source string
    pchDest - Receives source with replaced hex equivalents
    cbDest - Size of pchDest

Returns:

    TRUE if all characters converted, FALSE if the destination buffer is too
    small

--*/
{
    CHAR    ch;
    DWORD   cbSrc;

    cbSrc = strlen( pchSrc ) + 1;

    *pchDest = '\0';

    if ( cbSrc > cbDest )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    while ( ch = *pchSrc++ )
    {
        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( (((ch >= 0)   && (ch <= 32)) ||
              ((ch >= 128) && (ch <= 159))||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&') ||
              (ch == '#')) &&
             !(ch == TEXT('\n') || ch == TEXT('\r'))  )
        {
            if ( cbDest < cbSrc + 2 )
            {
                strcpy( pchDest, pchSrc );
                return FALSE;
            }

            //
            //  Insert the escape character
            //

            pchDest[0] = TEXT('%');

            //
            //  Convert the low then the high character to hex
            //

            UINT nDigit = (UINT)(ch % 16);

            pchDest[2] = HEXDIGIT( nDigit );

            ch /= 16;
            nDigit = (UINT)(ch % 16);

            pchDest[1] = HEXDIGIT( nDigit );

            pchDest += 3;
            cbDest  -= 3;
        }
        else
        {
            *pchDest++ = ch;
            cbDest++;
        }

        cbSrc++;
    }

    *pchDest = '\0';

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\deadcode.cxx ===
#if 0

    //
    // LICENSING code
    //

    //
    // globals.cxx
    //

//
//  The number of licenses allowed concurrently
//

DWORD            g_cMaxLicenses = 0xffffffff;


    //
    //  Get the license from the registry
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        W3_LICENSE_KEY,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey );

    if ( !err )
    {
        BOOL fConcurrentMode;

        //
        //  Per-Seat mode requires client side licenses so the server is
        //  unlimited.  For concurrent mode, check the concurrent limit.
        //

        fConcurrentMode = ReadRegistryDword( hkey,
                                             "Mode",
                                             FALSE );

        if ( fConcurrentMode )
        {
            g_cMaxLicenses = ReadRegistryDword( hkey,
                                                "ConcurrentLimit",
                                                0xffffffff );
        }

        TCP_REQUIRE( !RegCloseKey( hkey ));

        //
        //  If a license limit is specified, multiply it by four to account
        //  for the simultaneous connections most browsers use
        //

        if ( g_cMaxLicenses != 0xffffffff )
        {
            g_cMaxLicenses *= 4;
        }
    }


    //
    // connect.cxx
    //

inline
VOID
LogLicenseExceededWarning(
    VOID
    )
{
    //
    //  Make sure we only log one event in the event log
    //

    if ( !InterlockedExchange( &fLicenseExceededWarning, TRUE ))
    {
        g_pInetSvc->LogEvent( W3_EVENT_LICENSES_EXCEEDED,
                               0,
                               (WCHAR **) NULL,
                               NO_ERROR );
    }
}

    //
    // make sure we don't exceed license
    //

    else if ( cConnectedUsers >= g_cMaxLicenses )
    {
        LogLicenseExceededWarning();
        SendError( sNew, IDS_OUT_OF_LICENSES );
        goto error_exit;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\filtinit.cxx ===
/*++


Copyright (c) 1996  Microsoft Corporation

Module Name:

    filtinit.cxx

Abstract:

    This module contains the Microsoft HTTP server filter module for stuff that
    has to do with filter initialization, loading and unloading.

Author:

    John Ludeman (johnl)   06-Aug-1996

Revision History:

--*/

#include "w3p.hxx"

//
//  If the request doesn't specify an entry point, default to using
//  this
//

#define SF_DEFAULT_ENTRY    "HttpFilterProc"
#define SF_VERSION_ENTRY    "GetFilterVersion"
#define SF_TERM_ENTRY       "TerminateFilter"

//
//  Name of the value under the parameters key containing the list of
//  filter dlls.  This was the value for IIS 1.0 and 2.0.  Global filters
//  can still be specified under this key.
//

#define HTTP_FILTER_DLLS    "Filter DLLs"

//
//  Globals
//

static BOOL        g_fInitialized = FALSE;
LIST_ENTRY         g_FilterHead;                // List of filter DLLs
CRITICAL_SECTION   g_csFilterDlls;


//
//  Prototypes
//

BOOL
UpdateInstanceFilters(
    IN const CHAR *         pszNewDll,
    IN const CHAR *         pszOldDll,
    IN W3_SERVER_INSTANCE * pInst
    );


BOOL 
AdjustInstanceFilterListFlags( IN PVOID pvContext1,
                               IN PVOID pvContext2,
                               IN IIS_SERVER_INSTANCE *pInstance );


FILTER_LIST *
InitializeFilters(
    BOOL *           pfAnySecureFilters,
    W3_IIS_SERVICE * pSvc
    )
/*++

Routine Description:

    Loads the global filter DLLs and their corresponding entry point.  Note the
    global filter list does not allow unloads.

    g_fInitialized should only be set after all of the global filters are
    loaded.

Arguments:

    pfAnySecureFilters - Set to TRUE if there are any secure filters
    pSvc - Pointer to service global.  The global service pointer isn't
        initialized yet so we pass it in for global filter initialization.
        Only used for logging events.

Return Value:

    Global filter list or NULL if an error occurred

--*/
{
    CHAR          szFilterKey[MAX_PATH+1];
    FILTER_LIST * pfl;
    DWORD         cb;
    CHAR          szLoadOrder[1024];
    CHAR          szDllName[MAX_PATH+1];
    CHAR *        pchFilter;
    CHAR *        pchComma;
    MB            mb( (IMDCOM*) pSvc->QueryMDObject() );
    DWORD         fEnabled;
    DWORD         cFilters;
    HKEY          hkeyParam = NULL;
    DWORD         err = NO_ERROR;
    BOOL          fOpened;

    INITIALIZE_CRITICAL_SECTION( &g_csFilterDlls );
    InitializeListHead( &g_FilterHead );

    strcpy( szFilterKey, IIS_MD_LOCAL_MACHINE_PATH "/" W3_SERVICE_NAME_A );
    strcat( szFilterKey, IIS_MD_ISAPI_FILTERS );
    DBG_ASSERT( strlen( szFilterKey ) + 1 < sizeof( szFilterKey ));

    pfl = new FILTER_LIST();

    if ( !pfl ) {

        return NULL;
    }

    //
    // Loop through filter keys, if we can't access the metabase, we assume
    // success and continue
    //

    if ( !mb.Open( szFilterKey,
                   METADATA_PERMISSION_READ ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[InitializeFilterList] Cannot open path %s, error %lu\n",
                    szFilterKey, GetLastError() ));
        return pfl;
    }
    fOpened = TRUE;

    //
    //  Get the filter load order
    //

    cb = sizeof( szLoadOrder );
    *szLoadOrder = '\0';

    if ( !mb.GetString( "",
                        MD_FILTER_LOAD_ORDER,
                        IIS_MD_UT_SERVER,
                        szLoadOrder,
                        &cb,
                        0 ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[InitializeFilterList] Cannot load filter load order, error %lu\n",
                    szFilterKey, GetLastError() ));
        delete pfl;
        return NULL;
    }

    pchFilter = szLoadOrder;

    while ( *pchFilter )
    {
        if ( !fOpened &&
             !mb.Open( szFilterKey,
                       METADATA_PERMISSION_READ ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[InitializeFilterList] Cannot open path %s, error %lu\n",
                        szFilterKey, GetLastError() ));
            break;
        }
        fOpened = TRUE;

        pchComma = strchr( pchFilter, ',' );

        if ( pchComma )
        {
            *pchComma = '\0';
        }

        while ( ISWHITEA( *pchFilter ))
        {
            pchFilter++;
        }

        fEnabled = TRUE;
        mb.GetDword( pchFilter,
                     MD_FILTER_ENABLED,
                     IIS_MD_UT_SERVER,
                     &fEnabled );

        if ( fEnabled )
        {
            cb = sizeof(szDllName);
            if ( mb.GetString( pchFilter,
                               MD_FILTER_IMAGE_PATH,
                               IIS_MD_UT_SERVER,
                               szDllName,
                               &cb,
                               0 ))
            {
                mb.Close();
                fOpened = FALSE;

                if ( pfl->LoadFilter( &mb, szFilterKey, &fOpened, pchFilter, szDllName, TRUE, pSvc ))
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "[InitializeFilterList] Loaded %s\n",
                                szDllName ));
                }
            }
        }
        
        if ( pchComma )
        {
            pchFilter = pchComma + 1;
        }
        else
        {
            break;
        }
    }

    //
    //  Now load any filters that have been added in the registry for
    //  downlevel compatibility
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        W3_PARAMETERS_KEY,
                        0,
                        KEY_READ,
                        &hkeyParam );

    if( err == NO_ERROR )
    {
        TCHAR *            psz;
        TCHAR *            pszFilterList = NULL;

        if ( ReadRegString( hkeyParam,
                            &pszFilterList,
                            HTTP_FILTER_DLLS,
                            "" ))
        {
            RegCloseKey( hkeyParam );

            psz = pszFilterList;

            //
            //  Parse the comma separated list of dlls
            //

            INET_PARSER Parser( pszFilterList );
            Parser.SetListMode( TRUE );

            while ( *(psz = Parser.QueryToken()) )
            {
                if ( pfl->LoadFilter( NULL, NULL, &fOpened, psz, psz, TRUE, pSvc ))
                {
                    const CHAR * apszSubString[1];

                    DBGPRINTF(( DBG_CONTEXT,
                        "[InitializeFilterList] Loaded %s\n",
                        psz ));

                    apszSubString[0] = psz;

                    //
                    //  Log a warning here if we picked up a filter from the
                    //  registry
                    //

                    pSvc->LogEvent( W3_MSG_LOADED_FILTER_FROM_REG,
                                    1,
                                    apszSubString,
                                    NO_ERROR );
                }

                Parser.NextItem();
            }

            Parser.RestoreBuffer();

            TCP_FREE( pszFilterList );
        }
        else
        {
            RegCloseKey( hkeyParam );
        }
    }

    *pfAnySecureFilters = CheckForSecurityFilter( pfl );

    g_fInitialized = TRUE;

    return pfl;
}


VOID
TerminateFilters(
    VOID
    )
/*++

Routine Description:

    Unloads any filter DLLs and their corresponding entry point

--*/
{
    LIST_ENTRY      * pEntry;
    HTTP_FILTER_DLL * pFilterDll;

    if ( g_fInitialized )
    {
        EnterCriticalSection( &g_csFilterDlls );

        for ( pEntry  = g_FilterHead.Flink;
              pEntry != &g_FilterHead;
              pEntry  = g_FilterHead.Flink)
        {
            pFilterDll = CONTAINING_RECORD( pEntry, HTTP_FILTER_DLL, ListEntry );

            RemoveEntryList( pEntry );

            //
            //  This should delete the filter dll
            //

            DBGPRINTF(( DBG_CONTEXT,
                        "[TerminateFilters] Filter %s, ref count %d\n",
                        pFilterDll->QueryName(),
                        pFilterDll->QueryRef() ));

//            DBG_ASSERT( pFilterDll->QueryRef() == 1 );

            HTTP_FILTER_DLL::Dereference( pFilterDll );
        }

        LeaveCriticalSection( &g_csFilterDlls );
        DeleteCriticalSection( &g_csFilterDlls );
    }
}

HTTP_FILTER_DLL *
CheckoutFilterDll(
    IN const CHAR * pszFilterDll
    )
/*++

Routine Description:

    Checks to see if an existing filter dll is already loaded and ups the ref
    count if it is

    NOTE: THE FILTER LIST LOCK MUST BE TAKEN PRIOR TO CALLING THIS FUNCTION

Arguments:

    pszFilterDLL - Fully qualified path to filter dll to load

Return Value:

    Pointer to the filter if it's already loaded, NULL if the filter isn't
    loaded

--*/
{
    LIST_ENTRY * pEntry;
    HTTP_FILTER_DLL * pFilterDll;

    for ( pEntry = g_FilterHead.Flink;
          pEntry != &g_FilterHead;
          pEntry = pEntry->Flink )
    {
        pFilterDll = CONTAINING_RECORD( pEntry, HTTP_FILTER_DLL, ListEntry );

        DBG_ASSERT( pFilterDll->CheckSignature() );

        if ( !lstrcmpi( pFilterDll->QueryName(), pszFilterDll ))
        {
            pFilterDll->Reference();
            return pFilterDll;
        }
    }

    return NULL;
}

BOOL
HTTP_FILTER_DLL::LoadDll(
    MB *         pmb OPTIONAL,
    const CHAR * pszKeyName,
    LPBOOL       pfOpened,
    const CHAR * pszRelFilterPath,
    const CHAR * pszFilterDll
    )
/*++

Routine Description:

    Loads the specified dll

Arguments:

    pmb - Open metabase to /filters key
    pszKeyName - metabase filters key name
    pfOpened - updated with TRUE if pmb opened on return
    pszFilterDll - Fully qualified name of filter to load

    THE GLOBAL FILTER LIST LOCK MUST BE TAKEN PRIOR TO CALLING THIS METHOD

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    HTTP_FILTER_VERSION ver;

    if ( !m_strName.Copy( pszFilterDll ))
    {
        return FALSE;
    }

    //
    //  Load it and put it in the list, note the filter list lock
    //  is still taken
    //

    m_hmod = LoadLibraryEx( pszFilterDll,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH );

    if ( g_fIsWindows95 &&
         (m_hmod == NULL) &&
         (GetLastError() == ERROR_FILE_NOT_FOUND) ) {

        //
        // According to vlads: the behaviour of flags used in loadlibraryex
        // is different between chicago and NT.  This caused a problem
        // loading frontpage filters.
        //

        m_hmod = LoadLibrary( pszFilterDll);
    }

    if ( !m_hmod )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[LoadDll] LoadLibrary failed with error %d\n",
                    GetLastError()));

        goto ErrorExit;
    }

    //
    //  Retrieve the entry point
    //

    m_pfnSFVer  = (PFN_SF_VER_PROC) GetProcAddress( m_hmod,
                                                    SF_VERSION_ENTRY );
    m_pfnSFProc = (PFN_SF_DLL_PROC) GetProcAddress( m_hmod,
                                                    SF_DEFAULT_ENTRY );
    m_pfnSFTerm = (PFN_SF_TERM_PROC) GetProcAddress( m_hmod,
                                                    SF_TERM_ENTRY );


    if ( !m_pfnSFProc || !m_pfnSFVer )
    {
        //
        //  Don't call the terminator if we didn't call the initializer
        //

        m_pfnSFTerm = NULL;
        goto ErrorExit;
    }

    ver.dwServerFilterVersion = HTTP_FILTER_REVISION;

    //
    //  Call the version entry point and get the filter capabilities
    //

    if ( !m_pfnSFVer( &ver ) )
    {
        goto ErrorExit;
    }

    if ( pmb &&
         (*pfOpened ||
          pmb->Open( pszKeyName, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE )) )
    {
        *pfOpened = TRUE;

        if ( !pmb->SetString( pszRelFilterPath,
                              MD_FILTER_DESCRIPTION,
                              IIS_MD_UT_SERVER,
                              ver.lpszFilterDesc,
                              0 ) ||
             !pmb->SetDword( pszRelFilterPath,
                             MD_FILTER_FLAGS,
                             IIS_MD_UT_SERVER,
                             ver.dwFlags,
                             0 ))
        {
            goto ErrorExit;
        }
    }

    //
    //  If the client didn't specify any of the secure port notifications,
    //  supply them with the default of both
    //

    if ( !(ver.dwFlags & (SF_NOTIFY_SECURE_PORT | SF_NOTIFY_NONSECURE_PORT)))
    {
        ver.dwFlags |= (SF_NOTIFY_SECURE_PORT | SF_NOTIFY_NONSECURE_PORT);
    }

    m_dwVersion      = ver.dwFilterVersion;
    m_dwFlags        = (ver.dwFlags & SF_NOTIFY_NONSECURE_PORT) ? ver.dwFlags : 0;
    m_dwSecureFlags  = (ver.dwFlags & SF_NOTIFY_SECURE_PORT) ? ver.dwFlags : 0;

    //
    //  Put the new dll on the filter dll list
    //

    InsertHeadList( &g_FilterHead, &ListEntry );

    return TRUE;

ErrorExit:

    return FALSE;
}

BOOL
HTTP_FILTER_DLL::Unload(
    const CHAR * pszDll
    )
/*++

Routine Description:

    Finds the existing DLL and sets it up to be unloaded

Arguments:

    pszDLL - Fully qualified path to filter dll to load

Return Value:

    TRUE if the filter DLL was found, FALSE if it wasn't found or it's already
    marked for deletion

--*/
{
    LIST_ENTRY * pEntry;
    HTTP_FILTER_DLL * pFilterDll;

    EnterCriticalSection( &g_csFilterDlls );

    for ( pEntry = g_FilterHead.Flink;
          pEntry != &g_FilterHead;
          pEntry = pEntry->Flink )
    {
        pFilterDll = CONTAINING_RECORD( pEntry, HTTP_FILTER_DLL, ListEntry );

        DBG_ASSERT( pFilterDll->CheckSignature() );

        if ( !lstrcmpi( pFilterDll->QueryName(), pszDll ))
        {
            RemoveEntryList( pEntry );

            LeaveCriticalSection( &g_csFilterDlls );
            return TRUE;
        }
    }

    LeaveCriticalSection( &g_csFilterDlls );

    return FALSE;
}

BOOL
FILTER_LIST::LoadFilter(
    MB *             pmb,
    LPSTR            pszKeyName,
    LPBOOL           pfOpened,
    const CHAR *     pszRelativeMBPath,
    const CHAR *     pszFilterDll,
    BOOL             fAllowRawRead,
    W3_IIS_SERVICE * pSvc
    )
/*++

Routine Description:

    Loads the specified filter into this filter list.  Note the filter dll's
    ref count starts at one for being on the g_FilterHead list.  Thus if the
    refcount drops to one, no filter list is using the filter dll and it can
    be deleted.

Arguments:

    pmb - metabase open at the filter root, opened for Read/Write
    pszKeyName - Metabase open path for filters key
    pfOpened - TRUE if pmb currently opened, otherwise FALSE
               must be set before calling this function, which will 
               update it.
    pszRelativeMBPath - Metabase path to this filter dll
    pszFilterDll - Fully qualified name of filter to load
    fAllowRawRead - Set to TRUE if raw read filters are allowed
    pSvc - Optional service pointer for logging

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    HTTP_FILTER_VERSION  ver;
    HTTP_FILTER_DLL *    pFilterDll;
    DWORD                i;

    //
    //  pSvc will only be passed during InitializeFilters
    //

    if ( !pSvc )
    {
        pSvc = (W3_IIS_SERVICE *) g_pInetSvc;
    }

    //
    //  Make sure there's a free entry in the filter list array, and
    //  the secure/non-secure notification arrays (the latter two are used
    //  in conjunction with filters disabling themselves per request
    //

    if ( (m_cFilters+1) > (m_buffFilterArray.QuerySize() / sizeof(PVOID)))
    {
        if ( !m_buffFilterArray.Resize( (m_cFilters + 5) * sizeof(PVOID)) )
        {
            return FALSE;
        }

        if ( !m_buffSecureArray.Resize( (m_cFilters + 5) * sizeof(DWORD)) )
        {
            return FALSE;
        }

        if ( !m_buffNonSecureArray.Resize( (m_cFilters + 5) * sizeof(DWORD)) )
        {
            return FALSE;
        }
    }

    //
    //  Load the filter DLL
    //

    EnterCriticalSection( &g_csFilterDlls );

    if ( !(pFilterDll = CheckoutFilterDll( pszFilterDll )))
    {
        pFilterDll = new HTTP_FILTER_DLL;

        if ( !pFilterDll ||
             !pFilterDll->LoadDll( pmb,
                                   pszKeyName,
                                   pfOpened,
                                   pszRelativeMBPath,
                                   pszFilterDll ) )
        {
            const CHAR * apszSubString[1];
            DWORD err = GetLastError();

            LeaveCriticalSection( &g_csFilterDlls );
            delete pFilterDll;

            apszSubString[0] = pszFilterDll;

            if ( err )
            {
                //
                //  Log a warning here if the filter supplied an error code
                //

                pSvc->LogEvent( W3_EVENT_FILTER_DLL_LOAD_FAILED,
                                1,
                                apszSubString,
                                err );
            }

            DBGPRINTF(( DBG_CONTEXT,
                       "Cannot load filter dll (err = %d)\n",
                        err));

            if ( pmb &&
                 (*pfOpened ||
                   pmb->Open( pszKeyName, METADATA_PERMISSION_READ |
                                          METADATA_PERMISSION_WRITE )) )
            {
                *pfOpened = TRUE;

                pmb->SetDword( pszRelativeMBPath,
                               MD_WIN32_ERROR,
                               IIS_MD_UT_SERVER,
                               err,
                               0 );
                pmb->SetDword( pszRelativeMBPath,
                               MD_FILTER_STATE,
                               IIS_MD_UT_SERVER,
                               MD_FILTER_STATE_UNLOADED,
                               0 );
            }

            return FALSE;
        }

        //
        //  This filter list now officially owns a reference to this filter dll
        //

        pFilterDll->Reference();
    }

    //
    //  Not a fatal error if the status doesn't get updated
    //

    DBG_ASSERT( pFilterDll != NULL );
    
    if ( pmb &&
         (*pfOpened ||
         pmb->Open( pszKeyName, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE )) )
    {
        *pfOpened = TRUE;

        if ( !pmb->SetDword( pszRelativeMBPath,
                             MD_WIN32_ERROR,
                             IIS_MD_UT_SERVER,
                             NO_ERROR,
                             0 ) ||
             !pmb->SetDword( pszRelativeMBPath,
                             MD_FILTER_STATE,
                             IIS_MD_UT_SERVER,
                             MD_FILTER_STATE_LOADED,
                             0 ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error %d setting filter status\n",
                        GetLastError() ));
        }
    }

    //
    //  Disallow any per-instance read raw filters
    //

    if ( !fAllowRawRead &&
         (pFilterDll->QueryNotificationFlags() & SF_NOTIFY_READ_RAW_DATA) )
    {
        const CHAR * apszSubString[1];

        apszSubString[0] = pszFilterDll;

        pSvc->LogEvent( W3_MSG_READ_RAW_MUST_BE_GLOBAL,
                        1,
                        apszSubString,
                        0 );

        DBGPRINTF(( DBG_CONTEXT,
                   "Refusing READ_RAW filter on server instance (%s)\n",
                    pszFilterDll));

        if ( pmb &&
             (*pfOpened ||
              pmb->Open( pszKeyName, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE )) )
        {
            *pfOpened = TRUE;

            if ( !pmb->SetDword( pszRelativeMBPath,
                                 MD_WIN32_ERROR,
                                 IIS_MD_UT_SERVER,
                                 ERROR_INVALID_PARAMETER,
                                 0 ) ||
                 !pmb->SetDword( pszRelativeMBPath,
                                 MD_FILTER_STATE,
                                 IIS_MD_UT_SERVER,
                                 MD_FILTER_STATE_UNLOADED,
                                 0 ))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error %d setting filter status\n",
                            GetLastError() ));
            }
        }

        //
        //  Undo the ref for being on this filter list
        //

        HTTP_FILTER_DLL::Dereference( pFilterDll );

        //
        //  If nobody else is using this filter dll, then go ahead and force
        //  an unload.  The filter dll can't be checked out with the filter
        //  critical section held so this is a safe operation.
        //

        if ( pFilterDll->QueryRef() == 1 )
        {
            RemoveEntryList( &pFilterDll->ListEntry );
            HTTP_FILTER_DLL::Dereference( pFilterDll );
        }

        LeaveCriticalSection( &g_csFilterDlls );

        return FALSE;

    }

    //
    //  Find where pFilterDll goes in the list
    //

    for ( i = 0; i < m_cFilters; i++ )
    {
        if ( (QueryDll(i)->QueryNotificationFlags() & SF_NOTIFY_ORDER_MASK)
           <  (pFilterDll->QueryNotificationFlags() & SF_NOTIFY_ORDER_MASK) )
        {
            break;
        }
    }

    //
    //  And insert it into the array
    //

    memmove( (PVOID *) m_buffFilterArray.QueryPtr() + i + 1,
             (PVOID *) m_buffFilterArray.QueryPtr() + i,
             (m_cFilters - i) * sizeof(PVOID) );

    (((HTTP_FILTER_DLL * *) (m_buffFilterArray.QueryPtr())))[i] = pFilterDll;

    //
    //  Add notification DWORDS to secure/non-secure arrays
    //

    memmove( (DWORD *) m_buffSecureArray.QueryPtr() + i + 1,
             (DWORD *) m_buffSecureArray.QueryPtr() + i,
             (m_cFilters - i) * sizeof(DWORD) );

    ((DWORD*) m_buffSecureArray.QueryPtr())[i] = pFilterDll->QuerySecureFlags();

    memmove( (DWORD *) m_buffNonSecureArray.QueryPtr() + i + 1,
             (DWORD *) m_buffNonSecureArray.QueryPtr() + i,
             (m_cFilters - i) * sizeof(DWORD) );

    ((DWORD*) m_buffNonSecureArray.QueryPtr())[i] = pFilterDll->QueryNonsecureFlags();

    m_cFilters++;

    //
    //  Segregate the secure and non-secure port notifications
    //

    m_SecureNotifications |= pFilterDll->QuerySecureFlags();
    m_NonSecureNotifications |= pFilterDll->QueryNonsecureFlags();

    LeaveCriticalSection( &g_csFilterDlls );
    return TRUE;
}

#if 0
BOOL
FILTER_LIST::Copy(
    IN FILTER_LIST * pClone
    )
/*++

Routine Description:

    Clones the passed filter list

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    DWORD i;

    DBG_ASSERT( pClone->CheckSignature() );
    DBG_ASSERT( CheckSignature() );

    //
    //  Walk the list to be cloned and load all of the dlls
    //

    EnterCriticalSection( &g_csFilterDlls );

    for ( i = 0; i < pClone->QueryFilterCount(); i++ )
    {
        if ( !LoadFilter( pClone->QueryDll( i )->QueryName(),
                          FALSE ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[FILTER_LIST::Copy] Failed loading %s, error %d\n",
                        pClone->QueryDll( i )->QueryName(),
                        GetLastError() ));
        }
    }

    LeaveCriticalSection( &g_csFilterDlls );

    return TRUE;
}

BOOL
ReplaceFilterDll(
    IN const CHAR * pszNewDll,
    IN const CHAR * pszOldDll
    )
/*++

Routine Description:

    Given a new filter and an old filter, this function renames the old filter
    dll to a temporary name, copies the new .dll into place then walks the
    instance list and replaces all occurrences of the old .dll with the
    new .dll.

Arguments:

    pszNewDll - New filter dll
    pszOldDll - Existing filter dll that should be replaced

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    CHAR         achTmp[MAX_PATH + 1];
    CHAR *       pszTmp;
    DWORD        cVer = 1;
    CHAR         achVer[32];
    const CHAR * apsz[3];

    apsz[0] = pszOldDll;
    apsz[1] = pszNewDll;

    g_pInetSvc->LogEvent( W3_MSG_REP_FILTER,
                          2,
                          apsz,
                          0 );

    //
    //  Find a back up name - this just appends a number onto the dll
    //

    strcpy( achTmp, pszOldDll );
    pszTmp = achTmp + strlen( pszOldDll );

    while ( TRUE )
    {
        _itoa( cVer, achVer, 10 );
        strcpy( pszTmp, achVer );

        if ( GetFileAttributes( achTmp ) != 0xffffffff ||
             GetLastError() != ERROR_FILE_NOT_FOUND )
        {
            cVer++;

            //
            //  If we've tried a reasonable number of backups and we couldn't
            //  find a candidate then get out
            //

            if ( cVer > 8192 )
            {
                SetLastError( ERROR_FILE_NOT_FOUND );
                return FALSE;
            }

            continue;
        }


        //
        //  Rename the old DLL to the new dll name
        //

        if ( !MoveFileEx( pszOldDll,
                          achTmp,
                          MOVEFILE_WRITE_THROUGH | MOVEFILE_COPY_ALLOWED ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[ReplaceFilterDll] Move old file failed, %s -> %s, error %d\n",
                        pszOldDll,
                        achTmp,
                        GetLastError() ));

            if ( GetLastError() == ERROR_FILE_EXISTS )
            {
                cVer++;
                continue;
            }

            apsz[0] = pszOldDll;
            apsz[1] = pszNewDll;

            g_pInetSvc->LogEvent( W3_MSG_REP_FILTER,
                                  2,
                                  apsz,
                                  GetLastError() );

            return FALSE;
        }

        break;
    }

    //
    //  Rename the new DLL name to the old dll
    //

    if ( !MoveFileEx( pszNewDll,
                      pszOldDll,
                      MOVEFILE_WRITE_THROUGH | MOVEFILE_COPY_ALLOWED ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[ReplaceFilterDll] Move new file failed, %s -> %s, error %d\n",
                    pszNewDll,
                    pszOldDll,
                    GetLastError() ));

        apsz[0] = pszNewDll;
        apsz[1] = pszOldDll;

        g_pInetSvc->LogEvent( W3_MSG_REP_FILTER_FAILED,
                              2,
                              apsz,
                              0 );

        if ( !MoveFileEx( achTmp,
                          pszOldDll,
                          MOVEFILE_WRITE_THROUGH | MOVEFILE_COPY_ALLOWED ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                         "[ReplaceFilterDll] Move tmp to old file failed, %s -> %s, error %d\n",
                         achTmp,
                         pszOldDll,
                         GetLastError() ));

            apsz[0] = achTmp;
            apsz[1] = pszOldDll;

            g_pInetSvc->LogEvent( W3_MSG_REP_FILTER_FAILED,
                                  2,
                                  apsz,
                                  0 );
        }

        return FALSE;
    }

    //
    //  Update all of the instance filters
    //

    if ( !g_pInetSvc->EnumServiceInstances(
                                  (PVOID) pszNewDll,
                                  (PVOID) pszOldDll,
                                  (PFN_INSTANCE_ENUM) UpdateInstanceFilters ))
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
UpdateInstanceFilters(
    IN const CHAR *         pszNewDll,
    IN const CHAR *         pszOldDll,
    IN W3_SERVER_INSTANCE * pInst
    )
/*++

Routine Description:

    This is a simple utility function that handles the instance callbacks

Arguments:

    pszNewDll - New filter dll
    pszOldDll - Existing filter dll that should be replaced
    pInst - The instance the change is being applied to

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
#if 0
    if ( !pInst->UpdateFilterList( pszNewDll,
                                   pszOldDll ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                     "[UpdateInstanceFilters] Failed with error %d\n",
                     GetLastError() ));
        return FALSE;
    }
#endif
    return TRUE;
}
#endif


BOOL
FILTER_LIST::InsertGlobalFilters(
    VOID
    )
/*++

Routine Description:

    Transfers all of the global filters to the per-instance filter list

    Note: This method assumes the server filter list is not dynamic

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    DWORD               i;
    HTTP_FILTER_DLL *   pFilterDll;
    BOOL                fOpened;

    for ( i = 0; i < GLOBAL_FILTER_LIST()->QueryFilterCount(); i++ )
    {
        //
        //  Ignore the return code, an event gets logged in LoadFilter()
        //  We allow raw read filters here as we're just duplicating the
        //  global filter list
        //

        LoadFilter( NULL, NULL, &fOpened, "", GLOBAL_FILTER_LIST()->QueryDll( i )->QueryName(), TRUE );
    }

    return TRUE;
}

BOOL
CheckForSecurityFilter(
    FILTER_LIST * pFilterList
    )
/*++

Routine Description:

    Checks to see if there are any global filters that are encryption filters

Return Value:

    TRUE if an encryption filter was found, FALSE otherwise

--*/
{
    DWORD             i;
    HTTP_FILTER_DLL * pFilterDll;
    BOOL              fRet = FALSE;

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDll = pFilterList->QueryDll( i );

        //
        //  port notification, assume he's an encryption filter
        //

#define SECURE_FILTER   (SF_NOTIFY_SECURE_PORT   | \
                         SF_NOTIFY_READ_RAW_DATA | \
                         SF_NOTIFY_SEND_RAW_DATA | \
                         SF_NOTIFY_ORDER_HIGH)

        if ( (pFilterDll->QueryNotificationFlags() & SECURE_FILTER) ==
             SECURE_FILTER)
        {
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

BOOL
AdjustFilterFlags( 
    PVOID           pfnSFProc,
    DWORD           dwNewFlags 
    )
/*++

Routine Description:

    Private exported routine that allows a filter to dynamically adjust its
    notification flags.  This can only be done for global filters.

Return Value:

    TRUE on success, FALSE on failure
    
--*/
{
    W3_IIS_SERVICE *    pSvc = (W3_IIS_SERVICE *) g_pInetSvc;
    FILTER_LIST *       pFilterList;
    HTTP_FILTER_DLL  *  pFilterDll;
    DWORD               i;
    BOOL                fFoundSvcDLL = FALSE;
    BOOL                fFoundInstanceDLL = FALSE;

    //
    //  Can't adjust priority, just notification flags
    //
    
    if ( dwNewFlags & SF_NOTIFY_ORDER_MASK )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pFilterList = pSvc->QueryGlobalFilterList();

    if ( !pFilterList )
    {
        //
        //  Shouldn't happen but you never know
        //

        return TRUE;
    }
    
    //
    // Try to find the appropriate DLL in the single global per-service filter list
    // 
    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        DBG_ASSERT( pFilterList->QueryDll(i)->CheckSignature() );
        
        if ( pFilterList->QueryDll(i)->QueryEntryPoint() == pfnSFProc )
        {
            pFilterDll = pFilterList->QueryDll(i);
            
            //
            //  We've found the matching filter dll, adjust the flags in the
            //  filter dll object then adjust the flags in the filter list
            //

            pFilterDll->SetNotificationFlags( dwNewFlags );
            pFilterList->SetNotificationFlags( i, pFilterDll );

            fFoundSvcDLL = TRUE;
        }
    }

    if ( fFoundSvcDLL )
    {
        //
        // Try to update the flags in each of the per-instance filter lists
        //
        if ( pSvc )
        {
            if ( pSvc->EnumServiceInstances( (PVOID) &dwNewFlags,
                                             (PVOID) pfnSFProc,
                                             AdjustInstanceFilterListFlags ) )
            {
                fFoundInstanceDLL = TRUE;
            }
        }
    }

    if ( !( fFoundInstanceDLL && fFoundSvcDLL ) )
    {
        SetLastError( ERROR_FILE_NOT_FOUND );
        return FALSE;
    }
    
    return TRUE;
}



BOOL AdjustInstanceFilterListFlags( IN PVOID pdwNewFlags,
                                    IN PVOID pfnSFProc,
                                    IN IIS_SERVER_INSTANCE *pInstance )
/*++

Routine Description:

    This is the callback function called when we need to adjust the notification flags
    of a particular filter dll for the filter list associated with a server instance.
    Note that this filter list consists of the -global- [ie service-wide] filter dlls. 

Arguments :
     pdwNewFlags - pointer to DWORD containing new notification flags
     pfnSFProc - pointer to filter entry point function
     pInstance - pointer to W3_SERVER_INSTANCE whose filter list is to be updated 

Return Value:

    TRUE if the DLL was found and the flags adjusted, FALSE otherwise
    
--*/
{
    HTTP_FILTER_DLL *pFilterDll = NULL;
    W3_SERVER_INSTANCE *pW3Instance = (W3_SERVER_INSTANCE *) pInstance;
    BOOL fFound = FALSE;

    if ( !pInstance )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "NULL instance passed to AdjustInstanceFilterFlags !\n"));
        return FALSE;
    }

    pInstance->LockThisForRead();
    FILTER_LIST *pFilterList = ((W3_SERVER_INSTANCE *) pInstance)->QueryFilterList();
    pInstance->UnlockThis();

    if ( !pFilterList )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Very odd - instance 0x%p has no filter list associated with it !\n",
                   pInstance));
        return TRUE;
    }

    pInstance->LockThisForWrite();

    //
    // Try to find the appropriate DLL in the filter list for this instance
    // 
    for ( DWORD i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        DBG_ASSERT( pFilterList->QueryDll(i)->CheckSignature() );
        
        if ( pFilterList->QueryDll(i)->QueryEntryPoint() == pfnSFProc )
        {
            pFilterDll = pFilterList->QueryDll(i);
            
            //
            //  We've found the matching filter dll, adjust the flags in the
            //  filter dll object then adjust the flags in the filter list
            //

            pFilterDll->SetNotificationFlags( *((DWORD *) pdwNewFlags) );
            pFilterList->SetNotificationFlags( i, pFilterDll );

            fFound = TRUE;
            break;
        }
    }

    pInstance->UnlockThis();

    return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\doput.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    doput.cxx

    This module contains the code for the PUT verb


    FILE HISTORY:
        Henrysa     08-May-1996     Created from doget.cxx

*/

#include "w3p.hxx"

#include <stdlib.h>

//
//  Private constants.
//


//
//  Private globals.
//

CHAR    cPutDeleteBody[] = "<body><h1>%s was %s successfully.</h1></body>";

DWORD   dwPutNumCPU;
DWORD   dwPutBlockedCount;

//
//  Private prototypes.
//

BOOL
W95MoveFileEx(
    IN LPCSTR lpExistingFile,
    IN LPCSTR lpNewFile
    );


class FILENAME_LOCK;

typedef class FILENAME_LOCK     *PFILENAME_LOCK;

typedef struct _FN_LOCK_TABLE_ENTRY
{
    LIST_ENTRY          ListHead;
    CRITICAL_SECTION    csCritSec;
} FN_LOCK_TABLE_ENTRY, *PFN_LOCK_TABLE_ENTRY;

class FILENAME_LOCK
{
public:

    FILENAME_LOCK(STR                   *pstrFileName,
                  PFN_LOCK_TABLE_ENTRY  pTableEntry) :
        hEvent(NULL),
        dwWaitCount(0)
    {
        if (!strFileName.Copy(*pstrFileName))
        {
            return;
        }

        hEvent = IIS_CREATE_EVENT(
                     "FILENAME_LOCK::hEvent",
                     this,
                     FALSE,
                     FALSE
                     );

        if (hEvent == NULL)
        {
            return;
        }

        // It's important that we not insert this into the table until
        // we know if the event was created OK, because the validity
        // check only checks for the event handle, and this object
        // will be freed without being pulled from the table if
        // the validity check fails.

        pLockTableEntry = pTableEntry;

        InsertHeadList(&pTableEntry->ListHead, &ListEntry);

    }

    ~FILENAME_LOCK(VOID)
    {
        DBG_ASSERT(dwWaitCount == 0);

        if (hEvent != NULL)
        {
            CloseHandle(hEvent);
        }
    }

    BOOL IsValid(VOID)
    { return hEvent != NULL; }

    DWORD Acquire(VOID);

    VOID Release(VOID);

    PLIST_ENTRY     Next(VOID)
    {
        return ListEntry.Flink;
    }

    BOOL IsEqual(STR    *Name)
    {
        if (Name->QueryCB() == strFileName.QueryCB() &&
            _strnicmp(Name->QueryStr(), strFileName.QueryStr(), Name->QueryCB() ) == 0)
        {
            return TRUE;
        }

        return FALSE;
    }

    LIST_ENTRY              ListEntry;

private:

    HANDLE                  hEvent;
    STR                     strFileName;
    PFN_LOCK_TABLE_ENTRY    pLockTableEntry;
    DWORD                   dwWaitCount;
};

#define MAX_FN_LOCK_BUCKETS     67

FN_LOCK_TABLE_ENTRY     FNLockTable[MAX_FN_LOCK_BUCKETS];



//
//  Public functions.
//

BOOL
HandledByApp(
    CHAR            *pszURL,
    PW3_METADATA    pMD,
    enum HTTP_VERB  Verb,
    CHAR            *pszVerb
    )
/*++

Routine Description:

    Determine if a particular URL/Verb combo might be handled by a serer side
    app, such as an ISAPI or CGI app.

Arguments:

    pszURL          - URL to be checked.
    pMD             - Metadata for the URL
    Verb            - Verb to be checked.
    pszVerb         - String form of Verb.


Returns:

    TRUE if we think it might be handled by an app, FALSE otherwise.


--*/
{
    CHAR            *pchExt;
    STR             strDummy;
    GATEWAY_TYPE    Type;
    DWORD           cchExt;
    BOOL            fImageInURL;
    BOOL            fVerbExcluded;
    DWORD           dwScriptMapFlags;
    PVOID           pExtMapInfo;

    pchExt = pszURL;

    while (*pchExt)
    {
        pchExt = strchr( pchExt + 1, '.' );

        pExtMapInfo = NULL;

        if ( !pMD->LookupExtMap( pchExt,
                                 FALSE,
                                 &strDummy,
                                 &Type,
                                 &cchExt,
                                 &fImageInURL,
                                 &fVerbExcluded,
                                 &dwScriptMapFlags,
                                 pszVerb,
                                 Verb,
                                 &pExtMapInfo
                                 ))
        {
            return FALSE;
        }

        if ( pchExt == NULL ||
                (Type != GATEWAY_UNKNOWN && !fVerbExcluded))
        {
            break;
        }

    }

    return !(Type == GATEWAY_UNKNOWN || Type == GATEWAY_NONE);
}

DWORD
HTTP_REQUEST::BuildAllowHeader(
    CHAR            *pszURL,
    CHAR            *pszTail
    )
/*++

Routine Description:

    Build an Allow: header appropriate to the URL.
Arguments:

    pszURL          - URL to be checked.
    pszTail         - Place to build the allow header.


Returns:

    Number of bytes appended to incoming pszTail.


--*/
{
    CHAR            *pszOld = pszTail;
    BOOL            bExecAllowed;

    if (_pMetaData == NULL)
    {
        return 0;
    }

    APPEND_STRING(pszTail, "Allow: OPTIONS, TRACE");

    bExecAllowed = (IS_ACCESS_ALLOWED(EXECUTE) || _fAnyParams ||
                    _pMetaData->QueryAnyExtAllowedOnReadDir() );

    if ( (bExecAllowed && HandledByApp(_strURL.QueryStr(),
                                       _pMetaData,
                                       HTV_GET,
                                       "GET") )
        || IS_ACCESS_ALLOWED(READ)
       )
    {
        APPEND_STRING(pszTail, ", GET");
    }

    if ( (bExecAllowed && HandledByApp(_strURL.QueryStr(),
                                       _pMetaData,
                                       HTV_HEAD,
                                       "HEAD") )
        || IS_ACCESS_ALLOWED(READ)
       )
    {
        APPEND_STRING(pszTail, ", HEAD");
    }

    if ( (bExecAllowed && HandledByApp(_strURL.QueryStr(),
                                       _pMetaData,
                                       HTV_PUT,
                                       "PUT") )
        || IS_ACCESS_ALLOWED(WRITE)
       )
    {
        APPEND_STRING(pszTail, ", PUT");
    }

    if ( (bExecAllowed && HandledByApp(_strURL.QueryStr(),
                                       _pMetaData,
                                       HTV_DELETE,
                                       "DELETE") )
        || IS_ACCESS_ALLOWED(WRITE)
       )
    {
        APPEND_STRING(pszTail, ", DELETE");
    }

    if ( bExecAllowed && HandledByApp(_strURL.QueryStr(),
                                       _pMetaData,
                                       HTV_POST,
                                       "POST")
       )
    {
        APPEND_STRING(pszTail, ", POST");
    }

    APPEND_STRING(pszTail, "\r\n");

    return DIFF(pszTail - pszOld);
}

VOID
FILENAME_LOCK::Release(
    VOID
    )
/*++

Routine Description:

    Release a filename lock. If there's noone waiting on the lock, then we're
    done with it, and we can go ahead and delete it. Otherwise signal the
    waiter so he can continue.

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection(&pLockTableEntry->csCritSec);

    if (dwWaitCount == 0)
    {
        // Nobody's waiting. Pull this guy from the list and delete him.

        RemoveEntryList(&ListEntry);
        LeaveCriticalSection(&pLockTableEntry->csCritSec);

        delete this;

    }
    else
    {
        DWORD           dwRet;

        // Someone's waiting, so set the event to let then go.
        LeaveCriticalSection(&pLockTableEntry->csCritSec);

        dwRet = SetEvent(hEvent);

        DBG_ASSERT(dwRet != 0);
    }
}

DWORD
FILENAME_LOCK::Acquire(
    VOID
    )
/*++

Routine Description:

    Acquire a filename lock. This routine is called if a filename lock is
    already held by another thread. Increment the wait count, and then
    block on an event. The holder of the lock will signal the event when
    they're done.

    This routine is called with the lock table bucket critical section
    held, and will free it before returning.

Arguments:

    None

Return Value:

    None

--*/
{
        DWORD       dwRet;
        DWORD       dwMaxThreads;
        DWORD       dwAlreadyBlocked;

        // First, make sure we can block. We can block if no more than
        // 3/4ths of the total number of available threads are already
        // blocked in us. Note that we don't do this at all under Win95.

        if (g_fIsWindows95)
        {
            LeaveCriticalSection(&pLockTableEntry->csCritSec);
            return WAIT_TIMEOUT;
        }

        dwMaxThreads = (DWORD)AtqGetInfo(AtqMaxPoolThreads) * dwPutNumCPU;

        dwAlreadyBlocked = InterlockedIncrement((LPLONG)&dwPutBlockedCount) - 1;

        if (dwAlreadyBlocked < ((dwMaxThreads * 3) / 4))
        {
            // It's OK to block this guy.

            // Increment the wait count so the holder knows someone is
            // waiting.

            dwWaitCount++;

            LeaveCriticalSection(&pLockTableEntry->csCritSec);

            // Block on the event until we're signalled or time out.

            dwRet = WaitForSingleObject(hEvent, g_dwPutEventTimeout * 1000);

            // We're done waiting. Enter the critical section and decrement
            // the wait count. We can't do this with interlocked instructions
            // because because other parts of this package use the critical
            // section to serialize with the wait count and other actions
            // atomically.

            EnterCriticalSection(&pLockTableEntry->csCritSec);

            dwWaitCount--;


        }
        else
        {
            dwRet = WAIT_TIMEOUT;
        }

        InterlockedDecrement((LPLONG)&dwPutBlockedCount);
        LeaveCriticalSection(&pLockTableEntry->csCritSec);

        return dwRet;

    }


//
//  Private functions.
//

PFILENAME_LOCK
AcquireFileNameLock(
    STR     *pstrFileName
    )
/*++

Routine Description:

    Acquire a file name lock after looking it up in the table. We hash the file
    name, search the appropriate bucket for it, and acquire it. If we don't
    find one we create a new one.

Arguments:

    strFileName     - Name of the file name we're "locking".

Return Value:

    Pointer to the file name lock we return.

--*/
{
    DWORD           dwHash;
    CHAR            *pchTemp;
    PLIST_ENTRY     pCurrentEntry;
    PFILENAME_LOCK  pFNLock;

    // First, hash the file name.

    dwHash = 0;

    pchTemp = pstrFileName->QueryStr();

    while (*pchTemp != '\0')
    {
        dwHash += (DWORD) *pchTemp;

        dwHash = _rotr(dwHash, 1);

        pchTemp++;
    }

    dwHash = ( (dwHash & 0xff) +
               ((dwHash >> 8) & 0xff) +
               ((dwHash >> 16) & 0xff) +
               ((dwHash >> 24) & 0xff) ) % MAX_FN_LOCK_BUCKETS;

    // We've hashed it, now take the critical section for this bucket.

    EnterCriticalSection(&FNLockTable[dwHash].csCritSec);

    // Walk down the bucket, looking for an existing lock structure.
    pCurrentEntry = FNLockTable[dwHash].ListHead.Flink;

    while (pCurrentEntry != &FNLockTable[dwHash].ListHead)
    {
        pFNLock = CONTAINING_RECORD(pCurrentEntry, FILENAME_LOCK, ListEntry);

        // See if this one matches.

        if (pFNLock->IsEqual(pstrFileName))
        {
            DWORD       dwRet;

            // It is, so try to acquire this one. The acquire routine will free
            // the critical section for us.

            dwRet = pFNLock->Acquire();

            // Here we're done waiting. If we succeeded, return a pointer to
            // the lock, otherwise return NULL.


            if (dwRet == WAIT_OBJECT_0)
            {
                return pFNLock;
            }
            else
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return NULL;
            }
        }

        // Wasn't this one, try the next one.
        pCurrentEntry = pFNLock->Next();
    }

    // If we get here there is no filename lock currently existing, so create
    // a new one.

    pFNLock = new FILENAME_LOCK(pstrFileName, &FNLockTable[dwHash]);

    // Don't need the crit sec anymore, so let it go.

    LeaveCriticalSection(&FNLockTable[dwHash].csCritSec);

    if (pFNLock == NULL)
    {
        // Couldn't get it.
        return NULL;
    }

    // Make sure the initialization worked.
    if (!pFNLock->IsValid())
    {
        // It didn't.

        delete pFNLock;
        return NULL;
    }

    // Otherwise, we're cool, and we own the newly created lock, so we're done.

    return pFNLock;
}

BOOL
HTTP_REQUEST::BuildPutDeleteHeader(
    enum WRITE_TYPE Action
    )
/*++

Routine Description:

    This is a utility routine to build a response header and body appropriate
    for a put or delete response.

Arguments:

    Action          - The action we just took.

Return Value:

    None

--*/
{
    BOOL            fFinished;
    CHAR            *pszTail;
    CHAR            *pszResp;
    DWORD           cbRespBytes;
    DWORD           cbRespBytesNeeded;
    STACK_STR(strEscapedURL, 256);

    strEscapedURL.Copy(_strURL);

    strEscapedURL.Escape();

    if (Action == WTYPE_CREATE)
    {
        CHAR        *pszHostName;
        CHAR        *pszProtocol;
        DWORD       cbProtocolLength;
        DWORD       cbHostNameLength;
        BOOL        bNeedPort;

        if (!BuildHttpHeader(&fFinished, "201 Created", NULL))
        {
            return FALSE;
        }

        pszResp  = (CHAR *)QueryRespBufPtr();
        cbRespBytes = strlen(pszResp);

        pszHostName = QueryHostAddr();
        cbHostNameLength = strlen(pszHostName);


        // Now we need to add the Location header, which means fully
        // qualifying the URL. First figure out how many bytes we might
        // need, then build the Location header.

        if (IsSecurePort())
        {
            pszProtocol = "https://";
            cbProtocolLength = sizeof("https://") - 1;
            bNeedPort = (INT) QueryClientConn()->QueryPort() != HTTP_SSL_PORT;
        }
        else
        {
            pszProtocol = "http://";
            cbProtocolLength = sizeof("http://") - 1;
            bNeedPort = (INT) QueryClientConn()->QueryPort() != 80;
        }


        cbRespBytesNeeded = cbRespBytes +
                            (sizeof("Location: ")) - 1 +
                            cbProtocolLength +
                            cbHostNameLength +
                            (bNeedPort ? 6 : 0) +       // For :port, if needed
                            strEscapedURL.QueryCB() +
                            sizeof("\r\n")  - 1;

        if (!QueryRespBuf()->Resize(cbRespBytesNeeded))
        {
            return FALSE;
        }

        pszResp  = (CHAR *)QueryRespBufPtr();
        pszTail = pszResp + cbRespBytes;

        APPEND_STRING(pszTail, "Location: ");

        memcpy(pszTail, pszProtocol, cbProtocolLength);
        pszTail += cbProtocolLength;

        memcpy(pszTail, pszHostName, cbHostNameLength);
        pszTail += cbHostNameLength;

        // Append :port if we need to.
        if (bNeedPort)
        {
            APPEND_STRING(pszTail, ":");

            pszTail += sprintf(pszTail, "%u",
                                (UINT)(QueryClientConn()->QueryPort()));
        }

        memcpy(pszTail, strEscapedURL.QueryStr(), strEscapedURL.QueryCB());
        pszTail += strEscapedURL.QueryCB();

        APPEND_STRING(pszTail, "\r\n");

        cbRespBytes = cbRespBytesNeeded;

    }
    else
    {
        if (!BuildBaseResponseHeader(QueryRespBuf(),
                                        &fFinished,
                                        NULL,
                                        0))
        {
            return FALSE;
        }

        pszResp  = (CHAR *)QueryRespBufPtr();
        cbRespBytes = strlen(pszResp);

    }

    cbRespBytesNeeded = cbRespBytes +
                        sizeof("Content-Type: text/html\r\n") - 1 +
                        sizeof("Content-Length: ") - 1 +
                        5 +                     // For content length digits
                        MAX_ALLOW_SIZE +
                        strEscapedURL.QueryCB() +
                        sizeof("\r\n\r\n") - 1 +
                        7 +             // "written"/"deleted"/"created"
                        sizeof(cPutDeleteBody);

    if (!QueryRespBuf()->Resize(cbRespBytesNeeded))
    {
        return FALSE;
    }

    pszResp  = (CHAR *)QueryRespBufPtr();
    pszTail = pszResp + cbRespBytes;

    APPEND_STRING(pszTail, "Content-Type: text/html\r\n");
    APPEND_STRING(pszTail, "Content-Length: ");
    pszTail += sprintf(pszTail, "%u\r\n", sizeof(cPutDeleteBody) - 1 +
                                    strEscapedURL.QueryCB() +
                                    sizeof("deleted") - 1 -
                                    (sizeof("%s") - 1) -
                                    (sizeof("%s") - 1));

    if (Action != WTYPE_DELETE)
    {

        pszTail += BuildAllowHeader(_strURL.QueryStr(), pszTail);

    }

    APPEND_STRING(pszTail, "\r\n");

    sprintf(pszTail, cPutDeleteBody, strEscapedURL.QueryStr(),
        (Action == WTYPE_CREATE ? "created" :
            (Action == WTYPE_WRITE ? "written" : "deleted")));

    return TRUE;
}

VOID
HTTP_REQUEST::CleanupTempFile(
    VOID )
/*++

Routine Description:

    Utility routine to close the temp file handle and delete the file.

Arguments:

    None

Return Value:

    None

--*/
{
    // Impersonate the user who opened the file. If the temp file handle
    // is still valid, close it and delete the file.

    if ( ImpersonateUser( ) )
    {
        if ( _hTempFileHandle != INVALID_HANDLE_VALUE )
        {
            ::CloseHandle( _hTempFileHandle );

            ::DeleteFile( _strTempFileName.QueryStr( ) );

            _hTempFileHandle = INVALID_HANDLE_VALUE;
        }

        RevertUser( );
    }
}

VOID
HTTP_REQUEST::VerifyMimeType(
    VOID
    )
/*++

Routine Description:

    Make sure that the mime type specified for the current file
    matches that specified by the client. If it doesn't, create
    a custom mime mapping for this URL.

Arguments:

    None.

Return Value:



--*/
{
    STACK_STR(strMimeType, 80);
    CHAR        *pszClientMimeType;
    BOOL        bHaveMapping;

    // See if the client specified a mime type. If he didn't,
    // we're done.
    //
    pszClientMimeType = (CHAR * ) _HeaderList.FastMapQueryValue(HM_CTY);

    if (pszClientMimeType == NULL)
    {
        return;     // No mime type, system default is OK.
    }

    //
    // Client specified a mime type. See if it matches what we already
    // have.
    //

    bHaveMapping = SelectMimeMapping(   &strMimeType,
                                        _strPhysicalPath.QueryStr(),
                                        _pMetaData);

    if (!bHaveMapping || _stricmp(strMimeType.QueryStr(), pszClientMimeType))
    {
        //
        // Either the mime type lookup failed, or what we have doesn't match what
        // the client specified. In either case create a custom mime map entry
        // for the specified URL. The custom mime map we create is a default
        // one, since it's on a specific file.
        //

        MB                  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
        STACK_STR(strFullMDPath, 128);
        STACK_STR(strCustomMime, 80);

        if (!strCustomMime.Copy("*") ||
            !strCustomMime.Append(",", sizeof(",") - 1) ||
            !strCustomMime.Append(pszClientMimeType) )
        {
            return;
        }

        // Append the extra NULL.
        if (!strCustomMime.Resize(strCustomMime.QueryCCH() + 2))
        {
            return;
        }

        if (!strCustomMime.SetLen(strCustomMime.QueryCB() + 1))
        {
            return;
        }

        //
        // Construct the full path to the URL, and try and open it.
        //
        if (!strFullMDPath.Copy(QueryW3Instance()->QueryMDVRPath(),
                                QueryW3Instance()->QueryMDVRPathLen() - 1) ||
            !strFullMDPath.Append(_strURL))
        {
            //
            // Couldn't construct the path.
            //
            return;
        }

        // Now try and open it.

        if ( !mb.Open( strFullMDPath.QueryStr(),
                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )
            )
        {
            // See what the error was.
            if (GetLastError() != ERROR_PATH_NOT_FOUND)
            {
                // Some error other than not exist, so quit.
                return;
            }

            // The path doesn't exist, so add it.
            if (!mb.Open(QueryW3Instance()->QueryMDVRPath(),
                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)
                )
            {
                return;
            }

            if (!mb.AddObject(_strURL.QueryStr()) &&
                GetLastError() != ERROR_ALREADY_EXISTS
                )
            {
                return;
            }

            // We added it. Close the handle so the next guy can get in.
            DBG_REQUIRE(mb.Close());

            //
            // Now try again to open the full path.
            //
            if ( !mb.Open( strFullMDPath.QueryStr(),
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )
                )
            {
                return;
            }
        }

        mb.SetMultiSZ( "",
              MD_MIME_MAP,
              IIS_MD_UT_FILE,
              strCustomMime.QueryStr());
    }


}

BOOL
HTTP_REQUEST::DoPut(
    BOOL * pfFinished
    )
/*++

Routine Description:

    Handle a PUT request ( cf HTTP 1.1 spec )
    Check the URL being put, read the entity body and write it to disk, etc.

Arguments:

    pfFinished - Set to TRUE if no further processings is needed for this
        request

Return Value:

    TRUE if success, else FALSE

--*/
{
    HANDLE              hFile;
    SECURITY_ATTRIBUTES sa;
    TCHAR               szTempFileName[MAX_PATH/sizeof(TCHAR)];
    DWORD               err;
    BOOL                fDone = FALSE;
    BOOL                fFileSuccess;
    DWORD               cbFileBytesWritten;
    DWORD               dwFileCreateError;
    BOOL                fReturn;
    BOOL                bPrecondWorked;
    CHAR                *pszContentType;



    switch (_putstate)
    {

    case PSTATE_START:

        //
        // Make sure the virtual root allows write access
        //

        if ( !IS_ACCESS_ALLOWED(WRITE) )
        {
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );

            Disconnect( HT_FORBIDDEN,
                        IDS_WRITE_ACCESS_DENIED,
                        FALSE,
                        pfFinished );

            return TRUE;
        }

        //
        // Check what we're trying to PUT, make sure we have permission.
        //

        if ( !VrootAccessCheck( _pMetaData, FILE_GENERIC_WRITE ) )
        {
            SetDeniedFlags( SF_DENIED_RESOURCE );
            return FALSE;
        }

        // We don't support Range requests on PUTs.
        if (
            QueryHeaderList()->FindValueInChunks("Content-Range:",
                               sizeof("Content-Range:") - 1)
                != NULL
            )
        {
            SetState( HTR_DONE, HT_NOT_SUPPORTED, ERROR_NOT_SUPPORTED );

            Disconnect( HT_NOT_SUPPORTED, IDS_PUT_RANGE_UNSUPPORTED, FALSE, pfFinished );
            return TRUE;
        }

        // Also don't support PUT to the '*' URL.

        if (*_strURL.QueryStr() == '*')
        {
            // Don't allow GETs on the server URL.
            SetState( HTR_DONE, HT_BAD_REQUEST, ERROR_INVALID_PARAMETER );

            Disconnect( HT_BAD_REQUEST,
                        NULL,
                        FALSE,
                        pfFinished );

            return TRUE;
        }

        //
        // Make sure we support this content type. We don't understand how to
        // handle composite MIME types, so fail if it's a message/ content type.
        //

        pszContentType = (CHAR * ) _HeaderList.FastMapQueryValue(HM_CTY);

        if (pszContentType != NULL)
        {
            if (!_strnicmp(pszContentType,
                            "message/",
                            sizeof("message/") - 1)
               )
            {
                SetState( HTR_DONE, HT_NOT_SUPPORTED, ERROR_NOT_SUPPORTED );

                Disconnect( HT_NOT_SUPPORTED, IDS_UNSUPPORTED_CONTENT_TYPE, FALSE, pfFinished );
                return TRUE;
            }
        }


        // If we don't have a content length or chunked transfer encoding,
        // fail.
        if (!_fHaveContentLength && !IsChunked())
        {
            SetState( HTR_DONE, HT_LENGTH_REQUIRED, ERROR_NOT_SUPPORTED );

            Disconnect( HT_LENGTH_REQUIRED, IDS_CANNOT_DETERMINE_LENGTH, FALSE, pfFinished );
            return TRUE;
        }

        // Now get the filename lock.

        _pFileNameLock = AcquireFileNameLock(&_strPhysicalPath);

        if (_pFileNameLock == NULL)
        {
            // Couldn't get it, return 'resource busy'.

            //make sure we log the event
            SetState ( HTR_DONE, HT_SVC_UNAVAILABLE, ERROR_SHARING_VIOLATION );

            Disconnect( HT_SVC_UNAVAILABLE, IDS_PUT_CONTENTION, FALSE, pfFinished );
            return TRUE;
        }

        if ( !ImpersonateUser( ) )
        {

            _pFileNameLock->Release();
            _pFileNameLock = NULL;
            return (FALSE);

        }

        sa.nLength              = sizeof(sa);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle       = FALSE;

        hFile = ::CreateFile( _strPhysicalPath.QueryStr(),
                                GENERIC_READ | GENERIC_WRITE,
                                g_fIsWindows95 ?
                                    (FILE_SHARE_READ | FILE_SHARE_WRITE) :
                                    (FILE_SHARE_READ | FILE_SHARE_WRITE |
                                     FILE_SHARE_DELETE),
                                &sa,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if ( ( hFile != INVALID_HANDLE_VALUE ) &&
             ( GetFileType( hFile ) != FILE_TYPE_DISK ) )
        {
            DBG_REQUIRE( ::CloseHandle( hFile ) );
            hFile = INVALID_HANDLE_VALUE;
            SetLastError( ERROR_ACCESS_DENIED );
        }

        dwFileCreateError = ::GetLastError();

        if ( hFile == INVALID_HANDLE_VALUE)
        {
            // Some sort of error opening the file.


            RevertUser();

            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            if ( dwFileCreateError == ERROR_FILE_NOT_FOUND ||
                 dwFileCreateError == ERROR_PATH_NOT_FOUND)
            {
                // The path or filename itself is bad, fail the request.

                SetState( HTR_DONE, HT_NOT_FOUND, GetLastError() );
                Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                return TRUE;

            }

            if ( dwFileCreateError == ERROR_INVALID_NAME )
            {
                // An invalid name.

                SetState( HTR_DONE, HT_BAD_REQUEST, GetLastError() );
                Disconnect( HT_BAD_REQUEST, NO_ERROR, FALSE, pfFinished );
                return TRUE;
            }
            else
            {

                // A 'bad' error has occured, so return FALSE.

                if ( dwFileCreateError == ERROR_ACCESS_DENIED )
                {
                    SetDeniedFlags( SF_DENIED_RESOURCE );
                }

            }

            return FALSE;
        }
        else
        {

            // The create worked. If this isn't a directory and it's not
            // hidden or readonly we're OK. If we just created it now, delete
            // it so we don't have to remember to if the put fails later.

            BY_HANDLE_FILE_INFORMATION      FileInfo;


            // Get file information and check for a directory or hidden file.
            fReturn = GetFileInformationByHandle(
                                                hFile,
                                                &FileInfo
                                                );


            // See if this file is accessible. If not, fail.
            if ( fReturn)
            {

                // We got the information.

                if ( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    DBG_REQUIRE( ::CloseHandle( hFile ));
                    if ( dwFileCreateError != ERROR_ALREADY_EXISTS)
                    {

                        ::DeleteFile(  _strPhysicalPath.QueryStr() );
                    }

                    // Don't allow puts to directory.
                    RevertUser();

                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;

                    SetState( HTR_DONE, HT_BAD_REQUEST, GetLastError() );
                    Disconnect( HT_BAD_REQUEST, NO_ERROR, FALSE, pfFinished );
                    return TRUE;
                }

                if ( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
                {

                    // Pretend we can't see hidden files.
                    DBG_REQUIRE( ::CloseHandle( hFile ));
                    if ( dwFileCreateError != ERROR_ALREADY_EXISTS)
                    {

                        ::DeleteFile(  _strPhysicalPath.QueryStr() );
                    }

                    RevertUser();

                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;

                    SetState( HTR_DONE, HT_NOT_FOUND, GetLastError() );
                    Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                    return TRUE;

                }

            } else
            {
                // Some sort of fatal error.
                DBG_REQUIRE( ::CloseHandle( hFile ));
                if ( dwFileCreateError != ERROR_ALREADY_EXISTS)
                {

                    ::DeleteFile(  _strPhysicalPath.QueryStr() );
                }

                RevertUser();

                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                return FALSE;
            }

        }


        // Check the preconditions on this file, if there are any. It's
        // possible that it would be better to do this at the very end,
        // right before we rename the file, but for not we do it here.

        bPrecondWorked = FALSE;

        _bFileExisted = (dwFileCreateError == ERROR_ALREADY_EXISTS);

        if (_fIfModifier)
        {
            // Have a modifier. See if it succeeds. If it does, CheckPreconditions
            // will do a synchronous send of the appropriate response header.

            bPrecondWorked =  CheckPreconditions(hFile,
                                    _bFileExisted,
                                    pfFinished,
                                    &fReturn
                                    );

        }

        // Close the handle now, since we know longer need it.
        DBG_REQUIRE( ::CloseHandle( hFile ));

        if (!_bFileExisted)
        {
            // File didn't originally exist, so delete the one we just created.
            ::DeleteFile(  _strPhysicalPath.QueryStr() );
        }


        if (bPrecondWorked)
        {
            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            if (!fReturn)
            {
                return fReturn;
            }

            // We had a precondition work. If we're read the entire entity
            // body, we're done. Otherwise we need to keep reading and
            // discarding the data. CheckPreconditions has already done a synchronous
            // send of the appropriate headers.

            if (QueryClientContentLength() <= QueryTotalEntityBodyCB())
            {
                // All done. The call to CheckPreconditions() above should
                // have set our state to done already.

                DBG_ASSERT(QueryState() == HTR_DONE);

                *pfFinished = TRUE;
                return TRUE;
            }

            // Otherwise we need to start reading and discarding. We start the
            // first read here. If that pends, we just return, leaving our put
            // state set to discard-read so that we'll do the appropriate
            // things when the read completes. If the read succeeds now,
            // we set our put state to discard-chunk and call ourselves
            // recursively to let the discard-chunk substate handler do the
            // right things.

            DBG_ASSERT(!*pfFinished);

            SetState( HTR_DOVERB, _dwLogHttpResponse, NO_ERROR );
            _putstate = PSTATE_DISCARD_READ;

            if ( !ReadEntityBody( &fDone, TRUE,
                    QueryMetaData()->QueryPutReadSize() ))
            {
                return FALSE;
            }

            if (!fDone)
            {
                return TRUE;
            }

            _putstate = PSTATE_DISCARD_CHUNK;

            return DoPut(pfFinished);
        }

        // At this point we've verified the request. We need to generate a
        // temporary file name and if this is a 1.1 or greater client send
        // back a 100 Continue response.

        err = ::GetTempFileName(
                            g_pszW3TempDirName,
                            W3_TEMP_PREFIX,
                            0,
                            szTempFileName
                            );

        if ( err == 0 ||  !_strTempFileName.Copy( szTempFileName ) )
        {
            //
            // Couldn't create or copy a temporary file name.
            //

            RevertUser();
            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            return FALSE;

        }

        // Now open the temp file. We specify OPEN_EXISTING because we
        // want to fail if someone's deleted the temp file name before we
        // opened it. If that's happened we have no real guarantee that the
        // file is still unique. We don't specify any sharing as we don't
        // want anyone else to write into while we are.

        _hTempFileHandle =  ::CreateFile( szTempFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                g_fIsWindows95 ? 0 : FILE_SHARE_DELETE,
                                &sa,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);

        RevertUser();

        if (_hTempFileHandle == INVALID_HANDLE_VALUE)
        {
            // Uh-oh. Couldn't open the temp file we just created. This is bad,
            // return FALSE to fail the request rudely.

            DBGPRINTF((DBG_CONTEXT,"CreateFile[%s] failed with %d\n",
                szTempFileName, GetLastError()));

            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            return FALSE;
        }

        // Now everything's good. If this is a 1.1 client or greater send
        // back the 100 Continue response, otherwise skip that.

        if ( IsAtLeastOneOne() )
        {
            if ( !SendHeader( "100 Continue", "\r\n", IO_FLAG_SYNC, pfFinished,
                              HTTPH_NO_CONNECTION) )
            {
                // An error on the header send. Abort this request.

                CleanupTempFile( );

                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                return FALSE;
            }

            if ( *pfFinished )
            {
                CleanupTempFile();
            }
        }


        // Set out put state to reading, and begin reading the entity body.

        _putstate = PSTATE_READING;

        if ( !ReadEntityBody( &fDone, TRUE, QueryMetaData()->QueryPutReadSize() ))
        {
            // Had some sort of problem reading the entity body. This is
            // fatal.

            CleanupTempFile( );

            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            return FALSE;
        }

        if ( !fDone )
        {
            return TRUE;
        }

        DBG_ASSERT((QueryEntityBodyCB() >= QueryMetaData()->QueryPutReadSize())
                    || (QueryEntityBodyCB() == QueryClientContentLength()));

        // Fall through to the PSTATE_READING handler.

    case PSTATE_READING:

        // When we get here, we've completed a read. If this isn't the
        // fall through case call ReadEntityBody again to find out if
        // we're done with the current chunk.

        if ( !fDone )
        {
            if ( !ReadEntityBody( &fDone, FALSE,
                                    QueryMetaData()->QueryPutReadSize() ))
            {
                // Had some sort of problem reading the entity body. This is
                // fatal.

                CleanupTempFile( );
                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                return FALSE;
            }

            if ( !fDone )
            {
                return TRUE;
            }
        }

        // Right here we know we've read the current chunk, so we want
        // to set our state to writing and write this to the temp file.

        do
        {

            DWORD       dwAmountToWrite;

            // Since there could be extra slop in the buffer, we need to
            // figure out how much to actually write. TotalEntityBodyCB
            // is the total number of bytes we've read into the buffer
            // for this request, and EntityBodyCB is the number of bytes
            // in the buffer for this chunk. Therefore TEBCB - EBCB is the
            // amount we've already read and written to the file. We want to
            // write the minimum of the ContentLength - this amount and
            // EBCB.

            dwAmountToWrite = min ( QueryClientContentLength() -
                                        (QueryTotalEntityBodyCB() -
                                        QueryEntityBodyCB()),
                                    QueryEntityBodyCB() );


            //
            // Check to see if the amount we're to write is 0, and skip if it
            // is. This can happen in the chunked case where all we got on
            // the last read is the 0 terminator.
            //

            if (dwAmountToWrite != 0)
            {

                fFileSuccess = ::WriteFile( _hTempFileHandle,
                                                QueryEntityBody(),
                                                dwAmountToWrite,
                                                &cbFileBytesWritten,
                                                NULL
                                            );
                if ( !fFileSuccess || cbFileBytesWritten != dwAmountToWrite )
                {

                    // Some sort of problem with the write. Abort the request.

                    CleanupTempFile( );
                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;

                    return FALSE;
                }
            }

            _cbEntityBody = 0;
            _cbBytesWritten = 0;

            // Now, if we haven't read all of the entity body try to read some more.

            if ( QueryClientContentLength() > QueryTotalEntityBodyCB() )
            {
                if ( !ReadEntityBody( &fDone, TRUE,
                                        QueryMetaData()->QueryPutReadSize() ))
                {
                    // Had some sort of problem reading the entity body. This is
                    // fatal.

                    CleanupTempFile( );
                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;

                    return FALSE;
                }
            } else
            {

                // We've read and written all of the entity body. Rename the
                // temp file now, close the temp file handle (causing a delete),
                // flush the atq cache and we're done.

                if ( !ImpersonateUser( ) )
                {
                    CleanupTempFile( );

                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;
                    return (FALSE);
                }

                //
                // If the file we're PUTing already exists, rename it to
                // another name before we move the other one over.

                if ( _bFileExisted )
                {

                    err = ::GetTempFileName(
                                        g_pszW3TempDirName,
                                        W3_TEMP_PREFIX,
                                        0,
                                        szTempFileName
                                        );

                    if ( err == 0 )
                    {
                        //
                        // Couldn't create a temporary file name.
                        //

                        RevertUser();
                        CleanupTempFile();
                        _pFileNameLock->Release();
                        _pFileNameLock = NULL;

                        return FALSE;
                    }

                    // Now do the actual rename. GetTempFileName() will
                    // have created the file.
                    if ( g_fIsWindows95 ) {
                        fFileSuccess = ::W95MoveFileEx( _strPhysicalPath.QueryStr(),
                                                        szTempFileName
                                                    );
                    } else {
                        fFileSuccess = ::MoveFileEx(_strPhysicalPath.QueryStr(),
                                                    szTempFileName,
                                                    MOVEFILE_REPLACE_EXISTING |
                                                    MOVEFILE_COPY_ALLOWED
                                                    );
                    }

                    if ( !fFileSuccess )
                    {
                        // Couldn't move the file!
                        RevertUser();
                        CleanupTempFile();
                        _pFileNameLock->Release();
                        _pFileNameLock = NULL;

                        return FALSE;
                    }
                }


                ::CloseHandle( _hTempFileHandle );

                _hTempFileHandle = INVALID_HANDLE_VALUE;

                // Now rename the temp file to the file we're PUTing. The file
                // shouldn't already exist (since we'd have renamed it if it
                // did), so this should fail if it does.

                if ( g_fIsWindows95 ) {
                    fFileSuccess = ::W95MoveFileEx(_strTempFileName.QueryStr(),
                                               _strPhysicalPath.QueryStr()
                                                );
                } else {
                    fFileSuccess = ::MoveFileEx(_strTempFileName.QueryStr(),
                                               _strPhysicalPath.QueryStr(),
                                                MOVEFILE_COPY_ALLOWED
                                                );
                }

                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                if ( fFileSuccess ) {

                    BOOL        fHandled;
                    DWORD       cbDummy;

                    // The rename worked. Cleanup the renamed copy of the
                    // original file if it exists, and flush the cache.

                    if (_bFileExisted)
                    {
                        ::DeleteFile( szTempFileName );
                    }

                    RevertUser( );

                    _cFilesReceived++;

                    // Flush the atq cache here.
                    TsFlushURL(QueryW3Instance()->GetTsvcCache(),
                                _strURL.QueryStr(),
                                _strURL.QueryCB(),
                                RESERVED_DEMUX_URI_INFO);

                    //
                    // Now see if the mime type we currently have
                    // matches the mimetype the client requested. If
                    // it does, or the client requested one, we're
                    // good. Otherwise we need to create a custom
                    // mimetype entry for this file.
                    //
                    VerifyMimeType();

                    // Build and send the response.
                    if ( !BuildPutDeleteHeader( _bFileExisted ?
                                WTYPE_WRITE : WTYPE_CREATE ))
                    {
                        return FALSE;
                    }

                    SetState( HTR_DONE, _bFileExisted ? HT_OK : HT_CREATED,
                                            NO_ERROR );

                    return SendHeader( QueryRespBufPtr(),
                                       (DWORD) -1,
                                       IO_FLAG_ASYNC,
                                       pfFinished );
                } else
                {
                    // The rename failed. There's no easy way to tell why.
                    // Leave a backup copy around, and log it so that an admin
                    // can restore it.

                    const   CHAR    *pszFileName[3];

                    err = GetLastError();

                    pszFileName[0] = _strRawURL.QueryStr();
                    pszFileName[1] = _strPhysicalPath.QueryStr();

                    if (_bFileExisted)
                    {
                        pszFileName[2] = szTempFileName;
                        g_pInetSvc->LogEvent(  W3_EVENT_CANNOT_PUT_RENAME,
                                               3,
                                               pszFileName,
                                               0 );
                    }
                    else
                    {
                        g_pInetSvc->LogEvent(  W3_EVENT_CANNOT_PUT,
                                               2,
                                               pszFileName,
                                               0 );
                    }

                    IF_DEBUG(ERROR) {
                        DBGPRINTF((DBG_CONTEXT,
                            "MoveFileEx[%s to %s] failed with %d\n",
                            _strTempFileName.QueryStr(),
                            _strPhysicalPath.QueryStr(),
                            err));
                    }

                    ::DeleteFile( _strTempFileName.QueryStr( ));
                    RevertUser( );

                    //
                    // Rename failed somehow.
                    //

                    SetLastError(err);
                    return FALSE;

                }
            }

        } while ( fDone );

        return TRUE;

        break;

    case PSTATE_DISCARD_READ:

        // Just had a read complete. See if we've read all of the data for
        // this chunk. If not, wait until the next read completes. Otherwise
        // see if we're done reading and discarding.
        if ( !ReadEntityBody( &fDone, FALSE,
                QueryMetaData()->QueryPutReadSize() ))
        {
            return FALSE;
        }

        if (!fDone)
        {
            // Another read pending, so wait for it to complete.
            return TRUE;
        }

        // Otherwise we're read one chunk. Fall through to the discard chunk
        // code, to see if we're done overall and possibly get another
        // read going.

    case PSTATE_DISCARD_CHUNK:

        do {
            if ( QueryClientContentLength() <= QueryTotalEntityBodyCB() )
            {
                // We're read all of the data, so we're done.
                SetState( HTR_DONE, _dwLogHttpResponse, NO_ERROR );

                *pfFinished = TRUE;
                return TRUE;
            }

            // Haven't read it all yet, get another read going.
            _putstate = PSTATE_DISCARD_READ;
            _cbEntityBody = 0;
            _cbBytesWritten = 0;

            DBG_ASSERT(QueryClientContentLength() > QueryTotalEntityBodyCB());

            if ( !ReadEntityBody( &fDone, TRUE,
                    QueryMetaData()->QueryPutReadSize() ))
            {
                return FALSE;
            }


        } while ( fDone );

        return TRUE;

    default:

        break;


    }

    return FALSE;


}

BOOL
HTTP_REQUEST::DoDelete(
    BOOL * pfFinished
    )
/*++

Routine Description:

    Handle a DELETE request ( cf HTTP 1.1 spec )
    Check the URL being deleted, make sure we have permission, and
    delete it.

    In order to be safe we need to be sure we can both delete the file and
    send a response header. To make this work we'll open the file with delete
    access. If that works we'll try and build and send the response header, and
    iff that works we'll actually try to delete the file.

Arguments:

    None

Return Value:

    TRUE if success, else
    FALSE

--*/
{
    HANDLE              hFile;
    SECURITY_ATTRIBUTES sa;
    DWORD               err;
    STR                 ResponseStr;
    BOOL                fDone;
    BOOL                fReturn;
    BOOL                fDeleted = FALSE;


    //
    // Make sure the virtual root allows write access
    //

    if ( !IS_ACCESS_ALLOWED(WRITE) )
    {
        SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );

        Disconnect( HT_FORBIDDEN, IDS_WRITE_ACCESS_DENIED, FALSE, pfFinished );
        return TRUE;
    }

    // Check that we're not trying to DELETE the '*' URL.

    if (*_strURL.QueryStr() == '*')
    {
        // Don't allow GETs on the server URL.
        SetState( HTR_DONE, HT_BAD_REQUEST, ERROR_INVALID_PARAMETER );

        Disconnect( HT_BAD_REQUEST,
                    NULL,
                    FALSE,
                    pfFinished );

        return TRUE;
    }

    // Now get the filename lock.

    _pFileNameLock = AcquireFileNameLock(&_strPhysicalPath);

    if (_pFileNameLock == NULL)
    {
        // Couldn't get it, return 'resource busy'.
        return FALSE;
    }

    if ( !ImpersonateUser( ) )
    {
        _pFileNameLock->Release();
        _pFileNameLock = NULL;

        return (FALSE);
    }

    if ( TsDeleteOnClose(_pURIInfo, QueryImpersonationHandle(), &fDeleted ) ) {

        if ( !fDeleted ) {
            // A 'bad' error has occured, so return FALSE.
            RevertUser();
            SetDeniedFlags( SF_DENIED_RESOURCE );
            _pFileNameLock->Release();
            _pFileNameLock = NULL;
            return FALSE;
        } else {
            // Try to build and send the HTTP response header.

            if (!BuildPutDeleteHeader(WTYPE_DELETE)) {
                RevertUser();
                _pFileNameLock->Release();
                _pFileNameLock = NULL;
                return FALSE;
            }
        }
    }

    if (!fDeleted) {

        sa.nLength              = sizeof(sa);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle       = FALSE;

        hFile = ::CreateFile( _strPhysicalPath.QueryStr(),
                                GENERIC_READ | GENERIC_WRITE,
                                g_fIsWindows95 ?
                                    (FILE_SHARE_READ | FILE_SHARE_WRITE) :
                                    (FILE_SHARE_READ | FILE_SHARE_WRITE |
                                     FILE_SHARE_DELETE),
                                &sa,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if ( hFile == INVALID_HANDLE_VALUE)
        {
            // Some sort of error opening the file.

            err = ::GetLastError();

            RevertUser();

            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            if ( err == ERROR_FILE_NOT_FOUND ||
                 err == ERROR_PATH_NOT_FOUND)
            {
                // The path or filename itself is bad, fail the request.

                SetState( HTR_DONE, HT_NOT_FOUND, GetLastError() );
                Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                return TRUE;

            }

            if ( err == ERROR_INVALID_NAME )
            {
                // An invalid name.

                SetState( HTR_DONE, HT_BAD_REQUEST, GetLastError() );
                Disconnect( HT_BAD_REQUEST, NO_ERROR, FALSE, pfFinished );
                return TRUE;
            }
            else
            {

                // A 'bad' error has occured, so return FALSE.

                if ( err == ERROR_ACCESS_DENIED )
                {
                    SetDeniedFlags( SF_DENIED_RESOURCE );
                }

            }

            return FALSE;
        }
        else
        {
            // We should be able to delete it, so just close the handle.

            if (_fIfModifier)
            {
                fDone =  CheckPreconditions(hFile,
                                        TRUE,
                                        pfFinished,
                                        &fReturn
                                        );
            }
            else
            {
                fDone = FALSE;
            }

            ::CloseHandle(hFile);

            if (fDone)
            {
                RevertUser();
                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                *pfFinished = TRUE;

                return fReturn;
            }
        }

        TsFlushURL(QueryW3Instance()->GetTsvcCache(),
                    _strURL.QueryStr(),
                    _strURL.QueryCB(),
                    RESERVED_DEMUX_URI_INFO);

        // Try to build and send the HTTP response header.

        if (!BuildPutDeleteHeader(WTYPE_DELETE))
         {
            RevertUser();
            _pFileNameLock->Release();
            _pFileNameLock = NULL;
            return FALSE;
        }

        // We built the successful response, now delete the actual file.

        fDeleted = ::DeleteFile( _strPhysicalPath.QueryStr() );
    }

    RevertUser();

    _pFileNameLock->Release();
    _pFileNameLock = NULL;

    if ( !fDeleted) {

        return FALSE;
    }

    SetState( HTR_DONE, HT_OK, NO_ERROR );

    if ( !SendHeader( QueryRespBufPtr(),
                      (DWORD) -1,
                      IO_FLAG_ASYNC,
                      pfFinished ))
    {
        // Presumably if the WriteFile fails something serious has gone wrong,
        // and the connection is about to die.
        return FALSE;
    }


    // Here we should go ahead and purge this from the Tsunami cache

    return TRUE;

}


BOOL
W95MoveFileEx(
    IN LPCSTR lpExistingFile,
    IN LPCSTR lpNewFile
    )
{
    BOOL fRet;

    fRet = ::CopyFile( lpExistingFile, lpNewFile, FALSE );
    if ( fRet ) {
        ::DeleteFile(lpExistingFile);
    } else {
        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,
                "Error %d in CopyFile[%s to %s]\n",
                GetLastError(), lpExistingFile, lpNewFile));
        }
    }
    return(fRet);

} // W95MoveFileEx

VOID
HTTP_REQUEST::CleanupWriteState(
    VOID
    )
/*++

Routine Description:

    Cleanup any of the write methods (PUT, DELETE) state when a request is
    completed.

Arguments:

    None

Return Value:

    None.

--*/
{
    if (_pFileNameLock != NULL)
    {
        _pFileNameLock->Release();
        _pFileNameLock = NULL;
    }

    if (_hTempFileHandle != INVALID_HANDLE_VALUE)
    {
        CleanupTempFile();
    }
}


DWORD
InitializeWriteState(
    VOID
    )
/*++

Routine Description:

    Initialize the global state we need in order to do write methods such as
    PUT and DELETE.

Arguments:

    None

Return Value:

    NO_ERROR on success, or error code if we fail.

--*/
{
    DWORD           i;

    for (i = 0; i < MAX_FN_LOCK_BUCKETS; i++)
    {
        InitializeListHead(&FNLockTable[i].ListHead);
        INITIALIZE_CRITICAL_SECTION(&FNLockTable[i].csCritSec);
    }

    if ( !InetIsNtServer( IISGetPlatformType() ) )
    {
        dwPutNumCPU = 1;

    } else
    {

        SYSTEM_INFO si;

        //
        // get the count of CPUs for Thread Tuning.
        //

        GetSystemInfo( &si );
        dwPutNumCPU = si.dwNumberOfProcessors;
    }

    dwPutBlockedCount = 0;

    return NO_ERROR;
}


VOID
TerminateWriteState(
    VOID
    )
/*++

Routine Description:

    Terminate the global state we need in order to do write methods such as
    PUT and DELETE.

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD           i;

    for (i = 0; i < MAX_FN_LOCK_BUCKETS; i++)
    {
        DeleteCriticalSection(&FNLockTable[i].csCritSec);
    }
}


BOOL
HTTP_REQUEST::DoOptions(
    BOOL * pfFinished
    )
/*++

Routine Description:

    Handle an OPTIONS request. If this is a request for the '*' URL, we'll
    send back information about the global methods we support. If this is
    for a particular URL we'll send back information about what's allowable
    on that URL.

Arguments:

    pfFinished - Set to TRUE if no further processings is needed for this
        request

Return Value:

    TRUE if success, else FALSE

--*/
{
    CHAR            *pszResp;
    CHAR            *pszTail;
    DWORD           cbRespBytes;
    DWORD           cbRespBytesNeeded;
    BOOL            fDav = ((W3_IIS_SERVICE *) QueryW3Instance()->m_Service)->FDavDll();

    // Build the basic response header first.

    if (!BuildBaseResponseHeader(QueryRespBuf(),
                                pfFinished,
                                NULL,
                                0))
    {
        return FALSE;
    }

    pszResp  = (CHAR *)QueryRespBufPtr();
    cbRespBytes = strlen(pszResp);

    cbRespBytesNeeded = cbRespBytes +
                        sizeof("Public: OPTIONS, TRACE, GET, HEAD, POST, PUT, DELETE\r\n") - 1 +
                        sizeof("Content-Length: 0\r\n\r\n");

    if (!QueryRespBuf()->Resize(cbRespBytesNeeded))
    {
        return FALSE;
    }

    pszResp  = (CHAR *)QueryRespBufPtr();

    pszTail = pszResp + cbRespBytes;

    APPEND_STRING(pszTail, "Public: OPTIONS, TRACE, GET, HEAD, POST, PUT, DELETE\r\n");

    if (*_strURL.QueryStr() != '*')
    {
        // We have an actual URL. Figure out what methods are applicable to it.

        cbRespBytes = DIFF(pszTail - pszResp);

        cbRespBytesNeeded = cbRespBytes +
                            MAX_ALLOW_SIZE;

        if (!QueryRespBuf()->Resize(cbRespBytesNeeded))
        {
            return FALSE;
        }

        pszResp  = (CHAR *)QueryRespBufPtr();

        pszTail = pszResp + cbRespBytes;

        pszTail += BuildAllowHeader(_strURL.QueryStr(), pszTail);

    }

    APPEND_STRING(pszTail, "Content-Length: 0\r\n\r\n");

    SetState( HTR_DONE, HT_OK, NO_ERROR );

    if ( !SendHeader( QueryRespBufPtr(),
                      (DWORD) -1,
                      IO_FLAG_ASYNC,
                      pfFinished ))
    {
        return FALSE;
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\ftm.cpp ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1996, 1997, 1998 Microsoft Corporation. All Rights Reserved.

Component: Free Threaded Marshaller Base Class

File: ftm.cpp

Owner: Lei Jin

This is the free threaded marshaller base class implementation.
===================================================================*/
#include <w3p.hxx>
#pragma hdrstop
#include "ftm.h"

IMarshal* CFTMImplementation::m_pFTM     = NULL;

STDMETHODIMP 
CFTMImplementation::GetUnmarshalClass
( 
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags,
/* [out] */ CLSID __RPC_FAR *pCid
)
    {
    
    DBG_ASSERT(m_pFTM != NULL);
    
    return m_pFTM->GetUnmarshalClass(riid, pv, dwDestContext, pvDestContext, mshlflags, pCid);

    }

STDMETHODIMP 
CFTMImplementation::GetMarshalSizeMax( 
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags,
/* [out] */ DWORD __RPC_FAR *pSize)
    {
    DBG_ASSERT(m_pFTM != NULL);
    return m_pFTM->GetMarshalSizeMax(riid, pv, dwDestContext, pvDestContext, mshlflags, pSize);
    }

STDMETHODIMP
CFTMImplementation::MarshalInterface( 
/* [unique][in] */ IStream __RPC_FAR *pStm,
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags)
    {
    DBG_ASSERT(m_pFTM != NULL);
    return m_pFTM->MarshalInterface(pStm, riid, pv, dwDestContext, pvDestContext, mshlflags);
    }

STDMETHODIMP 
CFTMImplementation::UnmarshalInterface
( 
/* [unique][in] */ IStream __RPC_FAR *pStm,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
    {
    DBG_ASSERT(m_pFTM != NULL);
    return m_pFTM->UnmarshalInterface(pStm, riid, ppv);
    }

STDMETHODIMP 
CFTMImplementation::ReleaseMarshalData
( 
/* [unique][in] */ IStream __RPC_FAR *pStm
)
    {
    DBG_ASSERT(m_pFTM != NULL);
    return m_pFTM->ReleaseMarshalData(pStm);
    }

STDMETHODIMP 
CFTMImplementation::DisconnectObject
( 
/* [in] */ DWORD dwReserved
)
    {
    DBG_ASSERT(m_pFTM != NULL);
    return m_pFTM->DisconnectObject(dwReserved);
    }

HRESULT			
CFTMImplementation::Init
(
void
)
    {
    HRESULT hr;
    IUnknown *pUnk;

    hr = CoCreateFreeThreadedMarshaler(NULL, (IUnknown**)&pUnk);
    if(SUCCEEDED(hr)) {
        hr = pUnk->QueryInterface(IID_IMarshal, (void **) &m_pFTM);
        pUnk->Release();
    } else {
        DBG_ASSERT(SUCCEEDED(hr));
    }

    return hr;
    }

    
HRESULT			
CFTMImplementation::UnInit
(
void
)
    {
    DBG_ASSERT(m_pFTM != NULL);

    m_pFTM->Release();
    m_pFTM = NULL;

    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\ftm.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1996, 1997, 1998 Microsoft Corporation. All Rights Reserved.

Component: Free Threaded Marshaller Base Class

File: ftm.h

Owner: Lei Jin

This is the free threaded marshaller base class header file
===================================================================*/
#ifndef _FTM_GLOBAL_H
#define _FTM_GLOBAL_H

#include <objbase.h>

class CFTMImplementation : public IMarshal 
{
public:

    STDMETHODIMP GetUnmarshalClass( 
		    /* [in] */ REFIID riid,
		    /* [unique][in] */ void __RPC_FAR *pv,
		    /* [in] */ DWORD dwDestContext,
		    /* [unique][in] */ void __RPC_FAR *pvDestContext,
		    /* [in] */ DWORD mshlflags,
		    /* [out] */ CLSID __RPC_FAR *pCid);

    STDMETHODIMP GetMarshalSizeMax( 
	        /* [in] */ REFIID riid,
	        /* [unique][in] */ void __RPC_FAR *pv,
	        /* [in] */ DWORD dwDestContext,
	        /* [unique][in] */ void __RPC_FAR *pvDestContext,
	        /* [in] */ DWORD mshlflags,
	        /* [out] */ DWORD __RPC_FAR *pSize);
    
    STDMETHODIMP MarshalInterface( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm,
	        /* [in] */ REFIID riid,
	        /* [unique][in] */ void __RPC_FAR *pv,
	        /* [in] */ DWORD dwDestContext,
	        /* [unique][in] */ void __RPC_FAR *pvDestContext,
	        /* [in] */ DWORD mshlflags);
    
    STDMETHODIMP UnmarshalInterface( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm,
	        /* [in] */ REFIID riid,
	        /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
    
    STDMETHODIMP ReleaseMarshalData( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm);
    
    STDMETHODIMP DisconnectObject( 
	        /* [in] */ DWORD dwReserved);

	static	HRESULT			Init();
	static	HRESULT			UnInit();
	
private:
	// Global FTM pointer
	static	IMarshal *		m_pFTM; 
};

#endif _FTM_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\gip.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.h

Owner: DmitryR

This is the GIP header file.
===================================================================*/

#ifndef _ASP_GIP_H
#define _ASP_GIP_H

// ***********************************************************************
// =======================================================================
// -----------------------------------------------------------------------
// START OF SP3 1.78 SDK Additions
// -----------------------------------------------------------------------
// The following are SP3 1.78 Additions from Rick Hill (rickhi)
// extracted from CGUID.H and OBJIDL.H
// -----------------------------------------------------------------------
// UNDONE: Once the new SDK is available the stuff below will be gone
// -----------------------------------------------------------------------
// =======================================================================
// ***********************************************************************

EXTERN_C const CLSID CLSID_StdGlobalInterfaceTable;


#ifndef __IGlobalInterfaceTable_FWD_DEFINED__
#define __IGlobalInterfaceTable_FWD_DEFINED__
typedef interface IGlobalInterfaceTable IGlobalInterfaceTable;
#endif 	/* __IGlobalInterfaceTable_FWD_DEFINED__ */

#ifndef __IGlobalInterfaceTable_INTERFACE_DEFINED__
#define __IGlobalInterfaceTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGlobalInterfaceTable
 * at Fri Apr 04 10:36:42 1997
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][object][local] */ 


typedef /* [unique] */ __RPC_FAR *LPGLOBALINTERFACETABLE;


EXTERN_C const IID IID_IGlobalInterfaceTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGlobalInterfaceTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterInterfaceInGlobal( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeInterfaceFromGlobal( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceFromGlobal( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGlobalInterfaceTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGlobalInterfaceTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGlobalInterfaceTable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterInterfaceInGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RevokeInterfaceFromGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfaceFromGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        END_INTERFACE
    } IGlobalInterfaceTableVtbl;

    interface IGlobalInterfaceTable
    {
        CONST_VTBL struct IGlobalInterfaceTableVtbl __RPC_FAR *lpVtbl;
    };

#ifdef COBJMACROS

#define IGlobalInterfaceTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGlobalInterfaceTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGlobalInterfaceTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGlobalInterfaceTable_RegisterInterfaceInGlobal(This,pUnk,riid,
pdwCookie)	\
    (This)->lpVtbl -> RegisterInterfaceInGlobal(This,pUnk,riid,pdwCookie)

#define IGlobalInterfaceTable_RevokeInterfaceFromGlobal(This,dwCookie)	\
    (This)->lpVtbl -> RevokeInterfaceFromGlobal(This,dwCookie)

#define IGlobalInterfaceTable_GetInterfaceFromGlobal(This,dwCookie,riid,ppv)	\
    (This)->lpVtbl -> GetInterfaceFromGlobal(This,dwCookie,riid,ppv)

#endif /* COBJMACROS */

#endif 	/* C style interface */

HRESULT STDMETHODCALLTYPE 
IGlobalInterfaceTable_RegisterInterfaceInGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ REFIID riid,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IGlobalInterfaceTable_RegisterInterfaceInGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE 
IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_GetInterfaceFromGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ DWORD dwCookie,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IGlobalInterfaceTable_GetInterfaceFromGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IGlobalInterfaceTable_INTERFACE_DEFINED__ */

// ***********************************************************************
// =======================================================================
// -----------------------------------------------------------------------
// END OF SP3 1.78 SDK Additions
// -----------------------------------------------------------------------
// =======================================================================
// ***********************************************************************

/*===================================================================
  Includes
===================================================================*/


/*===================================================================
  Defines
===================================================================*/

#define NULL_GIP_COOKIE  0xFFFFFFFF

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

class CGlobalInterfaceAPI
    {
private:
    // Is inited?
    DWORD m_fInited : 1;
    
    // Pointer to the COM object
    IGlobalInterfaceTable *m_pGIT;

public:
    CGlobalInterfaceAPI();
    ~CGlobalInterfaceAPI();

    HRESULT Init();
    HRESULT UnInit();

    // inlines for the real API calls:
    HRESULT Register(IUnknown *pUnk, REFIID riid, DWORD *pdwCookie);
    HRESULT Get(DWORD dwCookie, REFIID riid, void **ppv);
    HRESULT Revoke(DWORD dwCookie);
    
public:
#if DBG
	inline void AssertValid() const
	    {
        DBG_ASSERT(m_fInited);
        DBG_ASSERT(m_pGIT);
	    }
#else
	inline void AssertValid() const {}
#endif
    };

/*===================================================================
  CGlobalInterfaceAPI inlines
===================================================================*/

inline HRESULT CGlobalInterfaceAPI::Register
(
IUnknown *pUnk,
REFIID riid,
DWORD *pdwCookie
)
    {
    AssertValid();
    return m_pGIT->RegisterInterfaceInGlobal(pUnk, riid, pdwCookie);
    }

inline HRESULT CGlobalInterfaceAPI::Get
(
DWORD dwCookie,
REFIID riid, 
void **ppv
)
    {
    AssertValid();
    return m_pGIT->GetInterfaceFromGlobal(dwCookie, riid, ppv);
    }
        
inline HRESULT CGlobalInterfaceAPI::Revoke
(
DWORD dwCookie
)
    {
    AssertValid();
    return m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
    }

/*===================================================================
  Globals
===================================================================*/

extern CGlobalInterfaceAPI g_GIPAPI;

#endif  // _ASP_GIP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\gip.cxx ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.cpp

Owner: DmitryR

This is the GIP source file.
===================================================================*/

#include "w3p.hxx"
#include "gip.h"

/*===================================================================
  Globals
===================================================================*/

CGlobalInterfaceAPI g_GIPAPI;

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

/*===================================================================
CGlobalInterfaceAPI::CGlobalInterfaceAPI

CGlobalInterfaceAPI constructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::CGlobalInterfaceAPI() 
    : m_fInited(FALSE), m_pGIT(NULL)
    {
    }
    
/*===================================================================
CGlobalInterfaceAPI::~CGlobalInterfaceAPI

CGlobalInterfaceAPI destructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::~CGlobalInterfaceAPI()
    {
    UnInit();
    }

/*===================================================================
CGlobalInterfaceAPI::Init

Creates instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CGlobalInterfaceAPI::Init()
    {
    IF_DEBUG( SERVICE_CTRL )
        DBGPRINTF(( DBG_CONTEXT, "CGlobalInterfaceAPI::Init()\n"));
    DBG_ASSERT(!m_fInited); // don't init twice
    
    HRESULT hr = CoCreateInstance
        (
        CLSID_StdGlobalInterfaceTable,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGlobalInterfaceTable,
        (void **)&m_pGIT
        );
        
    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        m_pGIT = NULL;

    return hr;
    }

/*===================================================================
CGlobalInterfaceAPI::UnInit

Releases instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT (NOERROR)
===================================================================*/	
HRESULT CGlobalInterfaceAPI::UnInit()
    {
    IF_DEBUG( SERVICE_CTRL )
        DBGPRINTF(( DBG_CONTEXT, "CGlobalInterfaceAPI::UnInit()\n"));
    if (m_pGIT)
        {
        m_pGIT->Release();
        m_pGIT = NULL;
        }

    m_fInited = FALSE;
    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\globals.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        globals.cxx

   Abstract:

        This module contains global variable definitions shared by the
        various W3 Service components.

   Author:
        KeithMo     07-Mar-1993 Created.

--*/

#include "w3p.hxx"
#include <time.h>
#include <timer.h>

//
//  Locks
//

CRITICAL_SECTION csGlobalLock;

//
//  User database related data.
//

DWORD            cConnectedUsers = 0;           // Current connections.

//
//  Connection information related data.
//

LIST_ENTRY       listConnections;

//
//  Miscellaneous data.
//

LARGE_INTEGER    AllocationGranularity;         // Page allocation granularity.
HANDLE           g_hSysAccToken = NULL;
TCHAR          * g_pszW3TempDirName = NULL;     // Name of temporary directory.
static BOOL      l_bTempDirAlloced = FALSE;

//
// Server type string
//

CHAR g_szServerType[ sizeof(MSW3_VERSION_STR_MAX)];
DWORD g_cbServerType = 0;

CHAR szServerVersion[sizeof(MAKE_VERSION_STRING(MSW3_VERSION_STR_MAX))];
DWORD cbServerVersionString = 0;

STR* g_pstrMovedMessage;

//
// Whether or not to send HTTP 1.1
//

DWORD g_ReplyWith11;

//
// Whether or not to use TransmitFileAndRecv
//

DWORD g_fUseAndRecv;

//
// PUT/DELETE event timeout.
//

DWORD    g_dwPutEventTimeout;
CHAR     g_szPutTimeoutString[17];
DWORD    g_dwPutTimeoutStrlen;

//
// Platform type
//

PLATFORM_TYPE W3PlatformType = PtNtServer;
BOOL g_fIsWindows95 = FALSE;

//
// Statistics.
// used to write statistics counter values to when instance is unknown
//

LPW3_SERVER_STATISTICS  g_pW3Stats;

extern BOOL fAnySecureFilters;

//
// Generate the string storage space
//

# include "strconst.h"
# define CStrM( FriendlyName, ActualString)   \
   const char  PSZ_ ## FriendlyName[] = ActualString;

ConstantStringsForThisModule()

# undef CStrM

//
// Header Date time cache
//

PW3_DATETIME_CACHE    g_pDateTimeCache = NULL;
//
// Downlevel Client Support (no HOST header support)
//

BOOL    g_fDLCSupport;
TCHAR*  g_pszDLCMenu;
DWORD   g_cbDLCMenu;
TCHAR*  g_pszDLCHostName;
DWORD   g_cbDLCHostName;
TCHAR*  g_pszDLCCookieMenuDocument;
DWORD   g_cbDLCCookieMenuDocument;
TCHAR*  g_pszDLCMungeMenuDocument;
DWORD   g_cbDLCMungeMenuDocument;
TCHAR*  g_pszDLCCookieName;
DWORD   g_cbDLCCookieName;


//
// Notification object used to watch for changes in CAPI stores
//
STORE_CHANGE_NOTIFIER *g_pStoreChangeNotifier;

//
// CPU accounting/limits globals
//

DWORD   g_dwNumProcessors = 1;

//
// Maximum client request buffer size
//

DWORD   g_cbMaxClientRequestBuffer = W3_DEFAULT_MAX_CLIENT_REQUEST_BUFFER;

//
// Should we get stack back traces when appropriate?
//

BOOL    g_fGetBackTraces = FALSE;

//
// WAM Event Log
//
EVENT_LOG *g_pWamEventLog = NULL;

//
//  Public functions.
//

APIERR
InitializeGlobals(
            VOID
            )

/*++

Routine Description:

    Initializes global shared variables.  Some values are
        initialized with constants, others are read from the
        configuration registry.

Arguments:

    None.

Return Value:

    Win32

--*/
{
    DWORD  err;
    HKEY   hkey;

    //
    // Initialize the server version string based on the platform type
    //

    W3PlatformType =  IISGetPlatformType();

    switch ( W3PlatformType ) {

    case PtNtWorkstation:
        strcpy(szServerVersion,MAKE_VERSION_STRING(MSW3_VERSION_STR_NTW));
        strcpy(g_szServerType, MSW3_VERSION_STR_NTW);
        break;

    case PtWindows95:
    case PtWindows9x:
        strcpy(szServerVersion,MAKE_VERSION_STRING(MSW3_VERSION_STR_W95));
        strcpy(g_szServerType, MSW3_VERSION_STR_W95);
        g_fIsWindows95 = TRUE;
        break;

    default:

        //
        // Either server or unhandled platform type!
        //

        DBG_ASSERT(InetIsNtServer(W3PlatformType));
        strcpy(szServerVersion,MAKE_VERSION_STRING(MSW3_VERSION_STR_IIS));
        strcpy(g_szServerType, MSW3_VERSION_STR_IIS);
    }

    g_cbServerType = strlen( g_szServerType);
    cbServerVersionString = strlen(szServerVersion);

    //
    //  Create global locks.
    //

    INITIALIZE_CRITICAL_SECTION( &csGlobalLock );

    //
    //  Initialize the connection list
    //

    InitializeListHead( &listConnections );

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        W3_PARAMETERS_KEY,
                        0,
                        KEY_READ,
                        &hkey );

    if ( !err )
    {

        BOOL Success = ReadRegString( hkey,
                            &g_pszW3TempDirName,
                            W3_TEMP_DIR_NAME,
                            "" );

        if ( !Success || !g_pszW3TempDirName || !*g_pszW3TempDirName )
        {
            DWORD dwTempDirNameLength;

            if ( l_bTempDirAlloced && g_pszW3TempDirName )
            {
                TCP_FREE( g_pszW3TempDirName );
                g_pszW3TempDirName = NULL;
            }

            l_bTempDirAlloced = FALSE;

            dwTempDirNameLength = GetTempPath( 0,
                                               NULL
                                             );
            if ( dwTempDirNameLength == 0)
            {
                g_pszW3TempDirName = ".\\";
            } else
            {
                DWORD           dwTemp = dwTempDirNameLength + 1;

                g_pszW3TempDirName = (TCHAR *) TCP_ALLOC(dwTemp * sizeof(TCHAR));

                if (g_pszW3TempDirName == NULL)
                {
                    g_pszW3TempDirName = ".\\";
                } else
                {
                    l_bTempDirAlloced = TRUE;
                    dwTempDirNameLength = GetTempPath( dwTemp,
                                                        g_pszW3TempDirName
                                                     );
                    if ( dwTempDirNameLength == 0 ||
                            dwTempDirNameLength > dwTemp)
                    {
                        TCP_FREE( g_pszW3TempDirName );
                        g_pszW3TempDirName = ".\\";
                        l_bTempDirAlloced = FALSE;
                    }
                }
            }
        }


#ifdef _NO_TRACING_
#if DBG
        DWORD Debug = ReadRegistryDword( hkey,
                                         W3_DEBUG_FLAGS,
                                         DEFAULT_DEBUG_FLAGS
                                         );
        SET_DEBUG_FLAGS (Debug);
#endif  // DBG
#endif

        g_ReplyWith11 = ReadRegistryDword(hkey,
                                        W3_VERSION_11,
                                        DEFAULT_SEND_11
                                        );

        g_dwPutEventTimeout = ReadRegistryDword(hkey,
                                        W3_PUT_TIMEOUT,
                                        DEFAULT_PUT_TIMEOUT
                                        );

        _itoa(g_dwPutEventTimeout, g_szPutTimeoutString, 10);

        g_dwPutTimeoutStrlen = strlen(g_szPutTimeoutString);

        //
        // See if we should use TransmitFileAndRecv
        //
        g_fUseAndRecv = ReadRegistryDword(hkey,
                                  W3_USE_ANDRECV,
                                  DEFAULT_USE_ANDRECV
                                  );

        //
        // Read globals for down level client support
        //

        g_fDLCSupport = !!ReadRegistryDword( hkey,
                                             W3_DLC_SUPPORT,
                                             0 );

        if ( !ReadRegString( hkey,
                             &g_pszDLCMenu,
                             W3_DLC_MENU_STRING,
                             "" ) )
        {
            return GetLastError();
        }
        g_cbDLCMenu = strlen( g_pszDLCMenu );

        if ( !ReadRegString( hkey,
                             &g_pszDLCHostName,
                             W3_DLC_HOSTNAME_STRING,
                             "" ) )
        {
            return GetLastError();
        }
        g_cbDLCHostName = strlen( g_pszDLCHostName );

        if ( !ReadRegString( hkey,
                             &g_pszDLCCookieMenuDocument,
                             W3_DLC_COOKIE_MENU_DOCUMENT_STRING,
                             "" ) )
        {
            return GetLastError();
        }
        g_cbDLCCookieMenuDocument = strlen( g_pszDLCCookieMenuDocument );

        if ( !ReadRegString( hkey,
                             &g_pszDLCMungeMenuDocument,
                             W3_DLC_MUNGE_MENU_DOCUMENT_STRING,
                             "" ) )
        {
            return GetLastError();
        }
        g_cbDLCMungeMenuDocument = strlen( g_pszDLCMungeMenuDocument );

        if ( !ReadRegString( hkey,
                             &g_pszDLCCookieName,
                             W3_DLC_COOKIE_NAME_STRING,
                             DLC_DEFAULT_COOKIE_NAME ) )
        {
            return GetLastError();
        }
        g_cbDLCCookieName = strlen( g_pszDLCCookieName );

        g_cbMaxClientRequestBuffer = ReadRegistryDword( 
                                        hkey,
                                        W3_MAX_CLIENT_REQUEST_BUFFER_STRING,
                                        W3_DEFAULT_MAX_CLIENT_REQUEST_BUFFER );

        g_fGetBackTraces = ReadRegistryDword( hkey,
                                              W3_GET_BACKTRACES,
                                              g_fGetBackTraces );

        TCP_REQUIRE( !RegCloseKey( hkey ));
    }

    g_pstrMovedMessage = NULL;

    //
    // Create statistics object
    //

    g_pW3Stats = new W3_SERVER_STATISTICS();

    if ( g_pW3Stats == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Get access token for system account
    //

    if ( !OpenProcessToken (
                 GetCurrentProcess(),
                 TOKEN_ALL_ACCESS,
                 &g_hSysAccToken
                 ) )
    {
        g_hSysAccToken = NULL;
    }

    //
    // Initialize the datetime cache
    //

    g_pDateTimeCache = new W3_DATETIME_CACHE;

    if ( g_pDateTimeCache == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Create the CAPI store notification object
    //
    g_pStoreChangeNotifier = new STORE_CHANGE_NOTIFIER();

    if ( g_pStoreChangeNotifier == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Get the CPU Accounting/Limits information
    //

    SYSTEM_INFO siInfo;

    GetSystemInfo(&siInfo);

    //
    // GetSystemInfo does not return any value, have to assume it succeeded.
    //

    g_dwNumProcessors = siInfo.dwNumberOfProcessors;

    //
    //  Success!
    //

    return NO_ERROR;

}   // InitializeGlobals


VOID
TerminateGlobals(
            VOID
            )

/*++

Routine Description:

    Terminates global shared variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( g_pDateTimeCache != NULL ) {
        delete g_pDateTimeCache;
        g_pDateTimeCache = NULL;
    }

    if( g_pW3Stats != NULL )
    {
        delete g_pW3Stats;
        g_pW3Stats = NULL;
    }

    if ( g_hSysAccToken )
    {
        CloseHandle( g_hSysAccToken );
        g_hSysAccToken = NULL;
    }

    if ( g_pszDLCMenu != NULL )
    {
        TCP_FREE( g_pszDLCMenu );
        g_pszDLCMenu = NULL;
    }

    if ( g_pszDLCHostName != NULL )
    {
        TCP_FREE( g_pszDLCHostName );
        g_pszDLCHostName = NULL;
    }

    if ( g_pszDLCCookieMenuDocument != NULL )
    {
        TCP_FREE( g_pszDLCCookieMenuDocument );
        g_pszDLCCookieMenuDocument = NULL;
    }

    if ( g_pszDLCMungeMenuDocument != NULL )
    {
        TCP_FREE( g_pszDLCMungeMenuDocument );
        g_pszDLCMungeMenuDocument = NULL;
    }

    if ( g_pszDLCCookieName != NULL )
    {
        TCP_FREE( g_pszDLCCookieName );
        g_pszDLCCookieName = NULL;
    }

    if ( g_pStoreChangeNotifier )
    {
        delete g_pStoreChangeNotifier;
        g_pStoreChangeNotifier = NULL;
    }

    if ( l_bTempDirAlloced && g_pszW3TempDirName )
    {
        TCP_FREE( g_pszW3TempDirName );
        g_pszW3TempDirName = NULL;
        l_bTempDirAlloced = FALSE;
    }

    TerminateFilters();

    W3_LIMIT_JOB_THREAD::TerminateLimitJobThread();

    W3_JOB_QUEUE::TerminateJobQueue();

    //
    //  Dump heap residue.
    //

    TCP_DUMP_RESIDUE( );

    if( g_pWamEventLog ) {
        delete g_pWamEventLog;
        g_pWamEventLog = NULL;
    }

    //
    //  Delete global locks.
    //

    DeleteCriticalSection( &csGlobalLock );

}   // TerminateGlobals
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\httpio.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    httpio.cxx

    This module contains the IO related http class methods


    FILE HISTORY:
        Johnl       09-Feb-1995     Created

*/


#include <w3p.hxx>

#include <issperr.h>

//
// Size of read during cert renegotiation phase
//

#define CERT_RENEGO_READ_SIZE   (1024*4)

//
// size of buffer for calls to GetTokenInformation
//

#define MAX_TOKEN_USER_INFO   (300)


BOOL
HTTP_REQ_BASE::StartNewRequest(
    PVOID  pvInitialBuff,
    DWORD  cbInitialBuff,
    BOOL   fFirst,
    BOOL   *pfDoAgain
    )
/*++

Routine Description:

    Sets up this request object for reading a new request and issues the async
    read to kick things off.

Arguments:

--*/
{
    //
    //  Set our initial state and variables for a new request, after
    //  checking to see if we might have a pipelined request.
    //

    if (!fFirst && (_cbBytesReceived > _cbClientRequest))
    {
        CHAR        *pchRequestPtr;
        DWORD       dwNextRequestSize = 0;

        // Might possibly have a pipelined request. We do if there is
        // no entity body or there is but we didn't consume all of
        // the entity body on the previous request.
        //

        if (!IsChunked() && (QueryTotalEntityBodyCB() == 0))
        {
            //
            // Have a pipelined request and the last request wasn't chunked, 
            // since we read more data than just the request header but there was 
            // no entity body with the request.
            //

            dwNextRequestSize = _cbBytesReceived - _cbClientRequest;

            pchRequestPtr = (CHAR *)_bufClientRequest.QueryPtr() +
                                _cbClientRequest;


        }
        else
        {
            if (_cbExtraData != 0)
            {
                // Have extra data in the buffer, so have a pipelined
                // request.

                pchRequestPtr = _pchExtraData;
                dwNextRequestSize = _cbExtraData;
            }
        }

        // Update bytes received to reflect what we would have seen
        // in the non-pipelined case.

        _cbBytesReceived -= dwNextRequestSize;

        //
        // If we have a pipelined request, copy the request forward and
        // update the counts.
        //

        if (dwNextRequestSize != 0)
        {
            Reset(FALSE);

            memcpy((CHAR *)_bufClientRequest.QueryPtr(),
                    pchRequestPtr,
                    dwNextRequestSize);


            _cbBytesWritten = dwNextRequestSize;

            // Return, forcing the reprocess.
            *pfDoAgain = TRUE;
            return TRUE;
        }
    }

    Reset(TRUE);

    *pfDoAgain = FALSE;

    //
    //  Prepare a buffer to receive the client's request
    //

    if ( !_bufClientRequest.Resize( max( W3_DEFAULT_BUFFSIZE, cbInitialBuff )))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[StartNewRequest] failed to allocate buffer, error %lu\n",
                    GetLastError()));

        return FALSE;
    }

    //
    //  Make the IO request if an inital buffer wasn't supplied
    //

    if ( pvInitialBuff != NULL )
    {
        CopyMemory(
                _bufClientRequest.QueryPtr(),
                pvInitialBuff,
                cbInitialBuff );

        _cbBytesWritten = cbInitialBuff;
    }
    else
    {
        SetState( HTR_READING_CLIENT_REQUEST );

        IF_DEBUG( CONNECTION )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[StartNewRequest] Issuing initial read, Conn = %lx, AtqCont = %lx\n",
                         QueryClientConn(),
                         QueryClientConn()->QueryAtqContext() ));
        }

        //
        //  Do the initial read.  We don't go through any filters at this
        //  point.  They'll get notified on the read completion as part of
        //  the raw data notification.
        //

        if ( !ReadFile( _bufClientRequest.QueryPtr(),
                        _bufClientRequest.QuerySize(),
                        NULL,
                        IO_FLAG_ASYNC | IO_FLAG_NO_FILTER))
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[StartNewRequest] ReadFile failed, error %lu\n",
                        GetLastError() ));

            return FALSE;
        }
    }

    return TRUE;
}

/*******************************************************************

    NAME:       HTTP_REQ_BASE::OnFillClientReq

    SYNOPSIS:   Waits for the full client request packet then decides
                the course of action

    ENTRY:      pfCompleteRequest - Set to TRUE if we've received a full
                    client request and we can start processing the request
                pfFinished - Set to TRUE if no further processing is requred
                pfContinueProcessingRequest  - Set to FALSE if we must stop processing
                     request

    RETURNS:    TRUE if processing should continue, FALSE to abort the
                this connection

    HISTORY:
        Johnl       22-Aug-1994 Created

********************************************************************/

BOOL
HTTP_REQ_BASE::OnFillClientReq(
    BOOL * pfCompleteRequest,
    BOOL * pfFinished,
    BOOL * pfContinueProcessingRequest
    )
{
    BYTE *    pbData = NULL;

    *pfCompleteRequest = FALSE;
    *pfContinueProcessingRequest = TRUE;
    _cbClientRequest += QueryBytesWritten();

    //
    //  If no bytes were read on the last request, then the socket has been
    //  closed, so abort everything and get out
    //

    if ( QueryBytesWritten() == 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[OnFillClientReq] Client socket closed while reading request (Conn = %lx)\n",
                    QueryClientConn() ));

        SetKeepConn( FALSE );
        *pfFinished = TRUE;
        return TRUE;
    }

    //NTBUG 264445  QFE and NTBUG 266474
    _msStartRequest = GetCurrentTime();

    if ( !UnWrapRequest( pfCompleteRequest,
                         pfFinished,
                         pfContinueProcessingRequest))
    {
        return FALSE;
    }

    if ( *pfCompleteRequest || *pfFinished || !*pfContinueProcessingRequest)
    {
        return TRUE;
    }

    //
    //  We still don't have a complete header, so keep reading
    //

    DBG_ASSERT(!*pfCompleteRequest);


    if ( !ReadFile( (BYTE *)_bufClientRequest.QueryPtr() + _cbClientRequest,
                    _bufClientRequest.QuerySize() - _cbClientRequest,
                    NULL,
                    IO_FLAG_ASYNC | IO_FLAG_NO_FILTER ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[OnFillClientReq] ReadFile failed, error %lu\n",
                    GetLastError() ));

        return FALSE;
    }

    return TRUE;
}


BOOL
HTTP_REQ_BASE::HandleCertRenegotiation(
    BOOL * pfFinished,
    BOOL * pfContinueProcessingRequest,
    DWORD cbData
    )
/*++

Routine Description:

    Calls the installed read filters

Arguments:

    pfFinished - No further processing is required for this request
    pfContinueProcessingRequest - Set to FALSE if we have must stop processing request

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BYTE *    pbData = NULL;
    TCHAR *   pchOutRequest;
    DWORD     cbOutRequest;
    DWORD     cbProcessed;
    BOOL      fTerminated;
    BOOL      fReadAgain = FALSE;
    TCHAR *   pchNewData;
    DWORD     cbOutRequestSave;


    *pfContinueProcessingRequest = TRUE;

    //
    //  If no bytes were read on the last request, then the socket has been
    //  closed, so abort everything and get out
    //

    if ( QueryBytesWritten() == 0 )
    {
        TCP_PRINT(( DBG_CONTEXT,
                    "[HandleCertRenegotiation] Client socket closed while reading request (Conn = %lx)\n",
                    QueryClientConn() ));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Notify any opaque filters of the incoming data
    //

    cbProcessed = _cbClientRequest + _cbEntityBody;
    pchNewData = (LPSTR)_bufClientRequest.QueryPtr() + cbProcessed;

    if ( !_Filter.NotifyRawReadDataFilters(
                         pchNewData,
                         (cbOutRequestSave = _cbOldData + cbData - cbProcessed),
                         _bufClientRequest.QuerySize() -
                             cbProcessed,            // Usable buffer size
                         (PVOID *) &pchOutRequest,
                         &cbOutRequest,
                         pfFinished,
                         &fReadAgain ))
    {
        return FALSE;
    }

    if ( *pfFinished )
    {
        return TRUE;
    }

    //
    //  If the output buffer is different, then we need to copy
    //  the data to our output buffer
    //
    //  CODEWORK: Get rid of this buffer copy - there are assumptions the
    //  incoming data is contained in _bufClientRequest
    //

    if ( pchOutRequest != NULL &&
         pchOutRequest != pchNewData )
    {
        if ( !_bufClientRequest.Resize( cbOutRequest + cbProcessed + 1 ))
            return FALSE;
            
        pchNewData = (LPSTR)_bufClientRequest.QueryPtr() + cbProcessed;
        memcpy( pchNewData,
                pchOutRequest,
                cbOutRequest );
    }

    if ( fReadAgain )
    {
        _cbOldData = cbProcessed + cbOutRequest;
        goto nextread;
    }

    //
    //  A filter may have changed the size of our effective input buffer
    //

    _cbEntityBody += cbOutRequest;
    _cbOldData = _cbClientRequest + _cbEntityBody;

    if ( cbOutRequestSave > cbOutRequest )
    {
        DBG_ASSERT( _cbBytesReceived >= cbOutRequestSave - cbOutRequest );

        _cbBytesReceived -= cbOutRequestSave - cbOutRequest;
    }
    else
    {
        _cbBytesReceived += cbOutRequest - cbOutRequestSave;
    }

    if ( _dwRenegotiated )
    {
        cbData = _cbEntityBody;
        _cbRestartBytesWritten = cbData;
        _cbEntityBody = 0;

        return OnRestartRequest( (LPSTR)_bufClientRequest.QueryPtr(),
                                 cbData,
                                 pfFinished,
                                 pfContinueProcessingRequest );
    }

nextread:

    DWORD cbNextRead = CERT_RENEGO_READ_SIZE;

    if ( !_bufClientRequest.Resize( _cbOldData + cbNextRead ))
    {
        return FALSE;
    }

    *pfContinueProcessingRequest = FALSE;

    if ( !ReadFile( (BYTE *) _bufClientRequest.QueryPtr() + _cbOldData,
                    cbNextRead,
                    NULL,
                    IO_FLAG_ASYNC|IO_FLAG_NO_FILTER ))
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
HTTP_REQ_BASE::UnWrapRequest(
    BOOL * pfCompleteRequest,
    BOOL * pfFinished,
    BOOL * pfContinueProcessingRequest
    )
/*++

Routine Description:

    Calls the installed filters to unwrap the client request

Arguments:

    pfCompleteRequest - Set to TRUE if we've received a full
        client request and we can start processing the request
    pfFinished - No further processing is required for this request
    pfContinueProcessingRequest - Set to FALSE if we're done for now

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BOOL      fHandled = FALSE;
    TCHAR *   pchOutRequest;
    DWORD     cbOutRequest;
    BOOL      fTerminated = FALSE;
    BOOL      fReadAgain;

    //
    //  Notify any opaque filters of the incoming data
    //

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_READ_RAW_DATA,
                                       IsSecurePort() ))
    {
        DWORD cbOutRequestSave;

        //
        //  Make sure filters don't see the same data twice unless they
        //  returned "read again" the last time
        //

        CHAR * pchNewData = (CHAR *) _bufClientRequest.QueryPtr() +
                            _cbOldData;

        pchOutRequest = pchNewData;
        cbOutRequestSave = cbOutRequest = _cbClientRequest - _cbOldData;
        fReadAgain   = FALSE;

        if ( !_Filter.NotifyRawReadDataFilters(
                             pchNewData,
                             cbOutRequest,
                             _bufClientRequest.QuerySize() -
                                 _cbOldData,            // Usable buffer size
                             (PVOID *) &pchOutRequest,
                             &cbOutRequest,
                             &fHandled,
                             &fReadAgain ))
        {
            return FALSE;
        }

        if ( fHandled )
        {
            *pfContinueProcessingRequest = FALSE;
            return TRUE;
        }

        //
        //  If the output buffer is different, then we need to copy
        //  the data to our output buffer
        //
        //  CODEWORK: Get rid of this buffer copy - there are assumptions the
        //  incoming data is contained in _bufClientRequest
        //

        if ( pchOutRequest != NULL &&
             pchOutRequest != pchNewData )
        {
            if ( !_bufClientRequest.Resize( cbOutRequest + _cbOldData + 1 ))
                return FALSE;

            pchNewData = (CHAR *) _bufClientRequest.QueryPtr() +
                         _cbOldData;
            memcpy( pchNewData,
                    pchOutRequest,
                    cbOutRequest );
        }

        //
        //  A filter may have changed the size of our effective input buffer
        //

        if ( cbOutRequestSave > cbOutRequest )
        {
            DBG_ASSERT(_cbBytesReceived >= cbOutRequestSave - cbOutRequest);
            _cbBytesReceived -= cbOutRequestSave - cbOutRequest;
        }
        else
        {
            _cbBytesReceived += cbOutRequest - cbOutRequestSave;
        }

        //
        // Variable names are not consistent with what is used
        // in HandleCertRenegotiation : here _cbClientRequest
        // indicates where to continue reading data, and _cbOldData
        // is # of decoded bytes in client request
        //

        _cbClientRequest = cbOutRequest + _cbOldData;

        //
        //  Can we continue processing this request?  The message just received
        //  may have been a session negotiation message and we have yet to
        //  receive the real HTTP request.
        //

        if ( fReadAgain )
        {
            //
            //  Resize the read buffer and issue an async read to get the next
            //  chunk for the filter.  UnwrapRequest uses the size of
            //  this buffer as the size of data to read
            //

            if ( !_bufClientRequest.Resize( _cbClientRequest +
                                            _Filter.QueryNextReadSize() ))
            {
                return FALSE;
            }

            return TRUE;
        }
    }

    //
    //  Remember how much data the filter has already seen so we don't
    //  renotify them with the same data in case we don't have a full
    //  set of headers
    //

    _cbOldData = _cbClientRequest;

    if ( !CheckForTermination( &fTerminated,
                               &_bufClientRequest,
                               _cbClientRequest,
                               NULL,
                               NULL,
                               W3_DEFAULT_BUFFSIZE ) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            SetState( HTR_DONE, HT_BAD_REQUEST, ERROR_INSUFFICIENT_BUFFER );
            Disconnect( HT_BAD_REQUEST, NO_ERROR, TRUE, pfFinished );
            *pfCompleteRequest = TRUE;
            *pfContinueProcessingRequest = FALSE;
            return TRUE;
        }
        return FALSE;
    }

    if ( !fTerminated && !::IsPointNine( (CHAR *) _bufClientRequest.QueryPtr() ) )
    {
        //
        //  We don't have a complete request, read more data
        //

        return TRUE;
    }

    *pfCompleteRequest = TRUE;

    return OnCompleteRequest( (CHAR *) _bufClientRequest.QueryPtr(),
                              _cbClientRequest,
                              pfFinished,
                              pfContinueProcessingRequest );
}

/*******************************************************************

    NAME:       HTTP_REQ_BASE::ReadMoreEntityBody

    SYNOPSIS:   Attempts to read more of the entity body, resizing
                the buffer if necessary

    ENTRY:      cbOffset - Offset in the buffer to read at.
                cbSize   - Size to read.

********************************************************************/

BOOL
HTTP_REQ_BASE::ReadMoreEntityBody(
    DWORD   cbOffset,
    DWORD   cbSize
    )
{
    if ( cbOffset + cbSize < cbSize )
    {
        //
        // The counter wrapped. Entity Body is greater than the address space !!
        //

        return FALSE;
    }
    
    if ( _bufClientRequest.QuerySize() < (cbOffset + cbSize) )
    {
        if ( !_bufClientRequest.Resize( cbOffset + cbSize ) )
        {
            return FALSE;
        }
    }

    if ( !ReadFile( (BYTE *) _bufClientRequest.QueryPtr() + cbOffset,
                            cbSize,
                            NULL,
                            IO_FLAG_ASYNC ))
    {
        return FALSE;
    }

    return TRUE;
}

/*******************************************************************

    NAME:       HTTP_REQ_BASE::ReadEntityBody

    SYNOPSIS:   Attempts to retrieve an entity body from the remote
                client

    ENTRY:      pfDone - Set to TRUE when _cbContentLength bytes have
                    been read
                fFirstRead - TRUE if this is the first read, FALSE on
                    subsequent reads.
                dwMaxAmmountToRead - Finish when this amount is read
                pfDisconnected - Set to TRUE if we disconnected (due to error)

    HISTORY:
        Johnl       03-Oct-1994 Created

********************************************************************/

BOOL
HTTP_REQ_BASE::ReadEntityBody(
    BOOL *pfDone,
    BOOL  fFirstRead,
    DWORD dwMaxAmountToRead,
    BOOL *pfDisconnected
    )
{
    DWORD cbNextRead;

    if ( pfDisconnected )
    {
        *pfDisconnected = FALSE;
    }

    if (dwMaxAmountToRead == 0)
    {
        dwMaxAmountToRead = QueryMetaData()->QueryUploadReadAhead();
    }

    if (!IsChunked())
    {

        _cbEntityBody += QueryBytesWritten();
        _cbTotalEntityBody += QueryBytesWritten();

        if ( _cbTotalEntityBody >= _cbContentLength)
        {
            //
            // Ugh - disgusting, but if we have no content length then
            // we take whatever we have in the buffer currently and return
            // it. This can lead to random behavior, depending on what
            // actually makes it in the first read. I hate to do this, but
            // we're doing it this way because of bug-for-bug compatibility
            // with IIS 3.0. Probably the right thing to do if we have no
            // content length is to keep reading until we get 0 bytes read,
            // and return whatever we read as the content length. JohnL
            // argues that the right thing is to fail the request in the
            // absence of a content length.

            if (_fHaveContentLength && (_cbTotalEntityBody > _cbContentLength))
            {
                _cbExtraData = _cbTotalEntityBody - _cbContentLength;

                DBG_ASSERT(_cbExtraData <= _cbEntityBody);

                _cbEntityBody -= _cbExtraData;

                _pchExtraData = (CHAR *)_bufClientRequest.QueryPtr() +
                                    _cbClientRequest +
                                    _cbEntityBody;

                _cbTotalEntityBody = _cbContentLength;
            }

            *pfDone = TRUE;
            return TRUE;
        }

        if (_cbEntityBody >= dwMaxAmountToRead)
        {

            *pfDone = TRUE;
            return TRUE;
        }

        //
        //  If no bytes were read on the last request, then the socket has been
        //  closed, so abort everything and get out
        //

        if ( !fFirstRead && QueryBytesWritten() == 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[ReadEntityBody] Client socket closed while reading request (Conn = %lx)\n",
                        QueryClientConn() ));

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        *pfDone = FALSE;

        cbNextRead = min( (dwMaxAmountToRead - _cbEntityBody),
                          (_cbContentLength - _cbTotalEntityBody ));

        if ( _bufClientRequest.QuerySize() <
              (_cbClientRequest + _cbEntityBody + cbNextRead))
        {
            if ( !_bufClientRequest.Resize( _cbClientRequest + _cbEntityBody + cbNextRead ))
            {
                return FALSE;
            }
        }

        if ( !ReadFile( (BYTE *) _bufClientRequest.QueryPtr() + _cbEntityBody +
                                                                _cbClientRequest,
                        cbNextRead,
                        NULL,
                        IO_FLAG_ASYNC ))
        {
            return FALSE;
        }

        return TRUE;
    } else
    {
        DWORD       cbBytesInBuffer;
        BYTE        *ChunkHeader;

        *pfDone = FALSE;

        // We'll just return here if the app says they want to
        // read it all. This might not be the right thing to do unless
        // they also call this routine to read the rest of the data,
        // because there could be a partial chunk in here. So we'll
        // make sure that there isn't, or force the client to send a
        // C-L.

        if (dwMaxAmountToRead == 0)
        {
            if (QueryBytesWritten() != 0)
            {
                SetState( HTR_DONE, HT_LENGTH_REQUIRED, ERROR_NOT_SUPPORTED );

                Disconnect( HT_LENGTH_REQUIRED, IDS_LENGTH_REQUIRED, FALSE, pfDone );
                if ( pfDisconnected )
                {
                    *pfDisconnected = TRUE;
                }                
            }
            else
            {
                *pfDone = TRUE;
            }

            return TRUE;
        }

        if (_ChunkState == READ_CHUNK_DONE)
        {

            *pfDone = TRUE;
            return TRUE;
        }


        if ( fFirstRead )
        {
            // Initialize our state variables, as this is the start of a chunk.
            _ChunkState = READ_CHUNK_SIZE;
            _dwChunkSize = -1;
            _cbChunkHeader = 0;
            _cbChunkBytesRead = 0;
            _cbEntityBody = 0;

        } else
        {
            if ( QueryBytesWritten() == 0 )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[ReadEntityBody] Client socket closed while reading request (Conn = %lx)\n",
                            QueryClientConn() ));

                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
        }


        *pfDone = FALSE;

        cbBytesInBuffer = QueryBytesWritten();

        ChunkHeader = (BYTE *)_bufClientRequest.QueryPtr() + _cbChunkHeader +
                                    + _cbEntityBody + _cbClientRequest;

        if(!DecodeChunkedBytes(ChunkHeader, &cbBytesInBuffer)) {
            // error in chunked data
            DBGPRINTF(( DBG_CONTEXT, "Error in chunked data at %d\r\n", 
                _cbEntityBody ));
            SetState( HTR_DONE, HT_BAD_REQUEST, ERROR_NOT_SUPPORTED );
            Disconnect( HT_BAD_REQUEST, IDS_HTRESP_BAD_REQUEST, FALSE, pfDone );
            if ( pfDisconnected )
            {
                *pfDisconnected = TRUE;
            }
            return TRUE;
        }

        _cbEntityBody += cbBytesInBuffer;
        _cbTotalEntityBody += cbBytesInBuffer;
        
        if( _cbEntityBody < dwMaxAmountToRead && 
            _ChunkState != READ_CHUNK_DONE ) 
        {
            cbNextRead = dwMaxAmountToRead - _cbEntityBody;
            
            if(cbNextRead < CHUNK_READ_SIZE) {
                cbNextRead = CHUNK_READ_SIZE;
            }
            
            return ReadMoreEntityBody(
                    _cbClientRequest + _cbChunkHeader + _cbEntityBody,
                    cbNextRead);
                
        } else {
        
            // We've read enough data
            *pfDone = TRUE;
            return TRUE;
        }

        
    }

    return TRUE;
}


/*******************************************************************

    NAME:       HTTP_REQ_BASE::DecodeChunkedBytes
    
    SYNOPSIS:   Decodes specified number of chunked bytes in-place,
                using member variables to keep track of the state
    
    ENTRY:      lpBuffer - points to first encoded byte 
                lpnBytes - points to count of encoded bytes
                
    EXIT:       lpnBytes - points to count of decoded bytes               
                
********************************************************************/
BOOL
HTTP_REQ_BASE::DecodeChunkedBytes(
    LPBYTE      lpBuffer,
    LPDWORD     pnBytes
    )
{
    DWORD cbBytesToDecode;
    DWORD cbBytesDecoded, cb;
    LPBYTE lpCurrent, lpData;
    BYTE Current;
    BOOL fSuccess = TRUE;
    

    // Cache the count of bytes to decode
    cbBytesToDecode = *pnBytes;

    // Setup our running buffer pointer and data pointer
    lpCurrent = lpBuffer;
    lpData = lpBuffer;
    
    // No data decoded
    cbBytesDecoded = 0;

    // while we have unprocessed data
    while( cbBytesToDecode ) {
    
        switch( _ChunkState ) {
        
        case READ_CHUNK_SIZE:
        
            while( cbBytesToDecode ) {
                Current = *lpCurrent;
                
                if( isxdigit( (UCHAR)Current ) ) {
                

                    if( _dwChunkSize == -1 ) {
                        _dwChunkSize = 0;
                    }
                    
                    // Adjust chunk size, count off consumed byte
                    _dwChunkSize = (_dwChunkSize * 16) + 
                        ( isdigit( (UCHAR)Current ) ? Current - '0' : 
                                        ( Current | 0x20 ) - 'a' + 10 );
                    lpCurrent++;
                    cbBytesToDecode--;
                    
                } else {

                    if( _dwChunkSize == -1 ) {
                        DBGPRINTF(( DBG_CONTEXT,
                           "[DecodeChunkedBytes] bad chunk size\n" ));
                        SetLastError( ERROR_INVALID_PARAMETER );
                        fSuccess = FALSE;
                        goto done;
                    }                        
                
                    // Not a hex digit, eat the rest of the line until LF
                    _CRCount = _LFCount = 0;
                    _ChunkState = READ_CHUNK_PARAMS;
                    

                    // Now is a good time to clear the counter 
                    // of chunk data bytes that we've read
                    _cbChunkBytesRead = 0;
                    
                    break;
                }
            }
            break;

        case READ_CHUNK_PARAMS:

            // Eat anything which follows chunk size until LF
            while( cbBytesToDecode ) {
            
                Current = *(lpCurrent++);
                cbBytesToDecode--;
                
                if( Current == '\r' ) {
                
                    _CRCount = 1;
                    
                } else {
                
                    if( Current == '\n' && _CRCount != 0 ) {
                    

                        // We got LF, proceed reading chunk data
                        
                        _ChunkState = READ_CHUNK;
                        _LFCount = 1;
                        
                        break;
                        
                    } else {
                    
                        //
                        // No LF -- ignore CR(s)
                        //
                        
                        _CRCount = 0;
                    }
                }
                        }
            
            //
            // Shift the data to remove any chunk header
            //
            
            if( cbBytesToDecode ) {
                memmove( lpData, lpCurrent, cbBytesToDecode );
                lpCurrent = lpData;
            }
            
            //
            // If we have a 0 chunk size, we've read all of the data
            // but we may still have some footers to read
            //
            if( _dwChunkSize == 0 ) {
            
                _ChunkState = READ_CHUNK_FOOTER;
            }
            break;
        
        case READ_CHUNK:

            cb = _dwChunkSize - _cbChunkBytesRead;

            if( cb <= cbBytesToDecode ) {
            
                //
                // We have the whole chunk
                //

                //
                // Count off chunk worth of bytes to decode
                //
                
                cbBytesToDecode -= cb;
                
                //
                // Advance current pointer
                //
                
                lpCurrent += cb;
                
                //
                // Count in decoded bytes 
                //
                
                cbBytesDecoded += cb;
                
                //
                // Notice the position right after the last data byte
                //
                
                lpData = lpCurrent;
                
                //
                // Prepare CR and LF counters to handle trailing CRLF
                //
                
                _CRCount = _LFCount = 0;
                
                //
                // Shift to a new state
                //
                
                _ChunkState = READ_CHUNK_CRLF;
            
            } else {
           
                //
                // All cbBytesToDecode are data bytes
                //
                
                //
                // Count in decoded bytes
                //
                
                cbBytesDecoded += cbBytesToDecode;
             
                //
                // Remember number of bytes read by this call - we'll need it 
                // on next entry to this function
                //
            
                _cbChunkBytesRead += cbBytesToDecode;
            
                // 
                // Nothing left to decode
                //
             
                cbBytesToDecode = 0;
             
            }
            break;
        

        case READ_CHUNK_FOOTER:
            while( cbBytesToDecode ) {
            
                Current = *(lpCurrent++);
                cbBytesToDecode--;
                
                if( Current == '\r' ) {
                    _CRCount++;
                } else {
                    if( Current == '\n' && _CRCount != 0 ) {
                        _LFCount++;

                        if( _CRCount == 2 && _LFCount == 2 ) {

                            //
                            // CODEWORK
                            // We may have other footers here...
                            //
                            
                            if(_dwChunkSize == 0) {
                                _ChunkState = READ_CHUNK_DONE;
                                goto done;
                            }
                        
                            _ChunkState = READ_CHUNK_SIZE;
                            _CRCount = _LFCount = 0;
                            _dwChunkSize = 0;
                            
                            break;
                        }

                    } else {
                        _CRCount = _LFCount = 0;
                    }
                }
            }
            break;
        
        case READ_CHUNK_CRLF:
        
            if( _CRCount == 0 ) {
                if( *lpCurrent == '\r' ) {
                    cbBytesToDecode--;
                    lpCurrent++;
                    _CRCount = 1;
                } else {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    fSuccess = FALSE;
                    goto done;
                }
            }
            
            if( cbBytesToDecode != 0 ) {
                if( *lpCurrent == '\n' ) {
                    if( cbBytesToDecode == 1 ) {
                        _ChunkState = READ_CHUNK_SIZE;
                        _CRCount = _LFCount = 0;
                        _dwChunkSize = 0;
                        goto done;
                    }
                    cbBytesToDecode--;
                    lpCurrent++;
                    
                    _dwChunkSize = 0;
                    _CRCount = _LFCount = 0;
                    _ChunkState = READ_CHUNK_SIZE;
                    break;
                    
                } else {
                
                    SetLastError( ERROR_INVALID_PARAMETER );
                    fSuccess = FALSE;
                    goto done;
                }
                
            }
            break;
            
        default:
            DBG_ASSERT( 0 );
        }
    }

done:
    *pnBytes = cbBytesDecoded;
    return fSuccess;
}


VOID
HttpReqResolveCallback(
    ADDRCHECKARG pArg,
    BOOL fSt,
    LPSTR pName
    )
{
    // ignore fSt : DNS name is simply unavailable

    ((CLIENT_CONN*)pArg)->PostCompletionStatus( 0 );
    //((CLIENT_CONN*)pArg)->DoWork( 0, 0, FALSE );
}


BOOL
HTTP_REQ_BASE::OnCompleteRequest(
    TCHAR * pchRequest,
    DWORD   cbData,
    BOOL *  pfFinished,
    BOOL *  pfContinueProcessingRequest
    )
/*++

Routine Description:

    This method takes a complete HTTP 1.0 request and handles the results
    of the parsing method

Arguments:

    pchRequest - Pointer to first byte of request header
    cbData - Number of data bytes in pchRequest
    pfFinished - Set to TRUE if no further processing is needed
    pfContinueProcessingRequest - Set to FALSE is we must stop processing request

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BOOL      fRet;
    DWORD     cbExtraData;
    BOOL      fNoCert;
    BOOL      fHandled = FALSE;
    LPBYTE    pbCaList;
    DWORD     dwCaList;
    LPBYTE    pbCa;
    DWORD     dwCa;
    BOOL      fDenyOnDnsFail = TRUE;
    BOOL      fDenyComplete = FALSE;
    BOOL      fDisconnected = FALSE;

    //
    //  Parse the request
    //

    fRet = Parse( pchRequest,
                  cbData,
                  &cbExtraData,
                  &fHandled,
                  pfFinished );

    //
    // We can process authorization now that virtual root mapping is done
    //

    if ( fRet && _HeaderList.FastMapQueryValue( HM_AUT ) != NULL &&
         !( *pfFinished || fHandled ) )
    {
        fRet = ProcessAuthorization( (CHAR *)
                                     _HeaderList.FastMapQueryValue( HM_AUT ) );
    }

    if ( !fRet )
    {
        DWORD hterr;
        DWORD winerr = GetLastError();
        DWORD errorResponse = NO_ERROR;

        IF_DEBUG(ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                   "[OnFillClientReq] httpReq.Parse or httpLogonUser failed, error %lu\n",
                    GetLastError() ));
        }

        switch ( winerr )
        {
        case ERROR_INVALID_PARAMETER:

            //
            //  If the request is bad, then indicate that to the client
            //

            hterr = HT_BAD_REQUEST;
            break;

        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:

            hterr = HT_NOT_FOUND;
            break;

        case ERROR_BAD_NET_NAME:

            hterr = HT_NOT_FOUND;
            errorResponse = IDS_SITE_NOT_FOUND;
            break;

        case ERROR_NOT_SUPPORTED:

            hterr = HT_NOT_SUPPORTED;
            break;

        case ERROR_PASSWORD_EXPIRED:
        case ERROR_PASSWORD_MUST_CHANGE:
            if ( !_fAnonymous && !_fMappedAcct )
            {
                if ( !DoChange( &fHandled ) )
                {
                    return FALSE;
                }
                if ( fHandled )
                {
                    *pfContinueProcessingRequest = FALSE;
                    return TRUE;
                }
            }
            
            if ( !DenyAccess( &fDenyComplete, &fDisconnected ) || fDenyComplete )
            {
                hterr = HT_DENIED;
                winerr = ERROR_ACCESS_DENIED;
                SetLastError( winerr );
                errorResponse = IDS_PWD_CHANGE;
                return FALSE;
            }
            else
            {
                *pfContinueProcessingRequest = FALSE;
                return TRUE;
            }

        case ERROR_ACCESS_DENIED:
        case ERROR_LOGON_FAILURE:
            SetLastError( ERROR_ACCESS_DENIED );

            if ( !DenyAccess( &fDenyComplete, &fDisconnected ) || fDenyComplete )
            {
                return FALSE;
            }
            else
            {
                *pfContinueProcessingRequest = FALSE;
                return TRUE;
            }

        case ERROR_LOGIN_WKSTA_RESTRICTION:
            hterr = HT_FORBIDDEN;
            winerr = ERROR_ACCESS_DENIED;
            errorResponse = IDS_SITE_ACCESS_DENIED;
            break;

        case ERROR_TOO_MANY_SESS:
            hterr = HT_FORBIDDEN;
            winerr = ERROR_ACCESS_DENIED;
            errorResponse = IDS_TOO_MANY_USERS;
            break;

        case ERROR_INVALID_DATA:
            hterr = HT_SERVER_ERROR;
            errorResponse = IDS_INVALID_CNFG;
            break;

        default:

            //
            //  Some other fatal error occurred
            //

            hterr  = HT_SERVER_ERROR;
            break;
        }

        if ( errorResponse == NO_ERROR ) {
            errorResponse = winerr;
        }

        if (!_fNoDisconnectOnError)
        {
            SetState( HTR_DONE, hterr, winerr );

            if (!_fDiscNoError)
            {
                Disconnect( hterr, errorResponse, FALSE, pfFinished );
            }
            else
            {
                Disconnect( 0, NO_ERROR, FALSE, pfFinished );
            }
        }

        //
        //  Since we handled the error ourselves (by issuing a disconnect),
        //  we will return success (otherwise another disconnect will
        //  occur)
        //

        *pfContinueProcessingRequest = FALSE;
        return TRUE;
    }

    if ( fHandled )
    {
        *pfContinueProcessingRequest = FALSE;
        return TRUE;
    }

    if ( *pfFinished )
    {
        return TRUE;
    }

    //
    //  Check to see if encryption is required before we do any processing
    //

    if ( ( ((HTTP_REQUEST*)this)->GetFilePerms() & VROOT_MASK_SSL )
            && !IsSecurePort() )
    {
        SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
        Disconnect( HT_FORBIDDEN, IDS_SSL_REQUIRED, FALSE, pfFinished );
        *pfContinueProcessingRequest = FALSE;
        return TRUE;
    }

    //
    // Check if encryption key size should be at least 128 bits
    //

    if ( ( ((HTTP_REQUEST*)this)->GetFilePerms() & VROOT_MASK_SSL128 ) )
    {
        DWORD   dwKeySize;

        if ( !_tcpauth.QueryEncryptionKeySize(&dwKeySize, &fNoCert) || (dwKeySize < 128) )
        {
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
            Disconnect( HT_FORBIDDEN, IDS_SSL128_REQUIRED, FALSE, pfFinished );
            *pfContinueProcessingRequest = FALSE;
            return  TRUE;
        }
    }

#if 0
    if ( IsSslCa( &pbCaList, &dwCaList ) )
    {
        if( !_tcpauth.QueryCa( &pbCa, &dwCa, &fNoCert ) )
        {
            if ( !fNoCert )
            {
                goto rjca;
            }
        }
        else if ( IsInCaList( pbCaList, dwCaList, pbCa, dwCa ) )
        {
rjca:
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
            Disconnect( HT_FORBIDDEN, IDS_CA_NOT_ALLOWED, FALSE, pfFinished );
            *pfContinueProcessingRequest = FALSE;
            return  TRUE;
        }
    }
#endif

#if defined(CAL_ENABLED)
    //
    // Check if CAL granted for SSL access
    //

    if ( IsSecurePort() && !m_pCalSslCtxt )
    {
        if ( !CalConnect( QueryClientConn()->QueryRemoteAddr(),
                          strlen( QueryClientConn()->QueryRemoteAddr() ),
                          TRUE,
                          "",
                          0,
                          NULL,
                          &m_pCalSslCtxt ) )
        {
            g_pInetSvc->LogEvent( W3_EVENT_CAL_SSL_EXCEEDED,
                                  0,
                                  NULL,
                                  0 );

            BOOL bOverTheLimit;

            switch ( ((W3_IIS_SERVICE*)(QueryW3Instance()->m_Service))->QueryCalMode() )
            {
                case MD_CAL_MODE_LOGCOUNT:
                    IncrErrorCount( (IMDCOM*)QueryW3Instance()->m_Service->QueryMDObject(),
                                    MD_CAL_SSL_ERRORS,
                                    QueryW3Instance()->m_Service->QueryMDPath(),
                                    &bOverTheLimit );

                    if ( !bOverTheLimit )
                    {
                        break;
                    }
                    // fall-through

                case MD_CAL_MODE_HTTPERR:
                    SetState( HTR_DONE,
                              ((W3_IIS_SERVICE*)(QueryW3Instance()->m_Service))->QueryCalW3Error(),
                              ERROR_ACCESS_DENIED );
                    Disconnect( ((W3_IIS_SERVICE*)(QueryW3Instance()->m_Service))->QueryCalW3Error(),
                                IDS_CAL_EXCEEDED,
                                FALSE,
                                pfFinished );
                    *pfContinueProcessingRequest = FALSE;
                    return  TRUE;
            }
        }
    }
#endif

    //
    // Check IP access granted
    //

    BOOL fNeedDns = FALSE;

    //
    // do access check once per authenticated request
    //

    if ( !IsIpDnsAccessCheckPresent() )
    {
        _acIpAccess = AC_IN_GRANT_LIST;
    }
    else if ( _acIpAccess == AC_NOT_CHECKED )
    {
        _acIpAccess = QueryClientConn()->CheckIpAccess( &_fNeedDnsCheck );

        fNeedDns = _fNeedDnsCheck;

        if ( (_acIpAccess == AC_IN_DENY_LIST) ||
             ((_acIpAccess == AC_NOT_IN_GRANT_LIST) && !_fNeedDnsCheck) )
        {
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
            Disconnect( HT_FORBIDDEN, IDS_ADDR_REJECT, FALSE, pfFinished );
            *pfContinueProcessingRequest = FALSE;
            return  TRUE;
        }
    }

    //
    // If DNS name required for further processing and is not already present,
    // request it now.
    //

    if ( !fNeedDns )
    {
        if ( !IsLoggedOn() &&
             (QueryW3Instance()->QueryNetLogonWks() == MD_NETLOGON_WKS_DNS) &&
             (QueryMetaData()->QueryAuthentInfo()->dwLogonMethod == LOGON32_LOGON_NETWORK) )
        {
            fNeedDns = TRUE;
        }
        else if ( QueryMetaData()->QueryDoReverseDns() )
        {
            //
            // We would like to get the host name of the client.  But if we
            // can't we shouldn't deny access on the request. 
            //
            
            fNeedDns = TRUE;
            fDenyOnDnsFail = FALSE;
        }
    }

    if ( fNeedDns && !QueryClientConn()->IsDnsResolved() )
    {
        BOOL fSync;
        LPSTR pDns;

        if ( !QueryClientConn()->QueryDnsName( &fSync,
                (ADDRCHECKFUNCEX)HttpReqResolveCallback,
                (ADDRCHECKARG)QueryClientConn(),
                &pDns ) )
        {
            if ( fDenyOnDnsFail )
            {
                SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
                Disconnect( HT_FORBIDDEN, IDS_ADDR_REJECT, FALSE, pfFinished );
                *pfContinueProcessingRequest = FALSE;
                return TRUE;
            }
            else
            {
                //
                // Just fall thru and handle the request.  
                //
                
                fSync = TRUE;
            }
        }
        
        if ( !fSync )
        {
            SetState( HTR_RESTART_REQUEST );
            *pfContinueProcessingRequest = FALSE;
            return TRUE;
        }
    }

    return OnRestartRequest( pchRequest, cbExtraData, pfFinished, pfContinueProcessingRequest );
}


BOOL
HTTP_REQ_BASE::DoChange(
    LPBOOL  pfHandled
    )
/*++

Routine Description:

    This method handles password expiration notification

Arguments:

    pfHandled - updated with TRUE if change pwd request handled

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    STR strExpUrl;
    BOOL fSt = TRUE;
    STR strUrlArgs;

    QueryW3Instance()->LockThisForRead();
    fSt = strExpUrl.Copy((TCHAR*)QueryW3Instance()->QueryAuthExpiredUrl() );
    QueryW3Instance()->UnlockThis();

    if ( !fSt || !strExpUrl.QueryCCH() )
    {
        // can't change pwd

        *pfHandled = FALSE;
        return TRUE;
    }

    if ( LogonAsSystem() )
    {
        //
        // Add the arg to be passed to the password-change URL - argument is the URL the
        // user is pointed to after all the password-change processing is done 
        //
        if ( fSt = strExpUrl.Append( (TCHAR*)"?" ) )
        {
            fSt = TRUE;
            
            //
            // If we're changing the password on the proxy, we use the original non-proxy-munged
            // URL 
            //
            if ( IsProxyRequest() )
            {
                fSt = strUrlArgs.Append( (TCHAR*) _strOriginalURL.QueryStr() );
            }
            //
            // Can't just use QueryHostAddr() concatentated with 
            // _HeaderList.FastMapQueryValue( HM_URL ) because for HTTP 1.1 we might have a fully
            // qualified request as an URL, so we have to build it up piece-meal.
            //
            else
            {
                if ( !strUrlArgs.Append( IsSecurePort() ? (TCHAR*)"https://" : 
                                         (TCHAR*)"http://" ) ||
                     !strUrlArgs.Append( (TCHAR*)QueryHostAddr() ) ||
                     !strUrlArgs.Append( (TCHAR*) QueryURL() ) ||
                     !strUrlArgs.Append( _strURLParams.IsEmpty() ? (TCHAR *) "" : (TCHAR*) "?" ) ||
                     !strUrlArgs.Append( _strURLParams.IsEmpty() ? (TCHAR*) "" : 
                                         (TCHAR*) QueryURLParams() ))
                {
                    fSt = FALSE;
                }
            }
            
            if ( fSt )
            {
                fSt = strExpUrl.Append( (TCHAR*) strUrlArgs.QueryStr() );
            }
        }
        
        if ( !fSt )
        {
            *pfHandled = FALSE;
            return FALSE;
        }
        
        //
        // We used to call ReprocessURL() here to send back the form that allows users
        // to change their password, but there was a problem with the compression filter
        // [see Bug 120119 in the NT DB for full description] (and potentially other filters 
        // as well) that make it better to do a 302 Redirect to the password change URL
        //

        BOOL fFinished = FALSE;

        //
        // Put ourselves in a known state after the redirect - some browsers may close the
        // connection, others may keep it if we don't explicitly close it 
        //
        SetKeepConn( FALSE );

        if ( BuildURLMovedResponse( QueryRespBuf(),
                                    &strExpUrl,
                                    HT_REDIRECT,
                                    FALSE ) &&
             ( (HTTP_REQUEST*)this )->SendHeader( QueryRespBufPtr(),
                                                  QueryRespBufCB(),
                                                  IO_FLAG_SYNC,
                                                  &fFinished ) )
        {
            *pfHandled = TRUE;
            return TRUE;
        }
        else
        {
            *pfHandled = FALSE;
            return FALSE;
        }
    }
        
    SetDeniedFlags( SF_DENIED_LOGON );
    SetLastError( ERROR_ACCESS_DENIED );

    *pfHandled = FALSE;
    return FALSE;
}


BOOL
HTTP_REQ_BASE::DenyAccess(
    BOOL *                  pfDenyComplete,
    BOOL *                  pfDisconnected
    )
/*++

Routine Description:

    This method prepare the connection for a deny access return status by
    eating any entity body in the denied request

Arguments:

    pfDenyComplete - Set to true when all entity body is read
    pfDisconnected - Set to true if we disconnected 

Return Value:

    TRUE if successful, else FALSE

--*/
{
    HTR_STATE               OldState = QueryState();
    BOOL                    fDisconnected = FALSE;
    
    SetState( HTR_ACCESS_DENIED );
    if ( !ReadEntityBody( pfDenyComplete, 
                          TRUE, 
                          QueryClientContentLength(),
                          pfDisconnected ) )
    {
        return FALSE;
    }
    
    if ( *pfDenyComplete )
    {
        SetState( OldState );
    }
    
    return TRUE;
}


BOOL
HTTP_REQ_BASE::OnRestartRequest(
    TCHAR * pchRequest,
    DWORD   cbData,
    BOOL *  pfFinished,
    BOOL *  pfContinueProcessingRequest
    )
/*++

Routine Description:

    This method takes a complete HTTP 1.0 request and handles the results
    of the parsing method

Arguments:

    pchRequest - Pointer to first byte of request header
    cbData - Number of read data bytes in message body
    pfFinished - Set to TRUE if no further processing is needed
    pfContinueProcessingRequest - Set to FALSE is we must stop processing request

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BOOL            fGranted;
    LARGE_INTEGER   cExpire;
    SYSTEMTIME      stExpire;
    FILETIME        ftNow;
    BYTE            rgbInfo[MAX_TOKEN_USER_INFO];
    DWORD           cbTotalRequired;
    STR             strExpUrl;
    BOOL            fAccepted = FALSE;
    DWORD           cbNextRead;
    AC_RESULT       acDnsAccess;
    BOOL            fHandled;
    DWORD           dwCertFlags = 0;
    BOOL            fNoCert;
    LPBYTE          pbCa;
    DWORD           dwCa;


    *pfContinueProcessingRequest = TRUE;          // Assume we'll handle this w/o I/O.

    //
    // restore BytesWritten as set by 1st phase of request
    // ( may have been overwritten by reverse DNS lookup phase )
    //

    _cbBytesWritten = _cbRestartBytesWritten;

    //
    // Check if cert renegotiation to be requested
    //

    if ( QueryState() != HTR_CERT_RENEGOTIATE )
    {
        if ( !((HTTP_REQUEST*)this)->RequestRenegotiate( &fAccepted ) )
        {
            if ( GetLastError() == SEC_E_INCOMPLETE_MESSAGE )
            {
                fAccepted = FALSE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    //
    // If requested, begin reading data. Notification will be handled
    // by HandleCertRenegotiation()
    //

    if ( fAccepted )
    {
        _cbEntityBody = cbData;
        _cbOldData = _cbClientRequest + cbData;
        cbNextRead = CERT_RENEGO_READ_SIZE;

        if ( !_bufClientRequest.Resize( _cbOldData + cbNextRead ))
        {
            return FALSE;
        }

        *pfContinueProcessingRequest = FALSE;

        if ( !ReadFile( (BYTE *) _bufClientRequest.QueryPtr() + _cbOldData,
                        cbNextRead,
                        NULL,
                        IO_FLAG_ASYNC|IO_FLAG_NO_FILTER ))
        {
            return FALSE;
        }

        return TRUE;
    }

    if ( _dwRenegotiated == CERT_NEGO_SUCCESS )
    {
        QueryW3Instance()->IsSslCa( &pbCa, &dwCa );
        if ( !_tcpauth.UpdateClientCertFlags( QueryW3Instance()->QueryCertCheckMode(),
                                              &fNoCert, 
                                              pbCa, 
                                              dwCa ) )
        {
            return FALSE;
        }

        if ( !_tcpauth.QueryCertificateFlags( &dwCertFlags, &fNoCert ) ||
             ( dwCertFlags & ( RCRED_STATUS_UNKNOWN_ISSUER | 
                               CRED_STATUS_INVALID_TIME |
                               CRED_STATUS_REVOKED ) ) )
        {
            goto cert_req;
        }
    }
    else if ( ((HTTP_REQUEST*)this)->GetFilePerms() & VROOT_MASK_NEGO_MANDATORY )
    {
cert_req:
        SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );

        //
        // Several things could go wrong, so order our processing from most to least severe
        // (the order is a little arbitrary, but oh well ...)
        //
        DWORD dwSubStatus = 0;

        if ( dwCertFlags & RCRED_STATUS_UNKNOWN_ISSUER )
        {
            dwSubStatus = IDS_CERT_BAD;
        }
        else if ( dwCertFlags & CRED_STATUS_INVALID_TIME )
        {
            dwSubStatus = IDS_CERT_TIME_INVALID;
        }
        else if ( dwCertFlags & CRED_STATUS_REVOKED )
        {
            dwSubStatus = IDS_CERT_REVOKED;
        }
        else
        {
            dwSubStatus = IDS_CERT_REQUIRED;
        }

        Disconnect( HT_FORBIDDEN, dwSubStatus, FALSE, pfFinished );

        *pfContinueProcessingRequest = FALSE; 

        return TRUE;
    }

    if ( _fInvalidAccessToken )
    {
        SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
        Disconnect( HT_FORBIDDEN, IDS_MAPPER_DENY_ACCESS, FALSE, pfFinished );
        *pfContinueProcessingRequest = FALSE;
        return TRUE;
    }

    //
    //  If we're having an authentication conversation, then we send an access denied
    //  response with the next authentication blob.  The client returns the next blob
    //  to us in an HTTP request.
    //


    if ( IsAuthenticating() )
    {
        //
        // If no blob to send to client then handle this as
        // a 401 notification with disconnect
        //

        if ( _strAuthInfo.IsEmpty() )
        {
            SetKeepConn( FALSE );
            SetDeniedFlags( SF_DENIED_LOGON );
            _fAuthenticating = FALSE;
        }

DoAuthentication:

        //
        //  An access denied error automatically sends the next part
        //  of the authentication conversation
        //

        SetLastError( ERROR_ACCESS_DENIED );
        
        BOOL fDenyComplete = FALSE;
        BOOL fDisconnected = FALSE;
        
        if ( !DenyAccess( &fDenyComplete, &fDisconnected ) || fDenyComplete )
        {
            return FALSE;
        }
        else
        {
            *pfContinueProcessingRequest = FALSE;
            return TRUE;
        }
    }

    if ( _fNeedDnsCheck )
    {
        acDnsAccess = QueryClientConn()->CheckDnsAccess();

        _fNeedDnsCheck = FALSE;

        // not checked name should be denied

        if ( acDnsAccess == AC_NOT_CHECKED ||
             acDnsAccess == AC_IN_DENY_LIST ||
             acDnsAccess == AC_NOT_IN_GRANT_LIST ||
             (_acIpAccess == AC_NOT_IN_GRANT_LIST && acDnsAccess != AC_IN_GRANT_LIST) )
        {
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
            Disconnect( HT_FORBIDDEN, IDS_ADDR_REJECT, FALSE, pfFinished );
            *pfContinueProcessingRequest = FALSE;
            return TRUE;
        }
    }

    ((HTTP_REQUEST*)this)->CheckValidAuth();

    //
    //  If we have all the authentication information we need and we're
    //  not already logged on, try to log the user on
    //

    if ( !IsLoggedOn() && !LogonUser( pfFinished ) )
    {
LogonErr:
        if ( (GetLastError() == ERROR_ACCESS_DENIED) ||
             (GetLastError() == ERROR_LOGON_FAILURE))
        {
            goto DoAuthentication;
        }

        if ( (GetLastError() == ERROR_PASSWORD_EXPIRED ||
             GetLastError() == ERROR_PASSWORD_MUST_CHANGE) )
        {
            BOOL                fDenyComplete = FALSE;
            
            SetLastError( ERROR_ACCESS_DENIED );

            if ( !DoChange( &fHandled ) )
            {
                return FALSE;
            }
            
            if ( !fHandled )
            {
#if 0
                SetState( HTR_DONE, HT_DENIED, ERROR_ACCESS_DENIED );
                Disconnect( HT_DENIED, IDS_PWD_CHANGE, FALSE, pfFinished );
#else
                SetDeniedFlags( SF_DENIED_LOGON );
                goto DoAuthentication;
#endif
            }
            else
            {
                *pfFinished = TRUE;
            }
            return TRUE;
        }

        return FALSE;
    }
    else if ( (QueryNotifyExAuth() & MD_NOTIFEXAUTH_NTLMSSL ) &&
              _Filter.IsNotificationNeeded( SF_NOTIFY_AUTHENTICATIONEX,
                                            IsSecurePort() ) )
    {
        HANDLE  hTok;

        if ( !_Filter.NotifyAuthInfoFiltersEx( _strUserName.QueryStr(),
                                               _strUserName.QueryCCH(),
                                               _strUserName.QueryStr(),
                                               _strUserName.QueryCCH(),
                                               "",
                                               "",
                                               QueryMetaData()->QueryAuthentInfo()->
                                               strDefaultLogonDomain.QueryStr(),
                                               _strAuthType.QueryStr(),
                                               _strAuthType.QueryCCH(),
                                               &hTok,
                                               &hTok,
                                               pfFinished ))
        {
            SetDeniedFlags( SF_DENIED_LOGON | SF_DENIED_FILTER );
            goto LogonErr;
        }
    }

    if ( *pfFinished )
    {
        return TRUE;
    }
    
    //
    // Call SF_NOTIFY_AUTH_COMPLETE filters if we're logged on now
    //
    
    if ( IsLoggedOn() && 
         _Filter.IsNotificationNeeded( SF_NOTIFY_AUTH_COMPLETE, 
                                       IsSecurePort() ) )
    {
        HTTP_FILTER_AUTH_COMPLETE_INFO      AuthInfo;
        STACK_STR(                          strOriginal, MAX_PATH );    
        
        //
        // Store away the original URL
        //
        
        if ( !strOriginal.Copy( _HeaderList.FastMapQueryValue( HM_URL ) ) )
        {
            return FALSE;
        }
        
        if ( !_Filter.NotifyAuthComplete( pfFinished, 
                                          &AuthInfo ) )
        {
            return FALSE;
        }
        
        if ( *pfFinished )
        {
            return TRUE;
        }
        
        if ( _stricmp( strOriginal.QueryStr(),
                       _HeaderList.FastMapQueryValue( HM_URL ) ) )
        {
            BOOL                    fRet;
            //
            // Filter changed the URL.  Reprocess the URL
            //
            
            if ( AuthInfo.fResetAuth )
            {
                ResetAuth( FALSE );
            }
            
            fRet = ((HTTP_REQUEST*)this)->ReprocessURL( 
                                    (char*) _HeaderList.FastMapQueryValue( HM_URL ),
                                    HTV_UNKNOWN );
            
            *pfContinueProcessingRequest = FALSE; 
            
            return fRet;
        }
    }
    
#if defined(CAL_ENABLED)
    //
    // Check if CAL granted for authenticated access
    //

    if ( !_fAnonymous && !m_pCalAuthCtxt )
    {
        if ( !CalConnect( QueryClientConn()->QueryRemoteAddr(),
                          strlen( QueryClientConn()->QueryRemoteAddr() ),
                          FALSE,
                          _strUserName.QueryStr(),
                          _strUserName.QueryCCH(),
                          _tcpauth.QueryImpersonationToken(),
                          &m_pCalAuthCtxt ) )
        {
            BOOL bOverTheLimit;

            switch ( ((W3_IIS_SERVICE*)(QueryW3Instance()->m_Service))->QueryCalMode() )
            {
                case MD_CAL_MODE_LOGCOUNT:
                    IncrErrorCount( (IMDCOM*)QueryW3Instance()->m_Service->QueryMDObject(),
                                    MD_CAL_AUTH_ERRORS,
                                    QueryW3Instance()->m_Service->QueryMDPath(),
                                    &bOverTheLimit );

                    if ( !bOverTheLimit )
                    {
                        break;
                    }
                    // fall-through

                case MD_CAL_MODE_HTTPERR:
                    SetState( HTR_DONE,
                              ((W3_IIS_SERVICE*)(QueryW3Instance()->m_Service))->QueryCalW3Error(),
                              ERROR_ACCESS_DENIED );
                    Disconnect( ((W3_IIS_SERVICE*)(QueryW3Instance()->m_Service))->QueryCalW3Error(),
                                IDS_CAL_EXCEEDED,
                                FALSE,
                                pfFinished );
                    *pfContinueProcessingRequest = FALSE;
                    return  TRUE;
            }
        }
    }
#endif

    //
    // Query pwd expiration time.
    // if available, check if in notification range as defined by configuration
    // if in range, call configured URL
    //

    if ( !_fMappedAcct &&
         !_fAnonymous &&
         _tcpauth.QueryExpiry( (PTimeStamp)&cExpire ) )
    {
        if ( cExpire.HighPart == 0x7fffffff )
        {
            IF_DEBUG(REQUEST) {
                DBGPRINTF( ( DBG_CONTEXT, "No expiration time\r\n" ) );
            }
        }
        else
        {
            ::IISGetCurrentTimeAsFileTime( &ftNow );
            {
                if ( *(__int64*)&cExpire > *(__int64*)&ftNow )
                {
                    _dwExpireInDay = (DWORD)((*(__int64*)&cExpire
                            - *(__int64*)&ftNow)
                            / ((__int64)10000000*86400));

                    if ( QueryW3Instance()->QueryAdvNotPwdExpInDays()
                         && _dwExpireInDay
                            <= QueryW3Instance()->
                                 QueryAdvNotPwdExpInDays()
                         && QueryW3Instance()->QueryAdvNotPwdExpUrl() )
                    {
                        //
                        // Check this SID has not already been notified
                        // of pwd expiration
                        //

                        if ( GetTokenInformation( _tcpauth.QueryPrimaryToken(),
                                                  TokenUser,
                                                  (LPVOID ) rgbInfo,
                                                  sizeof(rgbInfo),
                                                  &cbTotalRequired) )
                        {
                            TOKEN_USER * pTokenUser = (TOKEN_USER *) rgbInfo;
                            PSID pSid = pTokenUser->User.Sid;

                            if( !PenCheckPresentAndResetTtl( pSid,
                                                             QueryW3Instance()
                                                                 ->QueryAdvCacheTTL() ) )
                            {
                                PenAddToCache( pSid,
                                               QueryW3Instance()
                                                   ->QueryAdvCacheTTL() );

                                //
                                // flush cache when connection close
                                // so that account change will not be masked
                                // by cached information
                                //

                                _tcpauth.DeleteCachedTokenOnReset();

                                QueryW3Instance()->LockThisForRead();
                                BOOL fSt = strExpUrl.Copy( (TCHAR*)QueryW3Instance()
                                                            ->QueryAdvNotPwdExpUrl() );
                                QueryW3Instance()->UnlockThis();
                                if ( !fSt )
                                {
                                    return FALSE;
                                }
                                if ( strExpUrl.QueryStr()[0] )
                                {
                                    //
                                    // Add the arg to be passed to the password-change URL - 
                                    // argument is the URL the user is pointed to after all the 
                                    // password-change processing is done 
                                    //
                                    if ( fSt = strExpUrl.Append( (TCHAR*)"?" ) )
                                    {
                                        fSt = TRUE;
                                        STR strUrlArgs;

                                        //
                                        // If we're changing the password on the proxy, we use 
                                        // the original non-proxy-munged URL 
                                        //
                                        if ( IsProxyRequest() )
                                        {
                                            fSt = strUrlArgs.Append( (TCHAR*) 
                                                                     _strOriginalURL.QueryStr() );
                                        }
                                        //
                                        // Can't just use QueryHostAddr() concatentated with 
                                        // _HeaderList.FastMapQueryValue( HM_URL ) because for 
                                        // HTTP 1.1 we might have a fully qualified request as an 
                                        // URL, so we have to build it up piece-meal.
                                        //
                                        else
                                        {
                                            if ( !strUrlArgs.Append( IsSecurePort() ? 
                                                                     (TCHAR*)"https://" : 
                                                                     (TCHAR*)"http://" ) ||
                                                 !strUrlArgs.Append( (TCHAR*)QueryHostAddr() ) ||
                                                 !strUrlArgs.Append( (TCHAR*) QueryURL() ) ||
                     !strUrlArgs.Append( _strURLParams.IsEmpty() ? (TCHAR *) "" : (TCHAR*) "?" ) ||
                     !strUrlArgs.Append( _strURLParams.IsEmpty() ? (TCHAR*) "" : 
                                                                   (TCHAR*) QueryURLParams() ))
                                            {
                                                fSt = FALSE;
                                            }
                                        }

                                        if ( fSt )
                                        {
                                            fSt = strExpUrl.Append( (TCHAR*) 
                                                                    strUrlArgs.QueryStr() );
                                        }
                                    }
                                        
                                    if ( !fSt )
                                    {
                                        return FALSE;
                                    }

                                    _tcpauth.QueryFullyQualifiedUserName( 
                                            _strUnmappedUserName.QueryStr(),
                                            &_strUnmappedUserName,
                                            QueryW3Instance(),
                                            QueryMetaData()->QueryAuthentInfo());

                                    //
                                    // process new URL
                                    //

                                    SetKeepConn( FALSE );   // to resync input flow

                                    //
                                    // We used to call ReprocessURL() here to send back the form 
                                    // that allows users to change their password, but there was 
                                    // a problem with the compression filter
                                    // [see Bug 120119 in the NT DB for full description] 
                                    // (and potentially other filters as well) that make it 
                                    // better to do a 302 Redirect to the password change URL
                                    //
                                    // We're guaranteed not to get into an infinite loop with the
                                    // redirect because we check whether or not the given SID
                                    // has already been notified about the password expiration
                                    // [ see call to PenCheckPresentAndResetTtl() call above]
                                    //
                                    
#if 1
                                    BOOL fFinished = FALSE;
                                    if ( BuildURLMovedResponse( QueryRespBuf(),
                                                                &strExpUrl,
                                                                HT_REDIRECT,
                                                                FALSE ) &&
                                         ( (HTTP_REQUEST*)this )->SendHeader( QueryRespBufPtr(),
                                                                              QueryRespBufCB(),
                                                                              IO_FLAG_SYNC,
                                                                              &fFinished ) )
                                    {
                                        *pfFinished = TRUE;
                                        return TRUE;
                                    }
                                    else
                                    {
                                        return FALSE;
                                    }

#else
                                    if ( !((HTTP_REQUEST*)this)->CancelPreconditions() )
                                    {
                                        return FALSE;
                                    }

                                    if ( ((HTTP_REQUEST*)this)->ReprocessURL(
                                            strExpUrl.QueryStr(),
                                            HTV_GET ) )
                                    {
                                        *pfFinished = TRUE;
                                        return TRUE;
                                    }
                                    else
                                    {
                                        return FALSE;
                                    }
#endif
                               }
                            }
                        }
                    }
                }
                else
                {
                    _dwExpireInDay = 0;
                }
            }
#if DBG
            IF_DEBUG(REQUEST) {
                FileTimeToSystemTime( (FILETIME*)&cExpire, &stExpire );
                DBGPRINTF( ( DBG_CONTEXT,
                        "Expiration date: %2d-%2d-%4d, %02d:%02d\r\n",
                        stExpire.wMonth, stExpire.wDay, stExpire.wYear,
                        stExpire.wHour, stExpire.wMinute ) );
            }
#endif
        }
    }

    //
    //  Check to see if the client specified any additional data
    //  that we need to pickup. We want to do this if there is an entity
    //  body, so _fHaveContentLength should be TRUE,
    //  and this is either a request destined for an ISAPI app or a
    //  non-PUT request that the server will handle. We do it this way
    //  to handle weird error cases, like GETs with entity bodies. We
    //  don't do this for unknown verbs that we're not going to handle
    //  anyways, since those will generate an error and we don't need
    //  to bother reading the entity body.
    //
    //  Note also that this approach won't handle those cases of an
    //  entity body without a content-length or transfer-encoding. It's
    //  hard to distinguish those cases from pipelined requests. If we
    //  need to handle this we can check for cbData being non-zero and
    //  the request being for a verb that could have an entity body, i.e.
    //  HTV_UNKNOWN or HTV_POST. This checked would be or'ed with the check
    //  for _fHaveContentLength.
    //
    //  If the server is changed such that requests with entity bodies
    //  other than PUT are handled then the 'if' statement below will need
    //  to be modified, most likely to check for verbs other than PUT.
    //

    if ( _fHaveContentLength &&
         (IsProbablyGatewayRequest() ||
            (QueryVerb() != HTV_PUT && QueryVerb() != HTV_UNKNOWN)
         )
       )
    {

        //
        // If we've got a 1.1 client, and we're reading some data for the app,
        // and this is a PUT or a POST, we've got to send the 100 Continue
        // response here. Note: it's possible that the 100 response should
        // be sent for any request that has an entity body. If we decide
        // to do that then just remove the last part of the following 'if'
        // statement.

        if (IsAtLeastOneOne() &&
            (QueryMetaData()->QueryUploadReadAhead() != 0) &&
            ((QueryVerb() == HTV_PUT) || (QueryVerb() == HTV_POST)))
        {
            if ( !SendHeader( "100 Continue", "\r\n", IO_FLAG_SYNC, pfFinished,
                              HTTPH_NO_CONNECTION) )
            {
                // An error on the header send. Abort this request.
                return FALSE;
            }

            if ( *pfFinished )
            {
                return TRUE;
            }
        }

        //
        //  Now let's pickup the rest of the data.
        //

        SetState( HTR_READING_GATEWAY_DATA );

        //
        //  We're all set, read the entity body now.
        //
        if ( !ReadEntityBody( pfContinueProcessingRequest, TRUE ))
        {
            return FALSE;
        }

        if ( !*pfContinueProcessingRequest )
            return TRUE;

        //
        //  else Fall through as we have all of the gateway data
        //
    }

    SetState( HTR_DOVERB );
    return TRUE;
}


BOOL
HTTP_REQ_BASE::ReadFile(
    LPVOID  lpBuffer,
    DWORD   nBytesToRead,
    DWORD * pnBytesRead,
    DWORD   dwFlags )
{

    //
    //  If no filters are installed, do the normal thing
    //

    if ( (dwFlags & IO_FLAG_NO_FILTER) ||
         !_Filter.IsNotificationNeeded( SF_NOTIFY_READ_RAW_DATA,
                                        IsSecurePort() ))
    {
        if ( dwFlags & IO_FLAG_ASYNC )
        {
            return _pClientConn->ReadFile( lpBuffer,
                                           nBytesToRead );
        }
        else
        {
            DWORD nBytes = 0;
            BOOL fRet;
            DWORD err;

            //
            //  Bogus hack - server relies on GetLastError() too much
            //  select() and recv() both reset the last error which hoses
            //  us on some error cleanup paths
            //

            err = GetLastError();

            fRet = TcpSockRecv( _pClientConn->QuerySocket(),
                             (char *) lpBuffer,
                              nBytesToRead,
                              &nBytes,
                              60            // 60s timeout
                              );

            if ( pnBytesRead != NULL ) {
                *pnBytesRead = nBytes;
            }

            if ( fRet ) {
                SetLastError( err );
            }

            return fRet;
        }
    }
    else
    {
        //
        //  We don't need to up the ref-count because the filter
        //  will eventually post an async-completion with the connection
        //  object
        //

        if ( _Filter.ReadData( lpBuffer,
                               nBytesToRead,
                               pnBytesRead,
                               dwFlags ))
        {
            return TRUE;
        }

        return FALSE;
    }
} // HTTP_REQ_BASE::ReadFile


BOOL
HTTP_REQ_BASE::WriteFile(
    LPVOID  lpBuffer,
    DWORD   nBytesToWrite,
    DWORD * pnBytesWritten,
    DWORD   dwFlags )
{

    //
    // Don't use WriteFileAndRecv unless we're told to
    //
    if (! g_fUseAndRecv ) {
        dwFlags &= ~IO_FLAG_AND_RECV;
    }

    AtqSetSocketOption(_pClientConn->QueryAtqContext(), 
                        TCP_NODELAY, 
                        (dwFlags & IO_FLAG_NO_DELAY) ? 1 : 0
                       );
    
    if ( (dwFlags & IO_FLAG_NO_FILTER ) ||
         !_Filter.IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA,
                                        IsSecurePort() ))

    {
        if ( dwFlags & IO_FLAG_ASYNC )
        {
            _fAsyncSendPosted = TRUE;

            if ( dwFlags & IO_FLAG_AND_RECV ) {
                return _pClientConn->WriteFileAndRecv( lpBuffer,
                                                       nBytesToWrite,
                                                       _bufClientRequest.QueryPtr(),
                                                       _bufClientRequest.QuerySize() );
            } else {
                return _pClientConn->WriteFile( lpBuffer,
                                                nBytesToWrite );
            }
        }
        else
        {
            DWORD nBytes = 0;
            BOOL fRet;
            DWORD err;

            err = GetLastError();

            fRet = TcpSockSend( _pClientConn->QuerySocket(),
                             lpBuffer,
                             nBytesToWrite,
                             &nBytes,
                             60 // 60s timeout
                             );

            _cbBytesSent += nBytes;
            
            if ( pnBytesWritten != NULL ) {
                *pnBytesWritten = nBytes;
            }

            if ( fRet ) {
                SetLastError( err );
            }

            return fRet;
        }
    }
    else
    {
        //
        //  We don't need to up the ref-count because the filter
        //  will eventually post an async-completion with the connection
        //  object
        //

        if ( _Filter.SendData( lpBuffer,
                               nBytesToWrite,
                               pnBytesWritten,
                               dwFlags ))
        {
            return TRUE;
        }

        return FALSE;
    }
}


BOOL
HTTP_REQ_BASE::TestConnection( VOID )
{
    return TcpSockTest( _pClientConn->QuerySocket() );
}


BOOL
HTTP_REQ_BASE::TransmitFile(
    TS_OPEN_FILE_INFO *         pOpenFile,
    HANDLE                      hFile,
    DWORD                       Offset,
    DWORD                       BytesToWrite,
    DWORD                       dwFlags,
    PVOID                       pHead,
    DWORD                       HeadLength,
    PVOID                       pTail,
    DWORD                       TailLength
    )
{
    //
    //  Either a file handle or a TS_OPEN_FILE_INFO* must be passed in
    //

    // We want to support Transmit file with out a file handle.
    // DBG_ASSERT( hFile || pOpenFile );
    DBG_CODE(
        if( hFile == NULL && !pOpenFile )
        {
            // This is the no file handle case
            DBG_ASSERT( Offset == 0 );
            DBG_ASSERT( BytesToWrite == 0 );
        }
    );

    //
    //  File sends must always be async
    //

    DBG_ASSERT( !(dwFlags & IO_FLAG_SYNC));

    //
    // Don't use TransmitFileAndRecv unless we're told to
    //
    if (! g_fUseAndRecv ) {
        dwFlags |= IO_FLAG_NO_RECV;
    }

    //
    //  Don't count filter bytes
    //

    if ( !(dwFlags & IO_FLAG_NO_FILTER ))
    {
        _cFilesSent++;
    }

    if ( (dwFlags & IO_FLAG_NO_FILTER) ||
         !_Filter.IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA,
                                        IsSecurePort() ))

    {
        _fAsyncSendPosted = TRUE;

        if ( dwFlags & (TF_DISCONNECT|IO_FLAG_NO_RECV) ) {
            if ( pOpenFile )
            {
                return TransmitFileTs( pOpenFile,
                                       Offset,
                                       BytesToWrite,
                                       dwFlags,
                                       pHead,
                                       HeadLength,
                                       pTail,
                                       TailLength );
            }
            else
            {
                return _pClientConn->TransmitFile( hFile,
                                                   Offset,
                                                   BytesToWrite,
                                                   dwFlags,
                                                   pHead,
                                                   HeadLength,
                                                   pTail,
                                                   TailLength );
            }
                            
        } else {
            return _pClientConn->TransmitFileAndRecv( hFile ? hFile : 
                                                      GetFileHandle( pOpenFile ),
                                                      Offset,
                                                      BytesToWrite,
                                                      dwFlags,
                                                      pHead,
                                                      HeadLength,
                                                      pTail,
                                                      TailLength,
                                                      _bufClientRequest.QueryPtr(),
                                                      _bufClientRequest.QuerySize() );
        }
    }
    else
    {
        if ( _Filter.SendFile( pOpenFile,
                               hFile,
                               Offset,
                               BytesToWrite,
                               dwFlags,
                               pHead,
                               HeadLength,
                               pTail,
                               TailLength ))
        {
            return TRUE;
        }

        return FALSE;
    }
}


BOOL
HTTP_REQ_BASE::TransmitFileTs(
    TS_OPEN_FILE_INFO * pOpenFile,
    DWORD               Offset,
    DWORD               BytesToWrite,
    DWORD               dwFlags,
    PVOID               pHead,
    DWORD               HeadLength,
    PVOID               pTail,
    DWORD               TailLength
    )
{
    BOOL fRet;
    PBYTE pFileBuf = pOpenFile->QueryFileBuffer();

    if (pFileBuf && 
        !(HeadLength && TailLength) ) {
     
        //
        // Do the fast path by sending file through
        // head or tail buffer
        //
        if (TailLength) {
            fRet = _pClientConn->TransmitFile(
                       NULL,
                       0,
                       0,
                       dwFlags,
                       pFileBuf + Offset,
                       BytesToWrite,
                       pTail,
                       TailLength
                       );
        } else {
            fRet = _pClientConn->TransmitFile(
                       NULL,
                       0,
                       0,
                       dwFlags,
                       pHead,
                       HeadLength,
                       pFileBuf + Offset,
                       BytesToWrite
                       );
        }
    } else {
        //
        // Do the slow path
        //
        fRet = _pClientConn->TransmitFile(
                       GetFileHandle( pOpenFile ),
                       Offset,
                       BytesToWrite,
                       dwFlags,
                       pHead,
                       HeadLength,
                       pTail,
                       TailLength
                       );
    }

    return fRet;
}

BOOL 
HTTP_REQ_BASE::SyncWsaSend( 
    WSABUF *    rgWsaBuffers,
    DWORD       cWsaBuffers,
    LPDWORD     pcbWritten 
    )
{
    BOOL fRet;

    DBG_ASSERT( pcbWritten );

    fRet = _pClientConn->SyncWsaSend( rgWsaBuffers, 
                                      cWsaBuffers, 
                                      pcbWritten );

    if( pcbWritten )
    {
        _cbBytesSent += *pcbWritten;
    }

    return fRet;
}
    

BOOL
HTTP_REQ_BASE::PostCompletionStatus(
    DWORD cbBytesTransferred
    )
{
    return _pClientConn->PostCompletionStatus( cbBytesTransferred );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\httpext.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    httpext.cxx

Abstract:

    This module contains the Microsoft HTTP server extension module

Author:

    John Ludeman (johnl)   09-Oct-1994

Revision History:
    Murali R. Krishnan (MuraliK)  20-July-1996
         Rewrote to enable multiple Extension class forwarding
--*/


/************************************************************
 *    Include Headers
 ************************************************************/

#pragma warning( disable:4509 )  // nonstandard extension: SEH with destructors

#include <w3p.hxx>
#include "wamexec.hxx"
#include "wamreq.hxx"
#include "WamW3.hxx"
#include "ExecDesc.hxx"

/************************************************************
 *    Prototypes
 ************************************************************/

BOOL  IsImageRunnableInProcOnly( const STR & strImagePath);





/************************************************************
 *    Functions
 ************************************************************/

/*****************************************************************/

BOOL
HTTP_REQUEST::ProcessBGI(
    EXEC_DESCRIPTOR *       pExec,
    BOOL       *            pfHandled,
    BOOL       *            pfFinished,
    BOOL                    fTrusted,
    BOOL                    fStarScript
    )
/*++
  Description:
    This method handles the gateway request to server application.

  Arguments:
    pExec - Execution Descriptor block
    pfHandled - Indicates we handled this request
    pfFinished - Indicates no further processing is required
    fTrusted - Can this app be trusted to process things on a read only
        vroot

  Return Value:
    TRUE if successful, FALSE on error
--*/
{
    const STR *  pstrBgiPath;
    DBG_ASSERT( *(pExec->_pGatewayType) == GATEWAY_BGI);

    // UNDONE:  Need to decide what to do with this.
    if ( !pExec->IsRunningDAV() &&
         !VrootAccessCheck( pExec->_pMetaData, FILE_GENERIC_EXECUTE ) )
    {
        SetDeniedFlags( SF_DENIED_RESOURCE );
        return FALSE;
    }

    if ( pExec->_pstrGatewayImage->IsEmpty()) {

        DBG_ASSERT(pExec->_pAppPathURIBlob == NULL);
        //  obtain the physical path now
        //
        //  Retrieve AppPathURIBlob for other ISAPI DLLs.
        //  See below for more detail comment about AppPathURIBlob.
        //
        if ( !LookupVirtualRoot( pExec->_pstrPhysicalPath,
                                 pExec->_pstrURL->QueryStr(),
                                 pExec->_pstrURL->QueryCCH(),
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 FALSE,
                                 NULL,
                                 &(pExec->_pAppPathURIBlob) ))
        {
            return FALSE;
        }

        pstrBgiPath = pExec->_pstrPhysicalPath;
    }
    else
    {
        //
        //  Retrieve AppPathURIBlob for each Exec descriptor,  such that
        //  a .STM file and a .ASP file in the same application will have 
        //  two different AppPathURIBlob.  The AppPathURIBlob will solve the
        //  problem that .STM file is loaded under default application(inproc) 
        //  even the request's URL points to an out-proc application.
        //
        if ( pExec->_pAppPathURIBlob == NULL )
        {
            if ( !CacheUri( QueryW3Instance(),
                            &(pExec->_pAppPathURIBlob),
                            pExec->_pMetaData,
                            pExec->_pstrURL->QueryStr(),
                            pExec->_pstrURL->QueryCCH(),
                            pExec->_pstrPhysicalPath,
                            pExec->_pstrUnmappedPhysicalPath ) )
            {
                return FALSE;
            }

            //
            //  If the AppPathURIBlob contains a valid MetaData, we need to AddRef it.
            //  Because this MetaData object is only referenced once if HTTP_REQUEST.pURIInfo
            //  contains that. AppPathURIBlob is another URIInfo that points to the MetaData
            //  object, therefore, We need to AddRef the Metadata object here.
            //  Exec.Reset always CheckIn the _pAppPathURIBlob(), and FreeMetaData reference in
            //  the Reset.
            //
            if (pExec->_pAppPathURIBlob->pMetaData)
                {
                TsReferenceMetaData(pExec->_pAppPathURIBlob->pMetaData->QueryCacheInfo());
                }
        }

        pstrBgiPath = pExec->_pstrGatewayImage;
    }

    if ( !fStarScript &&
         !pExec->IsRunningDAV() &&
         !(fTrusted && IS_ACCESS_ALLOWED2(pExec, SCRIPT)) &&
         !IS_ACCESS_ALLOWED2(pExec, EXECUTE) )
    {
        *pfHandled = TRUE;
        if ( pExec->IsChild() )
        {
            SetLastError( ERROR_INVALID_FLAGS );
            return FALSE;
        }
        else
        {
            Disconnect( HT_FORBIDDEN, IDS_EXECUTE_ACCESS_DENIED, FALSE, pfFinished );
            return TRUE;
        }
    }

    return ( DoWamRequest( pExec, *pstrBgiPath, pfHandled, pfFinished));
} // HTTP_REQUEST::ProcessBGI()


BOOL
HTTP_REQUEST::DoWamRequest(
    EXEC_DESCRIPTOR *       pExec,
    const STR &             strPath,
    BOOL *                  pfHandled,
    BOOL *                  pfFinished
    )
/*++

Routine Description:

    This method handles a gateway request to a server extension DLL

Arguments:

    pExec - Execution descriptor block
    strPath - Fully qualified path to DLL
    pfHandled - Indicates we handled this request
    pfFinished - Indicates no further processing is required

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL fReturn = TRUE;
    
    DBG_ASSERT( *(pExec->_pGatewayType) == GATEWAY_BGI);

    //
    // 1. Have we already checked if this current request for a legacy
    //    ISAPI that has to be routed to inproc only AppRoot instance?
    //
    //  _pAppPathURIBlob is associated with each Exec descriptor.  Therefore,
    //  We can use this URIBlob to distiguish a .STM file's application path(always runs
    //  in proc) or a .ASP file's application path (could be out-proc application)
    //  This also solves the problem that "#EXEC ISA=/OUTAPP/hello.asp" case in a .STM 
    //  file.(Child Execution).
    //  The Child execution will get a new EXEC object.
    //
    if ( !pExec->_pAppPathURIBlob->bUseAppPathChecked) {

        //
        // This is the first time we are checking the ISAPI application root
        //  path with respect to current image path
        //

        BOOL fInProcOnly = IsImageRunnableInProcOnly( strPath);

        //
        // set the state of the inproc-only vs. anything in the URIInfo record
        // so that other callers can use this as well
        // UNDONE: For K2/beta3, combine this with the script map lookup
        //

        InterlockedExchange((LPLONG)&(pExec->_pAppPathURIBlob->bInProcOnly), (LONG)fInProcOnly);
        InterlockedExchange((LPLONG)&(pExec->_pAppPathURIBlob->bUseAppPathChecked),(LONG)TRUE);
                
        DBG_ASSERT(pExec->_pAppPathURIBlob->bUseAppPathChecked);
    }

    g_pWamDictator->Reference();
    
    fReturn = BoolFromHresult( g_pWamDictator->ProcessWamRequest( this, pExec, &strPath, pfHandled, pfFinished ) );

    g_pWamDictator->Dereference();

    return fReturn;
} // HTTP_REQUEST::DoWamRequest()



BOOL
HTTP_REQUEST::ProcessAsyncGatewayIO(VOID)
/*++
  Description:
     Calls the ISA (gateway) async i/o completion function
     (via this request's wamreq)

  Arguments:
    None

  Returns:
     TRUE on success
     FALSE on failure

--*/
{

    g_pWamDictator->Reference();
    DBG_ASSERT( QueryState() == HTR_GATEWAY_ASYNC_IO );
    DBG_ASSERT( _pWamRequest );

    BOOL    fRet = TRUE;
    HRESULT hr = NOERROR;


    //
    //  Set state to doverb, since we have completed async i/o. Preserve the error codes.
    //

    SetState( HTR_DOVERB, QueryLogHttpResponse(), QueryLogWinError());


    //
    //  Ref the wamreq - other threads may access it while we
    //  wait for ISA async i/o completion function to return
    //

    //
    //  Guard against ISAs which call HSE_REQ_DONE_WITH_SESSION or return
    //  in the mainline (with something other than HSE_STATUS_PENDING) before
    //  async completion.  When this happens the _pWamRequest may be NULLed
    //  from underneath us.  
    //

    __try
    {
        _pWamRequest->AddRef();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = E_FAIL;
    }

    if ( FAILED(hr) )
    {
        g_pWamDictator->Dereference();
        return FALSE;
    }

    hr = _pWamRequest->ProcessAsyncGatewayIO( QueryIOStatus(), QueryBytesWritten() );

    if( FAILED(hr) ) {

        //
        //  If i/o completion callback failed, log it
        //

        const CHAR * apsz[1];

        // UNDONE is this valid?  used to be ...
        //apsz[0] = _SeInfo.ecb.lpszQueryString;
        apsz[0] = _Exec._pstrURLParams->QueryStr();

        DBGPRINTF(( DBG_CONTEXT,
                   "\n\n[ProcessAsyncGatewayIO] Exception occurred "
                   " in calling the callback for %s\n",
                   apsz[0]));

        g_pInetSvc->LogEvent( W3_EVENT_EXTENSION_EXCEPTION,
                              1,
                              apsz,
                              0 );

        fRet = FALSE;

    }
        

    //
    //  Deref the wamreq
    //

    _pWamRequest->Release();
        
    g_pWamDictator->Dereference();
    return fRet;
    
} // ProcessAsyncGatewayIO()



VOID HTTP_REQUEST::CancelAsyncGatewayIO(VOID)
/*++
  Description:
     Cancels pending ISA (gateway) async i/o operation

  Arguments:
    None

  Returns:
    Nothing

--*/
{

    DBG_ASSERT( QueryState() == HTR_GATEWAY_ASYNC_IO );
        DBG_ASSERT( _pWamRequest );

    SetState( HTR_DONE );

    if( _pWamRequest ) {

        _pWamRequest->Release();
    }

}   // CancelAsyncGatewayIO()



BOOL
IsImageRunnableInProcOnly( const STR & strImagePath)
/*++
  Description:
     This function takes the image path supplied and checks to see if this
     matches any present in the InProc-only ISAPI's list. If it does, then
     this function returns TRUE else FALSE.
     This is used to check for and support legacy ISAPI applications that
     can only run inproc

  Arguments:
     strImagePath - STR object containing the fully qualified image path
       (physical path is present)

  Returns:
     TRUE if this ISAPI Application can only be run inproc
            (i.e., image path is present in the InProc-only list)
     FALSE, otherwise

--*/
{

    LPCSTR   pszImagePathStart = strImagePath.QueryStr();
    LPCSTR   pszDllNameOnly; // points to just the DLL name after last '\\'
    
        IF_DEBUG( BGI )
        {
                DBGPRINTF(( DBG_CONTEXT,
                                        " IsRunnableInProcOnly([%d] %s\n",
                                        strImagePath.QueryCCH(),
                                        strImagePath.QueryStr()
                                        ));
        }

    W3_IIS_SERVICE * pSvc = (W3_IIS_SERVICE *) g_pInetSvc;

    // Check the full path
    if (pSvc->IsInProcISAPI(pszImagePathStart))
        return TRUE;

    //
    // Get the DLL name alone for relative path checks.
    // DLL name appears after the last path-separator '\\' 
    // NYI: How to optimize this relative path check? 
    //
       
    pszDllNameOnly = strrchr( pszImagePathStart, '\\');
    if ( pszDllNameOnly == NULL) {
        //
        // There were no path-separator '\\' found in the image name
        //

        //
        // Since we get absolute path for image from earlier stages
        // This should not happen!
        //
        DBG_ASSERT( FALSE);

        // reset to the start of the name and continue
        pszDllNameOnly = pszImagePathStart;
    } else {

        DBG_ASSERT( *pszDllNameOnly == '\\'); // just paranoid
        
        //
        // Skip past the path separator for comparisons to work correctly
        //
        pszDllNameOnly++;
    }
     
    return pSvc->IsInProcISAPI(pszDllNameOnly);
} // IsImageRunnableInProcOnly()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\hgetinfo.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
     hgetinfo.cxx

   Abstract:
     This file contains the code for getting information from HTTP_REQUEST
      object. This is useful for ISAPI apps and filters.

   Author:

       Murali R. Krishnan    ( MuraliK )     20-Nov-1996

   Environment:


   Project:

       W3Svc DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "w3p.hxx"
extern "C"
{
    #include "md5.h"
}

//
// IsStringMatch()
//   Matches the given string variable to the constant string supplied.
//   The two variables involved are strings :(  which are null-terminated
//   So, we cannot apply Memory Comparisons
//
// Returns:
//  TRUE on a match
//  FALSE if there is a failure to match up
//
# define IsStringMatch( pszConstant, pszVar, cchVar)  \
     ((cchVar == (sizeof( pszConstant) - 1)) && \
      !strcmp( pszConstant, pszVar)             \
      )

//
// IsStringPrefixMatch()
//   Matches the given string variable for a prefix constant string.
//
// Returns:
//  TRUE on a match
//  FALSE if there is a failure to match up
//
# define IsStringPrefixMatch( pszConstantPrefix, pszVar, cchVar)  \
     ((cchVar >= (sizeof( pszConstantPrefix) - 1)) && \
      !memcmp( pszConstantPrefix, pszVar, (sizeof(pszConstantPrefix) - 1))\
      )

static const CHAR g_szHexDigits[] = "0123456789abcdef";

/************************************************************
 *    Function Prototypes and inlines
 ************************************************************/

BOOL
BuildCGIHeaderList(
    HTTP_HEADERS * pHeaderList,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    );

BOOL
GetInfoFromCertificate(
     IN TCP_AUTHENT & tcpauth,
     IN LPCSTR        pszValName,
     DWORD            cchValName,
     OUT CHAR *       pchBuffer,
     IN OUT DWORD  *  lpcchBuffer
     );


BOOL
HseBuildRawHeaders(
    IN HTTP_HEADERS * pHeaderList,
    OUT LPSTR       lpvBuffer,
    IN OUT LPDWORD  lpdwSize
    );



BOOL
CopyStringToBuffer(
    IN LPCSTR      psz,
    IN DWORD       cch,
    OUT CHAR *     pchBuffer,
    IN OUT DWORD * lpcchBuffer
    )
{
    if ( *lpcchBuffer >= cch ) {

        if ( pchBuffer != NULL ) {

            CopyMemory( pchBuffer, psz, cch);
            *lpcchBuffer = cch;
            return (TRUE);
        }
    }

    *lpcchBuffer = cch;
    SetLastError( ERROR_INSUFFICIENT_BUFFER);

    return ( FALSE);
} // CopyStringToBuffer()


BOOL
VariableNotAvailable(
    OUT CHAR*       pchBuffer,
    IN OUT DWORD*   lpcchBuffer
    )
/*++

  Description:
     handles server request for which content is not available,
     i.e. variables which depends on instance or metadata
     when such info is not available.
     In this case we return an empty string.

  Arguments:
    pchBuffer  - pointer to character buffer which will contain
                 the value if found
    lpcchBuffer - pointer to DWORD containing
                   IN: the count of characters pchBuffer can store
                   OUT: the count of characters actually stored (on success)
                        the count of characters required (on failure)

  Returns:
    TRUE if success, otherwise FALSE

    Win32 Error Code :
    NO_ERROR  for success
    ERROR_INSUFFICIENT_BUFFER - if space is not enough
    ERROR_INVALID_INDEX       - if item is not found

--*/
{
    if ( *lpcchBuffer >= 1 ) {

        if ( pchBuffer != NULL ) {

            *pchBuffer = '\0';
            *lpcchBuffer = 1;
            return TRUE;
        } else {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    *lpcchBuffer = 1;
    SetLastError( ERROR_INSUFFICIENT_BUFFER);

    return ( FALSE);
}


inline BOOL
CopyStringToBuffer(
    IN LPCSTR      psz,
    OUT CHAR *     pchBuffer,
    IN OUT DWORD * lpcchBuffer
    )
{
    DBG_ASSERT( psz != NULL );
    return (CopyStringToBuffer( psz, strlen(psz) + 1, pchBuffer, lpcchBuffer));
} // CopyStringToBuffer()


inline BOOL
ReturnNullString(
    OUT CHAR *     pchBuffer,
    IN OUT DWORD * lpcchBuffer
    )
{
    return (CopyStringToBuffer( "", 1, pchBuffer, lpcchBuffer));
}



/************************************************************
 *    Functions
 ************************************************************/

PW3_METADATA
HTTP_REQUEST::GetWAMMetaData(
    )
/*++

  Description:
    This function gets the metadata pointer taking into account
      running child ISAPI scenario. For some ISAPI related gets
      this should be used intstead of QueryMetaData()

  Arguments:

  Returns:
    PW3_METADATA pointer or NULL

--*/
{
    if ( _pWamRequest && _pWamRequest->IsChild() ) {

        return _pWamRequest->QueryExecMetaData();
    }
    else {

        return QueryMetaData();
    }
}


BOOL
HTTP_REQUEST::GetInfoForName(
    const CHAR *  pszValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
/*++

  Description:
    This function acts as the switch board for getting values
      for requested ValueName. It is used by Filters/ISAPI applications
      to obtain the required server and request values.

  Arguments:
    pszValName - pointer to string containing the name of the value
    pchBuffer  - pointer to character buffer which will contain
                 the value if found
    lpcchBuffer - pointer to DWORD containing
                   IN: the count of characters pchBuffer can store
                   OUT: the count of characters actually stored (on success)
                        the count of characters required (on failure)

  Returns:
    Win32 Error Code
    NO_ERROR  for success
    ERROR_INSUFFICIENT_BUFFER - if space is not enough
    ERROR_INVALID_INDEX       - if item is not found


--*/
{

    if ( !pszValName)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( !( *pszValName ) || !isalpha( (UCHAR)(*pszValName) ) )
    {
        SetLastError( ERROR_INVALID_INDEX);
        return (FALSE);
    }

    BOOL                fRet;
    PFN_GET_INFO        pfnGI;
    DWORD               cchValName = strlen( pszValName);

    pfnGI = HTTP_REQUEST::sm_GetInfoFuncs[IndexOfChar(*pszValName)];

    DBG_ASSERT( NULL != pfnGI);
    fRet  = (this->*pfnGI)( pszValName, cchValName, pchBuffer, lpcchBuffer );

#if OLD_MODE_COMPATIBILITY
    //
    // Once upon a time, this function was not there. Then all the queries
    //  if they did not get resolved were passed onto GetEnvironmentString()
    //  to extract and environment parameter.
    //
    // These days the GetEnvironmentString() which is part of the GetInfoMisc()
    //  is not a fast function => it consumes more time
    // So we will avoid this. Thanks for listening to the story.
    //

    if ( !fRet && ( GetLastError() == ERROR_INVALID_INDEX ) )
        {
            //
            // Try again with the Misc() function if we do not find
            //   the item in the general location.
            // This has performance costs :(
            //
            fRet = GetInfoMisc( pszValName, cchValName,
                                pchBuffer, lpcchBuffer );
        }

# endif // OLD_MODE_COMPATIBILITY

    return fRet;
} // HTTP_REQUEST::GetInfoForName()


BOOL
HTTP_REQUEST::GetInfoA(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'A');

    //
    //  ALL_HTTP is a special server specific value used by the CGI code
    //  to retrieve all of the HTTP headers the client sent
    //

    if ( IsStringMatch( "ALL_RAW", pszValName, cchValName)) {

        //
        //  Probably the proxy is making the request
        //  Get the raw list of headers
        //

        return ( HseBuildRawHeaders( QueryHeaderList(),
                                     pchBuffer, lpcchBuffer)
                 );

    } else if ( IsStringMatch( "APPL_MD_PATH", pszValName, cchValName )) {

        PW3_METADATA pMetaData = GetWAMMetaData();

        if ( pMetaData == NULL )
        {
            return VariableNotAvailable( pchBuffer, lpcchBuffer);
        }

        DBG_ASSERT( pMetaData->QueryAppPath() != NULL);

        return ( pMetaData->QueryAppPath()->
                   CopyToBuffer( pchBuffer, lpcchBuffer)
                 );
    } else if ( IsStringMatch( "APPL_PHYSICAL_PATH", pszValName, cchValName )) {

        PW3_METADATA pMetaData = GetWAMMetaData();
        MB           mb( (IMDCOM*) g_pInetSvc->QueryMDObject());

        if ( pMetaData == NULL )
        {
            return VariableNotAvailable( pchBuffer, lpcchBuffer);
        }

        STACK_STR( strAppPhysicalPath, MAX_PATH);

        //
        // Create the Applicaiton Physical Path in a separate buffer
        //  and then copy it over to the incoming buffer
        //

        return ( ( pMetaData->BuildApplPhysicalPath( 
                            &mb,
                            &strAppPhysicalPath)) 
                 && strAppPhysicalPath.CopyToBuffer( pchBuffer, lpcchBuffer)
                 );
    } else if ( IsStringMatch( "ALL_HTTP", pszValName, cchValName )) {

        return BuildCGIHeaderList( QueryHeaderList(), pchBuffer, lpcchBuffer );

    } else if ( IsStringMatch( "AUTH_TYPE", pszValName, cchValName )) {

        return ( _strAuthType.CopyToBuffer( pchBuffer, lpcchBuffer));

    } else if ( IsStringMatch( "AUTH_PASSWORD", pszValName, cchValName )) {

        return ( _strUnmappedPassword.CopyToBuffer( pchBuffer, lpcchBuffer));

    } else if ( IsStringMatch( "AUTH_USER", pszValName, cchValName )) {

        return ( _strUnmappedUserName.CopyToBuffer( pchBuffer, lpcchBuffer));

    } else {

        SetLastError( ERROR_INVALID_INDEX);
    }

    return ( FALSE);

} // HTTP_REQUEST::GetInfoA()



BOOL
HTTP_REQUEST::GetInfoC(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn;

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'C');

    if ( IsStringMatch( "CONTENT_LENGTH", pszValName, cchValName )) {

        CHAR rgchCL[40];

        _ultoa( _cbContentLength, rgchCL, 10);

        fReturn = CopyStringToBuffer( rgchCL,
                                      pchBuffer, lpcchBuffer);


    } else if ( IsStringMatch( "CONTENT_TYPE", pszValName, cchValName )) {

        fReturn = _strContentType.CopyToBuffer( pchBuffer, lpcchBuffer);

    } else if ( IsStringPrefixMatch( "CERT_", pszValName, cchValName)) {

        //
        // All the certificates related stuff has to go in here.
        //

        fReturn = GetInfoFromCertificate( _tcpauth, (pszValName + 5),
                                          cchValName - 5,
                                          pchBuffer, lpcchBuffer);
    } else {

        SetLastError( ERROR_INVALID_INDEX);
        fReturn = FALSE;
    }

    return ( fReturn);
} // HTTP_REQUEST::GetInfoC()


BOOL
HTTP_REQUEST::GetInfoH(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn = TRUE;
    LPCSTR pszSuffix;
    DWORD  cchSuffix;

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'H');

    if ( IsStringPrefixMatch( "HTTP_", pszValName, cchValName)) {

        pszSuffix = pszValName +  (sizeof("HTTP_") - 1);
        cchSuffix = cchValName - (sizeof("HTTP_") - 1);

        if ( IsStringMatch( "REQ_REALM", pszSuffix, cchSuffix)) {

            LPCSTR psz;

            //
            // generate the real information
            //

            if ( QueryMetaData() == NULL )
            {
                return VariableNotAvailable( pchBuffer, lpcchBuffer);
            }

            psz = ( QueryMetaData()->QueryRealm()
                     ? QueryMetaData()->QueryRealm()
                     : QueryHostAddr() );
            fReturn = CopyStringToBuffer( psz, pchBuffer, lpcchBuffer);

        } else if ( IsStringMatch( "REQ_PWD_EXPIRE", pszSuffix, cchSuffix )) {

            CHAR rgExp[40];

            _ultoa( _dwExpireInDay, rgExp, 10);
            fReturn = CopyStringToBuffer( rgExp, pchBuffer, lpcchBuffer);

        } else if ( IsStringMatch( "CFG_ENC_CAPS", pszSuffix, cchSuffix )) {

            if ( QueryW3Instance() == NULL )
            {
                return VariableNotAvailable( pchBuffer, lpcchBuffer);
            }

            CHAR rgNum[40];

            _ultoa( (UINT) QueryW3Instance()->QueryEncCaps(),
                    rgNum, 10);
            fReturn = CopyStringToBuffer( rgNum, pchBuffer, lpcchBuffer);

        } else {

            //
            //  Since the value begins with "HTTP_"
            //  then it's probably in our headers list
            //
            CHAR     achHeader[MAX_HEADER_LENGTH];
            CHAR *   pch;
            LPCSTR   pszValue;
            DWORD    cchValue;
            HTTP_FAST_MAP_HEADERS iField;

            // adjust "1" for the terminating ":" if needed
            if ( cchSuffix >= sizeof( achHeader ) - 1 ) {

                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }

            //
            //  Copy the client specified header name to a temp buffer
            //   so we can replace all "_" with "-"s so it will match the
            //   header names in our list.
            //  We also need to append a colon if needed
            //

            strcpy( achHeader, pszValName + 5 );
            for ( pch = achHeader; pch = strchr( pch, '_' ); *pch++ = '-')
                ;

            pszValue = NULL;
            // Lookup the name in the fast map first.
            if ( HTTP_HEADERS::FindOrdinalForHeader( achHeader, cchSuffix,
                                                     (LPDWORD ) &iField)
                 ) {
                // get the header value from fast map
                pszValue = _HeaderList.FastMapQueryValue( iField);
                cchValue = ((pszValue != NULL) ? strlen( pszValue) : 0);
            }

            // if the header is absent in the fast map, lookup the slow map
            if ( NULL == pszValue ) {

                // append a ':' if not already present
                if ( (cchSuffix >= 1) && (achHeader[cchSuffix-1] != ':') &&
                     (cchSuffix < sizeof(achHeader))) {

                    achHeader[cchSuffix] = ':';
                    achHeader[cchSuffix+1] = '\0';
                    cchSuffix++;
                }
                pszValue = _HeaderList.FindValue( achHeader, &cchValue );
            }

            if ( pszValue != NULL) {

                // Copy including the "null" character for the string.
                fReturn = CopyStringToBuffer( pszValue, cchValue + 1,
                                              pchBuffer, lpcchBuffer);
            } else {

                SetLastError( ERROR_INVALID_INDEX);
                fReturn = FALSE;
            }
        }

    } else if ( IsStringPrefixMatch( "HTTPS", pszValName, cchValName)) {

        pszSuffix = pszValName + (sizeof("HTTPS") - 1);
        cchSuffix = cchValName - (sizeof("HTTPS") - 1);

        if ( *pszSuffix == '\0') {
            // pszValName == "HTTPS"

            fReturn = CopyStringToBuffer( IsSecurePort() ? "on" : "off",
                                          pchBuffer, lpcchBuffer);
        } else if ( *pszSuffix == '_' ) {

            fReturn = GetInfoFromCertificate( _tcpauth, pszSuffix+1,
                                              cchSuffix - 1,
                                              pchBuffer, lpcchBuffer);
        } else {
            SetLastError( ERROR_INVALID_INDEX);
            fReturn = FALSE;
        }

    } else {
        SetLastError( ERROR_INVALID_INDEX);
        fReturn = FALSE;
    }

    return ( fReturn);
} // HTTP_REQUEST::GetInfoH()



BOOL
HTTP_REQUEST::GetInfoI(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn = FALSE;
    LPCSTR pszSuffix;
    DWORD  cchSuffix;

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'I');

    if ( IsStringPrefixMatch( "INSTANCE_", pszValName, cchValName))
    {
        pszSuffix = pszValName + (sizeof("INSTANCE_")-1);
        cchSuffix = cchValName - (sizeof("INSTANCE_") - 1);

        if ( IsStringMatch( "ID", pszSuffix, cchSuffix))
        {
            if ( QueryW3Instance() == NULL )
            {
                return VariableNotAvailable( pchBuffer, lpcchBuffer);
            }

            CHAR rgch[40];
            _ultoa( QueryW3Instance()->QueryInstanceId(),
                    rgch,
                    10);

            fReturn = CopyStringToBuffer( rgch, pchBuffer, lpcchBuffer);
        }
        else if ( IsStringMatch( "META_PATH", pszSuffix, cchSuffix ))
        {
            if ( QueryW3Instance() == NULL )
            {
                return VariableNotAvailable( pchBuffer, lpcchBuffer);
            }

            fReturn = CopyStringToBuffer( QueryW3Instance()->QueryMDPath(),
                                          pchBuffer,
                                          lpcchBuffer);
        }
        else
        {
            SetLastError( ERROR_INVALID_INDEX);
            fReturn = FALSE;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_INDEX);
        fReturn = FALSE;
    }

    return fReturn;
} // HTTP_REQUEST::GetInfoI()


BOOL
HTTP_REQUEST::GetInfoL(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn;

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'L');

    if ( IsStringMatch( "LOCAL_ADDR", pszValName, cchValName)) {

        //
        //  Note this returns the server IP address since we don't necessarily
        //  know the DNS name of this server
        //

        fReturn = CopyStringToBuffer( QueryClientConn()->QueryLocalAddr(),
                                      pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "LOGON_USER", pszValName, cchValName )) {

        fReturn = _strUserName.CopyToBuffer( pchBuffer, lpcchBuffer);
    } else {

        SetLastError( ERROR_INVALID_INDEX);
        fReturn = FALSE;
    }

    return ( fReturn);
} // HTTP_REQUEST::GetInfoL()



BOOL
HTTP_REQUEST::GetInfoP(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn;

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'P');


    if ( IsStringMatch( "PATH_INFO", pszValName, cchValName )) {

        fReturn = _strPathInfo.CopyToBuffer( pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "PATH_TRANSLATED", pszValName, cchValName )) {

        //
        //  Note that _strPathInfo has already been escaped
        //
        //  If the path can't be found (no home root for example) then
        //  treat it as success and return the empty string.
        //

        // Easiest is to use a string object to obtain the xlation.

        PW3_METADATA pMetaData = GetWAMMetaData();

        if ( pMetaData == NULL )
        {
            return VariableNotAvailable( pchBuffer, lpcchBuffer);
        }

        STACK_STR( str, MAX_PATH);

        if ( !LookupVirtualRoot( &str,
                                 _strPathInfo.QueryStr() ,
                                 _strPathInfo.QueryCCH() ) &&
             GetLastError() != ERROR_PATH_NOT_FOUND ) {

            fReturn = FALSE;
        } else {

            fReturn = str.CopyToBuffer( pchBuffer, lpcchBuffer);
        }

    } else {

        SetLastError( ERROR_INVALID_INDEX);
        fReturn = FALSE;
    }

    return ( fReturn);

} // HTTP_REQUEST::GetInfoP()


BOOL
HTTP_REQUEST::GetInfoR(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn;
    char chBuff[8];    // plenty of room for _itoa(USHORT_MAX, ...)

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'R');

    if ( IsStringMatch( "REQUEST_METHOD", pszValName, cchValName )) {

        fReturn = _strMethod.CopyToBuffer( pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "REMOTE_HOST", pszValName, cchValName)) {

        //
        //  Note that REMOTE_HOST returns DNS name if available
        //

        fReturn =
            CopyStringToBuffer( (( QueryClientConn()->IsDnsResolved() )?
                                 ( QueryClientConn()->QueryResolvedDnsName()) :
                                 ( QueryClientConn()->QueryRemoteAddr() )
                                 ),
                                pchBuffer,
                                lpcchBuffer);

    } else if ( IsStringMatch( "REMOTE_ADDR", pszValName, cchValName ) ) {

        fReturn = CopyStringToBuffer( QueryClientConn()->QueryRemoteAddr(),
                                      pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "REMOTE_USER", pszValName, cchValName)) {

        fReturn = _strUnmappedUserName.CopyToBuffer( pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "REMOTE_PORT", pszValName, cchValName ) ) {

        _itoa( QueryClientConn()->QueryRemotePort(), chBuff, 10);

        fReturn = CopyStringToBuffer( chBuff, pchBuffer, lpcchBuffer);

    } else {

        SetLastError( ERROR_INVALID_INDEX);
        fReturn = FALSE;
    }

    return ( fReturn);
} // HTTP_REQUEST::GetInfoR()




BOOL
HTTP_REQUEST::GetInfoS(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn;

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'S');


    if ( IsStringMatch( "SCRIPT_NAME", pszValName, cchValName ) ) {

        fReturn = _strURL.CopyToBuffer( pchBuffer, lpcchBuffer );

    } else if ( IsStringPrefixMatch( "SERVER_", pszValName, cchValName)) {

        LPCSTR pszSuffix = pszValName +  (sizeof("SERVER_") - 1);
        DWORD cchSuffix = cchValName - (sizeof("SERVER_") - 1);

        if ( IsStringMatch( "NAME", pszSuffix, cchSuffix ) ) {

            fReturn = CopyStringToBuffer( QueryHostAddr(),
                                          pchBuffer, lpcchBuffer );
        } else if ( IsStringMatch( "PROTOCOL", pszSuffix, cchSuffix)) {

            CHAR rgch[40];
            wsprintf( rgch,
                      "HTTP/%d.%d",
                      _VersionMajor,
                      _VersionMinor );
            fReturn = CopyStringToBuffer( rgch, pchBuffer, lpcchBuffer);

        } else if ( IsStringMatch( "PORT", pszSuffix, cchSuffix )) {

            CHAR rgch[40];

            _ultoa( QueryClientConn()->QueryPort(),
                    rgch, 10);
            fReturn = CopyStringToBuffer( rgch, pchBuffer, lpcchBuffer);

        } else if ( IsStringMatch( "PORT_SECURE", pszSuffix, cchSuffix)) {

            fReturn = CopyStringToBuffer( ( IsSecurePort() ? "1" : "0"), 2,
                                          pchBuffer, lpcchBuffer );

        } else if ( IsStringMatch( "SOFTWARE", pszSuffix, cchSuffix)) {

            DBG_ASSERT( g_szServerType[g_cbServerType] == '\0');
            fReturn = CopyStringToBuffer( g_szServerType, g_cbServerType + 1,
                                          pchBuffer, lpcchBuffer);
        } else {

            SetLastError( ERROR_INVALID_INDEX);
            fReturn = FALSE;
        }

    } else {

        SetLastError( ERROR_INVALID_INDEX);
        fReturn = FALSE;
    }

    return ( fReturn);

} // HTTP_REQUEST::GetInfoS()



BOOL
HTTP_REQUEST::GetInfoU(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn;

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( toupper(*pszValName) == 'U');

    if ( IsStringMatch( "UNMAPPED_REMOTE_USER", pszValName, cchValName )) {

        fReturn = _strUnmappedUserName.CopyToBuffer( pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "URL", pszValName, cchValName ) ) {

        fReturn = _strURL.CopyToBuffer( pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "URL_PATH_INFO", pszValName, cchValName ) ) {

        fReturn = _strURLPathInfo.CopyToBuffer( pchBuffer, lpcchBuffer);
    
    } else if ( IsStringMatch( "UNENCODED_URL", pszValName, cchValName ) ) {
        
        fReturn = _strRawURL.CopyToBuffer( pchBuffer, lpcchBuffer);

    }
     else {

        SetLastError( ERROR_INVALID_INDEX);
        fReturn = FALSE;
    }

    return ( fReturn);
} // HTTP_REQUEST::GetInfoU()




BOOL
HTTP_REQUEST::GetInfoMisc(
    const CHAR *  pszValName,
    DWORD         cchValName,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
{
    BOOL fReturn;

    DBG_ASSERT( pszValName != NULL);

    if ( IsStringMatch( "GATEWAY_INTERFACE", pszValName, cchValName )) {

        fReturn = CopyStringToBuffer( "CGI/1.1", sizeof("CGI/1.1"),
                                      pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "QUERY_STRING", pszValName, cchValName )) {

        fReturn = _strURLParams.CopyToBuffer( pchBuffer, lpcchBuffer);

    } else {

        //
        //  Any other value we assume to be a real environment variable
        //

        DWORD cch;

        //
        //  GetEnvironmentVariable()
        // If the function succeeds, the return value is the number of
        //     characters stored into the buffer pointed to by lpcchBuffer,
        //     not including the terminating null character.
        // If the specified environment variable name was not found
        //     in the environment block for the current process,
        //     the return value is zero.
        // If the buffer pointed to by lpcchBuffer is not large enough,
        //     the return value is the buffer size, in characters,
        //     required to hold the value string and its terminating
        //     null character.
        //

        cch = GetEnvironmentVariable( pszValName,
                                     pchBuffer,
                                     *lpcchBuffer);

        if ( cch == 0) {
            SetLastError( ERROR_INVALID_INDEX );
            fReturn = FALSE;

        } else if ( cch < *lpcchBuffer ) {

            // data is already copied. No problems. Return the length.
            *lpcchBuffer = (cch + 1);
            fReturn = TRUE;

        } else {

            *lpcchBuffer = cch;
            SetLastError( ERROR_INSUFFICIENT_BUFFER);
            fReturn = FALSE;
        }
    }

    return (fReturn);

} // HTTP_REQUEST::GetInfoMisc()


/************************************************************
 *   Support Functions for GetInfoXXX
 ************************************************************/


BOOL
GetInfoFromCertificate(
     IN TCP_AUTHENT & tcpauth,
     IN LPCSTR        pszValName,
     DWORD            cchValName,
     OUT CHAR *       pchBuffer,
     IN OUT DWORD  *  lpcchBuffer
     )
{
    IISMD5_CTX  md5;
    BOOL        fReturn = FALSE;
    BOOL        fNoCert;
    DWORD       i;
    CHAR        achCertName[MAX_CERT_FIELD_SIZE];
    DWORD       dwCertInfo;

    DBG_ASSERT( pszValName != NULL);
    DBG_ASSERT( !memcmp( pszValName - 5, "CERT_", 5) ||
                !memcmp( pszValName - 6, "HTTPS_", 6)
                );


    //
    // Find the value for the field in a certificate that is requested
    //

    if ( IsStringMatch( "SUBJECT", pszValName, cchValName )) {

        LPSTR pV = NULL;
        if ( !tcpauth.QueryCertificateSubject( achCertName, sizeof(achCertName), &fNoCert ) ) {

            fReturn = fNoCert ? ReturnNullString( pchBuffer, lpcchBuffer ) : FALSE;
        } else {
            fReturn = CopyStringToBuffer( achCertName, pchBuffer, lpcchBuffer);
        }
    } else if ( IsStringMatch( "ISSUER", pszValName, cchValName )) {

        LPSTR pV = NULL;
        if ( !tcpauth.QueryCertificateIssuer( achCertName, sizeof(achCertName), &fNoCert ) ) {
            // no certificate available

            fReturn = fNoCert ? ReturnNullString( pchBuffer, lpcchBuffer ) : FALSE;
        } else {
            fReturn = CopyStringToBuffer( achCertName, pchBuffer, lpcchBuffer);
        }
    } else if ( IsStringMatch( "FLAGS", pszValName, cchValName )) {
        DWORD dwF;
        CHAR rgF[40];
        if ( !tcpauth.QueryCertificateFlags( &dwF, &fNoCert ) ) {

            rgF[0] = '\0';
        } else {
            _ultoa( dwF, rgF, 10);
        }

        fReturn = CopyStringToBuffer( rgF, pchBuffer, lpcchBuffer);
    } else if ( IsStringMatch( "SERIALNUMBER", pszValName, cchValName )) {

        LPBYTE  pV;
        DWORD   cch;        // Buffer bytes

        if ( !tcpauth.QueryCertificateSerialNumber( &pV, &dwCertInfo, &fNoCert ) ) {
            // no certificate available

            fReturn = fNoCert ? ReturnNullString( pchBuffer, lpcchBuffer ) : FALSE;
        } else {

            // Buffer size (cert bytes * 2 + # of '-' + NULL)
            cch = dwCertInfo * 3;
            if ( (pchBuffer == NULL) || (*lpcchBuffer < cch) )
            {
                SetLastError( ERROR_INSUFFICIENT_BUFFER);
                fReturn = FALSE;
            }
            else
            {
                // Serial number is in reverse byte order
                i = 0;
                for( INT iSerialByte = dwCertInfo - 1; iSerialByte >= 0; --iSerialByte )
                {
                    pchBuffer[i++] = g_szHexDigits[ *(pV + iSerialByte) >> 4 ];
                    pchBuffer[i++] = g_szHexDigits[ *(pV + iSerialByte) & 0xf ];
                    pchBuffer[i++] = '-';
                }
                DBG_ASSERT(i == cch);
        
                pchBuffer[ cch - 1 ] = 0;
                fReturn = TRUE;
            }
            *lpcchBuffer = cch;
        }
    } else if ( IsStringMatch( "COOKIE", pszValName, cchValName )) {

        LPSTR pV;
        DWORD cch;      // Buffer bytes

        if ( !tcpauth.QueryCertificateIssuer( achCertName, sizeof(achCertName), &fNoCert ) ) {

            // no certificate available

            fReturn = fNoCert ? ReturnNullString( pchBuffer, lpcchBuffer ) : FALSE;
        } else {

            IISMD5Init( &md5 );
            IISMD5Update( &md5, (LPBYTE)achCertName, strlen(achCertName) );
            
            if ( !tcpauth.QueryCertificateSerialNumber( (LPBYTE*)&pV, &dwCertInfo, &fNoCert )) {

                // assumes that the above call set the error code

                DBG_ASSERT( fReturn == FALSE);

            } else {

                // Buffer size
                cch = (sizeof(md5.digest) * 2) + 1;

                if ((pchBuffer == NULL) || (*lpcchBuffer < cch) ) 
                {
                    SetLastError( ERROR_INSUFFICIENT_BUFFER);
                    fReturn = FALSE;
                } 
                else 
                {
                    IISMD5Update( &md5, (LPBYTE)pV, dwCertInfo );
                    IISMD5Final( &md5 );
                    for ( i = 0 ; i < sizeof(md5.digest) ; ++i ) {
                        wsprintf( pchBuffer + i * 2, "%02x", md5.digest[i] );
                    }
                    fReturn = TRUE;
                }
                *lpcchBuffer = cch;
            }
        }
    } else if ( IsStringMatch( "KEYSIZE", pszValName, cchValName)) {

        DWORD dwVal;
        CHAR rgVal[40];
        if ( !tcpauth.QueryEncryptionKeySize( &dwVal, &fNoCert ) ) {

            rgVal[0] = '\0';
        } else {
            _ultoa( dwVal, rgVal, 10);
        }

        fReturn = CopyStringToBuffer( rgVal, pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "SECRETKEYSIZE", pszValName, cchValName )) {

        DWORD dwVal;
        CHAR rgVal[40];
        if ( !tcpauth.QueryEncryptionServerPrivateKeySize( &dwVal, &fNoCert ) ) {

            rgVal[0] = '\0';
        } else {
            _ultoa( dwVal, rgVal, 10);
        }

        fReturn = CopyStringToBuffer( rgVal, pchBuffer, lpcchBuffer);

    } else if ( IsStringMatch( "SERVER_SUBJECT", pszValName, cchValName )) {

        LPSTR pV;
        if ( !tcpauth.QueryServerCertificateSubject( &pV, &fNoCert ) ) {

            // no certificate available

            fReturn = fNoCert ? ReturnNullString( pchBuffer, lpcchBuffer ) : FALSE;
        } else {
            fReturn = CopyStringToBuffer( pV, pchBuffer, lpcchBuffer);
        }
    } else if ( IsStringMatch( "SERVER_ISSUER", pszValName, cchValName )) {

        LPSTR pV;
        if ( !tcpauth.QueryServerCertificateIssuer( &pV, &fNoCert ) ) {

            // no certificate available

            fReturn = fNoCert ? ReturnNullString( pchBuffer, lpcchBuffer ) : FALSE;
        } else {
            fReturn = CopyStringToBuffer( pV, pchBuffer, lpcchBuffer);
        }
    } else {

        SetLastError( ERROR_INVALID_INDEX);
        DBG_ASSERT( fReturn == FALSE);
    }

    return ( fReturn);
} // GetInfoFromCertificate()




# define PSZ_HTTP_PREFIX      "HTTP_"
# define LEN_PSZ_HTTP_PREFIX  (sizeof(PSZ_HTTP_PREFIX) - 1)

BOOL
BuildCGIHeaderList(
    HTTP_HEADERS * pHeaderList,
    CHAR *        pchBuffer,
    DWORD *       lpcchBuffer
    )
/*++

Routine Description:

    Builds a list of all client passed headers in the form of

    //
    //  Builds a list of all client HTTP headers in the form of:
    //
    //    HTTP_<up-case header>: <field>\n
    //    HTTP_<up-case header>: <field>\n
    //    ...
    //

Arguments:

    pstr - Receives full list
    pHeaderList - List of headers

--*/
{
    CHAR * pchStart  = pchBuffer;

    DWORD  cchReq    = 0;
    BOOL   fReturn   = TRUE;

    HH_ITERATOR       hhi;
    NAME_VALUE_PAIR * pnp = NULL;

    pHeaderList->InitIterator( &hhi);

    while ( pHeaderList->NextPair( &hhi, &pnp)) {

        //
        //  Ignore "method", "url" and "version"
        //

        if ( pnp->pchName[pnp->cchName - 1] != ':' ) {
            continue;
        }

        //
        // add HTTP_ as prefix to the headers
        // convert all "-" to "_"
        // convert header names to UpperCase
        //

        //+1 for terminating '\n'
        cchReq += (pnp->cchName + pnp->cchValue + 1 + LEN_PSZ_HTTP_PREFIX);

        if ( pchStart != NULL && cchReq < *lpcchBuffer) {

            DWORD  i;

            CopyMemory( pchBuffer, PSZ_HTTP_PREFIX, LEN_PSZ_HTTP_PREFIX);
            pchBuffer += LEN_PSZ_HTTP_PREFIX;

            //
            //  Convert the destination to upper and replace all '-' with '_'
            //  Also convert lower-case header names to upper-case
            //

            for ( i = 0; i < pnp->cchName; i++) {
                pchBuffer[i] = (( pnp->pchName[i] == '-') ? '_' :
                                toupper( pnp->pchName[i])
                                );
            } // for

            pchBuffer += i;
            CopyMemory( (LPVOID) pchBuffer, pnp->pchValue, pnp->cchValue);
            pchBuffer += pnp->cchValue;
            *pchBuffer++ = '\n'; // store a \n
        } else {

            fReturn = FALSE;
        }
    } // while


    // Store the size depending upon if buffer was sufficient or not

    if ( fReturn && (pchStart != NULL)) {

        DBG_ASSERT( pchBuffer >= pchStart);
        *pchBuffer++ = '\0';       // +1 for '\0'
        *lpcchBuffer = DIFF(pchBuffer - pchStart);

    } else {

        fReturn = FALSE;
        *lpcchBuffer = cchReq + sizeof(CHAR);
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
    }

    return ( fReturn);
} // BuildCGIHeaderList()



BOOL
HseBuildRawHeaders( IN HTTP_HEADERS * pHeaderList,
                    OUT LPSTR       pchBuffer,
                    IN OUT LPDWORD  lpcchBuffer
                    )
/*++

Routine Description:

    Builds a list of all raw client passed headers in the form of

      <header>:<blank><field>\n
      <header>:<blank><field>\n

Arguments:

    pHeaderList - List of headers
    pchBuffer   - pointer to buffer which will contain generated headers
    lpcchBuffer - pointer to DWORD containing size of buffer
                 It will contain the size of written data on return.

Returns:
    TRUE on success and FALSE if failure.
     Error code is set to ERROR_INSUFFICIENT_BUFFER
      if there is not enough buffer.

--*/
{
    CHAR * pchStart  = pchBuffer;

    DWORD  cchReq    = 0;
    BOOL   fReturn   = TRUE;

    HH_ITERATOR       hhi;
    NAME_VALUE_PAIR * pnp = NULL;

    pHeaderList->InitIterator( &hhi);

    while ( pHeaderList->NextPair( &hhi, &pnp)) {

        //
        //  Ignore "method", "url" and "version"
        //

        if ( pnp->pchName[pnp->cchName - 1] != ':' ) {
            continue;
        }

        //
        // leave the headers in native form i.e. no conversion of '-' to '_'
        //

        cchReq += (pnp->cchName + pnp->cchValue + 3); //+3 for blank & \r\n

        if ( pchStart != NULL && cchReq < *lpcchBuffer) {

            CopyMemory( (LPVOID) pchBuffer, pnp->pchName,
                        pnp->cchName * sizeof(CHAR));
            pchBuffer += pnp->cchName;
            *pchBuffer++ = ' '; // store a blank
            memmove( (LPVOID) pchBuffer, pnp->pchValue, pnp->cchValue);
            pchBuffer += pnp->cchValue;
            *pchBuffer++ = '\r'; // store a \r
            *pchBuffer++ = '\n'; // store a \n
        } else {

            fReturn = FALSE;
        }
    } // while


    // Store the size depending upon if buffer was sufficient or not

    if ( fReturn && (pchStart != NULL)) {

        DBG_ASSERT( pchBuffer >= pchStart);
        *pchBuffer++ = '\0';       // +1 for '\0'
        *lpcchBuffer = DIFF(pchBuffer - pchStart);
    } else {

        fReturn = FALSE;
        *lpcchBuffer = cchReq + sizeof(CHAR);
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
    }

    return (fReturn);

} // HseBuildRawHeaders()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\httpfilt.cxx ===
/*++




Copyright (c) 1994  Microsoft Corporation

Module Name:

    httpfilt.cxx

Abstract:

    This module contains the Microsoft HTTP server filter module

Author:

    John Ludeman (johnl)   31-Jan-1995

Revision History:

--*/

#include "w3p.hxx"

//
// Maximum allowable cached buffer
//

#define MAX_CACHED_FILTER_BUFFER    (8 * 1024)

//
//  Maximum number of filters we allow (per-instance - includes global filters)
//

#define MAX_FILTERS                 50

//
//  Private globals.
//

BOOL
WINAPI
ServerFilterCallback(
    struct _HTTP_FILTER_CONTEXT * pfc,
    enum SF_REQ_TYPE              se,
    void *                        pData,
    ULONG_PTR                     ul,
    ULONG_PTR                     ul2
    );

BOOL
WINAPI
GetServerVariable(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszVariableName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
    );

BOOL
WINAPI
WriteFilterClient(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPVOID                        Buffer,
    LPDWORD                       lpdwBytes,
    DWORD                         dwReserved
    );

VOID *
WINAPI
AllocFilterMem(
    struct _HTTP_FILTER_CONTEXT * pfc,
    DWORD                         cbSize,
    DWORD                         dwReserved
    );

BOOL
WINAPI
ServerSupportFunction(
    struct _HTTP_FILTER_CONTEXT * pfc,
    enum SF_REQ_TYPE              sfReq,
    PVOID                         pData,
    ULONG_PTR                     ul1,
    ULONG_PTR                     ul2
    );

BOOL
WINAPI
AddFilterResponseHeaders(
    HTTP_FILTER_CONTEXT * pfc,
    LPSTR                 lpszHeaders,
    DWORD                 dwReserved
    );

VOID
FilterAtqCompletion(
    PVOID        Context,
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    );

VOID
ContinueRawRead(
    PVOID        Context,
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    );

BOOL
WINAPI
CompressionFilterCheck(
    HTTP_FILTER_CONTEXT *pfc,
    LPVOID              lpszEncodingString,
    ULONG_PTR           lpszVerbString,
    ULONG_PTR           sizesForBuffers
    );


/*****************************************************************/

BOOL
HTTP_FILTER::NotifyRequestSecurityContextClose(
    HTTP_FILTER_DLL * pFilterDLL,
    CtxtHandle *      pCtxt
    )
{
    HTTP_FILTER_REQUEST_CLOSE_SECURITY_CONTEXT hfcc;
    HTTP_FILTER_CONTEXT *   phfc;
    HTTP_FILTER_DLL *       pFilt;
    FILTER_LIST *           pFilterList;
    SF_STATUS_TYPE          sfStatus = SF_STATUS_REQ_HANDLED_NOTIFICATION;
    DWORD                   i;

    hfcc.pCtxt = (PVOID)pCtxt;

    phfc                     = QueryContext();
    phfc->fIsSecurePort      = QueryReq()->IsSecurePort();

    pFilterList = QueryFilterList();

    //
    //  If this filter doesn't support this type of notification
    //  then ignore it
    //

    if ( !pFilterDLL->IsNotificationNeeded(
             SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE,
             phfc->fIsSecurePort ))
    {
        //
        //  This filter doesn't support this type of notification.
        //

        return FALSE;
    }

    //
    //  This request is targetted at a particular DLL so find the filter
    //  context in the filter list
    //

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        if ( pFilterDLL == pFilterList->QueryDll( i ) )
        {
            phfc->pFilterContext = QueryClientContext( i );

            sfStatus = (SF_STATUS_TYPE)
                       pFilterDLL->QueryEntryPoint()( phfc,
                                                      SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE,
                                                      &hfcc );

            SetClientContext( i, phfc->pFilterContext );
        }

        break;
    }

    return sfStatus == SF_STATUS_REQ_HANDLED_NOTIFICATION;
}


BOOL
HTTP_FILTER::NotifyRawReadDataFilters(
    VOID *          pvInData,
    DWORD           cbInData,
    DWORD           cbInBuffer,
    VOID * *        ppvOutData,
    DWORD *         pcbOutData,
    BOOL *          pfRequestFinished,
    BOOL *          pfReadAgain
    )
/*++

Routine Description:

    This method handles notification of all filters that handle the
    raw data notifications.

    Note this is the only routine that needs to save phfc->pFilterContext
    because this is the only notification that can get occur while we're
    in another notification.

Arguments:

    pvInData - Raw data
    cbInData - count of bytes of raw data
    cbInBuffer - Size of input buffer
    ppvOutData - Receives pointer to buffer of translated data
    pcbOutData - Number of bytes of translated data
    pfRequestFinished - Set to TRUE if the filter completed request processing
    pfReadAgain - Set to TRUE if the caller should issue another read and
        call this routine again

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    HTTP_FILTER_RAW_DATA    hfrd;
    HTTP_FILTER_CONTEXT *   phfc;
    HTTP_FILTER_DLL *       pFilterDLL;
    FILTER_LIST *           pFilterList;
    SF_STATUS_TYPE          sfStatus;
    VOID *                  pvClientContext;
    DWORD                   CurrentDll;
    DWORD                   i;
    PVOID                   pvtmp;

    //
    //  Don't notify on zero length writes
    //

    if ( !cbInData )
    {
        *ppvOutData        = pvInData;
        *pcbOutData        = cbInData;
        return TRUE;
    }

    //
    //  Fill out the raw read structure
    //

    hfrd.pvInData        = pvInData;
    hfrd.cbInData        = cbInData;
    hfrd.cbInBuffer      = cbInBuffer;

    //
    //  Increment the nested notification level
    //

    _cRawNotificationLevel++;

    //
    //  Initialize items specific to this request
    //

    phfc                     = QueryContext();
    phfc->fIsSecurePort      = QueryReq()->IsSecurePort();

    //
    //  Save the current client context in the filter structure and the
    //  current dll because we may be in the middle of another filter
    //  notification
    //

    pvClientContext  = phfc->pFilterContext;
    CurrentDll =       QueryCurrentDll();
    pFilterList =      QueryFilterList();

    //
    //  If a filter needs to do a WriteClient in the middle of a raw data
    //  notification, we only notify the filters down (or up) the chain
    //

    i = (CurrentDll == INVALID_DLL ? 0 : CurrentDll);

    //
    //  For recv operations, walk the list in order so encryption filters
    //  are at the front of the list
    //


    for ( ; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDLL = pFilterList->QueryDll( i );

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        // NOTE : This code is also executed in the functions
        // HTTP_FILTER::NotifyRawSendDataFilters and HTTP_FILTER::NotifyFilters, so
        // any changes/corrections need to be made there as well. The reason it wasn't
        // broken out into a function is that this code is on the main-line code path
        // for each request and making a function call for each filter loaded would
        // be an efficiency hit.
        //

        if ( !QueryNotificationChanged() )
        {
            if (! pFilterDLL->IsNotificationNeeded(SF_NOTIFY_READ_RAW_DATA,
                                                   phfc->fIsSecurePort ))
            {
                //
                //  This filter doesn't support this type of notification.
                //

                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_READ_RAW_DATA,
                                               phfc->fIsSecurePort ))
            {
                //
                //  This filter doesn't support this type of notification.
                //

                continue;
            }
        }


        SetCurrentDll( i );

        pvtmp = phfc->pFilterContext = QueryClientContext( i );

        sfStatus = (SF_STATUS_TYPE)
                   pFilterDLL->QueryEntryPoint()( phfc,
                                                  SF_NOTIFY_READ_RAW_DATA,
                                                  &hfrd );
        if ( pvtmp != phfc->pFilterContext )
            SetClientContext( i, phfc->pFilterContext );

        switch ( sfStatus )
        {
        default:
            DBGPRINTF((DBG_CONTEXT,
                       "[NotifyRawReadDataFilters] Unknown status code from filter %d\n",
                       sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            SetCurrentDll( CurrentDll );
            _cRawNotificationLevel--;
            phfc->pFilterContext = pvClientContext;
            return FALSE;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported for raw data
            QueryReq()->Disconnect();
            *pfRequestFinished = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;

        case SF_STATUS_REQ_READ_NEXT:

            *pfReadAgain = TRUE;
            goto Exit;
        }
    }

Exit:
    *ppvOutData        = hfrd.pvInData;
    *pcbOutData        = hfrd.cbInData;

    phfc->pFilterContext    = pvClientContext;
    _cRawNotificationLevel--;
    SetCurrentDll( CurrentDll );

    return TRUE;
}

BOOL
HTTP_FILTER::NotifyRawSendDataFilters(
    VOID *          pvInData,
    DWORD           cbInData,
    DWORD           cbInBuffer,
    VOID * *        ppvOutData,
    DWORD *         pcbOutData,
    BOOL *          pfRequestFinished
    )
/*++

Routine Description:

    This method handles notification of all filters that handle the
    raw data notifications.

    Note this is the only routine that needs to save phfc->pFilterContext
    because this is the only notification that can get occur while we're
    in another notification.

Arguments:

    pvInData - Raw data
    cbInData - count of bytes of raw data
    cbInBuffer - Size of input buffer
    ppvOutData - Receives pointer to buffer of translated data
    pcbOutData - Number of bytes of translated data
    pfRequestFinished - Set to TRUE if the filter completed request processing

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    HTTP_FILTER_RAW_DATA    hfrd;
    HTTP_FILTER_CONTEXT *   phfc;
    HTTP_FILTER_DLL *       pFilterDLL;
    FILTER_LIST *           pFilterList;
    DWORD                   err;
    SF_STATUS_TYPE          sfStatus;
    VOID *                  pvClientContext;
    DWORD                   CurrentDll;
    DWORD                   i;
    PVOID                   pvtmp;

    //
    //  Don't notify on zero length writes
    //

    if ( !cbInData )
    {
        *ppvOutData = pvInData;
        *pcbOutData = cbInData;
        return TRUE;
    }

    pFilterList = QueryFilterList();

    //
    //  Fill out the raw send structure
    //

    hfrd.pvInData        = pvInData;
    hfrd.cbInData        = cbInData;
    hfrd.cbInBuffer      = cbInBuffer;

    //
    //  Increment the nested notification level
    //

    _cRawNotificationLevel++;

    //
    //  Initialize items specific to this request
    //

    phfc                     = QueryContext();
    phfc->fIsSecurePort      = QueryReq()->IsSecurePort();

    //
    //  Save the current client context in the filter structure and the
    //  current dll in the because we may be in the middle of another filter
    //  notification
    //

    pvClientContext  = phfc->pFilterContext;
    CurrentDll =       QueryCurrentDll();
    pFilterList =      QueryFilterList();

    //
    //  If a filter needs to do a WriteClient in the middle of a raw data
    //  notification, we only notify the filters up the chain
    //

    i = (CurrentDll == INVALID_DLL ? pFilterList->QueryFilterCount() - 1
                                            : CurrentDll) ;

    //
    //  For send operations, walk the list in reverse so encryption filters
    //  are at the end of the list
    //

    do {

        pFilterDLL = pFilterList->QueryDll( i );


        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        // NOTE : This code is also executed in the functions
        // HTTP_FILTER::NotifyRawReadDataFilters and HTTP_FILTER::NotifyFilters, so
        // any changes/corrections need to be made there as well. The reason it wasn't
        // broken out into a function is that this code is on the main-line code path
        // for each request and making a function call for each filter loaded would
        // be an efficiency hit.
        //


        if ( !QueryNotificationChanged() )
        {
            if (! pFilterDLL->IsNotificationNeeded(SF_NOTIFY_SEND_RAW_DATA,
                                                   phfc->fIsSecurePort ))
            {
                //
                //  This filter doesn't support this type of notification.
                //

                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_SEND_RAW_DATA,
                                               phfc->fIsSecurePort ))
            {
                //
                //  This filter doesn't support this type of notification.
                //

                continue;
            }
        }

        SetCurrentDll( i );

        pvtmp = phfc->pFilterContext = QueryClientContext( i );

        sfStatus = (SF_STATUS_TYPE)
                   pFilterDLL->QueryEntryPoint()( phfc,
                                                  SF_NOTIFY_SEND_RAW_DATA,
                                                  &hfrd );

        if ( pvtmp != phfc->pFilterContext )
            SetClientContext( i, phfc->pFilterContext );

        switch ( sfStatus )
        {
        default:
            DBGPRINTF((DBG_CONTEXT,
                       "[NotifyRawSendDataFilters] Unknown status code from filter %d\n",
                       sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            SetCurrentDll( CurrentDll );
            _cRawNotificationLevel--;
            phfc->pFilterContext = pvClientContext;
            return FALSE;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported for raw data
            QueryReq()->Disconnect();
            *pfRequestFinished = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    } while ( i-- > 0 );


Exit:
    *ppvOutData        = hfrd.pvInData;
    *pcbOutData        = hfrd.cbInData;

    phfc->pFilterContext    = pvClientContext;
    _cRawNotificationLevel--;
    SetCurrentDll( CurrentDll );

    return TRUE;
}


BOOL
HTTP_FILTER::NotifyRequestRenegotiate(
    HTTP_FILTER * pFilter,
    LPBOOL pfAccepted,
    BOOL fMapCert
    )
/*++

Routine Description:


Arguments:

    pFilter - Pointer to filter object
    pAccepted - updated with TRUE if request accepted

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    HTTP_FILTER_CONTEXT *       phfc;
    HTTP_FILTER_DLL *           pFilterDLL;
    SF_STATUS_TYPE              sfStatus;
    HTTP_FILTER_REQUEST_CERT    hfrc;
    DWORD                       i;
    FILTER_LIST *               pFilterList;
    PVOID                       pvtmp;

    //
    //  Increment the nested notification level
    //

    pFilter->_cRawNotificationLevel++;

    //
    //  Initialize items specific to this request
    //

    phfc                     = pFilter->QueryContext();
    phfc->fIsSecurePort      = pFilter->QueryReq()->IsSecurePort();
    phfc->ulReserved         = 0;


    pFilterList =      QueryFilterList();

    hfrc.fMapCert = fMapCert;
    hfrc.dwReserved = 0;

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDLL = pFilterList->QueryDll( i );

        //
        //  Skip this DLL if it doesn't want this notification
        //

        if ( !pFilterDLL->IsNotificationNeeded( SF_NOTIFY_RENEGOTIATE_CERT,
                                                phfc->fIsSecurePort ))
        {
            continue;
        }

        pFilter->SetCurrentDll( i );

        pvtmp = phfc->pFilterContext = pFilter->QueryClientContext( i );

        sfStatus = (SF_STATUS_TYPE)
                   pFilterDLL->QueryEntryPoint()( phfc,
                                                  SF_NOTIFY_RENEGOTIATE_CERT,
                                                  &hfrc );

        if ( pvtmp != phfc->pFilterContext )
            pFilter->SetClientContext( i, phfc->pFilterContext );

        switch ( sfStatus )
        {
        default:
            DBGPRINTF((DBG_CONTEXT,
                       "[NotifyRenegoCert] Unknown status code from filter %d\n",
                       sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            pFilter->SetCurrentDll( INVALID_DLL );
            pFilter->_cRawNotificationLevel--;
            return FALSE;

        case SF_STATUS_REQ_FINISHED:            // not supported
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            pFilter->QueryReq()->SetKeepConn( FALSE );
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            *pfAccepted = hfrc.fAccepted;

            goto Exit;
        }
    }

Exit:
    pFilter->SetCurrentDll( INVALID_DLL );
    pFilter->_cRawNotificationLevel--;

    return TRUE;
}


BOOL
HTTP_FILTER::NotifyAccessDenied(
    const CHAR *  pszURL,
    const CHAR *  pszPhysicalPath,
    BOOL *        pfFinished
    )
/*++

Routine Description:

    This method handles notification of all filters that handle the
    access denied notification

Arguments:

    pszURL - URL that was target of request
    pszPath - Physical path the URL mapped to
    pfFinished - Set to TRUE if no further processing is required

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    HTTP_FILTER_ACCESS_DENIED   hfad;
    HTTP_FILTER_CONTEXT *       phfc;
    BOOL                        fRet;

    //
    //  If these flags are not set, then somebody hasn't indicated the reason
    //  for denying the user access
    //

    DBG_ASSERT( QueryDeniedFlags() != 0 );

    //
    //  Ignore the notification of a send "401 ..." if this notification
    //  generated it
    //

    if ( _fInAccessDeniedNotification )
    {
        return TRUE;
    }

    _fInAccessDeniedNotification = TRUE;

    //
    //  Fill out the url map structure
    //

    hfad.pszURL          = pszURL;
    hfad.pszPhysicalPath = pszPhysicalPath;
    hfad.dwReason        = QueryDeniedFlags();

    //
    //  Initialize items specific to this request
    //

    phfc                     = QueryContext();
    phfc->fIsSecurePort      = QueryReq()->IsSecurePort();

    fRet = NotifyFilters(
               SF_NOTIFY_ACCESS_DENIED,
               phfc,
               &hfad,
               pfFinished,
               FALSE );

    _fInAccessDeniedNotification = FALSE;

    return fRet;
}

BOOL
HTTP_FILTER::NotifySendHeaders( const CHAR * pszHeaderList,
                                BOOL *       pfFinished,
                                BOOL *       pfAnyChanges,
                                BUFFER *     pChangeBuff )
{
    HTTP_FILTER_SEND_RESPONSE   hfph;
    BOOL                        fRet;
    DWORD                       cbJump;

    hfph.GetHeader    = GetSendHeader;
    hfph.SetHeader    = SetSendHeader;
    hfph.AddHeader    = AddSendHeader;

    _pchSendHeaders   = pszHeaderList;

    // When parsing out the status code, beware of bad response buffers:
    //  - empty buffers (in case of HTTP 0.x requests)
    //  - buffers not starting with HTTP/X.X
    //

    // first line is the status

    cbJump = sizeof( "HTTP/X.X" );
    if ( strlen( pszHeaderList ) > ( cbJump - 1 ) )
    {
        pszHeaderList += cbJump;
    }

    while ( *pszHeaderList != '\0' &&
            *pszHeaderList != '\r' &&
            *pszHeaderList != '\n' &&
            !isdigit( (UCHAR)(*pszHeaderList) ))
    {
        pszHeaderList++;
    }

    // If for some reason, there was no version in string,
    // atoi() returns 0 on the empty string, which I guess is OK.

    hfph.HttpStatus = atoi( pszHeaderList );

    fRet = NotifyFilters( SF_NOTIFY_SEND_RESPONSE,
                          QueryContext(),
                          &hfph,
                          pfFinished,
                          FALSE );

    if ( pfAnyChanges )
    {
        *pfAnyChanges = _fSendHeadersChanged;
    }

    if ( fRet && _fSendHeadersChanged )
    {
        fRet = BuildNewSendHeaders( pChangeBuff );
    }

    //
    // Make sure we reparse the headers
    //
    SetSendHeadersParsed(FALSE);
    _SendHeaders.Reset();

    return fRet;
}

BOOL
FILTER_LIST::NotifyFilters(
    HTTP_FILTER *         pFilter,
    DWORD                 NotificationType,
    HTTP_FILTER_CONTEXT * phfc,
    PVOID                 NotificationData,
    BOOL *                pfFinished,
    BOOL                  fNotifyAll
    )
/*++

Routine Description:

    Notifies all registered filters on this filter list for the specified
    notification type

Arguments:

    pFilter - Pointer to filter making this request
    NotificationType - SF_NOTIFY_ flag indicating the notification type
    pfc - Pointer to filter context
    NotificationData - Pointer to notification specific structure
    fNotifyAll - If TRUE, always notify all filters regardless of return code
        from filter

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    HTTP_FILTER_DLL *           pFilterDLL;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;

    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    pvCurrentClientContext = phfc->pFilterContext;

    phfc->fIsSecurePort  = pFilter->QueryReq()->IsSecurePort();

    for ( i = 0; i < m_cFilters; i++ )
    {
        pFilterDLL = QueryDll( i );

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        // NOTE : This code is also executed in the functions
        // HTTP_FILTER::NotifyRawSendDataFilters and HTTP_FILTER::NotifyRawReadDataFilters, so
        // any changes/corrections need to be made there as well. The reason it wasn't
        // broken out into a function is that this code is on the main-line code path
        // for each request and making a function call for each filter loaded would
        // be an efficiency hit.
        //

        if ( !pFilter->QueryNotificationChanged() )
        {
            if ( !pFilterDLL->IsNotificationNeeded( NotificationType,
                                                    phfc->fIsSecurePort ))
            {
                //
                //  This filter doesn't support this type of notification.
                //

                continue;
            }
        }
        else
        {
            if ( !pFilter->IsDisableNotificationNeeded( i,
                                                        NotificationType,
                                                        phfc->fIsSecurePort ) )
            {
                continue;
            }
        }

        pFilter->SetCurrentDll( i );

        pvtmp = phfc->pFilterContext = pFilter->QueryClientContext( i );

        sfStatus = (SF_STATUS_TYPE)
                   pFilterDLL->QueryEntryPoint()( phfc,
                                                  NotificationType,
                                                  NotificationData );

        if ( pvtmp != phfc->pFilterContext )
            pFilter->SetClientContext( i, phfc->pFilterContext );

        switch ( sfStatus )
        {
        default:
            DBGPRINTF((DBG_CONTEXT,
                       "[NotifyFilters] Unknown status code from filter %d\n",
                       sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            phfc->pFilterContext = pvCurrentClientContext;
            pFilter->SetCurrentDll( INVALID_DLL );
            return FALSE;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            pFilter->QueryReq()->SetKeepConn( FALSE );
            *pfFinished = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }

Exit:
    //
    // Reset the filter context we came in with
    //
    phfc->pFilterContext = pvCurrentClientContext;

    pFilter->SetCurrentDll( INVALID_DLL );

    return TRUE;
}

VOID FILTER_LIST::SetNotificationFlags(
    DWORD i,
    HTTP_FILTER_DLL * pFilterDll
    )
/*++

Routine Description:

    Adjusts the filter flags in the filter list. Note this is only safe on
    global filters, not per website filters.

Arguments:

    i - index of filter dll that is being adjusted
    pFilterDll - Pointer to filter dll that contains the updated list

Return Value:

--*/
{
    DWORD dwSec = 0;
    DWORD dwNonSec = 0;

    //
    //  Reset the flags in the array then rebuild the set of flags for
    //  the filter list.  Build the set in a temporary so the filter list
    //  gets updated in a single action so other filters won't be impacted
    //

    ((DWORD*) m_buffSecureArray.QueryPtr())[i] = pFilterDll->QuerySecureFlags();
    ((DWORD*) m_buffNonSecureArray.QueryPtr())[i] = pFilterDll->QueryNonsecureFlags();

    for (DWORD j = 0; j < m_cFilters; j++)
    {
        dwSec    |= QueryDll(j)->QuerySecureFlags();
        dwNonSec |= QueryDll(j)->QueryNonsecureFlags();
    }

    m_SecureNotifications = dwSec;
    m_NonSecureNotifications = dwNonSec;
}

HTTP_FILTER_DLL* FILTER_LIST::HasFilterDll(
    HTTP_FILTER_DLL *pFilterDll
    )
/*++

Routine Description:

    Checks whether this filter list contains a specific filter dll


Arguments:

    pFilterDll - filter dll to look for

Return Value:

    Pointer to matching HTTP_FILTER_DLL object if found, NULL otherwise.

    [This is probably redundant, since HTTP_FILTER_DLL objects are unique ...]

--*/
{
    HTTP_FILTER_DLL **apFilterDll = (HTTP_FILTER_DLL **)(m_buffFilterArray.QueryPtr());

    for ( DWORD i = 0; i < m_cFilters; i++ )
    {
        if ( apFilterDll[i] == pFilterDll )
        {
            return pFilterDll;
        }
    }

    return NULL;
}


HTTP_FILTER::HTTP_FILTER(
    HTTP_REQ_BASE       * pRequest
    )
/*++

Routine Description:

    Copies the filter context

Arguments:

    pRequest - Pointer to HTTP request this filter should be applied to

Return Value:

--*/
    : _fIsValid         ( FALSE ),
      _pRequest         ( pRequest ),
      _apvContexts      ( NULL ),
      _pFilterList      ( NULL ),
      _pGlobalFilterList( NULL ),
      _fSendHeadersChanged( FALSE ),
      _fSendHeadersParsed( FALSE ),
      _dwSecureNotifications( 0 ),
      _dwNonSecureNotifications( 0 ),
      _fNotificationsDisabled( FALSE )
{
    InitializeListHead( &_PoolHead );

    _hfc.cbSize             = sizeof( _hfc );
    _hfc.Revision           = HTTP_FILTER_REVISION;
    _hfc.ServerContext      = (void *) this;
    _hfc.ulReserved         = 0;

    _hfc.ServerSupportFunction = ServerFilterCallback;
    _hfc.GetServerVariable     = GetServerVariable;
    _hfc.AddResponseHeaders    = AddFilterResponseHeaders;
    _hfc.WriteClient           = WriteFilterClient;
    _hfc.AllocMem              = AllocFilterMem;

    _Overlapped.hEvent = NULL;
    _CurrentFilter     = INVALID_DLL;

    //
    //  Allocate the array of contexts for this request
    //

    _apvContexts = new PVOID[MAX_FILTERS];

    if ( !_apvContexts )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    //
    //  Initialize the array of filter contexts
    //

    memset( _apvContexts, 0, MAX_FILTERS * sizeof(PVOID) );


    //Reset();  We Assume Reset will be called when initializing the session

    SetGlobalFilterList( GLOBAL_FILTER_LIST() );

    _fIsValid = TRUE;
}

VOID
HTTP_FILTER::Reset(
    VOID
    )
/*++

Routine Description:

    Resets the state of this filter.  Called between net sessions.

--*/
{
    FILTER_POOL_ITEM * pfpi;

    _cbRecvRaw      = 0;
    _cbRecvTrans    = 0;
    _hFile          = NULL;
    _pFilterGetFile = NULL;
    _cbFileReadSize = 4096;
    _cRawNotificationLevel = 0;
    _dwDeniedFlags  = 0;
    _fInAccessDeniedNotification = FALSE;
    _pchSendHeaders = NULL;
    _fNotificationsDisabled = FALSE;

    if ( _fSendHeadersParsed )
    {
        _SendHeaders.Reset();
    }

    _fSendHeadersChanged = FALSE;
    _fSendHeadersParsed  = FALSE;
}

VOID
HTTP_FILTER::Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleans up this filter.  Called after a session terminates.

--*/
{
    FILTER_POOL_ITEM * pfpi;

    //
    //  Reset the array of filter contexts
    //

    memset( _apvContexts, 0, MAX_FILTERS * sizeof(PVOID) );

    //
    // Clean up the allocated buffers
    //

    if ( _bufRecvRaw.QuerySize( ) > MAX_CACHED_FILTER_BUFFER ) {
        _bufRecvRaw.FreeMemory();
    }

    _bufRecvTrans.Resize( 0 );

    //
    // Free pool items
    //

    while ( !IsListEmpty( &_PoolHead )) {

         pfpi = CONTAINING_RECORD( _PoolHead.Flink,
                                   FILTER_POOL_ITEM,
                                   _ListEntry );

        RemoveEntryList( &pfpi->_ListEntry );

        delete pfpi;
    }

    if ( _pFilterList )
    {
        FILTER_LIST::Dereference( _pFilterList );
        _pFilterList = NULL;
    }

    _fNotificationsDisabled = FALSE;

} // Cleanup

HTTP_FILTER::~HTTP_FILTER(
    VOID
    )
/*++

Routine Description:

    Destructor for HTTP filter class

Arguments:

Return Value:

--*/
{
    if ( _Overlapped.hEvent )
        CloseHandle( _Overlapped.hEvent );

    if ( _pFilterList )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[~HTTP_FILTER] Dereferencing _pFilterList at %lx\n",
                    _pFilterList ));

        FILTER_LIST::Dereference( _pFilterList );
        _pFilterList = NULL;
    }

#if 0   // Global filter lists are not dynamic so they're not counted
    if ( _pGlobalFilterList )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[~HTTP_FILTER] Dereferencing _pGlobalFilterList at %lx\n",
                    _pGlobalFilterList ));

        FILTER_LIST::Dereference( _pGlobalFilterList );
        _pGlobalFilterList = NULL;
    }
#endif

    delete [] _apvContexts;
}

BOOL
HTTP_FILTER::ReadData(
    LPVOID lpBuffer,
    DWORD  nBytesToRead,
    DWORD  *pcbBytesRead,
    DWORD  dwFlags
    )
/*++

Routine Description:

    This method reads data from the network and calls the
    filter dlls.  It also handles data tracking on data overflow
    or underflow.  The number of bytes read are translated
    bytes, which may be more or less then actual bytes transferred
    on the network.

    The user's buffer is used for the initial receive.  If a filter comes
    back indicating it needs more data (got the first 8k of a 32k SSL message
    for example) then we switch to using the _bufRecvRaw buffers.

Arguments:

    lpBuffer - Destination buffer
    nBytesToRead - Number of bytes to read
    *pcbBytesRead - Number of bytes read
    dwFlags - IO_FLAG values

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    DWORD    cbBytesRead = 0;
    DWORD    cbToCopy;

    if ( pcbBytesRead )
    {
        *pcbBytesRead = 0;
    }

    _pbReadBuff     = _pbClientBuff = (BYTE *) lpBuffer;
    _cbReadBuff     = _cbClientBuff = nBytesToRead;
    _cbReadBuffUsed = 0;

    //
    //  If there is old translated data that we need to give
    //  to the client, copy that now
    //

    if ( _cbRecvTrans )
    {
        cbToCopy = min( _cbRecvTrans, nBytesToRead );

        memcpy( lpBuffer,
                _bufRecvTrans.QueryPtr(),
                cbToCopy );

        if ( pcbBytesRead )
        {
            *pcbBytesRead = cbToCopy;
        }

        if ( _cbRecvTrans > cbToCopy )
        {
            _cbRecvTrans -= cbToCopy;

            //
            //  This should be very rare this happens, so flag it and if
            //  it does happen often then add an offset counter
            //

            DBGPRINTF(( DBG_CONTEXT,
                        "[HTTP_FILTER::ReadData] PERF WARNING! In place buffer copy (%d bytes)!\n",
                        _cbRecvTrans ));

            memmove( (BYTE *) _bufRecvTrans.QueryPtr(),
                     (BYTE *) _bufRecvTrans.QueryPtr() + cbToCopy,
                     _cbRecvTrans );
        }
        else
        {
            _cbRecvTrans = 0;
        }

        nBytesToRead    -= cbToCopy;
        _cbReadBuffUsed += cbToCopy;

        //
        //  If there were any bytes from the previous request, just complete
        //  the request now.  This prevents potentially blocking on a recv()
        //  with no data.
        //

        if ( dwFlags & IO_FLAG_ASYNC )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[ReadData] Posting dummy completion\n" ));

            if ( !_pRequest->PostCompletionStatus( cbToCopy ))
            {
                return FALSE;
            }
        }

        return TRUE;
    }

    if ( dwFlags & IO_FLAG_SYNC )
    {
        BOOL fRet;

        //
        //  Get the raw data, put it after any old raw data.  We temporarily
        //  bump up the thread pool count so we don't eat all of the threads.
        //

        AtqSetInfo( AtqIncMaxPoolThreads, 0 );

        fRet = TcpSockRecv(_pRequest->QueryClientConn()->QuerySocket(),
                        (char *) _pbReadBuff + _cbReadBuffUsed,
                         nBytesToRead,
                         &cbBytesRead,
                         60 // 60s timeout
                         );

        AtqSetInfo( AtqDecMaxPoolThreads, 0 );

        if ( !fRet || (cbBytesRead == 0) )
        {
            return FALSE;
        }

        if ( !ContinueRawRead( cbBytesRead,
                               NO_ERROR,
                               NULL,
                               pcbBytesRead ))
        {
            return FALSE;
        }
    }
    else
    {
        DBG_ASSERT( dwFlags & IO_FLAG_ASYNC );

        //
        //  Hook the Atq IO completion routine so reads complete through
        //  ContinueRawRead
        //

        _OldAtqCompletion = (ATQ_COMPLETION) AtqContextSetInfo( QueryAtqContext(),
                                                                ATQ_INFO_COMPLETION,
                                                                (ULONG_PTR) ::ContinueRawRead );

        _OldAtqContext    = (PVOID) AtqContextSetInfo( QueryAtqContext(),
                                                       ATQ_INFO_COMPLETION_CONTEXT,
                                                       (ULONG_PTR) this );

        if ( !_pRequest->ReadFile( _pbReadBuff + _cbReadBuffUsed,
                                   nBytesToRead,
                                   NULL,
                                   IO_FLAG_ASYNC | IO_FLAG_NO_FILTER ))
        {
            AtqContextSetInfo( QueryAtqContext(),
                               ATQ_INFO_COMPLETION,
                               (ULONG_PTR) _OldAtqCompletion );

            AtqContextSetInfo( QueryAtqContext(),
                               ATQ_INFO_COMPLETION_CONTEXT,
                               (ULONG_PTR) _OldAtqContext );

            return FALSE;
        }
    }

    return TRUE;

} // HTTP_FILTER::ReadData


VOID
ContinueRawRead(
    PVOID        Context,
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    )
{
    HTTP_FILTER * pFilter;
    pFilter = (HTTP_FILTER *) Context;

    ((HTTP_FILTER *)Context)->ContinueRawRead( BytesWritten,
                                               CompletionStatus,
                                               lpo );
}

BOOL
HTTP_FILTER::ContinueRawRead(
    DWORD        cbBytesRead,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo,
    DWORD *      pcbRead
    )
/*++

Routine Description:

    This method is the completion routine for an async (or sync) read.
    Note : It's a sync read if the overlapped structure [lpo] is null and
    a completion status [CompletionStatus] of NO_ERROR

Arguments:

    cbBytesRead - Number of bytes read
    CompletionStatus - status code of read operation
    lpo - Pointer to overlapped structure

Return Value:


    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    PVOID    pvOutData;
    DWORD    cbOutData;
    BOOL     fReadAgain;
    BOOL     fRequestFinished = FALSE;
    DWORD    cbToCopy;
    BOOL     fSyncRead = (lpo == NULL && CompletionStatus == NO_ERROR);

    //
    //  Don't update _cbReadBuffUsed until we get the data translated
    //

    if ( lpo )
    {
        _pRequest->Dereference();

        //
        //  If the socket has been closed get out.  It's the responsibility of the
        //  caller to detect this
        //

        if ( cbBytesRead == 0 )
        {
            goto CompleteRequest;
        }
    }

    if ( CompletionStatus )
    {
        goto CompleteRequest;
    }

ReadAgain:

    //
    //  Keeps track of the number of bytes the filter has *not* seen
    //

    _cbRecvRaw += cbBytesRead;

    //
    //  Call the filters to translate the raw data.  No need to check for
    //  any filters that need this notification as we wouldn't be here otherwise
    //
    //  _cbReadBuffUsed is translated bytes, _cbRecvRaw is untranslated bytes
    //

    fReadAgain = FALSE;

    if ( !NotifyRawReadDataFilters( _pbReadBuff + _cbReadBuffUsed,
                                    _cbRecvRaw,
                                    _cbReadBuff - _cbReadBuffUsed,
                                    &pvOutData,
                                    &cbOutData,
                                    &fRequestFinished,
                                    &fReadAgain ))
    {
        CompletionStatus = GetLastError();
        goto CompleteRequest;
    }

    //
    //  If the filter indicated this connection should be finished, force
    //  a tear down of our connection state
    //

    if ( fRequestFinished )
    {
        CompletionStatus = WSAECONNRESET;
        goto CompleteRequest;
    }

    if ( fReadAgain )
    {
        //
        //  If we need to read the next chunk, make sure it will fit in
        //  our read buffer.  If it won't, then switch to our own buffer
        //  and issue the read from there
        //

        if ( QueryNextReadSize() > (_cbReadBuff - _cbRecvRaw ) )
        {
            if ( !_bufRecvRaw.Resize( _cbRecvRaw + QueryNextReadSize() ))
            {
                CompletionStatus = GetLastError();
                goto CompleteRequest;
            }

            memcpy( _bufRecvRaw.QueryPtr(),
                    _pbReadBuff,
                    _cbRecvRaw );

            _pbReadBuff = (BYTE *) _bufRecvRaw.QueryPtr();
            _cbReadBuff = _bufRecvRaw.QuerySize();
        }

        if ( !_pRequest->ReadFile( _pbReadBuff + _cbRecvRaw,
                                   QueryNextReadSize(),
                                   pcbRead,
                                   (lpo ? (IO_FLAG_ASYNC | IO_FLAG_NO_FILTER) :
                                          (IO_FLAG_SYNC | IO_FLAG_NO_FILTER)) ))
        {
            CompletionStatus = GetLastError();
            goto CompleteRequest;
        }

        //
        //  Operation aborted, set error and return
        //

        if ( pcbRead && *pcbRead == 0 )
        {
            SetLastError( ERROR_OPERATION_ABORTED );
            return FALSE;
        }

        //
        //  If this is a sync request process the additional bytes now
        //

        if ( !lpo )
        {
            cbBytesRead = *pcbRead;
            goto ReadAgain;
        }

        return TRUE;
    }

    //
    //  Adjust the byte counts for the bytes just translated.
    //

    _pRequest->IncrementBytesSeenByRawReadFilter( cbOutData );
    _cbReadBuffUsed += cbOutData;
    _cbRecvRaw      = 0;

    //
    //  If we weren't able to use the original client buffer, copy as many
    //  bytes as possible to the client's buffer now.  We only hit this case
    //  if a filter indicated we need to read again.
    //

    if ( _pbReadBuff != _pbClientBuff )
    {
        cbToCopy = min( cbOutData, _cbClientBuff );

        memcpy( _pbClientBuff,
                pvOutData,
                cbToCopy );

        _cbReadBuffUsed = cbToCopy;

        //
        //  If more bytes were translated then what the client
        //  requested us to read, save those away for the next
        //  read request
        //

        if ( cbOutData > _cbClientBuff )
        {
            _cbRecvTrans = cbOutData - _cbClientBuff;

            if ( !_bufRecvTrans.Resize( _cbRecvTrans ))
            {
                CompletionStatus = GetLastError();
                goto CompleteRequest;
            }

            memcpy( _bufRecvTrans.QueryPtr(),
                    (BYTE *) pvOutData + cbToCopy,
                    _cbRecvTrans );
        }
    }

    if ( pcbRead )
    {
        *pcbRead = _cbReadBuffUsed;
    }

    //
    //  If this was an async request, reset the Atq information and complete
    //  the receive with _cbReadBuffUsed
    //

CompleteRequest:

    if (!fSyncRead)
    {
        //
        //  This is an async completion, the return is not used
        //

        AtqContextSetInfo( QueryAtqContext(),
                           ATQ_INFO_COMPLETION,
                           (ULONG_PTR) _OldAtqCompletion );

        AtqContextSetInfo( QueryAtqContext(),
                           ATQ_INFO_COMPLETION_CONTEXT,
                           (ULONG_PTR) _OldAtqContext );

        _OldAtqCompletion( _OldAtqContext,
                           _cbReadBuffUsed,
                           CompletionStatus,
                           NULL );

        return TRUE;
    }

    return (CompletionStatus == NO_ERROR);
}


BOOL
HTTP_FILTER::SendData(
    LPVOID  lpBuffer,
    DWORD   nBytesToSend,
    DWORD * pnBytesSent,
    DWORD   dwFlags
    )
/*++

Routine Description:

    This method calls the interested filters to do the appropriate data
    transformation then sends the data.

Arguments:

    lpBuffer - Destination buffer
    nBytesToRead - Number of bytes to read
    *pcbBytesRead - Number of bytes read
    dwFlags - IO_FLAG values

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    PVOID    pvOutData;
    DWORD    cbOutData;
    DWORD    cbToCopy;
    BOOL     fRequestFinished = FALSE;

    //
    //  We buffer any unsent data so indicate all the data was sent
    //

    if ( pnBytesSent )
        *pnBytesSent = nBytesToSend;

    pvOutData = lpBuffer;
    cbOutData = nBytesToSend;

    if ( IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA,
                               QueryReq()->IsSecurePort() ) &&
         !NotifyRawSendDataFilters( lpBuffer,
                                    nBytesToSend,
                                    nBytesToSend,
                                    &pvOutData,
                                    &cbOutData,
                                    &fRequestFinished ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[SendData] NotifyRawDataFilters failed with %d\n",
                    GetLastError()));

        return FALSE;
    }

    if ( fRequestFinished )
    {
        //
        //  We have to return an error so the client doesn't think
        //  they will receive an IO completion.  This may have odd
        //  manifestations
        //

        SetLastError( ERROR_OPERATION_ABORTED );
        return FALSE;
    }

    if ( !_pRequest->WriteFile( pvOutData,
                                cbOutData,
                                &nBytesToSend,
                                dwFlags | IO_FLAG_NO_FILTER ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[SendData] Send failed with %d\n",
                    GetLastError()));
        if ( pnBytesSent )
        {
            *pnBytesSent = (DWORD)SOCKET_ERROR;
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
HTTP_FILTER::SendFile(
    TS_OPEN_FILE_INFO *     pGetFile,
    HANDLE                  hFile,
    DWORD                   dwOffset,
    DWORD                   nBytesToWrite,
    DWORD                   dwFlags,
    PVOID                   pHead,
    DWORD                   HeadLength,
    PVOID                   pTail,
    DWORD                   TailLength
    )
/*++

Routine Description:

    This method simulates Winsock's TransmitFile with the addition
    of running the data through the interested filters.  This only
    supports async IO.

Arguments:

    pGetFile - Cached TS_OPEN_FILE_INFO to send
    hFile - Overlapped IO file to send (if NULL, pGetFile used to get handle)
    dwOffset - Offset from start of file
    nBytesToWrite - Bytes of file to send, note zero (meaning send the whole
        file) is not supported
    dwFlags - IO_FLAGs
    pHead - Optional pre-data to send
    HeadLength - Number of bytes of pHead
    pTail - Optional post data to send
    TailLength - Number of bytes of pTail

Return Value:

    TRUE on success, FALSE on failure (call GetLastError)

--*/
{
    HANDLE hEvent;

    DBG_ASSERT( (dwFlags & IO_FLAG_ASYNC) );

    //
    //  We assume pHead points to header data.  Send it synchronously, then
    //  we'll do chunk async sends for the file
    //

    if ( HeadLength )
    {
        DWORD cbSent;

        if ( !SendData( pHead,
                        HeadLength,
                        &cbSent,
                        (dwFlags & ~IO_FLAG_ASYNC) | IO_FLAG_SYNC ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[SendFile] SendData failed with %d\n",
                        GetLastError()));

            return FALSE;
        }
    }

    if ( !nBytesToWrite )
    {
        if ( hFile )
        {
            BY_HANDLE_FILE_INFORMATION hfi;

            if ( !GetFileInformationByHandle( hFile, &hfi ))
            {
                return FALSE;
            }

            if ( hfi.nFileSizeHigh )
            {
                SetLastError( ERROR_NOT_SUPPORTED );
                return FALSE;
            }

            nBytesToWrite = hfi.nFileSizeLow;
        }
        else if ( pGetFile )
        {
            LARGE_INTEGER           liSize;
        
            if ( !pGetFile->QuerySize( liSize ) )
            {
                return FALSE;
            }
        
            nBytesToWrite = liSize.LowPart;
        }
        // else -- We are doing a file-less transmit
    }

    //
    //  Set up variables for doing the file transmit
    //

    _hFile                 = hFile;
    _pFilterGetFile        = pGetFile;
    _cbFileBytesToWrite    = nBytesToWrite;
    _cbFileBytesSent       = 0;
    _cbFileData            = 0;
    _dwCompletionStatus    = NO_ERROR;
    _pTail                 = pTail;
    _cbTailLength          = TailLength;
    _dwFlags               = dwFlags;

    //
    //  Save the event handle if we previously created one
    //

    if ( _Overlapped.hEvent )
    {
        hEvent = _Overlapped.hEvent;
    }
    else
    {
        if ( !_Overlapped.hEvent )
        {
            hEvent = IIS_CREATE_EVENT(
                         "HTTP_FILTER::_Overlapped::hEvent",
                         this,
                         TRUE,
                         FALSE
                         );

            if ( !hEvent )
            {
                return FALSE;
            }
        }
    }

    memset( &_Overlapped, 0, sizeof( _Overlapped ));

    _Overlapped.hEvent = hEvent;
    _Overlapped.Offset = dwOffset;

    if ( !_bufFileData.Resize( 8192 ))
    {
        return FALSE;
    }

    //
    //  Hook the ATQ completion routine so the caller only sees a single
    //  completion since we have to chunk the sends for the filters
    //
    //  NOTE: If multiple requests over the same TCP session are being
    //  handled at once (not currently supported by protocol, but may
    //  eventually be) then there is a potential race condition between
    //  setting the context and setting the completion on the ATQ context
    //

    _OldAtqCompletion = (ATQ_COMPLETION) AtqContextSetInfo( QueryAtqContext(),
                                                            ATQ_INFO_COMPLETION,
                                                            (ULONG_PTR) FilterAtqCompletion );

    _OldAtqContext    = (PVOID) AtqContextSetInfo( QueryAtqContext(),
                                                   ATQ_INFO_COMPLETION_CONTEXT,
                                                   (ULONG_PTR) this );

    //
    //  Kick off the first send
    //

    OnAtqCompletion( 0, NO_ERROR, NULL );

    return TRUE;
}

VOID
FilterAtqCompletion(
    PVOID        Context,
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    )
/*++

Routine Description:

    This function substitutes for the normal request's ATQ completion.  It
    is used to simulate an Async transmit file that passes all data through
    the interested filters.

Arguments:

    Context - Pointer to filter object
    BytesWritten - Number of bytes written on last completion
    CompletionStatus - Status of last send
    lpo - Overlapped structure. NULL if error completion, non-null if IO comp.

--*/
{
    HTTP_FILTER * pFilter;
    pFilter = (HTTP_FILTER *) Context;

    ((HTTP_FILTER *)Context)->OnAtqCompletion( BytesWritten,
                                               CompletionStatus,
                                               lpo );
}

VOID
HTTP_FILTER::OnAtqCompletion(
    DWORD        BytesWritten,
    DWORD        CompletionStatus,
    OVERLAPPED * lpo
    )
/*++

Routine Description:

    This method handles ATQ completions.  It is used to simulate an Async
    transmit file that passes all data through the interested filters.

Arguments:

    BytesWritten - Number of bytes written on last completion
    CompletionStatus - Status of last send
    lpo - !NULL if this is a completion from an async IO

--*/
{
    DWORD         dwIoFlag;
    DWORD         BytesRead;
    DWORD         dwToRead;

    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "HTTP_FILTER::OnAtqCompletion: Last IO error %lu Bytes = %d IsIO = %s\n",
                    CompletionStatus,
                    BytesWritten,
                    lpo != NULL ? "TRUE" : "FALSE" ));
    }

    //
    //  Decrement the outstanding IO count
    //

    if ( lpo )
        _pRequest->Dereference();

    //
    //  If an error occurred on the completion and we haven't previous recorded
    //  an error, then record this one.  This prevents overwriting the real
    //  status code from a cancelled IO error.
    //

    if ( CompletionStatus && !_dwCompletionStatus )
    {
        _dwCompletionStatus = CompletionStatus;
    }

    //
    //  If an error occurred, restore the old ATQ information and forward
    //  the error
    //

    if ( _dwCompletionStatus ||
         _cbFileBytesSent >= _cbFileBytesToWrite )
    {
        // In the file-less case _cbFileBytesSent == 
        // _cbFileBytesToWrite == 0, so we will send the tail
        // if there is no error.

        if ( !_dwCompletionStatus && _cbTailLength )
        {
            DWORD cbSent;

            if ( !SendData( _pTail,
                            _cbTailLength,
                            &cbSent,
                            (_dwFlags & ~IO_FLAG_ASYNC) | IO_FLAG_SYNC ))
            {
                DBGPRINTF(( DBG_CONTEXT,
                           "[SendFile] SendData failed with %d\n",
                            GetLastError()));

                CompletionStatus = GetLastError();
                if ( CompletionStatus && !_dwCompletionStatus )
                    _dwCompletionStatus = CompletionStatus;
            }
        }
        goto ErrorExit;
    }

    //
    //  Read the next chunk of data from the file
    //

    dwToRead = _bufFileData.QuerySize();
    if ( dwToRead > _cbFileBytesToWrite - _cbFileBytesSent ) {
        dwToRead = _cbFileBytesToWrite - _cbFileBytesSent;
    }

    DBG_ASSERT(_dwCompletionStatus == NO_ERROR);

    if ( _pFilterGetFile && _pFilterGetFile->QueryFileBuffer() )
    {
        // Fast path.  We already have a buffer with the file contents, so 
        // read from the buffer directly.
        
        memcpy( (PCHAR) _bufFileData.QueryPtr(),
                _pFilterGetFile->QueryFileBuffer() + _Overlapped.Offset,
                dwToRead );
        
        BytesRead = dwToRead;
    }
    else
    {
        if ( !DoSynchronousReadFile(
                        _pFilterGetFile ? 
                            _pFilterGetFile->QueryFileHandle() : _hFile,
                        (PCHAR)_bufFileData.QueryPtr(),
                        dwToRead,
                        &BytesRead,
                        &_Overlapped ))
        {
            _dwCompletionStatus = GetLastError();

             DBGPRINTF(( DBG_CONTEXT,
                        "[Filter AtqCompletion] ReadFile failed with %d\n",
                         _dwCompletionStatus ));

             goto ErrorExit;
        }
    }

    //
    //  Now send the data through the filters
    //

    dwIoFlag = IO_FLAG_ASYNC;

    _cbFileBytesSent   += BytesRead;
    _Overlapped.Offset += BytesRead;

    if ( !SendData( _bufFileData.QueryPtr(),
                    BytesRead,
                    NULL,
                    dwIoFlag ))
    {
        _dwCompletionStatus = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                   "[Filter AtqCompletion] SendData failed with %d\n",
                    CompletionStatus ));

        goto ErrorExit;
    }
    return;

ErrorExit:

    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "HTTP_FILTER::OnAtqCompletion: Restoring AtqContext, "
                   "Bytes Sent = %d, Status = %d, IsIO = %s\n",
                   _cbFileBytesSent,
                   _dwCompletionStatus,
                   (lpo == NULL ? "FALSE" : "TRUE")));
    }

    AtqContextSetInfo( QueryAtqContext(),
                       ATQ_INFO_COMPLETION,
                       (ULONG_PTR) _OldAtqCompletion );

    AtqContextSetInfo( QueryAtqContext(),
                       ATQ_INFO_COMPLETION_CONTEXT,
                       (ULONG_PTR) _OldAtqContext );

    //
    //  Forward the error onto the old ATQ completion handler.  We always
    //  pass an lpo of NULL because we've already decremented the IO
    //  ref count.
    //
    //  NOTE: 'this' may be deleted in this callback!
    //

    _OldAtqCompletion( _OldAtqContext,
                       _cbFileBytesSent,
                       CompletionStatus,
                       NULL );

    return;
}

BOOL
HTTP_FILTER::DisableNotification(
    IN DWORD dwNotification
)
/*++

Routine Description:

    Called when a filter wants to disable one/more of its own notifications
    for the given request.

Arguments:

    dwNotification - Mask of notifications to disable for this request

--*/
{
    DBG_ASSERT( _pFilterList || _pGlobalFilterList );


    if ( !_fNotificationsDisabled )
    {
        //
        // All subsequent calls to IsNotificationNeeded() and NotifyFilter() must
        // use local copy of flags to determine action.
        //

        _fNotificationsDisabled = TRUE;

        //
        // Copy notification tables created in the FILTER_LIST objects
        //

        if ( !_BuffSecureArray.Resize( QueryFilterList()->QuerySecureArray()->QuerySize() ) ||
             !_BuffNonSecureArray.Resize( QueryFilterList()->QueryNonSecureArray()->QuerySize() ) )
        {
            return FALSE;
        }


        memcpy( _BuffSecureArray.QueryPtr(),
                QueryFilterList()->QuerySecureArray()->QueryPtr(),
                QueryFilterList()->QuerySecureArray()->QuerySize() );

        memcpy( _BuffNonSecureArray.QueryPtr(),
                QueryFilterList()->QueryNonSecureArray()->QueryPtr(),
                QueryFilterList()->QueryNonSecureArray()->QuerySize() );

    }

    //
    // Disable the appropriate filter in our local table
    //

    ((DWORD*)_BuffSecureArray.QueryPtr())[ QueryCurrentDll() ] &=
                                                        ~dwNotification;
    ((DWORD*)_BuffNonSecureArray.QueryPtr())[ QueryCurrentDll() ] &=
                                                        ~dwNotification;

    //
    // Calculate the aggregate notification status for our local scenario
    // NYI:  Might want to defer this operation?
    //

    _dwSecureNotifications = 0;
    _dwNonSecureNotifications = 0;

    for( DWORD i = 0; i < QueryFilterList()->QueryFilterCount(); i++ )
    {
        _dwSecureNotifications |= ((DWORD*)_BuffSecureArray.QueryPtr())[i];
        _dwNonSecureNotifications |= ((DWORD*)_BuffNonSecureArray.QueryPtr())[i];
    }


    return TRUE;
}

BOOL
HTTP_FILTER::SetFilterList(
    IN FILTER_LIST *pFilterList
    )
/*++

Routine Description:

    Sets the filter list associated with this object

Arguments :

   pFilterList - new filter list

Returns:

    Nothing

--*/

{
    DBG_ASSERT( !_pFilterList );
    FILTER_LIST *pOldList = _pFilterList;

    if ( pFilterList )
    {
        //
        // This function is called during HTTP_REQUEST::Parse, when a -global- filter
        // may already have disabled some notifications during READ_RAW processing
        // and thus set the _fNotificationsDisabled flag, so we'll leave the flag
        // as-is [it's reset at the end of each request and connection, so we're
        // not going to be using a stale value].
        //
        // The first time a notification is disabled, we make a local copy
        // of the notification flag arrays from the filter list and make the modifications
        // to our local copy. Hence, when the filter list is (re)set, the notification
        // arrays of the new filter list and the local copies have to be merged, since we
        // want to keep our old flags as well as picking up the flags for the new filters
        // that might be in the list.
        //

        //_fNotificationsDisabled = FALSE; //intentionally commented out !

        pFilterList->Reference();

        if ( _fNotificationsDisabled )
        {
            if ( !MergeNotificationArrays( pFilterList,
                                           TRUE )  ||
                 !MergeNotificationArrays( pFilterList,
                                           FALSE ) )
            {
                pFilterList->Dereference( pFilterList );
                return FALSE;
            }
        }

        _pFilterList = pFilterList;
    }

    return TRUE;
}

BOOL
HTTP_FILTER::MergeNotificationArrays(
    FILTER_LIST *pFilterList,
    BOOL fSecure
    )
/*++

Routine Description:

    This is called when the filter list for this HTTP_FILTER object needs to be replaced
    with a new list and we need to merge the arrays holding the notification flags. See
    comments in HTTP_FILTER::SetFilterList

Arguments:
    pFilterList - filter list whose notification flags need to be incorporated
    fSecure - flag indicating whether secure/nonsecure arrays are to be merged

Returns:
    Nothing

--*/

{
    DWORD dwNotifications = 0;
    DWORD *adwOldNotifArray = NULL;
    DWORD *adwMergedArray = NULL;
    DWORD *adwNewNotifArray = NULL;
    DWORD iOldFilterPos = 0;
    HTTP_FILTER_DLL *pFilterDll = NULL;
    BUFFER BuffMergedArray;

    if ( !BuffMergedArray.Resize( fSecure ?  pFilterList->QuerySecureArray()->QuerySize() :
                                             pFilterList->QueryNonSecureArray()->QuerySize() ) )
    {
        return FALSE;
    }

    if ( fSecure )
    {
        if ( !_BuffSecureArray.Resize( pFilterList->QuerySecureArray()->QuerySize() ) )
        {
            return FALSE;
        }
    }
    else
    {
        if ( !_BuffNonSecureArray.Resize( pFilterList->QueryNonSecureArray()->QuerySize() ) )
        {
            return FALSE;
        }
    }

    adwNewNotifArray = (DWORD *) (fSecure ? pFilterList->QuerySecureArray()->QueryPtr() :
                                            pFilterList->QueryNonSecureArray()->QueryPtr() );

    adwMergedArray = (DWORD *) BuffMergedArray.QueryPtr();

    //
    // This gets a little tricky : we have to walk through the present
    // notification arrays and the notification array for the new filter list
    // and merge them - all the notification flags for the filters in the old
    // list should be preserved, and the notifications for the new filters
    // need to be added to the notification array
    //

    for ( DWORD i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        //
        // If the old filter list had an entry for this filter, we want to
        // preserve those notification flags
        //
        if ( ( pFilterDll = QueryFilterList()->HasFilterDll( pFilterList->QueryDll( i ) ) ) )
        {
            adwMergedArray[i] = QueryFilterNotifications( pFilterDll,
                                                          fSecure );
        }
        //
        // New filter
        //
        else
        {
            adwMergedArray[i] = adwNewNotifArray[i];
        }
    }

    //
    // Copy merged array
    //
    memcpy( (fSecure ? _BuffSecureArray.QueryPtr() :
                       _BuffNonSecureArray.QueryPtr() ),
            BuffMergedArray.QueryPtr(),
            BuffMergedArray.QuerySize() );

    return TRUE;
}



BOOL
HTTP_FILTER::ParseSendHeaders(
    VOID
    )
/*++

Routine Description:

    Parses the list of headers the server is about to send and places them
    in the _SendHeaders parameter list for subsequent retrieval by the ISAPI
    Filter

--*/
{
    const CHAR *    pch;
    CHAR            ch;
    DWORD           cbHeaders = strlen( _pchSendHeaders );
    const CHAR *    pchEnd = _pchSendHeaders + cbHeaders;
    const CHAR *    pchHeader;
    const CHAR *    pchEndHeader;
    const CHAR *    pchValue;
    const CHAR *    pchEndValue;
    const CHAR *    pchNext;

    DBG_ASSERT( !_fSendHeadersParsed );

    //
    //  We don't want the PARAM_LIST to canon the headers because it
    //  will collapse the WWW-Authenticate: headers to a comma separated
    //  list which will mess up clients even though technically this is allowed
    //  by the HTTP spec
    //

    _SendHeaders.SetIsCanonicalized( TRUE );

    //
    //  Grab the first line and add it as a special value "status"
    //

    pch = pchNext = (const CHAR *) memchr( _pchSendHeaders, '\n', cbHeaders );

    if ( !pch )
        return TRUE;

    if ( pch > _pchSendHeaders && pch[-1] == '\r' )
    {
        pch--;
    }

    if ( !_SendHeaders.AddEntry( "status",
                                 6,
                                 _pchSendHeaders,
                                 DIFF(pch - _pchSendHeaders) ))
    {
        return FALSE;
    }

    //
    //  Now deal with the rest of the headers
    //

    pchHeader = pchNext + 1;
    cbHeaders = DIFF(pchEnd - pchHeader);

    while ( pchNext = (LPSTR)memchr( pchHeader, '\n', cbHeaders ) )
    {
        if ( pchValue = (LPSTR)memchr( pchHeader, ':', DIFF(pchNext - pchHeader) ) )
        {
            UINT ch = *(PBYTE)++pchValue;

            pchEndHeader = pchValue;
            int cName = DIFF(pchValue - pchHeader);

            if ( _HTTP_IS_LINEAR_SPACE( (CHAR)ch ) )
            {
                while ( _HTTP_IS_LINEAR_SPACE( *(PBYTE)++pchValue ) )
                    ;
            }

            if ( (pchNext > pchValue) && (pchNext[-1] == '\r') )
            {
                pchEndValue = pchNext - 1;
            }
            else
            {
                pchEndValue = pchNext;
            }

            if ( !_SendHeaders.AddEntry( pchHeader,
                                         DIFF(pchEndHeader - pchHeader),
                                         pchValue,
                                         DIFF(pchEndValue - pchValue) ))
            {
                return FALSE;
            }
        }
        else
        {
            if ( (*pchHeader == '\r') || (*pchHeader == '\n') )
            {
                pchHeader = pchNext + 1;

                //
                //  If a body was specified, add it as a special value
                //

                if ( pchEnd - pchHeader > 1 )
                {
                    if ( !_SendHeaders.AddEntry( "body",
                                                 sizeof("body") - 1,
                                                 pchHeader,
                                                 DIFF(pchEnd - pchHeader) ))
                    {
                        return FALSE;
                    }
                }

                break;
            }
        }

        pchHeader = pchNext + 1;
        cbHeaders = DIFF(pchEnd - pchHeader);
    }

    _fSendHeadersParsed = TRUE;

    return TRUE;
}

BOOL
HTTP_FILTER::BuildNewSendHeaders(
    BUFFER * pHeaderBuff
    )
/*++

Routine Description:

    Takes the set of send headers and builds up an HTTP response, only used
    when a header has been changed

Arguments:

    pHeaderBuff - Receives HTTP response headers

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PVOID   Cookie = NULL;
    CHAR *  pch;
    CHAR *  pszTail;
    CHAR *  pszField;
    DWORD   cbField;
    CHAR *  pszValue;
    DWORD   cbValue;

    pszTail = (CHAR *) pHeaderBuff->QueryPtr();
    *pszTail = '\0';

    pch = _SendHeaders.FindValue( "status", NULL, &cbValue );

    if ( !pch )
    {
        //
        //  Somebody deleted the status or this is a point nine request
        //  Supply a default and assume the filter really wanted to send a
        //  header response
        //

        if (!g_ReplyWith11)
        {
            pch = "HTTP/1.0 200 Ok";
        }
        else
        {
            pch = "HTTP/1.1 200 Ok";
        }

        cbValue = sizeof( "HTTP/1.0 200 Ok" ) - sizeof(CHAR);
    }

    if ( !pHeaderBuff->Resize( cbValue + 1, 512 ))
    {
        return FALSE;
    }
    pszTail = (CHAR *) pHeaderBuff->QueryPtr();

    CopyMemory( pszTail, pch, cbValue + 1 );
    pszTail += cbValue;

    *pszTail = '\r';
    pszTail++;
    *pszTail = '\n';
    pszTail++;

    while ( Cookie = _SendHeaders.NextPair( Cookie,
                                            &pszField,
                                            &cbField,
                                            &pszValue,
                                            &cbValue ))
    {
        //
        //  Ignore "status" and "body"
        //

        if ( !memcmp( pszField, "status", sizeof("status") ) ||
             !memcmp( pszField, "body", sizeof("body") ))
        {
            continue;
        }

        //
        //  Make sure there's room for the space, plus two '\r\n'
        //

        pch = (CHAR *) pHeaderBuff->QueryPtr();

        if ( !pHeaderBuff->Resize( DIFF(pszTail - pch) + cbValue + cbField + 6, 128 ))
        {
            return FALSE;
        }

        //
        //  Watch for pointer shift
        //

        if ( pch != pHeaderBuff->QueryPtr() )
        {
            pszTail = (CHAR *) pHeaderBuff->QueryPtr() + (pszTail - pch);
        }

        CopyMemory( pszTail, pszField, cbField + 1 );

        pszTail += cbField;

        *pszTail = ' ';
        pszTail++;

        CopyMemory( pszTail, pszValue, cbValue + 1 );
        pszTail += cbValue;

        *pszTail = '\r';
        pszTail++;
        *pszTail = '\n';
        pszTail++;
    }

    *pszTail = '\r';
    pszTail++;
    *pszTail = '\n';
    pszTail++;

    //
    //  Add the body if one was specified
    //

    pszValue = _SendHeaders.FindValue( "body", NULL, &cbValue );

    if ( pszValue )
    {
        pch = (CHAR *) pHeaderBuff->QueryPtr();

        if ( !pHeaderBuff->Resize( DIFF(pszTail - pch) + cbValue + 1 ))
        {
            return FALSE;
        }

        if ( pch != pHeaderBuff->QueryPtr() )
        {
            pszTail = (CHAR *) pHeaderBuff->QueryPtr() + (pszTail - pch);
        }

        CopyMemory( pszTail, pszValue, cbValue + 1 );
    }
    else
    {
        *pszTail = '\0';
    }

    return TRUE;
}

DWORD
HTTP_FILTER::QueryFilterNotifications( HTTP_FILTER_DLL *pFilterDll,
                                       BOOL fSecure )
/*++

Routine Description:

    Retrieves the notification flags for a given filter dll

Arguments:

    pFilterDll - filter dll whose notifications are to be retrieved
    fSecure - flag indicating whether secure/insecure port notifications are to be retrieved

Return Value:

    Notification flags for filter; zero if filter isn't found

--*/
{
    FILTER_LIST *pFilterList = QueryFilterList();
    DWORD cFilterCount = pFilterList->QueryFilterCount();

    for ( DWORD i = 0; i < cFilterCount ; i++ )
    {
        if ( pFilterList->QueryDll( i ) == pFilterDll )
        {
            if ( _fNotificationsDisabled )
            {
                return (((DWORD *) (fSecure ? _BuffSecureArray.QueryPtr() :
                                              _BuffNonSecureArray.QueryPtr()))[i]);
            }
            else
            {
                return (fSecure ? pFilterDll->QuerySecureFlags() :
                                  pFilterDll->QueryNonsecureFlags() );
            }
        }
    }

    return 0;
}


/*****************************************************************/

BOOL
WINAPI
ServerFilterCallback(
    HTTP_FILTER_CONTEXT *         pfc,
    enum SF_REQ_TYPE              sf,
    void *                        pData,
    ULONG_PTR                     ul1,
    ULONG_PTR                     ul2
    )
/*++

Routine Description:

    This method handles a gateway request to a server extension DLL

Arguments:

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_REQ_BASE *     pRequest;
    HTTP_FILTER *       pFilter;
    STACK_STR(          str, MAX_PATH);;
    STACK_STR(          strResp, MAX_PATH);;
    STACK_STR(          strURL, MAX_PATH);
    UINT                cb;
    int                 n;
    DWORD               CurrentDll;
    HTTP_FILTER_DLL *   pFilterDll;
    DWORD               dwAuth;
    BOOL                fFinished;
    DWORD               Status;
    DWORD               Win32Status;
    W3_SERVER_INSTANCE* pInst;
    DWORD               dwIOFlags;

    //
    //  Check for valid parameters
    //

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[ServerExtensionCallback: Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    pRequest = pFilter->QueryReq();

    //
    //  Handle the server extension's request
    //

    switch ( sf )
    {
    case SF_REQ_SEND_RESPONSE_HEADER:

        //
        //  Save the client context context because the client may call
        //  Send headers just after changing the context and we're about to
        //  write over it when we do the raw send notifications
        //

        CurrentDll = pFilter->QueryCurrentDll();
        DBG_ASSERT( CurrentDll != INVALID_DLL );

        pFilter->SetClientContext( CurrentDll, pfc->pFilterContext );

        //
        //  If we're doing a send header from a Raw data notification then we need
        //  to notify only the filters down the food chain so save the current
        //  filter and set the start point in the list to the next filter (remember
        //  raw sends walk the list backwards so encryption filters are last)
        //

        dwIOFlags = IO_FLAG_SYNC;

        if ( pFilter->IsInRawNotification() )
        {
            //
            // If this is the first filter in the list, then there's nobody that
            //  needs to be notified
            //

            if ( pFilter->IsFirstFilter( CurrentDll ) )
            {
                dwIOFlags |= IO_FLAG_NO_FILTER;
            }
            else
            {
                pFilter->SetCurrentDll( CurrentDll - 1 );
            }
        }

        if ( pData )
        {
            Status = atoi( (PCSTR)pData );

            if ( Status == HT_DENIED )
            {
                //
                //  Only set the reason as denied_filter if we're not doing
                //  denied access filter processing.
                //

                if ( !pFilter->ProcessingAccessDenied() )
                {
                    pRequest->SetDeniedFlags( SF_DENIED_FILTER );
                }

                Win32Status = ERROR_ACCESS_DENIED;
                pRequest->SetAuthenticationRequested( TRUE );

                //
                // If we do not have Metadata yet but we have an instance
                // then read metadata so that WWW authentication headers can
                // be properly generated
                //

                if ( pRequest->QueryW3Instance() &&
                     !pRequest->QueryMetaData() &&
                     pRequest->QueryHeaderList()->FastMapQueryValue( HM_URL ) )
                {
                    ((HTTP_REQUEST*)pRequest)->OnURL( (LPSTR)pRequest->QueryHeaderList()
                            ->FastMapQueryValue( HM_URL ) );
                }
            }
            else
            {
                Win32Status = NO_ERROR;
            }
        }
        else
        {
            Status = HT_OK;
            Win32Status = NO_ERROR;
        }

        pRequest->SetState( pRequest->QueryState(),
                            Status,
                            Win32Status );


        if ( !pRequest->SendHeader( (CHAR *) pData,
                                    (((CHAR *) ul1) ? ((CHAR *) ul1) : "\r\n"),
                                    dwIOFlags,
                                    &fFinished ))
        {
            pFilter->SetCurrentDll( CurrentDll );
            return FALSE;
        }

        //
        //  CODEWORK - need general method of handling an early finish
        //  indication (have flag and drop subsequent sends in bit bucket?
        //  return an error to filter?)
        //

        DBG_ASSERT( !fFinished );

        pFilter->SetCurrentDll( CurrentDll );
        break;

    case SF_REQ_ADD_HEADERS_ON_DENIAL:
        {
            BOOL fOK = TRUE;
            DWORD cb = 0;
            CHAR *pchHeaders = NULL;

            if ( !pData )
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }

            fOK = pRequest->QueryDenialHeaders()->Append( (CHAR *) pData );

            if ( fOK )
            {
                //
                // Need to make sure that the header ends with a CR-LF
                //
                cb = pRequest->QueryDenialHeaders()->QueryCCH();
                pchHeaders = pRequest->QueryDenialHeaders()->QueryStr();

                if ( cb < 2 ||
                     ( !(pchHeaders[cb - 2] == '\r' && pchHeaders[cb - 1] == '\n' ) ) )
                {
                    fOK = pRequest->QueryDenialHeaders()->Append( (CHAR *) "\r\n" );
                }
            }

            return fOK;
        }

    case SF_REQ_SET_NEXT_READ_SIZE:

        if ( (ul1 == 0) || (ul1 > 0x8000000) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        pFilter->SetNextReadSize( (DWORD) ul1 );
        return TRUE;

    case SF_REQ_SET_PROXY_INFO:

        //
        //  ul1 contains the proxy flags to set for this request (which right
        //  now is only On or Off).
        //

        pRequest->SetProxyRequest( (DWORD) ul1 & 0x00000001 );
        break;

    case SF_REQ_SET_CERTIFICATE_INFO:

        pFilterDll = pFilter->QueryFilterList()->QueryDll(
                         pFilter->QueryCurrentDll() );

        return pRequest->SetCertificateInfo(
                (PHTTP_FILTER_CERTIFICATE_INFO)pData,
                (CtxtHandle*)ul1,
                (HANDLE)ul2,
                pFilterDll );

    case SF_REQ_GET_PROPERTY:

        pInst = pRequest->QueryW3InstanceAggressively();

        dwAuth = pRequest->QueryMetaData() ? pRequest->QueryAuthentication() : 0;

        switch ( ul1 )
        {
            case SF_PROPERTY_GET_INSTANCE_ID:
                *(LPVOID*)pData = (LPVOID)pInst;
                break;

#if 0 // Unused
            case SF_PROPERTY_CLIENT_CERT_ENABLED:
                *(LPBOOL)pData = !!(dwAuth & INET_INFO_AUTH_CERT_AUTH);
                break;
#endif
            case SF_PROPERTY_MD5_ENABLED:
                *(LPBOOL)pData = !!(dwAuth & INET_INFO_AUTH_MD5_AUTH);
                break;
#if 0 // Unused
            case SF_PROPERTY_DIR_MAP_CERT:
                *(LPBOOL)pData = !!(dwAuth & INET_INFO_CERT_MAP);
                break;
#endif
            
            case SF_PROPERTY_DIGEST_SSP_ENABLED:
                if ( pRequest->QueryMetaData() )
                {
                    *(LPBOOL)pData = pRequest->QueryMetaData()->QueryUseDigestSSP();
                }
                else
                {
                    *(LPBOOL)pData = FALSE;
                }
                break;
            
            case SF_PROPERTY_GET_CERT11_MAPPER:
                if ( pInst )
                {
                    *(LPVOID*)pData = pInst->QueryMapper( MT_CERT11 );
                }
                else
                {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    return FALSE;
                }
                break;

            case SF_PROPERTY_GET_RULE_MAPPER:
                if ( pInst )
                {
                    *(LPVOID*)pData = pInst->QueryMapper( MT_CERTW );
                }
                else
                {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    return FALSE;
                }
                break;

            case SF_PROPERTY_GET_MD5_MAPPER:
                if ( pInst )
                {
                    *(LPVOID*)pData = pInst->QueryMapper( MT_MD5 );
                }
                else
                {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    return FALSE;
                }
                break;

            case SF_PROPERTY_GET_ITA_MAPPER:
                if ( pInst )
                {
                    *(LPVOID*)pData = pInst->QueryMapper( MT_ITA );
                }
                else
                {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    return FALSE;
                }
                break;

            case SF_PROPERTY_MD_IF:
                *(LPVOID*)pData = (LPVOID) g_pInetSvc->QueryMDObject();
                break;

            case SF_PROPERTY_SSL_CTXT:
                *(LPVOID*)pData = pRequest->QueryAuthenticationObj()->QuerySslCtxtHandle();
                break;

            case SF_PROPERTY_INSTANCE_NUM_ID:
                *(DWORD*)pData = pInst ? pInst->QueryInstanceId() : 0;
                break;

            case SF_PROPERTY_MD_PATH:

                    *(const CHAR**)pData = pInst ? pInst->QueryMDPath() :
                        g_pInetSvc->QueryMDPath();

                break;

            default:
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
        }
        return TRUE;

    case SF_REQ_NORMALIZE_URL:
        return ((HTTP_REQUEST * )pRequest)->NormalizeUrl( (LPSTR)pData );

    case SF_REQ_DONE_RENEGOTIATE:
        ((HTTP_REQUEST * )pRequest)->DoneRenegotiate( *(LPBOOL)pData );
        break;

    case SF_REQ_SET_NOTIFY:
        switch ( ul1 )
        {
            case SF_NOTIFY_MAPPER_MD5_CHANGED:
            case SF_NOTIFY_MAPPER_ITA_CHANGED:
            case SF_NOTIFY_MAPPER_CERT11_CHANGED:
            case SF_NOTIFY_MAPPER_CERTW_CHANGED:
                return SetFlushMapperNotify( (SF_NOTIFY_TYPE)ul1, (PFN_SF_NOTIFY)pData );

            case SF_NOTIFY_MAPPER_SSLKEYS_CHANGED:
                return SetSllKeysNotify( (PFN_SF_NOTIFY)pData );
        }
        return FALSE;

    case SF_REQ_DISABLE_NOTIFICATIONS:
        return pFilter->DisableNotification( (DWORD) ul1 );

    case SF_REQ_COMPRESSION_FILTER_CHECK:
        return CompressionFilterCheck(pfc,pData,ul1,ul2);

    case HSE_REQ_GET_CERT_INFO_EX: {

        //
        //  Descrption:
        //    Returns the first cert in the request's cert-chain,
        //    only used if using an SSPI package
        //
        //  Input:
        //    pData -   ISA-provided struct
        //              NOTE ISA must allocate buffer within struct
        //
        //  Notes:
        //    Works in-proc or out-of-proc
        //

        //
        // cast ISA-provided ptr to our cert struct
        //

        CERT_CONTEXT_EX *  pCertContextEx = reinterpret_cast
                                                <CERT_CONTEXT_EX *>
                                                ( pData );

        if ( pData == NULL ) {

            DBG_ASSERT( FALSE );

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        //
        // pass struct members as individual parameters
        //

        return pRequest->QueryAuthenticationObj()->GetClientCertBlob(
                        pCertContextEx->cbAllocated,
                        &( pCertContextEx->CertContext.dwCertEncodingType ),
                        pCertContextEx->CertContext.pbCertEncoded,
                        &( pCertContextEx->CertContext.cbCertEncoded ),
                        &( pCertContextEx->dwCertificateFlags ) );
    } // case HSE_REQ_GET_CERT_INFO_EX:

    default:
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
GetServerVariable(
    HTTP_FILTER_CONTEXT * pfc,
    LPSTR                 lpszVariableName,
    LPVOID                lpvBuffer,
    LPDWORD               lpdwSize
    )
/*++

Routine Description:

    Callback for a filter retrieving a server variable.  These are mostly
    CGI type varaibles

Arguments:

    pfc - Pointer to http filter context
    lpszVariableName - Variable to retrieve
    lpvBuffer - Receives value or '\0' if not found
    lpdwSize - Specifies the size of lpvBuffer, gets set to the number of
        bytes transferred including the '\0'

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fReturn = TRUE;  // fast path value

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[GetServerVariable] Filter sent invalid parameters\n"));
        SetLastError( ERROR_INVALID_PARAMETER );
        fReturn = FALSE;
    } else {
        HTTP_FILTER * pFilter =  (HTTP_FILTER *) pfc->ServerContext;
        HTTP_REQ_BASE * pRequest = pFilter->QueryReq();
        CHAR           tmpStr[MAX_PATH];
        STR            str(tmpStr, MAX_PATH);
        BOOL           fFound;

        //
        //  Get the requested variable and copy it into the supplied buffer
        //

                
        if ( fReturn = pRequest->GetInfo( lpszVariableName,
                                          &str,
                                          &fFound ) ) {
        
            DWORD   cb;
        
            if ( !fFound ) {
                SetLastError( ERROR_INVALID_INDEX );
                fReturn = FALSE;
            } else if ( (cb = str.QueryCB() + sizeof(CHAR)) > * lpdwSize) {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                *lpdwSize = cb;
                fReturn = FALSE;
            } else {
                *lpdwSize = cb;
                CopyMemory( lpvBuffer, str.QueryStr(), cb );
                DBG_ASSERT( fReturn);
            }
        }
    }

    return (fReturn);

} // GetServerVariable()

BOOL
WINAPI
AddFilterResponseHeaders(
    HTTP_FILTER_CONTEXT * pfc,
    LPSTR                 lpszHeaders,
    DWORD                 dwReserved
    )
/*++

Routine Description:

    Adds headers specified by the client to send with the response

Arguments:

    pfc - Pointer to http filter context
    lpszHeaders - List of '\r\n' terminated headers followed by '\0'
    dwReserved - must be zero

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER * pFilter;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[GetServerVariable] Filter passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;

    return pFilter->QueryReq()->QueryAdditionalRespHeaders()->
                Append( (CHAR*) lpszHeaders );
}

BOOL
WINAPI
WriteFilterClient(
    HTTP_FILTER_CONTEXT * pfc,
    LPVOID                Buffer,
    LPDWORD               lpdwBytes,
    DWORD                 dwReserved
    )
/*++

Routine Description:

    Callback for writing data to the client

Arguments:

    pfc - Pointer to http filter context
    Buffer - Pointer to data to send
    lpdwBytes - Number of bytes to send, receives number of bytes sent
    dwReserved - Not used

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER *     pFilter;
    STR               str;
    DWORD             cb;
    HTTP_FILTER_DLL * pFilterDll;
    DWORD             CurrentDll;
    DWORD             dwIOFlags = IO_FLAG_SYNC;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[GetServerVariable] Filter passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;

    //
    //  Ignore zero length sends
    //

    if ( !*lpdwBytes )
    {
        return TRUE;
    }

    //
    //  Save the client context because the client may call
    //  WriteClient just after changing the context and we're about to
    //  write over it when we do the raw send notifications
    //

    CurrentDll = pFilter->QueryCurrentDll();
    pFilter->SetClientContext( CurrentDll, pfc->pFilterContext );

    //
    //  If we're doing a WriteClient from a Raw data notification then we need
    //  to notify only the filters down the food chain so save the current
    //  filter and set the start point in the list to the next filter (remember
    //  raw sends walk the list backwards to encryption filters are last)
    //

    if ( pFilter->IsInRawNotification() )
    {
        //
        //  If this is the first filter in the list, then there's nobody that
        //  needs to be notified
        //

        if ( pFilter->IsFirstFilter( CurrentDll ) )
        {
            dwIOFlags |= IO_FLAG_NO_FILTER;
        }
        else
        {
            pFilter->SetCurrentDll( CurrentDll - 1 );
        }
    }

    if ( !pFilter->QueryReq()->WriteFile( Buffer,
                                          *lpdwBytes,
                                          lpdwBytes,
                                          dwIOFlags ))
    {
        pFilter->SetCurrentDll( CurrentDll );
        return FALSE;
    }

    pFilter->SetCurrentDll( CurrentDll );

    return TRUE;
}

BOOL
WINAPI
GetFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
    )
/*++

Routine Description:

    Callback for retrieving unprocessed headers

Arguments:

    pfc - Pointer to http filter context
    lpszName - Name of header to retrieve ("User-Agent:")
    lpvBuffer - Buffer to receive the value of the header
    lpdwSize - Number of bytes in lpvBuffer, receives number of bytes copied
        including the '\0'

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER *  pFilter;
    HTTP_HEADERS * pHeaderList;
    CHAR *         pszValue;
    DWORD          cbNeeded;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[GetFilterHeader] Extension passed invalid parameters\r\n"
                    ));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    pHeaderList = pFilter->QueryReq()->QueryHeaderList();

    //
    //  First, see if the specified header is in the list
    //

    pszValue = pHeaderList->FindValue( lpszName, &cbNeeded );

    //
    //  If not found, terminate the buffer and set the required size to the
    //  terminator
    //

    if ( !pszValue )
    {
        SetLastError( ERROR_INVALID_INDEX );
        return FALSE;
    }

    //
    //  Found the value, copy it if there's space
    //

    if ( ++cbNeeded > *lpdwSize )
    {
        *lpdwSize = cbNeeded;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    *lpdwSize = cbNeeded;
    memcpy( lpvBuffer, pszValue, cbNeeded );

    return TRUE;
}

BOOL
WINAPI
SetFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
    )
/*++

Routine Description:

    The specified header is added to the list with the specified value.  If
    any other occurrences of the header are found, they are removed from the
    list.

    Specifying a blank value will remove the header from the list

    This will generally be used to replace the value of an existing header

Arguments:

    pfc - Pointer to http filter context
    lpszName - Name of header to set ("User-Agent:")
    lpszValue - value of lpszValue

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER * pFilter;
    HTTP_HEADERS *pHeaderList;
    VOID *        pvCookie = NULL;
    CHAR *        pszListHeader;
    CHAR *        pszListValue;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[SetFilterHeader] Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    pHeaderList = pFilter->QueryReq()->QueryHeaderList();

    //
    //  Remove all occurrences of the value, then add the one we want
    //

    pHeaderList->CancelHeader( lpszName );

    //
    //  Only add the value if they specified a replacement
    //

    if ( lpszValue && *lpszValue )
    {
        return pHeaderList->StoreHeader( lpszName, lpszValue );
    }

    return TRUE;
}

BOOL
WINAPI
AddFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
    )
/*++

Routine Description:

    The specified header is added to the list with the specified value.

Arguments:

    pfc - Pointer to http filter context
    lpszName - Name of header to set ("User-Agent:")
    lpszValue - value of lpszValue

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER * pFilter;
    HTTP_HEADERS *pHeaderList;
    VOID *        pvCookie = NULL;
    CHAR *        pszListHeader;
    CHAR *        pszListValue;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[AddFilterHeader] Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    pHeaderList = pFilter->QueryReq()->QueryHeaderList();

    return pHeaderList->StoreHeader( lpszName, lpszValue);
} // AddFilterHeader()

BOOL
WINAPI
GetSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
    )
/*++

Routine Description:

    Callback for retrieving headers about to be sent to the client

Arguments:

    pfc - Pointer to http filter context
    lpszName - Name of header to retrieve ("User-Agent:")
    lpvBuffer - Buffer to receive the value of the header
    lpdwSize - Number of bytes in lpvBuffer, receives number of bytes copied
        including the '\0'

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER * pFilter;
    CHAR *        pszValue;
    DWORD         cbNeeded = 0;
    PARAM_LIST *  pHeaderList;
    PVOID         Cookie = NULL;
    CHAR *        pszField;
    DWORD         cbField;
    DWORD         cbValue;
    BOOL          fFound = FALSE;
    CHAR *        pszTail = (CHAR *) lpvBuffer;
    HTTP_REQ_BASE*  pRequest;


    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[GetFilterHeader] Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    DBG_ASSERT( pFilter != NULL );

    pRequest = (HTTP_REQ_BASE*) pFilter->QueryReq();
    DBG_ASSERT( pRequest != NULL );

    if ( pRequest->IsPointNine() )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    if ( !pFilter->AreSendHeadersParsed() &&
         !pFilter->ParseSendHeaders() )
    {
        return FALSE;
    }

    pHeaderList = pFilter->QuerySendHeaders();

    //
    //  First, see if the specified header is in the list
    //

    while ( Cookie = pHeaderList->NextPair( Cookie,
                                            &pszField,
                                            &cbField,
                                            &pszValue,
                                            &cbValue ))
    {
        if ( !_stricmp( pszField, lpszName ))
        {
            //
            //  If there is room, copy it in, note we need a comma separator
            //  after each subsequent entry
            //

            if ( (cbNeeded + cbValue + 1 + (fFound ? 1 : 0)) <= *lpdwSize )
            {
                if ( fFound )
                {
                    *pszTail++ = ',';
                }

                memcpy( pszTail, pszValue, cbValue + 1 );
                pszTail += cbValue;
            }

            cbNeeded += cbValue + (fFound ? 1 : 0);
            fFound = TRUE;
        }
    }

    //
    //  If not found, tell the caller
    //

    if ( !fFound )
    {
        SetLastError( ERROR_INVALID_INDEX );
        return FALSE;
    }

    //
    //  Found the value, copy it if there's space
    //

    if ( ++cbNeeded > *lpdwSize )
    {
        *lpdwSize = cbNeeded;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    *lpdwSize = cbNeeded;
    return TRUE;
}

BOOL
WINAPI
SetSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
    )
/*++

Routine Description:

    The specified header is added to the list with the specified value.  If
    any other occurrences of the header are found, they are removed from the
    list.

    Specifying a blank value will remove the header from the list

    This will generally be used to replace the value of an existing header

Arguments:

    pfc - Pointer to http filter context
    lpszName - Name of header to set ("User-Agent:")
    lpszValue - value of lpszValue

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER * pFilter;
    PARAM_LIST *  pHeaderList;
    HTTP_REQ_BASE * pRequest;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[SetFilterHeader] Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    DBG_ASSERT( pFilter != NULL );

    pRequest = (HTTP_REQ_BASE*) pFilter->QueryReq();
    DBG_ASSERT( pRequest != NULL );

    if ( pRequest->IsPointNine() )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    if ( !pFilter->AreSendHeadersParsed() &&
         !pFilter->ParseSendHeaders() )
    {
        return FALSE;
    }

    pHeaderList = pFilter->QuerySendHeaders();

    //
    //  Remove all occurrences of the value, then add the one we want
    //

    pFilter->SetSendHeadersChanged( TRUE );

    pHeaderList->RemoveEntry( lpszName );

    //
    //  Only add the value if they specified a replacement
    //

    if ( lpszValue && *lpszValue )
    {
        return pHeaderList->AddEntry( lpszName, lpszValue );
    }

    return TRUE;
}

BOOL
WINAPI
AddSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
    )
/*++

Routine Description:

    The specified header is added to the list with the specified value.

Arguments:

    pfc - Pointer to http filter context
    lpszName - Name of header to set ("User-Agent:")
    lpszValue - value of lpszValue

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER * pFilter;
    HTTP_REQ_BASE*  pRequest;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[AddFilterHeader] Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    DBG_ASSERT( pFilter != NULL );

    pRequest = (HTTP_REQ_BASE*) pFilter->QueryReq();
    DBG_ASSERT( pRequest != NULL );

    if ( pRequest->IsPointNine() )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    if ( !pFilter->AreSendHeadersParsed() &&
         !pFilter->ParseSendHeaders() )
    {
        return FALSE;
    }

    pFilter->SetSendHeadersChanged( TRUE );

    return pFilter->QuerySendHeaders()->AddEntry( lpszName, lpszValue );
}

VOID *
WINAPI
AllocFilterMem(
    struct _HTTP_FILTER_CONTEXT * pfc,
    DWORD                         cbSize,
    DWORD                         dwReserved
    )
{
    HTTP_FILTER * pFilter;
    FILTER_POOL_ITEM * pfpi;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[GetFilterHeader] Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return NULL;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;

    pfpi = FILTER_POOL_ITEM::CreateMemPoolItem( cbSize );

    if ( pfpi )
    {
        InsertHeadList( pFilter->QueryPoolHead(), &pfpi->_ListEntry );
        return pfpi->_pvData;
    }

    return NULL;
}

#if 0
PVOID
WINAPI
ServerFilterResize(
    struct _HTTP_FILTER_CONTEXT * pfc,
    DWORD                         cbSize
    )
{
    HTTP_FILTER * pFilter;
    HTTP_FILTER_RAW_DATA * phfrd;

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[ServerFilterResize] Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return NULL;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    phfrd   = (HTTP_FILTER_RAW_DATA *) pFilter->QueryNotificationStruct();

    //
    //  Only reallocate if necessary
    //

    if ( phfrd->cbOutBuffer < cbSize )
    {
        if ( !pFilter->QueryRecvTrans()->Resize( cbSize ) )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return NULL;
        }

        phfrd->pvOutData = pFilter->QueryRecvTrans()->QueryPtr();

        phfrd->cbOutBuffer = cbSize;
    }

    return phfrd->pvOutData;
}

#endif

PATQ_CONTEXT
HTTP_FILTER::QueryAtqContext(
    VOID
    ) const
{
    return _pRequest->QueryClientConn()->QueryAtqContext();
}

BOOL
WINAPI
GetUserToken(
    struct _HTTP_FILTER_CONTEXT * pfc,
    HANDLE *                      phToken
)
/*++

Routine Description:

    Get impersonated user token

Arguments:

    pfc - Filter context
    phToken - Filled with impersonation token
    
Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HTTP_FILTER * pFilter;
    HTTP_REQ_BASE*  pRequest;

    if ( !pfc ||
         !pfc->ServerContext ||
         !phToken )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[AddFilterHeader] Extension passed invalid parameters\r\n"));
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE;
    }

    pFilter = (HTTP_FILTER *) pfc->ServerContext;
    DBG_ASSERT( pFilter != NULL );
    
    pRequest = (HTTP_REQ_BASE*) pFilter->QueryReq();
    DBG_ASSERT( pRequest != NULL );
    
    *phToken = pRequest->QueryUserImpersonationHandle();
    
    return TRUE;
}



BOOL
WINAPI
CompressionFilterCheck(
    HTTP_FILTER_CONTEXT *pfc,
    LPVOID              lpszEncodingString,
    ULONG_PTR           lpszVerbString,
    ULONG_PTR           sizesForBuffers
    )
/*++

Routine Description:

    Special server suport function for compression filter to determine the need to 
    compress given request

Arguments:

    pfc - Pointer to http filter context
    lpszEncodingString - String containing accept encoding header if any
    lpszVerbString - String containing method 
    sizesForBuffers - max size for buffers
Return Value:

    TRUE if request is eligible for compression

--*/
{
    BOOL fReturn = FALSE;  // fast path value

    if ( !pfc ||
         !pfc->ServerContext )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[CompressionFilterCheck] Filter sent invalid parameters\n"));
        SetLastError( ERROR_INVALID_PARAMETER );
    } else {
        HTTP_FILTER * pFilter =  (HTTP_FILTER *) pfc->ServerContext;
        HTTP_REQ_BASE * pRequest = pFilter->QueryReq();
        HTTP_HEADERS    *pHttpHeaders;
        DWORD           len;
        PCHAR           pHdr_HM_ACE, pHdr_HM_MET;
        
        pHttpHeaders = pRequest->QueryHeaderList();


        *(PCHAR)lpszEncodingString = 0;
        *((PCHAR)lpszVerbString) = 0;


        //
        // Get the Accept-Encoding sent by the client, if any.  If we cannot
        // get this header, or if the size of the header is too large, then
        // we will make no effort to compress this request.
        //



        pHdr_HM_ACE = (PCHAR)pHttpHeaders->FastMapQueryValue (HM_ACE);
        
        if ( pHdr_HM_ACE )
        {
            pHdr_HM_MET = (PCHAR)pHttpHeaders->FastMapQueryValue(HM_MET);

            if (pHdr_HM_MET)
            {
                len = strlen((PCHAR)pHdr_HM_ACE)+1;
                if (len > sizesForBuffers)
                {
                    SetLastError (ERROR_INSUFFICIENT_BUFFER);
                    goto exit_point;
                }
                else
                {
                    strcpy ((PCHAR)lpszEncodingString,pHdr_HM_ACE);
                }


                len = strlen((PCHAR)pHdr_HM_MET)+1;
                if (len > sizesForBuffers)
                {
                    SetLastError (ERROR_INSUFFICIENT_BUFFER);
                    goto exit_point;
                }
                else
                {
                    strcpy ((PCHAR)lpszVerbString,pHdr_HM_MET);
                    fReturn = TRUE;
                }

            }
        }
 
    }

exit_point:
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\httpreq.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    httpreq.cxx

    This module contains the http request class implementation


    FILE HISTORY:
        Johnl       24-Aug-1994     Created
        MuraliK     16-May-1995     Modified LogInformation structure
                                     after adding additional fields.
        MuraliK     22-Jan-1996     Cache & use UNC impersonation.
*/


#include "w3p.hxx"
#include <inetinfo.h>

#include <ole2.h>
#include <issperr.h>

#include <imd.h>
#include <mb.hxx>
#include <mbstring.h>
#include "wamexec.hxx"

extern "C"
{
    #include "md5.h"
}


#pragma warning( disable:4355 )   // 'this' used in base member initialization

extern LPSYSTEMTIME
MinSystemTime(
    LPSYSTEMTIME Now,
    LPSYSTEMTIME Other
    );


//
// Hash defines

//
//
// Size of read during cert renegotiation phase
//

#define CERT_RENEGO_READ_SIZE   (1024*4)

//
// CGI Header Prefix
//
#define CGI_HEADER_PREFIX_SZ    "HTTP_"
#define CGI_HEADER_PREFIX_CCH   (sizeof(CGI_HEADER_PREFIX_SZ) - 1)

//
//  Private globals.
//

CHAR    Slash[] = "/";

BOOL                    HTTP_REQUEST::_fGlobalInit = FALSE;

HTTP_REQUEST::PFN_GET_INFO    HTTP_REQUEST::sm_GetInfoFuncs[26];


//
//  This table contains the verbs we recognize
//

struct _HTTP_VERBS
{
    TCHAR *                     pchVerb;      // Verb name
    UINT                        cchVerb;      // Count of characters in verb
    HTTP_VERB                   httpVerb;
    HTTP_REQUEST::PMFN_DOVERB   pmfnVerb;     // Pointer to member function
}
DoVerb[] =
{
    "GET",     3,  HTV_GET,     &HTTP_REQUEST::DoGet,
    "HEAD",    4,  HTV_HEAD,    &HTTP_REQUEST::DoGet,
    "TRACE",   5,  HTV_TRACE,   &HTTP_REQUEST::DoTrace,
    "PUT",     3,  HTV_PUT,     &HTTP_REQUEST::DoUnknown,
    "DELETE",  6,  HTV_DELETE,  &HTTP_REQUEST::DoUnknown,
    "TRACK",   5,  HTV_TRACECK, &HTTP_REQUEST::DoTraceCk,
    "POST",    4,  HTV_POST,    &HTTP_REQUEST::DoUnknown,
    "OPTIONS", 7,  HTV_OPTIONS, &HTTP_REQUEST::DoOptions,
    NULL,      0,  HTV_UNKNOWN, NULL
};

//
//  Private Prototypes.
//
BOOL
BuildCGIHeaderListInSTR( STR * pstr,
                    HTTP_HEADERS * pHeaderList
                    );

/*******************************************************************

    Maco support for ref/deref of CLIENT_CONN

    HISTORY:
        DaveK       22-Sep-1997 Added ref logging to HTTP_REQUEST

    NOTE callers to HR_LOG_REF_COUNT will not change ref count
    directly because HTTP_REQUEST can only change ref count by
    calling CLIENT_CONN::Ref/Deref.  We use negative ref count here
    to indicate no change to ref count.

********************************************************************/
#if DBG
extern PTRACE_LOG   g_pDbgCCRefTraceLog;
#endif

#define HR_LOG_REF_COUNT()          \
                                    \
    SHARED_LOG_REF_COUNT(           \
        - (int) QueryRefCount()     \
        , _pClientConn              \
        , this                      \
        , _pWamRequest              \
        , _htrState                 \
        );                          \



//
//  Functions.
//


/*******************************************************************

    NAME:       HTTP_REQUEST::HTTP_REQUEST

    SYNOPSIS:   Http request object constructor

    ENTRY:      pClientConn - Client connection the request is being made on

    NOTES:      Constructor can't fail

    HISTORY:
        Johnl       24-Aug-1994 Created

********************************************************************/

HTTP_REQUEST::HTTP_REQUEST(
    CLIENT_CONN * pClientConn,
    PVOID         pvInitialBuff,
    DWORD         cbInitialBuff
    )
    : HTTP_REQ_BASE( pClientConn,
                     pvInitialBuff,
                     cbInitialBuff ),
      _pGetFile    ( NULL ),
      _pWamRequest ( NULL )
{
}

HTTP_REQUEST::~HTTP_REQUEST( VOID )
{
    DBG_ASSERT( _pGetFile == NULL );
    DBG_ASSERT( _pURIInfo == NULL );
}

/*******************************************************************

    NAME:       W3MetaDataFree

    SYNOPSIS:   Frees a formatted meta data object when it's not in use.

    ENTRY:      pObject - Pointer to the meta data object.

    RETURNS:


    NOTES:


********************************************************************/

VOID
W3MetaDataFree(
    PVOID       pObject
)
{
    PW3_METADATA        pMD;

    pMD = (PW3_METADATA)pObject;

    delete pMD;
}

/*******************************************************************

    NAME:       ValidateURL

    SYNOPSIS:   WinSE 14424, added a function to check and make sure 
                the URL is not being used to bypass the metabase settings

    ENTRY:      mb - Metabase Object
                szPath - The full metabase path

    RETURNS:    TRUE - URL is good
                FALSE - URL contains characters sequence which is meant
                        to confuse the metabase. ie. "/foo./bar.asp"

    NOTES:

********************************************************************/

BOOL 
HTTP_REQUEST::ValidateURL( MB & mb, LPSTR szPath )
{
    UCHAR ch;
    FILETIME ft;
    LPSTR szPeriod = szPath;
    LPSTR szFirstPeriod;

    while ( ( szPeriod ) && ( *szPeriod != '\0' ) )
    {
        szPeriod = (PCHAR) _mbschr( (PUCHAR) szPeriod, '.' );
        while ( ( szPeriod ) && 
                ( *(szPeriod+1) != '/'  ) && 
                ( *(szPeriod+1) != '\\' ) &&
                ( *(szPeriod+1) != '\0' )
              )
        {
            szPeriod = (PCHAR) _mbschr( (PUCHAR) szPeriod+1, '.' );
        }

        // This string does not contain a './' or '.\'
        if (!szPeriod)
        { 
            return TRUE;
        }

        // find first period in this row of dots, /test.../test.htm
        szFirstPeriod = szPeriod;
        while (*CharPrev(szPath,szFirstPeriod)=='.')
        {
            szFirstPeriod--;
        }

        // Terminate Mini-String
        ch = *(szPeriod + 1);
        *(szPeriod + 1) = '\0';

        // Search for item in Metabase
        if (FAILED(mb.QueryPMDCOM()->ComMDGetLastChangeTime(mb.QueryHandle(),(PUCHAR) szPath,&ft)))
        {            
            // Item was not found, lets see if we can find it without the '.'
            *szFirstPeriod = '\0';

            if (SUCCEEDED(mb.QueryPMDCOM()->ComMDGetLastChangeTime(mb.QueryHandle(),(PUCHAR) szPath,&ft)))
            {
                // They are trying to bypass the name in the metabase, by using the '.'
                *(szPeriod + 1) = ch;
                *szFirstPeriod = '.';

                SetLastError( ERROR_FILE_NOT_FOUND );
                return FALSE;
            }             
        } // if (FAILED(mb.QueryPMDCOM()->ComMDGetLastChangeTime(mb.QueryHandle(),(PUCHAR) pszURL,&ft)))

        *(szPeriod + 1) = ch;
        *szFirstPeriod = '.';
        szPeriod++;
    } // while ( ( szPeriod ) && ( *szPeriod != '\0' ) )

    return TRUE;
} // ValidateURL

/*******************************************************************

    NAME:       HTTP_REQUEST::ReadMetaData

    SYNOPSIS:   Reads metadata for a URI, and formats it appropriately.

    ENTRY:      pszURL              - URL to find metadata for
                pstrPhysicalPath    - Physical path of strURL
                ppMetadata          - Receives pointer to metadata object

    RETURNS:    TRUE if successful, FALSE if an error occurred (call
                GetLastError())

    NOTES:


********************************************************************/

#define RMD_ASSERT(x) if (!(x)) {DBG_ASSERT(FALSE); delete pMD; return FALSE; }


BOOL HTTP_REQUEST::ReadMetaData(
    LPSTR           pszURL,
    STR *           pstrPhysicalPath,
    PW3_METADATA *  ppMetaData
    ){
    PW3_METADATA        pMD;
    DWORD               cbPath;
    DWORD               dwDataSetNumber;
    DWORD               dwDataSetSize;
    PVOID               pCacheInfo;
    MB                  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    LPSTR               pszVrPath = NULL;
    INT                 ch;
    LPSTR               pszInVr;
    LPSTR               pszMinInVr;
    DWORD               dwNeed;
    BUFFER              bufTemp1;
    DWORD               dwL;
    STACK_STR(          strFullPath, MAX_PATH );
    METADATA_ERROR_INFO MDErrorInfo;


    DBG_ASSERT( ppMetaData != NULL );

    *ppMetaData = NULL;

    // First read the data set number, and see if we already have it
    // cached.  We don't do a full open in this case.

    if (*pszURL == '*')
    {
        pszURL = Slash;
    }

    if ( !strFullPath.Copy( QueryW3Instance()->QueryMDVRPath() ) ||
         !strFullPath.Append( ( *pszURL == '/' ) ? pszURL + 1 : pszURL ) )
    {
        return FALSE;
    }

    if ( !ValidateURL( mb, strFullPath.QueryStr() ) )
    {
        return FALSE;
    }

    if (!mb.GetDataSetNumber( strFullPath.QueryStr(),
                              &dwDataSetNumber ))
    {
        return FALSE;
    }

    // See if we can find a matching data set already formatted.
    pMD = (PW3_METADATA)TsFindMetaData(dwDataSetNumber, METACACHE_W3_SERVER_ID);

    if (pMD == NULL)
    {
        pMD = new W3_METADATA;

        if (pMD == NULL)
        {
            return FALSE;
        }

        if ( !pMD->ReadMetaData( QueryW3Instance(),
                                 &mb,
                                 pszURL,
                                 &MDErrorInfo) )
        {
            delete pMD;
            mb.Close();

            SendMetaDataError(&MDErrorInfo);
            return FALSE;
        }

        // We were succesfull, so try and add this metadata. There is a race
        // condition where someone else could have added it while we were
        // formatting. This is OK - we'll have two cached, but they should be
        // consistent, and one of them will eventually time out. We could have
        // AddMetaData check for this, and free the new one while returning a
        // pointer to the old one if it finds one, but that isn't worthwhile
        // now.

        pCacheInfo = TsAddMetaData(pMD, W3MetaDataFree,
                            dwDataSetNumber, METACACHE_W3_SERVER_ID
                            );

    }

    *ppMetaData = pMD;

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //

    return pMD->BuildPhysicalPath( pszURL, pstrPhysicalPath );
}

BOOL
W3_METADATA::BuildProviderList(
    CHAR            *pszProviders
    )
/*++

Routine Description:

    Builds an array of SSPI Authentication providers

Arguments:

    pszProviders       - Comma separated list of providers

Returns:

    TRUE if we succeed, FALSE if we don't.

--*/
{
    BOOL        fRet = TRUE;
    INET_PARSER Parser( pszProviders );
    DWORD       cProv = 0;

    while ( m_apszNTProviders[cProv] )
    {
        TCP_FREE( m_apszNTProviders[cProv] );
        m_apszNTProviders[cProv++] = NULL;
    }

    Parser.SetListMode( TRUE );

    cProv = 0;
    while ( cProv < (MAX_SSPI_PROVIDERS-1) && *Parser.QueryToken() )
    {
        m_apszNTProviders[cProv] = (CHAR *) LocalAlloc( LMEM_FIXED,
                          strlen( Parser.QueryToken() ) + sizeof(CHAR));

        if ( !m_apszNTProviders[cProv] )
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            fRet = FALSE;
            break;
        }

        strcpy( m_apszNTProviders[cProv++], Parser.QueryToken() );
        Parser.NextItem();
    }

    Parser.RestoreBuffer();

    return fRet;
}

BOOL
W3_METADATA::CheckSSPPackage(
        IN LPCSTR pszAuthString
        )
{
    DWORD i = 0;

    while ( m_apszNTProviders[i] )
    {
        if ( !_stricmp( pszAuthString, m_apszNTProviders[i++] ))
        {
            return TRUE;
        }
    }

    return FALSE;

} // W3_SERVER_INSTANCE::CheckSSPPackage


/*******************************************************************

    NAME:       HTTP_REQUEST::Reset

    SYNOPSIS:   Resets the request object getting it ready for the next
                client request.  Called at the beginning of a request.

    RETURNS:    TRUE if successful, FALSE if an error occurred (call
                GetLastError())

    HISTORY:
        Johnl       04-Sep-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::Reset( BOOL fResetPipelineInfo )
{
    //
    //  Must reset the base object first
    //

    TCP_REQUIRE( HTTP_REQ_BASE::Reset(fResetPipelineInfo) );

    _fAcceptsAll             = FALSE;
    _fAnyParams              = FALSE;
    _fSendToDav              = FALSE;
    _fDisableScriptmap       = FALSE;

    _GatewayType             = GATEWAY_UNKNOWN;
    _dwScriptMapFlags        = 0;
    _dwFileSystemType        = FS_FAT;
    _hTempFileHandle         = INVALID_HANDLE_VALUE;

    _strGatewayImage.Reset();
    _strContentType.Reset();
    _strReturnMimeType.Reset();
    _strTempFileName.Reset();

    _pFileNameLock = NULL;

    CloseGetFile();

    QueryClientConn()->UnbindAccessCheckList();

    // Free the URI and/or metadata information if we have any. We know that
    // if we have URI info, then it points at meta data and will free the
    // metadata info when the URI info is free. Otherwise, we need to free
    // the metadata information here.

    ReleaseCacheInfo();

    // reset execution descriptor block

    _Exec.Reset();
    _dwCallLevel = 0;

    // DLC reset

    _strDLCString.Reset();

    // Default execute document

    _fPossibleDefaultExecute = FALSE;

    return TRUE;
}

VOID
HTTP_REQUEST::ReleaseCacheInfo(
    VOID
    )
/*++

Routine Description:

    Checks in any cache info we have out at the end of a
    request

    This is a virtual method from HTTP_REQ_BASE.

Arguments:

    None.

--*/

{
    //
    //  Let's release the base object first
    //

    HTTP_REQ_BASE::ReleaseCacheInfo();
    _Exec.ReleaseCacheInfo();
}


/*******************************************************************

    NAME:       HTTP_REQUEST::DoWork

    SYNOPSIS:   Calls the appropriate work item based on our state

    ENTRY:      pfFinished - Gets set to TRUE if the client request has
                    been completed

    RETURNS:    TRUE if successful, FALSE if an error occurred (call
                GetLastError())

    NOTES:      If a failure occurs because of bad info from the client (bad
                URL, syntax error etc) then the code that found the problem
                should call SendErrorResponse( error ), set the state to
                HTR_DONE and return TRUE (when send completes, HTR_DONE will
                cleanup).

                If an error occurs in the server (out of memory etc) then
                LastError should be set and FALSE should be returned.  A server
                error will be sent then the client will be disconnected.

    HISTORY:
        Johnl       26-Aug-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::DoWork(
    BOOL * pfFinished
    )
{
    BOOL fRet = TRUE;
    BOOL fContinueProcessingRequest;
    BOOL fHandled;
    BOOL fDone = FALSE;
    BOOL fCompleteRequest;
    DWORD dwOffset;
    DWORD dwSizeToSend;
    BOOL fEntireFile;
    BOOL fIsNxRange;
    BOOL fIsLastRange;

    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[http_request::DoWork] Object %lx.  State = %d, Bytes Written = %d\n",
                    QueryClientConn(),
                    QueryState(),
                    QueryBytesWritten() ));

    }

    DBG_CODE( HR_LOG_REF_COUNT(); );

    switch ( QueryState() )
    {
    case HTR_GATEWAY_ASYNC_IO:

        fRet = ProcessAsyncGatewayIO();
        break;

    case HTR_READING_CLIENT_REQUEST:

        _cbBytesReceived += QueryBytesWritten();

        fRet = OnFillClientReq( &fCompleteRequest,
                                pfFinished,
                                &fContinueProcessingRequest);
        
        if ( !fRet )
            break;

        if ( *pfFinished || !fContinueProcessingRequest)
            break;

        if ( fCompleteRequest )
        {
            goto ProcessClientRequest;
        }
        break;

    case HTR_READING_GATEWAY_DATA:

        _cbBytesReceived += QueryBytesWritten();

        fRet = ReadEntityBody( &fDone );

        if ( !fRet || !fDone )
        {
            break;
        }

        // Otherwise we're done reading the first piece of the entity body.
        // PUT (and possibly other verbs in the future) come through here to
        // read their intial entity body. We need to set the state to DOVERB
        // here in order to make them work, so that subsequent reads they might
        // issue don't come back through this path. Then fall through to the
        // DOVERB handlesr.

        SetState(HTR_DOVERB);

    case HTR_DOVERB:

ProcessClientRequest:

        DBG_ASSERT(QueryState() == HTR_DOVERB);

        // WinNT 379450
        if ( _GatewayType == GATEWAY_MALFORMED )
        {
              SetState( HTR_DONE, HT_NOT_FOUND, ERROR_INVALID_PARAMETER );
              Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
              fRet = TRUE;
              break;
        }

        //
        //  Check to see if encryption is required before we do any processing
        //

        if ( (GetFilePerms() & VROOT_MASK_SSL) && !IsSecurePort() )
        {
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );

            Disconnect( HT_FORBIDDEN, IDS_SSL_REQUIRED, FALSE, pfFinished );
            fRet = TRUE;

            DBG_CODE( HR_LOG_REF_COUNT(); );

            break;
        }
        //
        //  Check for short name as they break metabase equivalency
        //

        if ( memchr( _strPhysicalPath.QueryStr(), '~', _strPhysicalPath.QueryCB() ))             
        {
            BOOL  fShort;
            DWORD err;

            if ( err = CheckIfShortFileName( (UCHAR *) _strPhysicalPath.QueryStr(), 
                                             QueryImpersonationHandle(),
                                             &fShort ))
            {
                if ( err != ERROR_FILE_NOT_FOUND &&
                     err != ERROR_PATH_NOT_FOUND )
                {
                    fRet = FALSE;
                    break;
                }
                
                goto PathNotFound;
            }

            if ( fShort )
            {
PathNotFound:
                SetState( HTR_DONE, HT_NOT_FOUND, ERROR_FILE_NOT_FOUND );
                Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                fRet = TRUE;
                break;
            }
        }            

        if ( IsProbablyGatewayRequest() )
        {

            //
            // Optionally check whether the PATH_INFO exists and is openable
            //

            if ( *(_Exec._pdwScriptMapFlags) & MD_SCRIPTMAPFLAG_CHECK_PATH_INFO )
            {
                STACK_STR(           strTemp, MAX_PATH );
                TS_OPEN_FILE_INFO *  pGetFile = NULL;
                DWORD                err;

                if ( !LookupVirtualRoot( &strTemp,
                                         _Exec._pstrPathInfo->QueryStr(),
                                         _Exec._pstrPathInfo->QueryCCH() ) )
                {
                    fRet = FALSE;
                    break;
                }

                if ( !ImpersonateUser() )
                {
                    fRet = FALSE;
                    break;
                }

                pGetFile = TsCreateFile( QueryW3Instance()->GetTsvcCache(),
                                         strTemp.QueryStr(),
                                         QueryImpersonationHandle(),
                                         (_fClearTextPass || _fAnonymous) ?
                                                TS_CACHING_DESIRED : 0 );

                err = GetLastError();

                RevertUser();

                if ( pGetFile == NULL )
                {
                    fRet = TRUE;

                    if ( err == ERROR_FILE_NOT_FOUND ||
                         err == ERROR_PATH_NOT_FOUND )
                    {
                        SetState( HTR_DONE, HT_NOT_FOUND, err );
                        Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                        break;
                    }
                    else if (err == ERROR_INSUFFICIENT_BUFFER)
                    {
                        // Really means the file name was too long.

                        SetState(HTR_DONE, HT_URL_TOO_LONG, err);
                        Disconnect(HT_URL_TOO_LONG, IDS_URL_TOO_LONG, FALSE, pfFinished );
                        break;
                    }
                    else if ( err == ERROR_INVALID_NAME )
                    {
                        SetState( HTR_DONE, HT_BAD_REQUEST, err );
                        Disconnect( HT_BAD_REQUEST, NO_ERROR, FALSE, pfFinished );
                        break;
                    }
                    else if ( err == ERROR_ACCESS_DENIED )
                    {
                        fRet = FALSE;
                        SetDeniedFlags( SF_DENIED_RESOURCE );
                        break;
                    }
                    else
                    {
                        fRet = FALSE;
                        break;
                    }
                }
                else
                {
                    DBG_REQUIRE( TsCloseHandle( QueryW3Instance()->GetTsvcCache(),
                                                pGetFile ) );
                }
            }

            fHandled = FALSE;

            if ( _GatewayType == GATEWAY_BGI )
            {

                DBG_CODE( HR_LOG_REF_COUNT(); );

                fRet = ProcessBGI( &_Exec,
                                  &fHandled,
                                  pfFinished,
                                  _dwScriptMapFlags & MD_SCRIPTMAPFLAG_SCRIPT,
                                  _dwScriptMapFlags & MD_SCRIPTMAPFLAG_WILDCARD);

                DBG_CODE( HR_LOG_REF_COUNT(); );

            }
            else
            {
                fRet = ProcessGateway( &_Exec,
                                      &fHandled,
                                      pfFinished,
                                      _dwScriptMapFlags
                                        & MD_SCRIPTMAPFLAG_SCRIPT );
            }

            if ( !fRet) {
                break;
            }

            if ( fHandled || *pfFinished )
                break;

            //
            //  Either an error ocurred or the gateways should indicate they
            //  handled this
            //

            DBGPRINTF((
                  DBG_CONTEXT
                , "HTTP_REQUEST(%08x)::DoWork - "
                  "Un-finished, un-handled, succeeded request. "
                  "_pWamRequest(%08x) "
                  "fRet(%d) "
                  "fHandled(%d) "
                  "*pfFinished(%d) "
                  "\n"
                , this
                , _pWamRequest
                , fRet
                , fHandled
                , *pfFinished
            ));

            DBG_ASSERT( FALSE );
        }
        // SteveBr:  Removing MD_SCRIPTMAPFLAG_NOTRANSMIT_ON_READ_DIR
        else if ( _dwScriptMapFlags )
        {
            //
            // Disallow GET on requests with script mappings. This ensures that the only
            // way to get source code access is via DAV (translate:f header)
            //
            
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
            Disconnect( HT_FORBIDDEN, IDS_EXECUTE_ACCESS_DENIED, FALSE, pfFinished );
            break;
        }

        fRet = (this->*_pmfnVerb)( pfFinished );
        break;

    case HTR_CGI:
        fRet = TRUE;
        break;

    case HTR_RANGE:
        dwOffset = _dwRgNxOffset;
        dwSizeToSend = _dwRgNxSizeToSend;
        DBG_REQUIRE(ScanRange( &_dwRgNxOffset, &_dwRgNxSizeToSend, &fEntireFile, &fIsLastRange));
        fRet = SendRange( 0, dwOffset, dwSizeToSend, fIsLastRange );
        break;

    case HTR_CERT_RENEGOTIATE:
        _cbBytesReceived += QueryBytesWritten();

        fRet = HandleCertRenegotiation( pfFinished,
                                 &fContinueProcessingRequest,
                                 QueryBytesWritten() );

        if ( !fRet || !fContinueProcessingRequest || *pfFinished )
        {
            break;
        }

        goto ProcessClientRequest;

    case HTR_RESTART_REQUEST:

        DBG_CODE( HR_LOG_REF_COUNT(); );

        fRet = OnRestartRequest( (char *)_bufClientRequest.QueryPtr(),
                                 _cbBytesWritten = _cbRestartBytesWritten,
                                 pfFinished,
                                 &fContinueProcessingRequest);

        DBG_CODE( HR_LOG_REF_COUNT(); );

        if ( !fRet || !fContinueProcessingRequest || *pfFinished  )
        {
            break;
        }
        goto ProcessClientRequest;

    case HTR_REDIRECT:
    
        DBG_CODE( HR_LOG_REF_COUNT(); );
        
        _cbBytesReceived += QueryBytesWritten();

        fRet = ReadEntityBody( &fDone, FALSE, QueryClientContentLength() );
        
        if ( !fRet || !fDone )
        {
            break;
        }
        
        // 
        // Now we can do the redirect
        // 

        fRet = DoRedirect( pfFinished );        
        break;

    case HTR_ACCESS_DENIED:
        
        DBG_CODE( HR_LOG_REF_COUNT(); );
        
        _cbBytesReceived += QueryBytesWritten();
        
        fRet = ReadEntityBody( &fDone, FALSE, QueryClientContentLength() );
        if ( !fRet || !fDone )
        {
            break;
        }
        
        fRet = FALSE;
        SetLastError( ERROR_ACCESS_DENIED );
        
        break;

    case HTR_DONE:
        fRet = TRUE;
        *pfFinished = TRUE;

        break;

    default:
        DBG_ASSERT( FALSE );
        fRet = FALSE;
        SetLastError( ERROR_INVALID_PARAMETER );
        break;
    }

    IF_DEBUG( CONNECTION )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[http_request::DoWork] Leaving, Object %lx.  State = %d\n",
                    QueryClientConn(),
                    QueryState() ));

    }

    DBG_CODE( HR_LOG_REF_COUNT(); );

    return fRet;
}

BOOL
HTTP_REQUEST::FindHost(
    VOID
    )
/*++

Routine Description:

    Find the appropriate host from a request. This involves looking at
    the host header field and/or the URL itself, and selecting the
    appropriate value. For down level clients we may invoke the munging
    code.

Arguments:

    None.

Return value:

    TRUE if no error, otherwise FALSE

--*/
{
    CHAR        *pszURL;
    CHAR        *pszHost;
    BOOL        bFoundColon;
    DWORD       dwHostNameLength;
    BOOL        fHTTPS = FALSE;
    BOOL        fStartsWithHTTP = FALSE;
    
    pszURL = (CHAR *)_HeaderList.FastMapQueryValue(HM_URL);

    DBG_ASSERT(pszURL != NULL);

    if ( *pszURL != '/' )
    {
        //
        // We probably have an absolute URL. Verify that, then save
        // the host name part of the URL, and update the URL to point
        // beyond the host name.

        if ( _strnicmp("http://", pszURL, sizeof("http://") - 1) == 0)
        {
            fHTTPS = FALSE;
            fStartsWithHTTP = TRUE;
        }
        else if ( _strnicmp("https://", pszURL, sizeof("https://") - 1) == 0)
        {
            fHTTPS = TRUE;
            fStartsWithHTTP = TRUE;
        }

        if ( fStartsWithHTTP )
        {
            pszHost = pszURL + ( fHTTPS ? sizeof("https://") : sizeof("http://") ) - 1;

            // pszHost points to the host name. Walk forward from there.
            // If we find a colon we'll want to remember the length at
            // that point, and we'll keep searching for a termination slash.

            pszURL = pszHost;

            bFoundColon = FALSE;

            while (*pszURL != '\0')
            {

                if (*pszURL == ':')
                {
                    // Found a colon. If we haven't already seen one,
                    // calculate the length of the host name now.

                    if (!bFoundColon)
                    {
                        dwHostNameLength = DIFF(pszURL - pszHost);
                    }

                    // Convert the colon to a termianting NULL, remember we
                    // saw it, and keep going.

                    bFoundColon = TRUE;
                    pszURL++;
                }
                else
                {
                    // If we find a slash, we're done.

                    if (*pszURL == '/')
                    {
                        break;
                    }

                    pszURL++;
                }
            }

            if (*pszURL == '\0')
            {
                // A URL like http://www.microsoft.com is invalid, so
                // fail it here.

                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            if (!bFoundColon)
            {
                // Haven't computed host name length yet, do it now.
                dwHostNameLength = DIFF(pszURL - pszHost);
            }

            if (!_strHostAddr.Copy(pszHost, dwHostNameLength))
            {
                return FALSE;
            }

            return TRUE;

        }
        else
        {
            // This was not a valid HTTP scheme, nor is it an absolute path.
            // Fail the request, choosing the correct error depending on
            // whether or not this looks like a scheme.

            if (*pszURL != '*' || pszURL[1] != '\0')
            {
                if (strchr(pszURL, ':') != NULL)
                {
                    // unknown scheme ( e.g FTP )
                    // This is not an error as this may be handled by a filter
                    // such as the proxy filter

                    return TRUE;
                }
                else
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                }
                return FALSE;
            }

        }

    }

    //
    // If we get here we know we didn't have an absolute URI. Check
    // for a Host: header, and if we have one save that as the host name.
    //

    pszHost = (CHAR *)_HeaderList.FastMapQueryValue(HM_HST);

    if (pszHost != NULL)
    {
        CHAR        *pszTemp = pszHost;

        // Have a host value. Scan it for a colon, and calculate the
        // length based on the colon or the terminating null.

        while (*pszTemp != '\0' && *pszTemp != ':')
        {
            pszTemp++;
        }

        if (!_strHostAddr.Copy(pszHost, DIFF(pszTemp - pszHost) ) )
        {
            return FALSE;
        }

        return TRUE;
    }

    //
    // Right now we have neither an absolute URI or a Host: header. Invoke
    // the down level client support if we're supposed to.
    //

    if ( g_fDLCSupport )
    {
        if ( !DLCMungeSimple() )
        {
            return FALSE;
        }
    }

    return TRUE;


}


// Used to extract fast-map parameter, and parse it using sub-function.
# define CheckAndParseField( fld, pstr, func)  \
  if ( ((pstr = (LPSTR ) _HeaderList.FastMapQueryValue( fld)) != NULL) &&  \
       !(this->func( pstr))) {  \
      return ( FALSE);          \
  }


/*******************************************************************

    NAME:       HTTP_REQUEST::Parse

    SYNOPSIS:   Gathers all of the interesting information in the client
                request

    ENTRY:      pchRequest - raw Latin-1 request received from the
                    client, zero terminated
                pfFinished - Set to TRUE if no further processing is needed
                pfHandled - Set to TRUE if request has been handled

    RETURNS:    APIERR if an error occurred parsing the header

    HISTORY:
        Johnl       24-Aug-1994 Created
        MuraliK     19-Nov-1996 Created new HTTP HEADERS object and
                                modified parsing

********************************************************************/

BOOL
HTTP_REQUEST::Parse(
    const CHAR*   pchRequest,
    DWORD         cbData,
    DWORD *       pcbExtraData,
    BOOL *        pfHandled,
    BOOL *        pfFinished
    )
{
    PMFN_ONGRAMMAR   pmfn;
    BOOL             fRet;
    BOOL             fIsTrace = FALSE;
    BOOL             fSecondTry = FALSE;
    PW3_SERVER_INSTANCE pInstance;
    BOOL             fMaxConnExceeded;
    LPSTR            pszV;

    //
    //  1. Eliminate all the leading spaces
    //     Also eliminate \r\n since some clients are sending
    //     extra \r\n\r\n at the end of the POST
    //     sending extra characters is incorrect but RFC recommends 
    //     to handle it

    while ( cbData && 
            (  isspace( (UCHAR)(*(PCHAR)pchRequest) ) ||
              (*pchRequest == '\r')  ||
              (*pchRequest == '\n') 
            ) 
          )
    {
        --cbData;
        ++pchRequest;
    }

    //
    //  2. Find if Trace operation was requested.
    //
    if (*pchRequest == 'T' ) {
        if ( (cbData > 6) && !memcmp( pchRequest, "TRAC", sizeof("TRAC")-1) )
        {
            if ( ( pchRequest[sizeof("TRAC")-1] == 'E' &&
                   _HTTP_IS_LINEAR_SPACE( ((PBYTE)pchRequest)[sizeof("TRACE")-1] ) ) ||
                 ( pchRequest[sizeof("TRAC")-1] == 'K' &&
                   _HTTP_IS_LINEAR_SPACE( ((PBYTE)pchRequest)[sizeof("TRACK")-1] ) ) )
            {
                if ( !QueryRespBuf()->Resize( cbData + sizeof( CHAR ) ) )
                {
                    return FALSE;
                }
                CopyMemory( QueryRespBufPtr(), pchRequest, cbData );
                QueryRespBufPtr()[ cbData ] = '\0';
                fIsTrace = TRUE;
            }
        }
    }

    if ( !_HeaderList.ParseInput( pchRequest, cbData, pcbExtraData)) {

        return ( FALSE);
    }

    // WinSE 26482 - reject if request header has the character nul in it
    //
    DWORD cchHeader = cbData - *pcbExtraData;
    if ( memchr(pchRequest, 0, cchHeader)!=NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Parse out the version number now.  We do this so that we can send
    // the appropriate Connection: header in the error response if 
    // FindHost() fails.
    //

    CheckAndParseField( HM_VER, pszV, HTTP_REQUEST::OnVersion);

    //
    // If this client didn't send a host header, and down level client support
    // is required, then munge the URL if necessary.
    //

    if (!FindHost())
    {
        return FALSE;
    }


RetryQueryInstance:

    fMaxConnExceeded = FALSE;

    //
    // Get the server instance
    //

    pInstance = QueryW3Instance();

    if ( pInstance == NULL )
    {

        pInstance = (PW3_SERVER_INSTANCE)
            QueryClientConn()->QueryW3Endpoint()->FindAndReferenceInstance(
                            _strHostAddr.QueryStr(),
                            QueryClientConn()->QueryLocalIPAddress(),
                            &fMaxConnExceeded
                            );

#if 0
        if( pInstance != NULL && fMaxConnExceeded ) {
            pInstance->DecrementCurrentConnections();
            pInstance->Dereference();
            pInstance = NULL;
            SetLastError( ERROR_TOO_MANY_SESS );
            return FALSE;
        }
#endif

        //
        // set the instance. We know that fMaxConnExceeded can't be true
        // unless we found an instance.
        //

        DBG_ASSERT(!fMaxConnExceeded || pInstance != NULL);

        if ( pInstance == NULL)
        {
            DWORD err;

            if ( g_fDLCSupport )
            {
                if ( !fSecondTry &&
                     _strHostAddr.IsEmpty() &&
                     DLCHandleRequest( pfFinished ) )
                {
                    if ( *pfFinished )
                    {
                        return TRUE;
                    }
                    fSecondTry = TRUE;
                    goto RetryQueryInstance;
                }
            }

            err = GetLastError();

            IF_DEBUG(ERROR) {
                DBGPRINTF((DBG_CONTEXT,"FindInstance failed with %d\n",err));
            }

            //
            // map access denied to something else so we don't request
            // for authentication
            //

            if ( err == ERROR_ACCESS_DENIED ) {
                SetLastError(ERROR_LOGIN_WKSTA_RESTRICTION);
            }

            return FALSE;
        }

        DBG_ASSERT(pInstance != NULL);

        //
        //  Set the timeout for future IOs on this context
        //

        AtqContextSetInfo( QueryClientConn()->QueryAtqContext(),
                           ATQ_INFO_TIMEOUT,
                           (ULONG_PTR) pInstance->QueryConnectionTimeout() );

        //
        // Setup bandwidth throttling for this context
        //

        if ( pInstance->QueryBandwidthInfo() )
        {
            AtqContextSetInfo( QueryClientConn()->QueryAtqContext(),
                               ATQ_INFO_BANDWIDTH_INFO,
                               (ULONG_PTR) pInstance->QueryBandwidthInfo() );
        }

        //
        // FindInstance sets a reference to pInstance which
        // we use here.
        //

        QueryClientConn()->SetW3Instance(pInstance);
        SetW3Instance(pInstance);

        //
        // Set statistics object to point to pInstance's statistics object
        //

        QueryClientConn()->SetW3StatsObj(pInstance->QueryStatsObj());
        SetW3StatsObj(pInstance->QueryStatsObj());

        //
        //  Set and reference the filter list for this instance and then copy
        //  any global filter context pointers to the per-instance filter list
        //

        pInstance->LockThisForRead();
        if ( !_Filter.SetFilterList( pInstance->QueryFilterList() ) )
        {
            pInstance->UnlockThis();
            return FALSE;
        }
        pInstance->UnlockThis();

        _Filter.CopyContextPointers();
    }

    //
    // Keep track of what URL was before we passed it to any filters that might modify
    // it [other than READ_RAW filters]
    //
    _strOriginalURL.Copy( _HeaderList.FastMapQueryValue( HM_URL ) );

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_PREPROC_HEADERS,
                                       IsSecurePort() ))
    {
        //
        //  Notify any filters interested in the request and headers before
        //  we do any processing
        //

        if ( !_Filter.NotifyPreProcHeaderFilters( pfFinished ))
        {
            if ( GetLastError() == ERROR_ACCESS_DENIED )
            {
                //
                // we need to read metadata so that WWW authentication
                // headers can be properly generated.
                //

                OnURL( (LPSTR)_HeaderList.FastMapQueryValue( HM_URL ) );

                //
                // restore error ( may have been modified by OnUrl )
                // we disregard any error from OnUrl as we are already
                // doing error processing.
                //

                SetLastError( ERROR_ACCESS_DENIED );
                SetDeniedFlags( SF_DENIED_FILTER );
            }

            return FALSE;
        }

        if ( *pfFinished )
        {
            return TRUE;
        }
    }


    //
    //  Now scan for any RFC822 field names that we recognize
    //

    //
    // Check individual items of interest and execute the parse function
    //  for that item
    // NYI: It will be great if we can defer the execution and do it on
    //  demand basis. We need to modify entire use of the values from
    //  HTTP_REQUEST object to make this happen.


    //
    //WinSE 24317: URL and Verb are required
    {
        LPSTR pszVerb;
        LPSTR pszURL;
    
        pszVerb = (LPSTR)_HeaderList.FastMapQueryValue(HM_MET);
        pszURL = (LPSTR)_HeaderList.FastMapQueryValue(HM_URL);
    
        if ( pszVerb == NULL || pszURL == NULL )
        {
            SetState( HTR_DONE, HT_SERVER_ERROR, NO_ERROR );
            Disconnect( HT_SERVER_ERROR, 0, FALSE, pfFinished );

            *pfHandled = TRUE;
            return TRUE;
        }

        if (!(this->HTTP_REQUEST::OnVerb( pszVerb)))
            return ( FALSE);

        if (!(this->HTTP_REQUEST::OnURL( pszURL)))
            return ( FALSE);
    }


    // Now that we've accompished a minimum amount of header processing,
    // check to see if we've exceeded the maximum connection count.

    if (fMaxConnExceeded)
    {

        // We've exceeded the max, so we're done now.
        SetLastError( ERROR_TOO_MANY_SESS );
        return FALSE;
    }

    //
    // See if the site is stopped
    //

    DBG_ASSERT( pInstance != NULL);

    if (pInstance->IsSiteCPUPaused())
    {
        SetState( HTR_DONE, HT_SVC_UNAVAILABLE, ERROR_NOT_ENOUGH_QUOTA );

        Disconnect( HT_SVC_UNAVAILABLE, IDS_SITE_RESOURCE_BLOCKED, FALSE, pfFinished );

        *pfHandled = TRUE;
        return TRUE;
    }


    CheckAndParseField( HM_ACC, pszV, HTTP_REQUEST::OnAccept);
    CheckAndParseField( HM_CON, pszV, HTTP_REQUEST::OnConnection);
//    CheckAndParseField( HM_HST, pszV, HTTP_REQ_BASE::OnHost);
    // HM_AUT is deferred
    // CheckAndParseField( HM_AUT, pszV, HTTP_REQ_BASE::OnAuthorization);
    CheckAndParseField( HM_IMS, pszV, HTTP_REQ_BASE::OnIfModifiedSince);
    CheckAndParseField( HM_IFM, pszV, HTTP_REQ_BASE::OnIfMatch);
    CheckAndParseField( HM_INM, pszV, HTTP_REQ_BASE::OnIfNoneMatch);
    CheckAndParseField( HM_IFR, pszV, HTTP_REQ_BASE::OnIfRange);
    CheckAndParseField( HM_UMS, pszV, HTTP_REQ_BASE::OnUnlessModifiedSince);
    CheckAndParseField( HM_IUM, pszV, HTTP_REQ_BASE::OnIfUnmodifiedSince);
    CheckAndParseField( HM_CLE, pszV, HTTP_REQ_BASE::OnContentLength);
    CheckAndParseField( HM_CTY, pszV, HTTP_REQUEST::OnContentType);
    CheckAndParseField( HM_PRA, pszV, HTTP_REQUEST::OnProxyAuthorization);
    CheckAndParseField( HM_RNG, pszV, HTTP_REQ_BASE::OnRange);
    CheckAndParseField( HM_TEC, pszV, HTTP_REQUEST::OnTransferEncoding);
    CheckAndParseField( HM_LCK, pszV, HTTP_REQUEST::OnLockToken);
    
    //
    // Optionally ignore the Translate header
    //
    
    if ( !_pMetaData || !_pMetaData->QueryIgnoreTranslate() )
    {
        CheckAndParseField( HM_TRN, pszV, HTTP_REQUEST::OnTranslate);
    }
    
    CheckAndParseField( HM_ISM, pszV, HTTP_REQUEST::OnIf);

    // Make sure we're see a host header if this is a 1.1 request.

    if (IsOneOne() && _HeaderList.FastMapQueryValue(HM_HST) == NULL)
    {
        _HeaderList.FastMapCancel( HM_AUT );

        SetState( HTR_DONE, HT_BAD_REQUEST, ERROR_INVALID_PARAMETER );
        Disconnect( HT_BAD_REQUEST, IDS_HOST_REQUIRED, FALSE, pfFinished );

        *pfHandled = TRUE;
        return TRUE;
    }

    //
    // OK.  Now we have determined whether or not to keep the connection 
    // alive.  Now we can check when the VROOT allows it.
    //

    if ( !_pMetaData->QueryKeepAlives() )
    {
        SetKeepConn( FALSE );
    }

    //
    //  If we picked up some gateway data in the headers, adjust for that
    //  now
    //

    _cbClientRequest -= *pcbExtraData;

    //
    // store available input byte count for OnRestartRequest
    // necessary because _cbBytesWritten will be overwritten
    // by IO completion
    //

    if ( _fHaveContentLength )
    {
        _cbBytesWritten = _cbRestartBytesWritten = *pcbExtraData;
    }
    else
    {
        _cbRestartBytesWritten = _cbBytesWritten;
    }
    
    SetState( HTR_DOVERB );

    return (fIsTrace ? TRUE : ProcessURL( pfFinished, pfHandled ));
} // HTTP_REQUEST::Parse()

/*******************************************************************

    NAME:       HTTP_REQUEST::OnVerb

    SYNOPSIS:   Parses the verb from an HTTP request

    ENTRY:      pszValue - Pointer to zero terminated string


    RETURNS:    TRUE if successful, FALSE if an error occurred

    HISTORY:
        Johnl       24-Aug-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::OnVerb( CHAR * pszValue )
{
    UINT i = 0;
    UINT cchMethod;

    if ( !_strMethod.Copy( pszValue ) )
        return FALSE;

    //
    //  Look for the verbs we recognize
    //

    cchMethod = _strMethod.QueryCCH();
    
    while ( DoVerb[i].pchVerb )
    {
        if ( (cchMethod == DoVerb[i].cchVerb) &&
             (!memcmp( pszValue,
                      DoVerb[i].pchVerb,
                      DoVerb[i].cchVerb )))
        {
            _verb     = DoVerb[i].httpVerb;

            switch ( _verb )
            {
            case HTV_GET:
                QueryW3StatsObj()->IncrTotalGets();
                break;

            case HTV_HEAD:
                QueryW3StatsObj()->IncrTotalHeads();
                break;

            case HTV_TRACE:
                QueryW3StatsObj()->IncrTotalTraces();
                break;

            case HTV_TRACECK:
                break;

            case HTV_PUT:
                QueryW3StatsObj()->IncrTotalPuts();
                _putstate = PSTATE_START;
                _fSendToDav = TRUE;     // Verb is handled by DAV.
#if 0   // Not used anywhere /SAB
                _fIsWrite = TRUE;
#endif
                break;

            case HTV_DELETE:
                QueryW3StatsObj()->IncrTotalDeletes();
                _fSendToDav = TRUE;     // Verb is handled by DAV.
                break;

            case HTV_POST:
                QueryW3StatsObj()->IncrTotalPosts();
                break;

            case HTV_OPTIONS:
                QueryW3StatsObj()->IncrTotalOthers();
                _fSendToDav = TRUE;     // Verb is handled by DAV.
                break;

            default:
                DBG_ASSERT( FALSE );
                break;
            }

            _pmfnVerb = DoVerb[i].pmfnVerb;

            return TRUE;
        }

        i++;
    }

    //
    //  The verb may be a verb a gateway knows how to deal with so
    //  all hope isn't lost
    //

    QueryW3StatsObj()->IncrTotalOthers();

    _pmfnVerb = &HTTP_REQUEST::DoUnknown;
    _verb     = HTV_UNKNOWN;
    _fSendToDav = TRUE;     // Send unknown verbs to DAV.

    return TRUE;
}


BOOL
HTTP_REQUEST::NormalizeUrl(
    LPSTR   pszStart
    )
/*++

Routine Description:

    Normalize URL

Arguments:

    strUrl - URL to be updated to a canonical URI

Return value:

    TRUE if no error, otherwise FALSE

--*/
{
    TCHAR * pchParams;
    TCHAR * pch;
    TCHAR * pszACU;
    TCHAR   chParams;
    LPSTR   pszSlash;
    LPSTR   pszURL;
    LPSTR   pszValue;
    BOOL    fSt;
    STACK_STR( strChgUrl, MAX_PATH );


    if ( *pszStart != '/' )
    {
        //
        // assume HTTP URL, skip protocol & host name by
        // searching for 1st '/' following "//"
        //
        // We handle this information as a "Host:" header.
        // It will be overwritten by the real header if it is
        // present.
        //
        // We do not check for a match in this case.
        //

        if ( (pszSlash = strchr( pszStart, '/' )) && pszSlash[1] == '/' )
        {
            pszSlash += 2;
            if ( pszURL = strchr( pszSlash, '/' ) )
            {
                //
                // update pointer to URL to point to the 1st slash
                // following host name
                //

                pszValue = pszURL;
            }
            else
            {
                //
                // if no single slash following host name
                // consider the URL to be empty.
                //

                pszValue = pszSlash + strlen( pszSlash );
            }

            memmove( pszStart, pszValue, strlen(pszValue)+1 );
        }

        //
        // if no double slash, this is not a fully qualified URL
        // and we leave it alone.
        //
    }

    //
    // references to /_[W3_AUTH_CHANGE_URL] will be redirected
    // to the configured URL. This URL will be accessed from
    // the system context ( i.e with system access rights )
    //

    if ( pszStart[0] == '/' && pszStart[1] == '_'
         && !memcmp( pszStart+2, W3_AUTH_CHANGE_URL, sizeof(W3_AUTH_CHANGE_URL)-1 ) )
    {
        QueryW3Instance()->LockThisForRead();
        fSt = strChgUrl.Copy( pszACU = (TCHAR*)QueryW3Instance()->QueryAuthChangeUrl() );
        QueryW3Instance()->UnlockThis();

        if ( pszACU )
        {
            if ( fSt )
            {
                strcpy( pszStart, strChgUrl.QueryStr() );
            }
            else
            {
                return FALSE;
            }
        }
    }

    //
    //  Check for a question mark which indicates this URL contains some
    //  parameters and break the two apart if found
    //

    if ( (pchParams = ::_tcschr( pszStart, TEXT('?') )) )
    {
        *pchParams = TEXT('\0');
    }

    //
    // Unescape wants a STR ( sigh )
    //

    strChgUrl.Copy( (TCHAR*)pszStart );
    strChgUrl.Unescape();
    strcpy( pszStart, strChgUrl.QueryStr() );

    //
    //  Canonicalize the URL
    //

    CanonURL( pszStart, g_pInetSvc->IsSystemDBCS() );

    return TRUE;
}



/*******************************************************************

    NAME:       HTTP_REQUEST::OnURL

    SYNOPSIS:   Parses the URL from an HTTP request

    ENTRY:      pszValue - URL on http request line


    RETURNS:    TRUE if successful, FALSE if an error occurred

    NOTES:      The URL and Path info are unescaped in this method.
                Parameters coming after the "?" are *not* unescaped as they
                contain encoded '&' or other meaningful items.

    HISTORY:
        Johnl       24-Aug-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::OnURL( CHAR * pszValue )
{
    TCHAR * pchParams;
    TCHAR * pchStart;
    TCHAR * pch;
    TCHAR * pszACU;
    TCHAR   chParams;
    LPSTR   pszSlash;
    BOOL    fSt;
    LPSTR   pszArg = NULL;
    STACK_STR( strChgUrl, MAX_PATH );
    PW3_URI_INFO    pURIBlob;
    BOOL fHTTPS = FALSE;
    BOOL fHTTP = FALSE;

    if ( *pszValue != '/' )
    {
        //
        // skip protocol & host name by
        // searching for 1st '/' following "http://" or "https://"
        //

        if ( _strnicmp("http://", pszValue, sizeof("http://") - 1) == 0)
        {
            fHTTP = TRUE;
        }
        else if ( _strnicmp("https://", pszValue, sizeof("https://") - 1) == 0)
        {
            fHTTPS = TRUE;
        }

        if ( fHTTP || fHTTPS )
        {
            pszSlash = pszValue + ( fHTTP ? sizeof("http://") - 1 :
                                            sizeof("https://") - 1 );

            if ( !(pszValue = strchr( pszSlash, '/' )) )
            {
                //
                // if no single slash following host name
                // then URL is empty and this is an invalid request
                //

                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
        }
        else
        {
            if ( (*pszValue != '*' || pszValue[1] != '\0') &&
                 strchr(pszValue, ':') != NULL )
            {
                // unknown scheme ( e.g FTP )

                SetLastError( ERROR_NOT_SUPPORTED );

                return FALSE;
            }
        }
    }

    //
    // references to /_[W3_AUTH_CHANGE_URL] will be redirected
    // to the configured URL. This URL will be accessed from
    // the system context ( i.e with system access rights )
    //

    if ( pszValue[0] == '/' && pszValue[1] == '_'
         && !strncmp( pszValue+2, W3_AUTH_CHANGE_URL, sizeof(W3_AUTH_CHANGE_URL)-1 ) )
    {
        QueryW3Instance()->LockThisForRead();
        fSt = strChgUrl.Copy( pszACU = (TCHAR*)QueryW3Instance()->QueryAuthChangeUrl() );
        QueryW3Instance()->UnlockThis();

        // store ptr to arg to append it to URL
        pszArg = strchr( pszValue, '?' );

        if ( pszACU )
        {
            if ( fSt && LogonAsSystem() )
            {
                pszValue = strChgUrl.QueryStr();
                _strUnmappedUserName.Copy( _strUserName );
            }
            else
            {
                return FALSE;
            }
        }
    }


    // Check for the asterisk URL. If it's an asterisk with trailing stuff
    // it's illegal.

    if (*pszValue == '*')
    {
        if (pszValue[1] != '\0')
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    if ( !_strRawURL.Copy( pszValue ) )
    {
        return FALSE;
    }
    if ( pszArg != NULL && !_strRawURL.Append( pszArg ) )
    {
        return FALSE;
    }

    pchStart = pszValue;

    //
    //  Check for a question mark which indicates this URL contains some
    //  parameters and break the two apart if found
    //

    if ( (pchParams = pszArg) || (pchParams = ::_tcschr( pchStart, TEXT('?') )) )
    {
        if ( !pszArg )
        {
            chParams = *pchParams;
            *pchParams = TEXT('\0');
        }

        _fAnyParams = TRUE;

        if ( !_strURL.Copy( pchStart ) ||
             !_strURL.Unescape()       ||
             !_strURLParams.Copy( pchParams + 1 ))
        {
            return FALSE;
        }
    }
    else
    {
        _fAnyParams = FALSE;

        if ( !_strURL.Copy( _strRawURL ) ||
             !_strURL.Unescape() )
        {
            return FALSE;
        }

        _strURLParams.Reset();
    }

    //
    //  Canonicalize the URL and make sure it's valid
    //

    INT cchURL = CanonURL( _strURL.QueryStr(), g_pInetSvc->IsSystemDBCS() );
    _strURL.SetLen( cchURL );

    if( !_strURLPathInfo.Copy( _strURL ) )
    {
        return FALSE;
    }

    if ( pchParams && !pszArg )
    {
        *pchParams = chParams;
    }

    //
    // Now that we have the canonicalized URL we need to get metadata
    // information about it. Call the cache to get this. If it's not
    // in the cache, we'll call the metadata API to get it and add
    // it to the cache.
    //
    if ( !TsCheckOutCachedBlob( QueryW3Instance()->GetTsvcCache(),
                                _strURL.QueryStr(),
                                _strURL.QueryCCH(),
                                RESERVED_DEMUX_URI_INFO,
                                (VOID **) &pURIBlob,
                                NULL ))
    {

        // We don't have URI info available for this yet. We need to read
        // the metadata for this URI and format it into a usable form, and
        // save that with the request. If this request turns out to be
        // valid later on we'll add it to the cache.
        //

        if ( !ReadMetaData( _strURL.QueryStr(),
                            &_strPhysicalPath,
                            &_pMetaData ) ) {
            return FALSE;
        }

    } else
    {
        // We have a cached URI blob. Save it in the HTTP request.

        _pURIInfo = pURIBlob;

        if ( _pURIInfo->pszUnmappedName )
        {
            _strPhysicalPath.Copy( _pURIInfo->pszUnmappedName );
        }
        else
        {
            _strPhysicalPath.Copy( _pURIInfo->pszName, _pURIInfo->cchName );
        }

        _pMetaData = _pURIInfo->pMetaData;
    }

    if ( _pMetaData->QueryVrError() )
    {
        SetLastError( _pMetaData->QueryVrError() );
        return FALSE;
    }

    if ( _pMetaData->QueryIpDnsAccessCheckPtr() )
    {
        QueryClientConn()->BindAccessCheckList( (LPBYTE)_pMetaData->QueryIpDnsAccessCheckPtr(),
                                                _pMetaData->QueryIpDnsAccessCheckSize() );
    }

    //
    // If we're already logged on as an anonymouse user, make sure that
    // the anonymous user for this URL is compatible.
    //

    if (_fLoggedOn && _fAnonymous)
    {
        if (_cbLastAnonAcctDesc != _pMetaData->QueryAuthentInfo()->cbAnonAcctDesc ||
            memcmp(_bufLastAnonAcctDesc.QueryPtr(),
                _pMetaData->QueryAuthentInfo()->bAnonAcctDesc.QueryPtr(),
                _cbLastAnonAcctDesc))
        {
            QueryW3StatsObj()->DecrCurrentAnonymousUsers();

            ResetAuth(FALSE);

        }
    }

    return TRUE;
}

BOOL
HTTP_REQUEST::ExecuteChildCGIBGI(
    IN CHAR *               pszURL,
    IN DWORD                dwChildExecFlags,
    IN CHAR *               pszVerb
)
/*++

Routine Description:

    Provides ISAPI apps with ability to synchronously execute
    CGI scripts.

Arguments:

    pszURL - URL of request to be executed (must be executable)
    dwChildExecFlags - HSE_EXEC_???? flags
    pszVerb - Verb of request

Return value:

    TRUE if no error, otherwise FALSE

--*/
{
    EXEC_DESCRIPTOR         Exec;
    STACK_STR(              strChildURL, MAX_PATH + 1 );
    STACK_STR(              strChildPhysicalPath, MAX_PATH + 1 );
    STACK_STR(              strChildGatewayImage, MAX_PATH + 1 );
    STACK_STR(              strChildPathInfo, MAX_PATH + 1 );
    STACK_STR(              strChildURLParams, MAX_PATH + 1 );
    STACK_STR(              strChildUnmappedPhysicalPath, MAX_PATH + 1 );
    DWORD                   dwChildScriptMapFlags = 0;
    GATEWAY_TYPE            ChildGatewayType = GATEWAY_UNKNOWN;
    BOOL                    fHandled;
    BOOL                    fFinished;
    CHAR *                  pchParams = NULL;
    MB                      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    BOOL                    fRet;
    PW3_URI_INFO            pURIInfo = NULL;
    BOOL                    fMustCache = FALSE;
    BOOL                    fVerbExcluded;
    enum HTTP_VERB          RequestVerb;
    enum HTTP_VERB          OldVerb;
    CHAR *                  pszRequestVerb;
    STACK_STR(              strOldVerb, 16 );

    if ( _dwCallLevel > EXEC_MAX_NESTED_LEVELS )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    // Populate the execution descriptor block with our own "allocated"
    // members (instead of those from HTTP_REQUEST)
    //

    Exec._pstrURL = &strChildURL;
    Exec._pstrPhysicalPath = &strChildPhysicalPath;
    Exec._pstrUnmappedPhysicalPath = &strChildUnmappedPhysicalPath;
    Exec._pstrGatewayImage = &strChildGatewayImage;
    Exec._pstrPathInfo = &strChildPathInfo;
    Exec._pstrURLParams = &strChildURLParams;
    Exec._pdwScriptMapFlags = &dwChildScriptMapFlags;
    Exec._pGatewayType = &ChildGatewayType;
    Exec._pRequest = this;
    Exec._pPathInfoMetaData = NULL;
    Exec._pPathInfoURIBlob = NULL;
    Exec._pAppPathURIBlob = NULL;

    Exec._dwExecFlags = ( EXEC_FLAG_CHILD |
                          ( dwChildExecFlags &
                            ( HSE_EXEC_NO_HEADERS |
                              HSE_EXEC_REDIRECT_ONLY |
                              HSE_EXEC_NO_ISA_WILDCARDS | 
                              HSE_EXEC_CUSTOM_ERROR ) ) );


    if ( !strChildURL.Copy( pszURL ) )
    {
        return FALSE;
    }

    //
    //  Tiny bit of "duplicate" code to parse out a query string from the
    //  original URL request.
    //

    pchParams = ::_tcschr( strChildURL.QueryStr(), TEXT('?') );
    if ( pchParams != NULL )
    {
        if ( !strChildURL.SetLen( DIFF(pchParams - strChildURL.QueryStr()) ) ||
             !strChildURLParams.Copy( pchParams + 1 ) )
        {
            return FALSE;
        }
    }

    if ( !strChildURL.Unescape() )
    {
        return FALSE;
    }

    //
    //  Canonicalize the URL and make sure it's valid
    //

    CanonURL( strChildURL.QueryStr(), g_pInetSvc->IsSystemDBCS() );
    strChildURL.SetLen( strlen( strChildURL.QueryStr() ));

    if ( !LookupVirtualRoot( &strChildPhysicalPath,
                             strChildURL.QueryStr(),
                             strChildURL.QueryCCH(),
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             FALSE,
                             &(Exec._pMetaData),
                             & pURIInfo) )
    {
        fRet = FALSE;
        goto Exit;
    }

    //
    // Change the verb if requested
    //
    
    if ( pszVerb )
    {
        DWORD                   i = 0;
        DWORD                   cchVerb = strlen( pszVerb );
       
        while ( DoVerb[i].pchVerb )
        {
            if ( ( cchVerb == DoVerb[ i ].cchVerb ) && 
                 ( !memcmp( pszVerb, 
                            DoVerb[ i ].pchVerb, 
                            DoVerb[ i ].cchVerb ) ) )
            {
                break;
            }
            i++;
        }
        
        if ( !DoVerb[i].pchVerb )
        {
            fRet = FALSE;
            SetLastError( ERROR_INVALID_PARAMETER );
            goto Exit;
        }
        
        RequestVerb = DoVerb[ i ].httpVerb;
        pszRequestVerb = pszVerb;
    }
    else
    {
        RequestVerb = QueryVerb();
        pszRequestVerb = _strMethod.QueryStr();
    }
    
    //
    // Fill in members of execution descriptor block
    //

    if ( !ParseExecute( &Exec, 
                        TRUE, 
                        &fVerbExcluded, 
                        pURIInfo,
                        RequestVerb,
                        pszRequestVerb
                         ) )
    {
        fRet = FALSE;
        goto Exit;
    }

    DBG_ASSERT(!(dwChildScriptMapFlags & MD_SCRIPTMAPFLAG_WILDCARD));
    
    if (ChildGatewayType != GATEWAY_UNKNOWN && ChildGatewayType != GATEWAY_NONE &&
            fVerbExcluded)
    {
        ChildGatewayType = GATEWAY_NONE;
    }
    
    _dwCallLevel++;

    //
    // Remember the original verb to be restored after handling execute
    //

    if ( pszVerb )
    {
        OldVerb = QueryVerb();

        if ( !strOldVerb.Copy( _strMethod ) )
        {
            fRet = FALSE;
            goto Exit;
        }
        
        if ( !_strMethod.Copy( pszVerb ) )
        {
            fRet = FALSE;
            goto Exit;
        }
       
        _verb = RequestVerb;
    }

    if ( ChildGatewayType == GATEWAY_CGI )
    {
        fRet = ProcessGateway( &Exec,
                               &fHandled,
                               &fFinished,
                               dwChildScriptMapFlags &
                                  MD_SCRIPTMAPFLAG_SCRIPT );
    }
    else if ( ChildGatewayType == GATEWAY_BGI )
    {
        if ( fRet = Exec.CreateChildEvent() ) {

            Exec._pParentWamRequest = _pWamRequest;

            // process ISAPI request under System
            RevertUser();

            fRet =  ProcessBGI( &Exec,
                                &fHandled,
                                &fFinished,
                                dwChildScriptMapFlags &
                                       MD_SCRIPTMAPFLAG_SCRIPT );

            // restore impersonation
            DBG_REQUIRE( ImpersonateUser() );

            Exec.WaitForChildEvent();

        } else {

            DBGPRINTF((
                DBG_CONTEXT
                , "HTTP_REQUEST(%08x)::ExecuteChildCGIBGI() "
                  "CreateChildEvent() failed. "
                  "\n"
                , this
            ));

            //
            //  fRet is failure, so just fall through
            //

        }

    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fRet = FALSE;
    }

    _dwCallLevel--;

    //
    // Restore the verb if necessary
    //

    if ( pszVerb )
    {
        _verb = OldVerb;
        DBG_REQUIRE( _strMethod.Copy( strOldVerb ) );
    }

Exit:

    if ( pURIInfo != NULL)
    {
        if (pURIInfo->bIsCached)
        {
            TsCheckInCachedBlob( pURIInfo );
        }
        else
        {
            TsFree(QueryW3Instance()->GetTsvcCache(), pURIInfo );
        }
        pURIInfo = NULL;
    }
    else
    {
        if ( Exec._pMetaData != NULL)
        {
            TsFreeMetaData( Exec._pMetaData->QueryCacheInfo() );
        }
    }
    Exec.Reset();

    return fRet;
}

BOOL
HTTP_REQUEST::ExecuteChildCommand(
    IN CHAR *               pszCommand,
    IN DWORD                dwChildExecFlags
)
/*++

Routine Description:

    Provides ISAPI apps with ability to synchronously execute a shell command
    (useful for SSI functionality #exec cmd=)

Arguments:

    pszCommand - Command to be executed
    dwChildExecFlags - HSE_EXEC_???? flags

Return value:

    TRUE if no error, otherwise FALSE

--*/
{
    STACK_STR(          strCommand, MAX_PATH );
    BOOL                fHandled;
    DWORD               dwOldFlags = _Exec._dwExecFlags;
    BOOL                fRet;

    if ( !strCommand.Copy( pszCommand ) )
    {
        return FALSE;
    }

    //
    // Since there is no URL associated with a shell command, there is no
    // metadata.  Just use the HTTP_REQUEST Exec block.  But first set its
    // execFlags correctly
    //

    _Exec._dwExecFlags |= ( EXEC_FLAG_CHILD |
                            ( dwChildExecFlags &
                              ( HSE_EXEC_NO_HEADERS |
                                HSE_EXEC_REDIRECT_ONLY ) ) );

    fRet = ProcessCGI( &_Exec,
                       NULL,
                       NULL,
                       &fHandled,
                       NULL,
                       &strCommand );

    //
    // Restore original _Exec flags
    //

    _Exec._dwExecFlags = dwOldFlags;

    return fRet;
}



BOOL
HTTP_REQUEST::ParseExecute(
    IN OUT EXEC_DESCRIPTOR *        pExec,
    IN     BOOL                     fExecChildCGIBGI,
    OUT    BOOL *                   pfVerbExcluded,
    IN PW3_URI_INFO                 pURIInfo,
    IN enum HTTP_VERB               Verb,
    IN CHAR *                       pszVerb
)
/*++

Routine Description:

    Parse the request now that we know it is an execute.

Arguments:

    pExec - Execution Descriptor Block
    fExecChildCGIBGI - TRUE if this is a #exec request for a
                       CGI or ISAPI from inside an .stm page
                       or other isapi app. FALSE in the normal
                       case of a top level request to execute
                       a gateway of some sort.
    pfVerbExcluded - Is the verb excluded, regardless of extension match
    pURIInfo - URI Blob for this 'request'
    Verb - Verb (enum form) of request
    pszVerb - Verb (string form)

Returns:

    TRUE on success, FALSE on failure

--*/
{
    TCHAR *             pchStart = pExec->_pstrURL->QueryStr();
    TCHAR *             pchtmp = pchStart;
    TCHAR *             pchSlash = NULL;
    INT                 cchToEnd = 0;
    DWORD               cchExt = 0;
    GATEWAY_TYPE        GatewayType = GATEWAY_UNKNOWN;
    BOOL                fImageInURL = FALSE;
    TCHAR *             pch = NULL;
    PVOID               pvExtMapInfo;
    BOOL                fUseURIInfo = pURIInfo && pURIInfo->pvExtMapInfo;
    DWORD               cDots = 0;

    *pfVerbExcluded = FALSE;
    BOOL ExitedHere = FALSE;

    while ( *pchtmp )
    {
        pvExtMapInfo = NULL;
        
        pchtmp = strchr( pchtmp + 1, '.' );
        
        //
        //  Is this file extension mapped to a script?  _GatewayType is
        //  set to unknown if a mapping isn't found
        //

        if ( !pExec->_pMetaData->LookupExtMap( pchtmp,
                                               pExec->NoIsaWildcards(),
                                               pExec->_pstrGatewayImage,
                                               pExec->_pGatewayType,
                                               &cchExt,
                                               &fImageInURL,
                                               pfVerbExcluded,
                                               pExec->_pdwScriptMapFlags,
                                               pszVerb,
                                               Verb,
                                               fUseURIInfo ?
                                                 &(pURIInfo->pvExtMapInfo) :
                                                 &pvExtMapInfo
                                               ))
        {
            return FALSE;
        }
        
        GatewayType = *(pExec->_pGatewayType);

        if ( pchtmp == NULL )
        {
            break;
        }
        
        cDots++;

        if ( GatewayType != GATEWAY_UNKNOWN )
        {
                         
            if ( GatewayType == GATEWAY_NONE )
            {
                _fAnyParams = FALSE;
                return TRUE;
            }

            //
            //  If this is a regular CGI script, check for an "nph-"
            //

            if ( GatewayType == GATEWAY_CGI )
            {
                //
                //  Walk backwards till we find the '/' that begins
                //  this segment
                //

                pch = pchtmp;

                while ( pch >= pchStart && *pch != '/' )
                {
                    pch--;
                }

                if ( !_strnicmp( (*pch == '/' ? pch+1 : pch),
                                "nph-",
                                4 ))
                {
                    pExec->_dwExecFlags |= EXEC_FLAG_CGI_NPH;
                }
            }

            cchToEnd = DIFF(pchtmp - pchStart) + cchExt;
            break;
        }
        else if ( fUseURIInfo )
        {
            ExitedHere = TRUE;
            break;
        }
    }
    
    // WinNT 379450

    if (!ExitedHere) // with URIInfo the extension map is got from cache
    {
        if (pchtmp)
        {

            TCHAR *pNextDot   = strchr(pchtmp+1,'.');

            if (pNextDot && (pchtmp != pNextDot)) // two dot, bad we have to check
            {
                TCHAR *             pchStart2 = pExec->_pstrURL->QueryStr();
                DWORD dwLenURL  = lstrlen((TCHAR *)pchStart2);
                TCHAR * pCopyUrl  = (TCHAR *)LocalAlloc(LPTR,dwLenURL+1);

                if (!pCopyUrl)
                {
                    return FALSE;
                };

                lstrcpy(pCopyUrl,pchStart2);

                // terminate string
                pCopyUrl[DIFF(pchtmp - pchStart2)+cchExt] = 0;
            
                STACK_STR( StrPhys , MAX_PATH );

                // we are not going to enlarge string
                if ( !pExec->_pMetaData->BuildPhysicalPath( pCopyUrl,  //shortened via '/' -> '\0'
                                                            &StrPhys) )
                {
                    // free memory and fail
                    LocalFree(pCopyUrl);
                    *(pExec->_pGatewayType) = GATEWAY_MALFORMED;
                    return TRUE;
                };
        
                DWORD dwAttributes = 0xffffffff;
                TSVC_CACHE bogus;

                TS_OPEN_FILE_INFO* pOpenFile = TsCreateFile(bogus, 
                                                            StrPhys.QueryStr(),
                                                            0, 
                                                            TS_CACHING_DESIRED );

                if (pOpenFile != NULL)
                {
                    dwAttributes = pOpenFile->QueryAttributes();
                    TsCloseHandle(bogus, pOpenFile);
                };
            
                if  ( dwAttributes != 0xffffffff ) 
                {
                    if ( dwAttributes & FILE_ATTRIBUTE_DIRECTORY )                   
                    {
                        LocalFree(pCopyUrl);
                        *(pExec->_pGatewayType) = GATEWAY_MALFORMED ;
                        return TRUE;
                    }
                };

                LocalFree(pCopyUrl);
        
            }
        }

    }
    
    //-----------------------------------------------
    
    //
    // We should update the URI blob with the matched EXT_MAP_ITEM if
    //
    // a) We have a URIInfo to update
    // b) LookupExtMap() found a matching EXT_MAP_ITEM (or EXTMAP_UNKNOWN_PTR)
    // c) We didn't previously have a value for pvExtMapInfo
    // d) If the match occurred on the first dot encountered OR if this
    //    is a static file (and thus an EXTMAP_UNKNOWN_PTR)
    //
    
    if ( !fUseURIInfo &&
         pURIInfo &&
         pvExtMapInfo &&
         ( ( cDots == 1 ) || ( pvExtMapInfo == EXTMAP_UNKNOWN_PTR ) ) )
    {
        InterlockedExchangePointer( &(pURIInfo->pvExtMapInfo), pvExtMapInfo );
    }

    if ( GatewayType & GT_CGI_BGI )
    {

        //
        // If this is a top level request for an executable (not
        // #exec-ing from inside of an .stm or other isapi),
        // and the image was found in the URL, but the vroot
        // doesn't have execute permission set, then this isn't
        // really a gateway and the client is trying to download
        // the file, so let him.
        //

        if (!fExecChildCGIBGI && fImageInURL && !(GetFilePerms() & VROOT_MASK_EXECUTE))
        {
            *(pExec->_pGatewayType) = GATEWAY_NONE;
            _fAnyParams = FALSE;
            return TRUE;
        }

        if (*(pExec->_pdwScriptMapFlags) & MD_SCRIPTMAPFLAG_WILDCARD)
        {
            cchToEnd = pExec->_pstrURL->QueryCB();
        }

        //
        //  Save the path info and remove it from the URL.  If this is a
        //  script by association and there isn't any path info, then
        //  copy the base URL as the path info (reflects what the URL
        //  would like without an association (i.e., "/foo/bar.idc?a=b"
        //  is really "/scripts/httpodbc.dll/foo/bar.idc?a=b"))
        //
        //  If the binary image is actually in the URL, then always copy
        //  the path info.
        //

        if ( !pExec->_pstrPathInfo->Copy( ( fImageInURL ||
                                          (*(pchStart + cchToEnd) &&
                                           QueryW3Instance()->QueryAllowPathInfoForScriptMappings() ))
                                            ?
                                            pchStart + cchToEnd :
                                            pchStart ) )
        {
            return FALSE;
        }

        if ( pExec->_pstrURL->QueryCCH() != (UINT)cchToEnd )
        {
            pExec->_pstrURL->SetLen( cchToEnd );
            if ( !pExec->_pMetaData->BuildPhysicalPath( pExec->_pstrURL->QueryStr(),
                                                        pExec->_pstrPhysicalPath ) )
            {
                return FALSE;
            }
            pExec->_pstrUnmappedPhysicalPath->Reset();
        }

        IF_DEBUG( PARSING )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[OnURL] Possible script \"%s\" with path info \"%s\", parms \"%s\"\n",
                        pExec->_pstrURL->QueryStr(),
                        pExec->_pstrPathInfo->QueryStr(),
                        pExec->_pstrURLParams->QueryStr()));
        }

    }
    else if ( ( QueryDirBrowseFlags() & DIRBROW_LOADDEFAULT ) &&
              ( GetFilePerms() & VROOT_MASK_EXECUTE ) &&
              ( ( QueryVerb() == HTV_GET ) || ( QueryVerb() == HTV_HEAD ) ) )
    {
        //
        // The vroot is EXECUTE but it isn't a CGI or BGI.
        // This could be a directory for which we will later
        // load a default document
        //
        
#if 0
        DWORD dwAttributes = GetFileAttributes( _strPhysicalPath.QueryStr() );
#else
        DWORD dwAttributes = 0xffffffff;
        TSVC_CACHE bogus;
        TS_OPEN_FILE_INFO* pOpenFile =
            TsCreateFile(bogus, _strPhysicalPath.QueryStr(),
                         0, TS_CACHING_DESIRED | TS_NO_ACCESS_CHECK );

        if (pOpenFile != NULL)
        {
            dwAttributes = pOpenFile->QueryAttributes();
            TsCloseHandle(bogus, pOpenFile);
        }
#endif

        if ( ( dwAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
             ( dwAttributes != 0xffffffff ) )
        {
            _fPossibleDefaultExecute = TRUE;
        }
    }

    return TRUE;
}


VOID
HTTP_REQUEST::SetupDAVExecute(
    EXEC_DESCRIPTOR *pExec,
    CHAR *szDavDll
    )
/*++

Routine Description:

    Setups up the exec descriptor to call DAV to process the request.  Assumes
    it has already been setup for a call to ProcessExecute().

Arguments:

    pExec - Pointer to the exec descriptor

Returns

    TRUE on success, FALSE on failure

--*/
{
    if (pExec->_pstrGatewayImage->Copy(szDavDll) &&
        pExec->_pstrPathInfo->Copy(pExec->_pstrURL->QueryStr()))
    {
        *pExec->_pGatewayType = GATEWAY_BGI;
        pExec->_dwExecFlags |= EXEC_FLAG_RUNNING_DAV;
    }
}


BOOL
HTTP_REQUEST::ProcessURL(
    BOOL * pfFinished,
    BOOL * pfHandled
    )
/*++

Routine Description:

    Finally converts the URL to a physical path, checking for extension mappings

Arguments:

    pfFinished - Set to TRUE if no further processing is needed and no IOs
                 are pending
    pfHandled - If !NULL, set to TRUE if request is handled

Returns:

    TRUE on success, FALSE on failure

--*/
{
    TCHAR               chParams;
    BOOL                fVerbExcluded;
    BOOL                fRet;

    //
    //  First check if a redirect is in order.  If so, just do it.
    //

    if ( _pMetaData->QueryRedirectionBlob() != NULL )
    {
        BOOL                fDone = FALSE;
        HTR_STATE           OldState = QueryState();

        SetState( HTR_REDIRECT );
        
        if ( !ReadEntityBody( &fDone, TRUE, QueryClientContentLength() ) )
        {
            return FALSE;
        }

        if ( fDone )
        {
            SetState( OldState );
            if ( DoRedirect( pfFinished ) )
            {
                if ( pfHandled ) 
                {
                    *pfHandled = TRUE;
                }
                return TRUE;
            }
        }
        else
        {
            if ( pfHandled ) 
            {
                *pfHandled = TRUE;
            }
            return TRUE;
        }
    }

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_URL_MAP,
                                       IsSecurePort() ))
    {
        DWORD   dwDenied = SF_DENIED_RESOURCE;
        BOOL    fTmp = FALSE;

        _strUnmappedPhysicalPath.Copy( _strPhysicalPath );

        if ( !_strPhysicalPath.Resize( MAX_PATH+sizeof(TCHAR) ))
        {
            return FALSE;
        }

        //
        //  If the caller is going to ignore the Finished request flag, supply
        //  a value ourselves
        //

        if ( !pfFinished )
        {
            pfFinished = &fTmp;
        }

        fRet = _Filter.NotifyUrlMap( _strURL.QueryStr(),
                                     _strPhysicalPath.QueryStr(),
                                     _strPhysicalPath.QuerySize(),
                                     pfFinished );
        if ( !fRet )
        {
            dwDenied |= SF_DENIED_FILTER;
            if ( GetLastError() == ERROR_ACCESS_DENIED )
            {
                SetDeniedFlags( dwDenied );
            }
        }
        _strPhysicalPath.SetLen( strlen(_strPhysicalPath.QueryStr()) );

        //
        //  If the filters didn't change the physical path, zero out the unmapped
        //  path we saved before the filter call - this will save us work later
        //  

        if ( _strPhysicalPath.QueryCCH() == _strUnmappedPhysicalPath.QueryCCH() &&
            !memcmp( _strPhysicalPath.QueryStr(), 
                       _strUnmappedPhysicalPath.QueryStr(), 
                       _strPhysicalPath.QueryCCH() ))
        {
            _strUnmappedPhysicalPath.Reset();
        }

        //
        // If the new mapped physical path does not match what we have in the URI
        // cache entry we need to delete this entry.
        //

        if ( _pURIInfo && strcmp( _pURIInfo->pszName, _strPhysicalPath.QueryStr() ) )
        {
            //
            // We keep a reference to metadata in the HTTP_REQUEST object, so
            // we increment the reference count to metadata, as freeing the URI
            // cache entry will decrement the reference count.
            //

            DBG_ASSERT( _pURIInfo->pMetaData != NULL );

            TsAddRefMetaData( _pURIInfo->pMetaData->QueryCacheInfo() );

            if ( _pURIInfo->bIsCached )
            {
                //
                // This will dereference the URI cache entry and
                // kick it out of the cache.
                //

                TsDeCacheCachedBlob( (PVOID)_pURIInfo );

//                TsCheckInCachedBlob( _pURIInfo );
            }
            else
            {
                TsFree(QueryW3Instance()->GetTsvcCache(), _pURIInfo );
            }

            _pURIInfo = NULL;
        }
    }

    if ( *pfFinished )
    {
        return TRUE;
    }

#if 0       // This block does nothing in effect.  If execute permissions are
            // set, then the first 'if' is false.  If they are not set, then the
            // script map code below it will not execute, resulting in a return
            // of TRUE anyway.  /SAB
    //
    //  If the read bit is set, the execute bit is not set, we recognize the
    //  verb, there are no parameters and no ext is allowed on read dir,
    //  then don't bother looking at the execute mask
    //

    if ( (_verb != HTV_UNKNOWN) &&
         !(GetFilePerms() & VROOT_MASK_EXECUTE ) &&
         !_fAnyParams  &&
         !fCheckExt )
    {
        if (_verb == HTV_GET && (GetFilePerms() & VROOT_MASK_READ) ) {
            return TRUE;
        }

        if (IS_WRITE_VERB(_verb) && (GetFilePerms() & VROOT_MASK_WRITE) ) {
            return TRUE;
        }
    }

#endif // 0
    //
    //  If this is on a virtual root with execute permissions ||
    //  this might be an ismap request || should be handled by DAV
    //  {
    //      Check for a possible .exe, .com, or .dll gateway (CGI or BGI)
    //      If none, send to DAV if required.
    //  }
    //
    DBG_ASSERT(_GatewayType == GATEWAY_UNKNOWN);

    // Populate an EXECUTION descriptor block and check the scriptmap.
    _Exec._pstrURL = &_strURL;
    _Exec._pstrPhysicalPath = &_strPhysicalPath;
    _Exec._pstrUnmappedPhysicalPath = &_strUnmappedPhysicalPath;
    _Exec._pstrGatewayImage = &_strGatewayImage;
    _Exec._pstrPathInfo = &_strPathInfo;
    _Exec._pstrURLParams = &_strURLParams;
    _Exec._pdwScriptMapFlags = &_dwScriptMapFlags;
    _Exec._pGatewayType = &_GatewayType;
    _Exec._pMetaData = _pMetaData;
    _Exec._pRequest = this;
    _Exec._pPathInfoMetaData = NULL;
    _Exec._pPathInfoURIBlob = NULL;
    _Exec._pAppPathURIBlob = NULL;
    
    if ( _bProcessingCustomError )
    {
        _Exec._dwExecFlags |= EXEC_FLAG_CUSTOM_ERROR;
    }
    
    //
    // If we know this is a static file, then we don't have to go thru
    // ParseExecute()
    //
    
    /*
    
    // This optimization causes a regression for directories that use
    // asp/isapi as the default page when only execute/script access
    // is set. It should be fairly simple to reimplement, but given the
    // lateness in the release cycle I'm removing it as a safer fix.
    // Bug 379306 - taylorw

    if ( !_pURIInfo || 
         _pURIInfo->pvExtMapInfo != EXTMAP_UNKNOWN_PTR )
    {
    */
        if (!ParseExecute(&_Exec, 
                          FALSE, 
                          &fVerbExcluded, 
                          _pURIInfo,
                          QueryVerb(),
                          _strMethod.QueryStr()
                           ))
        {
            return FALSE;
        }
    /*
    }
    */

    // Did we find a scriptmap entry at all?
    if (_GatewayType != GATEWAY_UNKNOWN &&
            _GatewayType != GATEWAY_NONE &&
            _GatewayType != GATEWAY_MAP)
    {
        // Is it a wildcard?
        if (_dwScriptMapFlags & MD_SCRIPTMAPFLAG_WILDCARD ||

            // or is it a regular scriptmap entry and we allow these?
            !_fDisableScriptmap &&
            !fVerbExcluded &&
            (
                (_dwScriptMapFlags & MD_SCRIPTMAPFLAG_SCRIPT) && IS_ACCESS_ALLOWED(SCRIPT) ||
                IS_ACCESS_ALLOWED(EXECUTE)
            )
            )
        {
            // Call this scriptmap.
            DBG_ASSERT(!fVerbExcluded); // Should not return this.
            return TRUE;
        }

        //
        // If DAV isn't going to handle it, this script doesn't have execute permissions
        //
        if ( !_fSendToDav )
        {
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
            Disconnect( HT_FORBIDDEN, IDS_EXECUTE_ACCESS_DENIED, FALSE, pfFinished );
            if ( pfHandled )
            {
                *pfHandled = TRUE;
            }
            return TRUE;
        }
        else
        {
            _GatewayType = GATEWAY_NONE;
        }
    }

    // If no script map is assigned, and if this is not a verb that IIS should
    // handle, setup for execution by the DAV .dll.
    if (_fSendToDav)
    {
        W3_IIS_SERVICE * pservice = (W3_IIS_SERVICE *) QueryW3Instance()->m_Service;

        if (pservice->FDavDll())
            SetupDAVExecute(&_Exec, pservice->SzDavDllGet());
    }
    
    return TRUE;
}

/*******************************************************************

    NAME:       HTTP_REQUEST::OnVersion

    SYNOPSIS:   Parses the version from an HTTP request

    ENTRY:      pszValue - Pointer to zero terminated string


    RETURNS:    TRUE if successful, FALSE if an error occurred

    HISTORY:
        Johnl       24-Aug-1994 Created
        MuraliK     29-Jan-1996 Optimized for 1.1
********************************************************************/

BOOL HTTP_REQUEST::OnVersion( CHAR * pszValue )
{
    //
    //  Did the client specify a version string?  If not, assume 0.9
    //

    if ( strncmp( "HTTP/", pszValue, 5 ) == 0 )
    {
        //
        //  Move past "HTTP/"
        //

        // Optimize for Version 1.x in this release - 1/15/97 - MuraliK
        if ((pszValue[5] == '1') && (pszValue[6] == '.')) {

            _VersionMajor = 1;
            pszValue += 6;
        } else {
            _VersionMajor = (BYTE ) atol( pszValue + 5);
            pszValue = strchr( pszValue + 5, '.' );
        }

        if ( pszValue != NULL )
        {
            DBG_ASSERT( pszValue[0] == '.');
            if ((pszValue[1] == '1') && (pszValue[2] == '\0')) {

                if ( g_ReplyWith11 ) {
                    _VersionMinor = 1;
                }
                else {
                    _VersionMinor = 0;
                }
            } else if ((pszValue[1] == '0') && (pszValue[2] == '\0') ) {
                _VersionMinor = 0;
            } else {
                _VersionMinor = (BYTE ) atol( pszValue + 1);
            }
        }

        //
        // If this is an HTTP 1.1 request, make KeepConn the default.
        //

        if ( (_VersionMinor == 1) && (_VersionMajor == 1) ) {
          SetKeepConn( TRUE );
        }
    }
    else
    {
        // Make sure this really is .9, and not garbage.
        if (*pszValue == '\0')
        {
            _VersionMajor = 0;
            _VersionMinor = 9;
        }
        else
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    return TRUE;
} // HTTP_REQUEST::OnVersion()


/*******************************************************************

    NAME:       HTTP_REQUEST::OnAccept

    SYNOPSIS:   Adds the MIME type to our accept list

    ENTRY:      CHAR * pszValue


    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:      Accept fields can look like:

                Accept: text/html
                Accept: image/gif; audio/wav
                Accept: image/jpeg, q=.8, mxb=10000, mxt=5.0; image/gif

                q - Quality (between zero and one)
                mxb - Maximum bytes acceptable
                mxs - Maximum seconds acceptable

                We currently ignore the parameters

    HISTORY:
        Johnl       21-Sep-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::OnAccept( CHAR * pszValue )
{
    //
    //  Keep an eye out for "*/*".  If it's sent then we
    //  don't have to search the list for acceptable client
    //  types later on.  Note it won't catch the case if the "*" occurs
    //  after the first item in the list.
    //

    if ( *pszValue == '*'
            || strstr( pszValue, TEXT("*/*") ) )
    {
        _fAcceptsAll = TRUE;
    }

    return TRUE;
}

/*******************************************************************

    NAME:       HTTP_REQUEST::DoesClientAccept

    SYNOPSIS:   Searches the client accept list for the specified
                MIME type

    ENTRY:      str - MIME type to search for

    RETURNS:    TRUE if found, FALSE if not found

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::DoesClientAccept( PCSTR pstr )
{
    TCHAR        * pchSlash;
    TCHAR        * pchType;
    INT            cchToSlash;

    //
    //  If the client indicated "*/*" in their accept list, then
    //  we don't need to check
    //

    if ( IsAcceptAllSet() )
        return TRUE;

    LPSTR          pszAcc = (LPSTR ) _HeaderList.FastMapQueryStrValue(HM_ACC);

    //
    //  If no accept headers were passed, then assume client
    //  accepts "text/plain" and "text/html"
    //

    if ( *pszAcc == '\0' )
    {
        //
        //  Accept everything if no header was sent.
        //

        return TRUE;
    }

    //
    //  Find out where the slash is so we can do a prefix compare
    //

    pchSlash = _tcschr( pstr, TEXT('/') );

    if ( !pchSlash )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[DoesClientAccept] Bad accept type - \"%s\"",
                   pstr ));
        return FALSE;
    }

    cchToSlash = DIFF(pchSlash - pstr);

    //
    //  Scan through the list for entries that match up to the slash
    //

    INET_PARSER    Parser( pszAcc );
    Parser.SetListMode( TRUE );

    pchType = Parser.QueryToken();

    while ( *pchType )
    {
        if ( !::_tcscmp( TEXT("*/*"), pchType ) ||
             !::_tcscmp( TEXT("*"),   pchType ))
        {
            return TRUE;
        }

        if ( !_tcsnicmp( pstr,
                         pchType,
                         cchToSlash ))
        {
            //
            //  We matched to the slash.  Is the second part a '*'
            //  or a real match?
            //

            if ( *(pchType + cchToSlash + 1) == TEXT('*') ||
                 !_tcsicmp( pstr + cchToSlash + 1,
                            pchType + cchToSlash + 1 ))
            {
                return TRUE;
            }
        }

        pchType = Parser.NextItem();
    }

    IF_DEBUG( PARSING )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[DoesClientAccept] Client doesn't accept %s\n",
                   pstr ));
    }

    return FALSE;
}

/*******************************************************************

    NAME:       HTTP_REQUEST::OnContentType

    SYNOPSIS:   Saves the content type

    ENTRY:      pszValue - Pointer to zero terminated string

    RETURNS:    TRUE if successful, FALSE on error

    NOTES:      Client's will generally specify this only for gateway data

    HISTORY:
        Johnl       10-Oct-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::OnContentType( CHAR * pszValue )
{
    return _strContentType.Copy( pszValue );
}

BOOL
HTTP_REQUEST::OnConnection(
    CHAR * pszValue
    )
/*++

Routine Description:

    Looks to see if this connection is a keep-alive connection

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{

    //
    // Length should be greater than 9
    //

    if ( (*pszValue == 'K') || (*pszValue == 'k') ) {

        if ( _stricmp( pszValue+1, "eep-Alive") == 0 ) {
            SetKeepConn( TRUE );
            return(TRUE);
        }
    }
    else if ( (*pszValue == 'C') || (*pszValue == 'c') ) {
        if ( _stricmp( pszValue+1, "lose") == 0 ) {
            SetKeepConn( FALSE );
            return TRUE;
        }
    }

    //
    // Do it the long way
    //

    {

        INET_PARSER Parser( pszValue );

        Parser.SetListMode( TRUE );

        while ( *Parser.QueryToken() )
        {
            if ( !_stricmp( "Keep-Alive", Parser.QueryToken() ))
            {
                SetKeepConn( TRUE );
            }
            else
            {
                if ( !_stricmp( "Close", Parser.QueryToken() ))
                {
                    SetKeepConn( FALSE );
                }
            }
            Parser.NextItem();
        }
    }
    return TRUE;
}

BOOL
HTTP_REQUEST::OnTransferEncoding(
    CHAR * pszValue
    )
/*++

Routine Description:

    Handles the Transfer-Encoding header.

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    INET_PARSER Parser( pszValue );

    Parser.SetListMode( TRUE );

    while ( *Parser.QueryToken() )
    {
        if ( !_stricmp( "Chunked", Parser.QueryToken() ))
        {
            SetChunked( );
            _ChunkState = READ_CHUNK_SIZE;
            _dwChunkSize = -1;
            _cbChunkHeader = 0;
            _cbChunkBytesRead = 0;
            _cbContentLength = 0xffffffff;
            _fHaveContentLength = TRUE;
            return TRUE;
        }

        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;

    }

    return TRUE;

}


BOOL
HTTP_REQUEST::OnLockToken(
    CHAR * pszValue
    )
/*++

Routine Description:

    Handles the LockToken header.

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    _fSendToDav = TRUE;     // Send all requests with lock tokens to DAV
    return TRUE;
}



BOOL
HTTP_REQUEST::OnTranslate(
    CHAR * pszValue
    )
/*++

Routine Description:

    Handles the Translate header.

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    if (*pszValue == 'F' || *pszValue == 'f')
        {
        _fSendToDav = TRUE;
        _fDisableScriptmap = TRUE;
        }
    return TRUE;
}



BOOL
HTTP_REQUEST::OnIf(
    CHAR * pszValue
    )
/*++

Routine Description:

    Handles the LockToken header.

Arguments:

    pszValue - Pointer to zero terminated string

--*/
{
    _fSendToDav = TRUE;     // Send all requests with lock tokens to DAV
    return TRUE;
}



BOOL
HTTP_REQUEST::CacheUri(
    PW3_SERVER_INSTANCE         pInstance,
    PW3_URI_INFO*               ppURIInfo,
    PW3_METADATA                pMetaData,
    LPCSTR                      pszURL,
    ULONG                       cchURL,
    STR*                        pstrPhysicalPath,
    STR*                        pstrUnmappedPhysicalPath
    )
/*++

Routine Description:

    Cache a URI info structure

Arguments:

    pInstance - instance for this request
    ppURIInfo - updated with ptr to URI info if success
    pMetaData - metadata to associate with URI info
    pszURL - URL for which to cache URI info
    pstrPhysicalPath - physical path associated with pszURL
    pstrUnmappedPhysicalPath - unmapped physical path ( before calling filters )
        associated with pszURL. Can be empty if filter not called.

--*/
{
    DWORD           dwStringSize;
    PW3_URI_INFO    pURIInfo;

    // The URI information is NULL. Create a new URI blob, and try to open
    // the file.

    if (!TsAllocateEx(pInstance->GetTsvcCache(),
                     sizeof(W3_URI_INFO),
                     (PVOID *)&pURIInfo,
                     DisposeOpenURIFileInfo))
    {
        // Not enough memory to create the needed strucure, so fail the
        // request.

        return FALSE;
    }

#if 0
    pURIInfo->hFileEvent = IIS_CREATE_EVENT(
                               "W3_URI_INFO::hFileEvent",
                               pURIInfo,
                               TRUE,
                               FALSE
                               );

    if ( pURIInfo->hFileEvent == NULL ) {
        TsFree( pInstance->GetTsvcCache(), pURIInfo );
        return FALSE;
    }
#endif //!oplock

//    pURIInfo->bFileInfoValid = FALSE;
    pURIInfo->dwFileOpenError = ERROR_FILE_NOT_FOUND;
    pURIInfo->pOpenFileInfo = NULL;
    pURIInfo->bIsCached = TRUE;
    pURIInfo->pMetaData = pMetaData;
    pURIInfo->bInProcOnly = FALSE;
    pURIInfo->bUseAppPathChecked = FALSE;

    // Copy the name of the physical path, so we have it for change
    // notifies.
    dwStringSize = pstrPhysicalPath->QueryCCH() + 1;

    pURIInfo->cchName = dwStringSize - 1;
    pURIInfo->pszName = (PCHAR)TCP_ALLOC(dwStringSize * sizeof(CHAR));

    if (pURIInfo->pszName == NULL)
    {

        // Not enough memory, fail.

        TsFree(pInstance->GetTsvcCache(), pURIInfo);
        return FALSE;
    }

    memcpy( pURIInfo->pszName, pstrPhysicalPath->QueryStr(), dwStringSize);

    //
    // Copy unmapped physical path ( before filter notification )
    // if different from physical path
    //

    if ( !pstrUnmappedPhysicalPath->IsEmpty() &&
         strcmp( pstrPhysicalPath->QueryStr(), pstrUnmappedPhysicalPath->QueryStr() ) )
    {
        dwStringSize = pstrUnmappedPhysicalPath->QueryCCH() + 1;
        pURIInfo->pszUnmappedName = (PCHAR)TCP_ALLOC(dwStringSize * sizeof(CHAR));

        if ( pURIInfo->pszUnmappedName == NULL)
        {

            // Not enough memory, fail.

            TsFree(pInstance->GetTsvcCache(), pURIInfo);
            return FALSE;
        }

        memcpy( pURIInfo->pszUnmappedName, pstrUnmappedPhysicalPath->QueryStr(), dwStringSize);
    }
    else
    {
        pURIInfo->pszUnmappedName = NULL;
    }
    
    //
    // Cache the extension map info for this URI
    //
   
    pURIInfo->pvExtMapInfo = NULL;
    
    // It's set up, so add it to the cache.

    if ( !TsCacheDirectoryBlob( pInstance->GetTsvcCache(),
                                pszURL,
                                cchURL,
                                RESERVED_DEMUX_URI_INFO,
                                pURIInfo,
                                TRUE))
    {
        pURIInfo->bIsCached = FALSE;
    }

    *ppURIInfo = pURIInfo;

    return TRUE;
}

//
//  Verb worker methods
//

BOOL
HTTP_REQUEST::DoUnknown(
    BOOL * pfFinished
    )
{
    DBGPRINTF((DBG_CONTEXT,
              "OnDoUnknown - Unknown method - %s\n",
              _strMethod.QueryStr()));

    if (!_stricmp("POST", _strMethod.QueryStr()))
    {
        SetState( HTR_DONE, HT_METHOD_NOT_ALLOWED, ERROR_INVALID_FUNCTION );
        Disconnect( HT_METHOD_NOT_ALLOWED, NO_ERROR, FALSE, pfFinished );
    }
    else
    {
        SetState( HTR_DONE, HT_NOT_SUPPORTED, ERROR_NOT_SUPPORTED );
        Disconnect( HT_NOT_SUPPORTED, IDS_METHOD_NOT_SUPPORTED, FALSE, pfFinished );
    }
    return TRUE;
}


BOOL
HTTP_REQUEST::LookupVirtualRoot(
    OUT STR *        pstrPath,
    IN  const CHAR * pszURL,
    IN  ULONG        cchURL,
    OUT DWORD *      pcchDirRoot,
    OUT DWORD *      pcchVRoot,
    OUT DWORD *      pdwMask,
    OUT BOOL *       pfFinished,
    IN  BOOL         fGetAcl,
    OUT PW3_METADATA* ppMetaData,
    OUT PW3_URI_INFO* ppURIBlob
    )
/*++

Routine Description:

    Looks up the virtual root to find the physical drive mapping.  If an
    Accept-Language header was sent by the client, we look for a virtual
    root prefixed by the language tag

Arguments:

    pstrPath - Receives physical drive path
    pszURL - URL to look for
    pcchDirRoot - Number of characters in the found physical path
    pcchVRoot - Number of characters in the found virtual root
    pdwMask - Access mask for the specified URL
    pfFinished - Set to TRUE if a filter indicated the request should end
    fGetAcl - TRUE to retrieve ACL for this virtual root
    ppMetaData - Pointer to metadata object for URL.  If this parameter is
                 set (!= NULL), then MetaData/URIBlob is not freed/checked in
    ppURIBlob - Pointer to URIBlob for URL.  If this parameter is set
                (!= NULL), then MetaData/URIBlob is not freed/checked in
--*/
{
    DWORD           cbPath;
    BOOL            fRet = TRUE;
    DWORD           dwDenied = SF_DENIED_RESOURCE;
    BOOL            fAnyFilters = FALSE;
    PW3_URI_INFO    pURIBlob = NULL;
    PW3_METADATA    pMetaData = NULL;
    BOOL            fMustCache = FALSE;
    STR             strUnmappedPhysicalPath;

    if ( !TsCheckOutCachedBlob( QueryW3Instance()->GetTsvcCache(),
                                pszURL,
                                cchURL,
                                RESERVED_DEMUX_URI_INFO,
                                (VOID **) &pURIBlob,
                                NULL ))
    {

        // We don't have URI info available for this yet. We need to read
        // the metadata for this URI and format it into a usable form, and
        // add it to the cache

        if ( !ReadMetaData( (LPSTR)pszURL,
                            pstrPath,
                            &pMetaData ) )
        {
            fRet = FALSE;
            goto Exit;
        }

        fMustCache = TRUE;
    }
    else
    {
        if ( pURIBlob->pszUnmappedName )
        {
            fRet = pstrPath->Copy( pURIBlob->pszUnmappedName );
        }
        else
        {
            fRet = pstrPath->Copy( pURIBlob->pszName, pURIBlob->cchName );
        }

        pMetaData = pURIBlob->pMetaData;
    }

    if ( pMetaData->QueryVrError() )
    {
        SetLastError( pMetaData->QueryVrError() );
        fRet = FALSE;
        goto Exit;
    }

    if ( pcchVRoot )
    {
        *pcchVRoot = pMetaData->QueryVrLen();
    }

    if ( pdwMask )
    {
        *pdwMask = pMetaData->QueryAccessPerms();
    }

    if ( fRet && _Filter.IsNotificationNeeded( SF_NOTIFY_URL_MAP,
                                               IsSecurePort() ))
    {
        BOOL fTmp;

        fAnyFilters = TRUE;

        if ( !strUnmappedPhysicalPath.Copy( *pstrPath ) ||
             !pstrPath->Resize( MAX_PATH + sizeof(TCHAR) ) )
        {
            fRet = FALSE;
            goto Exit;
        }

        //
        //  If the caller is going to ignore the Finished request flag, supply
        //  a value ourselves
        //

        if ( !pfFinished )
        {
            pfFinished = &fTmp;
        }

        fRet = _Filter.NotifyUrlMap( pszURL,
                                     pstrPath->QueryStr(),
                                     pstrPath->QuerySize(),
                                     pfFinished );
        if ( !fRet )
        {
            dwDenied |= SF_DENIED_FILTER;
        }

        //
        // Reset length because filter may have resized the string
        //
        pstrPath->SetLen( strlen( pstrPath->QueryStr() ) );
    }

    //
    //  Check for short name as they break metabase equivalency
    //

    if ( fRet &&
         memchr( pstrPath->QueryStr(), '~', pstrPath->QueryCB() ))             
    {
        BOOL  fShort;
        DWORD err;

        if ( err = CheckIfShortFileName( (UCHAR *) pstrPath->QueryStr(), 
                                         pMetaData->QueryVrAccessToken(),
                                         &fShort ))
        {
            fRet = FALSE;
            goto Exit;       
        }

        if ( fShort )
        {
            fRet = FALSE;
            SetLastError( ERROR_FILE_NOT_FOUND );            
            goto Exit;
        }
    }            

    if ( !fRet && fAnyFilters && GetLastError() == ERROR_ACCESS_DENIED )
    {
        SetDeniedFlags( dwDenied );
    }

    if ( pcchDirRoot )
    {
        *pcchDirRoot = pMetaData->QueryVrPath()->QueryCB();
    }

Exit:

    if ( fRet && fMustCache && !CacheUri( QueryW3Instance(),
                                  &pURIBlob,
                                  pMetaData,
                                  pszURL,
                                  cchURL,
                                  pstrPath,
                                  &strUnmappedPhysicalPath ) )
    {
        fRet = FALSE;
    }

    //
    // A caller will set ppURIBlob and ppMetaData when it wants to use the
    // URI cache for the URL, but takes the reponsibility of freeing the
    // URIBlob/Metadata after it is done using the URL's metadata object.
    //

    if ( ppURIBlob )
    {
        *ppURIBlob = pURIBlob;
    }

    if ( ppMetaData )
    {
        *ppMetaData = pMetaData;
    }

    if ( ppMetaData || ppURIBlob )
    {
        return fRet;
    }

    if ( pURIBlob != NULL )
    {
        if (pURIBlob->bIsCached)
        {
            TsCheckInCachedBlob( pURIBlob );
        }
        else
        {
            TsFree(QueryW3Instance()->GetTsvcCache(), pURIBlob );
        }
    }
    else
    {
        if ( pMetaData != NULL)
        {
            TsFreeMetaData( pMetaData->QueryCacheInfo() );
        }
    }

    return fRet;
}

/*******************************************************************

    NAME:       HTTP_REQUEST::ReprocessURL

    SYNOPSIS:   Called when a map file or gateway has redirected us
                to a different URL.  An async completion will be posted
                if TRUE is returned.

    ENTRY:      pchURL - URL we've been redirected to
                
                htverb - New verb to use (or unknown to leave as is)

    RETURNS:    TRUE if successful, FALSE otherwise

    HISTORY:
        Johnl       04-Oct-1994 Created

********************************************************************/

BOOL HTTP_REQUEST::ReprocessURL( TCHAR * pchURL,
                                 enum HTTP_VERB htverb )
{
    BOOL fFinished = FALSE;
    BOOL fAcceptReneg = FALSE;
    BOOL fHandled = FALSE;

    //
    //  Reset the gateway type
    //

    _GatewayType               = GATEWAY_UNKNOWN;
    _strGatewayImage.Reset();
    _dwScriptMapFlags          = 0;
    _fPossibleDefaultExecute   = FALSE;

    // Need to send a Content-Location header, unless the caller
    // doesn't want us to.

    ToggleSendCL();

    switch ( htverb )
    {
    case HTV_GET:
        _verb     = HTV_GET;
        _pmfnVerb = DoGet;
        break;

    case HTV_HEAD:
        _verb     = HTV_HEAD;
        _pmfnVerb = DoGet;
        break;

    case HTV_TRACE:
        _verb     = HTV_TRACE;
        _pmfnVerb = DoTrace;
        break;

    case HTV_TRACECK:
        _verb     = HTV_TRACECK;
        _pmfnVerb = DoTraceCk;
        break;

    case HTV_POST:
    case HTV_UNKNOWN:
        break;

    default:
        DBG_ASSERT( !"[ReprocessURL] Unknown verb type" );
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    ReleaseCacheInfo();

    SetState( HTR_DOVERB );

    _acIpAccess = AC_NOT_CHECKED;

    if ( !OnURL( pchURL )           ||
         !ProcessURL( &fFinished, &fHandled ) )
    {
        return FALSE;
    }
    
    //
    // If ProcessUrl() handled the request, but we are not finished yet, then
    // ProcessUrl() must have asynchronously send a response
    //
    
    if ( !fFinished && fHandled )
    {
        return TRUE;
    }

    //
    // <Begin explanantion of client cert renegotiation voodoo>
    // Check if we need to request a client cert. RequestRenegotiate() will call down
    // to sspifilt to send the necessary SSPI/SSL blob to start the renegotiation
    //

    if ( QueryState() != HTR_CERT_RENEGOTIATE )
    {
        if ( !RequestRenegotiate( &fAcceptReneg ) )
        {
            if ( GetLastError() == SEC_E_INCOMPLETE_MESSAGE )
            {
                fAcceptReneg = FALSE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    //
    // If renegotiation was requested/accepted, begin reading data. We issue an async read 
    // for the blobs from the client [triggered by the call to RequestRenegotiate above] and
    // back out all the way [to CLIENT_CONN::DoWork] to wait for the async completion to come
    // in with the blob from the client. From there, HandleCertRenegotiation() will take
    // care of the rest of the renegotiation.
    // </End explanation of client cert renegotiation voodoo>
    //

    if ( fAcceptReneg )
    {
        //
        // _cbOldData is the number of bytes of the client request that have already
        // been seen by the READ_RAW filter(s)
        //
        _cbOldData = _cbClientRequest + _cbEntityBody;
        DWORD cbNextRead = CERT_RENEGO_READ_SIZE;

        if ( !_bufClientRequest.Resize( _cbOldData + cbNextRead ))
        {
            return FALSE;
        }


        if ( !ReadFile( (BYTE *) _bufClientRequest.QueryPtr() + _cbOldData,
                        cbNextRead,
                        NULL,
                        IO_FLAG_ASYNC|IO_FLAG_NO_FILTER ))
        {
            return FALSE;
        }

        return TRUE;
    }
        
    //
    // If need to check IP access, do so now
    //

    if ( !fFinished )
    {
        //
        //  Check to see if encryption is required before we do any processing
        //

        if ( ( GetFilePerms() & VROOT_MASK_SSL )
                && !IsSecurePort() )
        {
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
            Disconnect( HT_FORBIDDEN, IDS_SSL_REQUIRED, FALSE, &fFinished );
            goto Exit;
        }

        //
        // Check if encryption key size should be at least 128 bits
        //

        if ( ( GetFilePerms() & VROOT_MASK_SSL128 ) )
        {
            DWORD   dwKeySize;
            BOOL    fNoCert;

            if ( !_tcpauth.QueryEncryptionKeySize(&dwKeySize, &fNoCert) || (dwKeySize < 128) )
            {
                SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
                Disconnect( HT_FORBIDDEN, IDS_SSL128_REQUIRED, FALSE, &fFinished );
                goto Exit;
            }
        }

        if ( !IsIpDnsAccessCheckPresent() )
        {
            _acIpAccess = AC_IN_GRANT_LIST;
        }
        else if ( _acIpAccess == AC_NOT_CHECKED )
        {
            _acIpAccess = QueryClientConn()->CheckIpAccess( &_fNeedDnsCheck );

            if ( (_acIpAccess == AC_IN_DENY_LIST) ||
                 ((_acIpAccess == AC_NOT_IN_GRANT_LIST) && !_fNeedDnsCheck) )
            {
                SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
                Disconnect( HT_FORBIDDEN, IDS_ADDR_REJECT, FALSE, &fFinished );
                goto Exit;
            }

            if ( _fNeedDnsCheck && !QueryClientConn()->IsDnsResolved() )
            {
                BOOL        fSync;
                LPSTR       pDns;
                AC_RESULT   acDnsAccess;

                if ( !QueryClientConn()->QueryDnsName( &fSync,
                        (ADDRCHECKFUNCEX)NULL,
                        (ADDRCHECKARG)QueryClientConn(),
                        &pDns ) )
                {
                    SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
                    Disconnect( HT_FORBIDDEN, IDS_ADDR_REJECT, FALSE, &fFinished );
                    goto Exit;
                }

                acDnsAccess = QueryClientConn()->CheckDnsAccess();

                _fNeedDnsCheck = FALSE;

                if ( acDnsAccess == AC_IN_DENY_LIST ||
                     acDnsAccess == AC_NOT_IN_GRANT_LIST ||
                     (_acIpAccess == AC_NOT_IN_GRANT_LIST && acDnsAccess != AC_IN_GRANT_LIST) )
                {
                    SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );
                    Disconnect( HT_FORBIDDEN, IDS_ADDR_REJECT, FALSE, &fFinished );
                    goto Exit;
                }
            }
        }
    }

    CheckValidAuth();

    if ( !IsLoggedOn() && !LogonUser( &fFinished ) )
    {
        SetLastError(ERROR_ACCESS_DENIED);

        return FALSE;
    }

    if ( !fFinished )
    {
        if ( !DoWork( &fFinished ))
        {
            return FALSE;
        }
    }

Exit:

    //
    //  If no further processing is needed, set our state to done and post
    //  an async completion.  We do this as the caller expects an async
    //  completion to clean things up
    //

    if ( fFinished )
    {
        DBG_ASSERT( QueryLogHttpResponse() != HT_DONT_LOG );

        SetState( HTR_DONE, QueryLogHttpResponse(), QueryLogWinError() );
        return PostCompletionStatus( 0 );
    }

    return TRUE;
}

/*******************************************************************

    NAME:       HTTP_REQUEST::GetInfo

    SYNOPSIS:   Pulls out various bits of information from this request.

    ENTRY:      pszValName - Value to retrieve
                pstr - Receives information in a string format
                pfFound - Option, Set to TRUE if a value was found, FALSE
                    otherwise

    NOTES:

    HISTORY:
        Johnl       25-Sep-1994 Created
        MuraliK     3-July-1996 Rewrote for efficiency - used switch-case
        MuraliK     21-Nov-1996 Rewrote again for efficiency
                                - use sub-function pointers

********************************************************************/

BOOL
HTTP_REQUEST::GetInfo(
    const TCHAR * pszValName,
    STR *         pstr,
    BOOL *        pfFound
    )
{
    if ( !pszValName )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( pfFound )
    {
        *pfFound = TRUE;
    }

    //
    //  terminate the string
    //

    pstr->Reset();

    if ( !strcmp( "ALL_HTTP", pszValName ))
        return BuildCGIHeaderListInSTR( pstr, &_HeaderList );

    //
    // Use the GetInfoForName() function to generate the required value
    // All callers of GetInfo() should be directly calling GetInfoForName()
    //   for efficiency sake
    //

    BOOL  fRet;
    DWORD cb = pstr->QuerySize();
    fRet = GetInfoForName( pszValName, pstr->QueryStr(), &cb);

    if ( !fRet) {

        switch ( GetLastError()) {

        case ERROR_INSUFFICIENT_BUFFER:
            DBG_ASSERT( cb > pstr->QuerySize());
            if ( !pstr->Resize( cb + 1)) {

                return ( FALSE);
            }

            // Try to get the value again.
            fRet = GetInfoForName( pszValName, pstr->QueryStr(), &cb);
            if ( fRet) {
                pstr->SetLen( strlen( pstr->QueryStr()));
            } else {
                DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER);
            }

            break;

        case ERROR_INVALID_PARAMETER:
        case ERROR_INVALID_INDEX:

            if ( pfFound ) {
                *pfFound = FALSE;
            }
            break;

        default:
            // there is a failure. Return the error to caller
            break;
        } // switch()
    } else {

        // Set the appropriate length
        pstr->SetLen( strlen( pstr->QueryStr()));
    }

    return (fRet);
} // HTTP_REQUEST::GetInfo()



BOOL
BuildCGIHeaderListInSTR( STR * pstr,
                         HTTP_HEADERS * pHeaderList
                         )
/*++

Routine Description:

    Builds a list of all client passed headers in the form of

    //
    //  Builds a list of all client HTTP headers in the form of:
    //
    //    HTTP_<up-case header>: <field>\n
    //    HTTP_<up-case header>: <field>\n
    //    ...
    //

Arguments:

    pstr - Receives full list
    pHeaderList - List of headers

--*/
{

    CHAR   ach[MAX_HEADER_LENGTH + CGI_HEADER_PREFIX_CCH + 1];
    CHAR * pch;
    DWORD  i;
    HH_ITERATOR       hhi;
    NAME_VALUE_PAIR * pnp = NULL;

    CopyMemory( ach, CGI_HEADER_PREFIX_SZ, CGI_HEADER_PREFIX_CCH );

    pHeaderList->InitIterator( &hhi);

    while (pHeaderList->NextPair( &hhi, &pnp)) {

        if ( pnp->cchName + CGI_HEADER_PREFIX_CCH > sizeof( ach)) {
            continue;
        }

        //
        //  Ignore some headers like "method", "url" and "version" -
        //   ones without the ':' at the end
        //

        if ( pnp->pchName[pnp->cchName - 1] != ':' )
        {
            continue;
        }

        //
        //  Convert the destination to upper and replace all '-' with '_'
        //

        pch = ach + CGI_HEADER_PREFIX_CCH;
        for ( i = 0; i < pnp->cchName; i++) {
            pch[i] = (( pnp->pchName[i] == '-') ? '_' :
                      toupper( pnp->pchName[i])
                      );
        } // for

        pch[i] = '\0';

        if ( !pstr->Append( ach )      ||
             !pstr->Append( pnp->pchValue, pnp->cchValue ) ||
             !pstr->Append( "\n", sizeof("\n")-1 ))
        {
            return FALSE;
        }
    } // for iterator over headers

    return TRUE;
} // BuildCGIHeaderListInSTR()




DWORD
HTTP_REQUEST::Initialize(
    VOID
    )
{
    DBG_REQUIRE( HTTP_HEADERS::Initialize());

    _fGlobalInit = TRUE;

    //
    // Initialize the GetInfo function table
    //

    //
    // 1. init the values to standard function GetInfoMisc() to start with
    //
    for( CHAR ch = 'A'; ch <= 'Z'; ch++) {
        sm_GetInfoFuncs[IndexOfChar(ch)] =  (PFN_GET_INFO ) &GetInfoMisc;
    }

    //
    // 2. Initialize all known functions as appropriate
    //
    sm_GetInfoFuncs[IndexOfChar('A')] =  (PFN_GET_INFO ) &GetInfoA;
    sm_GetInfoFuncs[IndexOfChar('C')] =  (PFN_GET_INFO ) &GetInfoC;

    sm_GetInfoFuncs[IndexOfChar('H')] =  (PFN_GET_INFO ) &GetInfoH;
    sm_GetInfoFuncs[IndexOfChar('I')] =  (PFN_GET_INFO ) &GetInfoI;
    sm_GetInfoFuncs[IndexOfChar('L')] =  (PFN_GET_INFO ) &GetInfoL;

    sm_GetInfoFuncs[IndexOfChar('P')] =  (PFN_GET_INFO ) &GetInfoP;
    sm_GetInfoFuncs[IndexOfChar('R')] =  (PFN_GET_INFO ) &GetInfoR;

    sm_GetInfoFuncs[IndexOfChar('S')] =  (PFN_GET_INFO ) &GetInfoS;
    sm_GetInfoFuncs[IndexOfChar('U')] =  (PFN_GET_INFO ) &GetInfoU;

    return (NO_ERROR);

} // HTTP_REQUEST::Initialize()




VOID
HTTP_REQUEST::Terminate(
    VOID
    )
{
    if ( !_fGlobalInit )
        return;

    HTTP_HEADERS::Cleanup();
}


BOOL
HTTP_REQUEST::RequestRenegotiate(
    LPBOOL  pfAccepted
    )
/*++

Routine Description:

    This method is invoked to request a SSL cert renegotiation

Arguments:

    pfAccepted - updated with TRUE if renegotiation accepted

Returns:

    TRUE if no error, otherwise FALSE

--*/
{
    if ( !IsSecurePort() ||
         !(GetFilePerms() & VROOT_MASK_NEGO_CERT) )
    {
        *pfAccepted = FALSE;

        return TRUE;
    }

    if ( _dwRenegotiated &&
         (GetFilePerms() & VROOT_MASK_MAP_CERT) ==
            (UINT)((_dwSslNegoFlags & SSLNEGO_MAP) ? VROOT_MASK_MAP_CERT : 0) )
    {
        *pfAccepted = FALSE;

        return TRUE;
    }

    _dwRenegotiated = 0;

    //
    // Ask the filter to handle renegotiation
    //

    if ( !_Filter.NotifyRequestRenegotiate( &_Filter,
                                            pfAccepted,
                                            GetFilePerms() & VROOT_MASK_MAP_CERT )
       )
    {
        return FALSE;
    }

    if ( *pfAccepted )
    {
        if ( GetFilePerms() & VROOT_MASK_MAP_CERT )
        {
            _dwSslNegoFlags |= SSLNEGO_MAP;
        }
        else
        {
            _dwSslNegoFlags &= ~SSLNEGO_MAP;
        }

        SetState( HTR_CERT_RENEGOTIATE );
    }

    return TRUE;
}


BOOL
HTTP_REQUEST::DoneRenegotiate(
    BOOL fSuccess
    )
/*++

Routine Description:

    This method is invoked on SSL cert renegotiation completion

Arguments:

    fSuccess - TRUE if renegotiation successfully retrieve a certificate

Returns:

    TRUE if no error, otherwise FALSE

--*/
{
    _dwRenegotiated = fSuccess ? CERT_NEGO_SUCCESS : CERT_NEGO_FAILURE;

    return TRUE;
}


VOID
HTTP_REQUEST::EndOfRequest(
    VOID
    )
/*++

Routine Description:

    This method does the necessary cleanup for the end of this request - note
    on error conditions this method may not be called, so there is some
    duplication with SessionTerminated which is guaranteed to be called

Arguments:
    None

Returns:
    None

--*/
{
    //
    //  Notify filters this is the end of the request
    //

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_END_OF_REQUEST,
                                       IsSecurePort() ))
    {
        _Filter.NotifyEndOfRequest();
    }

    CloseGetFile();
    
    //
    // Reset the authentication if
    // - not in authentication phase of connection
    // - SSL connection; connection can't be reused [eg by proxy] because it's encrypted
    // - flag single request per auth is set
    // - flag single proxy request per auth is set and request coming from a proxy
    //   ( as determined by checking for 'Via:' header ). Note that this method
    //   cannot guarantee proxy detection, but this is the best we can do.
    //   There are 2 submodes : always reset auth for proxies, or reset auth only
    //   if not in proxy mode ( as set by ISAPI app, default )
    //

    if ( _pMetaData &&
         !_fAuthenticating &&
         !_fAnonymous &&
         !IsSecurePort() &&
         ( (_pMetaData->QueryAuthenticationPersistence() & MD_AUTH_SINGLEREQUEST) ||
           ( (_pMetaData->QueryAuthenticationPersistence() & MD_AUTH_SINGLEREQUESTALWAYSIFPROXY) &&
              IsClientProxy() ) ||
           ( (_pMetaData->QueryAuthenticationPersistence() & MD_AUTH_SINGLEREQUESTIFPROXY) &&
              IsClientProxy() &&
              !IsProxyRequest() )
         )
       )
    {
        _fSingleRequestAuth = TRUE;
    }

    // Free the URI and/or metadata information if we have any. We know that
    // if we have URI info, then it points at meta data and will free the
    // metadata info when the URI info is free. Otherwise, we need to free
    // the metadata information here.

    CleanupWriteState();

    ReleaseCacheInfo();

    return;

} // HTTP_REQUEST::EndOfRequest()


VOID
HTTP_REQUEST::SessionTerminated(
    VOID
    )
/*++

Routine Description:

    This method does the necessary cleanup for the connected session
     for this request object.

Arguments:
    None

Returns:
    None

--*/
{
    switch ( QueryState()) {

      case HTR_GATEWAY_ASYNC_IO:

        // does the necessary actions to cleanup outstanding IO operation
        (VOID ) ProcessAsyncGatewayIO();
        break;

      default:
        break;

    } // switch()

    CloseGetFile();

    // Free the URI and/or metadata information if we have any. We know that
    // if we have URI info, then it points at meta data and will free the
    // metadata info when the URI info is free. Otherwise, we need to free
    // the metadata information here.

    ReleaseCacheInfo();

    //
    // do the cleanup for base object
    //
    HTTP_REQ_BASE::SessionTerminated();

    return;

} // HTTP_REQUEST::SessionTerminated()

#define EXTRA_ETAG_PRECOND_SIZE (sizeof("ETag: W/\r\n") - 1 + \
                            MAX_ETAG_BUFFER_LENGTH + \
                            sizeof("Date: \r\n") - 1+ \
                            sizeof("Mon, 00 Jan 1997: 00:00:00 GMT") - 1 +\
                            sizeof("Last-Modified: \r\n") - 1+ \
                            sizeof("Mon, 00 Jan 1997 00:00:00 GMT") - 1)

#define EXTRA_PRECOND_SIZE  (sizeof("Connection: keep-alive\r\n") - 1 +\
                            sizeof("Content-Length: 4294967295\r\n\r\n") - 1)

BOOL
HTTP_REQUEST::SendPreconditionResponse(
    DWORD   HT_Response,
    DWORD   dwIOFlags,
    BOOL    *pfFinished
    )
/*++

Routine Description:

    Utility routine to send the appropriate header for a precondition
    failure.

Arguments:

    HT_Response - The response to be sent.

    pfFinished  - Boolean indicating whether or not we're finished.


Returns:

    TRUE if we sent a response to the request, FALSE if we didn't.

--*/
{
    CHAR        *pszTail;
    STACK_STR(strTemp, 80);
    DWORD       dwCurrentSize;
    CHAR        ach[64];

    //
    //  Build the response with support for keep-alives
    //

    if ( !BuildStatusLine( &strTemp,
                           HT_Response,
                           NO_ERROR ))
    {
        return FALSE;
    }



    //
    // If this is a 304 response we need to send an ETag, and Expires.
    //
    if (HT_Response == HT_NOT_MODIFIED)
    {

        if (!BuildBaseResponseHeader(QueryRespBuf(),
                                     pfFinished,
                                     &strTemp,
                                     HTTPH_SEND_GLOBAL_EXPIRE))
        {
            return FALSE;
        }

        dwCurrentSize = strlen(QueryRespBufPtr());

        if (!QueryRespBuf()->Resize(dwCurrentSize + EXTRA_ETAG_PRECOND_SIZE +
                                    EXTRA_PRECOND_SIZE))
        {
            return FALSE;
        }

        pszTail = QueryRespBufPtr() + dwCurrentSize;

        DBG_ASSERT(_pGetFile != NULL);

        if ( !QueryNoCache() )
        {
            //
            //  Don't send a Last-Modified time, per the 1.1 spec.
            //

            //
            // ETag: <Etag>
            //

            if (_pGetFile->WeakETag())
            {
                APPEND_PSZ_HEADER(pszTail, "ETag: W/", _pGetFile->QueryETag(),
                    "\r\n");
            } else
            {
                APPEND_PSZ_HEADER(pszTail, "ETag: ", _pGetFile->QueryETag(),
                    "\r\n");
            }
        }

    }
    else
    {
        if (!BuildBaseResponseHeader(QueryRespBuf(),
                                     pfFinished,
                                     &strTemp,
                                     HTTPH_NO_CUSTOM))
        {
            return FALSE;
        }

        pszTail = QueryRespBufPtr();
        dwCurrentSize = strlen(pszTail);

        if (!QueryRespBuf()->Resize(dwCurrentSize + EXTRA_PRECOND_SIZE))
        {
            return FALSE;
        }

        pszTail = QueryRespBufPtr() + dwCurrentSize;
    }

    //
    // Don't need to add Connection: header, that's done by
    // BuildBaseResponseHeader.

    if ( IsKeepConnSet() )
    {
        if (!_fHaveContentLength &&
            (_cbBytesReceived == _cbClientRequest))
        {
            dwIOFlags |= IO_FLAG_AND_RECV;
        }
    }

    if (HT_Response != HT_NOT_MODIFIED)
    {
        BYTE        cMsg[128];
        BUFFER      bufMsg(cMsg, sizeof(cMsg));
        DWORD       dwMsgSize;

        if (CheckCustomError(&bufMsg, HT_Response, 0, pfFinished, &dwMsgSize, FALSE))
        {
            //
            // Now that we know the content length, add a content length
            // header, and copy the custom error message to the buffer.
            //

            APPEND_NUMERIC_HEADER( pszTail, "Content-Length: ", dwMsgSize, "\r\n" );

            dwCurrentSize = DIFF(pszTail - QueryRespBufPtr());

            if (!QueryRespBuf()->Resize(dwCurrentSize + bufMsg.QuerySize()))
            {
                return FALSE;
            }

            pszTail = QueryRespBufPtr() + dwCurrentSize;

            strcat(pszTail, (CHAR *)bufMsg.QueryPtr());
        }
        else
        {
            APPEND_STRING(pszTail, "Content-Length: 0\r\n\r\n");
        }

    }
    else
    {
        //
        // Need to send a content length of 0 because of HTTP/1.0 clients
        //
        
        APPEND_STRING(pszTail, "Content-Length: 0\r\n\r\n");
    }


    SetState( HTR_DONE, HT_Response, NO_ERROR );

    return SendHeader( QueryRespBufPtr(),
                       QueryRespBufCB(),
                       dwIOFlags,
                       pfFinished );
}

BOOL
HTTP_REQUEST::FindInETagList(
    PCHAR   pLocalETag,
    PCHAR   pETagList,
    BOOL    bWeakCompare
    )
/*++

Routine Description:

    Search and input list of ETag for one that matches our local ETag.

Arguments:

    pLocalETag  - The local ETag we're using.

    pETagList   - The ETag list we've received from the client.

    bWeakCompare - TRUE if we're doing a weak compare.

Returns:

    TRUE if we found a matching ETag, FALSE otherwise.

--*/
{
    UINT        QuoteCount;
    PCHAR       pFileETag;
    BOOL        Matched;

    // Otherwise, we'll loop through the ETag string, looking for ETag to
    // compare, as long as we have an ETag to look at.

    do {

        while (isspace((UCHAR)(*pETagList)))
        {
            pETagList++;
        }

        if (!*pETagList)
        {
            // Ran out of ETag.
            return FALSE;
        }

        // If this ETag is '*', it's a match.
        if (*pETagList == '*')
        {
            return TRUE;
        }

        // See if this ETag is weak.
        if (*pETagList == 'W' && *(pETagList+1) == '/')
        {
            // This is a weak validator. If we're not doing the weak comparison,
            // fail.

            if (!bWeakCompare)
            {
                return FALSE;
            }

            // Skip over the 'W/', and any intervening whitespace.
            pETagList += 2;

            while (isspace((UCHAR)(*pETagList)))
            {
                pETagList++;
            }

            if (!*pETagList)
            {
                // Ran out of ETag.
                return FALSE;
            }
        }

        if (*pETagList != '"')
        {
            // This isn't a quoted string, so fail.
            return FALSE;
        }

        // OK, right now we should be at the start of a quoted string that
        // we can compare against our current ETag.

        QuoteCount = 0;

        Matched = TRUE;
        pFileETag = pLocalETag;

        // Do the actual compare. We do this by scanning the current ETag,
        // which is a quoted string. We look for two quotation marks, the
        // the delimiters if the quoted string. If after we find two quotes
        // in the ETag everything has matched, then we've matched this ETag.
        // Otherwise we'll try the next one.

        do
        {
            CHAR        Temp;

            Temp = *pETagList;

            if (Temp == '"')
            {
                QuoteCount++;
            }

            if (*pFileETag != Temp)
            {
                Matched = FALSE;
            }

            if (!Temp)
            {
                return FALSE;
            }

            pETagList++;

            if (*pFileETag == '\0')
            {
                break;
            }

            pFileETag++;


        } while (QuoteCount != 2);

        if (Matched)
        {
            return TRUE;
        }

        // Otherwise, at this point we need to look at the next ETag.

        while (QuoteCount != 2)
        {
            if (*pETagList == '"')
            {
                QuoteCount++;
            }
            else
            {
                if (*pETagList == '\0')
                {
                    return FALSE;
                }
            }

            pETagList++;
        }

        while (isspace((UCHAR)(*pETagList)))
        {
            pETagList++;
        }

        if (*pETagList == ',')
        {
            pETagList++;
        }
        else
        {
            return FALSE;
        }

    } while ( *pETagList );

    return FALSE;
}


BOOL
HTTP_REQUEST::CancelPreconditions(
    )
/*++

Routine Description:

    Cancel preconditions for this request

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    _strRange.Reset();
    _HeaderList.FastMapCancel(HM_IFM);
    _liUnmodifiedSince.QuadPart = 0;
    _HeaderList.FastMapCancel(HM_INM);
    _liModifiedSince.QuadPart = 0;
    _dwModifiedSinceLength = 0;
    _HeaderList.FastMapCancel(HM_IFR);

    return TRUE;
}


BOOL
HTTP_REQUEST::CheckPreconditions(
    LPTS_OPEN_FILE_INFO pFile,
    BOOL    *pfFinished,
    BOOL    *bReturn

    )
/*++

Routine Description:

    Handle all of the If Modifiers on a request, and do the right thing
    with them. Note that this version implicitly assumes that the caller
    is performing a GET or HEAD or something compatible.

Arguments:

    pFile   - Pointer to file information for file we're checking.

    pfFinished  - pass through BOOLEAN.

    bReturn     - Where to store the response value for this routine.

Returns:

    TRUE if we sent a response to the request, FALSE if we didn't.

--*/
{
    LPSTR       pszETagList;
    BOOL        bWeakCompare;

    //
    // There are currently 5 possible If-* modifiers: If-Match,
    // If-Unmodified-Since, If-Non-Match, If-Modified-Since, and
    // If-Range. We handle them in that order if all are present,
    // and as soon as one condition fails we stop processing and return
    // the appropriate header.
    //
    // If-Range is an exception. It only modifies the behavior of an incoming
    // Range: request, and it only applies if the response would otherwise
    // be 2xx. If it succeeds nothing is done, but if it fails we (essentially)
    // delete the Range header and force sending of the whole header.
    //


    //
    // First see if we can use the weak comparison function. We can use
    // the weak comparison function iff this is for a conditional GET with
    // no range request. Note that If-Match always requires the strong
    // comparison function.

    bWeakCompare = _strRange.IsEmpty();

    // Now handle the If-Match header, if we have one.

    pszETagList = (LPSTR ) _HeaderList.FastMapQueryValue(HM_IFM);

    if (pszETagList != NULL)
    {
        // Have an If-Match header. If we can match the ETag we have in
        // the list we'll continue, otherwise send back
        // 412 Precondition Failed. If-Match requires the strong
        // comparison function, so it fails if the local ETag is weak or
        // the incoming ETags are weak.

        if ( pFile->WeakETag() ||
            !FindInETagList(pFile->QueryETag(), pszETagList, FALSE))
        {
            *bReturn = SendPreconditionResponse(HT_PRECOND_FAILED,
                                                IO_FLAG_ASYNC,
                                                pfFinished);
            return TRUE;
        }
    }


    // Made it through that, handle If-Unmodified-Since if we have that.

    if ( _liUnmodifiedSince.QuadPart)
    {
        FILETIME    tm;
        TCP_REQUIRE( pFile->QueryLastWriteTime( &tm ));

        // If  our last write time is greater than their UnmodifiedSince
        // time, the precondition fails.
        if (*(LONGLONG*)&tm > _liUnmodifiedSince.QuadPart )
        {
            *bReturn = SendPreconditionResponse(HT_PRECOND_FAILED,
                                                IO_FLAG_ASYNC,
                                                pfFinished);
            return TRUE;
        }
    }

    //
    // Now see if we have an If-None-Match, and if so handle that.
    //

    pszETagList = (LPSTR ) _HeaderList.FastMapQueryValue(HM_INM);

    if (pszETagList != NULL)
    {
        // Have an If-None-Match header. We send 304 if the If-None-Match
        // condition is false. The If-None-Match condition is false if
        // it's not true that we're doing a strong compare against a weak
        // local ETag and we can find a match in the ETag list.

        if (!(!bWeakCompare && pFile->WeakETag()) &&
            FindInETagList(pFile->QueryETag(), pszETagList,
            bWeakCompare))
        {
            *bReturn = SendPreconditionResponse(HT_NOT_MODIFIED,
                                                IO_FLAG_ASYNC,
                                                pfFinished);
            return TRUE;
        }

    }

    // And check for last modified since.
    if ( _liModifiedSince.QuadPart)
    {
        FILETIME tm;
        TCP_REQUIRE( pFile->QueryLastWriteTime( &tm ));

        if ( *(LONGLONG*)&tm <= _liModifiedSince.QuadPart )
        {
            // Need to check and see if the Modified-Since time is greater than
            // our current time. If it is, we ignore it.

            ::GetSystemTimeAsFileTime(&tm);

            if (*(LONGLONG *)&tm >= _liModifiedSince.QuadPart)
            {
                LARGE_INTEGER       liFileSize;
                TCP_REQUIRE( pFile->QuerySize( liFileSize ));

                if (_dwModifiedSinceLength == 0 ||
                    (liFileSize.HighPart == 0 &&
                    (liFileSize.LowPart == _dwModifiedSinceLength)))
                {
                    *bReturn = SendPreconditionResponse(HT_NOT_MODIFIED,
                                                        IO_FLAG_ASYNC,
                                                        pfFinished);
                    return TRUE;
                }
            }
        }

    }

    // Finally, we can handle If-Range: if it exists. If we've gotten this
    // far presumably we're going to send a 2xx response. We'll ignore the
    // If-Range if this is not a range request. If it is a range request and
    // the If-Range matches we don't do anything. If the If-Range doesn't
    // match then we force retrieval of the whole file.

    pszETagList = (LPSTR ) _HeaderList.FastMapQueryValue(HM_IFR);

    if (pszETagList != NULL)
    {
        if (!_strRange.IsEmpty())
        {

            // Need to determine if what we have is a date or an ETag.

            // What we have can be either an ETag or a date string. An ETag
            // may start with a W/ or a quote. A date may start with a W
            // but will never have the second character be a /.

            if ( *pszETagList == '"' ||
                    (*pszETagList == 'W' && pszETagList[1] == '/'))
            {
                // This is an ETag.
                if (pFile->WeakETag() ||
                        !FindInETagList(pFile->QueryETag(), pszETagList,
                            FALSE))
                {
                    // The If-Range failed, so we can't send a range. Force
                    // sending the whole thing.
                    _strRange.SetLen(0);
                }
            } else
            {
                LARGE_INTEGER   liRangeTime;

                // This must be a date. Convert it to a time, and see if it's
                // less than or equal to our last write time. If it is, the
                // file's changed, and we can't perform the range.

                if ( !StringTimeToFileTime( pszETagList, &liRangeTime))
                {
                    // Couldn't convert it, so don't send the range.
                    _strRange.SetLen(0);

                } else
                {
                    FILETIME    tm;
                    TCP_REQUIRE( pFile->QueryLastWriteTime( &tm ));

                    if (*(LONGLONG*)&tm > liRangeTime.QuadPart )
                    {
                        _strRange.SetLen(0);
                    }
                }

            }
        }
    }

    return FALSE;

}

BOOL
HTTP_REQUEST::CheckPreconditions(
    HANDLE  hFile,
    BOOL    bExisted,
    BOOL    *pfFinished,
    BOOL    *bReturn

    )
/*++

Routine Description:

    Handle the If Modifiers on a request, and do the right thing
    with them. This routine is very similar to the other CheckPreconditions
    routine. The difference is that the other one is intended to be called
    by someone doing a GET or HEAD, and this one is intended for other
    methods. This version of the routine takes as input a file handle
    instead of a pointer to a TS_OPEN_FILE_INFO class. Also, this version
    always uses the strong comparison function for ETags, doesn't check
    If-Modified-Since or If-Range headers, and sends 412 instead of 304
    for If-None-Match failures. We don't handle the If-Match and If-Range
    headers because the spec. calls them out as being for use with a GET
    and this version of the routine isn't called for GETs.


Arguments:

    hFile       - Handle for file we're checking.

    bExists     - TRUE if the file we're checking existed before this call.

    pfFinished  - pass through BOOLEAN.

    bReturn     - Where to store the response value for this routine.

Returns:

    TRUE if we sent a response to the request, FALSE if we didn't.

--*/
{
    LPSTR       pszETagList;
    CHAR        ETag[MAX_ETAG_BUFFER_LENGTH];
    BOOL        bETagIsValid = FALSE;
    BOOL        bWeakETag;
    FILETIME    tm;

    //
    // There are currently 3 possible If-* modifiers we handle here: If-Match,
    // If-Unmodified-Since, and If-Non-Match. We handle them in that order if
    // all are present, and as soon as one condition fails we stop processing
    // and return the appropriate header.
    //
    // Now handle the If-Match header, if we have one.

    pszETagList = (LPSTR ) _HeaderList.FastMapQueryValue(HM_IFM);

    if (pszETagList != NULL)
    {
        // Have an If-Match header. If we can match the ETag we have in
        // the list we'll continue, otherwise send back
        // 412 Precondition Failed. If-Match requires the strong comparison
        // function. The first thing we have to do is call the tsunami cache to
        // create an ETag for us. If we can't do that, we assume the
        // precondition failed, and return the appropriate error.

        // Check for the special case of '*'.
        if (*pszETagList == '*')
        {
            if (!bExisted)
            {
                *bReturn = SendPreconditionResponse(HT_PRECOND_FAILED,
                                                    IO_FLAG_SYNC,
                                                    pfFinished);
                return TRUE;
            }
        } else
        {
            bETagIsValid = TsCreateETagFromHandle(hFile, ETag, &bWeakETag);
            if (!bETagIsValid ||
                bWeakETag ||
                !FindInETagList(ETag, pszETagList, FALSE))
            {
                *bReturn = SendPreconditionResponse(HT_PRECOND_FAILED,
                                                    IO_FLAG_SYNC,
                                                    pfFinished);
                return TRUE;
            }
        }

    }


    // Made it through that, handle If-Unmodified-Since if we have that.

    if ( _liUnmodifiedSince.QuadPart)
    {

        // If  our last write time is greater than their UnmodifiedSince
        // time, the precondition fails. We'll need to call tsunami to
        // get the file time, if that fails we can't do the compare, so
        // we err on the safe side and return the error.


        if (!TsLastWriteTimeFromHandle(hFile, &tm) ||
            *(LONGLONG*)&tm > _liUnmodifiedSince.QuadPart )
        {
            *bReturn = SendPreconditionResponse(HT_PRECOND_FAILED,
                                                IO_FLAG_SYNC,
                                                pfFinished);
            return TRUE;
        }
    }

    //
    // Now see if we have an If-None-Match, and if so handle that.
    //

    pszETagList = (LPSTR ) _HeaderList.FastMapQueryValue(HM_INM);

    if (pszETagList != NULL)
    {
        // Have an If-None-Match header. We send 412 if the If-None-Match
        // condition is false. The If-None-Match condition is false if
        // it's not true that we're doing a strong compare against a weak
        // local ETag and we can find a match in the ETag list. We may
        // still need to create an ETag. In this case we need the
        // ETag to be valid, if we can't create one we won't go with
        // the 412 response.

        // Check for the special case of '*'.
        if (*pszETagList == '*')
        {
            if (bExisted)
            {
                *bReturn = SendPreconditionResponse(HT_PRECOND_FAILED,
                                                    IO_FLAG_SYNC,
                                                    pfFinished);
                return TRUE;
            }
        } else
        {
            if (!bETagIsValid)
            {
                bETagIsValid = TsCreateETagFromHandle(hFile, ETag, &bWeakETag);
            }

            if (bETagIsValid && !bWeakETag &&
                FindInETagList(ETag, pszETagList, FALSE))
            {
                *bReturn = SendPreconditionResponse(HT_PRECOND_FAILED,
                                                    IO_FLAG_SYNC,
                                                    pfFinished);
                return TRUE;
            }
        }

    }

    return FALSE;
}

BOOL
HTTP_REQUEST::DLCMungeSimple(
    VOID
)
/*++

Routine Description:

    Handle the URL before (optionally) looking up instance.  This means
    removing any "/HostMenu" and embeeded hosts.

Arguments:

    None

Returns:

    TRUE if successful, else FALSE

--*/
{
    const CHAR *    pchURL = _HeaderList.FastMapQueryValue( HM_URL );

    if ( !_strnicmp( pchURL,
                     g_pszDLCMenu,
                     g_cbDLCMenu ) )
    {
        if ( !_strHostAddr.Copy( g_pszDLCHostName, g_cbDLCHostName ) )
        {
            return FALSE;
        }

        if ( *( pchURL + g_cbDLCMenu ) == '\0' ||
             *( pchURL + g_cbDLCMenu ) == '?' )
        {
            STACK_STR(   strHostCookie, MAX_PATH );
            STACK_STR(   strMenuURL, MAX_PATH );

            const CHAR * pchCookie = _HeaderList.FastMapQueryValue( HM_COK );

            if ( pchCookie != NULL && DLCGetCookie( (CHAR*) pchCookie,
                                                    g_pszDLCCookieName,
                                                    g_cbDLCCookieName,
                                                    &strHostCookie ) )
            {
                if ( !strMenuURL.Copy( g_pszDLCCookieMenuDocument,
                                       g_cbDLCCookieMenuDocument ) )
                {
                    return FALSE;
                }
            }
            else
            {
                if ( !strMenuURL.Copy( g_pszDLCMungeMenuDocument,
                                       g_cbDLCMungeMenuDocument ) )
                {
                    return FALSE;
                }
            }

            if ( !strMenuURL.Append( pchURL + g_cbDLCMenu ) )
            {
                return FALSE;
            }

            _HeaderList.FastMapStore( HM_URL,
                                      NULL );

            return _HeaderList.FastMapStoreWithConcat( HM_URL,
                                                       strMenuURL.QueryStr(),
                                                       strMenuURL.QueryCB() );
        }
        else
        {
            _HeaderList.FastMapStore( HM_URL,
                                      pchURL + g_cbDLCMenu );
            return TRUE;
        }
    }
    else
    {

        if ( *pchURL == '/' )
        {
            pchURL++;
        }

        if ( *pchURL == '*' )
        {
            CHAR * pchNextSlash = strchr( pchURL, '/' );

            if ( pchNextSlash != NULL )
            {
                if ( !_strDLCString.Copy( pchURL + 1,
                                          DIFF(pchNextSlash - pchURL) - 1 ) )
                {
                    return FALSE;
                }

                _HeaderList.FastMapStore( HM_URL,
                                          pchNextSlash );
            }
        }

        return TRUE;
    }
}

BOOL
HTTP_REQUEST::DLCHandleRequest(
    IN OUT BOOL *           pfFinished
)
/*++

Routine Description:

    Check for whether a down level client has sent a cookie for use as a
    host header.  If so, set the host header.  If no cookie is sent, redirect
    the client to the register configured host menu.

Arguments:

    pfFinished - Set to TRUE if request finished.

Returns:

    TRUE if successful, else FALSE

--*/
{
    const CHAR *    pch = NULL;
    const CHAR *    pchURL = NULL;
    STACK_STR(      strHostCookie, MAX_PATH );

    //
    // Check for a pseudoheader cookie
    //

    pch = _HeaderList.FastMapQueryValue( HM_COK );
    pchURL = _HeaderList.FastMapQueryValue( HM_URL );

    if ( pch != NULL && DLCGetCookie( (CHAR*) _HeaderList.FastMapQueryValue( HM_COK ),
                                      g_pszDLCCookieName,
                                      g_cbDLCCookieName,
                                      &strHostCookie ) )
    {
        return _strHostAddr.Copy( strHostCookie );

    }
    else if ( !_strDLCString.IsEmpty() )
    {
        return _strHostAddr.Copy( _strDLCString );
    }
    else
    {
        STACK_STR(      strRedirect, MAX_PATH );

        //
        // No cookie, no munged string.  Do a redirect!
        //

        //
        // Send a cookie with the redirect so we can tell how capable the
        // user's browser really is.
        //

        if ( !strRedirect.Copy( "Set-Cookie: path=/; domain=" ) ||
             !strRedirect.Append( g_pszDLCHostName ) ||
             !strRedirect.Append( "; " ) ||
             !strRedirect.Append( g_pszDLCCookieName ) ||
             !strRedirect.Append( "=" ) ||
             !strRedirect.Append( g_pszDLCHostName ) ||
             !strRedirect.Append( "\r\n" ) ||
             !strRedirect.Append( "Location: http://" ) ||
             !strRedirect.Append( g_pszDLCHostName ) ||
             !strRedirect.Append( g_pszDLCMenu ) ||
             !strRedirect.Append( "?" ) ||
             !strRedirect.Append( _HeaderList.FastMapQueryValue( HM_URL ) ) ||
             !strRedirect.Append( "\r\n\r\n" ) )
        {
            return FALSE;
        }

        if ( !SendHeader( "302 Temporary Redirect",
                          strRedirect.QueryStr(),
                          IO_FLAG_SYNC,
                          pfFinished ) )
        {
            return FALSE;
        }

        *pfFinished = TRUE;

        return TRUE;
    }
}

BOOL
HTTP_REQUEST::DLCGetCookie(
    IN CHAR *                   pszCookieString,
    IN CHAR *                   pszCookieName,
    IN DWORD                    cbCookieName,
    OUT STR *                   pstrCookieValue
)
{
    CHAR *              pchPos = NULL;

    DBG_ASSERT( pszCookieString != NULL );
    DBG_ASSERT( pszCookieName != NULL );
    DBG_ASSERT( pstrCookieValue != NULL );

    pchPos = strstr( pszCookieString, pszCookieName );

    if ( pchPos != NULL )
    {
        CHAR *          pchEnd = NULL;
        BOOL            fCopyOK;

        pchPos += cbCookieName + 1;

        // Handle case where multiple cookies are sent

        pchEnd = strchr( pchPos, ';' );
        if ( pchEnd == NULL )
        {
            fCopyOK = pstrCookieValue->Copy( pchPos );
        }
        else
        {
            fCopyOK = pstrCookieValue->Copy( pchPos,
                                             DIFF(pchEnd - pchPos) );
        }

        //
        // Unescape the value if we got it
        //
        if ( fCopyOK ) {
            return pstrCookieValue->Unescape();
        } else {
            return FALSE;
        }
    }
    return FALSE;
}

BOOL
HTTP_REQUEST::RequestAbortiveClose(
    )
/*++

Routine Description:

    Request for abortive close on disconnect

Arguments:

    None

Returns:

    TRUE if successful, else FALSE

--*/
{
    SetKeepConn( FALSE );

    return QueryClientConn()->RequestAbortiveClose();
}

BOOL
HTTP_REQUEST::CloseConnection(
    )
/*++

Routine Description:

    Closes the socket connection

Arguments:

    None

Returns:

    TRUE if successful, else FALSE

--*/
{
    CLIENT_CONN *pConn;
    BOOL fSuccess = FALSE;

    pConn = QueryClientConn();

    DBG_ASSERT( pConn );

    //
    // If client is not already disconnected itself,
    // clear _fKeepConn flag and close connection
    //

    if( pConn->QueryState() != CCS_DISCONNECTING ) {

        //
        // RACE ALERT: it is still possible that client disconnects
        // while we are getting down to ATQ.

        SetKeepConn( FALSE );
        fSuccess = pConn->CloseConnection();
    }
    else
    {
        //
        // at this point we know that client did disconnect itself
        //

        fSuccess = FALSE;
    }

    return fSuccess;
}

APIERR
WriteConfiguration( VOID )
/*++

Routine Description:

    Determination certain configuration items of server and write them out
    to the metabase so that admin can access

Arguments:

    None

Returns:

    0 if successful, else Win32 Error Code

--*/
{
    CHAR        achFilename[ MAX_PATH ];
    CHAR *      pchFilePart;
    DWORD       dwRet;
    DWORD       dwHandle;
    UINT        dwLen;
    HKEY        hKey = NULL;
    DWORD       dwServerConfiguration = 0;
    MB          mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );


    //
    // With the availability of Server gated crypto, all servers
    // can use 128 bits encryption
    //

#if !defined(CHECK_SCHANNEL_FOR_128_BITS)

    dwServerConfiguration |= MD_SERVER_CONFIG_SSL_128;

#else

    //
    // Determine what type of SCHANNEL.DLL is installed
    //

    dwRet = SearchPath( NULL,
                        "schannel.dll",
                        NULL,
                        MAX_PATH,
                        achFilename,
                        &pchFilePart );

    if ( dwRet != 0 )
    {
        VOID *      pBuf;
        VOID *      pValue;
        WORD *      pVerTransInfo;
        CHAR        achBlockName[ MAX_PATH ];

        dwRet = GetFileVersionInfoSize( achFilename,
                                        &dwHandle );

        if ( dwRet == 0 )
        {
            goto Continue;
        }

        pBuf = LocalAlloc( LPTR,
                           dwRet );

        if ( pBuf == NULL )
        {
            return GetLastError();
        }

        if ( !GetFileVersionInfo( achFilename,
                                  dwHandle,
                                  dwRet,
                                  pBuf ) )
        {
            LocalFree( pBuf );
            goto Continue;
        }

        if ( !VerQueryValue( pBuf,
                             "\\VarFileInfo\\Translation",
                             &pValue,
                             &dwLen ) )
        {
            LocalFree( pBuf );
            goto Continue;
        }

        DBG_ASSERT( dwLen == sizeof( WORD * ) );

        pVerTransInfo = (WORD*) pValue;

        wsprintf( achBlockName,
                  "\\StringFileInfo\\%04hx%04hx\\FileDescription",
                  pVerTransInfo[ 0 ],
                  pVerTransInfo[ 1 ] );

        if ( !VerQueryValue( pBuf,
                             achBlockName,
                             &pValue,
                             &dwLen ) )
        {
            LocalFree( pBuf );
            goto Continue;
        }

        if ( strstr( (CHAR*) pValue, "Not for Export" ) )
        {
            dwServerConfiguration |= MD_SERVER_CONFIG_SSL_128;
        }
        else
        {
            dwServerConfiguration |= MD_SERVER_CONFIG_SSL_40;
        }

        LocalFree( pBuf );
    }

Continue:

#endif

    //
    // Is encryption disabled due to locality?
    //

    if ( IsEncryptionPermitted() )
    {
        dwServerConfiguration |= MD_SERVER_CONFIG_ALLOW_ENCRYPT;
    }

    //
    // Now determine whether the sub-authenticator is installed
    //

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_AUTHENTICATOR_KEY,
                       0,
                       KEY_READ,
                       &hKey ) == NO_ERROR )
    {
        DWORD               lRet;
        CHAR *              pchNext;
        HKEY                hSubKey = NULL;
        DWORD               dwType;
        BUFFER              buf( MAX_PATH );
        DWORD               dwBufLen;
        BOOL                fSubAuthenticate = FALSE;

Retry:
        dwBufLen = buf.QuerySize();

        lRet = RegQueryValueEx( hKey,
                                "Authentication Packages",
                                NULL,
                                &dwType,
                                (BYTE*) buf.QueryPtr(),
                                &dwBufLen );

        if ( lRet == ERROR_MORE_DATA )
        {
            if ( !buf.Resize( dwBufLen ) )
            {
                RegCloseKey( hKey );
                return GetLastError();
            }
            goto Retry;
        }
        else if ( lRet == ERROR_SUCCESS )
        {

            DBG_ASSERT( dwType == REG_MULTI_SZ );
            pchNext = (CHAR*) buf.QueryPtr();

            while ( *pchNext != '\0' )
            {
                if ( RegOpenKeyEx( hKey,
                                   pchNext,
                                   0,
                                   KEY_READ,
                                   &hSubKey ) == NO_ERROR )
                {
                    BYTE        achBuffer[ MAX_PATH ];
                    DWORD       dwBufSize = MAX_PATH;
                    DWORD       dwType;

                    if ( RegQueryValueEx( hSubKey,
                                          "Auth132",
                                          NULL,
                                          &dwType,
                                          achBuffer,
                                          &dwBufSize ) == ERROR_SUCCESS)
                    {
                        DBG_ASSERT( dwType == REG_SZ );

                        if ( strstr( (CHAR*) achBuffer, "iissuba" ) != NULL )
                        {
                            fSubAuthenticate = TRUE;
                        }
                    }

                    RegCloseKey( hSubKey );

                    if ( fSubAuthenticate )
                    {
                        dwServerConfiguration |= MD_SERVER_CONFIG_AUTO_PW_SYNC;
                        break;
                    }
                }
                else
                {
                    break;
                }

                pchNext += strlen( pchNext );
            }
        }

        RegCloseKey( hKey );
    }


    if ( !mb.Open( "/LM/W3SVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
    {
        return GetLastError();
    }

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_CONFIGURATION_INFO,
                       IIS_MD_UT_SERVER,
                       dwServerConfiguration,
                       0 ) )
    {
        DBG_REQUIRE( mb.Close() );
        return GetLastError();
    }

    DBG_REQUIRE( mb.Close() );

    return 0;
}


VOID
HTTP_REQUEST::CloseGetFile(
    VOID
    )
/*++

Routine Description:

    Closes our tsunami file handle structure if we have one.
    
Arguments:

    None

Returns:

    Nothing

--*/
{
        TS_OPEN_FILE_INFO * pGetFile;

        //
        // This function is sometimes called after an async I/O
        // has been initiated, so to prevent a race we the
        // completion routine we have to do this interlocked
        // operation.
        //
        pGetFile = (TS_OPEN_FILE_INFO *) InterlockedExchangePointer(
                                             (PVOID *)& _pGetFile,
                                             NULL
                                             );
        if ( pGetFile ) {
            DBG_REQUIRE( TsCloseURIFile(pGetFile) );
        }
}

VOID
EXEC_DESCRIPTOR::ReleaseCacheInfo(
    VOID
    )
/*++

Routine Description:

    Frees just the items we have checked out in the cache

Arguments:

    None

Returns:

    Nothing

--*/
{
    //
    //  Always release AppPathURIBlob info.
    //
    if ( _pAppPathURIBlob != NULL)
    {
        if (_pAppPathURIBlob->bIsCached)
        {
            TsCheckInCachedBlob( _pAppPathURIBlob );
        }
        else
        {
            TsFree(_pRequest->QueryW3Instance()->GetTsvcCache(), _pAppPathURIBlob );
        }
        _pAppPathURIBlob = NULL;
    }

    if ( _pPathInfoURIBlob != NULL)
    {

        if (_pPathInfoURIBlob->bIsCached)
        {
            TsCheckInCachedBlob( _pPathInfoURIBlob );
        } else
        {
            TsFree(_pRequest->QueryW3Instance()->GetTsvcCache(), _pPathInfoURIBlob );
        }
        _pPathInfoMetaData = NULL;
        _pPathInfoURIBlob = NULL;
    }
    else
    {
        if (_pPathInfoMetaData != NULL)
        {
            TsFreeMetaData(_pPathInfoMetaData->QueryCacheInfo() );
            _pPathInfoMetaData = NULL;
        }
    }
}

VOID
EXEC_DESCRIPTOR::Reset(
    VOID
    )
/*++

Routine Description:

    Reset structure after usage

Arguments:

    None

Returns:

    Nothing

--*/
{
    ReleaseCacheInfo();

    _pstrURL = NULL;
    _pstrPhysicalPath = NULL;
    _pstrUnmappedPhysicalPath = NULL;
    _pstrGatewayImage = NULL;
    _pstrPathInfo = NULL;
    _pstrURLParams = NULL;
    _pdwScriptMapFlags = NULL;
    _pGatewayType = NULL;
    _pRequest = NULL;
    _pParentWamRequest = NULL;
    _pMetaData = NULL;

    //
    //  if this is a child request, preserve its childishness
    //  (which is specified in flags member), since we need
    //  to set child event after this reset has occurred.
    //

    if ( !IsChild() ) {

        _dwExecFlags = 0;
    }

}


HANDLE
EXEC_DESCRIPTOR::QueryImpersonationHandle(
    )
/*++

Routine Description:

    returns impersonation access token for this request

Arguments:

    None

Returns:

    HANDLE value

--*/
{
    if ( _pPathInfoMetaData &&
         _pPathInfoMetaData->QueryVrAccessToken() &&
         ( !_pPathInfoMetaData->QueryVrPassThrough()
           || _pRequest->QueryAuthenticationObj()->IsForwardable()) )
    {
        return _pPathInfoMetaData->QueryVrAccessToken();
    }
    else
    {
        return _pRequest->QueryImpersonationHandle();
    }
}

HANDLE
EXEC_DESCRIPTOR::QueryPrimaryHandle(
    HANDLE* phDel
    )
/*++

Routine Description:

    returns primary access token for this request

Arguments:

    phDel - updated with token to delete when usage of returned token is complete.
            can be NULL if no token to delete.

Returns:

    HANDLE value

--*/
{
    HANDLE  hDel;
    HANDLE  hRet;

    if ( _pPathInfoMetaData &&
         _pPathInfoMetaData->QueryVrAccessToken() &&
         ( !_pPathInfoMetaData->QueryVrPassThrough()
           || _pRequest->QueryAuthenticationObj()->IsForwardable()) )
    {
        hRet = _pPathInfoMetaData->QueryVrPrimaryAccessToken();
        *phDel = NULL;
    }
    else
    {
        hRet = _pRequest->QueryPrimaryToken( phDel );
    }

    return hRet;
}



BOOL
EXEC_DESCRIPTOR::CreateChildEvent(
    )
/*++

Routine Description:

    Creates the child event, which will be used to signal
    that a child request has completed.

Arguments:

    None

Returns:

    BOOL

--*/
{

    DBG_ASSERT( IsChild() );
    DBG_ASSERT( _hChildEvent == NULL );

    _hChildEvent =
        CreateEvent(
            NULL, // LPSECURITY_ATTRIBUTES ptr to security attributes
            TRUE, // BOOL bManualReset - flag for manual-reset event
            FALSE,// BOOL bInitialState - flag for initial state
            NULL  // LPCTSTR lpName - ptr to event-object name
        );


    // Only wait for this event if marked so (after WamRequest.Bind())

    _fMustWaitForChildEvent = FALSE;


    return ( _hChildEvent != NULL );

}



VOID
EXEC_DESCRIPTOR::WaitForChildEvent(
    )
/*++

Routine Description:

    Waits for a child request to complete.

Arguments:

    None

Returns:

    Nothing

--*/
{

    DBG_ASSERT( IsChild() );
    DBG_ASSERT( _hChildEvent != NULL );


    if ( _hChildEvent ) {

        if ( _fMustWaitForChildEvent ) {

            WaitForSingleObject( _hChildEvent, INFINITE );
        }

        //
        //  After we emerge from wait, close and null the event.
        //
        //  Because we force a child request to execute
        //  synchronously to completion, we have no
        //  further need for the event once it becomes
        //  signaled.
        //

        CloseHandle( _hChildEvent );
        _hChildEvent = NULL;
    }

}



VOID
EXEC_DESCRIPTOR::SetChildEvent(
    )
/*++

Routine Description:

    Sets the child event, which signals that a child request
    has completed.

Arguments:

    None

Returns:

    Nothing

--*/
{

    DBG_ASSERT( IsChild() );
    DBG_ASSERT( _hChildEvent != NULL );

    if ( _hChildEvent ) {

        DBG_ASSERT( _fMustWaitForChildEvent );  // someone better be waiting

        SetEvent( _hChildEvent );
    }

}



VOID
IncrErrorCount(
    IMDCOM* pCom,
    DWORD   dwProp,
    LPCSTR  pszPath,
    LPBOOL  pbOverTheLimit
    )
/*++

Routine Description:

    Increment DWORD counter in metabase

Arguments:

    pCom - ptr to metabase I/F
    dwProp - property ID to increment, must be MD_UT_SERVER
    pszPath - path in metabase,
    pbOverTheLimit - updated with TRUE if counter over limit, otherwise FALSE

Returns:

    Nothing

--*/
{
    MB                  mb( pCom );
    DWORD               dwCnt;

    *pbOverTheLimit = FALSE;

    if ( mb.Open( pszPath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
    {
        if ( !mb.GetDword(
                           "",
                           dwProp,
                           IIS_MD_UT_SERVER,
                           &dwCnt
                         ) )
        {
            dwCnt = 0;
        }

        mb.SetDword(
                     "",
                     dwProp,
                     IIS_MD_UT_SERVER,
                     dwCnt + 1
                    );

        mb.Close();
    }
}


VOID
HTTP_REQUEST::CheckValidAuth(
    )
/*++

Routine Description:

    Check that current authentication method valid for the current URL

Arguments:
    None

--*/
{
    BOOL    fEnab;

    //
    // Check valid auth type for this URI
    //

    if ( IsLoggedOn() )
    {
        if ( _fAnonymous )
        {
            fEnab = MD_AUTH_ANONYMOUS & QueryAuthentication();
        }
        else if ( _fClearTextPass )
        {
            fEnab = MD_AUTH_BASIC & QueryAuthentication();
        }
        else if ( _fAuthTypeDigest )
        {
            fEnab = MD_AUTH_MD5 & QueryAuthentication();
        }
        else if ( _fAuthSystem )
        {
            fEnab = TRUE;
        }
        else if ( _fAuthCert )
        {
            fEnab = (((HTTP_REQUEST*)this)->GetFilePerms()) & MD_ACCESS_MAP_CERT;
        }
        else if ( _fMappedAcct )
        {
            fEnab = MD_AUTH_MAPBASIC & QueryAuthentication();
        }
        else
        {
            if ( fEnab = MD_AUTH_NT & QueryAuthentication() )
            {
                // check SSPI package is valid

                fEnab = FALSE;

                const LPSTR*    apszNTProviders = _pMetaData->QueryNTProviders();
                DWORD           i;

                for ( i = 0 ; apszNTProviders[i] ; ++i )
                {
                    if ( !strcmp( _strAuthType.QueryStr(), apszNTProviders[i] ) )
                    {
                        fEnab = TRUE;
                        break;
                    }
                }
            }
        }
        if ( !fEnab )
        {
            if ( _fAnonymous )
            {
                QueryW3StatsObj()->DecrCurrentAnonymousUsers();
            }
            else
            {
                QueryW3StatsObj()->DecrCurrentNonAnonymousUsers();
            }

            ResetAuth( FALSE );
        }
    }
}

/*++

Routine Description:

    returns ApplicationPath for this EXEC.  For those ISAPI.dll that
    are only runnable in process, _pAppPathURIBlob->bInProcOnly will be true.
    Therefore, the default application path is returned.
    Example: .STM file.

Arguments:

    None

Returns:

    a pointer to STR that contains application path.

--*/
STR * EXEC_DESCRIPTOR::QueryAppPath
(
void
)
{
    STR *   pstr = NULL;

    DBG_REQUIRE(_pAppPathURIBlob != NULL);
    DBG_REQUIRE(_pMetaData != NULL);

    //
    // InProcOnly ISAPI gets the default application path.
    // Otherwise, use the application path come from MetaData.
    //
    if (_pAppPathURIBlob->bInProcOnly)
        {
        pstr = g_pWamDictator->QueryDefaultAppPath();
        }
    else
        {
        pstr = _pMetaData->QueryAppPath();
        }

   DBG_ASSERT(pstr != NULL);

   return pstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\makefile.inc ===
#
# Supplemental rules for generating message file.
#


$(O)\w3msg.h $(O)\w3msg.rc $(O)\msg00001.bin: w3msg.mc ..\..\..\inc\inetamsg.mc
    copy /a ..\..\..\inc\inetamsg.mc + /a w3msg.mc $(O)\tmp.mc
    mc -v -h .\$(O) -r .\$(O) $(O)\tmp.mc
    -del $(O)\w3msg.h $(O)\tmp.mc $(O)\w3msg.rc
    copy $(O)\tmp.h $(O)\w3msg.h
    del $(O)\tmp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\mtacb.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MTA Callback

File: mtacb.h

Owner: DmitryR

This file contains the definitons for MTA Callback
===================================================================*/

#ifndef MTACALLBACK_H
#define MTACALLBACK_H

// To be called from DllInit()
HRESULT InitMTACallbacks();

// To be called from DllUnInit()
HRESULT UnInitMTACallbacks();

// The callback function to be called from an MTA thread
typedef HRESULT (__stdcall *PMTACALLBACK)(void *, void *);

HRESULT CallMTACallback
    (
    PMTACALLBACK pMTACallback,          // call this function
    void        *pvContext,             // pass this to it
    void        *pvContext2             // extra arg
    );

#endif // MTACALLBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\httpxpc.h ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	HTTPXPC.H
//
//		Private interface to HTTPEXT perf counters for use by W3SVC.
//
//	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
//

EXTERN_C BOOL __fastcall
W3OpenDavPerformanceData();

EXTERN_C BOOL __fastcall
W3MergeDavPerformanceData( DWORD dwServerId, W3_STATISTICS_1 * pW3Stats );

EXTERN_C VOID __fastcall
W3CloseDavPerformanceData();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\httpxpc.cxx ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	HTTPXPC.CXX
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//
//	Monitor-side for W3 integration.
//

#include "w3p.hxx" // W3SVC Precompiled header

#include <windows.h>
#include <winperf.h>
#include "pclib.hxx"
#include "httpxctr.hxx" // Perf counter title index #defines
#include "caldbg.h"  // For DebugTrace()/Assert()


EXTERN_C const WCHAR gc_wszSignature[]	= L"HTTPEXT";
EXTERN_C const CHAR gc_szDbgIni[] = "HTTPXPC.INI";
EXTERN_C const CHAR gc_szSignature[] = "HTTPXPC";

//
// This is declared here because the shared memory library
// now requires any dll or exe using it to define this function.
// However this function is only used for the shared lock cache
// so we do not need to actually implement it for perf counters.
//
namespace IMPLSTUB
{
	VOID __fastcall SaveHandle(HANDLE hHandle);
}

VOID __fastcall
IMPLSTUB::SaveHandle(HANDLE h)
{
    Assert ( FALSE );
    return;
}
// end of hack working around shared lock cache.


//
//	The following macros, templates and classes are derived from
//	sources in the DAV project.
//

//	========================================================================
//
//	TEMPLATE CLASS Singleton
//
//	Use this template to implement classes that can only have one instance.
//	NOTE: For ref-counted or on-demand global objects, see below
//		(RefCountedGlobal and OnDemandGlobal).
//
//	The Singleton template provides the following:
//
//		o	a common memory layout for singleton classes which
//			allows template folding to reduce overall code size.
//
//		o	an instantiation mechanism that verifies (asserts)
//			that only instance of your class ever exists.
//
//		o	asserts to catch any code which attempts to use
//			your class when it's not initialized.
//
//	To use this template, declare your class like this:
//
//		class YourClass : private Singleton<YourClass>
//		{
//			//
//			//	Declare Singleton as a friend of YourClass
//			//	if YourClass's constructor is private (which it
//			//	should be since YourClass is a singleton and
//			//	should not be allowed to arbitrarily create
//			//	instances of it).
//			//
//			friend class Singleton<YourClass>;
//
//			//
//			//	YourClass private members.  Since the 'staticness'
//			//	of YourClass is provided entirely by this template,
//			//	you do not need to declare your members as 'static'
//			//	and you should use standard Hungarian class member
//			//	naming conventions (e.g. m_dwShoeSize).
//			//
//			[...]
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass which
//			//	would call CreateInstance() and DestroyInstance()
//			//	respectively.  Or, you could just expose these functions
//			//	directly to clients of YourClass with using declarations:
//			//
//			//		using Singleton<YourClass>::CreateInstance;
//			//		using Singleton<YourClass>::DestroyInstance;
//			//
//			//	Similarly, YourClass will probably have additional
//			//	static methods which access or operate on the
//			//	singleton instance.  These will call Instance()
//			//	to get at the global instance.  Or, though it's
//			//	not recommended from an encapsulation standpoint,
//			//	you could expose the global instance directly to
//			//	clients with:
//			//
//			//		using Singleton<YourClass>::Instance;
//			//
//			[...]
//		};
//
template<class _X>
class Singleton
{
	//
	//	Space for the sole instance
	//
	static BYTE sm_rgbInstance[];

	//
	//	Pointer to the instance
	//
	static _X * sm_pInstance;

public:
	//	STATICS
	//

	//
	//	Create the single, global instance of class _X.
	//
	static _X& CreateInstance()
	{
		//
		//	This actually calls Singleton::new()
		//	(defined below), but calls to new()
		//	must always be unqualified.
		//
		return *(new _X());
	}

	//
	//	Destroy the single, global instance of class _X.
	//
	static VOID DestroyInstance()
	{
		//
		//	This actually calls Singleton::delete()
		//	(defined below), but calls to delete()
		//	must always be unqualified.
		//
		delete sm_pInstance;
	}

	//
	//	Provide access to the single, global instance of class _X.
	//
	static _X& Instance()
	{
		Assert( sm_pInstance );

		return *sm_pInstance;
	}

	//
	//	Singleton operator new and operator delete "allocate"
	//	space for the object in static memory.  These must be
	//	defined public for syntactic reasons.  Do NOT call them
	//	directly!!  Use CreateInstance()/DestroyInstance().
	//
	static void * operator new(size_t)
	{
		Assert( !sm_pInstance );

		//
		//	Just return a pointer to the space
		//	in which to instantiate the object.
		//
		sm_pInstance = reinterpret_cast<_X *>(sm_rgbInstance);
		return sm_pInstance;
	}

	static void operator delete(void *, size_t)
	{
		Assert( sm_pInstance );

		//
		//	Since nothing was done to allocate space
		//	for the instance, we don't do anything
		//	here to free it.
		//
		sm_pInstance = NULL;
	}

};

//
//	Space for the sole instance of class _X
//
template<class _X>
BYTE Singleton<_X>::sm_rgbInstance[sizeof(_X)];

//
//	Pointer to the instance
//
template<class _X>
_X * Singleton<_X>::sm_pInstance = NULL;


//	========================================================================
//
//	CLASS _Empty
//
//	A completely empty, but instantiatable class.  Use the _Empty class
//	to get around the syntactic inability to instantiate anything of
//	type void (or VOID).
//
//	In retail builds, _Empty has the same memory footprint and code
//	impact as void -- none.
//
//	See the RefCountedGlobal template below for a usage example.
//
class _Empty
{
	//	NOT IMPLEMENTED
	//
	_Empty( const _Empty& );
	_Empty& operator=( const _Empty& );

public:
	_Empty() {}
	~_Empty() {}
};


//	========================================================================
//
//	TEMPLATE CLASS RefCountedGlobal
//
//	Use this template as boilerplate for any class that encapsulates
//	a global, refcounted initialization/deinitialization process.
//
//	This template maintains proper refcounting and synchronization when
//	there are multiple threads trying to initialize and deinitialize
//	references at the same time.  And it does so without a critical
//	section.
//
//	To use this template, declare your class like this:
//
//		class YourClass : private RefCountedGlobal<YourClass>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that they can call your private
//			//	initialization functions.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	should perform any failable initialization of the
//			//	instance of YourClass.  It should return TRUE
//			//	if initialization succeeds, and FALSE otherwise.
//			//	If YourClass does not have any initialization that
//			//	can fail then you should implement this function inline
//			//	to just return TRUE.
//			//
//			BOOL FInit();
//
//		public:
//			//
//			//	Public declarations for YourClass.  Among these should
//			//	be static functions to init and deinit YourClass.  These
//			//	functions would call DwInitRef() and DeinitRef() respectively.
//			//	Or, you could just expose DwInitRef() and DeinitRef()
//			//	directly to clients of YourClass with using declarations:
//			//
//			//		using RefCountedGlobal<YourClass>::DwInitRef;
//			//		using RefCountedGlobal<YourClass>::DeinitRef;
//			//
//			[...]
//		};
//
//	If YourClass::FInit() succeeds (returns TRUE), then DwInitRef()
//	returns the new refcount.  If YourClass::FInit() fails (returns
//	FALSE), then DwInitRef() returns 0.
//
//	See \cal\src\inc\memx.h for sample usage.
//
//	If YourClass::FInit() requires initialization parameters, you can
//	still use the RefCountedGlobal template.  You just need to provide
//	your parameter type in the template instantiation and declare your
//	FInit() to take a const reference to a parameter of that type:
//
//		class YourClass : private RefCountedGlobal<YourClass, YourParameterType>
//		{
//			//
//			//	Declare Singleton and RefCountedGlobal as friends
//			//	of YourClass so that htey can call your private
//			//	initialization functions.
//			//
//			//	Note the added parameter type to the RefCountedGlobal
//			//	declaration.
//			//
//			friend class Singleton<YourClass>;
//			friend class RefCountedGlobal<YourClass, YourParameterType>;
//
//			//
//			//	Private declarations for YourClass
//			//
//			[...]
//
//			//
//			//	Failable initialization function.  This function
//			//	now takes a const ref to the initialization parameters.
//			//
//			BOOL FInit( const YourParameterType& initParam );
//
//		public:
//			//
//			//	Public declarations for YourClass
//			//
//			[...]
//		};
//
//	See \cal\src\httpext\entry.cpp for an example of this usage.
//
template<class _X, class _ParmType = _Empty>
class RefCountedGlobal : private Singleton<_X>
{
	//
	//	The object's reference count.
	//
	static LONG sm_lcRef;

	//
	//	Set of states which describe the object's state
	//	of initialization.  The object's state is
	//	STATE_UNKNOWN while it is being initialized or
	//	deinitialized.
	//
	enum
	{
		STATE_UNINITIALIZED,
		STATE_INITIALIZED,
		STATE_UNKNOWN
	};

	static LONG sm_lState;

	//
	//	Member template that generates an appropriately-typed,
	//	(inline) function that calls _X::FInit with initialization
	//	parameters.
	//
	template<class _P> static BOOL
	FInit( const _P& parms ) { return Instance().FInit( parms ); }

	//
	//	Specialization of the above member template for
	//	the _Empty parameter type, which calls _X::FInit
	//	without initialization parameters.
	//
	static BOOL FInit( const _Empty& ) { return Instance().FInit(); }

protected:
	//
	//	Expose access to the single instance of class _X
	//
	using Singleton<_X>::Instance;

	//
	//	Expose operator new and operator delete from
	//	the Singleton template so that they will be
	//	used rather than the default new and delete
	//	to "allocate" space for the instance of class _X.
	//
	using Singleton<_X>::operator new;
	using Singleton<_X>::operator delete;

	static BOOL FInitialized()
	{
		return sm_lState == STATE_INITIALIZED;
	}

	static LONG CRef()
	{
		return sm_lcRef;
	}

public:
	static DWORD DwInitRef( const _ParmType& parms )
	{
		LONG lcRef;

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( sm_lState != STATE_INITIALIZED || sm_lcRef >= 1 );

		//
		//	Add the reference for the instance we're about
		//	to initialize.  Doing this now simplifies the
		//	code below at the expense of having to decrement
		//	if first time initialization (FInit()) fails.
		//	The only thing critical to the design is that
		//	at any point, when sm_lState is STATE_INITIALIZED,
		//	sm_lcRef is at least 1.
		//
		lcRef = InterlockedIncrement( &sm_lcRef );
		Assert( lcRef > 0 );

		//
		//	Don't proceed until the object is initialized.
		//
		while ( sm_lState != STATE_INITIALIZED )
		{
			//
			//	Simultaneously check whether initialization has
			//	started and, if it has not, start it.
			//
			LONG lStatePrev = InterlockedCompareExchange(
								&sm_lState,
								STATE_UNKNOWN,
								STATE_UNINITIALIZED );

			//
			//	If we're starting first time initialization,
			//	then create and initialize the sole instance.
			//
			if ( lStatePrev == STATE_UNINITIALIZED )
			{
				CreateInstance();

				//	This calls our private member template FInit()
				//	(declared above), which in turn calls _X::Finit()
				//	with the appropriate parameters.
				//
				if ( FInit( parms ) )
				{
					sm_lState = STATE_INITIALIZED;
					break;
				}

				//	We failed to init.
				//	Tear down now.
				//
				
				Assert( lcRef == 1 );
				Assert( sm_lState == STATE_UNKNOWN );

				//	Let go of our ref on the object.
				//	Destroy the object.
				//	And LAST, set the state to UNINITIALIZED.
				//	NOTE: This will let the next caller through the
				//	InterlockedCompare above.
				//
				InterlockedDecrement( &sm_lcRef );
				DestroyInstance();
				sm_lState = STATE_UNINITIALIZED;

				return 0;
			}

			//
			//	If first time initialization is in progress on
			//	another thread, then get out of the way so
			//	it can finish.
			//
			//$OPT	We should probably spin rather than Sleep()
			//$OPT	on multi-proc machines on the assumption that
			//$OPT	we only get here on a processor other than
			//$OPT	the one which is doing the initialization
			//$OPT	and we don't want to invite a task switch
			//$OPT	by calling Sleep() while we are waiting
			//$OPT	for initialization to complete.
			//
			if ( lStatePrev == STATE_UNKNOWN )
				Sleep(0);
		}

		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( sm_lState == STATE_INITIALIZED );
		Assert( sm_lcRef > 0 );

		return static_cast<DWORD>(lcRef);
	}

	static VOID DeinitRef()
	{
		//
		//	At this point, there must be at least
		//	one initialized reference.
		//
		Assert( sm_lState == STATE_INITIALIZED );
		Assert( sm_lcRef > 0 );

		//
		//	Remove that reference.  If it is the last
		//	then deinit the object.
		//
		if ( 0 == InterlockedDecrement( &sm_lcRef ) )
		{
			//
			//	After releasing the last reference, declare that
			//	the object is in an unknown state.  This prevents
			//	other threads trying to re-initialize the object
			//	from proceeding until we're done.
			//
			sm_lState = STATE_UNKNOWN;

			//
			//	There is a tiny window between decrementing the
			//	refcount and changing the state where another
			//	initialization could have come through.  Test this
			//	by rechecking the refcount.
			//
			if ( 0 == sm_lcRef )
			{
				//
				//	If the refcount is still zero, then no
				//	initializations happened before we changed
				//	states.  At this point, if an initialization
				//	starts, it will block until we change state,
				//	so it is safe to actually destroy the instance.
				//
				DestroyInstance();

				//
				//	Once the object has been deinitialized, update
				//	the state information.  This unblocks any
				//	initializations waiting to happen.
				//
				sm_lState = STATE_UNINITIALIZED;
			}
			else // refcount is now non-zero
			{
				//
				//	If the refcount is no longer zero, then an
				//	initialization happened between decrementing
				//	the refcount above and entering the unknown
				//	state.  When that happens, DO NOT deinit --
				//	there is now another valid reference somewhere.
				//	Instead, just restore the object's state to let
				//	other references proceed.
				//
				sm_lState = STATE_INITIALIZED;
			}
		}

		//
		//	Assert the invariant condition that we never have a
		//	reference without the state being initialized.
		//
		Assert( sm_lState != STATE_INITIALIZED || sm_lcRef >= 1 );
	}

	//	This provides a no-parameter version of DwInitRef
	//	for clients that do not need any parameters in FInit().
	//
	static DWORD DwInitRef()
	{
		_Empty e;

		return DwInitRef( e );
	}
};

template<class _X, class _ParmType>
LONG RefCountedGlobal<_X, _ParmType>::sm_lcRef = 0;

template<class _X, class _ParmType>
LONG RefCountedGlobal<_X, _ParmType>::sm_lState = STATE_UNINITIALIZED;


// ========================================================================
// SHARED MEMORY HANDLES
//
// They are always defined as 32 bit values
//
#ifdef _WIN64
 typedef VOID * __ptr32 SHMEMHANDLE;
#else
 typedef HANDLE SHMEMHANDLE;
#endif

// ========================================================================
//
// NAMESPACE SMH
//
// Differentiates the shared memory heap allocation functions
// from all of the other various heap allocation functions
// in existence.
//
// Yes, this could have been done with a prefix just as easily....
//
namespace SMH
{
 BOOL __fastcall FInitialize( IN LPCWSTR pwszInstanceName );
 VOID __fastcall Deinitialize();
 PVOID __fastcall PvAlloc( IN DWORD cbData, OUT SHMEMHANDLE * phsmba );
 VOID __fastcall Free( IN SHMEMHANDLE hsmba );
 PVOID __fastcall PvFromSMBA( IN SHMEMHANDLE hsmba );
};


//	========================================================================
//
//	CLASS CSmhInit
//
//	Initializer for shared memory heap.  Any class containing member objects
//	that reside on the shared memory heap should also include an instance
//	of this class as a member BEFORE the others to ensure that they are
//	properly destroyed before the heap is deinitialized.
//
class CSmhInit
{
	//	NOT IMPLEMENTED
	//
	CSmhInit& operator=( const CSmhInit& );
	CSmhInit( const CSmhInit& );

public:
	CSmhInit()
	{
	}

	BOOL FInitialize( LPCWSTR lpwszSignature )
	{
#ifdef COMPILE_WITHOUT_DAV
		return FALSE;
#else
		return SMH::FInitialize( lpwszSignature );
#endif
	}

	~CSmhInit()
	{
#ifdef COMPILE_WITHOUT_DAV
		// do nothing
#else
		SMH::Deinitialize();
#endif
	}
};


//	========================================================================
//
//	TEMPLATE CLASS auto_ptr
//
//		Stripped down auto_ptr class based on the C++ STL standard one
//
template<class X>
class auto_ptr
{
	mutable X *		owner;
	X *				px;

public:
	explicit auto_ptr(X* p=0) : owner(p), px(p) {}
	auto_ptr(const auto_ptr<X>& r) : owner(r.owner), px(r.relinquish()) {}

	auto_ptr& operator=(const auto_ptr<X>& r)
	{
		if ((void*)&r != (void*)this)
		{
			delete owner;
			owner = r.owner;
			px = r.relinquish();
		}

		return *this;
	}
	//	NOTE: This equals operator is meant to be used to load a
	//	new pointer (not yet held in any auto-ptr anywhere) into this object.
	auto_ptr& operator=(X* p)
	{
		Assert(!owner);		//	Scream on overwrite of good data.
		owner = p;
		px = p;
		return *this;
	}

	~auto_ptr()           { delete owner; }
	bool operator!()const { return (px == NULL); }
	operator X*()	const { return px; }
	X& operator*()  const { return *px; }
	X* operator->() const { return px; }
	X* get()		const { return px; }
	X* relinquish() const { owner = 0; return px; }

	void clear()
	{
		if (owner)
			delete owner;
		owner = 0;
		px = 0;
	}
};


//
//	From here down implements the performance monitor for HTTPEXT and
//	the functionality necessary to merge perf counters from HTTPEXT
//	into the Web Service object defined by W3CTRS.
//

//
//	The first flag says whether the CW3Monitor instance has been created.
//	The second flag says whether it has been initialized.
//	Since the CW3Monitor is created on-demand by the first call to
//	W3MergeDavPerformanceData(), these flags keep us from continually
//	retrying initialization after it fails the first time.
//
BOOL g_fCreatedMonitor = FALSE;
BOOL g_fInitializedMonitor = FALSE;


//	========================================================================
//
//	CLASS CW3Monitor
//
class CW3Monitor : private Singleton<CW3Monitor>
{
	//
	//	Friend declaration required by Singleton template
	//
	friend class Singleton<CW3Monitor>;

	//
	//	Hint about the size of the buffer to use for perf data coming back
	//	from HTTPEXT.  The buffer needs to be about 48K per vroot.  The
	//	initial guess is 48K (one vroot), and scales up geometrically as
	//	necessary.
	//
	DWORD m_cbDavDataAlloc;

	//
	//	Shared memory heap initialization.  Declare before any member
	//	variables which use the shared memory heap to ensure proper
	//	order of destruction.
	//
	CSmhInit m_smh;

	//
	//	Perf counter data
	//
	auto_ptr<ICounterData> m_pCounterData;

	//	CREATORS
	//
	CW3Monitor() :
		m_cbDavDataAlloc(48 * 1024)
	{
	}
	BOOL FInitialize();

	//	ACCESSORS
	//
	DWORD DwCollectPerformanceData( LPBYTE lpbPerfData,
									LPDWORD lpdwcbPerfData )
	{
		DWORD dwcObjectTypes;

		return m_pCounterData->DwCollectData( NULL, // Always query all data
											  0, // Use 0-relative indices
											  reinterpret_cast<LPVOID *>(&lpbPerfData),
											  lpdwcbPerfData,
											  &dwcObjectTypes );
	}

	//	NOT IMPLEMENTED
	//
	CW3Monitor& operator=( const CW3Monitor& );
	CW3Monitor( const CW3Monitor& );

public:
	static BOOL W3MergeDavPerformanceData( DWORD dwServerId, W3_STATISTICS_1 * pW3Stats );
	static VOID W3CloseDavPerformanceData()
	{
		DestroyInstance();
		g_fCreatedMonitor = FALSE;
	}
};

//	------------------------------------------------------------------------
//
//	CW3Monitor::FInitialize()
//
BOOL
CW3Monitor::FInitialize()
{

    //
	//	Initialize the shared memory heap
	//
	if ( !m_smh.FInitialize( gc_wszSignature ) )
	{
		DWORD dwResult = GetLastError();

		DebugTrace( "CW3Monitor::FInitialize() - Error initializing shared memory heap %d\n", dwResult );

		return FALSE;
	}

	//
	//	Bind to the counter data
	//
#ifdef COMPILE_WITHOUT_DAV

#else

    m_pCounterData = NewCounterMonitor( gc_wszSignature );

	if ( !m_pCounterData.get() )
	{

		DWORD dwResult = GetLastError();

		DebugTrace( "CW3Monitor::FInitialize() - Error binding to counter data %d\n", dwResult );

		return FALSE;
	}


#endif

    return TRUE;

}

//	------------------------------------------------------------------------
//
//	CW3Monitor::W3MergeDavPerformanceData()
//
BOOL
CW3Monitor::W3MergeDavPerformanceData( DWORD dwServerId, W3_STATISTICS_1 * pW3Stats )
{

	BYTE * lpbDavData = NULL;
	PERF_OBJECT_TYPE * ppot = NULL;
	PERF_COUNTER_DEFINITION * rgpcd = NULL;
	DWORD dwibServerId = 0;
	PERF_INSTANCE_DEFINITION * ppid = NULL;
	PERF_COUNTER_BLOCK * ppcb;
	LONG lcInstances;
	DWORD iCtr;
	BOOL fRet = FALSE;

	//
	//	Create the monitor on demand
	//

	if ( !g_fCreatedMonitor )
	{
		g_fInitializedMonitor = CreateInstance().FInitialize();
		g_fCreatedMonitor = TRUE;
	}

	//
	//	If we failed to init the monitor, then we can't get any
	//	performance data.  Since we can't fail this call, just leave
	//	the existing statistics alone.
	//
	if ( !g_fInitializedMonitor )
		goto ret;


	//
	//	From here out we always return TRUE
	//
	fRet = TRUE;

	//
	//	Try collecting the data.  If our buffer is too small, double
	//	its size repeatedly until it's big enough.  The initial guess
	//	should be large enough to succeed most of the time.
	//
	for ( ;; )
	{
		DWORD cbDavDataAlloc;
		DWORD cbDavData;
		DWORD dwCollectResult;

		//	If we have a buffer from a previous trip around the loop
		//	then free it.
		//
		if (lpbDavData)
			delete [] lpbDavData;

		cbDavDataAlloc = Instance().m_cbDavDataAlloc;
		cbDavData = cbDavDataAlloc;
		lpbDavData = new BYTE[cbDavData];
		if (NULL == lpbDavData)
		{
			DebugTrace( "W3MergeDavPerformanceData() - OOM allocating buffer for DAV perf data\n" );
			goto ret;
		}

		dwCollectResult = Instance().
						  DwCollectPerformanceData( lpbDavData,
													&cbDavData );

		if ( ERROR_SUCCESS == dwCollectResult )
		{
			if ( 0 != cbDavData )
			{
				break;
			}
			else
			{
				DebugTrace( "W3MergeDavPerformanceData() - No instances from which to collect data\n" );
				goto ret;
			}
		}

		if ( ERROR_MORE_DATA != dwCollectResult )
		{
			DebugTrace( "W3MergeDavPerformanceData() - Error collecting DAV perf data (%d)\n", dwCollectResult );
			goto ret;
		}

		Instance().m_cbDavDataAlloc = 2 * cbDavDataAlloc;
	}

	//
	//	Locate the HTTPEXT perf object (should be the first
	//	thing returned) and make sure it looks reasonable.
	//
	ppot = reinterpret_cast<PERF_OBJECT_TYPE *>( lpbDavData );

	if ( ppot->NumCounters < 1 )
	{
		DebugTrace( "W3MergeDavPerformanceData() - NumCounters < 1?" );
		goto ret;
	}

	if ( ppot->NumInstances < 1 )
	{
		DebugTrace( "W3MergeDavPerformanceData() - NumInstances < 1?" );
		goto ret;
	}

	//
	//	Locate the HTTPEXT counter definitions.
	//
	rgpcd = reinterpret_cast<PERF_COUNTER_DEFINITION *>(
				reinterpret_cast<LPBYTE>(ppot) + ppot->HeaderLength );

	//
	//	Locate the server ID counter.  This counter tells us what
	//	instance of the W3Ctrs data to merge into, so bail if we can't
	//	find it or if it looks wrong.
	//
	for ( iCtr = 0; iCtr < ppot->NumCounters; iCtr++ )
	{
		if ( rgpcd[iCtr].CounterNameTitleIndex == HTTPEXT_COUNTER_SERVER_ID )
		{
			if ( rgpcd[iCtr].CounterSize == sizeof(DWORD) &&
				 rgpcd[iCtr].CounterType == (PERF_DISPLAY_NOSHOW |
											 PERF_SIZE_DWORD |
											 PERF_TYPE_NUMBER) )
			{
				dwibServerId = rgpcd[iCtr].CounterOffset;
				break;
			}
			else
			{
				DebugTrace( "W3MergePerformanceData() - Server ID counter doesn't look right.  Bailing...\n" );
				goto ret;
			}
		}
	}

	if ( !dwibServerId )
	{
		DebugTrace( "W3MergePerformanceData() - Couldn't find server ID counter.  Bailing...\n" );
		goto ret;
	}

	//
	//	Now go through each instance of the HTTPEXT counters and merge the data
	//	from that instance into the correct W3Ctrs counter instance according
	//	to server ID.
	//
	ppid = reinterpret_cast<PERF_INSTANCE_DEFINITION *>(
			reinterpret_cast<LPBYTE>(ppot) + ppot->DefinitionLength );

	for ( lcInstances = ppot->NumInstances;
		  lcInstances-- > 0;
		  ppid = reinterpret_cast<PERF_INSTANCE_DEFINITION *>(
			  reinterpret_cast<LPBYTE>(ppcb) + ppcb->ByteLength ) )
	{
		ppcb = reinterpret_cast<PERF_COUNTER_BLOCK *>(
				reinterpret_cast<LPBYTE>(ppid) + ppid->ByteLength );

		//
		//	Get the server ID of this instance.
		//
		DWORD dwServerIdInstance =
			*reinterpret_cast<LPDWORD>(
				reinterpret_cast<LPBYTE>(ppcb) + dwibServerId);

		//
		//	If the server ID of this instance isn't the one
		//	we want then keep looking.
		//
		if ( dwServerIdInstance != dwServerId )
			continue;

		//
		//	The server IDs match, so sum in the info for this instance.
		//	NOTE: Since each vroot has its own instance, there may be
		//	multiple instances with the same server ID.  Sum them all.
		//
		//	Go through all the counters in the HTTPEXT instance
		//	and update the W3 statistics data.
		//
		for ( DWORD iCounter = 0;
			  iCounter < ppot->NumCounters;
			  iCounter++ )
		{
			PERF_COUNTER_DEFINITION * ppcd = &rgpcd[iCounter];

			switch ( ppcd->CounterNameTitleIndex )
			{
				case HTTPEXT_COUNTER_TOTAL_GET_REQUESTS:
				case HTTPEXT_COUNTER_TOTAL_HEAD_REQUESTS:
				case HTTPEXT_COUNTER_TOTAL_POST_REQUESTS:
				case HTTPEXT_COUNTER_TOTAL_DELETE_REQUESTS:
				case HTTPEXT_COUNTER_TOTAL_OTHER_REQUESTS:
				{
					//
					//	These values are already recorded
					//	in the statistics, so don't do anything
					//	more with them here.
					//
					break;
				}

				case HTTPEXT_COUNTER_TOTAL_PUT_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalFilesReceived += dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_OPTIONS_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalOptions += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_COPY_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalCopy += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_MOVE_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalMove += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_MKCOL_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalMkcol += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_PROPFIND_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalPropfind += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_PROPPATCH_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalProppatch += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_SEARCH_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalSearch += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_LOCK_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalLock += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_UNLOCK_REQUESTS:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalUnlock += dwValue;
						pW3Stats->TotalOthers -= dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_404_RESPONSES:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalNotFoundErrors += dwValue;
					}

					break;
				}

				case HTTPEXT_COUNTER_TOTAL_423_RESPONSES:
				{
					if ( ppcd->CounterType == PERF_COUNTER_RAWCOUNT &&
						 ppcd->CounterSize == sizeof(DWORD) )
					{
						DWORD dwValue = *reinterpret_cast<LPDWORD>(
							reinterpret_cast<LPBYTE>(ppcb) + ppcd->CounterOffset );

						pW3Stats->TotalLockedErrors += dwValue;
					}

					break;
				}

				default:
				{
					//
					//	We either don't care about or don't understand
					//	other counters, so skip them.
					//
					break;
				}
			}
		}
	}

ret:
	if (lpbDavData)
		delete [] lpbDavData;

	return fRet;

}


//	========================================================================
//
//	CLASS CW3MonitorInit
//
//	Refcounted global initialization class that controls the lifetime of
//	the singleton CW3Monitor instance.  Calls to collect performance data
//	are done in the scope of a reference to this class so that the server
//	can be taken down on one thread while another thread is in the middle
//	of -- or just beginning to -- collect data.  Whichever thread releases
//	the last reference to this class will be the one to close the counters.
//	
class CW3MonitorInit : private RefCountedGlobal<CW3MonitorInit>
{
	//
	//	Friend declarations required by RefCountedGlobal template
	//
	friend class Singleton<CW3MonitorInit>;
	friend class RefCountedGlobal<CW3MonitorInit>;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CW3MonitorInit()
	{
	}

	BOOL FInit()
	{
		return TRUE;
	}

	~CW3MonitorInit()
	{
		CW3Monitor::W3CloseDavPerformanceData();
	}

	//	NOT IMPLEMENTED
	//
	CW3MonitorInit( const CW3MonitorInit& );
	CW3MonitorInit& operator=( const CW3MonitorInit& );

public:
	using RefCountedGlobal<CW3MonitorInit>::DwInitRef;
	using RefCountedGlobal<CW3MonitorInit>::DeinitRef;
};


//	========================================================================
//
//	PUBLIC INTERFACE
//

//	------------------------------------------------------------------------
//
//	W3MergeDavPerformanceData()
//
EXTERN_C BOOL __fastcall
W3MergeDavPerformanceData( DWORD dwServerId, W3_STATISTICS_1 * pW3Stats )
{
	BOOL fResult;

	CW3MonitorInit::DwInitRef();

	fResult = CW3Monitor::W3MergeDavPerformanceData( dwServerId, pW3Stats );

	CW3MonitorInit::DeinitRef();

	return fResult;
}

//	------------------------------------------------------------------------
//
//	W3OpenDavPerformanceData()
//
EXTERN_C VOID __fastcall
W3OpenDavPerformanceData()
{
	CW3MonitorInit::DwInitRef();
}

//	------------------------------------------------------------------------
//
//	W3CloseDavPerformanceData()
//
EXTERN_C VOID __fastcall
W3CloseDavPerformanceData()
{
	CW3MonitorInit::DeinitRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the W3 Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        JohnL   ????
        MuraliK     11-July-1995 Used Ipc() functions from Inetsvcs.dll

*/


#include "w3p.hxx"
#include "wamexec.hxx"
#include "mtacb.h"
#include "gip.h"

//
// RPC related includes
//

extern "C" {
#include "inetinfo.h"
#include <timer.h>
#include "w3svci_s.h"
#include <inetsvcs.h>

//
// system event log id
//
#include "w3msg.h"
};

#include <dsgetdc.h>

//
//  Private constants.
//

BOOL        fAnySecureFilters = FALSE;
BOOL        fComInitialized = FALSE;
HANDLE      g_hPhaseSync = NULL;

//
// for PDC hack
//

#define VIRTUAL_ROOTS_KEY_A     "Virtual Roots"
#define HTTP_EXT_MAPS           "Script Map"

//
//  Private globals.
//

DEFINE_TSVC_INFO_INTERFACE();



#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisW3ServerGuid, 
0x784d8919, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
DECLARE_DEBUG_PRINTS_OBJECT();
#else
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();
#endif

//
// The following critical section synchronizes execution in ServiceEntry().
// This is necessary because the NT Service Controller may reissue a service
// start notification immediately after we have set our status to stopped.
// This can lead to an unpleasant race condition in ServiceEntry() as one
// thread cleans up global state as another thread is initializing it.
//

CRITICAL_SECTION g_csServiceEntryLock;

//
//  Private prototypes.
//

APIERR InitializeService( LPVOID pContext );
APIERR TerminateService( LPVOID pContext );

VOID LoopCheckingForDrainOfConnections(VOID);

DWORD InitializeExtension( VOID);

extern DWORD InitializeWriteState(VOID);
extern VOID  TerminateWriteState(VOID);

//
//  Public functions.
//

VOID
ServiceEntry(
    DWORD                   cArgs,
    LPSTR                   pArgs[],
    PTCPSVCS_GLOBAL_DATA    pGlobalData     // unused
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    Arguments:
        cArgs - Number of command line arguments to this service.

        pArgs - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    APIERR err = NO_ERROR;
    BOOL fInitSvcObject = FALSE;

    EnterCriticalSection( &g_csServiceEntryLock );

    if ( !InitCommonDlls() )
    {
        err = GetLastError();
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    //
    // Initialize Globals
    //

    err = InitializeGlobals();
    if ( err != NO_ERROR ) {
        goto exit;
    }

    //
    // Initialize phase synchronization event
    //
    
    g_hPhaseSync = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( g_hPhaseSync == NULL )
    {
        err = GetLastError();
        goto exit;
    }
    
    //
    //  Initialize the service status structure.
    //

    g_pInetSvc = new W3_IIS_SERVICE(
                                W3_SERVICE_NAME_A,
                                W3_MODULE_NAME,
                                W3_PARAMETERS_KEY,
                                INET_HTTP_SVC_ID,
                                INET_W3_SVCLOC_ID,
                                TRUE,
                                DEF_ACCEPTEX_RECV_BUFFER_SIZE,
                                W3OnConnect,
                                W3OnConnectEx,
                                W3Completion
                                );

    //
    //  If we couldn't allocate memory for the service info struct, then the
    //  machine is really hosed.
    //

    if ( (g_pInetSvc != NULL)     &&
          ((W3_IIS_SERVICE *) g_pInetSvc)->QueryGlobalFilterList() &&
          g_pInetSvc->IsActive() )
    {
        fInitSvcObject = TRUE;

        if ( g_pstrMovedMessage = new STR )
        {
            g_pInetSvc->LoadStr( *g_pstrMovedMessage, IDS_URL_MOVED );

            err = g_pInetSvc->StartServiceOperation(
                                        SERVICE_CTRL_HANDLER(),
                                        InitializeService,
                                        TerminateService
                                        );
        }
        else
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( err )
        {
                //
                //  The event has already been logged
                //

                DBGPRINTF(( DBG_CONTEXT,
                           "HTTP ServiceEntry: StartServiceOperation returned %d\n",
                           err ));
        }
    } else if ( g_pInetSvc == NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        err = g_pInetSvc->QueryCurrentServiceError();
    }

exit:

    if ( g_pInetSvc != NULL ) {
        g_pInetSvc->CloseService( );
    }
    
    if ( g_hPhaseSync != NULL ) {
        CloseHandle( g_hPhaseSync );
        g_hPhaseSync = NULL;
    }

    if ( g_pstrMovedMessage )
    {
        delete g_pstrMovedMessage;
    }

    TerminateGlobals( );

    TerminateCommonDlls();
    LeaveCriticalSection( &g_csServiceEntryLock );

notify_scm:
    //
    // We need to tell the Service Control Manager that the service
    // is stopped if we haven't called g_pInetSvc->StartServiceOperation.
    //  1) InitCommonDlls fails, or
    //  2) InitializeGlobals failed, or
    //  3) new operator failed, or
    //  4) W3_IIS_SERVICE constructor couldn't initialize properly
    //

    if ( !fInitSvcObject ) {
        SERVICE_STATUS_HANDLE hsvcStatus;
        SERVICE_STATUS svcStatus;

        hsvcStatus = RegisterServiceCtrlHandler( W3_SERVICE_NAME,
                                                 SERVICE_CTRL_HANDLER() );


        if ( hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
            svcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            svcStatus.dwCurrentState = SERVICE_STOPPED;
            svcStatus.dwWin32ExitCode = err;
            svcStatus.dwServiceSpecificExitCode = err;
            svcStatus.dwControlsAccepted = 0;
            svcStatus.dwCheckPoint = 0;
            svcStatus.dwWaitHint = 0;

            SetServiceStatus( hsvcStatus, (LPSERVICE_STATUS) &svcStatus );
        }
    }


} // ServiceEntry

//
//  Private functions.
//

APIERR
InitializeService(
            LPVOID pContext
            )
/*++

    Routine:
        This function initializes the various W3 Service components.

    Arguments:
        pContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err;
    PW3_IIS_SERVICE psi = (PW3_IIS_SERVICE)pContext;

    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo;


    IF_DEBUG( SERVICE_CTRL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "initializing service\n" ));
    }

    //
    // Initialize the Digest Authentication and NT Cert Mapper Capabilities here. We did not
    // initialize them with other capability checks in AdvertiseServiceInfo because net calls
    // take a significant amount of time resulting in Service Control Manager timeouts.
    //
    // The criterion for NT Cert Mapper is that htis machine is a member of a NT5 domain.
    // In addition, for Digest Authentication, the PDC needs to be running Directory Services
    // should have the "Capture Clear Text Password" flag set (Presently we only check the first
    // 2 requirements).
    //

    if (NO_ERROR == DsGetDcName( NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 DS_PDC_REQUIRED | DS_DIRECTORY_SERVICE_PREFERRED,
                                 &pDomainControllerInfo))
    {
        CHAR        szServiceKey[MAX_PATH+1];
        DWORD       capabilities = 0;
        MB          mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
        GUID        nullguid = {0};

        if ( nullguid != pDomainControllerInfo->DomainGuid)
        {

            //
            // NT5 DC. Add the NT Certmap Support capability to the already advertized capabilities.
            //

            strcpy( szServiceKey, IIS_MD_LOCAL_MACHINE_PATH "/" "W3SVC");

            if ( mb.Open( szServiceKey, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
            {
                mb.GetDword(IIS_MD_SVC_INFO_PATH,
                            MD_SERVER_CAPABILITIES,
                            IIS_MD_UT_SERVER,
                            &capabilities,
                            0);

                capabilities |= IIS_CAP1_NT_CERTMAP_SUPPORT;

                if ( pDomainControllerInfo->Flags & DS_DS_FLAG)
                {
                    capabilities |= IIS_CAP1_DIGEST_SUPPORT;
                }

                if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                                   MD_SERVER_CAPABILITIES,
                                   IIS_MD_UT_SERVER,
                                   capabilities,
                                   0 ))
                {
                     DBGPRINTF((DBG_CONTEXT,
                                 "Error %d setting capabilities flag %x\n",
                                 GetLastError(), capabilities));
                }

                mb.Close();
            }
            else
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[InitializeService] Cannot open MB path %s, error %lu\n",
                            szServiceKey, GetLastError() ));
            }
        }

        NetApiBufferFree( pDomainControllerInfo);
    }

    //
    // init com - we will need it to co-create wams
    //

    if( FAILED( err = CoInitializeEx(
                                NULL,                       // void *  pvReserved,  //Reserved - must be NULL
                                COINIT_MULTITHREADED        // DWORD  dwCoInit      //COINIT value
                                | COINIT_SPEED_OVER_MEMORY  // UNDONE are these the right flags?
                               )))
    {

        if ( err != E_INVALIDARG ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "W3SVC: CoInitializeEx failed, error %lu\n",
                        err ));
            return err;
        }
    }

    fComInitialized = TRUE;

    //
    // Initialize FTM instance
    //
    if( FAILED( err = CFTMImplementation::Init() ) ) {
        DBGPRINTF( (DBG_CONTEXT,
                    "W3SVC: Failure in CFTMImplementation::Init, error %x\n",
                    err ));
        return err;
    }

    //
    // Initialize MTA callback and GIP table for calling WAMs
    //
    if( FAILED( err = InitMTACallbacks() ) ) {
        DBGPRINTF( (DBG_CONTEXT,
                    "W3SVC: Failure to initialize MTACB API, error %08x\n",
                    err ));

        return err;
    }


    if( FAILED( err = g_GIPAPI.Init() ) ) {
        DBGPRINTF( (DBG_CONTEXT,
                    "W3SVC: Failure to initialize GIP API, error %08x\n",
                    err ));

        return err;
    }

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.  Globals should be
    //  initialized first, then the event logger.  After
    //  the event logger is initialized, the other components
    //  may be initialized in any order with one exception.
    //  InitializeSockets must be the last initialization
    //  routine called.  It kicks off the main socket connection
    //  thread.
    //

    if( ( err = CLIENT_CONN::Initialize() )                         ||
        ( err = HTTP_REQUEST::Initialize() )                        ||
        ( err = InitializeWriteState() )                            ||
        ( err = InitializeOleHack())                                ||
        ( err = InitializeExtension() )                             ||
        ( err = InitializeCGI() )                                   ||
        ( err = psi->InitializeDiscovery( ))                        ||
        ( err = ReadRegistryExtMap())                               ||
#if defined(CAL_ENABLED)
        ( err = InitializeCal( psi->QueryGlobalStatistics(),
                               psi->QueryCalVcPerLicense(),
                               psi->QueryCalAuthReserveTimeout(),
                               psi->QueryCalSslReserveTimeout() ))  ||
#endif
        ( err = psi->InitializeSockets( ))                  ||
        ( err = WriteConfiguration()) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "cannot initialize service, error %lu\n",
                    err ));

        return err;
    }

    //
    // Read and activate all the instances configured
    //

    DBG_ASSERT(g_pW3Stats);
    g_pW3Stats->UpdateStartTime();

    InitializeInstances( psi );

    //
    //  Success!
    //

    IF_DEBUG( SERVICE_CTRL )
    {
        DBGPRINTF(( DBG_CONTEXT, "Service initialized\n" ));
    }


    return NO_ERROR;

} // InitializeService

DWORD
TerminateServicePhase1( 
    IN LPVOID               pvContext
)
/*++

Routine Description:

    Terminate W3 Service Phase 1:  Stop all current connections/requests

Arguments:

    pvContext - Service
    
Return Value:

    ERROR_SUCCESS if successful, else Win32 Error
    
--*/
{
    //
    // Stop processing job limits and work items.
    //

    W3_LIMIT_JOB_THREAD::StopLimitJobThread();
    W3_JOB_QUEUE::StopJobQueue();

    //
    // Stop all CGI processes
    //

    KillCGIProcess();  

    //
    //  Blow away any connected users.  We do this before calling the WAM
    //  shutdown code so ASP apps with long network IOs will abort in a
    //  timely fashion.
    //

    CLIENT_CONN::DisconnectAllUsers();

    //
    // Start shutdown of wam dictator, do other stuff,
    // then uninit wam dictator below
    //

    DBG_ASSERT(g_pWamDictator);
    g_pWamDictator->StartShutdown();

    //
    // Uninit WamDictator.
    //

    DBG_ASSERT(g_pWamDictator);
    g_pWamDictator->UninitWamDictator();

    //
    //  By now all connections should have gone away
    //  However, we carry a large amount of inconsistencies in our shutdown code
    //   => some connections may not have shutdown.
    //  Let us loop and check for this straggler requests
    //
    LoopCheckingForDrainOfConnections();
   
    //
    // Allow the phase 2 shutdown to start
    //
    
    SetEvent( g_hPhaseSync );
    
    return ERROR_SUCCESS;
}

DWORD
TerminateServicePhase2(
    IN LPVOID               pvContext
)
/*++

Routine Description:

    Terminate W3 Service Phase 2:  Cleanup state

Arguments:

    pvContext - Service
    
Return Value:

    ERROR_SUCCESS if successful, else Win32 Error
    
--*/
{
    PW3_IIS_SERVICE psi = (PW3_IIS_SERVICE)pvContext;
    DWORD           err;

    //
    // Wait for phase 1 completion
    //
    
    WaitForSingleObject( g_hPhaseSync, INFINITE );
    
    //
    // Stop all networking I/O components now
    //
    g_pInetSvc->ShutdownService( );
    (VOID)psi->CleanupSockets( );

    //
    // Cleanup state now
    //

    TerminateOleHack();

    if ( (err = psi->TerminateDiscovery()) != NO_ERROR)
    {
        DBGPRINTF(( DBG_CONTEXT, "TerminateDiscovery() failed. Error = %u\n",
                   err));
    }


    CLIENT_CONN::Terminate();
    HTTP_REQUEST::Terminate();
    TerminateWriteState();

    FreeRegistryExtMap();
    TerminateCGI();

    // delay the destruction of WamDictator.
    // Uninit wamreq allocation cache is done in the destruction.

    delete g_pWamDictator;

    IF_DEBUG( SERVICE_CTRL )
    {
        DBGPRINTF(( DBG_CONTEXT,"service terminated\n" ));
    }

    //
    //  Delete the metacache items
    //

    TsCacheFlush( INET_HTTP_SVC_ID );
    TsFlushMetaCache(METACACHE_W3_SERVER_ID, TRUE);

#if defined(CAL_ENABLED)
    TerminateCal();
#endif

    //
    // cleanup MTA callback & GIP table
    //
    UnInitMTACallbacks();
    g_GIPAPI.UnInit();
    CFTMImplementation::UnInit();

    if( fComInitialized )
    {
        CoUninitialize();
    }
    
    psi->IndicateShutdownComplete();

    return NO_ERROR;
} 

DWORD
TerminateService(
    IN PVOID                    pvContext
)
/*++

Routine Description:

    Called to shutdown service

Arguments:

    pvContext - Service
    
Return Value:

    ERROR_SUCCESS if successful, else Win32 Error
    
--*/
{
    PW3_IIS_SERVICE psi = (PW3_IIS_SERVICE)pvContext;


    DBG_ASSERT(g_pW3Stats);
    g_pW3Stats->UpdateStopTime();

    TerminateServicePhase1( pvContext );
    
    return W3_IIS_SERVICE::DereferenceW3Service( pvContext );
}

DWORD
InitializeExtension( VOID)
{
    // Init wam dictator
    g_pWamDictator = new WAM_DICTATOR;
    if (!g_pWamDictator)
        {
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

    return ( g_pWamDictator->InitWamDictator() );

} // InitializeExtensions()



VOID
PrintClientConnStateOnDrain(IN CLIENT_CONN * pConn)
{
    DBGPRINTF(( DBG_CONTEXT,
                "[%d]"
                "[OnDrainOfConns] Stale CC @ 0x%p (HR: 0x%p), "
                "CC:State = %d (HR:State =%d), CC:Ref = %u;"
                " W3Endpoint = 0x%p,"
                " AtqContext = 0x%p,"
                " WamRequest = 0x%p,"
                " URL=%s\n; "
                ,
                GetCurrentThreadId(),
                pConn,
                (pConn ? pConn->QueryHttpReq() : NULL ),
                (pConn ? pConn->QueryState() : -1 ),
                (pConn ? pConn->QueryHttpReq()->QueryState() : NULL ),
                (pConn ? pConn->QueryRefCount() : -1 ),
                (pConn ? pConn->QueryW3Endpoint() : NULL ),
                (pConn ? pConn->QueryAtqContext() : NULL ),
                (pConn ? (((HTTP_REQUEST * ) pConn->QueryHttpReq())->
                 QueryWamRequest()) : NULL ),
                (pConn ? pConn->QueryHttpReq()->QueryURL() : NULL )
                ));
} // PrintClientConnStateOnDrain()


VOID
LoopCheckingForDrainOfConnections(VOID)
{
    CHAR rgchConns[1024];

    //
    //  This chunck of code is instrumentation to help catch any client
    //  requests that don't get cleaned up properly
    //

    LockGlobals();

    if ( !IsListEmpty( &listConnections ))
    {
        LIST_ENTRY * pEntry;
        DWORD        cConns = 0;

        for ( pEntry  = listConnections.Flink;
              pEntry != &listConnections;
              pEntry  = pEntry->Flink )
        {
            CLIENT_CONN * pConn = CONTAINING_RECORD( pEntry,
                                                     CLIENT_CONN,
                                                     ListEntry );

            PrintClientConnStateOnDrain( pConn);
            cConns++;
        }

        UnlockGlobals();

        wsprintf( rgchConns,
                  "\n--------------------\n"
                  "[W3Svc: TerminateService] Waiting for 2 minutes for %d straggler"
                  " conns to drain\n",
                  cConns );
        OutputDebugString( rgchConns);

        //
        // loop for 2 minutes trying to drain clients. Bail if it takes longer.
        //

        CONST DWORD cWaitMax       = 120000;      // in mseconds
        CONST DWORD cSleepInterval = 2000;        // in mseconds

        for(DWORD cWait = 0; cWait <= cWaitMax; cWait += cSleepInterval)
        {
            Sleep( cSleepInterval );

            LockGlobals();
            if ( IsListEmpty( &listConnections ))
            {
                UnlockGlobals();
                break;
            }

            for ( pEntry  = listConnections.Flink, cConns = 0;
                  pEntry != &listConnections;
                  pEntry  = pEntry->Flink )
            {
                CLIENT_CONN * pConn = CONTAINING_RECORD( pEntry,
                                                         CLIENT_CONN,
                                                         ListEntry );

                PrintClientConnStateOnDrain( pConn);
                cConns++;
            }

            UnlockGlobals();

            wsprintf( rgchConns,
                      "\n--------------------\n"
                      "[W3Svc] Waited for %d seconds for %d straggler"
                      " conns to drain\n",
                      cWait/1000, cConns );
            OutputDebugString( rgchConns);
        }

        //
        // Check for stragglers and log them to the system event log.
        //

        if (cWait > cWaitMax)
        {
            DWORD       cStragglerCount = 0;
            STR         strStragglerConnections = "\r\n";
            STR         strConnectionURL;

            LockGlobals();

            for ( pEntry = listConnections.Flink;
                  pEntry != &listConnections;
                  pEntry = pEntry->Flink)
            {
                CLIENT_CONN * pConn = CONTAINING_RECORD ( pEntry,
                                                          CLIENT_CONN,
                                                          ListEntry);

                if ( pConn->IsValid() && pConn->CheckSignature() &&
                    (NULL != pConn->QueryHttpReq()) &&
                    (NULL != pConn->QueryHttpReq()->QueryURL()))
                {
                    CHAR    *pCh = NULL;

                    strConnectionURL.Copy("\r\n");
                    strConnectionURL.Append(pConn->QueryHttpReq()->QueryURL());
                    strConnectionURL.Append("\r\n");

                    //
                    // Check if we already have this URL in the list. If not add it
                    //

                    if ( NULL == strstr( strStragglerConnections.QueryStr(), strConnectionURL.QueryStr()))
                    {
                        strStragglerConnections.Append(strConnectionURL.QueryStr()+2); //Don't copy extra \r\n
                        cStragglerCount++;
                    }
                }
            }

            if (cStragglerCount > 0)
            {
                const CHAR *pszEventDescription[1];

                pszEventDescription[0] = strStragglerConnections.QueryStr(),

                g_pInetSvc->LogEvent(W3_EVENT_FAILED_CLOSE_CC_SHUTDOWN,
                                     1,
                                     pszEventDescription,
                                     0);
            }

            UnlockGlobals();
        }
    }
    else
    {
        UnlockGlobals();
    }

    return;
} // LoopCheckingForDrainOfConnections()

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved
    )
{

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( W3_MODULE_NAME );
        SET_DEBUG_FLAGS( DEBUG_ERROR );
#else
        CREATE_DEBUG_PRINT_OBJECT( W3_MODULE_NAME, IisW3ServerGuid );
#endif

        DBG_REQUIRE( DisableThreadLibraryCalls( hDll ) );
        INITIALIZE_CRITICAL_SECTION( &g_csServiceEntryLock );

        break;

    case DLL_PROCESS_DETACH:

        DELETE_DEBUG_PRINT_OBJECT();
        DeleteCriticalSection( &g_csServiceEntryLock );
        break;

    }

    return TRUE;

}   // DllMain

APIERR
W3_IIS_SERVICE::ReferenceW3Service(
    IN PVOID                pService
)
/*++

Routine Description:

    Reference W3 service

Arguments:

    pService - Service to reference

Returns:

    None

--*/
{
    InterlockedIncrement( &( ((PW3_IIS_SERVICE)pService)->m_cReferences ) );
    return ERROR_SUCCESS;
}


APIERR
W3_IIS_SERVICE::DereferenceW3Service(
    IN PVOID                pService
)
/*++

Routine Description:

    De-reference W3 service

Arguments:

    pService - Service to reference

Returns:

    None

--*/
{
    if ( !InterlockedDecrement( &( ((PW3_IIS_SERVICE)pService)->m_cReferences ) ) )
    {
        return TerminateServicePhase2( pService );
    }
    else if ( ((PW3_IIS_SERVICE)pService)->QueryCurrentServiceState() == SERVICE_STOP_PENDING )
    {
        return ERROR_IO_PENDING;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\iisw3.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        iisw3.cxx

   Abstract:

        This module defines the W3_IIS_SERVICE class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996

--*/

#include "w3p.hxx"
#include <issched.hxx>
#include "wamexec.hxx"
#include "httpxpc.h"

#define ADJUST_FOR_MINMAX(a,b,c) ((a)<(b) ? (b) : ((a)>(c) ? (c) : (a)))

VOID WINAPI
NotifyCert11Touched(
    VOID
    )
/*++

Routine Description:

    Notification function called when any Cert11 mapper modified in metabase

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    //
    // If someone has asked to be notified for SSL events, forward notification
    //

    if ( g_pSslKeysNotify )
    {
        (g_pSslKeysNotify)( SF_NOTIFY_MAPPER_CERT11_TOUCHED, NULL );
    }
}


BOOL
W3_IIS_SERVICE::AddInstanceInfo(
                     IN DWORD dwInstance,
                     IN BOOL fMigrateRoots
                     )
{
    PW3_SERVER_INSTANCE pInstance;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF(( DBG_CONTEXT,
            "AddInstanceInfo: instance %d reg %s\n", dwInstance, QueryRegParamKey() ));
    }

    //
    // Create the new instance
    //

    pInstance = new W3_SERVER_INSTANCE(
                                this,
                                dwInstance,
                                IPPORT_W3,
                                QueryRegParamKey(),
                                W3_ANONYMOUS_SECRET_W,
                                W3_ROOT_SECRET_W,
                                fMigrateRoots
                                );

    return AddInstanceInfoHelper( pInstance );

} // W3_IIS_SERVICE::AddInstanceInfo

DWORD
W3_IIS_SERVICE::DisconnectUsersByInstance(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Virtual callback invoked by IIS_SERVER_INSTANCE::StopInstance() to
    disconnect all users associated with the given instance.

    Arguments:

        pInstance - All users associated with this instance will be
            forcibly disconnected.

--*/
{

    CLIENT_CONN::DisconnectAllUsers( pInstance );
    return NO_ERROR;

}   // W3_IIS_SERVICE::DisconnectUsersByInstance

VOID
W3_IIS_SERVICE::StopInstanceProcs(
    IN IIS_SERVER_INSTANCE * pInstance
    )
{
    KillCGIInstanceProcs( (W3_SERVER_INSTANCE *)pInstance );
    DBG_ASSERT(g_pWamDictator != NULL);

    if (!g_pWamDictator)
        {
        return;
        }

    DWORD dwScheduledId;
        
    dwScheduledId = ScheduleWorkItem
                    (
                    WAM_DICTATOR::StopApplicationsByInstance,
                    (PVOID) pInstance,
                    0,
                    FALSE
                    );

    DBG_ASSERT(dwScheduledId != NULL);
}



DWORD
W3_IIS_SERVICE::GetServiceConfigInfoSize(
                    IN DWORD dwLevel
                    )
{
    switch (dwLevel) {
    case 1:
        return sizeof(W3_CONFIG_INFO);
    }

    return 0;

} // W3_IIS_SERVICE::GetServerConfigInfoSize


W3_IIS_SERVICE::W3_IIS_SERVICE(
        IN  LPCSTR                           pszServiceName,
        IN  LPCSTR                           pszModuleName,
        IN  LPCSTR                           pszRegParamKey,
        IN  DWORD                            dwServiceId,
        IN  ULONGLONG                        SvcLocId,
        IN  BOOL                             MultipleInstanceSupport,
        IN  DWORD                            cbAcceptExRecvBuffer,
        IN  ATQ_CONNECT_CALLBACK             pfnConnect,
        IN  ATQ_COMPLETION                   pfnConnectEx,
        IN  ATQ_COMPLETION                   pfnIoCompletion
        ) : IIS_SERVICE( pszServiceName,
                         pszModuleName,
                         pszRegParamKey,
                         dwServiceId,
                         SvcLocId,
                         MultipleInstanceSupport,
                         cbAcceptExRecvBuffer,
                         pfnConnect,
                         pfnConnectEx,
                         pfnIoCompletion
                         ),
            m_pGlobalFilterList( NULL ),
            m_cInProcISAPI     ( 0 ),
            m_astrInProcISAPI  ( NULL ),
            m_afISAPIDllName (NULL),
            m_hinstDav (NULL),
            m_cReferences( 1 )
{
    DWORD               err;

    m_pGlobalFilterList = InitializeFilters( &fAnySecureFilters, this );

    //
    // Set the notification function in NSEP for mapping ( NSEPM )
    //

    if ( QueryMDNseObject() != NULL ) {

        MB mbx( (IMDCOM*)QueryMDNseObject() );

        if ( mbx.Open( "", METADATA_PERMISSION_WRITE ) ) 
        {

            PVOID CallbackAddress = ::NotifyCert11Touched;
            
            mbx.SetData(
                    "",
                    MD_NOTIFY_CERT11_TOUCHED,
                    IIS_MD_UT_SERVER,
                    BINARY_METADATA,
                    (PVOID) &CallbackAddress,
                    sizeof(PVOID)
                    );

            mbx.Close();
        }
    }

    MB                  mb( (IMDCOM*)QueryMDObject() );
    DWORD               dw;

#if defined(CAL_ENABLED)
    m_CalVcPerLicense = DEFAULT_W3_CAL_VC_PER_CONNECT;
    m_CalW3Error = DEFAULT_W3_CAL_W3_ERROR;
    m_CalAuthReserveTimeout = DEFAULT_W3_CAL_AUTH_RESERVE_TIMEOUT;
    m_CalSslReserveTimeout = DEFAULT_W3_CAL_SSL_RESERVE_TIMEOUT;
    m_CalMode = DEFAULT_W3_CAL_MODE;

    if ( mb.Open( QueryMDPath(), METADATA_PERMISSION_READ ) )
    {
        if ( mb.GetDword( "",
                          MD_CAL_VC_PER_CONNECT,
                          IIS_MD_UT_SERVER,
                          &dw ) &&
             dw >= MIN_W3_CAL_VC_PER_CONNECT &&
             dw <= MAX_W3_CAL_VC_PER_CONNECT )
        {
            m_CalVcPerLicense = dw;
        }

        if ( mb.GetDword( "",
                          MD_CAL_W3_ERROR,
                          IIS_MD_UT_SERVER,
                          &dw ) )
        {
            m_CalW3Error = dw;
        }

        if ( mb.GetDword( "",
                          MD_CAL_AUTH_RESERVE_TIMEOUT,
                          IIS_MD_UT_SERVER,
                          &dw ) )
        {
            m_CalAuthReserveTimeout = ADJUST_FOR_MINMAX( dw,
                                                         MIN_CAL_RESERVE_TIMEOUT,
                                                         MAX_CAL_RESERVE_TIMEOUT);
        }

        if ( mb.GetDword( "",
                          MD_CAL_SSL_RESERVE_TIMEOUT,
                          IIS_MD_UT_SERVER,
                          &dw ) )
        {
            m_CalSslReserveTimeout = ADJUST_FOR_MINMAX( dw,
                                                        MIN_CAL_RESERVE_TIMEOUT,
                                                        MAX_CAL_RESERVE_TIMEOUT);
        }

        mb.Close();
    }
#endif

    ReadInProcISAPIList();

    GetDavDll();

    //
    // Iinit Dav performance data
    //
    W3OpenDavPerformanceData();

} // W3_IIS_SERVICE::W3_IIS_SERVICE

W3_IIS_SERVICE::~W3_IIS_SERVICE()
{
    //
    // Deinit Dav performance data
    //
    W3CloseDavPerformanceData();

    if ( m_pGlobalFilterList )
    {
        FILTER_LIST::Dereference( m_pGlobalFilterList );
    }

    //
    // Reset the notification function in NSEP for mapping ( NSEPM )
    //

    if ( QueryMDNseObject() != NULL ) {

        MB mbx( (IMDCOM*)QueryMDNseObject() );

        if ( mbx.Open( "", METADATA_PERMISSION_WRITE ) )
        {
            PVOID CallbackAddress = NULL;
            
            mbx.SetData(
                    "",
                    MD_NOTIFY_CERT11_TOUCHED,
                    IIS_MD_UT_SERVER,
                    BINARY_METADATA,
                    (PVOID) &CallbackAddress,
                    sizeof(PVOID)
                    );

            mbx.Close();
        }
    }

    //
    //  Free the in-process ISAPI Applications data
    //

    delete [] m_astrInProcISAPI;
    delete [] m_afISAPIDllName;

    if (m_hinstDav != NULL)
        {
        FreeLibrary(m_hinstDav);
        m_hinstDav = NULL;
        }
}


VOID
W3_IIS_SERVICE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this service

  Arguments:

    pcoChangeList - path and id that has changed

--*/
{
    DWORD   i;
    BOOL    fSslModified = FALSE;

    if ( g_pInetSvc == NULL )
    {
        return;
    }

    AcquireServiceLock();

    IIS_SERVICE::MDChangeNotify( pcoChangeList );


    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {
#if 0   // Unused in IIS 5
        case MD_SSL_PUBLIC_KEY:
        case MD_SSL_PRIVATE_KEY:
        case MD_SSL_KEY_PASSWORD:
#endif 
            //
            // Server cert properties
            //
        case MD_SSL_CERT_HASH:
        case MD_SSL_CERT_CONTAINER:
        case MD_SSL_CERT_PROVIDER:
        case MD_SSL_CERT_OPEN_FLAGS:
        case MD_SSL_CERT_STORE_NAME:

            //
            // Fortezza-specific properties 
            //
        case MD_SSL_CERT_IS_FORTEZZA:
        case MD_SSL_CERT_FORTEZZA_PIN:
        case MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER:
        case MD_SSL_CERT_FORTEZZA_PERSONALITY:
        case MD_SSL_CERT_FORTEZZA_PROG_PIN:

            //
            // Server CTL properties
            //
        case MD_SSL_CTL_IDENTIFIER:
        case MD_SSL_CTL_CONTAINER:
        case MD_SSL_CTL_PROVIDER:
        case MD_SSL_CTL_PROVIDER_TYPE:
        case MD_SSL_CTL_OPEN_FLAGS:
        case MD_SSL_CTL_STORE_NAME:
        case MD_SSL_CTL_SIGNER_HASH:
        case MD_SSL_USE_DS_MAPPER:

            fSslModified = TRUE;
            break;

        case MD_IN_PROCESS_ISAPI_APPS:
            ReadInProcISAPIList();
            break;

        case MD_CPU_APP_ENABLED:
        case MD_CPU_LOGGING_MASK:
        case MD_CPU_LIMITS_ENABLED:

            DWORD dwPathBufferLen;
            VOID *pvPath;
            dwPathBufferLen = strlen((LPSTR)pcoChangeList->pszMDPath) + 1;
            pvPath = new BYTE[dwPathBufferLen];
            if (pvPath != NULL)
            {
                memcpy(pvPath, pcoChangeList->pszMDPath, dwPathBufferLen);

                if (W3_JOB_QUEUE::QueueWorkItem( JQA_RESTART_ALL_APPS,
                                             NULL,
                                             pvPath ) != ERROR_SUCCESS)
                {

                    delete pvPath;

                }
            }
            break;

        default:
            break;
        }
    }

    ReleaseServiceLock();

    if ( fSslModified && g_pSslKeysNotify )
    {
        (g_pSslKeysNotify)( SF_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );
    }
}

BOOL
W3_IIS_SERVICE::GetGlobalStatistics(
    IN DWORD dwLevel,
    OUT PCHAR *pBuffer
    )
{
    APIERR err = NO_ERROR;

    switch( dwLevel )
    {
    case 0 :
        {
            LPW3_STATISTICS_1 pstats1;

            pstats1 = (W3_STATISTICS_1 *) MIDL_user_allocate( sizeof(W3_STATISTICS_1) );
            if( pstats1 == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                g_pW3Stats->CopyToStatsBuffer( pstats1 );
                *pBuffer = (PCHAR)pstats1;
            }
        }
        break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

    SetLastError(err);
    return(err == NO_ERROR);
}   // IIS_SERVICE::GetGlobalStatistics
BOOL 
W3_IIS_SERVICE::AggregateStatistics(
        IN PCHAR    pDestination,
        IN PCHAR    pSource
        )
{
    LPW3_STATISTICS_1   pStatDest = (LPW3_STATISTICS_1) pDestination;
    LPW3_STATISTICS_1   pStatSrc  = (LPW3_STATISTICS_1) pSource;

    if ((NULL == pDestination) || (NULL == pSource))
    {
        return FALSE;
    }
    
    pStatDest->TotalBytesSent.QuadPart      += pStatSrc->TotalBytesSent.QuadPart;
    pStatDest->TotalBytesReceived.QuadPart  += pStatSrc->TotalBytesReceived.QuadPart;

    pStatDest->TotalFilesSent               += pStatSrc->TotalFilesSent;
    pStatDest->TotalFilesReceived           += pStatSrc->TotalFilesReceived;
    
    pStatDest->CurrentAnonymousUsers        += pStatSrc->CurrentAnonymousUsers;
    pStatDest->CurrentNonAnonymousUsers     += pStatSrc->CurrentNonAnonymousUsers;
    pStatDest->TotalAnonymousUsers          += pStatSrc->TotalAnonymousUsers;
    pStatDest->TotalNonAnonymousUsers       += pStatSrc->TotalNonAnonymousUsers;
    pStatDest->MaxAnonymousUsers            += pStatSrc->MaxAnonymousUsers;
    pStatDest->MaxNonAnonymousUsers         += pStatSrc->MaxNonAnonymousUsers;

    //
    // Global values. do not add
    //
    
    pStatDest->CurrentConnections           = pStatSrc->CurrentConnections;
    pStatDest->MaxConnections               = pStatSrc->MaxConnections;
    pStatDest->ConnectionAttempts           = pStatSrc->ConnectionAttempts;
    
    pStatDest->LogonAttempts                += pStatSrc->LogonAttempts;
    
    pStatDest->TotalOptions                 += pStatSrc->TotalOptions;
    pStatDest->TotalGets                    += pStatSrc->TotalGets;
    pStatDest->TotalPosts                   += pStatSrc->TotalPosts;
    pStatDest->TotalHeads                   += pStatSrc->TotalHeads;
    pStatDest->TotalPuts                    += pStatSrc->TotalPuts;
    pStatDest->TotalDeletes                 += pStatSrc->TotalDeletes;
    pStatDest->TotalTraces                  += pStatSrc->TotalTraces;
    pStatDest->TotalMove                    += pStatSrc->TotalMove;
    pStatDest->TotalCopy                    += pStatSrc->TotalCopy;
    pStatDest->TotalMkcol                   += pStatSrc->TotalMkcol;
    pStatDest->TotalPropfind                += pStatSrc->TotalPropfind;
    pStatDest->TotalProppatch               += pStatSrc->TotalProppatch;
    pStatDest->TotalSearch                  += pStatSrc->TotalSearch;
    pStatDest->TotalLock                    += pStatSrc->TotalLock;
    pStatDest->TotalUnlock                  += pStatSrc->TotalUnlock;
    pStatDest->TotalOthers                  += pStatSrc->TotalOthers;
    
    pStatDest->TotalCGIRequests             += pStatSrc->TotalCGIRequests;
    pStatDest->TotalBGIRequests             += pStatSrc->TotalBGIRequests;
    pStatDest->TotalNotFoundErrors          += pStatSrc->TotalNotFoundErrors;

#if defined(CAL_ENABLED)
    
    pStatDest->CurrentCalAuth               += pStatSrc->CurrentCalAuth;
    pStatDest->MaxCalAuth                   += pStatSrc->MaxCalAuth;
    pStatDest->TotalFailedCalAuth           += pStatSrc->TotalFailedCalAuth;
    pStatDest->CurrentCalSsl                += pStatSrc->CurrentCalSsl;
    pStatDest->MaxCalSsl                    += pStatSrc->MaxCalSsl;
    pStatDest->TotalFailedCalSsl            += pStatSrc->TotalFailedCalSsl;
    
#endif
    
    pStatDest->CurrentCGIRequests           += pStatSrc->CurrentCGIRequests;
    pStatDest->CurrentBGIRequests           += pStatSrc->CurrentBGIRequests;
    pStatDest->MaxCGIRequests               += pStatSrc->MaxCGIRequests;
    pStatDest->MaxBGIRequests               += pStatSrc->MaxBGIRequests;
    
    // bandwidth throttling info
    
    pStatDest->CurrentBlockedRequests       += pStatSrc->CurrentBlockedRequests;
    pStatDest->TotalBlockedRequests         += pStatSrc->TotalBlockedRequests;
    pStatDest->TotalAllowedRequests         += pStatSrc->TotalAllowedRequests;
    pStatDest->TotalRejectedRequests        += pStatSrc->TotalRejectedRequests;
    pStatDest->MeasuredBw                   += pStatSrc->MeasuredBw;

    return TRUE;
}

inline BOOL
IsISAPIRelativePath( LPCSTR pszPath)
/*++
    Description:
        This function checks to see if the path specified contains
        no path-separators. If there are no path separators, then
        the given string refers to relative path.

    Arguments:
        pszPath - pointer to string containing the path for check

    Returns:
        TRUE - if this is a relative path
        FALSE - if the specified path is an absolute path
--*/
{
    LPCSTR pszPathSeparator;

    DBG_ASSERT( NULL != pszPath);

    pszPathSeparator = strchr( pszPath, '\\');

    //
    // if there is no path-separator => pszPathSeparator == NULL
    //   ==> return TRUE
    // if there is a path-separator => pszPathSeparator != NULL
    //   ==> return FALSE
    //
    return ( pszPathSeparator == NULL);

} // IsISAPIRelativePath()


static
VOID
AddFiltersToMultiSz(
    IN const MB &       mb,
    IN const char *     szFilterPath,
    IN OUT MULTISZ *    pmsz
    )
/*++

    Description:
        Add the ISAPI filters at the specified metabase path to pmsz.
        
        Called by AddAllFiltersToMultiSz.

    Arguments:
        mb              metabase key open to /LM/W3SVC
        szFilterPath    path of /Filters key relative to /LM/W3SVC
        pmsz            multisz containing the in proc dlls

    Return:
        Nothing - failure cases ignored.

--*/
{
    CHAR    szKeyName[MAX_PATH + 1];
    STR     strFilterPath;
    STR     strFullKeyName( szFilterPath );
    INT     pchFilterPath = ::strlen( szFilterPath );

    DWORD   i = 0;

    if( strFullKeyName.Append( "/", 1 ) )
    {
        while ( const_cast<MB &>(mb).EnumObjects( szFilterPath,
                                                  szKeyName, 
                                                  i++ ) )
        {
        
            if( strFullKeyName.Append( szKeyName ) )
            {
                if( const_cast<MB &>(mb).GetStr( strFullKeyName.QueryStr(),
                                                 MD_FILTER_IMAGE_PATH,
                                                 IIS_MD_UT_SERVER,
                                                 &strFilterPath ) )
                {
                    pmsz->Append( strFilterPath );
                }
            }
            strFullKeyName.SetLen( pchFilterPath + 1 );
        }
    }
}

static
VOID
AddAllFiltersToMultiSz(
    IN const MB &       mb,
    IN OUT MULTISZ *    pmsz
    )
/*++

    Description:

        This is designed to prevent ISAPI extension/filter
        combination dlls from running out of process.

        Add the base set of filters defined for the service to pmsz.
        Iterate through the sites and add the filters defined for
        each site.

    Arguments:

        mb              metabase key open to /LM/W3SVC
        pmsz            multisz containing the in proc dlls

    Return:
        Nothing - failure cases ignored.

--*/
{
    CHAR    szKeyName[MAX_PATH + 1];
    STR     strFullKeyName("/");
    DWORD   i = 0;
    DWORD   dwInstanceId = 0;

    AddFiltersToMultiSz( mb, IIS_MD_ISAPI_FILTERS, pmsz );

    while ( const_cast<MB &>(mb).EnumObjects( "",
                                              szKeyName,
                                              i++ ) )
    {
        dwInstanceId = ::atoi( szKeyName );
        if( 0 != dwInstanceId )
        {
            // This is a site.
            if( strFullKeyName.Append( szKeyName ) &&
                strFullKeyName.Append( IIS_MD_ISAPI_FILTERS ) )
            {
                AddFiltersToMultiSz( mb, strFullKeyName.QueryStr(), pmsz );
            }

            strFullKeyName.SetLen( 1 );
        }
    }
}


BOOL
W3_IIS_SERVICE::ReadInProcISAPIList(
    VOID
    )
/*++

  This method reads the list of ISAPI dlls that must be run in process

  Arguments:

--*/
{
    MB             mb( (IMDCOM*)QueryMDObject() );
    MULTISZ        msz;
    BOOL           fReturn = TRUE;

    if ( mb.Open( QueryMDPath(), METADATA_PERMISSION_READ ) &&
         mb.GetMultisz( "",
                        MD_IN_PROCESS_ISAPI_APPS,
                        IIS_MD_UT_SERVER,
                        &msz ))
    {
        m_InProcLock.Lock( TSRES_LOCK_WRITE );

        //
        //  Free the existing list
        //

        delete [] m_astrInProcISAPI;
        delete [] m_afISAPIDllName;

        
        m_InProcISAPItable.Clear();
        m_astrInProcISAPI = NULL;
        m_afISAPIDllName = NULL;

        m_cInProcISAPI = 0;

        //
        // Merge all the ISAPI filters into the in-proc list.
        //
        AddAllFiltersToMultiSz( mb, &msz );

        if ( msz.QueryStringCount() )
        {
            DWORD          i;
            const CHAR *   psz;
            const DWORD    cIsapis = msz.QueryStringCount();

            m_astrInProcISAPI = new STR[cIsapis];
            m_afISAPIDllName = new BOOL[cIsapis];

            //
            //  Initialize the relative paths
            //
            if (m_astrInProcISAPI != NULL  && m_afISAPIDllName != NULL)
            {
                for ( i = 0, psz = msz.First();
                      psz != NULL;
                      i++, psz = msz.Next( psz ) )
                {
                    if ( !m_astrInProcISAPI[i].Copy( psz ))
                    {
                        fReturn = FALSE;
                        break;
                    }

                    m_afISAPIDllName[i] = ( IsISAPIRelativePath( psz));
                    m_InProcISAPItable.InsertRecord(&m_astrInProcISAPI[i]);
                    m_cInProcISAPI++;
                }
            } else {
                fReturn = FALSE;
            }

            DBG_ASSERT(m_cInProcISAPI == cIsapis);
            
        }

        m_InProcLock.Unlock();
    }

    return fReturn;
}



VOID
W3_IIS_SERVICE::GetDavDll()
    {
    LONG    lReg = 0;
    HKEY    hKey = NULL;
    HRESULT hr = NOERROR;

    DBG_ASSERT(m_hinstDav == NULL);

    lReg = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                    "Software\\Microsoft\\InetStp",
                    0,
                    KEY_READ,
                    &hKey);

    if (lReg == ERROR_SUCCESS)
        {
        DWORD   dwType;
        CHAR    szDavDllPath[255];
        DWORD   cbName = sizeof(szDavDllPath);

        lReg = RegQueryValueExA(hKey,
                    "InstallPath",
                    0,
                    &dwType,
                    (LPBYTE) szDavDllPath,
                    &cbName);

        if (lReg == ERROR_SUCCESS && dwType == REG_SZ)
            {
            m_strDav.Copy(szDavDllPath);
            m_strDav.Append("\\httpext.dll");

            m_hinstDav = LoadLibrary(m_strDav.QueryStr());
            if (m_hinstDav == NULL)
                m_strDav.Reset();
            }

        RegCloseKey(hKey);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\mimemap.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    mimemap.cxx

    This module contains the code for MIME to file type mappings

    The mime mappings are used for selecting the correct type based on file
    extensions and for indicating what types the server accepts.

    FILE HISTORY:
        Johnl           23-Aug-1994     Created

*/

#include "w3p.hxx"

//
//  Private constants.
//

//
//  Private globals.
//

//
//  Private prototypes.
//

BOOL
SelectCustomMimeMapping(
    IN  const   CHAR *pszPath,
    IN          STR  *pstrContentType,
    IN          CHAR *pszMimeMapping
    )
/*++

    Routine Description

        Called when we have a configured metadata mime mapping on a directory,
        and want to look it up.

    Arguments

        pszPath         - Path including extension to be looked up.
        pstrContentType - Where to return the content type.
        pszMimeMapping  - Pointer to mime mapping string.

    Returns

        TRUE if operation successful.

--*/
{
    CHAR        *pszCurrentMimeType;
    CHAR        *pszExt;
    DWORD       dwExtLength;
    BOOL        bCheckingDefault;
    CHAR        *pszLastSlash;

    if (pszPath == NULL)
    {
        pszExt = "*";
        dwExtLength = sizeof("*") - 1;
        bCheckingDefault = TRUE;
    }
    else
    {


        // Need to find the extension. The extension is whatever follows the
        // dot after the last slash in the path.

        // Find the last slash. If there isn't one, use the start of the path.

        pszLastSlash = strrchr((CHAR *)pszPath, '\\');

        if (pszLastSlash == NULL)
        {
            pszLastSlash = (CHAR *)pszPath;
        }

        pszExt = strrchr(pszLastSlash, '.');

        if (pszExt == NULL || *(pszExt+1) == '\0')
        {
            // Didn't find one, so look for the default mapping.
            pszExt = "*";
            dwExtLength = sizeof("*") - 1;
            bCheckingDefault = TRUE;
        }
        else
        {
            dwExtLength = strlen(pszExt);
            bCheckingDefault = FALSE;
        }

    }


    // Look at the mime type mapping string and see if we have a match. The
    // string was preformatted when we read the metadata, and is stored as
    // a set of multi-sz mime-type, .ext strings. If we're not looking for the
    // default, and we don't find one on the first pass, we'll try to find the
    // default mapping.

    for (;;)
    {
        pszCurrentMimeType = pszMimeMapping;

        do {
            CHAR        *pszCurrentSeparator;
            DWORD       dwCurrentExtLength;
            CHAR        *pszCurrentMimeString;
            DWORD       dwCurrentMimeStringLength;


            // First, isolate the mime type from the extension.

            pszCurrentSeparator = strchr(pszCurrentMimeType, ',');

            // Compute the length of the extension

            dwCurrentExtLength = DIFF(pszCurrentSeparator - pszCurrentMimeType);

            // Find the mime map string, and it's length

            pszCurrentMimeString = pszCurrentSeparator + 1;

            dwCurrentMimeStringLength = strlen(pszCurrentMimeString);

            // We have the extension and the length, compare against the
            // input extension.

            if (dwExtLength == dwCurrentExtLength &&
                !_strnicmp(pszExt, pszCurrentMimeType, dwExtLength))
            {
                // Allright, we have a winner.

                return pstrContentType->Copy(pszCurrentMimeString,
                    dwCurrentMimeStringLength);
            }


            // Otherwise, look at the next one.
            pszCurrentMimeType = pszCurrentMimeString + dwCurrentMimeStringLength + 1;


        } while ( *pszCurrentMimeType != '\0' );

        if (!bCheckingDefault)
        {

            // Look backwards for another '.' so we can support extensions
            // like ".xyz.xyz" or ".a.b.c".

            if ( pszExt > pszLastSlash )
            {
                pszExt--;

                while ( ( pszExt > pszLastSlash ) && ( *pszExt != '.' ) )
                {
                    pszExt--;
                }

                if ( *pszExt == '.' )
                {
                    dwExtLength = strlen( pszExt );
                    continue;
                }
            }

            // Didn't find one, so look for the default mapping.
            pszExt = "*";
            dwExtLength = sizeof("*") - 1;
            bCheckingDefault = TRUE;
        }
        else
        {
            break;
        }
    }

    return FALSE;
}

/*******************************************************************

    NAME:       SelectMimeMapping

    SYNOPSIS:   Given a file name, this routine finds the appropriate
                MIME type for the name

    ENTRY:      pstrContentType - Receives MIME type or icon file to use
                pszPath - Path of file being requested (extension
                    is used for the mime mapping).  Should be
                    fully qualified and canonicalized.  If NULL, then the
                    default mapping is used
                mmtype - Type of data to retrieve.  Can retrieve either
                    the mime type associated with the file extension or
                    the icon associated with the extension

    RETURNS:    TRUE on success, FALSE on error (call GetLastError)

    HISTORY:
        Johnl       04-Sep-1994     Created

********************************************************************/

BOOL SelectMimeMapping( STR *             pstrContentType,
                        const CHAR *      pszPath,
                        PW3_METADATA      pMetaData,
                        enum MIMEMAP_TYPE mmtype )
{
    BOOL            fRet = TRUE;
    CHAR            *pszMimeMap;

    switch ( mmtype )
    {
    case MIMEMAP_MIME_TYPE:

        pszMimeMap = (CHAR *)pMetaData->QueryMimeMap()->QueryPtr();
        if (*pszMimeMap != '\0')
        {
            fRet = SelectCustomMimeMapping( pszPath,
                                            pstrContentType,
                                            pszMimeMap );

            if ( fRet )
            {
                break;
            }

        }

        fRet = SelectMimeMappingForFileExt( g_pInetSvc,
                                            pszPath,
                                            pstrContentType );
        break;

    case MIMEMAP_MIME_ICON:
        fRet = SelectMimeMappingForFileExt( g_pInetSvc,
                                            pszPath,
                                            NULL,
                                            pstrContentType );
        break;

    default:
        DBG_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    IF_DEBUG( PARSING )
    {
        if ( mmtype == MIMEMAP_MIME_TYPE )
            DBGPRINTF((DBG_CONTEXT,
                      "[SelectMimeMapping] Returning %s for extension %s\n",
                       pstrContentType->QueryStr(),
                       pszPath ? pszPath : TEXT("*") ));
    }

    return fRet;
}

//
//  Private functions.
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\mtacb.cxx ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MTA Callback

File: mtacb.cpp

Owner: DmitryR

This file contains the implementation of MTA callbacks
===================================================================*/

#include <w3p.hxx>
#include <process.h>
#pragma hdrstop

#include "MTAcb.h"

/*===================================================================
  MTA Callback Thread

  Worker thread that implements the MTA callback functionality
===================================================================*/
class CMTACallbackThread
    {
private:
    DWORD m_fInited : 1;    // inited?
    DWORD m_fCSInited : 1;  // critical section inited?
    DWORD m_fShutdown : 1;  // shutdown?

    CRITICAL_SECTION  m_csLock;      // callback critical section
    HANDLE            m_hDoItEvent;  // callback requested event
    HANDLE            m_hDoneEvent;  // callback done event
    HANDLE            m_hThread;     // thread handle

    PMTACALLBACK      m_pMTACallback;   // callback function ptr
    void             *m_pvContext;      // arg1
    void             *m_pvContext2;     // arg2
    HRESULT           m_hrResult;       // return code

    // The call callback from MTA thread
    void DoCallback()
        {
        DBG_ASSERT(m_pMTACallback);
        m_hrResult = (*m_pMTACallback)(m_pvContext, m_pvContext2);
        }

    // The thread function
    static unsigned Thread(void *pvArg)
        {
        HRESULT hr;

        DBG_ASSERT(pvArg);
        CMTACallbackThread *pThread = (CMTACallbackThread *)pvArg;

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);  // MTA
        if (FAILED(hr))
            {
            // Bug 87857: Handle failure from CoInitialize
            if (hr == E_INVALIDARG)
                {
                CoUninitialize();
                }
                
            // This shouldnt actually fail.  Not entirely clear what to do if it does
            DBG_ASSERT(FALSE);
            return hr;
            }

        while (!pThread->m_fShutdown)
            {
            DWORD dwRet = MsgWaitForMultipleObjects
                (
                1,
                &(pThread->m_hDoItEvent),
                FALSE,
                INFINITE,
                QS_ALLINPUT
                );

            if (pThread->m_fShutdown)
                break;

            if (dwRet == WAIT_OBJECT_0)
                {
                // Event -> do the callback
                pThread->DoCallback();
                SetEvent(pThread->m_hDoneEvent);
                }
            else
                {
                // Do messages
                MSG msg;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    DispatchMessage(&msg);
                }
            }

        CoUninitialize();
        return 0;
        }

public:
    // Constructor
    CMTACallbackThread()
        : m_fInited(FALSE), m_fCSInited(FALSE), m_fShutdown(FALSE),
          m_hDoItEvent(NULL), m_hDoneEvent(NULL), m_hThread(NULL),
          m_pMTACallback(NULL)
        {
        }

    // Destructor
    ~CMTACallbackThread()
        {
        // Real cleanup is in UnInit()
        // This is to cleanup after a bad Init()
        if (m_fCSInited)
            DeleteCriticalSection(&m_csLock);
        if (m_hDoItEvent)
            CloseHandle(m_hDoItEvent);
        if (m_hDoneEvent)
            CloseHandle(m_hDoneEvent);
        }

    // Init (real constructor)
    HRESULT Init()
        {
        HRESULT hr = NOERROR;

        if (SUCCEEDED(hr))
            {
            INITIALIZE_CRITICAL_SECTION(&m_csLock);
            m_fCSInited = TRUE;
            }

        if (SUCCEEDED(hr))
            {
            m_hDoItEvent = IIS_CREATE_EVENT(
                               "CMTACallbackThread::m_hDoItEvent",
                               this,
                               FALSE,
                               FALSE
                               );
            if (!m_hDoItEvent)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_hDoneEvent = IIS_CREATE_EVENT(
                               "CMTACallbackThread::m_hDoneEvent",
                               this,
                               FALSE,
                               FALSE
                               );
            if (!m_hDoneEvent)
                hr = E_OUTOFMEMORY;
            }
        
        // Launch the MTA thread

        unsigned threadId;
        uintptr_t ulThread = _beginthreadex(NULL,
                                            0,
                                            CMTACallbackThread::Thread,
                                            this,
                                            0,
                                            &threadId);
        if (ulThread == 0xffffffff || ulThread == 0)
            hr = E_OUTOFMEMORY;
        else
            m_hThread = (HANDLE)ulThread;

        if (SUCCEEDED(hr))
            m_fInited = TRUE;
        return hr;
        }

    // UnInit (real destructor)
    HRESULT UnInit()
        {
        DBG_ASSERT(m_fInited);

        if (m_hThread)
            {
            // Kill the MTA thread
            m_fShutdown = TRUE;
            SetEvent(m_hDoItEvent);
            WaitForSingleObject(m_hThread, INFINITE);
            CloseHandle(m_hThread);
            m_hThread = NULL;
            }

        if (m_fCSInited)
            {
            DeleteCriticalSection(&m_csLock);
            m_fCSInited = FALSE;
            }

        if (m_hDoItEvent)
            {
            CloseHandle(m_hDoItEvent);
            m_hDoItEvent = NULL;
            }

        if (m_hDoneEvent)
            {
            CloseHandle(m_hDoneEvent);
            m_hDoneEvent = NULL;
            }
    
        m_fInited = FALSE;
        return NOERROR;
        }

    // Execute callback
    HRESULT CallCallback
    (
    PMTACALLBACK pMTACallback,
    void        *pvContext,
    void        *pvContext2
    )
        {
        if (m_fShutdown)
            return E_FAIL;

        DBG_ASSERT(m_fInited);
        DBG_ASSERT(pMTACallback);

        HRESULT hr = E_FAIL;
        EnterCriticalSection(&m_csLock);

        DBG_ASSERT(m_pMTACallback == NULL);
        m_pMTACallback = pMTACallback;
        m_pvContext  = pvContext;
        m_pvContext2 = pvContext2;
        m_hrResult   = E_FAIL;

        // Tell MTA thread to call back
        SetEvent(m_hDoItEvent);

        // Wait till done
        WaitForSingleObject(m_hDoneEvent, INFINITE);

        // remember HRESULT
        hr = m_hrResult;

        // to make sure we never do it twice
        m_pMTACallback = NULL;

        LeaveCriticalSection(&m_csLock);
        return hr;
        }
    };

// Sole instance of the above
static CMTACallbackThread *g_pMTACallbackThread = NULL;

/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitMTACallbacks

To be called from DllInit()
Inits the MTA callback processing
Launches the MTA thread

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitMTACallbacks()
    {
    g_pMTACallbackThread = new CMTACallbackThread;
    if (g_pMTACallbackThread == NULL)
        {
        return E_OUTOFMEMORY;
        }
        
    return g_pMTACallbackThread->Init();
    }

/*===================================================================
UnInitMTACallbacks

To be called from DllUnInit()
Stops the MTA callback processing
Kills the MTA thread

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitMTACallbacks()
    {
    HRESULT hr = E_FAIL;
    
    if (g_pMTACallbackThread != NULL)
        {
        hr = g_pMTACallbackThread->UnInit();
        delete g_pMTACallbackThread;
        g_pMTACallbackThread = NULL;
        }
        
    return hr;
    }

/*===================================================================
CallMTACallback

Calls the hack.

Parameters
    PMTACALLBACK  pMTACallback       call this function
    void         *pvContext          pass this to it
    void         *pvContext2         extra arg

Returns:
    HRESULT
===================================================================*/
HRESULT CallMTACallback
(
PMTACALLBACK pMTACallback,
void        *pvContext,
void        *pvContext2
)
    {
    return g_pMTACallbackThread->CallCallback
        (
        pMTACallback,
        pvContext,
        pvContext2
        );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\redirect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    redirect.cxx

    This module contains code for handling HTTP redirections in server.


    FILE HISTORY:
        t-bilala    10-Jan-1996     Created
*/

#include "w3p.hxx"

enum REDIR_TOKEN
{
    REDIR_TOKEN_EXACT_DST,
    REDIR_TOKEN_PERMANENT,
    REDIR_TOKEN_SUFFIX,
    REDIR_TOKEN_FULL,
    REDIR_TOKEN_PARAMETERS,
    REDIR_TOKEN_QMARK_PARAMETERS,
    REDIR_TOKEN_VROOT_REQUEST,
    REDIR_TOKEN_CHILD_ONLY,
    REDIR_TOKEN_UNKNOWN
};

struct _REDIR_TOKEN_LIST
{
    CHAR *           pszKeyword;
    DWORD            cbLen;
    REDIR_TOKEN      rtType;
}
RedirectTokenList[] =
{
    "EXACT_DESTINATION",17, REDIR_TOKEN_EXACT_DST,
    "PERMANENT",        9,  REDIR_TOKEN_PERMANENT,
    "$S",               2,  REDIR_TOKEN_SUFFIX,
    "$P",               2,  REDIR_TOKEN_PARAMETERS,
    "$Q",               2,  REDIR_TOKEN_QMARK_PARAMETERS,
    "$V",               2,  REDIR_TOKEN_VROOT_REQUEST,
    "CHILD_ONLY",      10,  REDIR_TOKEN_CHILD_ONLY,
    NULL,               0,  REDIR_TOKEN_UNKNOWN
};

DWORD
GetRedirectToken(
    IN CHAR *       pchToken,
    OUT DWORD *     pdwLen
)
/*++

Routine Description:

    Searches token table for match.

Arguments:

    pchToken - Pointer to string to search for.
    pdwLen - Receives the length of matched token.

Return Value:

    The type (REDIR_TOKEN enum) of the token if matched.
    Or REDIR_TOKEN_UNKNOWN if string not found.

--*/
{
    DWORD           dwCounter = 0;
    CHAR *          pszEntry;

    while ( RedirectTokenList[ dwCounter ].pszKeyword != NULL )
    {
        if ( !_strnicmp( pchToken,
                         RedirectTokenList[ dwCounter ].pszKeyword,
                         RedirectTokenList[ dwCounter ].cbLen ) )
        {
            break;
        }
        dwCounter++;
    }
    if ( pdwLen != NULL )
    {
        *pdwLen = RedirectTokenList[ dwCounter ].cbLen;
    }
    return RedirectTokenList[ dwCounter ].rtType;
}

BOOL
REDIRECTION_BLOB::ParseDestination(
    IN STR &            strDestination
)
/*++

Routine Description:

    Parse destination template.

Arguments:

    strDestination - Destination template

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR *              pchNextComma = NULL;
    DWORD               cbTokenLen;
    STACK_STR(          strOptions, MAX_PATH );
    CHAR *              pchWhiteSpace;
    DWORD               cbLen;

    // first separate out the destination path from the options (if any)

    if ( !_strDestination.Copy( strDestination ) )
    {
        return FALSE;
    }

    pchNextComma = strchr( _strDestination.QueryStr(), ',' );
    if ( pchNextComma != NULL )
    {

        if ( !strOptions.Copy( pchNextComma + 1 ) )
        {
            return FALSE;
        }

        cbLen = DIFF(pchNextComma - _strDestination.QueryStr());

        _strDestination.SetLen( cbLen );
    }
    else {
        cbLen = _strDestination.QueryCB();
    }

    //
    // look for any trailing white space in destination, remove it
    //

    pchWhiteSpace = pchNextComma ? pchNextComma :
                    _strDestination.QueryStr() + _strDestination.QueryCB();

    while( pchWhiteSpace > _strDestination.QueryStr() )
    {
        if ( !isspace( (UCHAR)(*( pchWhiteSpace - 1 )) ) )
        {
            break;
        }

        _strDestination.SetLen( --cbLen );

        pchWhiteSpace--;
    }

    //
    // now check whether this is a wildcard redirection
    //

    if ( *(_strDestination.QueryStr()) == '*' )
    {
        if ( !ParseWildcardDestinations() )
        {
            return FALSE;
        }
        _fWildcards = TRUE;
    }
    else
    {
        //
        // cache whether we expect tokens in the destination template
        //

        if ( strchr( _strDestination.QueryStr(), '$' ) != NULL )
        {
            _fHasTokens = TRUE;
        }
    }

    if ( !strOptions.IsEmpty() )
    {
        //
        // parse and cache any options set for redirection
        //

        pchNextComma = strOptions.QueryStr();

        while ( TRUE )
        {
            while ( isspace( (UCHAR)(*pchNextComma) ) )
            {
                pchNextComma++;
            }

            switch ( GetRedirectToken( pchNextComma, &cbTokenLen ) )
            {
                case REDIR_TOKEN_EXACT_DST:
                    _fExactDestination = TRUE;
                    break;
                case REDIR_TOKEN_PERMANENT:
                    _fPermanent = TRUE;
                    break;
                case REDIR_TOKEN_CHILD_ONLY:
                    _fChildOnly = TRUE;
                    break;
                default:
                    break;
            }

            pchNextComma = strchr( pchNextComma, ',' );

            if ( pchNextComma == NULL )
            {
                break;
            }

            pchNextComma++;
        }
    }

    return TRUE;
}

BOOL
REDIRECTION_BLOB::ParseWildcardDestinations( VOID )
/*++

Routine Description:

    Parse wildcard destination.

    Wildcard destination takes the form:

    *;<wildcard1>;<destination1>;<wildcard2>;<destination2>...
    eg. *;*.stm;/default1.htm,;*.htm;/default2.htm

Arguments:

    None

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR *              pchCursor;
    CHAR *              pchNext;
    CHAR *              pchEndToken;
    PWILDCARD_ENTRY     pEntry;

    pchCursor = strchr( _strDestination.QueryStr(), ';' );

    if ( pchCursor == NULL )
    {
        return FALSE;
    }

    while ( pchCursor != NULL )
    {
        pchCursor++;

        pchNext = strchr( pchCursor, ';' );
        if ( pchNext == NULL )
        {
            break;
        }

        while ( isspace( (UCHAR)(*pchCursor) ) )
        {
            pchCursor++;
        }

        pEntry = AddWildcardEntry();
        if ( pEntry == NULL )
        {
            return FALSE;
        }

        pchEndToken = pchNext - 1;
        while ( isspace( (UCHAR)(*pchEndToken) ) )
        {
            pchEndToken--;
        }

        if ( !pEntry->_strWildSource.Copy( pchCursor,
                                           DIFF(pchEndToken - pchCursor) + 1 ) )
        {
            return FALSE;
        }

        pchCursor = pchNext + 1;

        while ( isspace( (UCHAR)(*pchCursor) ) )
        {
            pchCursor++;
        }

        pchNext = strchr( pchCursor, ';' );

        if ( pchNext == NULL )
        {
            if ( !pEntry->_strWildDest.Copy( pchCursor ) )
            {
                return FALSE;
            }
        }
        else
        {
            pchEndToken = pchNext - 1;
            while ( isspace( (UCHAR)(*pchEndToken) ) )
            {
                pchEndToken--;
            }

            if ( !pEntry->_strWildDest.Copy( pchCursor,
                                             DIFF(pchEndToken - pchCursor) + 1 ) )
            {
                return FALSE;
            }
        }

        _fHasTokens = strchr( pEntry->_strWildDest.QueryStr(), '$' ) != NULL;

        pchCursor = pchNext;
    }

    return TRUE;
}

BOOL
REDIRECTION_BLOB::GetDestination(
    IN STR &            strRequestedURL,
    IN STR &            strParameters,
     IN HTTP_HEADERS    *pReqHeaders,
    OUT STR *           pstrFinalDestination,
    OUT DWORD *         pdwServerCode
)
/*++

Routine Description:

    Get the complete destination of a redirection

Arguments:

    strRequestedURL - URL originally requested
    strParameters - Query String of request
    pstrDestination - Redirection destination placed here.
    pdwServerCode - Server code of redirect (HT_REDIRECT or HT_MOVED )

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    STACK_STR(          strMatchedSuffix, MAX_PATH );
    STR *               pstrDestination;
    WILDCARD_MATCH_LIST wmlList( strRequestedURL.QueryCB() );
    PWILDCARD_ENTRY     pEntry;

    if ( pdwServerCode != NULL )
    {
        *pdwServerCode = _fPermanent ? HT_MOVED : HT_REDIRECT;
    }

    if ( !strMatchedSuffix.Copy( strRequestedURL.QueryStr() +
                                 _strSource.QueryCB() ) )
    {
        return FALSE;
    }

    if ( _fChildOnly )
    {
        CHAR *              pchOtherSlash;

        pchOtherSlash = strchr( strMatchedSuffix.QueryStr(), '/' );
        if ( pchOtherSlash == strMatchedSuffix.QueryStr() )
        {
            pchOtherSlash = strchr( pchOtherSlash + 1, '/' );
        }

        if ( pchOtherSlash != NULL )
        {
            return FALSE;
        }
    }

    if ( _fWildcards )
    {
        if ( !FindWildcardMatch( strMatchedSuffix,
                                 &pEntry,
                                 &wmlList ) )
        {
            return FALSE;
        }
        pstrDestination = &(pEntry->_strWildDest);
    }
    else
    {
        pstrDestination = &_strDestination;
    }

    if ( !_fHasTokens )
    {
        if ( !pstrFinalDestination->Copy( *pstrDestination ) )
        {
            return FALSE;
        }
    }
    else
    {
        CHAR            achAdd[ 2 ] = { '\0', '\0' };
        CHAR            ch;
        CHAR *          pchCursor = pstrDestination->QueryStr();
        DWORD           cbLen;
        CHAR *          pchNext;

        while ( ( ch = *pchCursor ) != '\0' )
        {
            switch ( ch )
            {
            case '$':
                // Substitute for special tokens in destination template

                switch ( GetRedirectToken( pchCursor, &cbLen ) )
                {
                case REDIR_TOKEN_SUFFIX:
                    pchCursor += ( cbLen - 1 );
                    if ( !pstrFinalDestination->Append( strMatchedSuffix ) )
                    {
                        return FALSE;
                    }
                    break;
                case REDIR_TOKEN_VROOT_REQUEST:
                    pchCursor += ( cbLen - 1 );
                    if ( !pstrFinalDestination->Append( strRequestedURL ) )
                    {
                        return FALSE;
                    }
                    break;
                case REDIR_TOKEN_PARAMETERS:
                    pchCursor += ( cbLen - 1 );
                    if ( !pstrFinalDestination->Append( strParameters ) )
                    {
                        return FALSE;
                    }
                    break;
                case REDIR_TOKEN_QMARK_PARAMETERS:
                    pchCursor += ( cbLen - 1 );
                    if ( !strParameters.IsEmpty() )
                    {
                        if ( !pstrFinalDestination->Append( "?" ) ||
                             !pstrFinalDestination->Append( strParameters ) )
                        {
                            return FALSE;
                        }
                    }
                    break;
                default:
                    pchCursor++;
                    ch = *pchCursor;
                    if ( isdigit( (UCHAR) ch ) )
                    {
                        if ( !pstrFinalDestination->Append(
                                wmlList.GetMatchNumber( ch - '0' ) ) )
                        {
                            return FALSE;
                        }
                    }
                    else
                    {
                        if ( !pstrFinalDestination->Append( "$" ) )
                        {
                            return FALSE;
                        }
                        achAdd[ 0 ] = ch;
                        if ( !pstrFinalDestination->Append( achAdd ) )
                        {
                            return FALSE;
                        }
                    }
                }
                break;
            default:
                pchNext = pchCursor;
                while ( pchCursor[ 1 ] != '$' && pchCursor[ 1 ] != '\0' )
                {
                    pchCursor++;
                }
                if ( !pstrFinalDestination->Append( pchNext, DIFF(pchCursor - pchNext) + 1 ) )
                {
                    return FALSE;
                }
            }
            pchCursor++;
        }
    }

    //
    // Now check to see if there were conditional headers configured for this
    // redirect. If there are, check them.
    //

    if (_ConditionalHeaderList != NULL)
    {
        // Have some conditional headers. Each conditional header in the list
        // must appear in the headers we got with this request (pReqHeaders),
        // and if there are parameters specifed with the conditional header
        // at least one of must be present as a parameter of the input
        // header.

        PRD_CONDITIONAL_HEADER          pCurrentHeader;
        CHAR                            *pszParamList;
        DWORD                           dwParamListLength;

        pCurrentHeader = _ConditionalHeaderList;

        do
        {
            pszParamList = pReqHeaders->FindValue(
                                            pCurrentHeader->Header.QueryStr(),
                                            &dwParamListLength
                                            );

            if (pszParamList == NULL)
            {
                // Couldn't find this header in the list, fail.
                return FALSE;
            }

            // Found the header. If there are parameters specified for it,
            // check to see if they exist.

            if (!pCurrentHeader->Parameters.IsEmpty())
            {
                BOOL        bFound;
                CHAR        *pszCurrentParam;
                CHAR        *pszConfigParam;

                //
                // There are parameters. For each parameter in the input header,
                // check to see if it matches one in the configured list
                // for this header. If it does, we're done and we can
                // check the next header. If we get all the way through
                // and we don't find a match, we've failed and the redirect
                // won't be performed.

                INET_PARSER Parser(pszParamList);

                Parser.SetListMode(TRUE);

                pszCurrentParam = Parser.QueryToken();

                bFound = FALSE;

                //
                // For each token in the input parameters, compare
                // it against each string in the configured parameters.

                while (*pszCurrentParam != '\0')
                {
                    pszConfigParam = (CHAR *)pCurrentHeader->Parameters.First();

                    DBG_ASSERT(pszConfigParam != NULL);
                    DBG_ASSERT(*pszConfigParam != '\0');

                    while (pszConfigParam != NULL)
                    {
                        if (!_stricmp(pszCurrentParam, pszConfigParam))
                        {
                            // Have a match.
                            bFound = TRUE;
                            break;
                        }
                        pszConfigParam =
                            (CHAR *)pCurrentHeader->Parameters.Next(pszConfigParam);

                    }

                    if (bFound)
                    {
                        break;
                    }

                    pszCurrentParam = Parser.NextItem();
                }

                Parser.RestoreBuffer();

                if (!bFound)
                {
                    //
                    // Didn't find a match, so fail.
                    //
                    return FALSE;
                }

            }

            pCurrentHeader = pCurrentHeader->Next;


        } while ( pCurrentHeader != NULL );
    }

    //
    // At this point either there were no conditional headers, or there
    // were but we satisfied all the conditions, so continue.

    // was EXACT_DESTINATION option used?

    if ( _fExactDestination )
    {
        return TRUE;
    }
    else
    {
        return pstrFinalDestination->Append( strMatchedSuffix );
    }
}

BOOL
REDIRECTION_BLOB::FindWildcardMatch(
    IN STR &                    strInput,
    OUT PWILDCARD_ENTRY *       ppEntry,
    OUT WILDCARD_MATCH_LIST *   pwmlList
)
/*++

Routine Description:

    Searches WILDCARD_ENTRYs for the first that matches the input string.
    Also fills in a WILDCARD_MATCH_LIST for the matched string (if any).

Arguments:

    strInput - Input string to check
    ppEntry - Set to point to the WILDCARD_ENTRY that matches (or NULL)
    pwmlList - Filled in if strInput matches a template

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY *            pListEntry;
    PWILDCARD_ENTRY         pWildcardEntry;

    for ( pListEntry = _ListHead.Flink;
          pListEntry != &_ListHead;
          pListEntry = pListEntry->Flink )
    {
        pWildcardEntry = CONTAINING_RECORD( pListEntry,
                                            WILDCARD_ENTRY,
                                            _ListEntry );

        if ( IsWildcardMatch( strInput,
                              pWildcardEntry->_strWildSource,
                              pwmlList ) )
        {
            *ppEntry = pWildcardEntry;
            return TRUE;
        }
    }
    *ppEntry = NULL;
    return FALSE;
}

BOOL
REDIRECTION_BLOB::IsWildcardMatch(
    IN STR &                    strInput,
    IN STR &                    strTemplate,
    OUT WILDCARD_MATCH_LIST *   pwmlList
)
/*++

Routine Description:

    Checks whether input string matches wildcard expression of internal
    source string.  For example:  given internal source of "a*b*c",
    "abooc", "asdfjbsdfc" match, "foobar", "scripts" do not match

Arguments:

    strInput - input string to check for wildcard match
    pwmlList - List of matched strings (one for each * in wildcard)
               Only generated if the destination string of
               contains special tokens.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR            chExpr;
    CHAR            chTemp;
    CHAR *          pchExpr = strTemplate.QueryStr();
    CHAR *          pchTest = strInput.QueryStr();
    CHAR *          pchEnd;

    pwmlList->Reset();

    pchEnd = pchExpr + strTemplate.QueryCB();
    while ( TRUE )
    {
        chExpr = *pchExpr++;
        if ( chExpr == '\0' )
        {
            if ( *pchTest == '\0' )
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
        else if ( chExpr != '*' )
        {
            chTemp = *pchTest++;
            if ( chTemp != chExpr )
            {
                return 0;
            }
        }
        else
        {
            INT             iComLen;
            CHAR *          pchNextWild;

            while ( *pchExpr == '*' )
            {
                pchExpr++;
            }

            pchNextWild = strchr( pchExpr, '*' );
            iComLen = pchNextWild == NULL ? DIFF(pchEnd - pchExpr) :
                                            DIFF(pchNextWild - pchExpr);
            while ( *pchTest != '\0' )
            {
                if ( strncmp( pchExpr,
                              pchTest,
                              iComLen ) || !iComLen )
                {
                    // if the destination has tokens, then generate WML
                    if ( _fHasTokens && !pwmlList->AddChar( *pchTest ) )
                    {
                        return FALSE;
                    }
                    pchTest++;
                }
                else
                {
                    break;
                }
            }
            if ( *pchTest == '\0' && iComLen )
            {
                return FALSE;
            }
            else if ( _fHasTokens && !pwmlList->NewString() )
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOL
HTTP_REQUEST::DoRedirect(
    OUT BOOL *       pfFinished
)
/*++

Routine Description:

    Do a HTTP redirect as specified by template in metadata.

Arguments:

    pfFinished - Set to TRUE if no more processing required.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PREDIRECTION_BLOB   pRBlob = _pMetaData->QueryRedirectionBlob();
    STACK_STR(          strDestination, MAX_PATH );
    DWORD               dwServerCode;

    if ( !pRBlob->GetDestination( _strURL,
                                  _strURLParams,
                                  QueryHeaderList(),
                                  &strDestination,
                                  &dwServerCode ) ||
         !BuildURLMovedResponse( QueryRespBuf(),
                                 &strDestination,
                                 dwServerCode ) ||
         !SendHeader( QueryRespBufPtr(),
                      QueryRespBufCB(),
                      IO_FLAG_SYNC,
                      pfFinished ) )
    {
        return FALSE;
    }

    SetState( HTR_DONE, dwServerCode );

    *pfFinished = TRUE;

    return TRUE;
}

BOOL
GetTrueRedirectionSource(
     LPSTR                   pszURL,
     PIIS_SERVER_INSTANCE    pInstance,
     IN CHAR *               pszDestination,
     IN BOOL                 bIsString,
     OUT STR *               pstrTrueSource
)
/*++

Routine Description:

    Determine the true source of the redirection.  That is, the object from
    which the required URL inherited the redirect metadata.

Arguments:

    pszURL         - URL requested
    pInstance      - Instance
    pszDestination - The destination metadata inherited by the original URL.
    pstrTrueSource - The path of the object from which the original URL
                     inherited pszDestination.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    MB                  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    STR                 strDestination;
    DWORD               dwNeed;
    DWORD               dwL;
    DWORD               dwVRLen;
    INT                 ch;
    LPSTR               pszInVr;
    LPSTR               pszMinInVr;
    BOOL                bAtThisLevel;

    // need to reopen the metabase and search up the tree

    if ( !mb.Open( pInstance->QueryMDVRPath() ))
    {
        return FALSE;
    }

    //
    // Check from where we got VR_PATH
    //

    pszMinInVr = pszURL ;
    if ( *pszURL )
    {
        for ( pszInVr = pszMinInVr + strlen(pszMinInVr) ;; )
        {
            ch = *pszInVr;
            *pszInVr = '\0';
            dwNeed = 0;

            if (bIsString)
            {
                bAtThisLevel = !mb.GetString(   pszURL,
                                                MD_HTTP_REDIRECT,
                                                IIS_MD_UT_FILE,
                                                NULL,
                                                &dwNeed,
                                                0 ) &&
                                GetLastError() == ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                bAtThisLevel = !mb.GetData(     pszURL,
                                                MD_HTTP_REDIRECT,
                                                IIS_MD_UT_FILE,
                                                MULTISZ_METADATA,
                                                NULL,
                                                &dwNeed,
                                                0 ) &&
                                GetLastError() == ERROR_INSUFFICIENT_BUFFER;
            }
            if ( bAtThisLevel )
            {
                *pszInVr = (CHAR)ch;
                // VR_PATH was defined at this level !

                break;
            }
            *pszInVr = (CHAR)ch;

            if ( ch)
            {
                if ( pszInVr > pszMinInVr )
                {
                    --pszInVr;
                }
                else
                {
                    DBG_REQUIRE( mb.Close() );
                    SetLastError( ERROR_FILE_NOT_FOUND );
                    return FALSE;
                }
            }

            // scan for previous delimiter

            while ( *pszInVr != '/' && *pszInVr != '\\' )
            {
                if ( pszInVr > pszMinInVr )
                {
                    --pszInVr;
                }
                else
                {
                    DBG_REQUIRE( mb.Close() );
                    SetLastError( ERROR_FILE_NOT_FOUND );
                    return FALSE;
                }
            }
        }

        dwVRLen = DIFF(pszInVr - pszMinInVr);
    }
    else
    {
        dwVRLen = 0;
        pszInVr = pszMinInVr;
    }

    DBG_REQUIRE( mb.Close() );

    DBG_ASSERT( pszURL[ 0 ] == '/' );

    if ( dwVRLen > 1 )
    { 
        return pstrTrueSource->Copy( pszURL, dwVRLen );
    }
    else
    {
        return TRUE;
    }
}

BOOL
REDIRECTION_BLOB::SetConditionalHeaders(
    CHAR *pmszConditionalHeaders
)
/*++

Routine Description:

    Take a bunch of conditional headers as a multisz, and convert them to a
    list of RD_CONDITIONAL_HEADERs attached to this redirection blob.

Arguments:

    pHeaders        - Pointer to multisz of conditional headers.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR                    *pszHeader;
    PRD_CONDITIONAL_HEADER  pCondition;
    PRD_CONDITIONAL_HEADER  pPrevCondition;

    pPrevCondition = CONTAINING_RECORD(&_ConditionalHeaderList,
                            RD_CONDITIONAL_HEADER, Next);

    DBG_ASSERT(pPrevCondition->Next == NULL);

    while (*pmszConditionalHeaders != '\0')
    {
        CHAR                *pszTemp;
        CHAR                *pszCurrentParam;

        //
        // Allocate a new conditional header block.
        //
        pCondition = new RD_CONDITIONAL_HEADER;

        if (pCondition == NULL)
        {
            // Couldn't get it.
            return FALSE;
        }

        // Now find the header, and add it.
        //

        pszHeader = pmszConditionalHeaders;

        while (isspace((UCHAR)(*pszHeader)))
        {
            pszHeader++;
        }

        pszTemp = strchr(pszHeader, ':');

        if (pszTemp == NULL)
        {
            // Poorly formed header, fail.

            delete pCondition;
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;

        }

        pszTemp++;

        if (!pCondition->Header.Copy(pszHeader, DIFF(pszTemp - pszHeader)))
        {
            //
            // Couldn't add it, fail.
            delete pCondition;
            return FALSE;

        }


        //
        // OK, now pszTemp points right after the header. We have a comma
        // seperated list of parameters following this, convert these to
        // the Parameters multisz.

        INET_PARSER Parser(pszTemp);

        Parser.SetListMode(TRUE);

        pszCurrentParam = Parser.QueryToken();

        while (*pszCurrentParam != '\0')
        {
            if (!pCondition->Parameters.Append(pszCurrentParam))
            {
                delete pCondition;
                return FALSE;
            }

            pszCurrentParam = Parser.NextItem();
        }

        Parser.RestoreBuffer();

        //
        // So far, so good. Append this one to the list.

        pPrevCondition->Next = pCondition;

        pPrevCondition = pCondition;

        pmszConditionalHeaders = pmszConditionalHeaders +
                                strlen(pmszConditionalHeaders) + 1;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\parmlist.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parmlist.cxx

Abstract:

    Simple class for parsing and storing parameter list pairs

Author:

    John Ludeman (johnl)   22-Feb-1995

Revision History:

--*/

#include "w3p.hxx"
#include <parmlist.hxx>

inline
BOOL
UnescapeStr( STR * pstr )
{
    CHAR * pch;

    pch = pstr->QueryStr();
    while ( pch = strchr( pch, '+' ))
        *pch = ' ';

    return pstr->Unescape();
}


PARAM_LIST::~PARAM_LIST(
    VOID
    )
/*++

Routine Description:

    Param list destructor

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    while ( !IsListEmpty( &_FieldListHead ))
    {
        pFVP = CONTAINING_RECORD( _FieldListHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        RemoveEntryList( &pFVP->ListEntry );

        delete( pFVP );
    }

    while ( !IsListEmpty( &_FreeHead ))
    {
        pFVP = CONTAINING_RECORD( _FreeHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        RemoveEntryList( &pFVP->ListEntry );

        delete( pFVP );
    }

}

VOID
PARAM_LIST::Reset(
    VOID
    )
/*++

Routine Description:

    Resets the parameter list back to its initially constructed state

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    while ( !IsListEmpty( &_FieldListHead ))
    {
        pFVP = CONTAINING_RECORD( _FieldListHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        RemoveEntryList( &pFVP->ListEntry );

        //
        //  Put the removed item on the end so the same entry will tend to
        //  be used for the same purpose on the next use
        //

        InsertTailList( &_FreeHead, &pFVP->ListEntry );
    }

    m_fCanonicalized = FALSE;
}

BOOL
PARAM_LIST::ParsePairs(
    const CHAR * pszList,
    BOOL         fDefaultParams,
    BOOL         fAddBlankValues,
    BOOL         fCommaIsDelim
    )
/*++

Routine Description:

    Puts the text list into a linked list of field/value pairs

    This can be used to parse lists in the form of:

    "a=b,c=d,e=f" (with fCommaIsDelim = TRUE)
    "name=Joe, Billy\nSearch=tom, sue, avery"  (with fCommaIsDelim = FALSE)

    Duplicates will be appended and tab separated

Arguments:

    pszList - list of comma separated field/value pairs
    fDefaultParams - If TRUE, means these parameters are only defaults and
        shouldn't be added to the list if the field name is already in the
        list and the value is non-empty.
    fAddBlankValues - if TRUE, allow fields with empty values to be added
        to the list, else ignore empty values.
    fCommaIsDelim - if TRUE, a comma acts as a separator between two sets of
        fields values, otherwise the comma is ignored

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *             pch;
    DWORD              cParams = 0;
    DWORD              i;
    BOOL               fRet;
    STR                strParams;
    STR                strField;

    //
    //  Make a copy we can muck with
    //

    if ( !strParams.Copy( pszList ))
        return FALSE;

    //
    //  Replace all of the equal signs and commas with '\n's for easier parsing
    //

    pch = strParams.QueryStr();
    while ( pch = strchr( pch, '=' ))
    {
        *pch = '\n';
        cParams++;
    }

    if ( fCommaIsDelim )
    {
        pch = strParams.QueryStr();
        while ( pch = strchr( pch, ',' ))
        {
            *pch = '\n';
            cParams++;
        }
    }

    //
    //  Pick out the fields and values and build the associative list
    //

    {
        INET_PARSER Parser( strParams.QueryStr() );

        for ( i = 0; i < cParams; i++ )
        {
            if ( !strField.Copy( Parser.QueryToken() ))
                return FALSE;

            Parser.NextLine();

            pch = Parser.QueryToken();

            //
            //  If we aren't supposed to add blanks, then just go to the next
            //  line
            //

            if ( !fAddBlankValues && !*pch )
            {
                Parser.NextLine();
                continue;
            }

            if ( !fDefaultParams )
            {
                FIELD_VALUE_PAIR * pFVP;
                LIST_ENTRY *       ple;

                //
                //  Look for an existing field with this name and append
                //  the value there if we find it, otherwise add a new entry
                //

                for ( ple  = _FieldListHead.Flink;
                      ple != &_FieldListHead;
                      ple  = ple->Flink )
                {
                    pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

                    if ( !_stricmp( pFVP->QueryField(),
                                   strField.QueryStr() ))
                    {
                        //
                        //  CODEWORK - Remove this allocation
                        //

                        STR strtmp( pch );

                        //
                        //  Found this header, append the new value
                        //

                        pFVP->_cValues++;

                        fRet = UnescapeStr( &strtmp )         &&
                               pFVP->_strValue.Append( "\t" ) &&
                               pFVP->_strValue.Append( strtmp );

                        goto Found;
                    }
                }

                fRet = AddEntry( strField.QueryStr(),
                                 pch,
                                 TRUE );
Found:
                ;
            }
            else
            {
                //
                //  Don't add if already in list
                //

                fRet = AddParam( strField.QueryStr(),
                                 pch );
            }

            if ( !fRet )
                return FALSE;

            Parser.NextLine();
        }
    }

    return TRUE;
}


BOOL
PARAM_LIST::AddEntryUsingConcat(
    const CHAR * pszField,
    const CHAR * pszValue,
    BOOL  fPossibleFastMap
)
/*++

Routine Description:

    Concatenate value with existing entry of same name
    or call AddEntry if none exists

Arguments:

    pszField         - Field to add
    pszValue         - Value to add
    fPossibleFastMap - TRUE if entry is not known not to be
                       in the fast map


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    //
    //  Look for an existing field with this name
    //  and add the value there
    //

    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;
    BOOL               fRet;

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            //
            //  Found this header, append the new value
            //

            pFVP->_cValues++;

            fRet = pFVP->_strValue.Append( "," ) &&
                   pFVP->_strValue.Append( pszValue );

            goto Found;
        }
    }

    fRet = AddEntry( pszField,
                     pszValue,
                     FALSE,
                     fPossibleFastMap );

Found:

    return fRet;
}



BOOL
PARAM_LIST::ParseSimpleList(
    const CHAR * pszList
    )
/*++

Routine Description:

    Puts the comma separated list into a linked list of field/value pairs
    where the value is always NULL

Arguments:

    pszList - list of comma separated fields

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *             pch;
    BOOL               fRet;

    //
    //  Pick out the fields and values and build the associative list
    //

    {
        INET_PARSER Parser( (CHAR *) pszList );

        Parser.SetListMode( TRUE );

        while ( *(pch = Parser.QueryToken()) )
        {
            fRet = AddEntry( pch,
                             NULL,
                             TRUE );

            if ( !fRet )
                return FALSE;

            Parser.NextItem();
        }
    }

    return TRUE;
}

CHAR *
PARAM_LIST::FindValue(
    const CHAR * pszField,
    BOOL *       pfIsMultiValue  OPTIONAL,
    DWORD *      pcbValue OPTIONAL
    )
/*++

Routine Description:

    Returns the value associated with pszField or NULL of no value was
    found

Arguments:

    pszField - field to search for value for
    pfIsMultiValue - Set to TRUE if this value is a composite of multiple fields
    pcbValue - Set to size of value (excluding nul terminator)


Return Value:

    Pointer to value or NULL if not found

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            if ( pfIsMultiValue )
            {
                *pfIsMultiValue = pFVP->IsMultiValued();
            }

            if ( pcbValue )
            {
                *pcbValue = pFVP->_strValue.QueryCB();
            }

            return pFVP->QueryValue();
        }
    }


    return NULL;
}

BOOL
PARAM_LIST::AddEntry(
    const CHAR * pszField,
    const CHAR * pszValue,
    BOOL         fUnescape,
    BOOL         fPossibleFastMap
    )
/*++

Routine Description:

    Unconditionally adds the field/value pair to the end of the list

Arguments:

    pszField         - Field to add
    pszValue         - Value to add
    fPossibleFastMap - TRUE if entry is not known not to be
                   in the fast map


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    CHAR *             pch;

    if ( !IsListEmpty( &_FreeHead ) )
    {
        LIST_ENTRY * pEntry;

        pEntry = _FreeHead.Flink;

        RemoveEntryList( _FreeHead.Flink );

        pFVP = CONTAINING_RECORD( pEntry, FIELD_VALUE_PAIR, ListEntry );

        pFVP->_strField.Reset();
        pFVP->_strValue.Reset();
    }
    else
    {
        pFVP = new FIELD_VALUE_PAIR;

        if ( !pFVP )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
    }

    pFVP->_cValues = 1;

    //
    //  Add it to the list now so we don't have to worry about deleting it
    //  if one of the below copies fail
    //

    InsertTailList( &_FieldListHead, &pFVP->ListEntry );

    if ( !pFVP->_strField.Copy( pszField ))
        return FALSE;

    if ( !pFVP->_strValue.Copy( pszValue ))
        return FALSE;

    if ( fUnescape )
    {
        //
        //  Normalize the fields and values (unescape and replace
        //  '+' with ' ')
        //

        if ( !UnescapeStr( &pFVP->_strField ) ||
             !UnescapeStr( &pFVP->_strValue ))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
PARAM_LIST::AddEntry(
    const CHAR * pszField,
    DWORD        cbField,
    const CHAR * pszValue,
    DWORD        cbValue
    )
/*++

Routine Description:

    Unconditionally adds the field/value pair to the end of the list

    The fast map is not used and the fields are not unescaped

Arguments:

    pszField         - Field to add
    cbField          - Number of bytes in pszField
    pszValue         - Value to add
    cbValue          - Number of bytes in pszValue

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR *  pFVP;
    CHAR *              pch;
    PLIST_ENTRY         listEntry;

    listEntry = RemoveHeadList( &_FreeHead );

    if ( listEntry != &_FreeHead )
    {
        pFVP = CONTAINING_RECORD(
                            listEntry,
                            FIELD_VALUE_PAIR,
                            ListEntry );

        pFVP->_strField.Reset();
        pFVP->_strValue.Reset();
    }
    else
    {
        pFVP = new FIELD_VALUE_PAIR;

        if ( !pFVP )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
    }

    pFVP->_cValues = 1;

    //
    //  Add it to the list now so we don't have to worry about deleting it
    //  if one of the below copies fail
    //

    InsertTailList( &_FieldListHead, &pFVP->ListEntry );

    if ( !pFVP->_strField.Copy( pszField, cbField ))
        return FALSE;

    if ( !pFVP->_strValue.Copy( pszValue, cbValue ))
        return FALSE;

    return TRUE;
}

BOOL PARAM_LIST::AddParam(
    const CHAR * pszField,
    const CHAR * pszValue
    )
/*++

Routine Description:

    Adds a field/value pair to the list if the field isn't already in the list
    or the value is empty

    The fields added through this method will be escaped

Arguments:

    pszField - Field to add
    pszValue - Value to add


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            //
            //  We found the field, replace the value if it is empty
            //

            if ( !*pFVP->QueryValue() )
            {
                return pFVP->_strValue.Copy( pszValue );
            }

            return TRUE;
        }
    }

    //
    //  The field name wasn't found, add it
    //

    return AddEntry( pszField,
                     pszValue,
                     TRUE );
}

BOOL
PARAM_LIST::RemoveEntry(
    const CHAR * pszFieldName
    )
/*++

Routine Description:

    Removes all occurrences of the specified fieldname from the list

Arguments:

    pszField - Field to remove

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;
    LIST_ENTRY *       pleNext;
    BOOL               fFound = FALSE;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = pleNext )
    {
        pleNext = ple->Flink;

        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszFieldName ))
        {
            //
            //  We found a matching field, remove it
            //

            RemoveEntryList( ple );

            InsertHeadList( &_FreeHead, ple );

            fFound = TRUE;
        }
    }

    return (fFound);
}


VOID *
PARAM_LIST::NextPair(
    VOID *   pCookie,
    CHAR * * ppszField,
    CHAR * * ppszValue
    )
/*++

Routine Description:

    Enumerates the field and values in this parameter list

Arguments:

    pCookie - Stores location in enumeration, set to NULL for new enumeration
    ppszField - Receives field
    ppszValue - Receives corresponding value

Return Value:

    NULL when the enumeration is complete

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  pCookie points to the ListEntry in the FIELD_VALUE_PAIR class
    //
    if ( pCookie == NULL )
    {

        if ( IsListEmpty( &_FieldListHead ))
        {
            return NULL;
        }

        //
        //  Start a new enumeration
        //

        pCookie = (VOID *) _FieldListHead.Flink;
    }
    else
    {
        //
        //  Have we finished the current enumeration?
        //

        if ( pCookie == (VOID *) &_FieldListHead )
        {
            return NULL;
        }
    }

    pFVP = CONTAINING_RECORD( pCookie, FIELD_VALUE_PAIR, ListEntry );

    *ppszField = pFVP->QueryField();
    *ppszValue = pFVP->QueryValue();

    pCookie = pFVP->ListEntry.Flink;

    return pCookie;
}

VOID *
PARAM_LIST::NextPair(
    VOID *   pCookie,
    CHAR * * ppszField,
    DWORD *  pcbField,
    CHAR * * ppszValue,
    DWORD *  pcbValue
    )
/*++

Routine Description:

    Enumerates the field and values in this parameter list

Arguments:

    pCookie - Stores location in enumeration, set to NULL for new enumeration
    ppszField - Receives field
    pcbField -  Receives pointer to length of field
    ppszValue - Receives corresponding value
    pcbValue -  Receives pointer to length of value

Return Value:

    NULL when the enumeration is complete

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  pCookie points to the ListEntry in the FIELD_VALUE_PAIR class
    //

    if ( pCookie == NULL )
    {

        if ( IsListEmpty( &_FieldListHead ))
        {
            return NULL;
        }

        //
        //  Start a new enumeration
        //

        pCookie = (VOID *) _FieldListHead.Flink;
    }
    else
    {
        //
        //  Have we finished the current enumeration?
        //

        if ( pCookie == (VOID *) &_FieldListHead )
        {
            return NULL;
        }
    }

    pFVP = CONTAINING_RECORD( pCookie, FIELD_VALUE_PAIR, ListEntry );

    *ppszField = pFVP->QueryField();
    *pcbField  = pFVP->_strField.QueryCB();

    *ppszValue = pFVP->QueryValue();
    *pcbValue  = pFVP->_strValue.QueryCB();

    pCookie = pFVP->ListEntry.Flink;

    return pCookie;
}

DWORD
PARAM_LIST::GetCount(
    VOID
    )
{
    LIST_ENTRY * pEntry;
    DWORD        cParams = 0;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    for ( pEntry = _FieldListHead.Flink;
          pEntry != &_FieldListHead;
          pEntry = pEntry->Flink )
    {
        cParams++;
    }

    return cParams;
}


VOID
PARAM_LIST::CanonList(
    VOID
    )
{
    FIELD_VALUE_PAIR * pFVP;
    PLIST_ENTRY        listEntry;
    PLIST_ENTRY        nextEntry;
    PLIST_ENTRY        tmpEntry;

    DBG_ASSERT(!m_fCanonicalized);

    //
    // Go through the list and make sure that there are no dups.
    // if there are, convert them into comma separated lists.
    //

    for ( listEntry  = _FieldListHead.Flink;
          listEntry != &_FieldListHead;
          listEntry  = nextEntry
          )
    {
        DWORD fieldLen;
        PCHAR fieldName;

        nextEntry = listEntry->Flink;

        pFVP = CONTAINING_RECORD( listEntry, FIELD_VALUE_PAIR, ListEntry );


        //
        // if field or value is empty, zap it
        //

        if ( (*pFVP->QueryField() == '\0') ||
             (*pFVP->QueryValue() == '\0') )
        {

            RemoveEntryList( listEntry );
            InsertHeadList( &_FreeHead, listEntry );
            continue;
        }

        fieldName = pFVP->QueryField();
        fieldLen = pFVP->_strField.QueryCB();

        //
        // Walk the rest of the list and look for dup fields
        //

        tmpEntry = nextEntry;

        while ( tmpEntry != &_FieldListHead )
        {

            FIELD_VALUE_PAIR * pTmpFVP;
            pTmpFVP = CONTAINING_RECORD(
                                tmpEntry,
                                FIELD_VALUE_PAIR,
                                ListEntry );

            //
            // combine the two fields
            //

            if ( (pTmpFVP->_strField.QueryCB() == fieldLen) &&
                 (_stricmp(pTmpFVP->QueryField(), fieldName) == 0) &&
                 (*pTmpFVP->QueryValue() != '\0') )
            {

                pFVP->_cValues++;

                (VOID)( pFVP->_strValue.Append( "," ) &&
                      pFVP->_strValue.Append(pTmpFVP->QueryValue()) );

                pTmpFVP->_strField.Reset();
            }

            tmpEntry = tmpEntry->Flink;
        }
    }

    m_fCanonicalized = TRUE;
    return;

} // PARAM_LIST::CanonList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\olehack.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    olehack.cxx

    This module contains the code that will allow single threaded ole apps
    to run in the Gibraltar service.


    FILE HISTORY:
        Johnl       22-Sep-1994     Created

*/


#include "w3p.hxx"
#include <objbase.h>        // for CoInitialize/Uninitialize

HANDLE hOleHackEvent = NULL;
HANDLE hOleHackThread = NULL;

//
//  Private constants.
//

//
//  Time to wait for the ole thread to exit
//

#define WAIT_FOR_OLE_THREAD             (30 * 1000)

//
//  Private prototypes
//

DWORD
OleHackThread(
    PVOID pv
    );


DWORD
InitializeOleHack(
    VOID
    )
/*++

Routine Description:

    Creates a main OLE thread so older OLE controls (including VB4) work

Return Value:

    NO_ERROR on success

--*/
{
    DWORD idThread;

    //
    //  Create the exit event
    //

    hOleHackEvent = IIS_CREATE_EVENT(
                        "hOleHackEvent",
                        &hOleHackEvent,
                        TRUE,
                        FALSE
                        );

    if ( !hOleHackEvent )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Unable to create OleHack event[err %d]\n", GetLastError()));
        return GetLastError();
    }

    //
    //  Create the main Ole thread
    //

    hOleHackThread = CreateThread( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) OleHackThread,
                                   NULL,
                                   0,
                                   &idThread );

    if ( !hOleHackThread )
    {
        DWORD err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
            "Unable to create OleHack thread[err %d]\n", err));
        CloseHandle( hOleHackEvent );
        return err;
    }

    return NO_ERROR;
}

DWORD
OleHackThread(
    PVOID pv
    )
/*++

Routine Description:

    Message loop thread for OLE controls

--*/
{
    HRESULT hr;
    MSG     msg;
    DWORD   ret;

    DBGPRINTF(( DBG_CONTEXT,
                "[OleHackThread] entered, thread ID %x\n",
                GetCurrentThreadId() ));

    hr = CoInitialize( NULL );

    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[OleHackThread] CoInitialize failed with error %lx\n",
                    hr ));

        return 0;
    }

    while ( TRUE )
    {
        ret = MsgWaitForMultipleObjects( 1,
                                         &hOleHackEvent,
                                         FALSE,
                                         INFINITE,
                                         QS_ALLINPUT );

        if ( ret == WAIT_OBJECT_0 )
        {
            break;
        }

        while ( PeekMessage( &msg,
                             NULL,
                             0,
                             0,
                             PM_REMOVE ))
        {
            DispatchMessage( &msg );
        }
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[OleHackThread] loop exited, calling CoUnitialize\n" ));

    CoUninitialize();

    DBGPRINTF(( DBG_CONTEXT,
                "[OleHackThread] Exiting thread\n" ));

    return 0;
}


VOID
TerminateOleHack(
    VOID
    )
/*++

Routine Description:

    Terminates the ole thread

--*/
{
    //
    //  Make sure we've been initialized
    //

    if ( !hOleHackEvent )
        return;

    //
    //  Signal the thread then wait for it to exit
    //

    DBG_REQUIRE( SetEvent( hOleHackEvent ));

    if ( WAIT_TIMEOUT == WaitForSingleObject( hOleHackThread,
                                              WAIT_FOR_OLE_THREAD ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[OleHackTerminate] Warning - WaitForSingleObject timed out\n" ));
    }

    DBG_REQUIRE( CloseHandle( hOleHackEvent ) );
    DBG_REQUIRE( CloseHandle( hOleHackThread ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\rpcsupp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    rpcsupp.cxx

    This module contains support routines for the W3 Service RPC
    interface.


    FILE HISTORY:
        KeithMo     23-Mar-1993 Created.

*/


#include "w3p.hxx"
#include "w3svci_s.h"
#include <timer.h>
#include <time.h>


//
//  Private globals.
//

//
//  Private prototypes.
//

BOOL
WriteParams(
    W3_CONFIG_INFO * pConfig
    );

//
//  Public functions.
//

NET_API_STATUS
NET_API_FUNCTION
W3rSetAdminInformation(
    IN  LPWSTR           pszServer OPTIONAL,
    IN  W3_CONFIG_INFO * pConfig
    )
{
    return ERROR_NOT_SUPPORTED;
}

NET_API_STATUS
NET_API_FUNCTION
W3rGetAdminInformation(
    IN  LPWSTR             pszServer OPTIONAL,
    OUT LPW3_CONFIG_INFO * ppConfig
    )
{
    return ERROR_NOT_SUPPORTED;
}

/*******************************************************************

    NAME:       W3rEnumerateUsers

    SYNOPSIS:   Enumerates the connected users.  This is a server-side
                worker routine for RPC.

    ENTRY:      pszServer - Target server (unused).

                pBuffer - Will receive the number of entries and a
                    pointer to the enumeration buffer.

    RETURNS:    NET_API_STATUS - Net status code, NERR_Success if OK.

    HISTORY:
        KeithMo     23-Mar-1993 Created.

********************************************************************/
NET_API_STATUS
NET_API_FUNCTION
W3rEnumerateUsers( W3_IMPERSONATE_HANDLE pszServer,
                   LPW3_USER_ENUM_STRUCT pBuffer )
{
    APIERR err;
    //DWORD  cbBuffer;

    DBG_ASSERT( pBuffer != NULL );

    UNREFERENCED_PARAMETER(pszServer);

    IF_DEBUG( RPC )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "in W3rEnumerateUsers\n" ));
    }

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_ENUMERATE_USERS );

    if( err != NO_ERROR )
    {
        IF_DEBUG( RPC )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "W3rEnumerateUsers failed access check, error %lu\n",
                        err ));
        }

        return (NET_API_STATUS)err;
    }

#if 0
    //
    //  Lock the user database.
    //

    LockUserDatabase();

    //
    //  Determine the necessary buffer size.
    //

    pBuffer->EntriesRead = 0;
    pBuffer->Buffer      = NULL;

    cbBuffer  = 0;
    err       = NERR_Success;

    EnumerateUsers( pBuffer, &cbBuffer );

    if( cbBuffer > 0 )
    {
        //
        //  Allocate the buffer.  Note that we *must*
        //  use midl_user_allocate/midl_user_free.
        //

        pBuffer->Buffer = (W3_USER_INFO *) MIDL_user_allocate( (unsigned int)cbBuffer );

        if( pBuffer->Buffer == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            //  Since we've got the user database locked, there
            //  *should* be enough room in the buffer for the
            //  user data.  If there isn't, we've messed up
            //  somewhere.
            //

            TCP_REQUIRE( EnumerateUsers( pBuffer, &cbBuffer ) );
        }
    }

    //
    //  Unlock the user database before returning.

    UnlockUserDatabase();

#endif //0

    return (NET_API_STATUS)err;

}   // W3rEnumerateUsers

/*******************************************************************

    NAME:       W3rDisconnectUser

    SYNOPSIS:   Disconnects a specified user.  This is a server-side
                worker routine for RPC.

    ENTRY:      pszServer - Target server (unused).

                idUser - Identifies the user to disconnect.  If 0,
                    then disconnect ALL users.

    RETURNS:    NET_API_STATUS - Net status code, NERR_Success if OK.

    HISTORY:
        KeithMo     23-Mar-1993 Created.

********************************************************************/
NET_API_STATUS
NET_API_FUNCTION
W3rDisconnectUser( W3_IMPERSONATE_HANDLE pszServer,
                   DWORD                  idUser )
{
    APIERR err = NERR_Success;

    UNREFERENCED_PARAMETER(pszServer);

    IF_DEBUG( RPC )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "in W3rDisconnectUser\n" ));
    }

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_DISCONNECT_USER );

    if( err != NO_ERROR )
    {
        IF_DEBUG( RPC )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "W3rDisconnectUser failed access check, error %lu\n",
                        err ));
        }

        return (NET_API_STATUS)err;
    }

    //
    //  Do it.
    //

    if( idUser == 0 )
    {
        CLIENT_CONN::DisconnectAllUsers();
    }
    else
    {
#if 0
        if( !DisconnectUser( idUser ) )
        {
            err = NERR_UserNotFound;
        }
#endif
    }

    return (NET_API_STATUS)err;

}   // W3rDisconnectUser

/*******************************************************************

    NAME:       W3rQueryStatistics

    SYNOPSIS:   Queries the current server statistics.  This is a
                server-side worker routine for RPC.

    ENTRY:      pszServer - Target server (unused).

                Level - Info level.  Currently only level 0 is
                    supported.

                pBuffer - Will receive a poitner to the statistics
                    structure.

    RETURNS:    NET_API_STATUS - Net status code, NERR_Success if OK.

    HISTORY:
        KeithMo     02-Jun-1993 Created.

********************************************************************/
NET_API_STATUS
NET_API_FUNCTION
W3rQueryStatistics( W3_IMPERSONATE_HANDLE pszServer,
                    DWORD Level,
                    LPSTATISTICS_INFO pBuffer )
{
    APIERR err;

    TCP_ASSERT( pBuffer != NULL );

    UNREFERENCED_PARAMETER(pszServer);

    IF_DEBUG( RPC )
    {
        TCP_PRINT(( DBG_CONTEXT,
                   "in W3rQueryStatistics, level %lu\n", Level ));
    }

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if( err != NO_ERROR )
    {
        IF_DEBUG( RPC )
        {
            TCP_PRINT(( DBG_CONTEXT,
                       "W3rQueryStatistics failed access check, error %lu\n",
                        err ));
        }

        return (NET_API_STATUS)err;
    }

#if 0
    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( Level )
    {
    case 0 :
        {
            LPW3_STATISTICS_0 pstats0;

            pstats0 = (W3_STATISTICS_0 *) MIDL_user_allocate( sizeof(W3_STATISTICS_0) );

            if( pstats0 == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                LockStatistics();
                RtlCopyMemory( pstats0, &W3Stats, sizeof(W3_STATISTICS_0) );
                UnlockStatistics();

                pBuffer->W3Stats0 = pstats0;
                pstats0->TimeOfLastClear = GetCurrentTimeInSeconds() -
                                           pstats0->TimeOfLastClear;
            }
        }
        break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }
#else
    err = ERROR_NOT_SUPPORTED;
#endif
    return (NET_API_STATUS)err;

}   // W3rQueryStatistics


/*******************************************************************

    NAME:       W3rClearStatistics

    SYNOPSIS:   Clears current server statistics.  This is a
                server-side worker routine for RPC.

    ENTRY:      pszServer - Target server (unused).

    RETURNS:    NET_API_STATUS - Net status code, NERR_Success if OK.

    HISTORY:
        KeithMo     02-Jun-1993 Created.

********************************************************************/
NET_API_STATUS
NET_API_FUNCTION
W3rClearStatistics( W3_IMPERSONATE_HANDLE pszServer )
{
    APIERR err;

    UNREFERENCED_PARAMETER(pszServer);

    IF_DEBUG( RPC )
    {
        TCP_PRINT(( DBG_CONTEXT,
                   "in W3rClearStatistics\n" ));
    }

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_CLEAR_STATISTICS );

    if( err != NO_ERROR )
    {
        IF_DEBUG( RPC )
        {
            TCP_PRINT(( DBG_CONTEXT,
                       "W3rClearStatistics failed access check, error %lu\n",
                         err ));
        }

        return (NET_API_STATUS)err;
    }

#if 0
    //
    //  Clear the statistics.
    //

    ClearStatistics();

#else
    err = ERROR_NOT_SUPPORTED;
#endif
    return (NET_API_STATUS)err;

}   // W3rClearStatistics


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\ptable.cxx ===
/*-----------------------------------------------------------------------------

   Copyright    (c)    1995-1998    Microsoft Corporation

   Module  Name :
       ptable.cxx

   Abstract:
       

   Author:
       Lei Jin    ( LeiJin )     13-Oct-1998

   Environment:
       User Mode - Win32

   Project:
       W3 services DLL

-----------------------------------------------------------------------------*/

#include <w3p.hxx>
#include "ptable.hxx"
#include "waminfo.hxx"
#include "comadmin.h"
//#include "comadmii.c"
#include "wamexec.hxx"

VOID
CleanupRecycledProcessEntry(
        VOID * pvContext
        );

//===============================================================================

/*-----------------------------------------------------------------------------
CProcessEntry::CProcessEntry

Constructor for a CProcessEntry.
-----------------------------------------------------------------------------*/
CProcessEntry::CProcessEntry
(  
DWORD   dwProcessId,
HANDLE  hProcessHandle,
LPCWSTR wszPackageId 
)
:   m_dwSignature(0),
    m_dwProcessId(dwProcessId),
    m_hProcessHandle(hProcessHandle),
    m_cRefs(0),
    m_fCrashed(FALSE),
    m_fRecycling(FALSE)
    {
    DBGPRINTF((DBG_CONTEXT, "Initializing new CProcessEntry 0x%p.\r\n", this));

    if (wszPackageId != NULL)
        {
        wcsncpy(static_cast<WCHAR *>(m_wszPackageId), wszPackageId, 39/*uSizeofCLSIDStr*/);
        }
    InitializeListHead(&m_ListHeadOfWamInfo);

    g_pWamDictator->Reference();
    }

CProcessEntry::~CProcessEntry()
{
    g_pWamDictator->Dereference();
}

/*-----------------------------------------------------------------------------
CProcessEntry::Release

Release a reference.  Call destructor if Ref count reaches zero.
-----------------------------------------------------------------------------*/    
void CProcessEntry::Release()
    {
    LONG cRefs = InterlockedDecrement(&m_cRefs);

    if (cRefs == 0)
        {
        delete this;
        }
    }

/*-----------------------------------------------------------------------------
CProcessEntry::AddWamInfoToProcessEntry

Add a WamInfo object to this ProcessEntry linklist.

return TRUE.
-----------------------------------------------------------------------------*/    
bool CProcessEntry::AddWamInfoToProcessEntry
(
CWamInfo* pWamInfo
)
    {
    InsertHeadList(&m_ListHeadOfWamInfo, &pWamInfo->leProcess);
    AddRef();

    return TRUE;
    }

/*-----------------------------------------------------------------------------
CProcessEntry::RemoveWamInfoFromProcessEntry

Remove a waminfo object from this ProcessEntry linklist.

Set fDelete to TRUE if the linklist after removal is empty.

return TRUE.
-----------------------------------------------------------------------------*/  
bool CProcessEntry::RemoveWamInfoFromProcessEntry
(
CWamInfo* pWamInfo,
bool*     fDelete
)
    {
    RemoveEntryList(&pWamInfo->leProcess);
    InitializeListHead(&pWamInfo->leProcess);
    Release();

    *fDelete = FALSE;
    if (IsListEmpty(&m_ListHeadOfWamInfo))
        {
        *fDelete = TRUE;
        }

    return TRUE;
    }

/*-----------------------------------------------------------------------------
CProcessEntry::FindWamInfo

Find a waminfo object from this ProcessEntry's linklist.

If found, returns the object via *ppWamInfo.  Else, set *ppWamInfo to NULL. 

return TRUE.
-----------------------------------------------------------------------------*/  
bool CProcessEntry::FindWamInfo
(
CWamInfo**  ppWamInfo
)
    {
    CWamInfo* pWamInfo = NULL;
    PLIST_ENTRY pleTemp = NULL;

    if (!IsListEmpty(&m_ListHeadOfWamInfo))
        {
        pleTemp = m_ListHeadOfWamInfo.Flink;

        DBG_ASSERT(pleTemp != NULL);

        pWamInfo = CONTAINING_RECORD(
                    pleTemp,
                    CWamInfo,
                    leProcess);

        pWamInfo->Reference();
        }

    *ppWamInfo = pWamInfo;
    return TRUE;
    }

bool CProcessEntry::Recycle()
{
    CWamInfo *      pWamInfo = NULL;
    LIST_ENTRY *    pleTemp = NULL;
    DWORD           dwTimeElapsed = 0;
    DWORD           dwTimeAllowed = 0;

    IF_DEBUG( WAM_ISA_CALLS )
                DBGPRINTF((
                        DBG_CONTEXT,
                        "Recycling CProcessEntry 0x%p m_fRecycling is %d\r\n",
                        this,
                        m_fRecycling
                        ));

    //
    // Only 1 thread gets to do this.
    //

    if ( InterlockedExchange( (LONG*)&m_fRecycling, (LONG)TRUE ) )
    {
        IF_DEBUG( WAM_ISA_CALLS )
                        DBGPRINTF((
                                DBG_CONTEXT,
                                "CProcessEntry 0x%p already recycled.\r\n",
                                this
                                ));

        return TRUE;
    }

    //
    // Grab the write lock on WAM_DICTATOR's hash table and delete
    // all the CWamInfo entries associated with this process.  We
    // need to minimize the time that we hold the write lock because
    // no WAM_REQUESTs will get through as long as we have it.
    //
    // We'll go through the list again after we release the lock and
    // shut down the wam info dudes.
    //

    g_pWamDictator->HashWriteLock();

    pleTemp = m_ListHeadOfWamInfo.Flink;

    while ( pleTemp != &m_ListHeadOfWamInfo )
    {
        pWamInfo = CONTAINING_RECORD(
            pleTemp,
            CWamInfo,
            leProcess
            );

        DBG_ASSERT( pWamInfo );

                if ( !m_dwShutdownTimeLimit )
                {
                        m_dwShutdownTimeLimit = pWamInfo->QueryShutdownTimeLimit();
                }

        g_pWamDictator->DeleteWamInfoFromHashTable( pWamInfo );

        pleTemp = pleTemp->Flink;
    }

    pleTemp = NULL;
    pWamInfo = NULL;

    g_pWamDictator->HashWriteUnlock();

        //
        // Kick off a scheduler a scheduler thread that will cleanup
        // the CWamInfo object for this process entry.
        //

        m_pShuttingDownCWamInfo = NULL;
        m_dwShutdownStartTime = GetCurrentTimeInSeconds();
        AddRef();

        ScheduleWorkItem(
                CleanupRecycledProcessEntry,
                this,
                0,
                FALSE
                );

    return TRUE;
}

//===============================================================================

/*-----------------------------------------------------------------------------
CProcessTable::CProcessTable

Constructor for CProcessTable
-----------------------------------------------------------------------------*/  
CProcessTable::CProcessTable()
    : m_dwCnt(0),
      m_pCurrentProcessId(0),
      m_pCatalog(NULL),
      m_HashTable(LK_DFLT_MAXLOAD, LK_DFLT_INITSIZE, LK_DFLT_NUM_SUBTBLS)
    {
    }

/*-----------------------------------------------------------------------------
CProcessTable::~CProcessTable

Destructor for CProcessTable
-----------------------------------------------------------------------------*/  
CProcessTable::~CProcessTable()
    {
    DBG_ASSERT(m_dwCnt == 0);
    }


/*-----------------------------------------------------------------------------
CProcessTable::Init

Constructor for CProcessTable
Caches inetinfo.exe's process id in m_pCurrentProcessId.
-----------------------------------------------------------------------------*/  
bool CProcessTable::Init()
    {
    INITIALIZE_CRITICAL_SECTION(&m_csPTable);
    m_pCurrentProcessId = GetCurrentProcessId();
    return TRUE;
    }

/*-----------------------------------------------------------------------------
CProcessTable::UnInit

UnInit.  Release the m_pCatalog.
-----------------------------------------------------------------------------*/  
bool CProcessTable::UnInit()
    {
    if (m_pCatalog)
        {
        m_pCatalog->Release();
        m_pCatalog = NULL;
        }
    DeleteCriticalSection(&m_csPTable);
    return FALSE;
    }
    
/*-----------------------------------------------------------------------------
CProcessTable::AddWamInfoToProcessTable

Add a waminfo to the process table.  First find a process entry with the same process id,
if none, create a new process entry.  Then, add the waminfo to that process entry's linklist.

Return pointer to ProcessEntry.
-----------------------------------------------------------------------------*/  
CProcessEntry* CProcessTable::AddWamInfoToProcessTable
(
CWamInfo *pWamInfo,
LPCWSTR  szPackageId,
DWORD pid
)
    {
    HANDLE          hProcess = INVALID_HANDLE_VALUE;
    CProcessEntry*  pProcEntry = NULL;
    bool            fReturn = TRUE;

    Lock();
    m_HashTable.FindKey(pid, &pProcEntry);

    if (pProcEntry)
        {
        pProcEntry->AddWamInfoToProcessEntry(pWamInfo);
        pProcEntry->Release();
        }
    else
        {
        hProcess = OpenProcess( 
                        PROCESS_DUP_HANDLE | PROCESS_TERMINATE | PROCESS_SET_QUOTA, // get duplicate handle
                        FALSE,              // fInheritable = ?
                        pid );
        if (hProcess)
            {
            pProcEntry = new CProcessEntry(pid, hProcess, szPackageId);
            if (pProcEntry)
                {
                LK_RETCODE  lkReturn;
                bool        fDelete;
                pProcEntry->AddWamInfoToProcessEntry(pWamInfo);
                
                if ( LK_SUCCESS != m_HashTable.InsertRecord(pProcEntry))
                    {
                    pProcEntry->RemoveWamInfoFromProcessEntry(pWamInfo, &fDelete);
                    fReturn = FALSE;
                    }

                if (fReturn == FALSE)
                    {
                    delete pProcEntry;
                    pProcEntry = NULL;
                    }
                }
            else
                {
                SetLastError(E_OUTOFMEMORY);
                fReturn = FALSE;
                }
            }

        if (fReturn == FALSE)
            {
            CloseHandle(hProcess);
            hProcess = INVALID_HANDLE_VALUE;
            }
        }
        
    UnLock();
    return pProcEntry;      
    }

/*-----------------------------------------------------------------------------
CProcessTable::FindWamInfo

Giving a process entry, and find a Waminfo in that process entry's linklist.

return TRUE/FALSE.
-----------------------------------------------------------------------------*/  
bool CProcessTable::FindWamInfo
(
CProcessEntry   *pProcEntry,
CWamInfo        **ppWamInfo
)
    {
    bool fRet;
    DBG_ASSERT(pProcEntry != NULL);
    Lock();
    fRet = pProcEntry->FindWamInfo(ppWamInfo);
    UnLock();

    return fRet;
    }

bool CProcessTable::RecycleWamInfo
(
CWamInfo *  pWamInfo
)
    {
    BSTR            bstrInstanceId = NULL;
    HRESULT         hr = NOERROR;
    CProcessEntry * pProcEntry = NULL;
    DWORD           dwProcEntryPid;
    VARIANT         varInstanceId = {0};

    DBG_ASSERT( pWamInfo );

    IF_DEBUG( WAM_ISA_CALLS )
                DBGPRINTF((
                        DBG_CONTEXT,
                        "Recycling CWamInfo 0x%p.\r\n",
                        pWamInfo
                        ));

    //
    // Get the com admin application interface
    //

    if (m_pCatalog == NULL)
    {
        // Create instance of the catalog object
        hr = CoCreateInstance(
            CLSID_COMAdminCatalog,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_ICOMAdminCatalog2,
            (void**)&m_pCatalog
            );

        if (FAILED(hr))
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Failed to CoCreateInstance of CLSID_ICOMAdminCatalog2, hr = %08x\n",
                hr
                ));
            
            goto Finished;
        }
    }

    pProcEntry = pWamInfo->QueryProcessEntry();

    if ( pProcEntry )
    {
        pProcEntry->AddRef();
    }

    //
    // If the application is inproc, then we don't want to
    // recycle it.
    //

    if ( pWamInfo->FInProcess() || !pProcEntry )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Failing to recycle CProcessEntry 0x%d.  OOP=%d.\r\n",
            pProcEntry,
            pWamInfo->FInProcess
            ));
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    //
    // If the process has already been recycled, then we
    // don't need to recycle it.
    //

    if ( pProcEntry->IsRecycling() )
    {
        IF_DEBUG( WAM_ISA_CALLS )
                        DBGPRINTF((
                                DBG_CONTEXT,
                                "ProcEntry 0x%p is already recycling.\r\n",
                                pProcEntry
                                ));
        
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    //
    // Get the Instance ID
    //

    dwProcEntryPid = pProcEntry->QueryProcessId();

    hr = m_pCatalog->GetApplicationInstanceIDFromProcessID( dwProcEntryPid, &bstrInstanceId );

    if ( FAILED( hr ) )
    {
                pWamInfo->Print();

        DBGPRINTF((
            DBG_CONTEXT,
            "Failed to get instance ID for application '%s'. "
            "Error=0x%08x, CProcessEntry=0x%p, PID=%d.\r\n",
            pWamInfo->QueryApplicationPath().QueryStr(),
            hr,
                        pProcEntry,
                        dwProcEntryPid
            ));

        goto Finished;
    }

    DBG_ASSERT( bstrInstanceId );

    //
    // Call the COM+ function to recycle the process.
    // If this fails, we'll just return the error and let
    // the existing instance continue handling requests.
    //
    // CODEWORK
    //
    // The second argument to RecycleProcess should be
    // CRR_RECYCLED_FROM_API, but that constant was not
    // been defined yet...
    //

    varInstanceId.vt = VT_BSTR;
    varInstanceId.bstrVal = bstrInstanceId;

    hr = m_pCatalog->RecycleApplicationInstances( &varInstanceId, 0 );

    if ( FAILED( hr ) )
    {
        //
        // CODEWORK
        //
        // Need to write an event to the log for this failure.
        //

        DBGPRINTF((
            DBG_CONTEXT,
            "Error recycling application.  App = %s, "
            "Instance ID = %S, hr = 0x%08x\r\n",
            pWamInfo->QueryApplicationPath().QueryStr(),
            bstrInstanceId,
            hr
            ));

        goto Finished;
    }

    //
    // Notify the process entry that it has been
    // recycled.
    //

    if ( !pProcEntry->Recycle() )
        {
                hr = E_FAIL;
        }

Finished:

    VariantClear(&varInstanceId);

    if ( pProcEntry != NULL )
    {
        pProcEntry->Release();
    }

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    return TRUE;
}

/*-----------------------------------------------------------------------------
CProcessTable::RemoveWamInfoFromProcessTable

Remove the WamInfo from the process table.  Using pWaminfo to find ProcessEntry.  Then,
Search the hashtable to find ProcessEntry, and then call ProcessEntry to remove the WamInfo
from that process entry's linklist.

Return TRUE/FALSE.
-----------------------------------------------------------------------------*/  
bool CProcessTable::RemoveWamInfoFromProcessTable
(
CWamInfo *pWamInfo
)
    {
    CProcessEntry*   pProcEntry = pWamInfo->QueryProcessEntry();
    bool            fDelete;
/*
    DBGPRINTF((
        DBG_CONTEXT,
        "CProcessTable::RemoveWamInfoFromProcessTable called on CWamInfo 0x%p.\r\n",
        pWamInfo
        ));
*/
    DBG_ASSERT(pProcEntry != NULL);

    if (pProcEntry != NULL)
        {
        pProcEntry->AddRef();
        }
    else
        {
        return FALSE;
        }

    Lock();
    pProcEntry->RemoveWamInfoFromProcessEntry(pWamInfo, &fDelete);
    if (fDelete)
        {
        LK_RETCODE LkReturn;

        LkReturn = m_HashTable.DeleteRecord(pProcEntry);
        DBG_ASSERT(LkReturn == LK_SUCCESS);

        if (pProcEntry->QueryProcessId() != m_pCurrentProcessId
            && !pProcEntry->IsCrashed())
            {
            ShutdownProcess(pProcEntry->QueryProcessId());
            }
        CloseHandle(pProcEntry->QueryProcessHandle());
        }
    UnLock();

    pProcEntry->Release();
        
    return fDelete;
    }

/*-----------------------------------------------------------------------------
CProcessTable::ShutdownPackage

Shut down the out of process package,(wszPackageID).

If the m_pCatalog is not CoCreated, then, m_pCatalog will be created first, and call COM+
ShutdownApplication() to shutdown a package.

Return:
HRESULT
-----------------------------------------------------------------------------*/
HRESULT
CProcessTable::ShutdownProcess
(
DWORD   dwProcEntryPid
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::ShutdownPackage\n"));

    HRESULT                 hr = NOERROR;
    BSTR                    bstrInstanceId = NULL;
    VARIANT                 varInstanceId = {0};

    if (m_pCatalog == NULL)
        {
        //CONSIDER : CoCreateInstance Catalog object in everycall might not be a bad idea.
        //
        // Create instance of the catalog object
        hr = CoCreateInstance(CLSID_COMAdminCatalog
                                        , NULL
                                        , CLSCTX_INPROC_SERVER
                                        , IID_ICOMAdminCatalog2
                                        , (void**)&m_pCatalog);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to CoCreateInstance of CLSID_ICOMAdminCatalog2, hr = %08x\n",
                    hr));
            goto LErrExit;
            }
        }

    hr = m_pCatalog->GetApplicationInstanceIDFromProcessID( dwProcEntryPid, &bstrInstanceId );

        if (FAILED(hr))
        {
                DBGPRINTF((DBG_CONTEXT, "ShutdownProcess failed to obtain instance ID, PID=%d, "
                               "hr=0x%08x.\r\n", dwProcEntryPid, hr));

                goto LErrExit;

        }

    varInstanceId.vt = VT_BSTR;
    varInstanceId.bstrVal = bstrInstanceId;
    hr = m_pCatalog->ShutdownApplicationInstances(&varInstanceId);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to ShutdownProcess, PID=%d, instanceid=%S, hr=%08x\n",
                        dwProcEntryPid,
                        bstrInstanceId,
                        hr));
        }

LErrExit:

    if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to ShutdownPackage, hr = %08x\n",
                        hr));
        
        // Perhaps an over-aggressive assert.  Remove for now.  
        // 
        // DBG_ASSERT(SUCCEEDED(hr));
        }
        
    VariantClear(&varInstanceId);

    return hr;
    }//CProcessTable::ShutdownPackage

VOID
CleanupRecycledProcessEntry(
        VOID * pvContext
        )
{
        CProcessEntry * pProcEntry = (CProcessEntry*)pvContext;
        LIST_ENTRY *    pleTemp;
        DWORD                   dwCurrentRequests;
    BOOL            fW3SvcShuttingDown;

        DBG_ASSERT( pProcEntry );

        //
        // If there is no CWamInfo shutting down, check for the
        // next one.  If there is another on the list, queue a
        // work item to shut it down, else we're done and can
        // release the CProcessEntry.
        //

        if ( !pProcEntry->m_pShuttingDownCWamInfo )
        {
                if ( IsListEmpty( &pProcEntry->m_ListHeadOfWamInfo ) )
                {
                        //
                        // All CWamInfos are shut down.  Release our
                        // reference on the CProcessEntry and return
                        //

                        pProcEntry->Release();

                        return;
                }

                //
                // Get the next CWamInfo and schedule it for shutdown
                //

                pleTemp = RemoveHeadList( &pProcEntry->m_ListHeadOfWamInfo );

                pProcEntry->m_pShuttingDownCWamInfo = CONTAINING_RECORD(
                        pleTemp,
                        CWamInfo,
                        leProcess
                        );

                DBG_ASSERT( pProcEntry->m_pShuttingDownCWamInfo );

                pProcEntry->m_pShuttingDownCWamInfo->Reference();
                pProcEntry->m_pShuttingDownCWamInfo->ChangeToState( WIS_SHUTDOWN );

                ScheduleWorkItem(
                        CleanupRecycledProcessEntry,
                        pProcEntry,
                        0,
                        FALSE
                        );

                return;
        }

        //
        // If we get here, the then we are shutting down a CWamInfo.
        // There are 4 possible scenarios here:
        //
        // The shutdown time limit has been exceeded.  In this case,
        // we'll force the CWamInfo closed immediately.
        //
        // The CWamInfo has no requests remaining in flight.  In this
        // case, we'll gracefully shut down the CWamInfo.
        //
        // The CWamInfo still has requests remaining in flight.  In
        // this case, we'll schedule another work item and check again
        // in 1000ms.
    //
    // W3SVC is shutting down, in which case we want to treat it
    // the same as if the timeout has expired and we're immediately
    // closing all CWamInfo's forcably.
        //

    DBG_ASSERT( g_pWamDictator );
    
    fW3SvcShuttingDown =  g_pWamDictator->FIsShutdown();

        DWORD dwTime = GetCurrentTimeInSeconds();

        if ( GetCurrentTimeInSeconds() - pProcEntry->m_dwShutdownStartTime >
                 pProcEntry->m_dwShutdownTimeLimit ||
         fW3SvcShuttingDown )
        {
                //
                // Forceably shut down the CWamInfo.  Calling StartShutdown
                // will cause the CWamInfo's m_pIWam to disconnect immediately.
                //

                IF_DEBUG( WAM_ISA_CALLS )
                        DBGPRINTF((
                                DBG_CONTEXT,
                                "CProcessEntry 0x%08x forceably shutting down CWamInfo 0x%08x\r\n",
                                pProcEntry,
                                pProcEntry->m_pShuttingDownCWamInfo
                                ));

                pProcEntry->m_pShuttingDownCWamInfo->StartShutdown(0);
                pProcEntry->m_pShuttingDownCWamInfo->UnInit();
                pProcEntry->m_pShuttingDownCWamInfo->Dereference(); // This function's ref
                pProcEntry->m_pShuttingDownCWamInfo->Dereference(); // WAM_DICTATOR's ref
                pProcEntry->m_pShuttingDownCWamInfo = NULL;

                ScheduleWorkItem(
                        CleanupRecycledProcessEntry,
                        pProcEntry,
                        0,
                        FALSE
                        );

                return;
        }

        dwCurrentRequests = pProcEntry->m_pShuttingDownCWamInfo->QueryCurrentRequests();

        if ( dwCurrentRequests  )
        {
                //
                // Requests remaining - try again in 1000ms
                //

                DBGPRINTF((
                        DBG_CONTEXT,
                        "CProcessEntry 0x%08x, CWamInfo 0x%08x, waiting for %d requests.\r\n",
                        pProcEntry,
                        pProcEntry->m_pShuttingDownCWamInfo,
                        dwCurrentRequests
                        ));

                ScheduleWorkItem(
                        CleanupRecycledProcessEntry,
                        pProcEntry,
                        1000,
                        FALSE
                        );

                return;
        }

        //
        // Finally, if we get here, then we have a CWamInfo with no
        // requests remaining in flight.  We can just Uninit and release
        // it.
        //

        pProcEntry->m_pShuttingDownCWamInfo->UnInit();
        pProcEntry->m_pShuttingDownCWamInfo->Dereference(); // This functions's ref
        pProcEntry->m_pShuttingDownCWamInfo->Dereference(); // WAM_DICTATOR's ref
        pProcEntry->m_pShuttingDownCWamInfo = NULL;

        ScheduleWorkItem(
                CleanupRecycledProcessEntry,
                pProcEntry,
                0,
                FALSE
                );

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\rpcex.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        rpcex.cxx

   Abstract:

        This module defines K2 rpc support.

   Author:

        Johnson Apacible    (JohnsonA)      June-19-1996

--*/


#include "w3p.hxx"
#include "w3svci_s.h"
#include <timer.h>
#include <time.h>

#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include "httpxpc.h"


BOOL
IsEncryptionPermitted(
                VOID
                )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
    LCID DefaultLcid;
    WCHAR CountryCode[10];
    ULONG CountryValue;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c) {
        return(FALSE);
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfoW(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0) {
        return(FALSE);
    }

    CountryValue = (ULONG) wcstol(CountryCode,NULL,10);
    if (CountryValue == CTRY_FRANCE) {
        return(FALSE);
    }
    return(TRUE);

} // IsEncryptionPermitted



DWORD
W3_SERVER_INSTANCE::QueryEncCaps(
    VOID
    )
/*++

   Description

       Returns encryption capability

   Arguments:

       None

   Return:

       Encryption capability

--*/
{
    //
    //  Get the encryption capability bits.  SecurePort may be zero because
    //  no keys are installed or the locale does not allow encryption
    //

    return !HasSecureBindings()
        ? (IsEncryptionPermitted()
                ? ENC_CAPS_NOT_INSTALLED
                : ENC_CAPS_DISABLED)
        // note : we do not currently support PCT
        : ENC_CAPS_SSL;
} // W3_SERVER_INSTANCE::QueryEncCaps



BOOL
W3_SERVER_INSTANCE::SetServiceConfig(
    IN PCHAR pBuffer
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pConfig - Admin information to set

   Note:

--*/
{
    LPW3_CONFIG_INFO pConfig = (LPW3_CONFIG_INFO)pBuffer;

    if ( !WritePublicW3Params( pConfig ) ||
         !ReadPublicW3Params( pConfig->FieldControl ))
    {
        return FALSE;
    }

    return TRUE;

} // W3_SERVER_INSTANCE::SetServiceConfig




BOOL
W3_SERVER_INSTANCE::GetServiceConfig(
    IN  PCHAR   pBuffer,
    IN  DWORD   dwLevel
    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pBuffer - Buffer to fill up.
       dwLevel - info level of information to return.

   Note:

--*/
{
    LPW3_CONFIG_INFO    pConfig = (LPW3_CONFIG_INFO)pBuffer;
    DWORD               err = NO_ERROR;
    MB                  MetaInfo( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    STR                 strDefaultFile;

    ZeroMemory( pConfig, sizeof( W3_CONFIG_INFO ) );

    // We want to open a read handle to the server instance
    // name, and then we'll read the indivdual info out next.
    //

    if ( !MetaInfo.Open( QueryMDVRPath() ))
    {
        return FALSE;
    }

    LockThisForRead();

    //
    //  Get always retrieves all of the parameters
    //

    pConfig->FieldControl = FC_W3_ALL;

    if (!MetaInfo.GetDword("/", MD_DIRECTORY_BROWSING,
        IIS_MD_UT_FILE, &pConfig->dwDirBrowseControl))
    {
        err = GetLastError();
        if (err ==  MD_ERROR_DATA_NOT_FOUND)
        {
            pConfig->dwDirBrowseControl = DEFAULT_DIR_BROWSE_CONTROL;
            err = NO_ERROR;
        }
        else
        {
            goto done;
        }

    }

    if ( !MetaInfo.GetStr( "/",
                           MD_DEFAULT_LOAD_FILE,
                           IIS_MD_UT_FILE,
                           &strDefaultFile,
                           METADATA_INHERIT,
                           "default.htm" ))
    {
        err = GetLastError();
        goto done;
    }

    pConfig->fCheckForWAISDB   = FALSE;
    pConfig->fServerAsProxy    = FALSE;
    pConfig->fSSIEnabled       = FALSE;
    pConfig->csecGlobalExpire  = 0;

    //
    //  Set the encryption capability bits.  SecurePort may be zero
    //  because no keys are installed or the locale does not allow
    //  encryption
    //

    pConfig->dwEncCaps |= QueryEncCaps();

    if ( !ConvertStringToRpc( &pConfig->lpszDefaultLoadFile,
                              strDefaultFile.QueryStr() ) ||
         !ConvertStringToRpc( &pConfig->lpszDirectoryImage,
                              "" )  ||
         !ConvertStringToRpc( &pConfig->lpszSSIExtension,
                              "" ))
    {
        err = GetLastError();

        FreeRpcString( pConfig->lpszDefaultLoadFile );
        FreeRpcString( pConfig->lpszDirectoryImage );
        FreeRpcString( pConfig->lpszCatapultUser );
        FreeRpcString( pConfig->lpszSSIExtension );
    }


done:
    UnlockThis();

    SetLastError(err);
    return(err==NO_ERROR);

} // W3_SERVER_INSTANCE::GetServiceConfig




BOOL
W3_SERVER_INSTANCE::EnumerateUsers(
    OUT PCHAR * pBuffer,
    OUT PDWORD  nRead
    )
/*++

   Description

       Enumerates the connected users.

   Arguments:

       pBuffer - Buffer to fill up.

--*/
{
    BOOL fRet = TRUE;

#if 0
    //
    //  Lock the user database.
    //

    LockUserDatabase();

    //
    //  Determine the necessary buffer size.
    //

    pBuffer->EntriesRead = 0;
    pBuffer->Buffer      = NULL;

    cbBuffer  = 0;
    err       = NERR_Success;

    EnumerateUsers( pBuffer, &cbBuffer );

    if( cbBuffer > 0 )
    {
        //
        //  Allocate the buffer.  Note that we *must*
        //  use midl_user_allocate/midl_user_free.
        //

        pBuffer->Buffer = (W3_USER_INFO *) MIDL_user_allocate( (unsigned int)cbBuffer );

        if( pBuffer->Buffer == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            //  Since we've got the user database locked, there
            //  *should* be enough room in the buffer for the
            //  user data.  If there isn't, we've messed up
            //  somewhere.
            //

            TCP_REQUIRE( ::EnumerateUsers( pBuffer, &cbBuffer ) );
        }
    }

    //
    //  Unlock the user database before returning.

    UnlockUserDatabase();

#endif //0

    return fRet;

} // EnumerateUsers


BOOL
W3_SERVER_INSTANCE::DisconnectUser(
                        IN DWORD dwIdUser
                        )
/*++

   Description

       Disconnect the user

   Arguments:

       dwIdUser - Identifies the user to disconnect.  If 0,
           then disconnect ALL users.

--*/
{
    BOOL fRet = TRUE;

    //
    //  Do it.
    //

    if( dwIdUser == 0 )
    {
        CLIENT_CONN::DisconnectAllUsers();
    }
    else
    {
#if 0
        if( !CLIENT_CONN::DisconnectUser( idUser ) )
        {
            err = NERR_UserNotFound;
        }
#endif
    }

    return fRet;

} // DisconnectUser


BOOL
W3_SERVER_INSTANCE::GetStatistics(
                        IN DWORD dwLevel,
                        OUT PCHAR* pBuffer
                        )
/*++

   Description

       Disconnect Queries the server statistics

   Arguments:

       dwLevel - Info level.  Currently only level 0 is
           supported.

       pBuffer - Will receive a pointer to the statistics
           structure.

--*/
{
    APIERR err = NO_ERROR;

    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( dwLevel )
    {
    case 0 :
        {
            LPW3_STATISTICS_1 pstats1;

            pstats1 = (W3_STATISTICS_1 *) MIDL_user_allocate( sizeof(W3_STATISTICS_1) );

            if( pstats1 == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                ATQ_STATISTICS      atqStat;

                ZeroMemory( pstats1, sizeof( W3_STATISTICS_1 ) );

                QueryStatsObj()->CopyToStatsBuffer( pstats1 );

                //
                //  Merge in HTTPEXT statistics
				//
				W3MergeDavPerformanceData( QueryInstanceId(), pstats1 );

                //
                //  Get instance's bandwidth throttling statistics
                //

                if ( QueryBandwidthInfo() )
                {
                    if ( AtqBandwidthGetInfo( QueryBandwidthInfo(),
                                              ATQ_BW_STATISTICS,
                                              (ULONG_PTR *) &atqStat ) )
                    {
                        pstats1->TotalBlockedRequests = atqStat.cBlockedRequests;
                        pstats1->TotalRejectedRequests = atqStat.cRejectedRequests;
                        pstats1->TotalAllowedRequests = atqStat.cAllowedRequests;
                        pstats1->CurrentBlockedRequests = atqStat.cCurrentBlockedRequests;
                        pstats1->MeasuredBw = atqStat.MeasuredBandwidth;
                    }
                }

                pstats1->TimeOfLastClear = GetCurrentTimeInSeconds() -
                                           pstats1->TimeOfLastClear;

                //
                //  Copy Global statistics counter values
                //
                pstats1->CurrentConnections =
                    g_pW3Stats->QueryStatsObj()->CurrentConnections;
                pstats1->MaxConnections =
                    g_pW3Stats->QueryStatsObj()->MaxConnections;
                pstats1->ConnectionAttempts =
                    g_pW3Stats->QueryStatsObj()->ConnectionAttempts;

                *pBuffer = (PCHAR)pstats1;

            }
        }
        break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

    SetLastError(err);
    return(err == NO_ERROR);

} // QueryStatistics



BOOL
W3_SERVER_INSTANCE::ClearStatistics(
                        VOID
                        )
/*++

   Description

       Clears the server statistics

   Arguments:

        None.

--*/
{

    QueryStatsObj()->ClearStatistics();

    return TRUE;

} // ClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\stats.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module Name :
    
       stats.cxx

   Abstract:
    
       Defines functions required for server statistics

   Author:

       Murali R. Krishnan    ( MuraliK )     04-Nov-1994
   
   Project:

       Web Server DLL

   Functions Exported:

               W3_SERVER_STATISTICS::SERVER_STATISTICS( VOID) 
       VOID    W3_SERVER_STATISTICS::ClearStatistics( VOID)
       DWORD   CopyToStatsBuffer( LPW3_STATISTICS_1 lpStat)

   Revision History:

       Sophia Chung ( SophiaC )     20-Nov-1996

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include <w3p.hxx>
# include "stats.hxx"
# include "timer.h"
# include "time.h"


/************************************************************
 *    Functions 
 ************************************************************/


W3_SERVER_STATISTICS::W3_SERVER_STATISTICS( VOID) 
/*++
     Initializes statistics information for server.
--*/
{
    INITIALIZE_CRITICAL_SECTION( & m_csStatsLock);

    ClearStatistics();

} // W3_SERVER_STATISTICS::W3_SERVER_STATISTICS();


VOID
W3_SERVER_STATISTICS::ClearStatistics( VOID)
/*++

    Clears the counters used for statistics information

--*/ 
{
    LockStatistics();

    memset( &m_W3Stats, 0, sizeof(W3_STATISTICS_1) );
    m_W3Stats.TimeOfLastClear       = GetCurrentTimeInSeconds();

    UnlockStatistics();

} // W3_SERVER_STATISTICS::ClearStatistics()



DWORD
W3_SERVER_STATISTICS::CopyToStatsBuffer( LPW3_STATISTICS_1 lpStat)
/*++
    Description:
        copies the statistics data from the server statistcs structure
        to the W3_STATISTICS_1 structure for RPC access.

    Arugments:
        lpStat  pointer to W3_STATISTICS_1 object which contains the 
                data on successful return

    Returns:
        Win32 error codes. NO_ERROR on success. 

--*/
{

    DBG_ASSERT( lpStat != NULL);

    LockStatistics();

    CopyMemory( lpStat, &m_W3Stats, sizeof(W3_STATISTICS_1) );

    UnlockStatistics();

    if (lpStat->ServiceUptime)
    {
        lpStat->ServiceUptime = GetCurrentTimeInSeconds() - lpStat->ServiceUptime;
    }

    return ( NO_ERROR);

} // CopyToStatsBuffer()


VOID 
W3_SERVER_STATISTICS::UpdateStartTime ()
{
    m_W3Stats.ServiceUptime = GetCurrentTimeInSeconds();
}


VOID 
W3_SERVER_STATISTICS::UpdateStopTime ()
{
    m_W3Stats.ServiceUptime = 0;
}


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\security.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    security.c

    This module manages security for the W3 Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.

*/


#include "w3p.hxx"
#include <lonsi.hxx>

DWORD   DeniedFlagTable[] = {   0,
                                SF_DENIED_BY_CONFIG,
                                SF_DENIED_RESOURCE,
                                SF_DENIED_FILTER,
                                SF_DENIED_APPLICATION
                            };

DWORD
DeniedFlagsToSubStatus(
    DWORD   fFlags
)
/*++

Routine Description:

    Map a set of denied flags to a substatus for use in custom error lookup.

Arguments:

    fFlags          - The flags to be mapped.

Return Value:

  The substatus if we can map it, or 0 otherwise.

--*/
{
    int             i;

    fFlags &= ~SF_DENIED_LOGON;

    for (i = 0; i < sizeof(DeniedFlagTable)/sizeof(DWORD);i++)
    {
        if (DeniedFlagTable[i] == fFlags)
        {
            return i+1;
        }
    }

    return 0;
}

//
//  Public functions.
//

BOOL
HTTP_REQ_BASE::SendAuthNeededResp(
    BOOL * pfFinished
    )
/*++

Routine Description:

    Sends an access denied HTTP server response with the accompanying
    authentication schemes the server supports

Parameters:

    pfFinished - If set to TRUE, indicates no further processing is needed
        for this request

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR * pszTail;
    DWORD  cbRespBufUsed;
    DWORD  cbRespBufLeft;
    DWORD  cbNeeded;
    LPCSTR pszAccessDeniedMsg;
    CHAR * pszMsgBody;
    BYTE   cMsgBuffer[128] ={ '\0' };
    BUFFER bufMsg(cMsgBuffer, sizeof(cMsgBuffer));
    DWORD  dwSubStatus;
    DWORD  dwMsgSize;
    DWORD  dwMsgSizeNeeded;
    BOOL   bHaveCustom;
    STR    strAuthHdrs;

    *pfFinished = FALSE;

    if ( QueryRespBuf()->QuerySize() < MIN_BUFFER_SIZE_FOR_HEADERS )
    {
        if ( !QueryRespBuf()->Resize( MIN_BUFFER_SIZE_FOR_HEADERS ) )
        {
            return FALSE;
        }
    }

    if ( !HTTP_REQ_BASE::BuildStatusLine( QueryRespBuf(),
                                          !IsProxyRequest() ? HT_DENIED :
                                                             HT_PROXY_AUTH_REQ,
                                          NO_ERROR ))
    {
        return FALSE;
    }
    
    //
    //  "Server: Microsoft/xxx
    //
    
    pszTail = (char*) QueryRespBuf()->QueryPtr() + QueryRespBufCB();

    APPEND_VER_STR( pszTail );
    
    //
    //  "Date: <GMT Time>" - Time the response was sent.
    //

    // build Date: uses Date/Time cache
    pszTail += g_pDateTimeCache->GetFormattedCurrentDateTime( pszTail );

    //
    // See if we have a custom error message defined for this.
    //

    dwSubStatus = DeniedFlagsToSubStatus(_Filter.QueryDeniedFlags());

    if (CheckCustomError(&bufMsg, !IsProxyRequest() ?
        HT_DENIED : HT_PROXY_AUTH_REQ, dwSubStatus, pfFinished, &dwMsgSize, FALSE))
    {
        DBG_ASSERT(!*pfFinished);

        pszAccessDeniedMsg = (CHAR *)bufMsg.QueryPtr();
        dwMsgSizeNeeded = strlen(pszAccessDeniedMsg);
        bHaveCustom = TRUE;

    }
    else
    {
        pszAccessDeniedMsg = QueryW3Instance()->QueryAccessDeniedMsg();
        if ( memcmp( _strMethod.QueryStr(), "HEAD", 4 ))
        {
            dwMsgSize = strlen(pszAccessDeniedMsg);
        }
        else
        {
            dwMsgSize = 0;
        }
        dwMsgSizeNeeded = dwMsgSize;
        bHaveCustom = FALSE;
    }

    //
    //  If this is not the first call, then return the current authentication
    //  data blob otherwise return the forms of authentication the server
    //  accepts
    //

    if ( IsAuthenticating() )
    {
        if ( !strAuthHdrs.Copy( IsProxyRequest() ? "Proxy-Authenticate" : 
                                                   "WWW-Authenticate" ) ||
             !strAuthHdrs.Append( ": " ) ||
             !strAuthHdrs.Append( _strAuthInfo ) ||
             !strAuthHdrs.Append( "\r\n" ) )
        {
            return FALSE;
        }
    }
    else
    {
        if ( !AppendAuthenticationHdrs( &strAuthHdrs,
                                        pfFinished ))
        {
            return FALSE;
        }

        if ( *pfFinished )
        {
            return TRUE;
        }
    }

    //
    //  Make sure there's enough size for any ISAPI denial headers plus any
    //  admin specified access denied message
    //

    cbRespBufUsed = QueryRespBufCB();
    cbRespBufLeft = QueryRespBuf()->QuerySize() - cbRespBufUsed;

    cbNeeded = dwMsgSizeNeeded +
               _strDenialHdrs.QueryCB()    +
               250 + 
               strAuthHdrs.QueryCB();

    if ( cbNeeded > cbRespBufLeft )
    {
        if ( !QueryRespBuf()->Resize( cbNeeded + cbRespBufUsed ))
        {
            return FALSE;
        }
    }

    pszTail = QueryRespBufPtr() + cbRespBufUsed;
    
    memcpy( pszTail,
            strAuthHdrs.QueryStr(),
            strAuthHdrs.QueryCB() );
    
    pszTail += strAuthHdrs.QueryCB();

    if ( IsKeepConnSet() )
    {
        if (!IsOneOne())
        {
            if ( !IsProxyRequest() )
            {
                APPEND_STRING( pszTail, "Connection: keep-alive\r\n" );
            }
            else
            {
                APPEND_STRING( pszTail, "Proxy-Connection: keep-alive\r\n" );
            }
        }
    } else
    {
        if (IsOneOne())
        {
            if ( !IsProxyRequest() )
            {
                APPEND_STRING( pszTail, "Connection: close\r\n" );
            } else
            {
                APPEND_STRING( pszTail, "Proxy-Connection: close\r\n" );
            }
        }
    }

    //
    //  Add any additional headers supplied by the filters plus the header
    //  termination
    //

    APPEND_NUMERIC_HEADER( pszTail, "Content-Length: ", dwMsgSize, "\r\n" );


    if (!_strDenialHdrs.IsEmpty())
    {
        DWORD cb = _strDenialHdrs.QueryCCH();
        CHAR *pszDenialHdr = _strDenialHdrs.QueryStr();

        //
        // We must always have CR-LF at the end
        //
        DBG_ASSERT( cb >= 2 && pszDenialHdr[cb - 2] == '\r' && pszDenialHdr[cb - 1] == '\n' );

        APPEND_STR_HEADER( pszTail, "", _strDenialHdrs, "" );

    }

    if (!bHaveCustom)
    {
        APPEND_STRING( pszTail, "Content-Type: text/html\r\n\r\n" );
    }

    if ( memcmp( _strMethod.QueryStr(), "HEAD", 4 ))
    {

        APPEND_PSZ_HEADER( pszTail, "", pszAccessDeniedMsg, "" );
    }
    else
    {
        if (bHaveCustom)
        {
            DWORD   dwBytesToCopy;

            // Copy in only the content-type header, which is everything
            // except for the message itself.

            dwBytesToCopy = dwMsgSizeNeeded - dwMsgSize;

            memcpy(pszTail, pszAccessDeniedMsg, dwBytesToCopy);

            pszTail += dwBytesToCopy;
            *pszTail++ = '\0';
        }
    }

    DBG_ASSERT( QueryRespBuf()->QuerySize() > QueryRespBufCB() );

    IF_DEBUG( PARSING )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[SendAuthNeededResp] Sending headers: %s",
                    QueryRespBufPtr() ));
    }

    //
    //  Add IO_FLAG_AND_RECV if we're doing a multi-leg authentication exchange and the 
    //  connection is to be kept open for the duration of the exchange 
    //

    return SendHeader( QueryRespBufPtr(),
                       (DWORD) -1,
                       (IO_FLAG_ASYNC | ( ( IsAuthenticating() && IsKeepConnSet() ) ?
                                           IO_FLAG_AND_RECV :
                                           0)),
                       pfFinished );
}


BOOL
HTTP_REQ_BASE::AppendAuthenticationHdrs(
    STR *     pstrAuthenticationHdrs,
    BOOL *    pfFinished
    )
/*++

Routine Description:

    This method adds the appropriate "WWW-Authenticate" strings to the passed
    server response string

    This routine assumes pRespBuf is large enough to hold the authentication
    headers

Parameters:

    pStrAuthenticationHdrs - buffer
    pfFinished - Set to TRUE if no further processing is needed on this request

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR * pchField;
    DWORD  dwAuth;
    BOOL   fDoBasic;
    const LPSTR * apszNTProviders = NULL;
    PW3_SERVER_INSTANCE pInstance = QueryW3Instance();
    STACK_STR( strRealm, MAX_PATH); // make a local copy of the realm headers.

    //
    //  If no realm was supplied in the registry, use the host name
    //

    if ( !_fBasicRealm )
    {
        fDoBasic = TRUE;
    }
    else
    {
        fDoBasic = FALSE;
    }

    //
    //  Notify any Access Denied filters the user has been denied access
    //

    if ( _Filter.IsNotificationNeeded( SF_NOTIFY_ACCESS_DENIED,
                                       IsSecurePort() ))
    {
        if ( !_Filter.NotifyAccessDenied( _strURL.QueryStr(),
                                          _strPhysicalPath.QueryStr(),
                                          pfFinished ))
        {
            return FALSE;
        }

        if ( *pfFinished )
        {
            return TRUE;
        }
    }

    //
    //  We may not have read the metadata for this URL yet if a filter
    //  returned access denied during the initial read_raw notifications
    //

    if ( !QueryMetaData() )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[AppendAuthenticationHeaders] Warning - Metadata not read yet for NT auth list!\n"));
        return TRUE;
    }

    //
    //  Send the correct header depending on if we're a proxy
    //

    if ( !IsProxyRequest() )
    {
        pchField = "WWW-Authenticate: ";
    }
    else
    {
        pchField = "Proxy-Authenticate: ";
    }

    dwAuth = QueryAuthentication();
    apszNTProviders = QueryMetaData()->QueryNTProviders();

    //
    // generate the realm information for this request
    //

    strRealm.Copy( QueryMetaData()->QueryRealm()
                   ? QueryMetaData()->QueryRealm()
                   : QueryHostAddr() );

    //
    //  Append the appropriate authentication headers
    //

    if ( dwAuth & INET_INFO_AUTH_NT_AUTH )
    {
        DWORD i = 0;

        //
        //  For each authentication package the server supports, add a
        //  WWW-Authenticate header
        //

        while ( apszNTProviders[i] )
        {
            if ( !pstrAuthenticationHdrs->Append( pchField ) ||
                 !pstrAuthenticationHdrs->Append( apszNTProviders[ i ] ) ||
                 !pstrAuthenticationHdrs->Append( "\r\n" ) )
            {
                return FALSE;
            }
            i++;
        }
    }

    if ( fDoBasic && (dwAuth & INET_INFO_AUTH_CLEARTEXT) )
    {
        if ( !pstrAuthenticationHdrs->Append( pchField ) ||
             !pstrAuthenticationHdrs->Append( "Basic realm=\"" ) ||
             !pstrAuthenticationHdrs->Append( strRealm ) ||
             !pstrAuthenticationHdrs->Append( "\"\r\n" ) )
        { 
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
HTTP_REQ_BASE::ExtractClearNameAndPswd(
    CHAR *       pch,
    STR *        pstrUserName,
    STR *        pstrPassword,
    BOOL         fUUEncoded
    )
/*++

Routine Description:

    This method breaks a string in the form "username:password" and
    places the components into pstrUserName and pstrPassword.  If fUUEncoded
    is TRUE, then the string is UUDecoded first.

Parameters:

    pch - Pointer to <username>:<password>

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    STACK_STR( strDecoded, MAX_PATH );
    CHAR * pchtmp;

    pch = SkipWhite( pch );

    if ( fUUEncoded )
    {
        if ( !uudecode( pch,
                        &strDecoded ))
        {
            return FALSE;
        }

        pch = strDecoded.QueryStrA();
    }

    pchtmp = SkipTo( pch, TEXT(':') );

    if ( *pchtmp == TEXT(':') )
    {
        *pchtmp = TEXT('\0');

        if ( !_strUserName.Copy( pch ) ||
             !_strPassword.Copy( pchtmp + 1 ))
        {
             return FALSE;
        }
    }

    return TRUE;
}

HANDLE
HTTP_REQ_BASE::QueryPrimaryToken(
    HANDLE * phDelete
    )
/*++

Routine Description:

    This method returns a non-impersonation user token handle that's
    usable with CreateProcessAsUser.

Parameters:

    phDelete - If returned as non-null, the caller is responsible for calling
        CloseHandle on this value when done using the returned value.

Return Value:

    The primary token handle if successful, FALSE otherwise

--*/
{
    *phDelete = NULL;

    if ( !UseVrAccessToken() )
    {
        return _tcpauth.QueryPrimaryToken();
    }

    return _pMetaData->QueryVrPrimaryAccessToken();
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\w3svci_s_stub.c ===
#include "w3svci_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\utility.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    utility.cxx

    This module contains routines of general utility.


    FILE HISTORY:
        KeithMo     17-Mar-1993 Created.

*/


#include "w3p.hxx"
#include <time.h>

//
//  Private constants.
//

//
//  The number of times to retry outputting a log item
//

#define LOG_FILE_RETRIES        2

//
//  Private globals.
//


//
//  Private prototypes.
//

/*******************************************************************

    NAME:       ::SkipNonWhite

    SYNOPSIS:   Returns the first whitespace character starting
                from the passed position

    HISTORY:
        Johnl       21-Sep-1994 Created

********************************************************************/

CHAR * SkipNonWhite( CHAR * pch )
{
    while ( *pch && !ISWHITEA( *pch ) && *pch != '\n' )
        pch++;

    return pch;
}

CHAR * SkipTo( CHAR * pch, CHAR ch )
{
    while ( *pch && *pch != '\n' && *pch != ch )
        pch++;

    return pch;
}

/*******************************************************************

    NAME:       ::SkipWhite

    SYNOPSIS:   Skips white space starting at the passed point in the string
                and returns the next non-white space character.

    HISTORY:
        Johnl       23-Aug-1994 Created

********************************************************************/

CHAR * SkipWhite( CHAR * pch )
{
    while ( ISWHITEA( *pch ) )
    {
        pch++;
    }

    return pch;
}

/*******************************************************************

    NAME:       IsPointNine

    SYNOPSIS:   Determines if the HTTP request is a 0.9 request (has no
                version number)

    ENTRY:      pchReq - HTTP request to look in

    RETURNS:    TRUE if this is a 0.9 request, FALSE if not

    HISTORY:
        Johnl       08-Sep-1994 Created

********************************************************************/

BOOL IsPointNine( CHAR * pchReq )
{
    //
    //  If there's no '\n' then we don't have a complete request yet
    //

    if ( !strchr( pchReq, '\n' ))
        return FALSE;

    //
    //  Skip white space at beginning of request.
    //
    pchReq = ::SkipWhite( pchReq );

    //
    // Should be at a 'GET' now.
    //

    if (*pchReq != 'G' && *pchReq != 'g')
    {
        return FALSE;
    }

    //
    // Skip the rest of the verb, whitespace, and the URL.
    // URL.

    pchReq = ::SkipNonWhite( pchReq );
    pchReq = ::SkipWhite( pchReq );
    pchReq = ::SkipNonWhite( pchReq );

    //
    // Skip white space after the URL
    //
    pchReq = ::SkipWhite( pchReq );

    if (*pchReq == '\n' || *pchReq == '\0')
    {
        return TRUE;
    }

    return FALSE;

}


//
//  Private functions.
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\strconst.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       strconst.h

   Abstract:
       This class defines common constant strings used by
        W3 server for formatting the HTTP responses.

   Author:

       Murali R. Krishnan    ( MuraliK )    26-July-1996

   Environment:
       User mode - Win32

   Project:
   
       Internet Server DLL

   Revision History:

--*/

# ifndef _STRCONSTS_HXX_
# define _STRCONSTS_HXX_

/************************************************************
 *     Symbolic Definitions
 ************************************************************/


//
// Below is a list of strings, which are commonly used.
//  Format:
//   CStrM( FriendlyName,  ActualString)
//  This will be expanded into
//  extern const char  PSZ_FriendlyName[];  - in a header
//  enumerated value  LEN_FriendlyName = sizeof( ActualString). - in a header
//  const char  PSZ_FriendlyName[] = ActualString;  - in a c++ file (compiled)
//
//  
//

//
// Special Notes:
//    HTTP_VERSION_STR is always used with trailing blank (leave one)
//

# define ConstantStringsForThisModule()           \
CStrM( ENDING_CRLF, "\r\n")                       \
CStrM( CONTENT_TYPE_END_HEADER, "Content-Type: text/html\r\n\r\n") \
CStrM( HTTP_VERSION_STR, "HTTP/1.0 ")             \
CStrM( HTTP_VERSION_STR11, "HTTP/1.1 ")             \
CStrM( KWD_CONTENT_TYPE, "Content-Type: ")        \
CStrM( KWD_SYSTEM,       "SYSTEM")                \




//
// Generate the extern definitions for strings
//

# define CStrM( FriendlyName, ActualString)   \
   extern const char  PSZ_ ## FriendlyName[];

ConstantStringsForThisModule()
 
# undef CStrM
    
    
//
//  Generate the enumerated values, containing the length of strings.
//  The values are constants and are computed at compile time
//     sizeof(string) - 1 ==> string length in bytes.
//        since sizeof(CHAR) == 1 ==> byte == character count
//

# define CStrM( FriendlyName, ActualString)   \
       LEN_PSZ_ ## FriendlyName = (sizeof( ActualString) - 1),

enum ConstantStringLengths {

ConstantStringsForThisModule()

ConstantStringLengthsDummy = 0,
};

# undef CStrM


# endif // _STRCONSTS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\w3jobobj.cxx ===
/*++

   Copyright    (c)    1998        Microsoft Corporation

   Module Name:

        w3jobobj.cxx

   Abstract:

        This module implements the W3_JOB_OBJECT class

   Author:

        Michael Thomas    (michth)      Jan-02-1998

--*/

/*++

   Site and Job Object Locking

   The locking is rather complex, so here I attempt to describe the
   locks and interactions.

   W3_SERVER_INSTANCE Locks:

   1) m_tslock, inherited from IIS_SERVER_INSTANCE. Accessed via
   the methods LockThisForRead, LockThisForWrite, and UnlockThis. Controls
   access to the main members of the class, and to the job object members
   m_dwJobResetInterval and m_dwJobIntervalSchedulerCookie.

   2) m_tsJobLock. Accessed via the methods LockJobsForRead, LockJobsForWrite,
   and UnlockJobss. Controls access to the job object members, except
   m_dwJobResetInterval and m_dwJobIntervalSchedulerCookie.

   Scheduler Locks:

   1) For each deferred process set up via ScheduleWorkItem, the following pseudo
   lock applies: RemoveWorkItem will not not complete while the scheduled item is
   being processed.

   W3_JOB_OBJECT Locks:

   1) m_csLock, Accessed via the methods LockThis and UnlockThis. Controls access
   to all members.

   Other Locks:

   1) The site calls many other components, which may have their own locking.

   Interactions:

   For the resources used in the W3_SERVER_INSTANCE locks, it is possible to
   recursively get read locks, recursively get write locks, or recursively get
   get a read lock with a write lock held. Attempting to recursively get a write
   lock if a read lock is held will deadlock. Care must be take to prevent this
   situation when calling routines which grab a write lock.

   The deferred processing routines must not get locks that are held when
   RemoveWorkItem is called. This is why we need 2 instance locks, and why
   m_dwJobResetInterval and m_dwJobIntervalSchedulerCookie are not controlled
   via m_tsJobLock.

   JobResetInterval accesses many job object members. It gets m_tsJobLock. It
   must not get m_tslock.

   All places that call RemoveWorkItem(m_dwJobIntervalSchedulerCookie) must
   not hold m_tsJobLock. They should have m_tslock.

   QueryandLogJobInfo does not get any lock as m_tsJobLock is held when
   RemoveWorkItem(m_dwJobLoggingSchedulerCookie) is called. This is relatively
   benign. Routines which call QueryandLogJobInfo which are not running as
   deferred routines should LockJobsForRead when QueryAndLogJobInfo is called.

--*/



#include "w3p.hxx"
#include <issched.hxx>
#include <wmrgexp.h>
#include <wamexec.hxx>

//
// Map logging events to strings.
//

static LPCSTR pszarrayJOLE[JOLE_NUM_ELEMENTS] = {
    JOLE_SITE_START_STR,
    JOLE_SITE_STOP_STR,
    JOLE_SITE_PAUSE_STR,
    JOLE_PERIODIC_LOG_STR,
    JOLE_RESET_INT_START_STR,
    JOLE_RESET_INT_STOP_STR,
    JOLE_RESET_INT_CHANGE_STR,
    JOLE_LOGGING_INT_START_STR,
    JOLE_LOGGING_INT_STOP_STR,
    JOLE_LOGGING_INT_CHANGE_STR,
    JOLE_EVENTLOG_LIMIT_STR,
    JOLE_PRIORITY_LIMIT_STR,
    JOLE_PROCSTOP_LIMIT_STR,
    JOLE_PAUSE_LIMIT_STR,
    JOLE_EVENTLOG_LIMIT_RESET_STR,
    JOLE_PRIORITY_LIMIT_RESET_STR,
    JOLE_PROCSTOP_LIMIT_RESET_STR,
    JOLE_PAUSE_LIMIT_RESET_STR,
};

//
// Map Logging Process types to strings.
//

static LPCSTR pszarrayJOPT[JOPT_NUM_ELEMENTS] = {
    JOPT_CGI_STR,
    JOPT_APP_STR,
    JOPT_ALL_STR
};

W3_JOB_OBJECT::W3_JOB_OBJECT(DWORD dwJobCGICPULimit):
    m_hJobObject                ( NULL ),
    m_dwJobCGICPULimit          ( dwJobCGICPULimit ),
    m_dwError                   ( ERROR_SUCCESS )
{
    ResetCounters(NULL);

    INITIALIZE_CRITICAL_SECTION(&m_csLock);

    m_hJobObject = CreateJobObject(NULL,
                                   NULL);
    if (m_hJobObject == NULL) {
        m_dwError = GetLastError();
    }
    else if ( m_dwJobCGICPULimit != NO_W3_CPU_CGI_LIMIT ) {
        SetJobLimit(SLA_PROCESS_CPU_LIMIT, m_dwJobCGICPULimit);
    }

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_JOB_OBJECT::W3_JOB_OBJECT] \nConstructing job object %p, error = 0x%X\n",
                  this,
                  m_dwError));
    }

}


W3_JOB_OBJECT::~W3_JOB_OBJECT(
                        VOID
                        )
{
    LockThis();

    if (m_hJobObject != NULL) {

        TerminateJobObject(m_hJobObject,
                           ERROR_SUCCESS);
        DBG_REQUIRE(CloseHandle(m_hJobObject));
        m_hJobObject = NULL;

    }

    UnlockThis();

    DeleteCriticalSection(&m_csLock);

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_JOB_OBJECT::~W3_JOB_OBJECT] \nDestructing job object %p\n",
                  this,
                  m_dwError));
    }
} // W3_JOB_OBJECT::~W3_JOB_OBJECT

/*++

Routine Description:

    Add Job Object to the global completion port for limit checking.
    Sets up the job object to post to the completion port.

Arguments:
    hCompletionPort The completion port to add the job object to.
    pvCompletionKey The completion key.

Return Value:
    DWORD   - ERROR_SUCCESS
              Errors returned by SetInformationJobObject

Notes:
--*/
DWORD
W3_JOB_OBJECT::SetCompletionPort(HANDLE hCompletionPort,
                                 PVOID pvCompletionKey)
{

    JOBOBJECT_ASSOCIATE_COMPLETION_PORT joacpPort;
    JOBOBJECT_END_OF_JOB_TIME_INFORMATION joeotiTermination;
    DWORD dwReturn = ERROR_SUCCESS;

    joacpPort.CompletionPort = hCompletionPort;
    joacpPort.CompletionKey = pvCompletionKey;

    LockThis();

    DBG_ASSERT(m_hJobObject != NULL);

    if (!SetInformationJobObject(m_hJobObject,
                                 JobObjectAssociateCompletionPortInformation,
                                 &joacpPort,
                                 sizeof(joacpPort))) {

        dwReturn = GetLastError();

        //
        //  Log an event
        //

        DBGPRINTF((DBG_CONTEXT,
                  "[SetCompletionPort] - SetInformationJobObject failed, error code = 0x%X\n",
                   GetLastError()));

        g_pInetSvc->LogEvent( W3_EVENT_JOB_SET_LIMIT_FAILED,
                              0,
                              NULL,
                              dwReturn );
    }
    else {

        //
        // Need notifications
        //

        joeotiTermination.EndOfJobTimeAction = JOB_OBJECT_POST_AT_END_OF_JOB;

        if (!SetInformationJobObject(m_hJobObject,
                                     JobObjectEndOfJobTimeInformation,
                                     &joeotiTermination,
                                     sizeof(joeotiTermination))) {
            dwReturn = GetLastError();
            //
            //  Log an event
            //

            DBGPRINTF((DBG_CONTEXT,
                      "[SetCompletionPort] - SetInformationJobObject failed, error code = 0x%X\n",
                       GetLastError()));

            g_pInetSvc->LogEvent( W3_EVENT_JOB_SET_LIMIT_FAILED,
                                  0,
                                  NULL,
                                  dwReturn );
        }
    }

    UnlockThis();


    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_JOB_OBJECT::W3_JOB_OBJECT] \nJob object %p assigned to completion port 0x%X error = 0x%X\n",
                  this,
                  HandleToUlong(hCompletionPort),
                  dwReturn));
    }

    return dwReturn;
}

/*++

Routine Description:

    Set new limits for the Job Object.

Arguments:

    slaActions    The limit to set
    dwValue       The new limit value. NO_W3_CPU_LIMIT = 0 = Remove Limit.
Return Value:

Notes:
--*/

VOID
W3_JOB_OBJECT::SetJobLimit(SET_LIMIT_ACTION slaAction,
                           DWORD dwValue,
                           LONGLONG llJobCPULimit)
{
    JOBOBJECT_BASIC_LIMIT_INFORMATION jobliLimits;
    LONGLONG llTimeLimit;

    LockThis();

    //
    // Save CGI limit for future use.
    //

    if (slaAction == SLA_PROCESS_CPU_LIMIT) {
        m_dwJobCGICPULimit = dwValue;
    }

    //
    // Get the existing limits.
    //

    if (!QueryInformationJobObject(m_hJobObject,
                                   JobObjectBasicLimitInformation,
                                   &jobliLimits,
                                   sizeof(jobliLimits),
                                   NULL)) {
        //
        //  Log an event
        //

        DBGPRINTF((DBG_CONTEXT,
                  "[SetJobLimit] - QueryInformationJobObject failed, error code = 0x%X\n",
                   GetLastError()));

        g_pInetSvc->LogEvent( W3_EVENT_JOB_QUERY_FAILED,
                               0,
                               NULL,
                               GetLastError() );
    }
    else {

        //
        // Change the limit.
        //

        switch (slaAction) {
        case SLA_PROCESS_CPU_LIMIT:
            if (dwValue == NO_W3_CPU_CGI_LIMIT) {
                jobliLimits.LimitFlags &= ~JOB_OBJECT_LIMIT_PROCESS_TIME;
            }
            else {
                jobliLimits.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_TIME;
                llTimeLimit = (LONGLONG)m_dwJobCGICPULimit * (LONGLONG)SECONDSTO100NANOSECONDS;
                jobliLimits.PerProcessUserTimeLimit.LowPart = (DWORD)llTimeLimit;
                jobliLimits.PerProcessUserTimeLimit.HighPart = (DWORD)(llTimeLimit >> 32);
            }

            //
            // Keep existing job cpu limit
            //

            jobliLimits.LimitFlags |= JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME;

            break;
        case SLA_PROCESS_PRIORITY_CLASS:
            if (dwValue == NO_W3_CPU_LIMIT) {
                jobliLimits.LimitFlags &= ~JOB_OBJECT_LIMIT_PRIORITY_CLASS;
            }
            else {
                jobliLimits.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;
                jobliLimits.PriorityClass = (DWORD)dwValue;
            }

            //
            // Keep existing job cpu limit
            //

            jobliLimits.LimitFlags |= JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME;

            break;
        case SLA_TERMINATE_ALL_PROCESSES:

            JOBOBJECT_END_OF_JOB_TIME_INFORMATION joeotiTermination;

            if (dwValue == NO_W3_CPU_LIMIT) {
                //
                // Need notifications
                //

                joeotiTermination.EndOfJobTimeAction = JOB_OBJECT_POST_AT_END_OF_JOB;

                if (!SetInformationJobObject(m_hJobObject,
                                             JobObjectEndOfJobTimeInformation,
                                             &joeotiTermination,
                                             sizeof(joeotiTermination))) {
                    //
                    //  Log an event
                    //

                    DBGPRINTF((DBG_CONTEXT,
                              "[SetJobLimit] - SetInformationJobObject failed, error code = 0x%X\n",
                               GetLastError()));

                    g_pInetSvc->LogEvent( W3_EVENT_JOB_SET_LIMIT_FAILED,
                                          0,
                                          NULL,
                                          GetLastError() );
                }

                jobliLimits.LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_TIME;
            }
            else {

                //
                // Need Terminate Behavior instead of notifications
                //

                joeotiTermination.EndOfJobTimeAction = JOB_OBJECT_TERMINATE_AT_END_OF_JOB;

                if (!SetInformationJobObject(m_hJobObject,
                                             JobObjectEndOfJobTimeInformation,
                                             &joeotiTermination,
                                             sizeof(joeotiTermination))) {
                    //
                    //  Log an event
                    //

                    DBGPRINTF((DBG_CONTEXT,
                              "[SetJobLimit] - SetInformationJobObject failed, error code = 0x%X\n",
                               GetLastError()));

                    g_pInetSvc->LogEvent( W3_EVENT_JOB_SET_LIMIT_FAILED,
                                          0,
                                          NULL,
                                          GetLastError() );
                }
                jobliLimits.LimitFlags |= JOB_OBJECT_LIMIT_JOB_TIME;
                jobliLimits.PerJobUserTimeLimit.QuadPart = 1;
            }
            break;
        case SLA_JOB_CPU_LIMIT:
            if (dwValue == NO_W3_CPU_LIMIT) {
                jobliLimits.LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_TIME;
            }
            else {

#if 0
                JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jobaiInfo;
                if (!QueryInformationJobObject(m_hJobObject,
                                               JobObjectBasicAccountingInformation,
                                               &jobaiInfo,
                                               sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
                                               NULL)) {

                    DBGPRINTF((DBG_CONTEXT,
                              "[QueryJobInfo] - QueryInformationJobObject failed, error code = 0x%X\n",
                               GetLastError()));

                    g_pInetSvc->LogEvent( W3_EVENT_JOB_QUERY_FAILED,
                                           0,
                                           NULL,
                                           GetLastError() );
                }
                else {
                    llJobCPULimit += jobaiInfo.TotalUserTime.QuadPart;
#endif
                    jobliLimits.LimitFlags |= JOB_OBJECT_LIMIT_JOB_TIME;
                    jobliLimits.PerJobUserTimeLimit.QuadPart = llJobCPULimit;
#if 0
                }
#endif
            }
            break;
        default:
            DBG_ASSERT(FALSE);
        }

        //
        // Set the new limit.
        //

        if (!SetInformationJobObject(m_hJobObject,
                                     JobObjectBasicLimitInformation,
                                     &jobliLimits,
                                     sizeof(jobliLimits))) {
            //
            //  Log an event
            //

            DBGPRINTF((DBG_CONTEXT,
                      "[SetJobLimit] - SetInformationJobObject failed, error code = 0x%X\n",
                       GetLastError()));

            g_pInetSvc->LogEvent( W3_EVENT_JOB_SET_LIMIT_FAILED,
                                  0,
                                  NULL,
                                  GetLastError() );
        }
        else {
            IF_DEBUG( JOB_OBJECTS )
            {
                DBGPRINTF((DBG_CONTEXT,
                          "[W3_JOB_OBJECT::SetJobLimit] \nJob object %p limit action %d taken,\n"
                          "value = 0x%X, cpulimit high word = 0x%X, cpulimit low word = 0x%X\n",
                          this,
                          slaAction,
                          dwValue,
                          (DWORD)((LONGLONG)llJobCPULimit >> 32),
                          (DWORD)llJobCPULimit ));
            }
        }
    }

    UnlockThis();
}

/*++

Routine Description:

    Add a process to the Job Object.

Arguments:

    hProcess    The process handle to add to the Job Object.
Return Value:
    HRESULT - ERROR_SUCCESS
              Errors returned by AssignProcessToJobObject

Notes:
--*/

DWORD
W3_JOB_OBJECT::AddProcessToJob(
        IN HANDLE hProcess
        )
{
    HRESULT dwReturn = ERROR_SUCCESS;

    DBG_ASSERT (m_hJobObject != NULL);

    if (!AssignProcessToJobObject(m_hJobObject,
                                  hProcess)) {
        dwReturn = GetLastError();
    }

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_JOB_OBJECT::AddProcessToJob] \nProcess 0x%X added to Job object %p, error = 0x%X\n",
                  HandleToUlong(hProcess),
                  this,
                  dwReturn ));
    }

    return dwReturn;
}

/*++

Routine Description:

    Query Job Object Information.

Arguments:

    pjobaiInfo    Buffer to return the data.
                  Will contain the difference since the last call to Reset Counters.

Return Value:
    BOOL      TRUE if succeeded

Notes:
--*/

BOOL
W3_JOB_OBJECT::QueryJobInfo(
        JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiInfo,
        BOOL bResetCounters
        )
{

    BOOL bReturn = FALSE;

    LockThis();

    DBG_ASSERT(m_hJobObject != NULL);

    bReturn = QueryInformationJobObject(m_hJobObject,
                              JobObjectBasicAccountingInformation,
                              pjobaiInfo,
                              sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
                              NULL);

    if (!bReturn) {

        DBGPRINTF((DBG_CONTEXT,
                  "[QueryJobInfo] - QueryInformationJobObject failed, error code = 0x%X\n",
                   GetLastError()));

        g_pInetSvc->LogEvent( W3_EVENT_JOB_QUERY_FAILED,
                               0,
                               NULL,
                               GetLastError() );
    }
    else {
        JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jobaiInfoBackup;

        //
        // Save away the real info in case we need it to reset the counters
        //

        if (bResetCounters) {
            memcpy(&jobaiInfoBackup, pjobaiInfo, sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION));
        }

        //
        // Subtract off the previous counters, to return values for this interval.
        //

        SubtractJobInfo(pjobaiInfo,
                        pjobaiInfo,
                        &m_jobaiPrevInfo);

        //
        // Reset the counters
        // This modifies m_jobaiPrevInfo, so must be done after setting pjobaiInfo.
        //

        if (bResetCounters) {
            ResetCounters(&jobaiInfoBackup);
        }

    }

    UnlockThis();

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_JOB_OBJECT::QueryJobInfo] \nJob object %p queried, Counter Reset = 0x%X, boolean error = 0x%X\n",
                  this,
                  bResetCounters,
                  bReturn ));
    }

    return bReturn;
}

/*++

Routine Description:

    Reset the period CPU counters. Can't actually reset them, so store the old values.
    Caller must call QueryInformationJobObject before calling Reset Counters and pass
    in the results.

Arguments:

    pjobaiInfo    Buffer with current counters.
                  If null, initialize counters to 0.
Return Value:

Notes:
--*/

VOID
W3_JOB_OBJECT::ResetCounters( JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiInfo )
{
    if (pjobaiInfo == NULL) {
        memset((VOID *)&m_jobaiPrevInfo,
               0,
               sizeof(m_jobaiPrevInfo));
    }
    else {

        //
        // Set these to the total values, since the ThisPeriod values
        // returned by QueryJobInfo may have been adjusted by a previous reset.
        //

        memcpy(&m_jobaiPrevInfo, pjobaiInfo, sizeof(m_jobaiPrevInfo));

        //
        // Active Processes is not a cumulative value, so set it to 0
        //
        //

        m_jobaiPrevInfo.ActiveProcesses = 0;
    }

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_JOB_OBJECT::ResetCounters] \nJob object %p counters reset\n",
                  this ));
    }

}

/*++

Routine Description:

    Increment the stopped process for this period. This is called because
    stopped applications are stopped outside the job object, so do not get counted
    in the job object statistics.
    Can't actually add them to the job object info, so subtract them from the previous
    values, which get subtracted from current values on queries.

Arguments:

Return Value:

Notes:
--*/

VOID
W3_JOB_OBJECT::IncrementStoppedProcs( VOID )
{

    LockThis();

    m_jobaiPrevInfo.TotalTerminatedProcesses--;

    UnlockThis();

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_JOB_OBJECT::IncrementStoppedProcs] \nJob object %p stopped processes incremented\n",
                  this ));
    }
}

/*++

Routine Description:

    Process the Instance Stop Notification. When the instance stops:
    - remove periodic query routine.
    - Log current info
    - Reset Counters
    - Record the state

Arguments:

Return Value:

Notes:
--*/

VOID
W3_SERVER_INSTANCE::ProcessStopNotification()
{

    //
    // Remove periodic reset
    //

    if (m_dwJobIntervalSchedulerCookie != 0) {
        DBG_REQUIRE(RemoveWorkItem( m_dwJobIntervalSchedulerCookie ));
        m_dwJobIntervalSchedulerCookie = 0;
    }

    LockJobsForWrite();

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::ProcessStopNotification] \n"
                  "Processing site stop notification for site %p\n",
                  this ));
    }

    m_dwLastJobState = MD_SERVER_STATE_STOPPED;

    //
    // Remove periodic logging
    //

    if (m_dwJobLoggingSchedulerCookie != 0) {
        DBG_REQUIRE(RemoveWorkItem( m_dwJobLoggingSchedulerCookie ));
        m_dwJobLoggingSchedulerCookie = 0;
        QueryAndLogJobInfo(JOLE_LOGGING_INT_STOP, FALSE);
    }

    //
    // log info.
    //

    QueryAndLogJobInfo(JOLE_RESET_INT_STOP, FALSE);

    QueryAndLogJobInfo(JOLE_SITE_STOP, TRUE);

    //
    // Counters have been reset, so reset the limits
    //

    SetJobSiteCPULimits(TRUE);

    UnlockJobs();
}

/*++

Routine Description:

    Start Job Objects up. Called in response to site start
    or enabling of limits or logging.

Arguments:

Return Value:

Notes:
    Jobs lock must be held for write at entry.
--*/
VOID
W3_SERVER_INSTANCE::StartJobs()
{

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::StartJobs] \n"
                  "Starting Job Object functionality for site %p\n",
                  this ));
    }

    SetCompletionPorts();

    LimitSiteCPU(TRUE, TRUE);

    ScheduleJobDeferredProcessing();
}

/*++

Routine Description:

    Stop Job Objects, if necessary. Called in response to disabling
    of limits or logging.

Arguments:

Return Value:

Notes:
    Jobs lock must be held for write EXACTLY ONCE at entry.
--*/
VOID
W3_SERVER_INSTANCE::StopJobs()
{

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::StopJobs] \n"
                  "Conditinally removing Job Object functionality for site %p\n",
                  this ));
    }

    if (!m_fCPULoggingEnabled && m_dwJobLoggingSchedulerCookie) {
        DBG_REQUIRE(RemoveWorkItem( m_dwJobLoggingSchedulerCookie ));
        m_dwJobLoggingSchedulerCookie = 0;
        QueryAndLogJobInfo(JOLE_LOGGING_INT_STOP, FALSE);
    }

    if (!m_fCPULimitsEnabled) {
        LimitSiteCPU(FALSE, TRUE);
    }

    if (!m_fCPULoggingEnabled && !m_fCPULimitsEnabled) {

        //
        // Cannot have job lock when removing the interval work item.
        // This is still protected by the site lock, and job object
        // functions are disabled, so not really a problem.
        //

        UnlockJobs();

        if (m_dwJobIntervalSchedulerCookie != 0) {
            DBG_REQUIRE(RemoveWorkItem( m_dwJobIntervalSchedulerCookie ));
            m_dwJobIntervalSchedulerCookie = 0;

            QueryAndLogJobInfo(JOLE_RESET_INT_STOP, TRUE);
        }

        LockJobsForWrite();
    }
}
/*++

Routine Description:

    Process the Instance Start Notification. When the instance starts:
    - Log current info
    - Reset Counters if previous state was stopped
    - Add periodic query routine
    - Record the state

    The logging and resetting above are done both at stop and start, in
    case an application or CGI continued processing while the instance was
    stopped or paused.

Arguments:

Return Value:

Notes:
--*/
VOID
W3_SERVER_INSTANCE::ProcessStartNotification()
{

    LockJobsForWrite();

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::ProcessStartNotification] \n"
                  "Processing site start notification for site %p\n",
                  this ));
    }

    //
    // If not already started
    //

    if (m_dwLastJobState != MD_SERVER_STATE_STARTED) {

        if (m_dwLastJobState ==  MD_SERVER_STATE_STOPPED) {

            QueryAndLogJobInfo(JOLE_SITE_START, FALSE);

            StartJobs();

        }
        else {
            DBG_ASSERT(m_dwLastJobState == MD_SERVER_STATE_PAUSED);
            QueryAndLogJobInfo(JOLE_SITE_START, FALSE);
        }

        m_dwLastJobState = MD_SERVER_STATE_STARTED;

    }

    UnlockJobs();
}

/*++

Routine Description:

    Process the Instance Pause Notification. When the instance starts:
    - Remove periodic query routine
    - Log current info
    - Record the state

Arguments:

Return Value:

Notes:
--*/
VOID
W3_SERVER_INSTANCE::ProcessPauseNotification()
{
    LockJobsForWrite();

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::ProcessPauseNotification] \n"
                  "Processing site pause notification for site %p\n",
                  this ));
    }

    QueryAndLogJobInfo(JOLE_SITE_PAUSE, FALSE);
    m_dwLastJobState = MD_SERVER_STATE_PAUSED;

    UnlockJobs();
}

/*++

Routine Description:

    Schedule the deferred processing routines for reset interval and logging,
    if they're not already scheduled.
    The instance and jobs locks must both be locked for write when this is called.

Arguments:

Return Value:
    BOOL      TRUE if succeeded

Notes:
--*/

BOOL
W3_SERVER_INSTANCE::ScheduleJobDeferredProcessing()
{
    BOOL bReturn = TRUE;

    bReturn = ScheduleJobDeferredReset();

    if (bReturn) {
        bReturn = ScheduleJobDeferredLogging();
    }

    return bReturn;

}

/*++

Routine Description:

    Schedule the deferred processing routine for reset interval,
    if it's not already scheduled.
    The instance lock must be locked for write when this is called.

Arguments:

Return Value:
    BOOL      TRUE if succeeded

Notes:
--*/

BOOL
W3_SERVER_INSTANCE::ScheduleJobDeferredReset()
{
    BOOL bReturn = TRUE;

    LockJobsForWrite();

    if ((m_fCPULoggingEnabled || m_fCPULimitsEnabled)&&
        (m_dwJobIntervalSchedulerCookie == 0)) {

        m_dwJobIntervalSchedulerCookie = ScheduleWorkItem(DeferredJobResetInterval,
                                               (void *)this,
                                               m_dwJobResetInterval * MINUTESTOMILISECONDS,
                                               TRUE);
        if (m_dwJobIntervalSchedulerCookie == 0) {
            bReturn = FALSE;

            //
            //  Log an event
            //

            DBGPRINTF((DBG_CONTEXT,
                      "[ScheduleJobDeferredReset] - ScheduleWorkItem failed, error code = 0x%X\n",
                       GetLastError()));

            g_pInetSvc->LogEvent( W3_EVENT_JOB_SCEDULE_FAILED,
                                   0,
                                   NULL,
                                   GetLastError() );

        }
        else {

            //
            // Log Start of new interval
            //

            QueryAndLogJobInfo(JOLE_RESET_INT_START, FALSE);
            IF_DEBUG( JOB_OBJECTS )
            {
                DBGPRINTF((DBG_CONTEXT,
                          "[W3_SERVER_INSTANCE::ScheduleJobDeferredReset] \n"
                          "Reset interval processing started for site %p\n",
                          this ));
            }
        }

    }

    UnlockJobs();

    return bReturn;

}

/*++

Routine Description:

    Schedule the deferred processing routine for and logging,
    if it's not already scheduled.
    The jobs lock must be locked for write when this is called.

Arguments:

Return Value:
    BOOL      TRUE if succeeded

Notes:
--*/

BOOL
W3_SERVER_INSTANCE::ScheduleJobDeferredLogging()
{
    BOOL bReturn = TRUE;

    LockJobsForWrite();

    if (m_fCPULoggingEnabled && (m_dwJobLoggingSchedulerCookie == 0)) {
        m_dwJobLoggingSchedulerCookie = ScheduleWorkItem(DeferredQueryAndLogJobInfo,
                                               (void *)this,
                                               m_dwJobQueryInterval * MINUTESTOMILISECONDS,
                                               TRUE);
        if (m_dwJobLoggingSchedulerCookie == 0) {
            bReturn = FALSE;

            //
            //  Log an event
            //

            DBGPRINTF((DBG_CONTEXT,
                      "[ScheduleJobDeferredLogging] - ScheduleWorkItem failed, error code = 0x%X\n",
                       GetLastError()));

            g_pInetSvc->LogEvent( W3_EVENT_JOB_SCEDULE_FAILED,
                                  0,
                                  NULL,
                                  GetLastError() );
        }
        else {
            QueryAndLogJobInfo(JOLE_LOGGING_INT_START, FALSE);

            IF_DEBUG( JOB_OBJECTS )
            {
                DBGPRINTF((DBG_CONTEXT,
                          "[W3_SERVER_INSTANCE::ScheduleJobDeferredLogging] \n"
                          "Logging Deferred processing started %p\n",
                          this ));
            }

        }
    }

    UnlockJobs();

    return bReturn;

}

/*++

Routine Description:

    Add all Job Objects in the instance to the global completion port for limit checking, if
    limit checking is enabled.

Arguments:

Return Value:
    DWORD   - ERROR_SUCCESS
              Errors returned by SetCompletionPort

Notes:
--*/
VOID
W3_SERVER_INSTANCE::SetCompletionPorts( )
{
    SetCompletionPort(m_pwjoApplication);
    SetCompletionPort(m_pwjoCGI);
}

/*++

Routine Description:

    Add Job Object to the global completion port for limit checking, if
    limit checking is enabled.

Arguments:

    pwjoCurrent The job object class to add to the completion port.

Return Value:
    DWORD   - ERROR_SUCCESS
              Errors returned by W3_LIMIT_JOB_THREAD::GetLimitJobThread
              Errors returned by W3_JOB_OBJECT::SetCompletionPort

Notes:
--*/
DWORD
W3_SERVER_INSTANCE::SetCompletionPort(
        IN PW3_JOB_OBJECT pwjoCurrent
        )
{
    DWORD dwReturn = ERROR_SUCCESS;
    PW3_LIMIT_JOB_THREAD pwljtClass = NULL;

    if (m_fCPULimitsEnabled && pwjoCurrent != NULL) {
        dwReturn = W3_LIMIT_JOB_THREAD::GetLimitJobThread(&pwljtClass);

        if (dwReturn == ERROR_SUCCESS) {
            DBG_ASSERT(pwljtClass != NULL);
            dwReturn = pwjoCurrent->SetCompletionPort(pwljtClass->GetCompletionPort(),
                                                      (PVOID)this);

        }

        IF_DEBUG( JOB_OBJECTS )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[W3_SERVER_INSTANCE::SetCompletionPort] \n"
                      "Job Object %p for site %p added to completion port 0x%X\n"
                      "error = 0x%X\n",
                      pwjoCurrent,
                      this,
                      (pwljtClass != NULL) ? HandleToUlong(pwljtClass->GetCompletionPort()) : 0,
                      dwReturn ));
        }

    }
    return dwReturn;
}

/*++

Routine Description:

    Add a process to the appropriate Job Object. Create the Job Object class if
    necessary. Add to completion port if limits enabled.

Arguments:

    hProcess    The process handle to add to the Job Object.
    bIsApplicationProcess If true, process is added to the Application Job Object.
                          Otherwise, it is added to the CGI Job Object.
Return Value:
    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              Errors returned by ScheduleWorkItem
              Errors returned by W3_JOB_OBJECT::AddProcessToJob

Notes:
--*/

DWORD
W3_SERVER_INSTANCE::AddProcessToJob(
        IN HANDLE hProcess,
        IN BOOL bIsApplicationProcess
        )
{
    DWORD dwReturn = ERROR_SUCCESS;
    PW3_JOB_OBJECT *ppwjoCurrent = NULL;

    if (m_fCPULoggingEnabled || m_fCPULimitsEnabled) {

        if (bIsApplicationProcess) {
            ppwjoCurrent = &m_pwjoApplication;
        }
        else {
            ppwjoCurrent = &m_pwjoCGI;
        }

        if (*ppwjoCurrent == NULL) {
            LockJobsForWrite();
            if (*ppwjoCurrent == NULL) {
                if (bIsApplicationProcess) {
                    *ppwjoCurrent = new W3_JOB_OBJECT();
                }
                else {
                    *ppwjoCurrent = new W3_JOB_OBJECT(m_dwJobCGICPULimit);
                }
                if (*ppwjoCurrent == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    dwReturn = (*ppwjoCurrent)->GetInitError();
                }
                if (dwReturn != ERROR_SUCCESS) {
                    delete (*ppwjoCurrent);
                    *ppwjoCurrent = NULL;
                }
                else {

                    dwReturn = SetCompletionPort(*ppwjoCurrent);

                    if (dwReturn != ERROR_SUCCESS) {
                        delete (*ppwjoCurrent);
                        *ppwjoCurrent = NULL;
                    }
                    else {

                        if (m_fJobSiteCPULimitPriorityEnabled) {
                            SetJobLimits(SLA_PROCESS_PRIORITY_CLASS, IDLE_PRIORITY_CLASS);
                        }
                        if (m_fJobSiteCPULimitProcStopEnabled) {
                            SetJobLimits(SLA_TERMINATE_ALL_PROCESSES, 1);
                        }


                        //
                        // Set limit times and enforce current limits in job object
                        //

                        LimitSiteCPU(TRUE,
                                     TRUE);

                    }

                }
            }
            UnlockJobs();
        }

        //
        // *ppwjoCurrent This only gets changed in this routine, and only gets deleted at termination,
        // so I claim we do not need instance locking here.
        //
        // The job object class does its own locking if necessary.
        //

        if (*ppwjoCurrent != NULL) {
            dwReturn = (*ppwjoCurrent)->AddProcessToJob(hProcess);
        }

    }

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::AddProcessToJob] \n"
                  "Site %p adding process 0x%X to Job Object %p\n"
                  "error = 0x%X\n",
                  this,
                  HandleToUlong(hProcess),
                  (ppwjoCurrent != NULL) ? *ppwjoCurrent : 0,
                  dwReturn ));
    }

    return dwReturn;
}

/*++

Routine Description:

    Calculate the CPU time as a percentage of the interval time.
    Return and ASCII string with the percent in 2.3% format.

Arguments:

    llCPUTime    The currently used CPU time in 100 nanosecond units.
    pszPercentCPUTime character buffer of length 8 to return the string.

Return Value:
    HRESULT - ERROR_SUCCESS
              E_OUTOFMEMORY
              Errors returned by ScheduleWorkItem
              Errors returned by W3_JOB_OBJECT::AddProcessToJob

Notes:
--*/
VOID
W3_SERVER_INSTANCE::GetPercentFromCPUTime(IN LONGLONG llCPUTime,
                                          OUT LPSTR pszPercentCPUTime)
{
    LONGLONG llPercentCPUTime = (llCPUTime * (LONGLONG)100000) / m_llJobResetIntervalCPU;
    DBG_ASSERT(llPercentCPUTime < 100000);

    //
    // Can't find a numeric routine to format this nicely so just do it.
    //

    pszPercentCPUTime[0] = (char)((llPercentCPUTime / 10000) + '0');
    pszPercentCPUTime[1] = (char)(((llPercentCPUTime / 1000) % 10) + '0');
    pszPercentCPUTime[2] = '.';
    pszPercentCPUTime[3] = (char)(((llPercentCPUTime / 100) % 10) + '0');
    pszPercentCPUTime[4] = (char)(((llPercentCPUTime / 10) % 10) + '0');
    pszPercentCPUTime[5] = (char)((llPercentCPUTime % 10) + '0');
    pszPercentCPUTime[6] = '%';
    pszPercentCPUTime[7] = '\0';
}

#define ShouldLogJobInfo() ((m_fCPULoggingEnabled || joleLogEvent == JOLE_LOGGING_INT_STOP) && \
                            (m_dwJobLoggingOptions != MD_CPU_DISABLE_ALL_LOGGING))

/*++

Routine Description:

    Write log informatin to the log file.

Arguments:

    pjbaiLogInfo   The statistics.
    joleLogEvent   The event being logged.
    joptProcessType The type of the processes being logged (CGI, Application, All).

Return Value:
    HRESULT - ERROR_SUCCESS
              E_OUTOFMEMORY
              Errors returned by ScheduleWorkItem
              Errors returned by W3_JOB_OBJECT::AddProcessToJob

Notes:
--*/
VOID
W3_SERVER_INSTANCE::LogJobInfo(IN PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION pjbaiLogInfo,
                               IN JOB_OBJECT_LOG_EVENTS joleLogEvent,
                               IN JOB_OBJECT_PROCESS_TYPE joptProcessType)
{

    CUSTOM_LOG_DATA cldarrayLogInfo[JOLF_NUM_ELEMENTS];
    char pszUserTimePercent[8];
    char pszKernelTimePercent[8];

    cldarrayLogInfo[JOLF_EVENT].szPropertyPath = W3_CPU_LOG_PATH W3_CPU_LOG_EVENT_PATH;
    cldarrayLogInfo[JOLF_EVENT].pData = (PVOID) pszarrayJOLE[joleLogEvent];

    cldarrayLogInfo[JOLF_INFO_TYPE].szPropertyPath = W3_CPU_LOG_PATH W3_CPU_LOG_PROCESS_TYPE_PATH;
    cldarrayLogInfo[JOLF_INFO_TYPE].pData = (PVOID) pszarrayJOPT[joptProcessType];

    GetPercentFromCPUTime((LONGLONG)pjbaiLogInfo->TotalUserTime.QuadPart,
                          pszUserTimePercent);
    cldarrayLogInfo[JOLF_USER_TIME].szPropertyPath = W3_CPU_LOG_PATH W3_CPU_LOG_USER_TIME_PATH;
    cldarrayLogInfo[JOLF_USER_TIME].pData = (PVOID) &pszUserTimePercent;

    GetPercentFromCPUTime((LONGLONG)pjbaiLogInfo->TotalKernelTime.QuadPart,
                          pszKernelTimePercent);
    cldarrayLogInfo[JOLF_KERNEL_TIME].szPropertyPath = W3_CPU_LOG_PATH W3_CPU_LOG_KERNEL_TIME_PATH;
    cldarrayLogInfo[JOLF_KERNEL_TIME].pData = (PVOID) &pszKernelTimePercent;

    cldarrayLogInfo[JOLF_PAGE_FAULT].szPropertyPath = W3_CPU_LOG_PATH W3_CPU_LOG_PAGE_FAULT_PATH;
    cldarrayLogInfo[JOLF_PAGE_FAULT].pData = (PVOID) &(pjbaiLogInfo->TotalPageFaultCount);

    cldarrayLogInfo[JOLF_TOTAL_PROCS].szPropertyPath = W3_CPU_LOG_PATH W3_CPU_LOG_TOTAL_PROCS_PATH;
    cldarrayLogInfo[JOLF_TOTAL_PROCS].pData = (PVOID) &(pjbaiLogInfo->TotalProcesses);

    cldarrayLogInfo[JOLF_ACTIVE_PROCS].szPropertyPath = W3_CPU_LOG_PATH W3_CPU_LOG_ACTIVE_PROCS_PATH;
    cldarrayLogInfo[JOLF_ACTIVE_PROCS].pData = (PVOID) &(pjbaiLogInfo->ActiveProcesses);

    cldarrayLogInfo[JOLF_TERMINATED_PROCS].szPropertyPath = W3_CPU_LOG_PATH W3_CPU_LOG_TERMINATED_PROCS_PATH;
    cldarrayLogInfo[JOLF_TERMINATED_PROCS].pData = (PVOID) &(pjbaiLogInfo->TotalTerminatedProcesses);

    DWORD dwError = m_Logging.LogCustomInformation(JOLF_NUM_ELEMENTS,
                                                   cldarrayLogInfo,
                                                   "#SubComponent: Process Accounting"
                                                   );

    if (dwError != ERROR_SUCCESS) {

        //
        // CODEWORK - Log to Event Log Here
        //

    }
    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::LogJobInfo] \n"
                  "Site %p logging job information,\n"
                  "event = %d, process type = %d, error = 0x%X\n",
                  this,
                  (DWORD)joleLogEvent,
                  (DWORD)joptProcessType,
                  dwError ));
    }
}

/*++

Routine Description:

    Query the job objects in this site and log the info.

Arguments:

    joleLogEvent  The event being Logged.
    bResetCounters Reset the counters if TRUE.

Return Value:
    HRESULT - ERROR_SUCCESS
              Errors returned by Logging

Notes:
    This does not get the jobs lock, because that would risk a deadlock between the
    deferred process and the call to RemoveWorkItem call to remove the deferred
    process. It is ok, and a good idea, for nondeferred called to hold the jobs lock.
--*/

VOID
W3_SERVER_INSTANCE::QueryAndLogJobInfo( IN JOB_OBJECT_LOG_EVENTS joleLogEvent,
                                        IN BOOL bResetCounters )
{
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jobaiApplicationInfo;
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jobaiCGIInfo;
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jobaiSumInfo;

    //
    // Make sure counters get reset for limits, even if logging is off
    //

    if ( (bResetCounters) ||
         ShouldLogJobInfo() ) {

        QueryAndSumJobInfo(&jobaiSumInfo,
                           &jobaiApplicationInfo,
                           &jobaiCGIInfo,
                           bResetCounters);

        //
        // LogJobsInfo will check ShouldLogJobInfo, so no
        // need to check it again.
        //

        LogJobsInfo( joleLogEvent,
                     &jobaiApplicationInfo,
                     &jobaiCGIInfo,
                     &jobaiSumInfo );

    }

}

/*++

Routine Description:

    Log the info for all jobs on this site.

Arguments:

    joleLogEvent  The event being Logged.
    jobaiApplicationInfo   The job object info for applications.
    jobaiCGIInfo           The job object info for CGI.
    jobaiSumInfo           The job object info for all jobs.

Return Value:

Notes:
    This does not get the jobs lock, because that would risk a deadlock between the
    deferred process and the call to RemoveWorkItem call to remove the deferred
    process. It is ok, and a good idea, for nondeferred called to hold the jobs lock.
--*/

VOID
W3_SERVER_INSTANCE::LogJobsInfo( IN JOB_OBJECT_LOG_EVENTS joleLogEvent,
                                 IN JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiApplicationInfo,
                                 IN JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiCGIInfo,
                                 IN JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiSumInfo )
{

    if (ShouldLogJobInfo()) {

        IF_DEBUG( JOB_OBJECTS )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[W3_SERVER_INSTANCE::LogJobsInfo] \n"
                      "Site %p conditionally logging job information for all types\n"
                      "event = %d\n",
                      this,
                      (DWORD)joleLogEvent ));
        }

        if ((m_dwJobLoggingOptions & MD_CPU_ENABLE_CGI_LOGGING) != 0) {
            LogJobInfo(pjobaiCGIInfo,
                       joleLogEvent,
                       JOPT_CGI);
        }

        if ((m_dwJobLoggingOptions & MD_CPU_ENABLE_APP_LOGGING) != 0) {
            LogJobInfo(pjobaiApplicationInfo,
                       joleLogEvent,
                       JOPT_APP);
        }

        if ((m_dwJobLoggingOptions & MD_CPU_ENABLE_ALL_PROC_LOGGING) != 0) {
            LogJobInfo(pjobaiSumInfo,
                       joleLogEvent,
                       JOPT_ALL);
        }
    }
}

/*++

Routine Description:

    Reset The job query interval.
    Logging has either been enabled, disabled, or the interval changed.
    Reset query routine as appropriate.

Arguments:

Return Value:

Notes:
--*/

VOID
W3_SERVER_INSTANCE::ResetJobQueryInterval()
{

    LockJobsForWrite();

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::ResetJobQueryInterval] \n"
                  "Site %p resetting job query interval\n",
                  this ));
    }

    if (m_dwJobLoggingSchedulerCookie != 0) {

        DBG_REQUIRE(RemoveWorkItem( m_dwJobLoggingSchedulerCookie ));

        m_dwJobLoggingSchedulerCookie = 0;
        QueryAndLogJobInfo(JOLE_LOGGING_INT_STOP, FALSE);
    }

    if ((m_dwLastJobState != MD_SERVER_STATE_STOPPED) &&
        (m_fCPULoggingEnabled)) {
        QueryAndLogJobInfo(JOLE_LOGGING_INT_CHANGE, FALSE);
        ScheduleJobDeferredLogging();
    }

    UnlockJobs();
}

/*++

Routine Description:

    Changes the job reset interval. Removes all existing limits, resets all information,
    and starts the new interval.


    Notes:
    Instance should be locked for write prior to this call.
--*/

VOID
W3_SERVER_INSTANCE::ResetJobResetInterval()
{

    if (m_dwJobIntervalSchedulerCookie != 0) {

        //
        // Remove periodic reset
        //

        DBG_REQUIRE(RemoveWorkItem( m_dwJobIntervalSchedulerCookie ));
        m_dwJobIntervalSchedulerCookie = 0;
    }

    //
    // Calculate the total cpu time per interval
    //

    m_llJobResetIntervalCPU = GetCPUTimeFromInterval(m_dwJobResetInterval);


    LockJobsForWrite();

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::ResetJobResetInterval] \n"
                  "Site %p resetting job reset interval\n",
                  this ));
    }

    if ((m_dwLastJobState != MD_SERVER_STATE_STOPPED) &&
        (m_fCPULoggingEnabled || m_fCPULimitsEnabled)) {

        //
        // Remove periodic logging
        //

        if (m_dwJobLoggingSchedulerCookie != 0) {
            DBG_REQUIRE(RemoveWorkItem( m_dwJobLoggingSchedulerCookie ));
            m_dwJobLoggingSchedulerCookie = 0;
            QueryAndLogJobInfo(JOLE_LOGGING_INT_STOP, TRUE);
        }

        QueryAndLogJobInfo(JOLE_RESET_INT_STOP, TRUE);
        //
        // reset the counters, and log info.
        //

        QueryAndLogJobInfo(JOLE_RESET_INT_CHANGE, FALSE);

        //
        // Reset Limits
        //

        SetJobSiteCPULimits(TRUE);

        //
        // Restart Periodic routines, if necessary
        //

        ScheduleJobDeferredProcessing();
    }

    UnlockJobs();
}

/*++

Routine Description:

    Interval expired, start next interval.
    Removes all existing limits, resets all information,
    and starts the new interval.

--*/

VOID
W3_SERVER_INSTANCE::JobResetInterval()
{

    LockJobsForWrite();

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::JobResetInterval] \n"
                  "Site %p processing job reset interval\n",
                  this ));
    }

    //
    // Remove periodic logging
    //

    if (m_dwJobLoggingSchedulerCookie != 0) {
        DBG_REQUIRE(RemoveWorkItem( m_dwJobLoggingSchedulerCookie ));
        QueryAndLogJobInfo(JOLE_LOGGING_INT_STOP, FALSE);
    }

    //
    // reset the counters, and log info.
    //

    QueryAndLogJobInfo(JOLE_RESET_INT_STOP, TRUE);

    //
    // Reset Limits
    //

    SetJobSiteCPULimits(TRUE);

    //
    // Log Again to show start of new interval
    //

    QueryAndLogJobInfo(JOLE_RESET_INT_START, FALSE);

    //
    // Restart Periodic logging, if necessary
    //

    if (m_dwJobLoggingSchedulerCookie != 0) {
        m_dwJobLoggingSchedulerCookie = 0;
        ScheduleJobDeferredLogging();
    }

    UnlockJobs();

}

/*++

Routine Description:

    Terminate Applications. Called when ProcStop limit hit.

--*/

VOID
W3_SERVER_INSTANCE::TerminateCPUApplications(DWORD_PTR dwValue)
{
    BUFFER bufDataPaths;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    LPSTR   pszCurrentPath;
    DWORD   dwMBValue;
    STR     strPath;
    BOOL    fAppUnloaded;

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::TerminateCPUApplications] \n"
                  "Site %p terminating Applications\n",
                  this ));
    }

    if ( mb.Open( QueryMDPath(),
                  METADATA_PERMISSION_READ ) ) {

        //
        // First find the OOP Applications
        //

        if (mb.GetDataPaths(NULL,
                            MD_APP_PACKAGE_ID,
                            STRING_METADATA,
                            &bufDataPaths)) {

            //
            // For each OOP Application
            //

            for (pszCurrentPath = (LPSTR)bufDataPaths.QueryPtr();
                 *pszCurrentPath != '\0';
                 pszCurrentPath += (strlen(pszCurrentPath) + 1)) {

                //
                // If the application is CPU enabled.
                //

                if (mb.GetDword(pszCurrentPath,
                                MD_CPU_APP_ENABLED,
                                IIS_MD_UT_FILE,
                                &dwMBValue) &&
                    dwMBValue) {

                    //
                    // Close the metabase before doing application calls
                    //

                    mb.Close();
                    strPath.Copy(QueryMDPath());
                    strPath.Append(pszCurrentPath);
                    strPath.SetLen(strlen(strPath.QueryStr()) - 1);
                    if (dwValue != NO_W3_CPU_LIMIT) {
                        g_pWamDictator->UnLoadWamInfo(&strPath, TRUE, &fAppUnloaded);
                        if (fAppUnloaded) {
                            if (m_pwjoApplication != NULL) {
                                m_pwjoApplication->IncrementStoppedProcs();
                            }
                        }
                    }
                    else {
                        g_pWamDictator->CPUResumeWamInfo(&strPath);
                    }

                    if ( !mb.Open( QueryMDPath(),
                                   METADATA_PERMISSION_READ ) ) {
                        break;
                    }
                }
            }
        }
    }
}

/*++

Routine Description:

    Set or reset Job limits.

Arguments:

    slaAction    The limit to set
    dwValue      The limit value. 0 = remove limit.

Return Value:

Notes:

    Requires at least write lock on entry.
    Cannot have read lock, as TerminateCPUApplications will eventually result
    in a call to AddProcessToJob, which attempts to get a write lock.
--*/
VOID
W3_SERVER_INSTANCE::SetJobLimits(SET_LIMIT_ACTION slaAction,
                                 DWORD dwValue,
                                 LONGLONG llJobCPULimit)
{
    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::SetJobLimits] \n"
                  "Site %p taking limit action %d,\n"
                  "value = 0x%X, cpulimit high word = 0x%X, cpulimit low word = 0x%X\n",
                  this,
                  slaAction,
                  dwValue,
                  (DWORD)((LONGLONG)llJobCPULimit >> 32),
                  (DWORD)llJobCPULimit ));
    }

    switch (slaAction) {
    case SLA_PROCESS_CPU_LIMIT:
        if (m_pwjoCGI != NULL) {
            m_pwjoCGI->SetJobLimit(slaAction, dwValue);
        }
        break;
    case SLA_PROCESS_PRIORITY_CLASS:
        if (m_pwjoCGI != NULL) {
            m_pwjoCGI->SetJobLimit(slaAction, dwValue);
        }
        if (m_pwjoApplication != NULL) {
            m_pwjoApplication->SetJobLimit(slaAction, dwValue);
        }
        break;
    case SLA_TERMINATE_ALL_PROCESSES:
        if (m_pwjoCGI != NULL) {
            m_pwjoCGI->SetJobLimit(slaAction, dwValue);
        }

        W3_JOB_QUEUE::QueueWorkItem( JQA_TERMINATE_SITE_APPS,
                                     (PVOID)this,
                                     (PVOID)UIntToPtr(dwValue) );

        break;
    case SLA_JOB_CPU_LIMIT:
        if (m_pwjoCGI != NULL) {
            m_pwjoCGI->SetJobLimit(slaAction, dwValue, llJobCPULimit);
        }
        if (m_pwjoApplication != NULL) {
            m_pwjoApplication->SetJobLimit(slaAction, dwValue, llJobCPULimit);
        }
        break;
    default:
        DBG_ASSERT(FALSE);
    }
}

/*++

Routine Description:

    Set the limit processing as appropriate.
    Called when limits or reset interval may have changed.
    Remove limits that should not be there.
    Add limits that should be there.
    Start or stop site limit Deferred Processing Routine.

--*/
VOID
W3_SERVER_INSTANCE::SetJobSiteCPULimits(BOOL fHasWriteLock)
{
    if (!fHasWriteLock) {
        LockJobsForWrite();
    }

    //
    // There may be a limit that was increased or removed, so first
    // check and disable penalty if necessary.
    //

    LimitSiteCPU(FALSE,
                 TRUE);

    //
    // There may  have been a limit added are reduced, so
    // enable limits.
    //

    LimitSiteCPU(TRUE,
                 TRUE);

    if (!fHasWriteLock) {
        UnlockJobs();
    }
}

/*++

Routine Description:

    Add the values of 2 job objects.

Arguments:

    pjobaiSumInfo   Buffer to return the sum.
    pjobaiInfo1     First job object info.
    pjobaiInfo2     Second job object info.

--*/
VOID
W3_JOB_OBJECT::SumJobInfo(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiSumInfo,
                          JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiInfo1,
                          JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiInfo2)
{
    DBG_ASSERT (pjobaiSumInfo != NULL);
    DBG_ASSERT (pjobaiInfo1 != NULL);
    DBG_ASSERT (pjobaiInfo2 != NULL);

    pjobaiSumInfo->TotalUserTime.QuadPart =
        (pjobaiInfo1->TotalUserTime.QuadPart +
         pjobaiInfo2->TotalUserTime.QuadPart);
    pjobaiSumInfo->TotalKernelTime.QuadPart =
        (pjobaiInfo1->TotalKernelTime.QuadPart +
         pjobaiInfo2->TotalKernelTime.QuadPart);
    pjobaiSumInfo->ThisPeriodTotalUserTime.QuadPart =
        (pjobaiInfo1->ThisPeriodTotalUserTime.QuadPart +
         pjobaiInfo2->ThisPeriodTotalUserTime.QuadPart);
    pjobaiSumInfo->ThisPeriodTotalKernelTime.QuadPart =
        (pjobaiInfo1->ThisPeriodTotalKernelTime.QuadPart +
         pjobaiInfo2->ThisPeriodTotalKernelTime.QuadPart);
    pjobaiSumInfo->TotalPageFaultCount =
        (pjobaiInfo1->TotalPageFaultCount +
         pjobaiInfo2->TotalPageFaultCount);
    pjobaiSumInfo->TotalProcesses =
        (pjobaiInfo1->TotalProcesses +
         pjobaiInfo2->TotalProcesses);
    pjobaiSumInfo->ActiveProcesses =
        (pjobaiInfo1->ActiveProcesses +
         pjobaiInfo2->ActiveProcesses);
    pjobaiSumInfo->TotalTerminatedProcesses =
        (pjobaiInfo1->TotalTerminatedProcesses +
         pjobaiInfo2->TotalTerminatedProcesses);
}

/*++

Routine Description:

    Subtract the values of 2 job objects.

Arguments:

    pjobaiResultInfo   Buffer to return the difference.
    pjobaiInfo1        First job object info, to subtract from.
    pjobaiInfo2        Second job object info, to subtract.

--*/
VOID
W3_JOB_OBJECT::SubtractJobInfo(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiResultinfo,
                               JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiInfo1,
                               JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiInfo2)
{
    DBG_ASSERT (pjobaiResultinfo != NULL);
    DBG_ASSERT (pjobaiInfo1 != NULL);
    DBG_ASSERT (pjobaiInfo2 != NULL);

    pjobaiResultinfo->TotalUserTime.QuadPart =
        (pjobaiInfo1->TotalUserTime.QuadPart -
         pjobaiInfo2->TotalUserTime.QuadPart);
    pjobaiResultinfo->TotalKernelTime.QuadPart =
        (pjobaiInfo1->TotalKernelTime.QuadPart -
         pjobaiInfo2->TotalKernelTime.QuadPart);
    pjobaiResultinfo->ThisPeriodTotalUserTime.QuadPart =
        (pjobaiInfo1->ThisPeriodTotalUserTime.QuadPart -
         pjobaiInfo2->ThisPeriodTotalUserTime.QuadPart);
    pjobaiResultinfo->ThisPeriodTotalKernelTime.QuadPart =
        (pjobaiInfo1->ThisPeriodTotalKernelTime.QuadPart -
         pjobaiInfo2->ThisPeriodTotalKernelTime.QuadPart);
    pjobaiResultinfo->TotalPageFaultCount =
        (pjobaiInfo1->TotalPageFaultCount -
         pjobaiInfo2->TotalPageFaultCount);
    pjobaiResultinfo->TotalProcesses =
        (pjobaiInfo1->TotalProcesses -
         pjobaiInfo2->TotalProcesses);
    pjobaiResultinfo->ActiveProcesses =
        (pjobaiInfo1->ActiveProcesses -
         pjobaiInfo2->ActiveProcesses);
    pjobaiResultinfo->TotalTerminatedProcesses =
        (pjobaiInfo1->TotalTerminatedProcesses -
         pjobaiInfo2->TotalTerminatedProcesses);
}

/*++

Routine Description:

    Query the job objects. Return the results of those queries and the sum.
    Reset counters if necessary (on interval change).

Arguments:

    pjobaiSumInfo           Buffer to return the sum.
    pjobaiApplicationInfo   Buffer to return the Application info.
    pjobaiCGIInfo           Buffer to return the CGI infoSecond job object info.
    bResetCounters          Reset counters if true.

Returns:
    TRUE = Information was queried from at least one job object.
    FALSE = All returned info set to 0.
--*/
BOOL
W3_SERVER_INSTANCE::QueryAndSumJobInfo(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiSumInfo,
                                       JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiApplicationInfo,
                                       JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiCGIInfo,
                                       BOOL bResetCounters)
{

    BOOL bIsApplicationInfo = FALSE;
    BOOL bIsCGIInfo = FALSE;
    BOOL bReturn = FALSE;

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[W3_SERVER_INSTANCE::QueryAndSumJobInfo] \n"
                  "Site %p Querying all site job objects\n",
                  this ));
    }
    if (m_pwjoApplication != NULL) {
        bIsApplicationInfo = m_pwjoApplication->QueryJobInfo(pjobaiApplicationInfo,
                                                             bResetCounters);
    }
    if (!bIsApplicationInfo) {
        memset(pjobaiApplicationInfo, 0, sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION ));
    }

    if (m_pwjoCGI != NULL) {
        bIsCGIInfo = m_pwjoCGI->QueryJobInfo(pjobaiCGIInfo,
                                             bResetCounters);
    }

    if (!bIsCGIInfo) {
        memset(pjobaiCGIInfo, 0, sizeof(JOBOBJECT_BASIC_ACCOUNTING_INFORMATION ));
    }

    W3_JOB_OBJECT::SumJobInfo(pjobaiSumInfo,
                              pjobaiApplicationInfo,
                              pjobaiCGIInfo);

    if (bIsCGIInfo || bIsApplicationInfo) {
        bReturn = TRUE;
    }

    return bReturn;
}

/*++

Routine Description:

    Convert a percent CPU limit to a CPU time.
Arguments:
    dwLimitPercent The percent limit in units 1/100000 of the reset interval.

Returns:
    The cpu time for the limit in 100 nanosecond units.

--*/
LONGLONG
W3_SERVER_INSTANCE::PercentCPULimitToCPUTime(DWORD dwLimitPercent)
{
    //
    // It's always safe to divide the reset interval by 100000, since it is
    // calculated as minutes * 60 * 10000000
    //

    return ((LONGLONG)dwLimitPercent * (m_llJobResetIntervalCPU / (LONGLONG)100000));
}

/*++

Routine Description:

    Check if the Site CPU Limit as been exceeded.

Arguments:

    CPULimit - The limit in 100 nanosecond units.

Return Value:
    TRUE if limit is valid.

Notes:
--*/

BOOL
W3_SERVER_INSTANCE::ExceededLimit(LONGLONG llCPULimit,
                                  JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiSumInfo)
{
    LONGLONG llCurrentCPU;
    BOOL bReturn = FALSE;

    if (IsLimitValid(llCPULimit)) {

        llCurrentCPU = pjobaiSumInfo->TotalUserTime.QuadPart +
                       pjobaiSumInfo->TotalKernelTime.QuadPart;

        if (llCurrentCPU >= llCPULimit) {
            bReturn = TRUE;
        }
    }

    return bReturn;
}

/*++

Routine Description:

    Calculate the time until a limit is reached.

Arguments:

    llCPULimit          The limit, in 100 nanosecond units.
    pjobaiSumInfo       The current resources used for the site.

Returns:
    The time left in 100 nanosecond units.
    If the limit does not exist, or is in the past, then MAXLONGLONG.

--*/
LONGLONG
W3_SERVER_INSTANCE::CalculateTimeUntilStop(LONGLONG llCPULimit,
                                           JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *pjobaiSumInfo)
{
    LONGLONG llCurrentCPU;
    LONGLONG llReturn = MAXLONGLONG;

    if (IsLimitValid(llCPULimit)) {

        llCurrentCPU = pjobaiSumInfo->TotalUserTime.QuadPart +
                       pjobaiSumInfo->TotalKernelTime.QuadPart;

        if (llCurrentCPU < llCPULimit) {
            llReturn = llCPULimit - llCurrentCPU;
        }
    }

    return llReturn;
}

/*++

Routine Description:

    Calculate the time limit to set in each job object from
    the time until the next limit is hit.

Arguments:

    llTimeToNextLimit   The time until the next limit is hit, 100 nanosecond units.
    dwNumJobObjects     The current number of job objects.

Returns:
    The time to set, in seconds.

--*/
LONGLONG
W3_SERVER_INSTANCE::CalculateNewJobLimit(LONGLONG llTimeToNextLimit,
                                         DWORD dwNumJobObjects)
{
    LONGLONG llNewJobLimit = llTimeToNextLimit;

    DBG_ASSERT (dwNumJobObjects > 0);

    if ((dwNumJobObjects > 1) &&
        (llNewJobLimit > MINUTESTO100NANOSECONDS)) {

        //
        // If more than a minute left, divide time
        // among job objects.
        //

        llNewJobLimit /= dwNumJobObjects;
    }

    return llNewJobLimit;
}


/*++

Routine Description:

    Check site limits and enable or disable as appropriate.

Arguments:

    fEnableLimits - TRUE = check and enable limits if exceeded.
                    FALSE = check and disable limits if not exceeded.

--*/
VOID
W3_SERVER_INSTANCE::LimitSiteCPU(BOOL fEnableLimits,
                                 BOOL fHasWriteLock)
{

    if (!fHasWriteLock) {
        LockJobsForWrite();
    }

    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jobaiSumInfo;
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jobaiCGIInfo;
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION jobaiApplicationInfo;

    //
    // If there is any information
    //

    if (QueryAndSumJobInfo(&jobaiSumInfo,
                           &jobaiApplicationInfo,
                           &jobaiCGIInfo,
                           FALSE)) {

        IF_DEBUG( JOB_OBJECTS )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "[W3_SERVER_INSTANCE::LimitSiteCPU] \n"
                      "Site %p checking site limits, fEnableLimits = 0x%X\n",
                      this,
                      (DWORD)fEnableLimits ));
        }

        const CHAR * apsz[1];

        //
        // if limits enabled for this site and paremeter = enable limits
        //

        if (m_fCPULimitsEnabled && fEnableLimits) {

            //
            // if limit not in force and limit exceeded
            // then enable limit
            //

            if ((!m_fJobSiteCPULimitLogEventEnabled) &&
                (ExceededLimit(m_llJobSiteCPULimitLogEvent,
                               &jobaiSumInfo))) {
                m_fJobSiteCPULimitLogEventEnabled = TRUE;

                LogJobsInfo( JOLE_EVENTLOG_LIMIT,
                             &jobaiApplicationInfo,
                             & jobaiCGIInfo,
                             &jobaiSumInfo );

                //
                //  Log an event
                //

                DBGPRINTF((DBG_CONTEXT,
                          "[LimitSiteCPU] - LogEvent Limit Hit\n"));

                apsz[0] = QuerySiteName();

                DBG_ASSERT(apsz[0] != NULL);

                g_pInetSvc->LogEvent( W3_EVENT_JOB_LOGEVENT_LIMIT,
                                      1,
                                      apsz,
                                      0 );

            }

            //
            // if limit not in force and limit exceeded
            // then enable limit
            //

            if ((!m_fJobSiteCPULimitPriorityEnabled) &&
                (ExceededLimit(m_llJobSiteCPULimitPriority,
                               &jobaiSumInfo))) {
                m_fJobSiteCPULimitPriorityEnabled = TRUE;

                LogJobsInfo( JOLE_PRIORITY_LIMIT,
                             &jobaiApplicationInfo,
                             & jobaiCGIInfo,
                             &jobaiSumInfo );

                SetJobLimits(SLA_PROCESS_PRIORITY_CLASS, IDLE_PRIORITY_CLASS);

                //
                //  Log an event
                //

                DBGPRINTF((DBG_CONTEXT,
                          "[LimitSiteCPU] - Priority Limit Hit\n"));

                apsz[0] = QuerySiteName();

                DBG_ASSERT(apsz[0] != NULL);

                g_pInetSvc->LogEvent( W3_EVENT_JOB_PRIORITY_LIMIT,
                                      1,
                                      apsz,
                                      0 );

            }

            //
            // if limit not in force and limit exceeded
            // then enable limit
            //

            if ((!m_fJobSiteCPULimitProcStopEnabled) &&
                (ExceededLimit(m_llJobSiteCPULimitProcStop,
                               &jobaiSumInfo))) {
                m_fJobSiteCPULimitProcStopEnabled = TRUE;

                LogJobsInfo( JOLE_PROCSTOP_LIMIT,
                             &jobaiApplicationInfo,
                             & jobaiCGIInfo,
                             &jobaiSumInfo );

                SetJobLimits(SLA_TERMINATE_ALL_PROCESSES, 1);

                //
                //  Log an event
                //

                DBGPRINTF((DBG_CONTEXT,
                          "[LimitSiteCPU] - ProcStop Limit Hit\n"));

                apsz[0] = QuerySiteName();

                DBG_ASSERT(apsz[0] != NULL);

                g_pInetSvc->LogEvent( W3_EVENT_JOB_PROCSTOP_LIMIT,
                                      1,
                                      apsz,
                                      0 );

            }

            //
            // if limit not in force and limit exceeded
            // then enable limit
            //

            if ((!m_fJobSiteCPULimitPauseEnabled) &&
                (ExceededLimit(m_llJobSiteCPULimitPause,
                               &jobaiSumInfo))) {

                m_fJobSiteCPULimitPauseEnabled = TRUE;

                LogJobsInfo( JOLE_PAUSE_LIMIT,
                             &jobaiApplicationInfo,
                             & jobaiCGIInfo,
                             &jobaiSumInfo );

                //
                //  Log an event
                //

                DBGPRINTF((DBG_CONTEXT,
                          "[LimitSiteCPU] - Site Pause Limit Hit\n"));

                apsz[0] = QuerySiteName();

                DBG_ASSERT(apsz[0] != NULL);

                g_pInetSvc->LogEvent( W3_EVENT_JOB_PAUSE_LIMIT,
                                      1,
                                      apsz,
                                      0 );

            }

            //
            // Calulate and set job limits
            //


            DWORD dwNumJobObjects;
            dwNumJobObjects = 0;


            if (m_pwjoCGI != NULL) {
                dwNumJobObjects++;
            }

            if (m_pwjoApplication != NULL) {
                dwNumJobObjects++;
            }

            if (!m_fJobSiteCPULimitPauseEnabled &&
                !m_fJobSiteCPULimitProcStopEnabled &&
                dwNumJobObjects > 0) {

                //
                // There may be another limit coming
                //

                LONGLONG llTimeToNextLimit;

                llTimeToNextLimit = MAXLONGLONG;

                llTimeToNextLimit = min(llTimeToNextLimit,
                                        CalculateTimeUntilStop(m_llJobSiteCPULimitLogEvent,
                                                            &jobaiSumInfo));

                llTimeToNextLimit = min(llTimeToNextLimit,
                                        CalculateTimeUntilStop(m_llJobSiteCPULimitPriority,
                                                            &jobaiSumInfo));

                llTimeToNextLimit = min(llTimeToNextLimit,
                                        CalculateTimeUntilStop(m_llJobSiteCPULimitProcStop,
                                                            &jobaiSumInfo));

                llTimeToNextLimit = min(llTimeToNextLimit,
                                        CalculateTimeUntilStop(m_llJobSiteCPULimitPause,
                                                            &jobaiSumInfo));

                if (llTimeToNextLimit != MAXLONGLONG) {

                    LONGLONG llNewJobLimit;

                    llNewJobLimit = CalculateNewJobLimit(llTimeToNextLimit,
                                                         dwNumJobObjects);
                    IF_DEBUG( JOB_OBJECTS )
                    {
                        DBGPRINTF((DBG_CONTEXT,
                                  "[W3_SERVER_INSTANCE::LimitSiteCPU] \nSetting New Limit in seconds,"
                                  "high word = %u, low word = %u \n",
                                  (DWORD)((LONGLONG)(llNewJobLimit / SECONDSTO100NANOSECONDS) >> 32),
                                  (DWORD)((LONGLONG)(llNewJobLimit / SECONDSTO100NANOSECONDS)) ));
                    }

                    SetJobLimits(SLA_JOB_CPU_LIMIT,
                                 1,
                                 llNewJobLimit);

                }

            }

        }
        else {

            //
            // There's been a configuration change. May need to disable
            // a limit that's already been hit.
            //

            //
            // if limit in force and limit not exceeded
            // then disable limit.
            //

            if ((m_fJobSiteCPULimitLogEventEnabled) &&
                (!m_fCPULimitsEnabled || !ExceededLimit(m_llJobSiteCPULimitLogEvent,
                                                        &jobaiSumInfo))) {
                m_fJobSiteCPULimitLogEventEnabled = FALSE;
                //log event
                LogJobsInfo( JOLE_EVENTLOG_LIMIT_RESET,
                             &jobaiApplicationInfo,
                             & jobaiCGIInfo,
                             &jobaiSumInfo );

            }

            if ((m_fJobSiteCPULimitPriorityEnabled) &&
                (!m_fCPULimitsEnabled || !ExceededLimit(m_llJobSiteCPULimitPriority,
                                                        &jobaiSumInfo))) {
                // log event
                m_fJobSiteCPULimitPriorityEnabled = FALSE;

                LogJobsInfo( JOLE_PRIORITY_LIMIT_RESET,
                             &jobaiApplicationInfo,
                             & jobaiCGIInfo,
                             &jobaiSumInfo );

                SetJobLimits(SLA_PROCESS_PRIORITY_CLASS, NO_W3_CPU_LIMIT);

            }

            if ((m_fJobSiteCPULimitProcStopEnabled) &&
                (!m_fCPULimitsEnabled || !ExceededLimit(m_llJobSiteCPULimitProcStop,
                                                        &jobaiSumInfo))) {
                m_fJobSiteCPULimitProcStopEnabled = FALSE;
                // log event

                LogJobsInfo( JOLE_PROCSTOP_LIMIT_RESET,
                             &jobaiApplicationInfo,
                             & jobaiCGIInfo,
                             &jobaiSumInfo );

                SetJobLimits(SLA_TERMINATE_ALL_PROCESSES, NO_W3_CPU_LIMIT);
                // Stop Processes
            }

            if ((m_fJobSiteCPULimitPauseEnabled) &&
                (!m_fCPULimitsEnabled || !ExceededLimit(m_llJobSiteCPULimitPause,
                                                        &jobaiSumInfo))) {
                // log event
                m_fJobSiteCPULimitPauseEnabled = FALSE;

                LogJobsInfo( JOLE_PAUSE_LIMIT_RESET,
                             &jobaiApplicationInfo,
                             & jobaiCGIInfo,
                             &jobaiSumInfo );

            }

            if (!m_fCPULimitsEnabled) {

                SetJobLimits(SLA_JOB_CPU_LIMIT,
                             NO_W3_CPU_LIMIT);

            }
        }

    }

    if (!fHasWriteLock) {
        UnlockJobs();
    }
}

W3_LIMIT_JOB_THREAD *W3_LIMIT_JOB_THREAD::m_pljtLimitJobs = NULL;
/*++

Routine Description:

    Constructor for W3_LIMIT_JOB_THREAD.
    Create a completion port and a thread to monitor it.

Arguments:

    None

Returns:

    Sets m_dwInitError, which can be queried by GetInitError()

Notes:

    The caller should check the init error and delete this class on failure.

--*/
W3_LIMIT_JOB_THREAD::W3_LIMIT_JOB_THREAD( void ):
    m_hLimitThread    ( NULL ),
    m_hCompletionPort ( NULL ),
    m_dwInitError      ( NO_ERROR )
{
    DWORD dwLimitThreadId;
    m_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,    // No associated file
                                               NULL,                    // No existing completion port
                                               NULL,                    // Completion Key, this is ignored
                                               0);                      // max Concurrent threads = numprocessors

    if (m_hCompletionPort == NULL) {
        m_dwInitError = GetLastError();
    }
    else {
        m_hLimitThread = CreateThread(NULL,     // Security Attributes
                                      0,        // Default Stack Size
                                      &LimitThreadProcStub,  // Thread start routine
                                      (LPVOID)this, // parameter
                                      0,            // Creation Flags
                                      &dwLimitThreadId); // Thread ID
        if (m_hLimitThread == NULL) {
            m_dwInitError = GetLastError();
        }
    }
}

/*++

Routine Description:

    Destructor for W3_LIMIT_JOB_THREAD.
    Posts an entry to the completion port to cause the thread to terminate.
    Close the handle of the completion port.

Arguments:

    None

Returns:

    Nothing


--*/
W3_LIMIT_JOB_THREAD::~W3_LIMIT_JOB_THREAD( void )
{

    TerminateLimitJobThreadThread();

    if (m_hCompletionPort != NULL) {
        DBG_REQUIRE(CloseHandle(m_hCompletionPort));
    }
}

/*++

Routine Description:

    Terminate the LimitJobThread class, if any.

Arguments:

    None

Returns:

    Nothing


--*/
//static
VOID
W3_LIMIT_JOB_THREAD::TerminateLimitJobThread( void )
// Static
{
    LockGlobals();
    if ( m_pljtLimitJobs )
    {
        delete m_pljtLimitJobs;
        m_pljtLimitJobs = NULL;
    }
    UnlockGlobals();
}

/*++

Routine Description:

    Stop Processing the job queue, if any.

Arguments:

    None

Returns:

    Nothing


--*/
// static
VOID
W3_LIMIT_JOB_THREAD::StopLimitJobThread( void )
{
    LockGlobals();
    if ( m_pljtLimitJobs )
    {
        m_pljtLimitJobs->TerminateLimitJobThreadThread();
    }
    UnlockGlobals();
}

/*++

Routine Description:

    Terminate the limit thread.

Arguments:

    None

Returns:

    Nothing


--*/
VOID
W3_LIMIT_JOB_THREAD::TerminateLimitJobThreadThread( void )
{
    if (m_hLimitThread != NULL) {
        DBG_ASSERT(m_hCompletionPort != NULL);

        PostQueuedCompletionStatus(m_hCompletionPort,
                                   0,           // dwNumberOfBytesTransferred
                                   0,           // dwCompletionKey
                                   NULL);       // lpOverlapped
        DBG_REQUIRE (WaitForSingleObject(m_hLimitThread,
                                         10000) != WAIT_TIMEOUT);

        m_hLimitThread = NULL;
    }
}
/*++

Routine Description:

    Static routine to get an instance of this class.

Arguments:

    ppljtLimitJobs On return, will contain the class pointer

Returns:

    ERROR_SUCCESS
    ERROR_NOT_ENOUGH_MEMORY
    Errors returned by constructor

--*/
DWORD
W3_LIMIT_JOB_THREAD::GetLimitJobThread( W3_LIMIT_JOB_THREAD ** ppljtLimitJobs )
{
    DWORD dwReturn = ERROR_SUCCESS;

    if (m_pljtLimitJobs != NULL) {
        *ppljtLimitJobs = m_pljtLimitJobs;
    }
    else {
        LockGlobals();
        if (m_pljtLimitJobs != NULL) {
            *ppljtLimitJobs = m_pljtLimitJobs;
        }
        else {

            PW3_LIMIT_JOB_THREAD pljtLimitJobs;

            //
            // Create the class
            // Be sure not to set m_pljtLimitJobs until it's
            // known valid, since it's normally accessed
            // outside the lock.
            //

            pljtLimitJobs = new W3_LIMIT_JOB_THREAD();
            if (pljtLimitJobs == NULL) {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                dwReturn = pljtLimitJobs->GetInitError();
                if (dwReturn == NO_ERROR) {
                    m_pljtLimitJobs = pljtLimitJobs;
                    *ppljtLimitJobs = pljtLimitJobs;
                }
                else {
                    delete pljtLimitJobs;
                }
            }
        }
        UnlockGlobals();
    }

    return dwReturn;
}

/*++

Routine Description:

    The main routine of the monitoring thread.
    Calls the instance on check job object limits.
    Terminates when the completion key is NULL.

Arguments:

    ppljtLimitJobs On return, will contain the class pointer

Returns:

    ERROR_SUCCESS
    ERROR_NOT_ENOUGH_MEMORY
    Errors returned by constructor

--*/
DWORD
W3_LIMIT_JOB_THREAD::LimitThreadProc ( void )
{

    DWORD dwNumberOfBytesTransferred;
    ULONG_PTR uipCompletionKey;
    LPOVERLAPPED pOverlapped;

    DBG_ASSERT(m_hCompletionPort != NULL);

    while (TRUE) {
        if (GetQueuedCompletionStatus(m_hCompletionPort,
                                      &dwNumberOfBytesTransferred,
                                      &uipCompletionKey,
                                      &pOverlapped,
                                      INFINITE) ) {
            if (uipCompletionKey == NULL) {
                break;
            }
            if (dwNumberOfBytesTransferred == JOB_OBJECT_MSG_END_OF_JOB_TIME) {
                DBG_ASSERT(uipCompletionKey != NULL);

                ((W3_SERVER_INSTANCE *)uipCompletionKey)->LimitSiteCPU(TRUE,
                                                                       FALSE);
            }
        }
        else {
            DBG_ASSERT(FALSE);
        }
    }

    return NO_ERROR;
}


W3_JOB_QUEUE *W3_JOB_QUEUE::m_pjqJobQueue = NULL;

/*++

Routine Description:

    Constructor for W3_JOB_QUEUE.
    Create a Job Queue and a thread to monitor it.

Arguments:

    None

Returns:

    Sets m_dwInitError, which can be queried by GetInitError()

Notes:

    The caller should check the init error and delete this class on failure.

--*/
W3_JOB_QUEUE::W3_JOB_QUEUE( void ):
    m_hQueueThread     ( NULL ),
    m_hQueueEvent      ( NULL ),
    m_dwInitError      ( NO_ERROR )
{
    DWORD dwQueueThreadId;
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    InitializeListHead( &m_leJobQueue );

    m_hQueueEvent = CreateEvent ( NULL, FALSE, FALSE, NULL );

    if (m_hQueueEvent == NULL) {
        m_dwInitError = GetLastError();
    }
    else {
        m_hQueueThread = CreateThread(NULL,     // Security Attributes
                                      0,        // Default Stack Size
                                      &QueueThreadProcStub,  // Thread start routine
                                      (LPVOID)this, // parameter
                                      0,            // Creation Flags
                                      &dwQueueThreadId); // Thread ID
        if (m_hQueueThread == NULL) {
            m_dwInitError = GetLastError();
        }
    }
}

/*++

Routine Description:

    Destructor for W3_JOB_QUEUE.

Arguments:

    None

Returns:

    Nothing


--*/
W3_JOB_QUEUE::~W3_JOB_QUEUE( void )
{

    PLIST_ENTRY pleWorkItem;
    PJOB_WORK_ITEM pjwiWorkItem;

    TerminateJobQueueThread();

    LockThis();

    while (!IsListEmpty(&m_leJobQueue )) {
        pleWorkItem = RemoveHeadList ( &m_leJobQueue );
        pjwiWorkItem = CONTAINING_RECORD(pleWorkItem,
                                         JOB_WORK_ITEM,
                                         ListEntry);
        LocalFree (pjwiWorkItem);
    }

    if (m_hQueueEvent != NULL) {
        CloseHandle(m_hQueueEvent);
    }

    UnlockThis();

    DeleteCriticalSection(&m_csLock);

}

/*++

Routine Description:

    Terminate the job queue, if any.

Arguments:

    None

Returns:

    Nothing


--*/
// Static
VOID
W3_JOB_QUEUE::TerminateJobQueue( void )
{
    LockGlobals();
    if ( m_pjqJobQueue )
    {
        delete m_pjqJobQueue;
        m_pjqJobQueue = NULL;
    }
    UnlockGlobals();
}

/*++

Routine Description:

    Stop Processing the job queue, if any.

Arguments:

    None

Returns:

    Nothing


--*/
// Static
VOID
W3_JOB_QUEUE::StopJobQueue( void )
{
    LockGlobals();
    if ( m_pjqJobQueue )
    {
        m_pjqJobQueue->TerminateJobQueueThread();
    }
    UnlockGlobals();
}

/*++

Routine Description:

    Stop Processing the job queue, if any.

Arguments:

    None

Returns:

    Nothing


--*/
VOID
W3_JOB_QUEUE::TerminateJobQueueThread( void )
{
    if (m_hQueueThread != NULL) {

        DBG_REQUIRE(QueueWorkItem_Worker( JQA_TERMINATE_THREAD,
                                          NULL,
                                          NULL,
                                          FALSE ) == ERROR_SUCCESS);

        DBG_REQUIRE (WaitForSingleObject(m_hQueueThread,
                                         10000) != WAIT_TIMEOUT);
        m_hQueueThread = NULL;
    }
}
/*++

Routine Description:

    Static routine to get an instance of this class.

Arguments:

    ppljtLimitJobs On return, will contain the class pointer

Returns:

    ERROR_SUCCESS
    ERROR_NOT_ENOUGH_MEMORY
    Errors returned by constructor

--*/
DWORD
W3_JOB_QUEUE::GetJobQueue( W3_JOB_QUEUE ** ppjqJobQueue )
{
    DWORD dwReturn = ERROR_SUCCESS;

    if (m_pjqJobQueue != NULL) {
        *ppjqJobQueue = m_pjqJobQueue;
    }
    else {
        LockGlobals();
        if (m_pjqJobQueue != NULL) {
            *ppjqJobQueue = m_pjqJobQueue;
        }
        else {

            PW3_JOB_QUEUE pjqJobQueue;

            //
            // Create the class
            // Be sure not to set m_pjqJobQueue until it's
            // known valid, since it's normally accessed
            // outside the lock.
            //

            pjqJobQueue = new W3_JOB_QUEUE();
            if (pjqJobQueue == NULL) {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                dwReturn = pjqJobQueue->GetInitError();
                if (dwReturn == NO_ERROR) {
                    m_pjqJobQueue = pjqJobQueue;
                    *ppjqJobQueue = pjqJobQueue;
                }
                else {
                    delete pjqJobQueue;
                }
            }
        }
        UnlockGlobals();
    }

    return dwReturn;
}

/*++

Routine Description:

    The main routine of the monitoring thread.
    Processes the queue of work items.
    Terminates when it receives a JQA_TERMINATE_THREAD item.

Arguments:

Returns:

    ERROR_SUCCESS

--*/
DWORD
W3_JOB_QUEUE::QueueThreadProc ( void )
{

    DWORD dwResult;
    PLIST_ENTRY pleWorkItem;
    PJOB_WORK_ITEM pjwiWorkItem;
    BOOL fTerminate = FALSE;

    while (!fTerminate) {
        dwResult = WaitForSingleObject ( m_hQueueEvent, INFINITE );
        if (dwResult == WAIT_FAILED) {
            Sleep(1000);
            continue;
        }

        LockThis();

        while (!IsListEmpty(&m_leJobQueue ) && !fTerminate) {
            pleWorkItem = RemoveHeadList ( &m_leJobQueue );
            UnlockThis();

            pjwiWorkItem = CONTAINING_RECORD(pleWorkItem,
                                             JOB_WORK_ITEM,
                                             ListEntry);

            switch (pjwiWorkItem->jqaAction) {
            case JQA_RESTART_ALL_APPS:
                {
                    DeferredRestartChangedApplications(pjwiWorkItem->pvParam);
                }
                break;
            case JQA_TERMINATE_SITE_APPS:
                {
                    ((PW3_SERVER_INSTANCE)(pjwiWorkItem->pwsiInstance))->
                        TerminateCPUApplications((DWORD_PTR)pjwiWorkItem->pvParam);
                }
                break;
            case JQA_TERMINATE_THREAD:
                {
                    fTerminate = TRUE;
                }
                break;
            default:
                {
                    DBG_ASSERT(FALSE);
                }
            }


            LocalFree(pjwiWorkItem);

            LockThis();

        }

        UnlockThis();

    }

    return NO_ERROR;
}

/*++

Routine Description:

    Static routine to queue a work item to the job
    queue.

Arguments:

    jqaAction       The action to perform.
    pwsiInstance    The instance associated with this action.
    pvParam         The parameter to the work item.

Returns:

    ERROR_SUCCESS
    Errors returned by GetJobQueue
    Errors returned by QueueWorkItem_Worker

--*/

DWORD
W3_JOB_QUEUE::QueueWorkItem( JOB_QUEUE_ACTION jqaAction,
                             PVOID            pwsiInstance,
                             PVOID            pvParam)
{
    W3_JOB_QUEUE *pjqJobQueue;
    DWORD dwReturn;

    dwReturn = GetJobQueue(&pjqJobQueue);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = pjqJobQueue->QueueWorkItem_Worker(jqaAction,
                                                     pwsiInstance,
                                                     pvParam);
    }

    if (dwReturn != ERROR_SUCCESS) {

        //
        //  Log an event
        //

        DBGPRINTF((DBG_CONTEXT,
                  "[W3_JOB_QUEUE::QueueWorkItem_Worker] - failed, error code = 0x%X\n",
                  dwReturn));

        g_pInetSvc->LogEvent( W3_EVENT_JOB_QUEUE_FAILURE,
                              0,
                              NULL,
                              dwReturn );
    }

    return dwReturn;
}

/*++

Routine Description:

    Queue a work item to the job queue.

Arguments:

    jqaAction       The action to perform.
    pwsiInstance    The instance associated with this action.
    pvParam         The parameter to the work item.
    fQueueAtTail    If true, item will added to end of queue.

Returns:

    ERROR_SUCCESS
    ERROR_NOT_ENOUGH_MEMORY

--*/
DWORD
W3_JOB_QUEUE::QueueWorkItem_Worker( JOB_QUEUE_ACTION jqaAction,
                                    PVOID            pwsiInstance,
                                    PVOID            pvParam,
                                    BOOL             fQueueAtTail)
{

    DWORD dwReturn = ERROR_SUCCESS;
    PJOB_WORK_ITEM pjwiWorkItem;

    pjwiWorkItem = (PJOB_WORK_ITEM)LocalAlloc( LMEM_FIXED, sizeof(JOB_WORK_ITEM) );

    if (pjwiWorkItem == NULL) {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        pjwiWorkItem->jqaAction = jqaAction;
        pjwiWorkItem->pwsiInstance = pwsiInstance;
        pjwiWorkItem->pvParam = pvParam;

        LockThis();

        if (fQueueAtTail) {
            InsertTailList( &m_leJobQueue, &(pjwiWorkItem->ListEntry) );
        }
        else {
            InsertHeadList( &m_leJobQueue, &(pjwiWorkItem->ListEntry) );
        }

        UnlockThis();

        SetEvent(m_hQueueEvent);
    }

    return dwReturn;
}

/*++

Routine Description:

    Stub routine to pass into ScheduleWorkItem, to handle interval change.

Arguments:

    pContext    W3_SERVER_INSTANCE Pointer.

Return Value:

Notes:
--*/
VOID
DeferredJobResetInterval(
     VOID * pContext
    )
{
    ((W3_SERVER_INSTANCE *)pContext)->JobResetInterval();
}

/*++

Routine Description:

    Stub routine to pass into ScheduleWorkItem, to do periodic logging.

Arguments:

    pContext    W3_SERVER_INSTANCE Pointer.

Return Value:

Notes:
--*/
VOID
DeferredQueryAndLogJobInfo(
     VOID * pContext
    )
{
    ((W3_SERVER_INSTANCE *)pContext)->QueryAndLogJobInfo(JOLE_PERIODIC_LOG, FALSE);
}

/*++

Routine Description:

    Restart Wams if they have been job enabled or disabled.

Arguments:

    pContext    LPSTR path where metadata was changed.

Return Value:

Notes:
--*/
VOID
DeferredRestartChangedApplications(VOID * pContext)
{

    BUFFER bufDataPaths;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    LPSTR   pszCurrentPath;
    STR     strPath;
    LPSTR pszMDPath = (LPSTR) pContext;

    DBG_ASSERT(pszMDPath != NULL);

    IF_DEBUG( JOB_OBJECTS )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[DeferredRestartChangedApplications] \n"
                  "Restarting changed applications under path %s\n",
                  pszMDPath ));
    }

    //
    // Get rid of trailing /
    //

    DBG_ASSERT(pszMDPath[strlen(pszMDPath) - 1] == '/');
    pszMDPath[strlen(pszMDPath) - 1] = '\0';

    if ( mb.Open( pszMDPath,
                  METADATA_PERMISSION_READ ) )
    {

        //
        // First find the OOP Applications
        //

        if (mb.GetDataPaths(NULL,
                            MD_APP_PACKAGE_ID,
                            STRING_METADATA,
                            &bufDataPaths))
        {

            //
            // Close metabase in case an application needs to use it.
            // The destructor will close this if not closed, so ok
            // to close in if statement.
            //

            mb.Close();
            //
            // For each OOP Application
            //

            for (pszCurrentPath = (LPSTR)bufDataPaths.QueryPtr();
                 *pszCurrentPath != '\0';
                 pszCurrentPath += (strlen(pszCurrentPath) + 1))
            {
                if (strPath.Copy(pszMDPath))
                {
                    if (strPath.Append(pszCurrentPath))
                    {
                        strPath.SetLen(strlen(strPath.QueryStr()) - 1);
                        g_pWamDictator->CPUUpdateWamInfo(&strPath);
                    }
                }

            }
        }
    }
    delete pContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\debug\help.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    help.c
    This module implements the "help" command of the W3 Server debugger
    extension DLL.


    FILE HISTORY:
        KeithMo     18-May-1993 Created.

*/

#include "w3dbg.h"


/*******************************************************************

    NAME:       help

    SYNOPSIS:   Implements the "help" command.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    HISTORY:
        KeithMo     18-May-1993 Created.

********************************************************************/
VOID help( HANDLE hCurrentProcess,
           HANDLE hCurrentThread,
           DWORD  dwCurrentPc,
           LPVOID lpExtensionApis,
           LPSTR  lpArgumentString )
{
    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Show the help.
    //

    DebugPrint( "W3 Server Debugger Extensions:\n" );
    DebugPrint( "  help           - Show this help\n" );
    DebugPrint( "  user           - Dump user info\n" );
    DebugPrint( "  stats          - Dump statistics\n" );

    return;

}   // help
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\waminfo.cxx ===
/*-----------------------------------------------------------------------------

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       wamexec.cxx

   Abstract:
       This module executes a wam request

   Author:
       David Kaplan    ( DaveK )     11-Mar-1997
       Lei Jin          (leijin)     24-Apr-1997    (WamInfo & WamDictator)

   Environment:
       User Mode - Win32

   Project:
       W3 services DLL

-----------------------------------------------------------------------------*/

#include <w3p.hxx>
#include "wamexec.hxx"
#include "waminfo.hxx"
#include "wamreq.hxx"

// MIDL-generated include files
#include "wam.h"
#include "wam_i.c"
#include <wmrgexp.h>
#include <issched.hxx>
#include "mtacb.h"
#include "gip.h"
#include <malloc.h>
#include "wrcstids.hxx"
#include "wrcfixed.hxx"

#define SZ_FAILED_OOP_REQUEST_LOG_MESSAGE   \
    "Out-of-process ISAPI extension request failed."
#define SZ_FAILED_OOP_EXCEEDED_CRASH_LOG_MESSAGE   \
    "Out-of-process ISAPI extension has exceeded crash limit."

/*-----------------------------------------------------------------------------
 Globals
-----------------------------------------------------------------------------*/
extern PFN_INTERLOCKED_COMPARE_EXCHANGE g_pfnInterlockedCompareExchange;

//
// This number is in ms, 10 (min) * 60 (sec/min) * 1000 (ms/s).
// DCOM/RPC level holds some reference(up to 2) to a WAM_REQUESTs when an OOP MTS process crashes,
// In order to clean the Wam_Request completely, w3svc needs to wait for 10 min(enough for 6 min DCOM
// refenrence timeout).
//
#define DEFAULT_CLEANUP_WAIT 600000


/*-----------------------------------------------------------------------------
    WamInfo State Description

    State               Valid(Can Serving requests)

    WIS_START           F (sould not get into this state at runtime)       
    WIS_RUNNING         T
    WIS_REPAIR          T (Yes, although requests is going to be waiting or rejected).
    WIS_PAUSE           F (NYI)
    WIS_CPUPAUSE        T
    WIS_ERROR           T (Yes, the requests is going to be rejected).
    WIS_SHUTDOWN        T
    WIS_END             F (should not get into this state at runtime)
    WIS_MAX_STATE       F (should not get into this state at runtime)

    Please refer to waminfo.hxx for detailed description of waminfo state.
-----------------------------------------------------------------------------*/
BOOL CWamInfo::m_rgValidState[WIS_MAX_STATE] =
    {
    FALSE,
    TRUE,
    TRUE,
    FALSE,
    FALSE,
    TRUE,
    FALSE,
    FALSE
    };


#define WAMINFO_SIGNATURE       (DWORD)'FIMW'
#define FREED_WAMINFO_SIGNATURE (DWORD)'fIMW'



/*-----------------------------------------------------------------------------
CWamInfo::CWamInfo

Constructor

Arguments:
pstrMetabasePath    [in]    a pointer to Metabase Path.
fInProcess          [in]    in-proc/out-proc    // remote is not a choice
fEnableTryExcept    [in]    enable try/except flag
clsidWam            [in]    the WAM CLSID

-----------------------------------------------------------------------------*/
CWamInfo::CWamInfo
(
const STR   &strMetabasePath,
BOOL    fInProcess,
BOOL    fInPool,
BOOL    fEnableTryExcept,
REFGUID clsidWam
)
:   m_strApplicationPath(strMetabasePath),
    m_dwSignature(WAMINFO_SIGNATURE),
    m_pIWam(NULL),
    m_dwIWamGipCookie( NULL_GIP_COOKIE ),
    m_cRef(0),
    m_cCurrentRequests(0),
    m_cTotalRequests(0),
    m_dwState(WIS_START),
    m_fInProcess(fInProcess),
    m_fEnableTryExcept(fEnableTryExcept),
    m_fShuttingDown(FALSE),
    m_pProcessEntry(NULL),
    m_clsidWam(clsidWam),
    m_fInPool(fInPool),
    m_dwRecycleSchedulerCookie(0),
    m_fRecycled(0),
    m_cMaxRequests(0)
    {
    InitializeListHead(&leProcess);
    INITIALIZE_CRITICAL_SECTION(&m_csRecycleLock);
    }
/*-----------------------------------------------------------------------------
CWamInfo::~CWamInfo

Destructor
-----------------------------------------------------------------------------*/
CWamInfo::~CWamInfo
(
void
)
    {
    DeleteCriticalSection(&m_csRecycleLock);
    m_dwSignature = FREED_WAMINFO_SIGNATURE;
    DBG_ASSERT(m_cRef == 0);
    DBG_ASSERT(m_cCurrentRequests == 0);
    }

HRESULT     
CWamInfo::PreProcessWamRequest
(
IN  WAM_REQUEST*    pWamRequest,
IN  HTTP_REQUEST*   pHttpRequest,
OUT IWam**          ppIWam,
OUT BOOL*           pfHandled
)
    {
    IWam *pIWam = NULL;
    DBG_ASSERT( m_dwIWamGipCookie != NULL_GIP_COOKIE );

    if( FAILED( g_GIPAPI.Get( m_dwIWamGipCookie, IID_IWam, (void **)&pIWam )))
        {
        //
        // bad news - GIP refused to provide a pointer
        // we'll let higher levels to deal with it and return NULL here
        //
        pIWam = NULL;
        }
    *ppIWam = pIWam;
    return NOERROR;
    }

HRESULT     
CWamInfo::PreProcessAsyncIO
(
IN  WAM_REQUEST *   pWamRequest,
OUT IWam **         ppIWam
)
{
    IWam *pIWam = NULL;
    DBG_ASSERT( m_dwIWamGipCookie != NULL_GIP_COOKIE );

    if( FAILED( g_GIPAPI.Get( m_dwIWamGipCookie, IID_IWam, (void **)&pIWam )))
        {
        //
        // bad news - GIP refused to provide a pointer
        // we'll let higher levels to deal with it and return NULL here
        //
        pIWam = NULL;
        }
    *ppIWam = pIWam;
    return NOERROR;
}

/*-----------------------------------------------------------------------------
CWamInfo::ProcessWamRequest

Process a Wam Request(of this application path).
The request must ask for the same application path with this WamInfo.  This function will create a
wam request, process the request and finish the request.

Arguments:
pHttpRequest    [in]    pointer to HTTP Request
pExec           [in]    pointer to Exec descriptor
pstrPath,       [in]    physical path of the dll???
pfHandled,      [out]
pfFinished      [out]

Return:
HRESULT

-----------------------------------------------------------------------------*/
HRESULT
CWamInfo::ProcessWamRequest
(
HTTP_REQUEST    *       pHttpRequest,
EXEC_DESCRIPTOR *       pExec,
const STR *             pstrPath,
BOOL *                  pfHandled,
BOOL *                  pfFinished
)
    {
    HRESULT         hr = NOERROR;
    WAM_REQUEST *   pWamRequest = NULL;
    IWam *          pIWam = NULL;

    if ( !FCurrentStateValid() || m_fShuttingDown)
        {

        if ( QueryState() == WIS_CPUPAUSE )
            {
            //
            // Since WAM_INFO is going to send some message to the browser, we need
            // to set pfHandled = TRUE here.
            //
            *pfHandled = TRUE;

            if ( !pExec->IsChild() )
            {
                pHttpRequest->SetLogStatus( HT_SVC_UNAVAILABLE, 
                                            ERROR_NOT_ENOUGH_QUOTA );
                                            
                pHttpRequest->Disconnect(HT_SVC_UNAVAILABLE, 
                                         IDS_SITE_RESOURCE_BLOCKED, 
                                         TRUE, 
                                         pfFinished);
            }

            Dereference();

            //
            // Since we already called Disconnect, WAM_INFO should return TRUE to high level.
            //

            return  NOERROR;
            }

        IF_DEBUG( WAM_ISA_CALLS )
            {
            DBGPRINTF((
                DBG_CONTEXT
                , "CWamInfo(%08x) shutting down.  "
                  "Http-request(%08x) will be aborted.\n"
                , this
                , pHttpRequest
            ));
            }

        Dereference();
        return HRESULT(ERROR_SERVER_DISABLED);
        }


    // Create the wam req NOTE CreateWamRequestInstance addref's
    hr = CreateWamRequestInstance( pHttpRequest,
                                    pExec,
                                    pstrPath,
                                    this,
                                    &pWamRequest);
    if ( FAILED(hr))
        {
        DBGPRINTF(( DBG_CONTEXT,
                   "WAMInfo::ProcessWamRequest: CreateWamRequestInstance failed, hr = %08x\n",
                   hr
                   ));

        // The Dereference balances the reference in FindWamInfo.
        Dereference();
        goto LExit;
        }

    DBG_ASSERT(pWamRequest != NULL);

    //  Temporarily allow the number of pool threads to grow while we're processing the request
    AtqSetInfo( AtqIncMaxPoolThreads, 0 );
    InterlockedIncrement(&m_cTotalRequests);
    InterlockedIncrement(&m_cCurrentRequests);

    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((
            DBG_CONTEXT,
            "CWamInfo 0x%08x: serviced %d requests of maximum %d.\r\n",
            this,
            m_cTotalRequests,
            m_cMaxRequests
            ));

    if ( m_cMaxRequests && m_cMaxRequests <= m_cTotalRequests )
    {
        Recycle( 0 );
    }

    hr = PreProcessWamRequest(pWamRequest, pHttpRequest, &pIWam, pfHandled);

    if (SUCCEEDED(hr))
        {
        DBG_ASSERT(pIWam != NULL);

        hr = DoProcessRequestCall( pIWam, pWamRequest, pfHandled );

        pIWam->Release();
        //
        // got rid of it in Avalanche
        //
        *pfFinished = FALSE;

        AtqSetInfo( AtqDecMaxPoolThreads, 0 );

        if( WIN32_FROM_HRESULT( hr ) == ERROR_ACCESS_DENIED )
            {

            DBGPRINTF(( DBG_CONTEXT,"Process wam request-access denied\n",hr));
            pWamRequest->SetDeniedFlags( SF_DENIED_RESOURCE );

            pWamRequest->SetExpectCleanup( TRUE );

            }
        else if( RPC_S_CALL_FAILED == WIN32_FROM_HRESULT(hr) ||
                 RPC_S_CALL_FAILED_DNE == WIN32_FROM_HRESULT(hr) ||
                 RPC_S_SERVER_UNAVAILABLE == WIN32_FROM_HRESULT(hr)
                 )
            {
            
            // 1> If the OOP call failed during the call, RPC returns RPC_S_CALL_FAILED.
            // ie. OOP process crashed during the call
            // 2> If OOP process crashed before the call, RPC returns RPC_S_CALL_FAILED_DNE.
            //
            // Subsequest requests to the crashed OOP Process will get RPC_S_SERVER_UNAVAILABLE.
            //
            PostProcessRequest(hr, pWamRequest);
            
            }
        else
            {

            DBG_ASSERT( HRESULT_FACILITY(hr) != FACILITY_RPC );

            // Success
            pWamRequest->SetExpectCleanup( TRUE );

            }
        }
    else
        {
        if (TRUE == *pfHandled)
            {
            DBG_ASSERT(pIWam == NULL && hr == HRESULT_FROM_WIN32(RPC_S_CALL_FAILED));
            hr = NOERROR;
            }
        AtqSetInfo( AtqDecMaxPoolThreads, 0 );
        }

    InterlockedDecrement(&m_cCurrentRequests);

LExit:
    // NOTE this release balances with addref in CreateWamRequestInstance()
    if (pWamRequest)
        {
        pWamRequest->Release();
        pWamRequest = NULL;
        }

    return hr;
    }//CWamInfo::ProcessWamRequest

HRESULT 
CWamInfo::DoProcessRequestCall
(
    IN IWam *           pIWam,
    IN WAM_REQUEST *    pWamRequest,
    OUT BOOL *          pfHandled
)
{
    return pIWam->ProcessRequest( pWamRequest,
                                  pWamRequest->CbWrcStrings( m_fInProcess ),
                                  NULL,
                                  pfHandled
                                  );
}

/*-----------------------------------------------------------------------------
CWamInfo::ProcessAsyncIO

ProcessAsyncIO.
-----------------------------------------------------------------------------*/
HRESULT CWamInfo::ProcessAsyncIO
(
WAM_REQUEST*    pWamRequest,
#ifdef _WIN64
UINT64          pWamExecInfoIn,
#else
ULONG_PTR       pWamExecInfoIn,
#endif
DWORD           dwStatus,
DWORD           cbWritten,
LPBYTE          lpOopReadData   // Default == NULL
)
{
    HRESULT hr = NOERROR;
    IWam *pIWam = NULL;

    hr = PreProcessAsyncIO(pWamRequest, &pIWam);
    if (SUCCEEDED(hr))
    {
        DBG_ASSERT(pIWam != NULL);

        if( lpOopReadData == NULL )
        {
            hr = pIWam->ProcessAsyncIO(
                                pWamExecInfoIn,
                                dwStatus,
                                cbWritten
                                );
        }
        else
        {
            DBG_ASSERT( !m_fInProcess );
            hr = pIWam->ProcessAsyncReadOop(
                                pWamExecInfoIn,
                                dwStatus,
                                cbWritten,
                                lpOopReadData
                                );
        }

        pIWam->Release();

        if( WIN32_FROM_HRESULT( hr ) == ERROR_ACCESS_DENIED )
        {
            DBGPRINTF(( DBG_CONTEXT,"Process wam request-access denied\n",hr));
            pWamRequest->SetDeniedFlags( SF_DENIED_RESOURCE );
        }

        PostProcessRequest(hr, pWamRequest);
    }

    return hr;
}//CWamInfo::ProcessAsyncIO


/*-----------------------------------------------------------------------------
CWamInfo::GetStatistics

This code is used internally for iisprobe.dll only.
-----------------------------------------------------------------------------*/

HRESULT CWamInfo::GetStatistics
(
DWORD     Level,
LPWAM_STATISTICS_INFO pWamStatsInfo
)
    {
    IWam *pIWam = NULL;
    HRESULT hr;

    //
    // both case - go through GIP
    //
    DBG_ASSERT(m_dwIWamGipCookie != NULL_GIP_COOKIE);
    hr = g_GIPAPI.Get( m_dwIWamGipCookie, IID_IWam, (void **) &pIWam );
    if( SUCCEEDED( hr ) )
        {
        hr = pIWam->GetStatistics(Level, pWamStatsInfo);
        pIWam->Release();
        }

    return hr;
    } // CWamInfo::GetStatistics


//
// aux class, used temporarily by WamInfo::CreateWamInstance()
//
struct WAM_CREATOR {
    REFCLSID m_clsidWam;
    DWORD m_dwContext;
    IWam * m_pIWam;
    DWORD m_dwIWamCookie;
    BOOL m_fOutOfProc;

    WAM_CREATOR( REFCLSID clsidWam, DWORD dwContext, BOOL fOutOfProc );
};

//
// initialize WAM_CREATOR instance
//
WAM_CREATOR::WAM_CREATOR(
                 REFCLSID clsidWam,
                 DWORD dwContext,
                 BOOL fOutOfProc )
    : m_clsidWam( clsidWam ),
      m_dwContext( dwContext ),
      m_pIWam( 0 ),
      m_dwIWamCookie( 0 ),
      m_fOutOfProc( fOutOfProc )
{
}

//
// this conforms to MTA callback format
//
HRESULT __stdcall WamCreatorCallback(void *v1, void *v2)
{
    HRESULT hr;
    WAM_CREATOR * pwc = (WAM_CREATOR *) v1;

    hr = CoCreateInstance( pwc->m_clsidWam,
                             NULL,
                             pwc->m_dwContext,
                             IID_IWam,
                             (void **)&pwc->m_pIWam
                             );
    DBGPRINTF( (DBG_CONTEXT, "CoCreated WAM: %x(%x)\n", pwc->m_pIWam, hr ) );

    if(SUCCEEDED(hr) && pwc->m_fOutOfProc) {
        //
        // BUG: 609457
        // Set the proxy blanket so that the client can't
        // impersonate us.
        //

        hr = CoSetProxyBlanket(
            pwc->m_pIWam,
            RPC_C_AUTHN_DEFAULT,
            RPC_C_AUTHZ_DEFAULT,
            COLE_DEFAULT_PRINCIPAL,
            RPC_C_AUTHN_LEVEL_DEFAULT,
            RPC_C_IMP_LEVEL_IDENTIFY,
            COLE_DEFAULT_AUTHINFO,
            EOAC_DEFAULT
        );

        if ( FAILED( hr ) )
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to CoSetProxyBlanket WAM.\r\n"));
        }
    }
            
    if(SUCCEEDED(hr)) {

        //
        // OOP case needs GIPs
        //

        hr = g_GIPAPI.Register(pwc->m_pIWam, IID_IWam, &pwc->m_dwIWamCookie);

        if(FAILED(hr)) {
            DBGPRINTF( (DBG_CONTEXT, "Failed to register w GIP:%x (%x)\n", pwc->m_pIWam, hr ) );
            pwc->m_pIWam->Release();
            pwc->m_pIWam = NULL;
        }else{
            DBGPRINTF( (DBG_CONTEXT, "Registered w GIP OK\n" ) );
        }
    }

    return hr;
}

/*-----------------------------------------------------------------------------
CWamInfo::CreateWamInstance

Creates WAM instance. For complete detail, see BUG #137647.
In short, the purpose of this is to make sure that CoCreateInstance()
is called from MTA thread and not from one of ATQ threads, converted to
STA by a random ISAPI extension.

The real work is done in WamCreatorCallback() above.

Returns:
    HRESULT of CoCreateInstance(), and, in OOP case,
    HRESULT of GIPAPI.Register

-----------------------------------------------------------------------------*/
HRESULT CWamInfo::CreateWamInstance( DWORD dwContext )
{
    HRESULT hr = 0;
    WAM_CREATOR wc( m_clsidWam, CLSCTX_ALL, !m_fInProcess );

    //
    // do the actual work on MTA thread
    //

    hr = CallMTACallback( WamCreatorCallback, &wc, NULL );

    //
    // store resulting IWAM pointer and GIP cookie
    //

    m_pIWam = (IWam *) wc.m_pIWam;
    m_dwIWamGipCookie = wc.m_dwIWamCookie;

    return hr;
}

/*-----------------------------------------------------------------------------
CWamInfo::Init

Create the WAM object.  One-to-One mapping between a WamInfo and a Wam.

Arguments:
None.

Return:
HRESULT
-----------------------------------------------------------------------------*/
HRESULT
CWamInfo::Init
(
WCHAR* wszPackageId,
DWORD  pidInetInfo
)
    {
    HRESULT     hr = NOERROR;
    IWam *      pIWam = NULL;

    // If WamInfo on start or
    // WamInfo is out of proc and it is in either repair or cuppause sate.
    // Init the WamInfo
    DBG_ASSERT(((m_dwState == WIS_REPAIR  || m_dwState == WIS_CPUPAUSE) && !m_fInProcess)
                || m_dwState == WIS_START );         

    DWORD dwContext =   ((m_fInProcess) ?
                        CLSCTX_INPROC_SERVER : CLSCTX_LOCAL_SERVER
                        );

    IF_DEBUG( ERROR )
        {
        Print();
        }

    DBG_ASSERT( NULL == m_pIWam);
    DBGPRINTF( (DBG_CONTEXT, "Creating WAM Instance dwContext = %x\n", dwContext ) );
    hr = CreateWamInstance( dwContext );
    //DBGPRINTF( (DBG_CONTEXT, "Created WAM Instance %x (%x)\n", m_pIWam, hr ) );

    if (SUCCEEDED(hr))
        {
        DWORD pidWamProcess = 0;

        // Use GIP in inproc case as well.

        DBG_ASSERT( m_dwIWamGipCookie != NULL_GIP_COOKIE);

        hr = g_GIPAPI.Get( m_dwIWamGipCookie, IID_IWam, (void **) &pIWam );
        if( SUCCEEDED( hr ) )
            {
            hr = pIWam->InitWam(
                m_fInProcess,
                m_fInPool,
                m_fEnableTryExcept,
                W3PlatformType,
                &pidWamProcess
                );
            pIWam->Release();
            }

        if( SUCCEEDED(hr) && !m_fInProcess )
        {
            //
            // Under some circumstances com svcs my get hosed. This causes 
            // object activation to happen in process even if the object 
            // is registered to be launched in the surrogate. In order to 
            // prevent inetinfo from AV'ing we want to prevent these 
            // applications from running.
            //
            DBG_ASSERT( pidInetInfo != pidWamProcess );
            if( pidInetInfo == pidWamProcess )
            {
                // Log the failure.
                // W3_EVENT_FAIL_OOP_ACTIVATION - in W3SVC.dll
                const CHAR * pszEventLog[2];
                CHAR         szAppId[40];

                *szAppId = 0;
                WideCharToMultiByte( CP_ACP, 0, wszPackageId, -1, szAppId, 40, NULL, NULL );

                pszEventLog[0] = szAppId;
                pszEventLog[1] = m_strApplicationPath.QueryStr();

                g_pInetSvc->LogEvent( W3_EVENT_FAIL_OOP_ACTIVATION,
                                      2,
                                      pszEventLog,
                                      0
                                      );
                
                // We need to return an error code to prevent further
                // processing. Since this will get looked up and event
                // logged, by the WAM_DICTATOR we want to return something
                // innocuous, but understandable.
                hr = W3_EVENT_FAIL_OOP_ACTIVATION;
            }
            else
            {
                //
                // Schedule recycling if configured to do so
                //

                if ( m_dwRecycleTime )
                {
                    Recycle( m_dwRecycleTime * 60 * 1000 );
                }
            }
        }

        if (SUCCEEDED(hr))
            {
            m_pProcessEntry = g_pWamDictator->m_PTable.AddWamInfoToProcessTable(
                                    this,
                                    wszPackageId,
                                    pidWamProcess);

            if (m_pProcessEntry != NULL)
                {
                // Make WamInfo Alive.  This reference is balanced
                // by CWamInfo::Uninit if the CWamInfo has an associated
                // process entry.
                Reference();
                DBGPRINTF(( DBG_CONTEXT, "New WamInfo(%08x))\n", this));
                }
           else 
                {
                 DWORD err = GetLastError();
                 DBGPRINTF(( DBG_CONTEXT, "Dup Handle, error %08x\n", err ));
                 hr = HRESULT_FROM_WIN32( err);
                }
            }
        else
            {
            DBGPRINTF(( DBG_CONTEXT,
                        "WAM(%08x)::InitWam() failed, error %08x\n",
                        m_dwIWamGipCookie, hr ));
            }

        }
    else
        {
        /*
        some possible failures:
        CO_E_NOTINITIALIZED        0x800401f0
        REGDB_E_CLASSNOTREG        0x80040154
        */
        DBG_ASSERT( hr != CO_E_NOTINITIALIZED );
        DBG_ASSERT( hr != REGDB_E_CLASSNOTREG );
        DBGPRINTF(( DBG_CONTEXT,
                   "CoCreateInstance failed to create WAM, error %08x\n",
                    hr ));
        DBG_ASSERT( m_pIWam == NULL);
        }


    // Rely on the correct call to UnInit to free things up. If uninit
    // isn't correctly called, then the WAM object is leaked anyway.

    /*
    if ( FAILED( hr)  && (m_pIWam != NULL))
        {
        m_pIWam->Release(); // release the Wam
        m_pIWam = NULL;
        }
    */

    return hr;
    } // CWamInfo::Init()

VOID        
CWamInfo::NotifyGetInfoForName
(
    IN LPCSTR   pszServerVariable
)
{
    // Only functional oop
    return;
}

/*-----------------------------------------------------------------------------
CWamInfo::StartShutdown

Phase 1 of shutdown process.

Return:
HRESULT
-----------------------------------------------------------------------------*/
HRESULT
CWamInfo::StartShutdown
(
INT cIgnoreRefs
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "CWamInfo::StartShutdown\n"));

    HRESULT hr = NOERROR;
    LONG fShuttingDown;

    fShuttingDown = InterlockedExchange((LPLONG)&m_fShuttingDown, (LONG)TRUE);

    if ((BOOL)fShuttingDown == FALSE && m_pIWam != NULL)
        {
        IWam *pIWam = NULL;
        DBG_ASSERT( m_dwIWamGipCookie != NULL_GIP_COOKIE );
        if( FAILED( g_GIPAPI.Get( m_dwIWamGipCookie, IID_IWam, (void **)&pIWam )))
            {
            //
            // bad news - GIP refused to provide a pointer
            // we'll let higher levels to deal with it and return NULL here
            //
            pIWam = NULL;
            }
        else
            {
            hr = pIWam->StartShutdown();
            pIWam->Release();
            pIWam = NULL;
            }
        }

    LoopWaitForActiveRequests(cIgnoreRefs);
    return hr;

    } // CWamInfo::StartShutdown()

/*-----------------------------------------------------------------------------
CWamInfo::ClearMembers

Clears the members that are not cleared by unit, so that
it can be reused after a CPU Pause.

Return:
HRESULT
-----------------------------------------------------------------------------*/
void
CWamInfo::ClearMembers
(
void
)
    {
    m_fShuttingDown = FALSE;
    DBG_ASSERT(m_pIWam == NULL
                && m_pProcessEntry == NULL
                && m_dwIWamGipCookie == NULL_GIP_COOKIE
                );
    }

    
/*-----------------------------------------------------------------------------
CWamInfo::LoopWaitForActiveRequests

Loop wait until all active requests are gone.  Upon return from this call, there
should be no more active requests for this WamInfo.

Return:
HRESULT
-----------------------------------------------------------------------------*/
void
CWamInfo::LoopWaitForActiveRequests
(
INT cIgnoreRefs
)
    {
    INT     cBaseRef = 1 + cIgnoreRefs;

    //
    // Allow all other references to WAMINFO to drain away.
    // This loop is especially important in Unload scenario.
    // Unload Application while w3svc is still running, a busy application might
    // still have some outstanding WAMREQUEST unfinished which hold the reference to
    // this WAMINFO.
    //
    // m_cRef should be 1 in normal condition.  However, m_cRef could be 0.
    // TODO: Update Comments.
    //
    //cBaseRef = (fIgnoreHashTableRef) ? 2;

    //while (m_cRef > cBaseRef)
    while(m_cCurrentRequests > 0)
        {
        DBGPRINTF((DBG_CONTEXT, "Still have out-standing reference(%d) to this WamInfo %08x\n",
            //m_cRef,
            m_cCurrentRequests,
            this));
        Sleep(20);
        }

    } // CWamInfo::LoopWaitForActiveRequests


/*-----------------------------------------------------------------------------
CWamInfo::UnInit

Phase 2 of shutdown process.
Unload WAM.  Release the WAM object.  Also release the Process handle.

Return:
HRESULT
-----------------------------------------------------------------------------*/
HRESULT
CWamInfo::UnInit
(
void
)
    {
    HRESULT hr = NOERROR;

    DBG_ASSERT( m_dwState == WIS_SHUTDOWN || 
                m_dwState == WIS_CPUPAUSE || 
                m_dwState == WIS_START
                );

    //
    // If there is a scheduled recycle pending, delete it here.
    //

    if ( m_dwRecycleSchedulerCookie && !m_fRecycled )
    {
        RemoveWorkItem( m_dwRecycleSchedulerCookie );
    }
    
    if (m_pIWam != NULL)
        {
        IWam * pIWam = NULL;

        if ( m_dwIWamGipCookie != NULL_GIP_COOKIE )
            {

            //
            // use a thread-valid pIWam from GIP
            //
            hr = g_GIPAPI.Get( m_dwIWamGipCookie, IID_IWam, (void **)&pIWam );
            if( SUCCEEDED( hr ) )
                {
                DBG_ASSERT( pIWam );

                pIWam->UninitWam();
                pIWam->Release();
                }

            //
            // get rid of the GIP entry
            // note - this hr will be the return result
            //
            hr = g_GIPAPI.Revoke( m_dwIWamGipCookie );                
            m_dwIWamGipCookie = NULL_GIP_COOKIE;
            }

        // balance the AddRef in CWamInfo::Init.
        m_pIWam->Release();
        m_pIWam = NULL;
        }

    // If we got a handle for an Out Of Proc Wam, release it
    if( m_pProcessEntry != NULL)
        {
        // Process entry remains in the table, but this reference is
        // no longer valid
        g_pWamDictator->m_PTable.RemoveWamInfoFromProcessTable(this);
        m_pProcessEntry = NULL;
        
        // balance the AddRef in WamInfo::Init.
        Dereference();
        }

    return hr;
    }

void
CWamInfo::Print(void) const
    {
        if (m_pProcessEntry) {
            DBGPRINTF(( DBG_CONTEXT,
                        " WAM_INFO(%08x) Refs=%d; TotalReqs=%d; dwState=%d;"
                        " AppPath=%s;"
                        " WamGipCookie=%d; clsid=" GUID_FORMAT " pidWam=%d; hWam=%08x\n"
                        ,
                        this, m_cRef, m_cTotalRequests, m_dwState,
                        m_strApplicationPath.QueryStr(),
                        m_dwIWamGipCookie, GUID_EXPAND( &m_clsidWam), 
                        m_pProcessEntry->QueryProcessId(),
                        m_pProcessEntry->QueryProcessHandle()
                        ));
        }
        else {
            DBGPRINTF(( DBG_CONTEXT,
                        " WAM_INFO(%08x) Refs=%d; TotalReqs=%d; dwState=%d;"
                        " AppPath=%s;"
                        " WamGipCookie=%d; clsid=" GUID_FORMAT " No WAM Object\n"
                        ,
                        this, m_cRef, m_cTotalRequests, m_dwState,
                        m_strApplicationPath.QueryStr(),
                        m_dwIWamGipCookie, GUID_EXPAND( &m_clsidWam) 
                        ));
        }
    } // CWamInfo::Print()

void CWamInfo::Recycle
(
DWORD dwTimeInSec
)
{
    RecycleLock();

    if ( m_fRecycled )
    {
        goto Done;
    }

    //
    // If dwTimeInSec is zero, set m_fRecycled to TRUE now.  This
    // will prevent races within the scheduler when a CWamInfo
    // overshoots it's target number of requests and every request
    // wants to recycle.
    //

    if ( !dwTimeInSec )
    {
        m_fRecycled = TRUE;
    }

    //
    // Do the recycle on a different thread so that the current
    // request is not delayed.
    //

    if ( m_dwRecycleSchedulerCookie )
    {
        if ( ScheduleAdjustTime( m_dwRecycleSchedulerCookie, 0 ) != NO_ERROR )
        {
            //
            // Too late.  We had a previously scheduled thread,
            // and it's not here anymore.  It must have run.
            //

            goto Done;
        }
        else
        {
            goto Done;
        }
    }

    //
    // This reference is balanced by the callback function or the
    // zero m_dwRecycleSchedulerCookie check below.
    //

    Reference();

    m_dwRecycleSchedulerCookie = ScheduleWorkItem(
        RecycleCallback,
        this,
        dwTimeInSec,
        FALSE
        );

    if ( !m_dwRecycleSchedulerCookie )
    {
        Dereference();
    }

Done:

    RecycleUnlock();
}

/*-----------------------------------------------------------------------------
CWamInfo::QueryKey

Query strMetabasePath.

Return:
HRESULT
-----------------------------------------------------------------------------*/
LPCSTR CWamInfo::QueryKey() const
    {
    return m_strApplicationPath.QueryStr();
    }

/*-----------------------------------------------------------------------------
COOPWamReqList::COOPWamReqList

Constructor for COOPWamReqList

-----------------------------------------------------------------------------*/
COOPWamReqList::COOPWamReqList()
:   m_dwTimeStamp(0),
    m_fActive(TRUE)

    {
    InitializeListHead(&m_leRecoverListLink);
    InitializeListHead(&m_leOOPWamReqListHead);
    }

/*-----------------------------------------------------------------------------
COOPWamReqList::~COOPWamReqList

Destructor for COOPWamReqList

-----------------------------------------------------------------------------*/
COOPWamReqList::~COOPWamReqList(VOID)
    {
    DBG_ASSERT(IsListEmpty(&m_leOOPWamReqListHead));
    // Reset link with m_rgOOPWamReqLists...
    InitializeListHead(&m_leRecoverListLink);
    }

/*-----------------------------------------------------------------------------
COOPWamReqList::FTimeToCleanup

Check whether it is the time to cleanup the CleanupList.  Must meet the condition that
the time since the corresponding instance of WAM crashed elapsed is more that 10 min.

-----------------------------------------------------------------------------*/
BOOL COOPWamReqList::FTimeToCleanup(DWORD dwCurrentTime)
    {
    //
    // iF THIS WamReqList is an active list, return FALSE immediately, because
    // an ActiveOne have timestamp = 0, the following check most likely will trigger
    // a TRUE value.
    //
    if (m_fActive)
        {
        return FALSE;
        }

    // CASE 1
    // After the DEFAULT_CLEANUP_WAIT period, it is OK to cleanup this list.
    //
    if ((dwCurrentTime > m_dwTimeStamp) &&
        (dwCurrentTime - m_dwTimeStamp) > DEFAULT_CLEANUP_WAIT)
        {
        return TRUE;
        }

    // CASE 2, the value returned from GetTickCount() gets wraped, needs to take care
    // the special condition.
    //
    if ((dwCurrentTime < m_dwTimeStamp) &&
        ((dwCurrentTime - 0) + (0xFFFFFFFF - m_dwTimeStamp) > DEFAULT_CLEANUP_WAIT))
        {
        return TRUE;
        }

    return FALSE;
    }//CWamInfoOutProc::FTimeToCleanup


/*-----------------------------------------------------------------------------
CWamInfoOutProc::CWamInfoOutProc

Arguments:
pstrMetabasePath    [in]    a pointer to Metabase Path.
fInProcess          [in]    in-proc/out-proc    // remote is not a choice
fEnableTryExcept    [in]    enable try/except flag
clsidWam            [in]    the WAM CLSID

-----------------------------------------------------------------------------*/
CWamInfoOutProc::CWamInfoOutProc
(
IN const STR &strMetabasePath,
IN BOOL fInProcess,
IN BOOL fInPool,
IN BOOL fEnableTryExcept,
IN REFGUID clsidWam,
IN DWORD dwThreshold,
IN PW3_SERVER_INSTANCE pwsiInstance,
IN BOOL fJobEnabled,
IN DWORD dwPeriodicRestartRequests,
IN DWORD dwPeriodicRestartTime,
IN DWORD dwShutdownTimeLimit
)
:
    CWamInfo(strMetabasePath, fInProcess, fInPool, fEnableTryExcept, clsidWam),
    m_fInRepair(FALSE),
    m_fNoMoreRecovery(FALSE),
    m_hPermitOOPEvent((HANDLE)NULL),
    m_dwThreshold(dwThreshold),
    m_dwWamVersion(0),
    m_cRecoverList(0),
    m_idScheduled(0),
    m_pCurrentListHead(NULL),
    m_pwsiInstance(pwsiInstance),
    m_fJobEnabled(fJobEnabled)
    {
    InitializeListHead(&m_rgRecoverListHead);
    INITIALIZE_CRITICAL_SECTION(&m_csList);
    m_cMaxRequests = dwPeriodicRestartRequests;
    m_dwRecycleTime = dwPeriodicRestartTime;
    m_dwShutdownTimeLimit = dwShutdownTimeLimit;
    }


/*-----------------------------------------------------------------------------
CWamInfoOutProc::~CWamInfoOutProc
Destructor for CWamInfoOutProc
-----------------------------------------------------------------------------*/
CWamInfoOutProc::~CWamInfoOutProc
(
VOID
)
    {
    DBG_ASSERT(IsListEmpty(&m_rgRecoverListHead));
    DBG_ASSERT(m_hPermitOOPEvent == (HANDLE)NULL);
    DeleteCriticalSection(&m_csList);
    }//CWamInfoOutProc::~CWamInfoOutProc


/*-----------------------------------------------------------------------------
CWamInfoOutProc::InitOutProc

Init the CWamInfoOutProc data structure.

Argument:
fRepair         - TRUE, if Init() is called to recreate an WAM after a OOP crash

Return:
HRESULT
-----------------------------------------------------------------------------*/
HRESULT
CWamInfoOutProc::Init
(
IN WCHAR* wszPackageId,
IN DWORD  pidInetInfo
)
    {
    HRESULT hr = NOERROR;
    COOPWamReqList *pList = NULL;

    //
    //  Init a COOPWamReqList for the first OOP Wam instance.
    //
    pList = new COOPWamReqList();
    if (NULL == pList)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
        }
    else
        {
        //
        // Insert to Tail of the LinkList, this action usually is done inside
        // of a CS, however, since this is the Init time, it is already in a CS,
        // there could only be one thread doing the Init part of CWamInfoOutProc.
        // therefore, no CS is needed.
        //
        LockList();
        InsertTailList(&m_rgRecoverListHead, &(pList->m_leRecoverListLink));
        m_pCurrentListHead = &(pList->m_leOOPWamReqListHead);
        m_cRecoverList++;
        UnLockList();
        }

    hr = CWamInfo::Init(wszPackageId, pidInetInfo);

    if (SUCCEEDED(hr))
        {
        if (m_fJobEnabled)
            {
            DBG_ASSERT(m_pwsiInstance != NULL && m_pProcessEntry->QueryProcessId() != NULL);
            m_pwsiInstance->AddProcessToJob(m_pProcessEntry->QueryProcessHandle(), TRUE);        
            }
                
        //
        // m_hPermitOOPEvent can served as m_fInited.
        //
        m_hPermitOOPEvent = IIS_CREATE_EVENT(
                                "CWamInfoOutProc::m_hPermitOOPEvent",
                                this,
                                TRUE,
                                TRUE
                                );
        if (NULL == m_hPermitOOPEvent)
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

    //
    // If either CWamInfo::Init or Create Event failed, we need to
    // remove the pList from CleanupListHead.
    //
    if (FAILED(hr) && pList)
        {
        RemoveHeadList(&m_rgRecoverListHead);
        delete pList;
        pList = NULL;
        m_cRecoverList--;
        }

    return hr;
    }//CWamInfoOutProc::Init

/*-----------------------------------------------------------------------------
CWamInfoOutProc::UnInit

Phase 2 of shutdown process.
Uninit the CWamInfoOutProc data structure.

Argument:
VOID

Return:
HRESULT
-----------------------------------------------------------------------------*/
HRESULT
CWamInfoOutProc::UnInit
(
void
)
    {
    HRESULT hr = NOERROR;

    hr = CWamInfo::UnInit();

    FinalCleanup();
 
    if (m_hPermitOOPEvent)
        {
        CloseHandle(m_hPermitOOPEvent);
        m_hPermitOOPEvent = (HANDLE)NULL;
        }
        
    return hr;
    }//CWamInfoOutProc::UnInit

/*-----------------------------------------------------------------------------
CWamInfoOutProc::ClearMembers

Clears the members that are not cleared by unit, so that
it can be reused after a CPU Pause.

Return:
HRESULT
-----------------------------------------------------------------------------*/
VOID
CWamInfoOutProc::ClearMembers()
{
    CWamInfo::ClearMembers();
    m_cRecoverList = 0;
}

/*-----------------------------------------------------------------------------
CWamInfo::LoopWaitForActiveRequests

Loop wait until all active requests are gone.  Upon return from this call, there
should be no more active requests for this WamInfo.

Return:
HRESULT
-----------------------------------------------------------------------------*/
void
CWamInfoOutProc::LoopWaitForActiveRequests
(
INT cIgnoreRefs
)
    {
    INT     cCount = 0;
    BOOL    fWaitforActiveReq = TRUE;
    BOOL    fDidForceKill = FALSE;
    BOOL    fForceRequestCleanup;

    //
    // No need to unlock/lock the OOPWamRequestList in order to check list is empty or not.
    //
    while(m_pCurrentListHead && fWaitforActiveReq)
        {
        if (IsListEmpty(m_pCurrentListHead))
            {
            fWaitforActiveReq = FALSE;
            }
            
        Sleep(20);

        cCount++;
        // 2 sec = 20 ms * 100 times 
        if (cCount > 100 && fDidForceKill == FALSE)
            {
            BOOL fRet;
            UINT uExitCode = 0;
            fRet = TerminateProcess(m_pProcessEntry->QueryProcessHandle(), uExitCode);
            if (!fRet)
                {
                DBGPRINTF((DBG_CONTEXT, "Unable to TerminateProcess, error %d\n", GetLastError()));
                }
            fDidForceKill = TRUE;

            // 
            // Walk the list of current WAM_REQUESTs
            //
            
            while(!IsListEmpty(m_pCurrentListHead)) 
                {

                LockList();

                LIST_ENTRY * ple = RemoveHeadList(m_pCurrentListHead);
                DBG_ASSERT(ple);
                
                WAM_REQUEST * pWamRequest = CONTAINING_RECORD(
                                                ple,
                                                WAM_REQUEST,
                                                m_leOOP);

                // Completely disassociate this wamreq from the list before
                // leaving the critical section.
                InitializeListHead( &pWamRequest->m_leOOP );                

                // Is wamreq about to be cleaned up by itself?
                fForceRequestCleanup = 
                    !( pWamRequest->InterlockedNonZeroAddRef() == 0 );

                UnLockList();

                if( fForceRequestCleanup )
                    {
                    //
                    // Invalidate any references that COM might have
                    //
                
                    CoDisconnectObject( static_cast<IWamRequest *>(pWamRequest), NULL );

                    //
                    // This triggers WAM_REQUEST destructor
                    //
                
                    pWamRequest->Release();
                    }

                }
                
            fWaitforActiveReq = FALSE;
            }
        }
    } // CWamInfoOutProc::LoopWaitForActiveRequests


/*-----------------------------------------------------------------------------
CWamInfoOutProc::EnterOOPZone

Enter the OOP Zone.  If there is a WAM crash-recovery in place, the newer coming requests are blocked
until the new WAM construction finished.  And after the number of crashes reaches a threshold, the
function will assigned a NULL pointer to IWam return value. Means WamInfoOutProc will no longer serve
any new requests.

Parameter:
pWamRequest        a pointer to WamRequest.
pdwWamVersion      pointer to a DWORD buffer holds the current WamVersion upon return.
fRecord            TRUE, add WamRequest to the Current OOPWamReqList.
                   FALSE, no-op.
NOTE:
EnterOOPZone is called by ProcessAsyncIO().  However, the time a WamRequest in the ProcessAsynIO() call,
the WamRequest is already recorded on the OOPWamRequest, therefore, there is no need to add the WamRequest
to OOPWamRequest again.
-----------------------------------------------------------------------------*/
IWam *
CWamInfoOutProc::EnterOOPZone
(
WAM_REQUEST * pWamRequest,
DWORD *pdwWamVersion,
BOOL fRecord
)
    {
    IWam *  pIWam = NULL;

    //
    // In Repair()
    // We first ReSet the PermitOOPEvent, and then raise the flag.
    // Therefore, if m_fInRepair, all incoming threads will now wait.
    //
LWait:
    if (m_fInRepair)
        {
        DWORD dwReturn = WaitForSingleObject(m_hPermitOOPEvent, INFINITE);
        DBG_ASSERT(dwReturn == WAIT_OBJECT_0);
        }

    LockList();
    if (m_fInRepair)
        {
        UnLockList();
        goto LWait;
        }
    else
        {
        if (!FExceedCrashLimit() && !m_fShuttingDown)
            {
            if (fRecord)
                {
                InsertHeadList(m_pCurrentListHead, &pWamRequest->m_leOOP);
                }

            //
            // get thread-valid IWam (see #122711)
            //
            DBG_ASSERT( m_dwIWamGipCookie != NULL_GIP_COOKIE );

            if( FAILED( g_GIPAPI.Get( m_dwIWamGipCookie, IID_IWam, (void **)&pIWam )))
                {
                //
                // bad news - GIP refused to provide a pointer
                // we'll let higher levels to deal with it and return NULL here
                //
                pIWam = NULL;

                }
            *pdwWamVersion = m_dwWamVersion;
            }
        else
            {
            if (fRecord)
                {
                InitializeListHead(&pWamRequest->m_leOOP);
                }
            pIWam = NULL;
            *pdwWamVersion = m_dwWamVersion;
            }
        }
    UnLockList();

    //DBG_ASSERT(pIWam != NULL);

    return pIWam;
    } //CWamInfo::EnterOOPZone

/*-----------------------------------------------------------------------------
CWamInfoOutProc::LeaveOOPZone
Leave OOP zone.  take itself from the OOPWamReqList.

Parameter:
pWamRequest     a pointer to a WamRequest that is going to be taken out from OOPWamReqList.
fRecord         FALSE, NO-OP.  Please see comments in EnterOOPZone.
                FALSE, only used in ProcessAsyncIO.

Note:
-----------------------------------------------------------------------------*/
VOID
CWamInfoOutProc::LeaveOOPZone
(
WAM_REQUEST * pWamRequest,
BOOL fRecord
)
{
    if (fRecord)
    {
        //
        // Remove the wamreq from the list of active requests
        //
        LockList();

        if (!IsListEmpty(&pWamRequest->m_leOOP))
        {
            RemoveEntryList(&pWamRequest->m_leOOP);
        }
        InitializeListHead(&pWamRequest->m_leOOP);

        UnLockList();
    }

    return;
}

HRESULT CWamInfoOutProc::PreProcessWamRequest
(
IN  WAM_REQUEST*    pWamRequest,
IN  HTTP_REQUEST*   pHttpRequest,
OUT IWam **         ppIWam,
OUT BOOL *          pfHandled
)
    {
    DWORD   dwVersion = 0;
    HRESULT hrReturn = NOERROR;
    IWam*   pIWam = NULL;
    BOOL    fFinished;


    DBG_ASSERT(pWamRequest);

    pIWam = EnterOOPZone(pWamRequest, &dwVersion, TRUE);

    // stamp the wamreq with wam's current version
    pWamRequest->SetWamVersion( dwVersion );

    if (NULL == pIWam)
        {
        // We reach this state only if we exceed the crash limit.
        DBG_ASSERT(FExceedCrashLimit());

        //
        //  write log message for the failed wam request
        //
        if ( !pWamRequest->IsChild() )
        {
            pWamRequest->WriteLogInfo(
                SZ_FAILED_OOP_EXCEEDED_CRASH_LOG_MESSAGE,
                HT_SERVER_ERROR,
                RPC_S_CALL_FAILED);
    
            pHttpRequest->Disconnect(
                HT_SERVER_ERROR,
                IDS_WAM_NOMORERECOVERY_ERROR,
                TRUE,
                &fFinished);
        }

        DBGPRINTF((DBG_CONTEXT, "Exceed crash limit, Wam Request %08x quits\n",
                        pWamRequest));

        *pfHandled = TRUE;

        hrReturn = HRESULT_FROM_WIN32( RPC_S_CALL_FAILED );
        }

    *ppIWam = pIWam;
    return hrReturn;
    }//CWamInfoOutProc::PreProcessRequest


HRESULT
CWamInfoOutProc::PostProcessRequest
(
IN  HRESULT         hrIn,
IN  WAM_REQUEST *   pWamRequest
)
    {
    // 1> If the OOP call failed during the call, RPC returns RPC_S_CALL_FAILED.
    // ie. OOP process crashed during the call
    // 2> If OOP process crashed before the call, RPC returns RPC_S_CALL_FAILED_DNE.
    //
    // Subsequest requests to the crashed OOP Process will get RPC_S_SERVER_UNAVAILABLE.
    //
    if (RPC_S_CALL_FAILED == WIN32_FROM_HRESULT(hrIn) ||
        RPC_S_CALL_FAILED_DNE == WIN32_FROM_HRESULT(hrIn) ||
        RPC_S_SERVER_UNAVAILABLE == WIN32_FROM_HRESULT(hrIn))
        {
        const BOOL  F_INRECOVERY = TRUE;
        const BOOL  F_HEALTHY = FALSE;
        HRESULT hrCleanup;

        DBGPRINTF((
            DBG_CONTEXT
            , "CWamInfoOutProc(%08x) "
              "calling CoDisconnectObject on pWamRequest(%08x)\n"
            , this
            , pWamRequest
        ));
        
        //
        //  write log message for the failed wam request
        //
        if (pWamRequest && !pWamRequest->IsChild() )
            {
            DWORD dwHTHeader = (!m_fShuttingDown) ? HT_SERVER_ERROR : HT_SVC_UNAVAILABLE;

            pWamRequest->DisconnectOnServerError(dwHTHeader, WIN32_FROM_HRESULT(hrIn));
            pWamRequest->WriteLogInfo(
                SZ_FAILED_OOP_REQUEST_LOG_MESSAGE,
                dwHTHeader,
                WIN32_FROM_HRESULT(hrIn));
            }

        hrCleanup = CoDisconnectObject( 
            static_cast<IWamRequest *>(pWamRequest), 
            NULL
            );
            
        DBG_ASSERT(hrCleanup == S_OK);

        if (F_INRECOVERY == (BOOL)g_pfnInterlockedCompareExchange(
                        (LONG *)&m_fInRepair,
                        (LONG)F_INRECOVERY,
                        (LONG)F_HEALTHY))
            {
            // Other thread already doing the recovery job.
            DBGPRINTF((DBG_CONTEXT, "Recovery mode: Other thread is doing recovery job.\n"));

            //exit this function
            return hrIn;
            }

        //
        // Try to Repair(call repair function).  But other thread might already working on the repairing
        // Therefore, this thread will return immediately if repairing is in-place.
        // Forget about pWamRequest->Release(), whoever(thread) doing the repairing job will call
        // self-destruction on the pWamRequest.
        //
        Repair();
            
        
        if (F_HEALTHY == (BOOL)g_pfnInterlockedCompareExchange(
                        (LONG *)&m_fInRepair,
                        (LONG)F_HEALTHY,
                        (LONG)F_INRECOVERY))
            {
            // Other thread already doing the recovery job.
            DBG_ASSERT(FALSE);
            }

        return hrIn;
        }

    return NOERROR;
    }// CWamInfoOutProc::PreProcessRequest


/*-----------------------------------------------------------------------------

-----------------------------------------------------------------------------*/
HRESULT CWamInfoOutProc::PreProcessAsyncIO
(
IN  WAM_REQUEST*    pWamRequest,
OUT IWam **         ppIWam
)
    {
    HRESULT hr = S_OK;
    IWam*   pIWam = NULL;
    DWORD dwVersion;

    pIWam = EnterOOPZone(pWamRequest, &dwVersion, FALSE);

    if (dwVersion > pWamRequest->GetWamVersion())
        {
        // reject the request if current wam version is later
        // than wam version when request began
        DBGPRINTF(( DBG_CONTEXT,
                    "CWamInfoOutProc::ProcessAsyncIO  - Crashed since request was started. "
                    "Wam Request %08x quits\n",
                    pWamRequest));
        hr = HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE);   // UNDONE better return code?
        }
    else
        {
        if (NULL == pIWam)
            {

            // We reach this state if we exceed the crash limit
            // or if we failed to obtain thread-valid pointer from GIP
            // note that higher levels rely on hr and *don't* check the pointer

            DBG_ASSERT(FExceedCrashLimit());
            DBGPRINTF((DBG_CONTEXT, "Exceed crash limit, Wam Request %08x quits\n",
                            pWamRequest));
            hr = HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE);
            }
        }

    *ppIWam = pIWam;
    return hr;
    }


/*-----------------------------------------------------------------------------
CWamInfoOutProc::Repair

This is the recovery function.  And this function refused to repair the WAM if the crashes exceed a
threshold.

-----------------------------------------------------------------------------*/
HRESULT
CWamInfoOutProc::Repair
(
VOID
)
    {
    HRESULT         hr = NOERROR;
    COOPWamReqList* pNewList = NULL;
    BOOL            fExceedCrashLimit;  // flag indicates we exceed crash limit or not this time

    //
    // Step 1.  ReSet FinishRecoveryEvent to UnSignaled State.
    //
    //DBG_ASSERT( m_pProcessEntry );
    if ( m_pProcessEntry )
        {
        m_pProcessEntry->NotifyCrashed();
        }

    ResetEvent(m_hPermitOOPEvent);

    if (m_dwState == WIS_SHUTDOWN || m_dwState == WIS_CPUPAUSE)
        {
        //LockList();
        //m_pCurrentListHead = NULL;
        //UnLockList();
        //
        // Set Event, so that let all other wait threads go
        //
        SetEvent(m_hPermitOOPEvent);
        goto LExit;
        }

    //
    //  Make sure m_pCurrentListHead is a valid one.
    //
    DBG_ASSERT(m_pCurrentListHead);

    //
    // Step 2. Call CleanupAll to release any empty(or timedout) OOPWamReqList
    // resources.  Note: CleanupAll does not touch the list pointed by m_pCurrentListHead.
    //
    //
    CleanupAll(FALSE);

    DBGPRINTF((DBG_CONTEXT, "Application %s(%08x) currently has %d OOPWamReqLists, %d crashes, m_pCurrentListHead %08x\n",
                m_strApplicationPath.QueryStr(),
                this,
                m_cRecoverList,
                m_dwWamVersion+1,
                m_pCurrentListHead
                ));

    //
    // Step 3: Create a new OOPWamReqList, and update m_pCurrentListHead to it.
    //
    LockList();
    COOPWamReqList *pCleanupList;
    pCleanupList = CONTAINING_RECORD(m_pCurrentListHead, COOPWamReqList, m_leOOPWamReqListHead);

    //
    // if the CurrentList is empty, then, it is OK to remove the OOPWamReqList pointed
    // by CurrentListHead.  Done this step in a CriticalSection.  That is, you can only
    // access OOPWamReqList in a CS.
    //
    if (IsListEmpty(m_pCurrentListHead))
        {
        RemoveEntryList(&pCleanupList->m_leRecoverListLink);
        InterlockedDecrement((LPLONG)&m_cRecoverList);
        delete pCleanupList;
        }
    else
        {
        DBG_ASSERT(pCleanupList != NULL);
        pCleanupList->SetTimeStamp();
        }

    // m_pCurrentListHead is invalid until reassigned a new OOPList later.

    //
    // If WamInfoOutProc has already reach the OOPWamReqList resource threshould.
    //
    fExceedCrashLimit = FExceedCrashLimit();

    //
    // If we did not exceed the crash limit, then, it is OK to add another OOPWamReqList.
    //
    if (!fExceedCrashLimit)
        {
        InterlockedIncrement((LPLONG)&m_dwWamVersion);
        //
        // Alloc a new CleanupList resource
        //
        pNewList = new COOPWamReqList();
        if (pNewList != NULL)
            {
            InsertTailList(&m_rgRecoverListHead, &(pNewList->m_leRecoverListLink));
            InterlockedIncrement((LPLONG)&m_cRecoverList);
            //
            // Activate new OOPWamReq List.
            //
            m_pCurrentListHead = &pNewList->m_leOOPWamReqListHead;
            }
        else
            {
            //
            // Find out exact what error cause new operation to fail
            //
            m_pCurrentListHead = NULL;
            hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

    UnLockList();

    //
    // Step 3.  Wam is bad. Recreate the wam.
    //

    if (SUCCEEDED(hr) && !fExceedCrashLimit)
        {
        DBG_ASSERT(m_pCurrentListHead);

        hr = ReInitWam();

        if (FAILED(hr))
            {
            // If ReInitWam failed, then, we can assume there is some thing went really wrong,
            // We will treate the application as it exceeds the crash limit.
            LockList();
            m_fNoMoreRecovery = TRUE;
            m_pCurrentListHead = NULL;
            UnLockList();

            DBGPRINTF((DBG_CONTEXT, "Application %s(%08x) Fail to ReInitWam() in Repair, hr = %08x\n",
                m_strApplicationPath.QueryStr(),
                this,
                hr));
            }
        }

    // Assert that either hr succeeded or list head is null
    DBG_ASSERT( SUCCEEDED(hr) || (m_pCurrentListHead == NULL) );

    fExceedCrashLimit = FExceedCrashLimit();
    //
    // Set Event, so that let all other wait threads go
    //
    SetEvent(m_hPermitOOPEvent);

    //
    //  Log the crash.
    //
    const CHAR  *pszEventLog[1];

    pszEventLog[0] = m_strApplicationPath.QueryStr();
    // Event log
    g_pInetSvc->LogEvent(W3_EVENT_OOPAPP_VANISHED,
                        1,
                        pszEventLog,
                        0);

    //
    //  Crash control.  If the OOP Server keeps crashing, it's a waste of computer resource
    //  to rebuild a ill-formed ISAPI DLL.  Therefore, we will stop to service this WAMINFO
    //  and log our decision in the eventlog.
    if (fExceedCrashLimit)
        {
        // Event log
        g_pInetSvc->LogEvent(W3_EVENT_NO_MORE_CRASH,
                            1,
                            pszEventLog,
                            0);
        }

LExit:
    return hr;
    }


/*-----------------------------------------------------------------------------
CWamInfoOutProc::Cleanup
Clean up all wamrequests in a OOPWamRequestList.  call WamRequest Self Destruction fuction directly.

Argument:
pCleanupList:     a pointer to COOPWamRequestList.
-----------------------------------------------------------------------------*/
BOOL
CWamInfoOutProc::Cleanup
(
COOPWamReqList*   pCleanupList
)
    {
    PLIST_ENTRY     ple = NULL;
    WAM_REQUEST*    pWamRequest = NULL;
    BOOL            fFoundEntry = TRUE;

    // Always try to clean up any requests in the list.
    while (fFoundEntry)
        {
        LockList();
        if (!IsListEmpty(&(pCleanupList->m_leOOPWamReqListHead)))
            {
            ple = RemoveHeadList(&(pCleanupList->m_leOOPWamReqListHead));

            DBG_ASSERT(ple);
            pWamRequest = CONTAINING_RECORD(
                    ple,
                    WAM_REQUEST,
                    m_leOOP);

            // Completely disassociate the wamreq from this list before
            // we leave this critical section.
            InitializeListHead( &pWamRequest->m_leOOP );

            if (0 == pWamRequest->InterlockedNonZeroAddRef())
                {
                // Last reference to wamreq is gone, so cleanup is already
                // happening

                UnLockList();
                continue;
                }
            }
        else
            {
            fFoundEntry = FALSE;
            }
        UnLockList();

        if (fFoundEntry)
            {
            HRESULT hr;

            if ( !pWamRequest->IsChild() )
            {
                pWamRequest->WriteLogInfo(
                        SZ_FAILED_OOP_REQUEST_LOG_MESSAGE,
                        HT_SERVER_ERROR,
                        E_FAIL);
            }

            //
            // Assume all the requests in the stage is only refed by COM.
            hr = CoDisconnectObject(
                static_cast<IWamRequest *>(pWamRequest), 
                NULL
                );
            pWamRequest->Release();
            }
        }

    // Got to assert pCleanupList is cleaned.
    DBG_ASSERT(IsListEmpty(&(pCleanupList->m_leOOPWamReqListHead)));

    return TRUE;
    }

/*-----------------------------------------------------------------------------
CWamInfoOutProc::CleanupAll

This function goes through the CleanupLists.  It skips the current OOP list during the walk through,
If an CleanupList's timestamp indicates it is ready to cleanup, it triggers a cleanup of WAMREQUESTs in
that list.  After the cleanup, the CleanupList will be removed from the linklist of CleanupList.

If a Cleanuplist contains no WAMREQUEST, this function will remove the CleanupList from the
linklist of CleanupList.

Parameter:
fScheduled:     TRUE if the function is called in a scheduler.
                FALSE, otherwise.

return:
BOOL

Note:

This function does not touch the CleanupList pointed by m_pCurrentListHead.
-----------------------------------------------------------------------------*/
BOOL
CWamInfoOutProc::CleanupAll
(
BOOL fScheduled
)
    {
    BOOL            fReturn = TRUE;
    PLIST_ENTRY     pTemp = NULL;
    COOPWamReqList* pCleanupList = NULL;
    DWORD           dwCurrentTime = GetTickCount();
    LIST_ENTRY      rgCleanupListHead;

    InitializeListHead(&rgCleanupListHead);

    DBG_CODE
        (
        DWORD cnt = 0;
        );

    LockList();

    pTemp = (&m_rgRecoverListHead)->Flink;

    while (pTemp != &m_rgRecoverListHead)
        {
        DBG_ASSERT(pTemp != NULL);
        pCleanupList = CONTAINING_RECORD(pTemp, COOPWamReqList, m_leRecoverListLink);
        pTemp = pTemp->Flink;
        //
        // Skip the Current Active list.  A rare case when called from a Scheduler,
        // the m_pCurrentListHead gets changed during the loop, in that case, we just
        // have more than 2 LinkLists after the loop, therefore, a Cleanup will be scheduled
        // again.
        //
        if (IsListEmpty(&pCleanupList->m_leOOPWamReqListHead) && !pCleanupList->FActive())
            {
            //
            // pCleanupList record can be released.
            // If pCleanupList is active, move on to the next Link.
            // Otherwise, the list needs to be cleaned.
            //
            RemoveEntryList(&pCleanupList->m_leRecoverListLink);
            InterlockedDecrement((LPLONG)&m_cRecoverList);
            delete pCleanupList;
            }
        else if(pCleanupList->FTimeToCleanup(dwCurrentTime))
            {
            //
            // pCleanupList is timedout, therefore, it is ok to clean all WamRequests
            // in that list and then remove the list.
            //
            //
            RemoveEntryList(&pCleanupList->m_leRecoverListLink);
            InterlockedDecrement((LPLONG)&m_cRecoverList);
            InsertTailList(&rgCleanupListHead, &pCleanupList->m_leRecoverListLink);
            }
        else
            {// No Op. Keep the list there.
            }
        }

    if (fScheduled)
        {
        //
        // There are some cleanup list other than the current active list,
        // therefore, need to schedule another work item.
        //
        if (m_cRecoverList > 1)
            {
            m_idScheduled = ScheduleWorkItem
                            (
                            CWamInfoOutProc::CleanupScheduled,
                            (VOID *)this,
                            DEFAULT_CLEANUP_WAIT,
                            FALSE
                            );
            DBG_ASSERT(m_idScheduled != 0);
            if (m_idScheduled == 0)
                {
                fReturn = FALSE;
                }
            }
        else
            {
            //
            // otherwise, no more to cleanup. Since this is called from Scheduled thread,
            // therefore, m_pCurrentListHead is a valid OOP List head.  Then, cleanup list
            // count == 1 tells us no other cleanup lists need to be cleanup. reset the
            // scheduled id to be 0.
            //
            m_idScheduled = 0;
            }
        }
    else
        {
        //
        // If this is called right after a crash, then, we need to check
        // if there is not scheduled workitem and there are some wam requests on
        // the current OOPList, we need to schedule a workitem.
        //
        if (m_idScheduled == 0 && !IsListEmpty(m_pCurrentListHead))
            {
            m_idScheduled = ScheduleWorkItem
                            (
                            CWamInfoOutProc::CleanupScheduled,
                            (VOID *)this,
                            DEFAULT_CLEANUP_WAIT,
                            FALSE
                            );

            DBG_ASSERT(m_idScheduled != 0);
            if (m_idScheduled == 0)
                {
                fReturn = FALSE;
                }
            }
        }

    UnLockList();

    //
    // Cleanup the lists.
    //
    while (!IsListEmpty(&rgCleanupListHead))
        {
        pTemp = RemoveHeadList(&rgCleanupListHead);
        pCleanupList = CONTAINING_RECORD(pTemp, COOPWamReqList, m_leRecoverListLink);

        Cleanup(pCleanupList);
        delete pCleanupList;

        DBG_CODE(cnt++;);
        }

    DBG_CODE
        (
        DBGPRINTF((DBG_CONTEXT, "Application %s(%08x) CleanupAll cleaned up %d list(s), idScheduled %d, m_cRecoverList %d\n",
            m_strApplicationPath.QueryStr(),
            this,
            cnt,
            m_idScheduled,
            m_cRecoverList));
        );

    return fReturn;
    }


/*-----------------------------------------------------------------------------
CWamInfoOutProc::FinalCleanup

Cleanup function called at Shutdown.  It cancelled any out-standing scheduled workitem.  And do the
clean up itself.

Argument:
None.

-----------------------------------------------------------------------------*/
BOOL
CWamInfoOutProc::FinalCleanup(VOID)
    {
    DWORD           cList = m_cRecoverList;       // Count of CleanupList in the WamInfo.
    COOPWamReqList* pList = NULL;
    PLIST_ENTRY     ple = NULL;

    if (0 != m_idScheduled)
        {
        //
        // Still have out-standing Scheduled cleanup work item.
        // Remove the scheduled cleanup work item here.
        // And let me clean up.
        //
        DWORD   dwOldCookie = m_idScheduled;
        BOOL    fRemoved;

        fRemoved = RemoveWorkItem(dwOldCookie);
        if (fRemoved)
            {
            //  The Work Item is removed.
            //  This thread is going to clean up.
            InterlockedExchange((LPLONG)&(m_idScheduled), 0);
            }
        else
            {
            DWORD dwErr = GetLastError();
            DBGPRINTF((DBG_CONTEXT, "Application %s(%08x) failed to removeWorkItem(%d), ErrCode %d\n",
                        m_strApplicationPath.QueryStr(),
                        this,
                        m_idScheduled,
                        dwErr));
            DBG_ASSERT(FALSE);
            }
        }

    //
    // Walk through the cleanuplist head list, remove all cleanup list.
    //
    while(!IsListEmpty(&m_rgRecoverListHead))
        {
        LockList();
        ple = RemoveHeadList(&m_rgRecoverListHead);
        UnLockList();

        pList = CONTAINING_RECORD(ple, COOPWamReqList, m_leRecoverListLink);

        DBG_ASSERT(pList);


        // No out-standing Scheduled cleanup work item.
        // Verify the list should be clean.
        //
        if ( !(IsListEmpty(&(pList->m_leOOPWamReqListHead))))
            {
            // The List can have some element without a WorkItem Scheduled.
            // A crash happens right after a request finishs OOP operation but before
            // COM releases the request's refs.
            Cleanup(pList);
            }

        //
        // Work Item is already finished.
        // The List should be empty now.
        //
        DBG_ASSERT(IsListEmpty(&(pList->m_leOOPWamReqListHead)));

        delete pList;
        pList = NULL;

        cList--;
        }

    //
    //  cList should be 0 and the ListHead should be empty too.
    //
    DBG_ASSERT(cList == 0 && IsListEmpty(&m_rgRecoverListHead));

    m_cRecoverList = cList;
    m_pCurrentListHead = NULL;
    
    return TRUE;
    }


/*-----------------------------------------------------------------------------
CWamInfoOutProc::CleanupScheduled

Call back function for Cleanup.

Argument:
pContext:   a pointer to COOPWamReqList.(refer to header file for the definition of COOPWamReqList).

-----------------------------------------------------------------------------*/
VOID
CWamInfoOutProc::CleanupScheduled
(
VOID *pContext
)
    {
    CWamInfoOutProc*    pWamInfoOutProc = reinterpret_cast<CWamInfoOutProc*>(pContext);
    DBG_ASSERT(pWamInfoOutProc);

    //
    // Call CleanupAll
    //
    pWamInfoOutProc->CleanupAll(TRUE);

    return;
    }


/*-----------------------------------------------------------------------------
CWamInfoOutProc::ReInit

Reinit a Wam.
Argument:
NONE.

-----------------------------------------------------------------------------*/
HRESULT
CWamInfoOutProc::ReInitWam
(
VOID
)
    {
    HRESULT hr = NOERROR;
    WCHAR  wszPackageId[uSizeCLSIDStr];

    ChangeToState(WIS_REPAIR);
    
    DBG_ASSERT(m_pProcessEntry);
    memcpy(wszPackageId, m_pProcessEntry->QueryPackageId(), sizeof(wszPackageId));

    if (m_pIWam != NULL)
        {
        IWam * pIWam;

        hr = g_GIPAPI.Get(m_dwIWamGipCookie, IID_IWam, (void **) &pIWam);
        if(SUCCEEDED(hr))
           {
           pIWam->UninitWam();
           pIWam->Release();
           }

        hr = g_GIPAPI.Revoke(m_dwIWamGipCookie);

        // balance the AddRef in CWamInfo::Init.
        m_pIWam->Release();
        m_pIWam = NULL;
        }

    // If we got a handle for an Out Of Proc Wam, release it
    if( m_pProcessEntry != NULL)
        {
        g_pWamDictator->m_PTable.RemoveWamInfoFromProcessTable(this);
        m_pProcessEntry = NULL;
        }

    //
    // This Dereference() balanced the AddRef in the old WAM Init time.
    //
    DBGPRINTF((
        DBG_CONTEXT
        , "Dereference CWamInfoOutProc(%08x)\n"
        , this
    ));

    Dereference();

    // Ok. We make a new Wam.
    hr = CWamInfo::Init((WCHAR*)wszPackageId, g_pWamDictator->QueryInetInfoPid());
    if (SUCCEEDED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "ReInited a new Wam. \n"));
        if (m_fJobEnabled)
            {
            DBG_ASSERT(m_pwsiInstance != NULL);
            m_pwsiInstance->AddProcessToJob(m_pProcessEntry->QueryProcessHandle(), TRUE);
            }

        if (SUCCEEDED(hr))
            {
            ChangeToState(WIS_RUNNING);
            }
        }

    // if shtudown process has been started, changed state to STOP_PENDING.
    if (m_fShuttingDown)
        {
        ChangeToState(WIS_SHUTDOWN);
        }
    return hr;
    }

VOID        
CWamInfoOutProc::NotifyGetInfoForName
(
    IN LPCSTR   pszServerVariable
)
{
    DBG_ASSERT( pszServerVariable );

    if( pszServerVariable && *pszServerVariable != '\0' )
    {
        const SV_CACHE_MAP & refSVMap = g_pWamDictator->QueryServerVariableMap();

        DWORD dwOrdinal;
        if( refSVMap.FindOrdinal( pszServerVariable, 
                                  // Could get len on hash
                                  strlen( pszServerVariable ),
                                  &dwOrdinal 
                                  ) )
        {
            m_svCache.SetCacheIt( dwOrdinal );
        }
    }
}

HRESULT 
CWamInfoOutProc::DoProcessRequestCall
(
    IN IWam *           pIWam,
    IN WAM_REQUEST *    pWamRequest,
    OUT BOOL *          pfHandled
)
{
    DBG_ASSERT(pfHandled);
    DBG_ASSERT(pWamRequest);
    DBG_ASSERT(pIWam);

    //
    // Using _alloca to get the core state data is "probably"
    // perfectly safe here. Since this call is heading oop the stack
    // is going to bottom out fairly soon. 
    // 
    // But the core state, in the case of a post or put could be quite 
    // large. and there is currently no bound on the amount of data that
    // could be part of the server variable cache. So we'll use 
    // dwMaxStackAlloc as a threshold for using alloca
    //
    const DWORD dwMaxStackAlloc = (1024 * 4) - sizeof(DWORD);

    BOOL        fHeapAllocCore = FALSE;
    BOOL        fHeapAllocServerVars = FALSE;
    
    HRESULT     hr = NOERROR;
    DWORD       cbWrcStrings;
    DWORD       cbServerVars;
    
    OOP_CORE_STATE  oopCoreState;
    ZeroMemory( &oopCoreState, sizeof(OOP_CORE_STATE) );

    // Copy the current cache list

    SV_CACHE_LIST   svCache( m_svCache );

    SV_CACHE_LIST::BUFFER_ITEM  svCacheItems[SVID_COUNT];
    DWORD                       cCachedServerVariables = SVID_COUNT;

    svCache.GetBufferItems( svCacheItems, &cCachedServerVariables );

    // Get the core state

    WAM_REQ_CORE_FIXED  wrc;
    oopCoreState.cbFixedCore = sizeof( WAM_REQ_CORE_FIXED );
    oopCoreState.pbFixedCore = (LPBYTE)&wrc;


    cbWrcStrings = pWamRequest->CbWrcStrings( m_fInProcess );

    oopCoreState.cbCoreState = WRC_CB_FIXED_ARRAYS + cbWrcStrings;

    if( oopCoreState.cbCoreState > dwMaxStackAlloc )
    {
        fHeapAllocCore = TRUE;
        oopCoreState.pbCoreState = 
            (LPBYTE)LocalAlloc( LPTR, oopCoreState.cbCoreState );

        if( oopCoreState.pbCoreState == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        oopCoreState.pbCoreState = 
            (LPBYTE)_alloca( oopCoreState.cbCoreState );
    }

    if( SUCCEEDED(hr) )
    {
        DBG_ASSERT( oopCoreState.pbCoreState );

        //
        // Load the core state. This will fail if the oop application
        // has died. In this case, the easiest thing to do is to make
        // the call to IWam::Process request with a NULL core state
        // and let the failure get handled back by the normal code path
        //
        hr = pWamRequest->GetCoreState( oopCoreState.cbCoreState,
                                        oopCoreState.pbCoreState,
                                        oopCoreState.cbFixedCore,
                                        oopCoreState.pbFixedCore
                                        );
    }

    // Get the server variable cache data

    if( SUCCEEDED(hr) )
    {
        // Temporarily use a separate buffer for the server variable values
        cbServerVars = pWamRequest->CbCachedSVStrings( 
                                    svCacheItems, 
                                    cCachedServerVariables 
                                    );
        if( cbServerVars )
        {
            DBG_ASSERT( cCachedServerVariables > 0 );

            // Temporarily use a separate buffer 
            oopCoreState.cbServerVarData = cbServerVars;

            if( cbServerVars > dwMaxStackAlloc )
            {
                fHeapAllocServerVars = TRUE;
                oopCoreState.pbServerVarData = 
                    (LPBYTE)LocalAlloc( LPTR, cbServerVars );

                if( oopCoreState.pbServerVarData == NULL )
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                oopCoreState.pbServerVarData = 
                    (LPBYTE)_alloca( cbServerVars );
            }

            if( SUCCEEDED(hr) )
            {
                DBG_ASSERT( oopCoreState.pbServerVarData );

                hr = pWamRequest->GetCachedSVStrings( 
                        oopCoreState.pbServerVarData,
                        oopCoreState.cbServerVarData,
                        svCacheItems,
                        cCachedServerVariables
                        );

                if( SUCCEEDED(hr) )
                {
                    oopCoreState.pbServerVarCache = (LPBYTE)svCacheItems;
                
                    oopCoreState.cbServerVars = 
                        cCachedServerVariables * 
                        sizeof(SV_CACHE_LIST::BUFFER_ITEM);
                }
            }
        }
    }

    OOP_CORE_STATE * pOopCoreState = (SUCCEEDED(hr)) ? &oopCoreState :
                                                       NULL;

    // The last thing we do...
    hr = pIWam->ProcessRequest( pWamRequest,
                                cbWrcStrings,
                                pOopCoreState,
                                pfHandled
                                );
    
    if( fHeapAllocCore && oopCoreState.pbCoreState )
    {
        LocalFree( oopCoreState.pbCoreState );
    }
    if( fHeapAllocServerVars && oopCoreState.pbServerVarData ) 
    {
        LocalFree( oopCoreState.pbServerVarData );
    }

    return hr;
}

HRESULT CWamInfoOutProc::GetStatistics
(
DWORD     Level,
LPWAM_STATISTICS_INFO pWamStatsInfo
)
    {
    HRESULT hr = S_OK;
    IWam*   pIWam = NULL;
    DWORD dwVersion;

    if (!FExceedCrashLimit())
        {
        pIWam = m_pIWam;
        }

    if (NULL == pIWam)
        {
        // We reach this state only if we exceed the crash limit.
        DBG_ASSERT(FExceedCrashLimit());
        hr = HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE);
        }
    else
        {
        hr = pIWam->GetStatistics(0, pWamStatsInfo);

        // 1> If the OOP call failed during the call, RPC returns RPC_S_CALL_FAILED.
        // ie. OOP process crashed during the call
        // 2> If OOP process crashed before the call, RPC returns RPC_S_CALL_FAILED_DNE.
        //
        // Subsequest requests to the crashed OOP Process will get RPC_S_SERVER_UNAVAILABLE.
        //
        if (RPC_S_CALL_FAILED == WIN32_FROM_HRESULT(hr) ||
            RPC_S_CALL_FAILED_DNE == WIN32_FROM_HRESULT(hr) ||
            RPC_S_SERVER_UNAVAILABLE == WIN32_FROM_HRESULT(hr))
            {
            const BOOL  F_INRECOVERY = TRUE;
            const BOOL  F_HEALTHY = FALSE;

            if (F_INRECOVERY == (BOOL)g_pfnInterlockedCompareExchange(
                            (LONG *)&m_fInRepair,
                            (LONG)F_INRECOVERY,
                            (LONG)F_HEALTHY))
                {
                // Other thread already doing the recovery job.
                DBGPRINTF((DBG_CONTEXT, "Recovery mode: Other thread is doing recovery job.\n"));
                hr = NOERROR;

                }

            //
            // Try to Repair(call repair function).  But other thread might already working on the repairing
            // Therefore, this thread will return immediately if repairing is in-place.
            //

            Repair();

            if (F_HEALTHY == (BOOL)g_pfnInterlockedCompareExchange(
                            (LONG *)&m_fInRepair,
                            (LONG)F_HEALTHY,
                            (LONG)F_INRECOVERY))
                {
                // Other thread already doing the recovery job.
                DBG_ASSERT(FALSE);
                }
            }
        }

    return hr;
    }
/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\w3inst.cxx ===
/*++




   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        w3inst.cxx

   Abstract:

        This module defines the W3_SERVER_INSTANCE class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996

--*/

#include "w3p.hxx"

#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

#include <nsepname.hxx>
#include <mbstring.h>
#include <issched.hxx>

#if DBG
#define VALIDATE_HEAP() DBG_ASSERT( RtlValidateProcessHeaps() )
#else
#define VALIDATE_HEAP() 
#endif 

//
//  Constants
//

//
// Globals
//

LPVOID          g_pMappers[MT_LAST] = { NULL, NULL, NULL, NULL };
PFN_SF_NOTIFY   g_pFlushMapperNotify[MT_LAST] = { NULL, NULL, NULL, NULL };
PFN_SF_NOTIFY   g_pSslKeysNotify = NULL;
extern STORE_CHANGE_NOTIFIER *g_pStoreChangeNotifier;

//
//  Prototypes
//


DWORD
InitializeInstances(
    PW3_IIS_SERVICE pService
    )
/*++

Routine Description:

    Reads the instances from the metabase

Arguments:

    pService - Server instances added to.

Return Value:

    Win32

--*/
{
    DWORD   i;
    DWORD   cInstances = 0;
    MB      mb( (IMDCOM*) pService->QueryMDObject() );
    CHAR    szKeyName[MAX_PATH+1];
    DWORD   err = NO_ERROR;
    BUFFER  buff;
    BOOL    fMigrateRoots = FALSE;

    //
    //  Open the metabase for write to get an atomic snapshot
    //

ReOpen:

    if ( !mb.Open( "/LM/W3SVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "InitializeInstances: Cannot open path %s, error %lu\n",
                    "/LM/W3SVC/", GetLastError() ));

        //
        //  If the web service key isn't here, just create it
        //

        if ( !mb.Open( "",
                       METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/W3SVC/" ))
        {
            return GetLastError();
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "/LM/W3Svc not found, auto-created\n" ));

        mb.Close();
        goto ReOpen;
    }

    //
    // Loop through instance keys and build a list.  We don't keep the
    // metabase open because the instance instantiation code will need
    // to write to the metabase
    //

TryAgain:
    i = 0;
    while ( mb.EnumObjects( "",
                            szKeyName,
                            i++ ))
    {
        BOOL fRet;
        DWORD dwInstance;
        CHAR szRegKey[MAX_PATH+1];

        //
        // Get the instance id
        //

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"instance key %s\n",szKeyName));
        }

        dwInstance = atoi( szKeyName );
        if ( dwInstance == 0 ) {
            IF_DEBUG(INSTANCE) {
                DBGPRINTF((DBG_CONTEXT,"invalid instance ID %s\n",szKeyName));
            }
            continue;
        }

        if ( buff.QuerySize() < (cInstances + 1) * sizeof(DWORD) )
        {
            if ( !buff.Resize( (cInstances + 10) * sizeof(DWORD)) )
            {
                return GetLastError();
            }
        }

        ((DWORD *) buff.QueryPtr())[cInstances++] = dwInstance;
    }

    if ( cInstances == 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "No defined instances\n" ));

        if ( !mb.AddObject( "1" ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create first instance, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }

        fMigrateRoots = TRUE; // Force reg->metabase migration of virtual directories
        goto TryAgain;
    }

    DBG_REQUIRE( mb.Close() );

    for ( i = 0; i < cInstances; i++ )
    {
        DWORD dwInstance = ((DWORD *)buff.QueryPtr())[i];
        pService->StartUpIndicateClientActivity();

        if( !g_pInetSvc->AddInstanceInfo( dwInstance, fMigrateRoots ) ) {

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "InitializeInstances: cannot create instance %lu, error %lu\n",
                dwInstance,
                err
                ));

            break;
        }
    }

    return err;

} // InitializeInstances



W3_SERVER_INSTANCE::W3_SERVER_INSTANCE(
        IN PW3_IIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT Port,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszVirtualRootsSecretName,
        IN BOOL   fMigrateRoots
        )
:   IIS_SERVER_INSTANCE(pService,
                        dwInstanceId,
                        Port,
                        lpszRegParamKey,
                        lpwszAnonPasswordSecretName,
                        lpwszVirtualRootsSecretName,
                        fMigrateRoots),

    m_signature                 (W3_SERVER_INSTANCE_SIGNATURE),
    m_fAnySecureFilters         (fAnySecureFilters),
    m_dwUseHostName             (DEFAULT_W3_USE_HOST_NAME ),
    m_pszDefaultHostName        (NULL ),
    m_fAcceptByteRanges         (DEFAULT_W3_ACCEPT_BYTE_RANGES ),
    m_fLogErrors                (DEFAULT_W3_LOG_ERRORS ),
    m_fLogSuccess               (DEFAULT_W3_LOG_SUCCESS ),
#if 0
    m_cbUploadReadAhead         (DEFAULT_W3_UPLOAD_READ_AHEAD ),
#endif
    m_fUsePoolThreadForCGI      (DEFAULT_W3_USE_POOL_THREAD_FOR_CGI ),
    m_pszAccessDeniedMsg        (NULL ),
    m_dwNetLogonWks             (DEFAULT_W3_NET_LOGON_WKS),
    m_cAdvNotPwdExpInDays       (DEFAULT_W3_ADV_NOT_PWD_EXP_IN_DAYS),
    m_dwAdvCacheTTL             (DEFAULT_W3_ADV_CACHE_TTL),
    m_pFilterList               ( NULL ),
    m_fAllowPathInfoForScriptMappings   ( DEFAULT_W3_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS ),
    m_fProcessNtcrIfLoggedOn    ( DEFAULT_W3_PROCESS_NTCR_IF_LOGGED_ON ),
    m_pW3Stats                  ( NULL ),
    m_dwSslCa                   ( 0 ),
    m_dwJobResetInterval        ( DEFAULT_W3_CPU_RESET_INTERVAL ),
    m_tsJobLock                 ( ),
    m_llJobResetIntervalCPU     ( GetCPUTimeFromInterval(DEFAULT_W3_CPU_RESET_INTERVAL) ),
    m_dwJobQueryInterval        ( DEFAULT_W3_CPU_QUERY_INTERVAL ),
    m_dwJobLoggingSchedulerCookie ( 0 ),
    m_dwJobIntervalSchedulerCookie ( 0 ),
    m_dwJobCGICPULimit          ( DEFAULT_W3_CPU_CGI_LIMIT ),
    m_dwJobLoggingOptions       ( DEFAULT_W3_CPU_LOGGING_OPTIONS ),
    m_pwjoApplication           ( NULL ),
    m_pwjoCGI                   ( NULL ),
    m_dwLastJobState            ( MD_SERVER_STATE_STOPPED ),
    m_llJobSiteCPULimitLogEvent ( PercentCPULimitToCPUTime(DEFAULT_W3_CPU_LIMIT_EVENTLOG) ),
    m_llJobSiteCPULimitPriority ( PercentCPULimitToCPUTime(DEFAULT_W3_CPU_LIMIT_PRIORITY) ),
    m_llJobSiteCPULimitProcStop ( PercentCPULimitToCPUTime(DEFAULT_W3_CPU_LIMIT_PROCSTOP) ),
    m_llJobSiteCPULimitPause    ( PercentCPULimitToCPUTime(DEFAULT_W3_CPU_LIMIT_PAUSE) ),
    m_fJobSiteCPULimitLogEventEnabled ( FALSE ),
    m_fJobSiteCPULimitPriorityEnabled ( FALSE ),
    m_fJobSiteCPULimitProcStopEnabled ( FALSE ),
    m_fJobSiteCPULimitPauseEnabled    ( FALSE ),
    m_fCPULoggingEnabled              ( FALSE ),
    m_fCPULimitsEnabled               ( FALSE ),
    m_pSSLInfo                        ( NULL )

{

    DWORD i;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF(( DBG_CONTEXT,
        "Init instance from %s\n", lpszRegParamKey ));
    }

    for ( i = 0 ; i < MT_LAST ; ++i ) {
        m_apMappers[i] = NULL;
    }

    if ( QueryServerState( ) == MD_SERVER_STATE_INVALID ) {
        return;
    }

    //
    // Create statistics object
    //

    m_pW3Stats = new W3_SERVER_STATISTICS();

    if ( m_pW3Stats == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SetServerState(MD_SERVER_STATE_INVALID, ERROR_NOT_ENOUGH_MEMORY);
    }

    return;

} // W3_SERVER_INSTANCE::W3_SERVER_INSTANCE



W3_SERVER_INSTANCE::~W3_SERVER_INSTANCE(
                        VOID
                        )
{
    DWORD i = 0;

    //
    // There seems to be a lag betwenn calling RemoveWorkItem and
    // the last possible call from the scheduler. For now,
    // Just put this at the beginning of the destructor so items
    // will actually get removed before constructor completes.
    //


    if (m_dwJobLoggingSchedulerCookie != 0) {
        RemoveWorkItem( m_dwJobLoggingSchedulerCookie );
    }

    if (m_dwJobIntervalSchedulerCookie != 0) {
        RemoveWorkItem( m_dwJobIntervalSchedulerCookie );
    }

    if ((m_dwJobLoggingSchedulerCookie != 0) ||
        (m_dwJobIntervalSchedulerCookie != 0)) {
        QueryAndLogJobInfo(JOLE_SITE_STOP);
    }

    delete m_pwjoApplication;
    delete m_pwjoCGI;

    //
    // delete statistics object
    //

    if( m_pW3Stats != NULL )
    {
        delete m_pW3Stats;
        m_pW3Stats = NULL;
    }

    //
    //  Free the registry strings.
    //

    CleanupRegistryStrings( );

    if ( m_pszDefaultHostName != NULL ) {
        TCP_FREE(m_pszDefaultHostName);
        m_pszDefaultHostName = NULL;
    }

    if ( m_pFilterList ) {
        FILTER_LIST::Dereference( m_pFilterList );
    }

    UINT iM;
    for ( iM = 0 ; iM < MT_LAST ; ++iM )
    {
        if ( m_apMappers[iM] )
        {
            ((RefBlob*)(m_apMappers[iM]))->Release();
        }
    }
    
    ResetSSLInfo( this );

} // W3_SERVER_INSTANCE::~W3_SERVER_INSTANCE


DWORD
W3_SERVER_INSTANCE::StartInstance()
{
    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "W3_SERVER_INSTANCE::StartInstance called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DWORD dwError = IIS_SERVER_INSTANCE::StartInstance();

    if ( dwError)
    {
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((
                DBG_CONTEXT,
                "W3_SERVER_INSTANCE - IIS_SERVER_INSTANCE Failed. StartInstance returned 0x%x",
                dwError
                ));
        }
        
        return dwError;
    }

    //
    // Read the w3 specfic params
    //

    if ( !ReadPrivateW3Params( ) ) {
        
        DBGERROR(( 
            DBG_CONTEXT,
            "[W3_SERVER_INSTANCE::StartInstance] id(%d) "
            "ReadPrivateW3Params failed\n",
            QueryInstanceId()
            ));
        
        goto error_exit;
    }

    if ( !ReadPublicW3Params( FC_W3_ALL ) ) {

        DBGERROR(( 
            DBG_CONTEXT,
            "[W3_SERVER_INSTANCE::StartInstance] id(%d) "
            "ReadPublicW3Params failed\n",
            QueryInstanceId()
            ));
        
        goto error_exit;
    }

    //
    // Get host name
    //

    InitializeHostName( );

    //
    // Directory browsing
    //

    InitializeDirBrowsing( );

    if ( !CreateFilterList() ) {

        DBGERROR(( 
            DBG_CONTEXT,
            "[W3_SERVER_INSTANCE::StartInstance] id(%d) "
            "CreateFilterList failed\n",
            QueryInstanceId()
            ));
        
        goto error_exit;
    }

    //
    //  Don't listen on the secure port if there aren't any filters to
    //  handle it
    //

    if ( !m_fAnySecureFilters ) {
        LockThisForWrite();
        RemoveSecureBindings();
        UnlockThis();
    }

    DBG_ASSERT(m_pW3Stats);
    m_pW3Stats->UpdateStartTime();


    return ERROR_SUCCESS;

error_exit:

    //
    // We don't know the exact error to set here, as the above functions 
    // that can fail do not SetLastError() consistently.
    //
    
    return (GetLastError() != NO_ERROR) ? GetLastError() : 
                                          ERROR_NOT_ENOUGH_MEMORY;
}


DWORD
W3_SERVER_INSTANCE::StopInstance()
{
    DBG_ASSERT(m_pW3Stats);
    m_pW3Stats->UpdateStopTime();

    return IIS_SERVER_INSTANCE::StopInstance();
}


BOOL
W3_SERVER_INSTANCE::ReadMappers(
    )
/*++

   Description

       Read mappers for this instance

   Arguments:

       None

   Return Value:

       TRUE if successful, FALSE otherwise

   Note :
       Instance must be locked before calling this function

--*/
{
    DWORD               dwR;
    UINT                iM;
    LPVOID              aOldMappers[MT_LAST];
    BOOL                fSt = FALSE;

    //
    // release reference to current mappers
    //

    memcpy( aOldMappers, m_apMappers, MT_LAST*sizeof(LPVOID) );

    for ( iM = 0 ; iM < MT_LAST ; ++iM )
    {
        if ( m_apMappers[iM] )
        {
            ((RefBlob*)(m_apMappers[iM]))->Release();
            m_apMappers[iM] = NULL;
        }
    }

    //
    // Read mappers from Name Space Extension Metabase
    //

    if ( !g_pInetSvc->QueryMDNseObject() )
    {
        return FALSE;
    }

    MB                  mbx( (IMDCOM*) g_pInetSvc->QueryMDNseObject() );

    if ( mbx.Open( QueryMDPath() ) )
    {
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_CERT11_PATH,
                           MD_CPP_CERT11,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_CERT11],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_CERT11] = NULL;
        }
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_CERTW_PATH,
                           MD_CPP_CERTW,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_CERTW],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_CERTW] = NULL;
        }
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_BASIC_PATH,
                           MD_CPP_ITA,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_ITA],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_ITA] = NULL;
        }
        dwR = sizeof(LPVOID);
        if ( !mbx.GetData( NSEPM_DIGEST_PATH,
                           MD_CPP_DIGEST,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           &m_apMappers[MT_MD5],
                           &dwR,
                           0 ) )
        {
            m_apMappers[MT_MD5] = NULL;
        }
        mbx.Close();

        fSt = TRUE;
    }

    //
    // Call notification functions for mappers existence change
    // ( i.e. from non-exist to exist or exist to non-exist )
    //

    if ( (aOldMappers[MT_CERT11] == NULL) != (m_apMappers[MT_CERT11] == NULL)
         && g_pFlushMapperNotify[MT_CERT11] )
    {
        (g_pFlushMapperNotify[MT_CERT11])( SF_NOTIFY_MAPPER_CERT11_CHANGED, this );
    }

    if ( (aOldMappers[MT_CERTW] == NULL) != (m_apMappers[MT_CERTW] == NULL)
         && g_pFlushMapperNotify[MT_CERTW] )
    {
        (g_pFlushMapperNotify[MT_CERTW])( SF_NOTIFY_MAPPER_CERTW_CHANGED, this );
    }

    if ( (aOldMappers[MT_ITA] == NULL) != (m_apMappers[MT_ITA] == NULL)
         && g_pFlushMapperNotify[MT_ITA] )
    {
        (g_pFlushMapperNotify[MT_ITA])( SF_NOTIFY_MAPPER_ITA_CHANGED, this );
    }

    if ( (aOldMappers[MT_MD5] == NULL) != (m_apMappers[MT_MD5] == NULL)
         && g_pFlushMapperNotify[MT_MD5] )
    {
        (g_pFlushMapperNotify[MT_MD5])( SF_NOTIFY_MAPPER_MD5_CHANGED, this );
    }

    return fSt;
}



BOOL
W3_SERVER_INSTANCE::ReadPrivateW3Params(
                        VOID
                        )
/*++

   Description

       Reads reg values not defined in UI

   Arguments:

       fc - Items to read

   Note:

--*/
{
    DWORD   err;
    HKEY    hkey;
    HKEY    hDefkey;
    DWORD   cProv = 0;
    BOOL    fRet = TRUE;
    STR     strProviderList;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    DWORD   dwValue;
    DWORD   i;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey( ),
                        0,
                        KEY_READ,
                        &hkey );

    if ( err != NO_ERROR ) {
        return(TRUE);
    }

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        W3_PARAMETERS_KEY,
                        0,
                        KEY_READ,
                        &hDefkey );

    if ( err != NO_ERROR ) {
        RegCloseKey( hkey );
        return(TRUE);
    }

    LockThisForWrite();

    if ( !ReadMappers() ) {

        //
        // Ignore error for win95
        //

        if ( !g_fIsWindows95 ) {
            DBGPRINTF((DBG_CONTEXT,"Call to ReadMapper failed\n"));
            fRet = FALSE;
            goto exit;
        }
    }

#if 0
    m_fUseHostName = !!ReadRegistryDword( hkey,
                                        W3_DEFAULT_HOST_NAME,
                                        DEFAULT_W3_USE_HOST_NAME);
#endif
    m_fAcceptByteRanges  = !!ReadRegistryDword( hkey,
                                          W3_ACCEPT_BYTE_RANGES,
                                          DEFAULT_W3_ACCEPT_BYTE_RANGES);

    m_fLogErrors = !!ReadRegistryDword( hkey,
                                   W3_LOG_ERRORS,
                                   DEFAULT_W3_LOG_ERRORS );

    m_fLogSuccess = !!ReadRegistryDword( hkey,
                                   W3_LOG_SUCCESS,
                                   DEFAULT_W3_LOG_SUCCESS );


    ReadRegString( hkey,
                   &m_pszAccessDeniedMsg,
                   W3_ACCESS_DENIED_MSG,
                   DEFAULT_W3_ACCESS_DENIED_MSG );

    if ( mb.Open( QueryMDPath() ) )
    {
        mb.GetStr( "",
                   MD_AUTH_CHANGE_URL,
                   IIS_MD_UT_SERVER,
                   &m_strAuthChangeUrl );

        mb.GetStr( "",
                   MD_AUTH_EXPIRED_URL,
                   IIS_MD_UT_SERVER,
                   &m_strAuthExpiredUrl );

        mb.GetStr( "",
                   MD_AUTH_NOTIFY_PWD_EXP_URL,
                   IIS_MD_UT_SERVER,
                   &m_strAdvNotPwdExpUrl );

        mb.GetStr( "",
                   MD_AUTH_EXPIRED_UNSECUREURL,
                   IIS_MD_UT_SERVER,
                   &m_strAuthExpiredUnsecureUrl );

        mb.GetStr( "",
                   MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL,
                   IIS_MD_UT_SERVER,
                   &m_strAdvNotPwdExpUnsecureUrl );

        if ( !mb.GetDword( "",
                           MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,
                           IIS_MD_UT_SERVER,
                           &m_cAdvNotPwdExpInDays ) )
        {
            m_cAdvNotPwdExpInDays = DEFAULT_W3_ADV_NOT_PWD_EXP_IN_DAYS;
        }

        if ( !mb.GetDword( "",
                           MD_CERT_CHECK_MODE,
                           IIS_MD_UT_SERVER,
                           &m_dwCertCheckMode ) )
        {
            m_dwCertCheckMode = 0;
        }

        if ( !mb.GetDword( "",
                           MD_AUTH_CHANGE_FLAGS,
                           IIS_MD_UT_SERVER,
                           &m_dwAuthChangeFlags ) )
        {
            m_dwAuthChangeFlags = 0;
        }

        if ( !mb.GetDword( "",
                           MD_ADV_CACHE_TTL,
                           IIS_MD_UT_SERVER,
                           &m_dwAdvCacheTTL ) )
        {
            m_dwAdvCacheTTL = DEFAULT_W3_ADV_CACHE_TTL;
        }

        if ( !mb.GetDword( "",
                           MD_NET_LOGON_WKS,
                           IIS_MD_UT_SERVER,
                           &m_dwNetLogonWks ) )
        {
            m_dwNetLogonWks = DEFAULT_W3_NET_LOGON_WKS;
        }

        if ( !mb.GetDword( "",
                           MD_USE_HOST_NAME,
                           IIS_MD_UT_SERVER,
                           &m_dwUseHostName ) )
        {
            m_dwUseHostName = DEFAULT_W3_USE_HOST_NAME;
        }

        if ( !mb.GetDword( "",
                           MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS,
                           IIS_MD_UT_SERVER,
                           &dwValue ) )
        {
            m_fAllowPathInfoForScriptMappings = DEFAULT_W3_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS;
        }
        else
        {
            m_fAllowPathInfoForScriptMappings = !!dwValue;
        }

        if ( !mb.GetDword( "",
                           MD_PROCESS_NTCR_IF_LOGGED_ON,
                           IIS_MD_UT_SERVER,
                           &dwValue ) )
        {
            m_fProcessNtcrIfLoggedOn = DEFAULT_W3_PROCESS_NTCR_IF_LOGGED_ON;
        }
        else
        {
            m_fProcessNtcrIfLoggedOn = !!dwValue;
        }

        if ( !mb.GetBuffer( "",
                            MD_SSL_CA,
                            IIS_MD_UT_SERVER,
                            &m_buSslCa,
                            &m_dwSslCa ) )
        {
            m_dwSslCa = 0;
        }

        //
        // Get Job Object Info
        // Constructor initialized these to defaults, so don't need to handle
        // error case. Do need to handle changes;
        //

        if ((!mb.GetDword( NULL,
                         MD_CPU_RESET_INTERVAL,
                         IIS_MD_UT_SERVER,
                         &dwValue )) ||
            (dwValue == 0) )
        {
            //
            // 0 is invalid and could result in a divide by 0 error
            //

            dwValue = DEFAULT_W3_CPU_RESET_INTERVAL;
        }

        if (m_dwJobResetInterval != dwValue)
        {
            m_dwJobResetInterval = dwValue;
            ResetJobResetInterval();
        }

        LockJobsForWrite();

        if (!mb.GetDword( NULL,
                          MD_CPU_LIMITS_ENABLED,
                          IIS_MD_UT_SERVER,
                          &dwValue ))
        {
            dwValue = FALSE;
        }

        if ((BOOL)dwValue != m_fCPULimitsEnabled)
        {

            m_fCPULimitsEnabled = dwValue;

            if (m_fCPULimitsEnabled) {

                //
                // Start the reset interval, completion ports, and limits
                //

                StartJobs();
            }
            else {


                //
                // Start the reset interval, completion ports, and limits
                //

                StopJobs();

            }
        }

        if ((!mb.GetDword( NULL,
                          MD_CPU_LOGGING_INTERVAL,
                          IIS_MD_UT_SERVER,
                          &dwValue )) ||
            (dwValue == 0))
        {
            dwValue = DEFAULT_W3_CPU_QUERY_INTERVAL;
        }

        if (m_dwJobQueryInterval != dwValue)
        {
            m_dwJobQueryInterval = dwValue;
            ResetJobQueryInterval();
        }

        if (!mb.GetDword( NULL,
                          MD_CPU_LOGGING_MASK,
                          IIS_MD_UT_SERVER,
                          &dwValue )) {
            dwValue = DEFAULT_W3_CPU_LOGGING_MASK;
        }

        {
            BOOL fLoggingEnabled =  ((dwValue & MD_CPU_ENABLE_LOGGING) != 0) ? TRUE : FALSE;
            if (m_fCPULoggingEnabled != fLoggingEnabled)
            {
                m_fCPULoggingEnabled = fLoggingEnabled;
                if (m_fCPULoggingEnabled) {

                    //
                    // Start the reset interval, logging interval
                    //

                    StartJobs();
                }
                else {

                    //
                    // Stop the reset interval, logging interval
                    //

                    StopJobs();
                }
            }
        }

        if (mb.GetDword( NULL,
                         MD_CPU_CGI_LIMIT,
                         IIS_MD_UT_SERVER,
                         &dwValue ))
        {
            if (m_dwJobCGICPULimit != dwValue)
            {
                m_dwJobCGICPULimit = dwValue;
                SetJobLimits(SLA_PROCESS_CPU_LIMIT, m_dwJobCGICPULimit);
            }
        }

        mb.GetDword( NULL,
                     MD_CPU_LOGGING_OPTIONS,
                     IIS_MD_UT_SERVER,
                     &m_dwJobLoggingOptions );

        BOOL fLimitsChanged = FALSE;

        if (mb.GetDword( NULL,
                         MD_CPU_LIMIT_LOGEVENT,
                         IIS_MD_UT_SERVER,
                         &dwValue ))
        {
            if (m_llJobSiteCPULimitLogEvent != PercentCPULimitToCPUTime(dwValue))
            {
                m_llJobSiteCPULimitLogEvent = PercentCPULimitToCPUTime(dwValue);
                fLimitsChanged = TRUE;
            }
        }

        if (mb.GetDword( NULL,
                         MD_CPU_LIMIT_PRIORITY,
                         IIS_MD_UT_SERVER,
                         &dwValue ))
        {
            if (m_llJobSiteCPULimitPriority != PercentCPULimitToCPUTime(dwValue))
            {
                m_llJobSiteCPULimitPriority = PercentCPULimitToCPUTime(dwValue);
                fLimitsChanged = TRUE;
            }
        }

        if (mb.GetDword( NULL,
                         MD_CPU_LIMIT_PROCSTOP,
                         IIS_MD_UT_SERVER,
                         &dwValue ))
        {
            if (m_llJobSiteCPULimitProcStop != PercentCPULimitToCPUTime(dwValue))
            {
                m_llJobSiteCPULimitProcStop = PercentCPULimitToCPUTime(dwValue);
                fLimitsChanged = TRUE;
            }
        }

        if (mb.GetDword( NULL,
                         MD_CPU_LIMIT_PAUSE,
                         IIS_MD_UT_SERVER,
                         &dwValue ))
        {
            if (m_llJobSiteCPULimitPause != PercentCPULimitToCPUTime(dwValue))
            {
                m_llJobSiteCPULimitPause = PercentCPULimitToCPUTime(dwValue);
                fLimitsChanged = TRUE;
            }
        }

        if (fLimitsChanged) {
            SetJobSiteCPULimits(TRUE);
        }

        UnlockJobs();

        mb.Close();
    }

#if 0
    m_cbUploadReadAhead = ReadRegistryDword( hkey,
                                     W3_UPLOAD_READ_AHEAD,
                                     DEFAULT_W3_UPLOAD_READ_AHEAD );
#endif

    m_fUsePoolThreadForCGI = !!ReadRegistryDword( hkey,
                                     W3_USE_POOL_THREAD_FOR_CGI,
                                     DEFAULT_W3_USE_POOL_THREAD_FOR_CGI );

exit:
    UnlockThis();

    DBG_REQUIRE( !RegCloseKey( hkey ));
    DBG_REQUIRE( !RegCloseKey( hDefkey ));
    return(fRet);

} // W3_SERVER_INSTANCE::ReadPrivateW3Params



BOOL
W3_SERVER_INSTANCE::ReadPublicW3Params(
    IN FIELD_CONTROL fc
    )

/*++

Routine Description:

   Initializes HTTP parameters from the registry

Arguments:

   fc - Items to read

Return Value:

    TRUE if successful, FALSE on error

--*/

{
#if 0
    DWORD err;
    BOOL  fRet = TRUE;
    HKEY  hkeyW3;

    //
    //  Connect to the registry.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey( ),
                        0,
                        KEY_ALL_ACCESS,
                        &hkeyW3 );

    if( err != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "cannot open registry key, error %lu\n",
                    err ));

        err = NO_ERROR;
    }

    LockThisForWrite();

    //
    //  Read registry data.
    //

    UnlockThis( );
    RegCloseKey( hkeyW3 );

    return fRet;
#endif

    return TRUE;
} // W3_SERVER_INSTANCE::ReadPublicW3Params



BOOL
W3_SERVER_INSTANCE::WritePublicW3Params(
    IN LPW3_CONFIG_INFO pConfig
    )
/*++

   Description

       Updates the registry with the passed parameters

   Arguments:

       pConfig - Items to write to the registry

--*/
{
    DWORD err;
    BOOL  fRet = TRUE;
    HKEY  hkey;
    DWORD disp;

    //
    //  Connect to the registry.
    //

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          QueryRegParamKey(),
                          0,
                          NULL,
                          0,
                          KEY_READ|KEY_WRITE,
                          NULL,
                          &hkey,
                          &disp );

    if( err != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "cannot open registry key, error %lu\n",
                    err ));

        return FALSE;
    }

    //
    //  Write the strings - Note some of these are written for registry
    //  compatiblity with pre-metabase applications
    //

    if ( !err && IsFieldSet( pConfig->FieldControl, FC_W3_DEFAULT_LOAD_FILE )
              && (pConfig->lpszDefaultLoadFile != NULL) )
    {
        err = WriteRegistryStringW( hkey,
                              W3_DEFAULT_FILE_W,
                              pConfig->lpszDefaultLoadFile,
                              (wcslen( pConfig->lpszDefaultLoadFile ) + 1) *
                                   sizeof( WCHAR ),
                              REG_SZ);
    }

    if ( hkey )
        RegCloseKey( hkey );

    if ( err )
    {
        SetLastError( err );
        return FALSE;
    }

    return TRUE;

} // W3_SERVER_INSTANCE::WritePublicW3Params


VOID
W3_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this instance

  Arguments:

    pcoChangeList - path and id that has changed

--*/
{
    DWORD   i;
    BOOL    fFiltersModified = FALSE;
    PCSTR   pszURL;
    DWORD   dwURLLength;
    BOOL    fSslModified = FALSE;

    LockThisForWrite();

    //
    //  Tell our parent about the change notification first
    //

    IIS_SERVER_INSTANCE::MDChangeNotify( pcoChangeList );

    //
    // Now flush the metacache and relevant file handle cache entries.
    //

    TsFlushMetaCache(METACACHE_W3_SERVER_ID, FALSE);

    if (!IISstrnicmp((PUCHAR)pcoChangeList->pszMDPath, (PUCHAR)QueryMDVRPath(),
                    IISstrlen( (PUCHAR)QueryMDVRPath() )))
    {
        pszURL = (CHAR *)pcoChangeList->pszMDPath + QueryMDVRPathLen() - 1;

        //
        // Figure out the length of the URL. Unless this is the root,
        // we want to strip the trailing slash.

        if (memcmp(pszURL, "/", sizeof("/")) != 0)
        {
            dwURLLength = strlen(pszURL) - 1;
        }
        else
        {
            dwURLLength = sizeof("/") - 1;
        }

    }
    else
    {
        //
        // Presumably this is for a change above the root URL level, i.e. a
        // change of a property at the service level. Since this affects
        // everything, flush starting at the root.
        //

        pszURL = "/";
        dwURLLength = sizeof("/") - 1;
    }

    DBG_ASSERT(pszURL != NULL);
    DBG_ASSERT(*pszURL != '\0');

    TsFlushURL(GetTsvcCache(), pszURL, dwURLLength, RESERVED_DEMUX_URI_INFO);

    BOOL fReadPrivateW3Params = FALSE;

    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {

        case MD_FILTER_ENABLED:
        case MD_FILTER_IMAGE_PATH:
        case MD_FILTER_LOAD_ORDER:

            if ( fFiltersModified )     // First change will pick up all changes
                continue;

            if ( !CreateFilterList() )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Failed to create new filter list\n" ));
            }
            else
            {
                fFiltersModified = TRUE;
            }

            break;

        case MD_SERIAL_CERT11:          // Cert mapper support
        case MD_SERIAL_CERTW:
        case MD_SERIAL_DIGEST:
        case MD_SERIAL_ITA:

        case MD_AUTH_CHANGE_URL:
        case MD_AUTH_EXPIRED_URL:
        case MD_AUTH_NOTIFY_PWD_EXP_URL:
        case MD_AUTH_EXPIRED_UNSECUREURL:
        case MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL:
        case MD_ADV_NOTIFY_PWD_EXP_IN_DAYS:
        case MD_CERT_CHECK_MODE:
        case MD_AUTH_CHANGE_FLAGS:
        case MD_ADV_CACHE_TTL:
        case MD_NET_LOGON_WKS:
        case MD_USE_HOST_NAME:
        case MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS:
        case MD_PROCESS_NTCR_IF_LOGGED_ON:
        case MD_CPU_LOGGING_OPTIONS:
        case MD_CPU_LOGGING_INTERVAL:
        case MD_CPU_RESET_INTERVAL:
        case MD_CPU_CGI_LIMIT:
        case MD_CPU_LIMIT_LOGEVENT:
        case MD_CPU_LIMIT_PRIORITY:
        case MD_CPU_LIMIT_PROCSTOP:
        case MD_CPU_LIMIT_PAUSE:
        case MD_CPU_LOGGING_MASK:
        case MD_CPU_LIMITS_ENABLED:
        case MD_SERVER_COMMENT:

            fReadPrivateW3Params = TRUE;
            break;
            
            //
            // Server cert properties
            //
        case MD_SSL_CERT_HASH:
        case MD_SSL_CERT_CONTAINER:
        case MD_SSL_CERT_PROVIDER:
        case MD_SSL_CERT_OPEN_FLAGS:
        case MD_SSL_CERT_STORE_NAME:

            //
            // Fortezza-specific
            //
        case MD_SSL_CERT_IS_FORTEZZA:
        case MD_SSL_CERT_FORTEZZA_PIN:
        case MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER:
        case MD_SSL_CERT_FORTEZZA_PERSONALITY:
        case MD_SSL_CERT_FORTEZZA_PROG_PIN:

            //
            // Server CTL properties
            //
        case MD_SSL_CTL_IDENTIFIER:
        case MD_SSL_CTL_CONTAINER:
        case MD_SSL_CTL_PROVIDER:
        case MD_SSL_CTL_PROVIDER_TYPE:
        case MD_SSL_CTL_OPEN_FLAGS:
        case MD_SSL_CTL_STORE_NAME:
        case MD_SSL_CTL_SIGNER_HASH:
        case MD_SSL_USE_DS_MAPPER:

            fSslModified = TRUE;
            break;

        case MD_SERVER_STATE:

            switch (QueryServerState()) {
            case MD_SERVER_STATE_STARTED:
                ProcessStartNotification();
                break;
            case MD_SERVER_STATE_STOPPED:
                ProcessStopNotification();
                break;
            case MD_SERVER_STATE_PAUSED:
                ProcessPauseNotification();
                break;
            default:
                ;
            }

            break;

        default:
            break;
        }
    }

    if (fReadPrivateW3Params) {
        if ( !ReadPrivateW3Params() )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to re-read parameters\n" ));
        }
    }

    UnlockThis();

    //
    // If anything related to SSL has changed, call the function used to flush
    // the SSL/Schannel credential cache and reset the server certificate
    //
    if ( fSslModified )
    {
        ResetSSLInfo( this );
    }
}


BOOL
W3_SERVER_INSTANCE::CreateFilterList(
    VOID
    )
/*++

   Description

       Creates the list of filters this server instance needs to notify.
       If there's an existing filter list on this instance, the old filter
       list is atomically exchanged and allowed to die off.

   Arguments:



--*/
{
    CHAR          szFilterKey[MAX_PATH+1];
    FILTER_LIST * pfl;
    FILTER_LIST * pflOld;
    DWORD         cb;
    DWORD         fEnabled;
    CHAR          szLoadOrder[1024];
    CHAR          szDllName[MAX_PATH+1];
    CHAR *        pchFilter;
    CHAR *        pchComma;
    MB            mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    BOOL          fOpened;

    strcpy( szFilterKey, QueryMDPath() );
    strcat( szFilterKey, IIS_MD_ISAPI_FILTERS );
    DBG_ASSERT( strlen( szFilterKey ) + 1 < sizeof( szFilterKey ));

    //
    //  Create a filter list for this instance
    //

    pfl = new FILTER_LIST();

    if ( !pfl || !pfl->InsertGlobalFilters() ) {

        delete pfl;
        return FALSE;
    }

    //
    // Loop through filter keys, if we can't access the metabase, we assume
    // success and continue
    //

    if ( mb.Open( szFilterKey,
                  METADATA_PERMISSION_READ ))
    {
        fOpened = TRUE;

        //
        //  Get the filter load order
        //

        cb = sizeof( szLoadOrder );
        *szLoadOrder = '\0';

        if ( mb.GetString( "",
                           MD_FILTER_LOAD_ORDER,
                           IIS_MD_UT_SERVER,
                           szLoadOrder,
                           &cb,
                           0 ))
        {
            pchFilter = szLoadOrder;

            while ( *pchFilter )
            {
                if ( !fOpened &&
                     !mb.Open( szFilterKey, METADATA_PERMISSION_READ ))
                {
                    DBGPRINTF(( DBG_CONTEXT,
                               "CreateFilterList: Cannot open path %s, error %lu\n",
                                szFilterKey, GetLastError() ));
                    break;
                }
                fOpened = TRUE;

                pchComma = strchr( pchFilter, ',' );

                if ( pchComma )
                {
                    *pchComma = '\0';
                }

                while ( ISWHITEA( *pchFilter ))
                {
                    pchFilter++;
                }

                fEnabled = TRUE;
                mb.GetDword( pchFilter,
                             MD_FILTER_ENABLED,
                             IIS_MD_UT_SERVER,
                             &fEnabled );

                if ( fEnabled ) 
                {
                    cb = sizeof(szDllName);
                    if ( mb.GetString( pchFilter,
                                       MD_FILTER_IMAGE_PATH,
                                       IIS_MD_UT_SERVER,
                                       szDllName,
                                       &cb,
                                       0 ))
                    {
                        mb.Close();
                        fOpened = FALSE;

                        if ( pfl->LoadFilter( &mb, szFilterKey, &fOpened, pchFilter, szDllName, FALSE ))
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                        "[CreateFilterList] Loaded %s\n",
                                        szDllName ));
                        }
                    }
                }
                
                if ( pchComma )
                {
                    pchFilter = pchComma + 1;
                }
                else
                {
                    break;
                }
            }
        }
    }

    //
    //  Replace the old filter list with the new filter list
    //

    LockThisForWrite();

    pflOld = m_pFilterList;
    m_pFilterList = pfl;

    UnlockThis();

    if ( pflOld ) {
        FILTER_LIST::Dereference( pflOld );
    }

    return TRUE;
}

#if 0



BOOL
W3_SERVER_INSTANCE::UpdateFilterList(
    CHAR * pszNewDll,
    CHAR * pszOldDll
    )
/*++

Description

    Given a filter dll to replace on this instance, this routine updates
    the filter list with the new dll and lets the old filter list die off

Arguments:

    pszNewDll - Fully Qualified path to new dll - may be NULL
    pszOldDll - The DLL this filter is replacing (or NULL for just adding a
        new Filter)

--*/
{
    FILTER_LIST * pfl;
    FILTER_LIST * pflOld;

    DBG_ASSERT( m_pFilterList );

    //
    //  Create a new filter list for this instance and copy the old filter list
    //

    pfl = new FILTER_LIST();

    if ( !pfl ||
         !pfl->Copy( m_pFilterList ) ||
         !pfl->LoadFilter( pszNewDll, FALSE ) ||
         !pfl->Remove( pszOldDll ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[UpdateFilterList] Failed - Error %d\n",
                    GetLastError() ));

        delete pfl;
        return FALSE;
    }

    //
    //  Replace the old filter list with the new filter list
    //

    LockThisForWrite();

    pflOld = m_pFilterList;
    m_pFilterList = pfl;

    UnlockThis();

    if ( pflOld ) {
        FILTER_LIST::Dereference( pflOld );
    }

    return TRUE;
}
#endif


APIERR
W3_SERVER_INSTANCE::InitializeHostName(
    VOID
    )
/*++

Routine Description:

    Initializes the default host name

Arguments:

    None

Return Value:

    Win32

--*/

{

    //
    // Build Host Name to be used in URL creation
    //

    if ( m_dwUseHostName )
    {
        char hn[128];
        PHOSTENT pH;

        if ( !gethostname( hn, sizeof(hn) )
                && (pH = gethostbyname( hn ))
                && pH->h_name
                && pH->h_addr_list
                && pH->h_addr_list[0]
#if 0
                // disabled for now : if the UseHostName flag is set,
                // we will always use the DNS name specified in the
                // TCP/IP configuration panel
                //

                && pH->h_addr_list[1] == NULL
#endif
                )
        {
            m_pszDefaultHostName = (PCHAR)TCP_ALLOC(strlen( pH->h_name ) + 1);
            if ( m_pszDefaultHostName == NULL )
            {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            strcpy( m_pszDefaultHostName, pH->h_name );

            if ( m_pszDefaultHostName[0] == '\0' ) {
                TCP_FREE(m_pszDefaultHostName);
                m_pszDefaultHostName = NULL;
            }
        }
    }

    return(NO_ERROR);

} // W3_SERVER_INSTANCE::InitializeHostName



VOID
W3_SERVER_INSTANCE::CleanupRegistryStrings(
    VOID
    )
/*++

   Description

       Frees all configurable strings in the W3_SERVER_INSTANCE class

   Arguments:

       None.

--*/
{
    DWORD i = 0;

    if ( m_pszAccessDeniedMsg != NULL ) {
        TCP_FREE(m_pszAccessDeniedMsg);
        m_pszAccessDeniedMsg = NULL;
    }

    return;

} // W3_SERVER_INSTANCE::CleanupRegistryStrings


LPVOID
W3_SERVER_INSTANCE::QueryMapper(
    MAPPER_TYPE mt
    )
/*++

   Description

       Returns mapper

   Arguments:

       mt - mapper type

   Returns:

       ptr to Blob referencing mapper or NULL if no such mapper

--*/
{
    LPVOID pV;

    LockThisForRead();

    if ( pV = m_apMappers[(UINT)mt] )
    {
        ((RefBlob*)pV)->AddRef();
    }
    else
    {
        pV = NULL;
    }

    UnlockThis();

    return pV;
}

IIS_SSL_INFO*
W3_SERVER_INSTANCE::GetAndReferenceSSLInfoObj( VOID )
/*++

   Description

       Returns SSL info for this instance; calls Reference() before returning

   Arguments:

   Returns:

       Ptr to SSL info object on success, NULL if failure

--*/
{
    IIS_SSL_INFO *pPtr = NULL;

    LockThisForRead();

    //
    // If it's null, we may have to create it - unlock, lock for write and make sure it's
    // still NULL before creating it
    //
    if ( !m_pSSLInfo )
    {
        UnlockThis();

        LockThisForWrite();

        //
        // Still null, so create it now
        //
        if ( !m_pSSLInfo )
        {
            m_pSSLInfo = IIS_SSL_INFO::CreateSSLInfo( 
                                        (LPTSTR) QueryMDPath(),
                                        (IMDCOM *) g_pInetSvc->QueryMDObject() );

            if ( m_pSSLInfo == NULL )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                UnlockThis();
                return NULL;
            }

            //
            // Acquire an internal reference
            //
            m_pSSLInfo->Reference();

            //
            // Construct the server certificate and CTL and log 
            // the status
            //
            IIS_SERVER_CERT *pCert = m_pSSLInfo->GetCertificate();
            if ( pCert )
            {
                LogCertStatus();
            }

            IIS_CTL *pCTL = m_pSSLInfo->GetCTL();
            if ( pCTL )
            {
                LogCTLStatus();
            }

            //
            // Register for changes
            //

            if ( g_pStoreChangeNotifier )
            {
                if ( pCert && pCert->IsValid() )
                {
                    //
                    // Watch for changes to the store the cert came out of 
                    //
                    if (!g_pStoreChangeNotifier->RegisterStoreForChange( pCert->QueryStoreName(),
                                                                     pCert->QueryStoreHandle(),
                                                                     ResetSSLInfo,
                                                                     (PVOID) this ) )
                    {
                        DBGPRINTF((DBG_CONTEXT,
                                   "Failed to register for change event on store %s\n",
                                   pCert->QueryStoreName()));
                    }
                }

                if ( pCTL && pCTL->IsValid() )
                {
                    //
                    // Watch for changes to the store the CTL came out of 
                    //
                    if (!g_pStoreChangeNotifier->RegisterStoreForChange( pCTL->QueryStoreName(),
                                                                     pCTL->QueryOriginalStore(),
                                                                         ResetSSLInfo,
                                                                         (PVOID) this ) )
                    {
                        DBGPRINTF((DBG_CONTEXT,
                                   "Failed to register for change event on store %s\n",
                                   pCTL->QueryStoreName()));
                    }
                }

                
                if ( ( pCert && pCert->IsValid()) || 
                     ( pCTL && pCTL->IsValid() ) )
                {
                    HCERTSTORE hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                                           0,
                                                           NULL,
                                                           CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                                           "ROOT" );

                    if ( hRootStore )
                    {
                        //
                        // Watch for changes to the ROOT store
                        //
                        if ( !g_pStoreChangeNotifier->RegisterStoreForChange( "ROOT",
                                                                              hRootStore,
                                                                              ResetSSLInfo,
                                                                              (PVOID) this ) )
                        {
                            DBGPRINTF((DBG_CONTEXT,
                                       "Failed to register for change event on root store\n"));
                        }

                        CertCloseStore( hRootStore,
                                        0 );
                    }
                    else
                    {
                        DBGPRINTF((DBG_CONTEXT,
                                   "Failed to open ROOT store, error 0x%d\n",
                                   GetLastError()));
                        
                    }
                } // if ( pCert || pCTL )

            } // if (g_pStoreChangeNotifier)

        } // if ( !m_pSSLInfo )

    } //if ( !m_pSSLInfo )

    //
    // At this point, m_pSSLInfo should not be NULL anymore, so add the external reference
    //
    m_pSSLInfo->Reference();

    pPtr = m_pSSLInfo;

    UnlockThis();

    return pPtr;
}


BOOL
SetFlushMapperNotify(
    SF_NOTIFY_TYPE nt,
    PFN_SF_NOTIFY pFn
    )
/*++

   Description

       Set the function called to notify that a mapper is being flushed
       Can be called only once for a given mapper type

   Arguments:

       nt - notification type
       pFn - function to call to notify mapper flushed

   Returns:

       TRUE if function reference stored, FALSE otherwise

--*/
{
    MAPPER_TYPE mt;

    switch ( nt )
    {
        case SF_NOTIFY_MAPPER_MD5_CHANGED:
            mt = MT_MD5;
            break;

        case SF_NOTIFY_MAPPER_ITA_CHANGED:
            mt = MT_ITA;
            break;

        case SF_NOTIFY_MAPPER_CERT11_CHANGED:
            mt = MT_CERT11;
            break;

        case SF_NOTIFY_MAPPER_CERTW_CHANGED:
            mt = MT_CERTW;
            break;

        default:
            return FALSE;
    }

    if ( g_pFlushMapperNotify[(UINT)mt] == NULL || pFn == NULL )
    {
        g_pFlushMapperNotify[(UINT)mt] = pFn;
        return TRUE;
    }

    return FALSE;
}



VOID W3_SERVER_INSTANCE::ResetSSLInfo( LPVOID pvParam )
/*++
    Description:

        Wrapper function for function to call to notify of SSL changes

    Arguments:

        pvParam - pointer to instance for which SSL keys have changed

    Returns:

        Nothing

--*/
{
    //
    // Call function to flush credential cache etc
    //
    if ( g_pSslKeysNotify )
    {
        g_pSslKeysNotify( SF_NOTIFY_MAPPER_SSLKEYS_CHANGED,
                          pvParam );
    }

    W3_SERVER_INSTANCE *pInst = (W3_SERVER_INSTANCE *) pvParam;

    //
    // Clean up all the SSL information associated with this instance
    //
    pInst->LockThisForRead();

    if ( pInst->m_pSSLInfo )
    {
        pInst->UnlockThis();

        pInst->LockThisForWrite();

        if ( pInst->m_pSSLInfo )
        {
            //
            // Stop watching for change notifications
            //
            IIS_SERVER_CERT *pCert = pInst->m_pSSLInfo->QueryCertificate();
            IIS_CTL *pCTL = pInst->m_pSSLInfo->QueryCTL();

            if ( g_pStoreChangeNotifier )
            {
                //
                // Stop watching the store the cert came out of 
                //
                if ( pCert && pCert->IsValid() )
                {
                    g_pStoreChangeNotifier->UnregisterStore( pCert->QueryStoreName(),
                                                             ResetSSLInfo,
                                                             (PVOID) pvParam );
                }

                //
                // Stop watching the store the CTL came out of 
                //
                if ( pCTL && pCTL->IsValid() )
                {
                    g_pStoreChangeNotifier->UnregisterStore( pCTL->QueryStoreName(),
                                                             ResetSSLInfo,
                                                             (PVOID) pvParam );
                }

                //
                // Stop watching the ROOT store
                //
                g_pStoreChangeNotifier->UnregisterStore( "ROOT",
                                                         ResetSSLInfo,
                                                         (PVOID) pvParam );
            }


            pInst->m_pSSLInfo->ReleaseFortezzaHandlers();

            //
            // Release internal reference
            //
            IIS_SSL_INFO::Release( pInst->m_pSSLInfo );

            //
            // Next call to GetAndReferenceSSLObj() will create it again
            //
            pInst->m_pSSLInfo = NULL;
        }
    }

    pInst->UnlockThis();
}


VOID W3_SERVER_INSTANCE::LogCertStatus()
/*++
    Description:

       Writes system log event about status of server certificate if the cert is in some
       way not quite kosher eg expired, revoked, not signature-valid

    Arguments:

       None 

    Returns:

       Nothing
--*/
{
    DBG_ASSERT( m_pSSLInfo );

    DWORD dwCertValidity = 0;

    //
    // If we didn't construct the cert fully, log an error
    //
    if ( !m_pSSLInfo->QueryCertificate()->IsValid() )
    {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCertificate()->Status();
        DWORD dwStringID = 0;

        DBGPRINTF((DBG_CONTEXT,
                   "Couldn't retrieve server cert; status : %d\n",
                   dwStatus));

        switch ( dwStatus )
        {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CERT_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CERT_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CERT_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CERT_INTERNAL_ERROR;
            break;
        }

        g_pInetSvc->LogEvent( dwStringID,
                              2,
                              apszMsgs,
                              0 );

        return;
    }


    //
    // If cert is invalid in some other way , write the appropriate log message
    //
    if ( m_pSSLInfo->QueryCertValidity( &dwCertValidity ) )
    {
        const CHAR *apszMsgs[1];
        CHAR achInstance[20];
        wsprintfA( achInstance,
                   "%lu",
                   QueryInstanceId() );
        apszMsgs[0] = achInstance;
        DWORD dwMsgID = 0;

        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_VALID ) ||
             ( dwCertValidity & CERT_TRUST_IS_NOT_TIME_NESTED ) ||
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_TIME_VALID ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Server cert/CTL is not time-valid or time-nested\n"));
            
            dwMsgID = SSL_MSG_TIME_INVALID_SERVER_CERT;
        }
        
        
        if ( dwCertValidity & CERT_TRUST_IS_REVOKED )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Server Cert is revoked\n"));
            
            dwMsgID = SSL_MSG_REVOKED_SERVER_CERT;
        }
        
        if ( ( dwCertValidity & CERT_TRUST_IS_UNTRUSTED_ROOT ) ||
             ( dwCertValidity & CERT_TRUST_IS_PARTIAL_CHAIN ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Server Cert doesn't chain up to a trusted root\n"));
            
            dwMsgID = SSL_MSG_UNTRUSTED_SERVER_CERT;
        }
        
        if ( ( dwCertValidity & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) || 
             ( dwCertValidity & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Server Cert/CTL is not signature valid\n"));
            
            dwMsgID = SSL_MSG_SIGNATURE_INVALID_SERVER_CERT;
        }

        if ( dwMsgID )
        {
            g_pInetSvc->LogEvent( dwMsgID,
                                  1,
                                  apszMsgs,
                                  0 ) ;
        }
    }

}


VOID W3_SERVER_INSTANCE::LogCTLStatus()
/*++
    Description:

       Writes system log event about status of server CTL if CTL isn't valid 

    Arguments:

      None 

    Returns:

       Nothing
--*/
{
    DBG_ASSERT( m_pSSLInfo );

    //
    // If we didn't construct the CTL fully, log an error
    //
    if ( !m_pSSLInfo->QueryCTL()->IsValid() )
    {
        CONST CHAR *apszMsgs[2];
        CHAR achInstance[20];
        CHAR achErrorNumber[20];
        wsprintf( achInstance,
                  "%lu",
                  QueryInstanceId() );
        wsprintf( achErrorNumber,
                  "0x%x",
                  GetLastError() );

        apszMsgs[0] = achInstance;
        apszMsgs[1] = achErrorNumber;

        DWORD dwStatus = m_pSSLInfo->QueryCTL()->QueryStatus();
        DWORD dwStringID = 0;

        DBGPRINTF((DBG_CONTEXT,
                   "Couldn't retrieve server CTL; status : %d\n",
                   dwStatus));

        switch ( dwStatus )
        {
        case CERT_ERR_MB:
            dwStringID = SSL_MSG_CTL_MB_ERROR;
            break;

        case CERT_ERR_CAPI:
            dwStringID = SSL_MSG_CTL_CAPI_ERROR;
            break;

        case CERT_ERR_CERT_NOT_FOUND:
            dwStringID = SSL_MSG_CTL_NOT_FOUND;
            break;

        default:
            dwStringID = SSL_MSG_CTL_INTERNAL_ERROR;
            break;
        }

        g_pInetSvc->LogEvent( dwStringID,
                              2,
                              apszMsgs,
                              0 );
        return;
    }
}


BOOL
SetSllKeysNotify(
    PFN_SF_NOTIFY pFn
    )
/*++

   Description

       Set the function called to notify SSL keys have changed
       Can be called only once

   Arguments:

       pFn - function to call to notify SSL keys change

   Returns:

       TRUE if function reference stored, FALSE otherwise

--*/
{
    if ( g_pSslKeysNotify == NULL || pFn == NULL )
    {
        g_pSslKeysNotify = pFn;
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\debug\stats.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    stats.c
    This module implements the "stats" command of the W3 Server
    debugger extension DLL.


    FILE HISTORY:
        KeithMo     13-Jun-1993 Created.

*/


#include "w3dbg.h"
#include <time.h>


/*******************************************************************

    NAME:       stats

    SYNOPSIS:   Displays the server statistics.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    HISTORY:
        KeithMo     13-Jun-1993 Created.

********************************************************************/
VOID stats( HANDLE hCurrentProcess,
            HANDLE hCurrentThread,
            DWORD  dwCurrentPc,
            LPVOID lpExtensionApis,
            LPSTR  lpArgumentString )
{
    W3_STATISTICS_0 W3Stats;
    CHAR             szLargeInt[64];
    LPVOID           pstats;

    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Capture the statistics.
    //

    pstats = (LPVOID)DebugEval( "W3Stats" );

    if( pstats == NULL )
    {
        DebugPrint( "cannot locate W3Stats\n" );
        return;
    }

    ReadProcessMemory( hCurrentProcess,
                       pstats,
                       (LPVOID)&W3Stats,
                       sizeof(W3Stats),
                       (LPDWORD)NULL );

    //
    //  Dump the statistics.
    //

    RtlLargeIntegerToChar( &W3Stats.TotalBytesSent,
                           10,
                           sizeof(szLargeInt),
                           szLargeInt );

    DebugPrint( "TotalBytesSent           = %s\n",
                szLargeInt                       );

    RtlLargeIntegerToChar( &W3Stats.TotalBytesReceived,
                           10,
                           sizeof(szLargeInt),
                           szLargeInt );

    DebugPrint( "TotalBytesReceived       = %s\n",
                szLargeInt                       );

    DebugPrint( "TotalFilesSent           = %lu\n",
                W3Stats.TotalFilesSent           );

    DebugPrint( "TotalFilesReceived       = %lu\n",
                W3Stats.TotalFilesReceived       );

    DebugPrint( "CurrentAnonymousUsers    = %lu\n",
                W3Stats.CurrentAnonymousUsers    );

    DebugPrint( "CurrentNonAnonymousUsers = %lu\n",
                W3Stats.CurrentNonAnonymousUsers );

    DebugPrint( "TotalAnonymousUsers      = %lu\n",
                W3Stats.TotalAnonymousUsers      );

    DebugPrint( "TotalNonAnonymousUsers   = %lu\n",
                W3Stats.TotalNonAnonymousUsers   );

    DebugPrint( "MaxAnonymousUsers        = %lu\n",
                W3Stats.MaxAnonymousUsers        );

    DebugPrint( "MaxNonAnonymousUsers     = %lu\n",
                W3Stats.MaxNonAnonymousUsers     );

    DebugPrint( "CurrentConnections       = %lu\n",
                W3Stats.CurrentConnections       );

    DebugPrint( "MaxConnections           = %lu\n",
                W3Stats.MaxConnections           );

    DebugPrint( "ConnectionAttempts       = %lu\n",
                W3Stats.ConnectionAttempts       );

    DebugPrint( "LogonAttempts            = %lu\n",
                W3Stats.LogonAttempts            );

    DebugPrint( "TimeOfLastClear          = %s\n",
                asctime( localtime( (time_t *)&W3Stats.TimeOfLastClear ) ) );

}   // stats
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\w3meta.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

      w3meta.cxx

   Abstract:
       Defines the functions for W3_METADATA

   Author:

       IIS Core Team 1997

   Environment:
       Win32 - User Mode

   Project:

       W3 Service DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "w3p.hxx"
#include <inetinfo.h>
#include "basereq.hxx"
#include <lonsi.hxx>

#define SET_WIN32_ERR(p,x)  {       (p)->IsValid = TRUE; \
                                    (p)->ErrorReason = METADATA_ERROR_WIN32;\
                                    (p)->Win32Error = (x); \
                            }

#define SET_VALUE_ERR(x)    {       (x)->IsValid = TRUE; \
                                    (x)->ErrorReason = METADATA_ERROR_VALUE;\
                            }


/************************************************************
 *    Functions
 ************************************************************/

BOOL
W3_METADATA::BuildCustomErrorTable(
    CHAR            *pszErrorList,
    PMETADATA_ERROR_INFO    pMDErrorInfo

    )
/*++
    Description:

        Take an input string and build a custom error table out of it. The
        input string is a multi-sz, where each string is of the form error,
        suberror, {FILE | URL}, path.

    Arguments:
        pszErrorList    - Pointer to the error list.

    Returns:
        TRUE if we built the table successfully, FALSE otherwise.

--*/
{
    CHAR                *pszType;
    CHAR                *pszSubError;
    CHAR                *pszPath;
    CHAR                *pszNewPath;
    CHAR                cTemp;
    DWORD               dwError;
    DWORD               dwSubError;
    BOOL                bWildcardSubError;
    BOOL                bIsFile;
    PCUSTOM_ERROR_ENTRY pNewEntry;
    DWORD               dwPathLength;

    for (;;)
    {

        // Convert the first parameter to a number.
        dwError = atoi(pszErrorList);

        if (dwError < 300)
        {
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        // Now convert the second parameter (the suberror) to a number.

        pszSubError = strchr(pszErrorList, ',');

        if (pszSubError == NULL)
        {
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        pszSubError++;
        while (isspace((UCHAR)(*pszSubError)))
        {
            pszSubError++;
        }

        if (*pszSubError == '*')
        {
            bWildcardSubError = TRUE;
            dwSubError = 0;
        }
        else
        {
            if (!isdigit((UCHAR)(*pszSubError)))
            {
                SET_VALUE_ERR(pMDErrorInfo);
                return FALSE;
            }

            dwSubError = atoi(pszSubError);
            bWildcardSubError = FALSE;
        }


        // Now find the comma that seperates the number and the type.
        pszType = strchr(pszSubError, ',');

        if (pszType == NULL)
        {
            // Didn't find it.
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        pszType++;

        // Skip any preceding ws.

        while (isspace((UCHAR)(*pszType)))
        {
            pszType++;
        }

        // We found the end of ws. If this isn't an alphabetic character, it's
        // an error. If it is, find the end of the alpha. chars.

        if (!isalpha((UCHAR)(*pszType)))
        {
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        pszPath = pszType;

        while (isalpha((UCHAR)(*pszPath)))
        {
            pszPath++;
        }

        cTemp = *pszPath;
        *pszPath = '\0';

        // Now see what the parameter is.

        if (!_stricmp(pszType, "FILE"))
        {
            bIsFile = TRUE;
        }
        else
        {
            if (!_stricmp(pszType, "URL"))
            {
                bIsFile = FALSE;
            }
            else
            {
                *pszPath = cTemp;
                SET_VALUE_ERR(pMDErrorInfo);
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;
            }
        }

        *pszPath = cTemp;

        // Now find the comma that seperates the type from the URL/path.

        pszPath = strchr(pszPath, ',');

        if (pszPath == NULL)
        {
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        // Found the comma. Go one past and find the path or URL.

        pszPath++;

        while (isspace((UCHAR)(*pszPath)))
        {
            pszPath++;
        }

        if (*pszPath == '\0')
        {
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        dwPathLength = strlen(pszPath) + 1;

        pszNewPath = (CHAR *)TCP_ALLOC(dwPathLength);

        if (pszNewPath == NULL)
        {
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        memcpy(pszNewPath, pszPath, dwPathLength);

        pNewEntry = new CUSTOM_ERROR_ENTRY(dwError, dwSubError,
                                bWildcardSubError, pszNewPath, bIsFile);

        if (pNewEntry == NULL)
        {
            SET_WIN32_ERR(pMDErrorInfo, GetLastError());
            TCP_FREE(pszNewPath);
            return FALSE;
        }

        // Insert wildcard errors at the end, and specific errors at the
        // begining, so that specific errors have priority.

        if (bWildcardSubError)
        {
            InsertTailList(&m_CustomErrorHead, &pNewEntry->_ListEntry );
        }
        else
        {
            InsertHeadList(&m_CustomErrorHead, &pNewEntry->_ListEntry );
        }

        pszErrorList = pszPath + dwPathLength;

        if (*pszErrorList == '\0')
        {
            return TRUE;
        }

    }
}

VOID
W3_METADATA::DestroyCustomErrorTable(
    VOID
    )
/*++
    Description:

        Destroy the custom error table for this metadata.

    Arguments:

    Returns:

--*/
{
    LIST_ENTRY          *pEntry;
    PCUSTOM_ERROR_ENTRY pErrorEntry;

    while ( !IsListEmpty( &m_CustomErrorHead ))
    {
        pErrorEntry = CONTAINING_RECORD(  m_CustomErrorHead.Flink,
                                      CUSTOM_ERROR_ENTRY,
                                      _ListEntry );

        RemoveEntryList( &pErrorEntry->_ListEntry );

        delete pErrorEntry;
    }
}

/*******************************************************************

    NAME:       CompactParameters

    SYNOPSIS:   Reads a metadata multisz set of comma seperated
                strings, and copies this into a BUFFER while stripping
                whitespace. There can be multiple lines.

    ENTRY:      bufDest         - Pointer to BUFFER to copy into.
                pszSrc          - Source string.
                dwNumParam      - Number of paramters to retrieve.
                fFlags          - Bit field, indicating which parameters
                                    are to have white space stripped.

    RETURNS:    TRUE if successful, FALSE if an error occurred.

    NOTES:


********************************************************************/
BOOL
CompactParameters(
    BUFFER      *bufDest,
    CHAR        *pszSrc,
    DWORD       dwNumParam,
    DWORD       fFlags,
    PMETADATA_ERROR_INFO    pMDErrorInfo
    )
{
    DWORD       dwParamFound;
    CHAR        *pszCurrent;
    BOOL        bFirst;
    DWORD       dwBytesCopied;
    DWORD       dwBufferSize;
    CHAR        *pszBuffer;
    DWORD       fWSFlags;

    DBG_ASSERT(pszSrc != NULL);


    // Go through each line, looking for dwNumParam parameters. When we find
    // that many, go to end of line, and start again. If we don't find
    // enough parameters in a line, fail.

    dwParamFound = 0;
    dwBytesCopied = 0;
    bFirst = TRUE;
    fWSFlags = fFlags;

    dwBufferSize = bufDest->QuerySize();
    pszBuffer = (CHAR *)bufDest->QueryPtr();

    for (;;)
    {
        DWORD       dwBytesNeeded;

        while (isspace((UCHAR)(*pszSrc)))
        {
            pszSrc++;
        }

        if (*pszSrc == '\0')
        {
            // Didn't find enough.

            SET_VALUE_ERR(pMDErrorInfo);
            return FALSE;

        }

        // Now scan this parameter, looking for either WS or a comma,
        // depending on fWSFlags.

        pszCurrent = pszSrc;

        while (*pszSrc != ',' && ( (fWSFlags & 1) ? TRUE : !isspace((UCHAR)(*pszSrc))) &&
                *pszSrc != '\0')
        {
            pszSrc++;
        }

        dwParamFound++;

        // Now pszSrc points at the character that terminated our parameter.
        // Make sure we have enough room to copy this.

        dwBytesNeeded = DIFF(pszSrc - pszCurrent) + (bFirst ? 0 : sizeof(CHAR)) +
                        ((dwParamFound != dwNumParam) ? 0 : sizeof(CHAR));

        if ((dwBufferSize - dwBytesCopied) < dwBytesNeeded)
        {
            if (!bufDest->Resize(dwBytesCopied + dwBytesNeeded + 32))
            {
                SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                return FALSE;
            }

            dwBufferSize = bufDest->QuerySize();
            pszBuffer = (CHAR *)bufDest->QueryPtr();
        }

        if (!bFirst)
        {
            *(pszBuffer + dwBytesCopied) = ',';
            dwBytesCopied++;
        }

        memcpy(pszBuffer + dwBytesCopied, pszCurrent, DIFF(pszSrc - pszCurrent));
        dwBytesCopied += DIFF(pszSrc - pszCurrent);

        bFirst = FALSE;
        fWSFlags >>= 1;

        if (dwParamFound == dwNumParam)
        {
            // Found all we need on this line, look for the next.
            *(pszBuffer + dwBytesCopied) = '\0';
            dwBytesCopied++;

            bFirst = TRUE;
            fWSFlags = fFlags;
            dwParamFound = 0;

            while (*pszSrc != '\0')
            {
                pszSrc++;
            }

            // Move to start of next line.
            pszSrc++;

            if (*pszSrc == '\0')
            {
                // Found end of multisz. Terminate buffer and return.

                break;

            }

        }
        else
        {
            // Otherwise, still have more parameters to find on this line.

            while (*pszSrc != ',')
            {
                if (*pszSrc == '\0')
                {
                    if (dwNumParam != 0xffffffff)
                    {
                        SET_VALUE_ERR(pMDErrorInfo);
                        SetLastError( ERROR_INVALID_DATA );
                        return FALSE;
                    }

                    // Copying an unknown number, so terminate the line now.

                    if ((dwBufferSize - dwBytesCopied) == 0)
                    {
                        if (!bufDest->Resize(dwBytesCopied + 32))
                        {
                            SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                            return FALSE;
                        }
                        dwBufferSize = bufDest->QuerySize();
                        pszBuffer = (CHAR *)bufDest->QueryPtr();
                    }

                    *(pszBuffer + dwBytesCopied) = '\0';
                    dwBytesCopied++;
                    bFirst = TRUE;
                    fWSFlags = fFlags;
                    dwParamFound = 0;



                    break;

                }
                else
                {
                    pszSrc++;
                }

            }

            if (*pszSrc == '\0')
            {
                // We broke out of the loop because we hit the end of the
                // line on a 'read all' string.

                if (*(pszSrc + 1)  == '\0')
                {
                    // Hit the end of a multisz.
                    break;
                }
            }

            pszSrc++;

        }


    }

    // We get here when we've copied all of the buffer. Terminate the multisz
    // and we're done.

    if ((dwBufferSize - dwBytesCopied) == 0)
    {
        if (!bufDest->Resize(dwBytesCopied + 1))
        {
            SET_WIN32_ERR(pMDErrorInfo, GetLastError());
            return FALSE;
        }
        pszBuffer = (CHAR *)bufDest->QueryPtr();
    }

    *(pszBuffer + dwBytesCopied) = '\0';

    return TRUE;
}


BOOL
W3_METADATA::ReadCustomFooter(
    CHAR            *pszFooter,
    TSVC_CACHE      &Cache,
    HANDLE          User,
    PMETADATA_ERROR_INFO    pMDErrorInfo

    )
/*++

Routine Description:

    Process a footer string, either reading the file or copying the string
    to the buffer.

Arguments:

    pszFooter       - The footer string, which may be a string or a file name.
    Cache           - Cache info for opening file
    User            - Token for opening user

Returns:

    TRUE if we succeed, FALSE if we don't.

--*/
{
    BOOL            bIsString;
    DWORD           dwLength;
    STACK_STR(strError, 128);

    if (!FooterEnabled())
    {
        return TRUE;
    }

    // First thing to do is to determine if this is a string or a file name.
    // Skip preceding whitespace and then strcmp.

    while (isspace((UCHAR)(*pszFooter)))
    {
        pszFooter++;
    }


    if (!_strnicmp(pszFooter, "STRING", sizeof("STRING") - 1))
    {
        bIsString = TRUE;
        pszFooter += sizeof("STRING") - 1;
    }
    else
    {
        if (!_strnicmp(pszFooter, "FILE", sizeof("FILE") - 1))
        {
            bIsString = FALSE;
            pszFooter += sizeof("FILE") - 1;
        }
        else
        {
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }
    }

    // Now we look for 0 or more white space, followed by a colon, followed by
    // more white space.

    while (isspace((UCHAR)(*pszFooter)))
    {
        pszFooter++;
    }

    if (*pszFooter != ':')
    {
        // No colon seperator, error.
        SET_VALUE_ERR(pMDErrorInfo);
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    pszFooter++;

    //
    // OK, now if this is a string we take everything after the colon to the
    // end for the string. If this is a file name then we'll open and read the
    // file.
    //

    if (bIsString)
    {

        dwLength = strlen(pszFooter);

        if (!m_bufFooter.Resize(dwLength))
        {
            SET_WIN32_ERR(pMDErrorInfo, GetLastError());
            return FALSE;
        }

        memcpy(m_bufFooter.QueryPtr(), pszFooter, dwLength);


    }
    else
    {
        //
        // For files, we'll skip any more white space before the name.
        //

        while (isspace((UCHAR)(*pszFooter)))
        {
            pszFooter++;
        }


        if (!ReadEntireFile(pszFooter, Cache, User ,&m_bufFooter, &dwLength))
        {
            // Couldn't read the file, so instead we'll read the error
            // string and use that.
            if ( g_pInetSvc->LoadStr( strError, IDS_ERROR_FOOTER ))
            {
                dwLength = strError.QueryCB();

                if (!m_bufFooter.Resize(dwLength))
                {
                    SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                    return FALSE;
                }

                memcpy(m_bufFooter.QueryPtr(), strError.QueryStr(), dwLength);
            }
            else
            {
                // Couldn't read the error string, so fail.
                SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                return FALSE;
            }
        }
    }

    SetFooter(dwLength, (CHAR *)m_bufFooter.QueryPtr());
    return TRUE;
}

#define SIZEOF_EXPIRE_HEADER            sizeof("Expires: \r\n")
#define SIZEOF_GMT_DATETIME             64
#define SIZEOF_CACHE_CONTROL            (sizeof("Cache-Control: max-age=4294967295\r\n") - 1)


BOOL
W3_METADATA::SetExpire(
    CHAR*   pszExpire,
    PMETADATA_ERROR_INFO    pMDErrorInfo

    )
/*++

Routine Description:

    Set metadata based on MD_HTTP_EXPIRES entry

Arguments:

    pszExpire - expire configuration

Return value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD       dwExpires;
    LPSTR       pszParam;
    CHAR        *EndPtr;

    while (isspace((UCHAR)(*pszExpire)))
    {
        pszExpire++;
    }

    if ( !(pszParam = strchr( pszExpire, ',' )) )
    {
        if (*pszExpire == '\0' || toupper(*pszExpire) == 'N')
        {
            m_dwExpireMode = EXPIRE_MODE_OFF;
            return TRUE;
        }

        SET_VALUE_ERR(pMDErrorInfo);

        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }
    ++pszParam;

    while (isspace((UCHAR)(*pszParam)))
    {
        pszParam++;
    }

    switch ( *(CHAR*)pszExpire )
    {
        case 's': case 'S':
            if ( !m_strExpireHeader.Copy( "Expires: " ) ||
                 !m_strExpireHeader.Append( pszParam ) ||
                 !m_strExpireHeader.Append( "\r\n" ) )
            {
                SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                return FALSE;
            }

            m_dwExpireMaxLength = m_strExpireHeader.QueryCCH() +
                                SIZEOF_CACHE_CONTROL;
            m_dwExpireMode = EXPIRE_MODE_STATIC;

            if ( !StringTimeToFileTime( pszParam,
                                       &m_liExpireTime ))
            {
                m_liExpireTime.QuadPart = 0;
            }
            break;

        case 'd': case 'D':
            dwExpires = strtoul(pszParam,&EndPtr,0);

            if (!isspace((UCHAR)(*EndPtr)) && *EndPtr != '\0')
            {
                SET_VALUE_ERR(pMDErrorInfo);
                return FALSE;
            }

            if ( dwExpires != NO_GLOBAL_EXPIRE )
            {
                if (dwExpires > MAX_GLOBAL_EXPIRE )
                {
                    dwExpires = MAX_GLOBAL_EXPIRE;
                }

                m_dwExpireMode = EXPIRE_MODE_DYNAMIC;
                m_dwExpireDelta = dwExpires;
                m_dwExpireMaxLength = SIZEOF_EXPIRE_HEADER + SIZEOF_GMT_DATETIME;
            }
            break;

        case 'n': case 'N':
            m_dwExpireMode = EXPIRE_MODE_OFF;
            break;

        default:
            SET_VALUE_ERR(pMDErrorInfo);
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
    }

    return TRUE;
}

#define RMD_ASSERT(x) if (!(x)) {   pMDErrorInfo->IsValid = TRUE; \
                                    pMDErrorInfo->ErrorParameter = pMDRecord->dwMDIdentifier; \
                                    pMDErrorInfo->ErrorReason = METADATA_ERROR_TYPE;\
                                    SetLastError(ERROR_INVALID_PARAMETER);\
                                    return FALSE; \
                                    }

BOOL
W3_METADATA::HandlePrivateProperty(
    LPSTR                   pszURL,
    PIIS_SERVER_INSTANCE    pInstance,
    METADATA_GETALL_INTERNAL_RECORD  *pMDRecord,
    PVOID                   pDataPointer,
    BUFFER                  *pBuffer,
    DWORD                   *pdwBytesUsed,
    PMETADATA_ERROR_INFO    pMDErrorInfo
    )
/*++

Routine Description:

    Handle metadata properties specific to W3

Arguments:

    pszURL - URL for which we are reading metadata
    pInstance - current w3 instance
    pMDRecord - metadata record to process
    pDataPointer - data associated with pMDRecord

Return value:

    TRUE if success, otherwise FALSE

--*/
{
    BUFFER              bufTemp1;
    PW3_METADATA_INFO   pMDInfo;
    CHAR                *pszStart;

    pMDErrorInfo->ErrorParameter = pMDRecord->dwMDIdentifier;

    if (*pdwBytesUsed == 0)
    {
        if (!pBuffer->Resize(sizeof(W3_METADATA_INFO)))
        {
            SET_WIN32_ERR(pMDErrorInfo, GetLastError());
            return FALSE;
        }

        *pdwBytesUsed = sizeof(W3_METADATA_INFO);

    }


    switch( pMDRecord->dwMDIdentifier )
    {
        CHAR        *pszTemp;
        DWORD       dwTemp;

        case MD_ANONYMOUS_USER_NAME:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );

            if ( *(CHAR*)pDataPointer == '\0' )
            {
                SET_VALUE_ERR(pMDErrorInfo);
                return FALSE;
            }

            if ( !SetAnonUserName( (CHAR *) pDataPointer ) ||
                 !BuildAnonymousAcctDesc( QueryAuthentInfo() ))
            {
                return FALSE;
            }

#if defined(CAL_ENABLED)
            CalExemptAddRef( (CHAR *) pDataPointer, &m_dwCalHnd );
#endif
            break;

        case MD_ANONYMOUS_PWD:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );

            if ( !SetAnonUserPassword( (CHAR *) pDataPointer ) ||
                 !BuildAnonymousAcctDesc( QueryAuthentInfo() ))
            {
                return FALSE;
            }

            break;

        case MD_ANONYMOUS_USE_SUBAUTH:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetUseAnonSubAuth( *((UNALIGNED DWORD *) pDataPointer ));
            break;

        case MD_DEFAULT_LOGON_DOMAIN:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );

            if ( !SetDefaultLogonDomain( (CHAR *) pDataPointer ))
            {
                return FALSE;
            }
            break;

        case MD_LOGON_METHOD:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            
            //
            // The MD_LOGON_METHOD values in the metabase don't match the NT logon
            // values, so we'll convert them
            //
            // Win64 UNALIGNED pointer fix
            switch ( *((UNALIGNED DWORD *) pDataPointer ) )
            {
            case MD_LOGON_BATCH:
                SetLogonMethod( LOGON32_LOGON_BATCH );
                break;

            case MD_LOGON_INTERACTIVE:
                SetLogonMethod( LOGON32_LOGON_INTERACTIVE );
                break;

            case MD_LOGON_NETWORK:
                SetLogonMethod( LOGON32_LOGON_NETWORK );
                break;
                
            case MD_LOGON_NETWORK_CLEARTEXT:
                SetLogonMethod( LOGON32_LOGON_NETWORK_CLEARTEXT );
                break;

            default:
                return FALSE;
            }

            break;

        case MD_AUTHORIZATION:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            if ( QuerySingleAccessToken() )
            {
                // Win64 UNALIGNED pointer fix
                SetAuthentication( (*((UNALIGNED DWORD *) pDataPointer)&~MD_AUTH_BASIC ));
            }
            else
            {
                // Win64 UNALIGNED pointer fix
                SetAuthentication( *((UNALIGNED DWORD *) pDataPointer ));
            }
            break;

        case MD_AUTHORIZATION_PERSISTENCE:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetAuthenticationPersistence( *((UNALIGNED DWORD *) pDataPointer ));
            break;

        case MD_REALM:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );

            if ( !SetRealm( (CHAR *)pDataPointer ))
            {
                return FALSE;
            }
            break;

        case MD_DEFAULT_LOAD_FILE:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            if (!QueryDefaultDocs()->Copy((const CHAR *)pDataPointer))
            {
                SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                return FALSE;
            }
            break;

        case MD_DIRECTORY_BROWSING:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetDirBrowseFlags( *((UNALIGNED DWORD *) pDataPointer ));
            break;

        case MD_MIME_MAP:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == MULTISZ_METADATA );

            if ( *((CHAR *)pDataPointer) )
            {
                if (!CompactParameters(QueryMimeMap(), (CHAR *)pDataPointer,
                                                2, 0x2, pMDErrorInfo))
                {
                    return FALSE;
                }
            }
            break;

        case MD_SCRIPT_MAPS:

            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == MULTISZ_METADATA );

            if ( *((CHAR *)pDataPointer) )
            {
                if (!CompactParameters(&bufTemp1, (CHAR *)pDataPointer, 0xffffffff,
                            0x02, pMDErrorInfo))
                {
                    return FALSE;
                }


                if (!BuildExtMap((CHAR *)bufTemp1.QueryPtr()))
                {

                    if (GetLastError() == ERROR_INVALID_DATA)
                    {
                        // Return the specific error that the script map is bad
                        SET_VALUE_ERR(pMDErrorInfo);
                    }
                    else
                    {
                        // Handle other errors
                        SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                    }

                    return FALSE;
                }
            }
            break;

        case MD_HTTP_EXPIRES:

            // An Expires value. Range check it, and then format it and
            // save it in the metadata.

            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );

            return SetExpire( (CHAR*)pDataPointer, pMDErrorInfo );

        case MD_HTTP_PICS:
        case MD_HTTP_CUSTOM:

            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == MULTISZ_METADATA );

            // Copies these headers into our header structure. If it fails,
            // free our metadata and give up.


            pszStart = (CHAR *)pDataPointer;

            while ( *pszStart != '\0' )
            {
                DWORD       dwLength;

                dwLength = strlen(pszStart);

                if ( !QueryHeaders()->Append( pszStart,
                                                   dwLength ) ||
                       !QueryHeaders()->Append( "\r\n",
                                                sizeof("\r\n") - 1) )
                {
                    SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                    return FALSE;
                }

                pszStart += (dwLength + 1);

            }
            break;

        case MD_CREATE_PROCESS_AS_USER:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetCreateProcessAsUser( *((UNALIGNED DWORD *) pDataPointer ));
            break;

        case MD_CREATE_PROC_NEW_CONSOLE:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetCreateProcessNewConsole( *((UNALIGNED DWORD *) pDataPointer ));
            break;

        case MD_HTTP_REDIRECT:
        {
            STACK_STR(      strRealSource, MAX_PATH );
            STACK_STR(      strDestination, MAX_PATH );

            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( (pMDRecord->dwMDDataType == STRING_METADATA) ||
                        (pMDRecord->dwMDDataType == MULTISZ_METADATA) );

            if ( !strDestination.Copy( (CHAR*) pDataPointer ) ||
                 !GetTrueRedirectionSource( pszURL,
                                            pInstance,
                                            (CHAR*) pDataPointer,
                                            pMDRecord->dwMDDataType == STRING_METADATA,
                                            &strRealSource ) ||
                 !SetRedirectionBlob( strRealSource,
                                      strDestination ) )
            {
                return FALSE;
            }

            if (pMDRecord->dwMDDataType == MULTISZ_METADATA)
            {
                // Have some conditional headers, add them now.
                //
                DBG_ASSERT(QueryRedirectionBlob() != NULL);

                if (!QueryRedirectionBlob()->SetConditionalHeaders(
                    (CHAR *)pDataPointer + strlen((CHAR *)pDataPointer) + 1)
                    )
                {
                    SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                    return FALSE;
                }

            }

            break;
        }

        case MD_CUSTOM_ERROR:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == MULTISZ_METADATA );

            // Treat a NULL custom error string as not being present.

            if (*(CHAR *)pDataPointer == '\0')
            {
                break;
            }

            if (!BuildCustomErrorTable( (CHAR *) pDataPointer,pMDErrorInfo ))
            {
                return FALSE;
            }

            break;

        case MD_FOOTER_DOCUMENT:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );

            if (!ReadCustomFooter((CHAR *)pDataPointer,
                    pInstance->GetTsvcCache(),
                    g_hSysAccToken,
                    pMDErrorInfo
                    ))
            {
                return FALSE;
            }
            break;

        case MD_FOOTER_ENABLED:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            if (*(UNALIGNED DWORD *)pDataPointer == 0)
            {
                SetFooterEnabled(FALSE);
                SetFooter(0, NULL);
            }
            break;

        case MD_SSI_EXEC_DISABLED:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetSSIExecDisabled( !!*((UNALIGNED DWORD *) pDataPointer) );
            break;

        case MD_SCRIPT_TIMEOUT:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetCGIScriptTimeout( *((UNALIGNED DWORD *) pDataPointer ) );
            break;

        case MD_POOL_IDC_TIMEOUT:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetPoolIDCTimeout( *((UNALIGNED DWORD *) pDataPointer ) );
            break;

        case MD_NTAUTHENTICATION_PROVIDERS:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            // Win64 UNALIGNED pointer fix
            if ( !BuildProviderList( (CHAR *) pDataPointer ))
            {
                return FALSE;
            }
            break;

        case MD_ALLOW_KEEPALIVES:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetAllowKeepAlives( *((UNALIGNED DWORD *) pDataPointer ) );
            break;

        case MD_CACHE_EXTENSIONS:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetCacheISAPIApps( *((UNALIGNED DWORD *) pDataPointer ) );
            break;

        case MD_DO_REVERSE_DNS:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            m_fDoReverseDns = !!*((UNALIGNED DWORD *) pDataPointer);
            break;

        case MD_NOTIFY_EXAUTH:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            m_dwNotifyExAuth = *((UNALIGNED DWORD *) pDataPointer);
            break;

        case MD_CC_NO_CACHE:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            if (*(UNALIGNED DWORD *)pDataPointer != 0)
            {
                SetConfigNoCache();

                if (QueryExpireMode() == EXPIRE_MODE_NONE)
                {
                    return SetExpire("d, 0", pMDErrorInfo);
                }
            }
            break;

        case MD_CC_MAX_AGE:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );

            pMDInfo = (PW3_METADATA_INFO)pBuffer->QueryPtr();
            // Win64 UNALIGNED pointer fix
            pMDInfo->dwMaxAge = *(UNALIGNED DWORD *)pDataPointer;

            SetHaveMaxAge();
            break;

        case MD_CC_OTHER:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );

            if (*(CHAR *)pDataPointer != '\0')
            {
                if (!m_strCacheControlHeader.Copy("Cache-Control: ",
                    sizeof("Cache-Control: ") - 1) ||
                    !m_strCacheControlHeader.Append((CHAR *)pDataPointer))
                {
                    SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                    return FALSE;
                }
            }
            break;

        case MD_REDIRECT_HEADERS:

            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == MULTISZ_METADATA );

            // Copies these headers into our redirect header structure.
            pszStart = (CHAR *)pDataPointer;

            while ( *pszStart != '\0' )
            {
                DWORD       dwLength;

                dwLength = strlen(pszStart);

                if ( !QueryRedirectHeaders()->Append( pszStart,
                                                   dwLength ) ||
                       !QueryRedirectHeaders()->Append( "\r\n",
                                                sizeof("\r\n") - 1) )
                {
                    SET_WIN32_ERR(pMDErrorInfo, GetLastError());
                    return FALSE;
                }

                pszStart += (dwLength + 1);

            }
            break;

        case MD_UPLOAD_READAHEAD_SIZE:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetUploadReadAhead( *((UNALIGNED DWORD *) pDataPointer ) );
            break;

        case MD_PUT_READ_SIZE:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetPutReadSize( *((UNALIGNED DWORD *) pDataPointer ) );
            break;

        case MD_CPU_CGI_ENABLED:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
#ifdef _WIN64
//            SetJobCGIEnabled( *((CHAR *) pDataPointer ));
            // Win64 UNALIGNED pointer fix
            SetJobCGIEnabled( *((UNALIGNED DWORD *) pDataPointer ));
#else
            SetJobCGIEnabled( *((DWORD *) pDataPointer ));
#endif
            break;

        case MD_VR_IGNORE_TRANSLATE:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // Win64 UNALIGNED pointer fix
            SetIgnoreTranslate( *((UNALIGNED DWORD *) pDataPointer) );
            break;
        
        case MD_USE_DIGEST_SSP:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            SetUseDigestSSP( *((UNALIGNED DWORD *) pDataPointer) );
            break;

    }

    return TRUE;
}

BOOL
W3_METADATA::SetCCHeader(
    BOOL            bNoCache,
    BOOL            bMaxAge,
    DWORD           dwMaxAge
    )
/*++

Routine Description:

    Build a Cache-Control header with no-cache or max-age=.

Arguments:

    bNoCache        - True if we're to build a no-cache header.
    bMaxAge         - True if we're to build a max-age= header.
    dwMaxAge        - Max-Age to use.


Return value:

    TRUE if success, otherwise FALSE

--*/
{
    CHAR                cMaxAgeBuffer[34];
    BOOL                bHaveCCHeader;
    METADATA_ERROR_INFO DummyError;

    bHaveCCHeader = !m_strCacheControlHeader.IsEmpty();

    //
    // If we don't already have the basic Cache-Control: header, add it.
    //

    if (!bHaveCCHeader)
    {
        if (!m_strCacheControlHeader.Copy("Cache-Control: ",
            sizeof("Cache-Control: ") - 1) )
        {
            return FALSE;
        }

    }

    //
    // Now see if we're to add a no-cache or max-age= header.
    //
    if (bNoCache)
    {
        // It's a no-cache, this is straightforward.
        //
        if (!m_strCacheControlHeader.Append(bHaveCCHeader ?
                ",no-cache" : "no-cache",
                sizeof("no-cache") - (bHaveCCHeader ? 0 : 1) ))
        {
            return FALSE;
        }
    }
    else
    {
        if (bMaxAge)
        {
            // Add a max-age header. First convert it to a string.
            // We build the string at an offset into the MaxAge buffer
            // so later we can convert the MaxAge buffer into a string
            // suitable for SetExpire if we need to.

            _itoa(dwMaxAge, &cMaxAgeBuffer[2], 10);

            if (!m_strCacheControlHeader.Append(bHaveCCHeader ?
                    ",max-age=" : "max-age=",
                    sizeof("max-age=") - (bHaveCCHeader ? 0 : 1) ))
            {
                return FALSE;
            }

            if (!m_strCacheControlHeader.Append(&cMaxAgeBuffer[2]))
            {
                return FALSE;
            }

            // Now, if we don't already have an expiration time, set one.
            if (QueryExpireMode() == EXPIRE_MODE_NONE)
            {
                cMaxAgeBuffer[0] = 'd';
                cMaxAgeBuffer[1] = ',';

                if (!SetExpire(cMaxAgeBuffer, &DummyError))
                {
                    return FALSE;
                }

            }
        }
    }

    return TRUE;
}

BOOL
W3_METADATA::FinishPrivateProperties(
    BUFFER                  *pBuffer,
    DWORD                   dwBytesUsed,
    BOOL                    bSucceeded
    )
/*++

Routine Description:

    Finish processing of private W3 metadata properties.

Arguments:

    pBuffer         - Pointer to BUFFER containing info gathered during
                        calls to HandlePrivateProperty.
    dwBytesUsed     - Size in bytes of buffer pointed to by pBuffer
    bSucceede       - TRUE iff we read all private properties successfully.

Return value:

    TRUE if success, otherwise FALSE

--*/
{
    PW3_METADATA_INFO   pMDInfo;
    BOOL                bHaveCCHeader;

    if (dwBytesUsed != 0 && dwBytesUsed != sizeof(W3_METADATA_INFO))
    {
        return FALSE;
    }

    pMDInfo = (PW3_METADATA_INFO)pBuffer->QueryPtr();

    if (bSucceeded)
    {

        bHaveCCHeader = !m_strCacheControlHeader.IsEmpty();

        if (QueryExpireMode() == EXPIRE_MODE_OFF)
        {
            ClearConfigNoCache();
            ClearHaveMaxAge();
        }
        else
        {
            if (QueryConfigNoCache() || QueryHaveMaxAge())
            {
                // We have some sort of cache-control header to add here.

                if (!SetCCHeader(QueryConfigNoCache(), QueryHaveMaxAge(),
                     QueryHaveMaxAge() ? pMDInfo->dwMaxAge : 0))
                {
                    return FALSE;
                }

                bHaveCCHeader = TRUE;


            }
            else
            {
                //
                // We don't have either a max-age or no-cache header. If we have
                // a dynamic Expires header, create a max-age header now.
                //
                if (QueryExpireMode() == EXPIRE_MODE_DYNAMIC)
                {
                    DWORD       dwDelta = QueryExpireDelta();
                    BOOL        SetCCRetVal;

                    if (dwDelta != 0)
                    {
                        SetCCRetVal = SetCCHeader(FALSE, TRUE, dwDelta);
                    }
                    else
                    {
                        SetCCRetVal = SetCCHeader(TRUE, FALSE, 0);
                    }

                    if (!SetCCRetVal)
                    {
                        return FALSE;
                    }

                    bHaveCCHeader = TRUE;
                }
                else
                {
                    if (QueryExpireMode() == EXPIRE_MODE_STATIC)
                    {
                        // We have a static expiration data and no configured
                        // max-age or no-cache controls. If we don't have a
                        // cache-control header built, build one, and leave off
                        // the trailing CRLF, that'll be added later when we build
                        // the whole header.

                        if (!bHaveCCHeader)
                        {
                            if (!m_strCacheControlHeader.Copy("Cache-Control: ",
                                sizeof("Cache-Control: ") - 1) )
                            {
                                return FALSE;
                            }

                        }
                        else
                        {
                            // Already have a header, append a comma.
                            if (!m_strCacheControlHeader.Append(",",
                                    sizeof(",") - 1) )
                            {
                                return FALSE;
                            }
                        }

                        bHaveCCHeader = FALSE;
                    }
                }
            }
        }



        if (bHaveCCHeader)
        {
            if ( !m_strCacheControlHeader.Append("\r\n", sizeof("\r\n") - 1))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

#define DEFINE_MD_MAP(x) {x, #x }

struct MDIDMap
{
    DWORD       MDID;
    CHAR        *IDName;

} MDIDMappingTable[] =
{
    DEFINE_MD_MAP(MD_AUTHORIZATION),
    DEFINE_MD_MAP(MD_REALM),
    DEFINE_MD_MAP(MD_HTTP_EXPIRES),
    DEFINE_MD_MAP(MD_HTTP_PICS),
    DEFINE_MD_MAP(MD_HTTP_CUSTOM),
    DEFINE_MD_MAP(MD_DIRECTORY_BROWSING),
    DEFINE_MD_MAP(MD_DEFAULT_LOAD_FILE),
    DEFINE_MD_MAP(MD_CONTENT_NEGOTIATION),
    DEFINE_MD_MAP(MD_CUSTOM_ERROR),
    DEFINE_MD_MAP(MD_FOOTER_DOCUMENT),
    DEFINE_MD_MAP(MD_FOOTER_ENABLED),
    DEFINE_MD_MAP(MD_HTTP_REDIRECT),
    DEFINE_MD_MAP(MD_DEFAULT_LOGON_DOMAIN),
    DEFINE_MD_MAP(MD_LOGON_METHOD),
    DEFINE_MD_MAP(MD_SCRIPT_MAPS),
    DEFINE_MD_MAP(MD_MIME_MAP),
    DEFINE_MD_MAP(MD_ACCESS_PERM),
#if 0
    DEFINE_MD_MAP(MD_HEADER_DOCUMENT),
    DEFINE_MD_MAP(MD_HEADER_ENABLED),
#endif
    DEFINE_MD_MAP(MD_IP_SEC),
    DEFINE_MD_MAP(MD_ANONYMOUS_USER_NAME),
    DEFINE_MD_MAP(MD_ANONYMOUS_PWD),
    DEFINE_MD_MAP(MD_ANONYMOUS_USE_SUBAUTH),
    DEFINE_MD_MAP(MD_DONT_LOG),
    DEFINE_MD_MAP(MD_ADMIN_ACL),
    DEFINE_MD_MAP(MD_SSI_EXEC_DISABLED),
    DEFINE_MD_MAP(MD_DO_REVERSE_DNS),
    DEFINE_MD_MAP(MD_SSL_ACCESS_PERM),
    DEFINE_MD_MAP(MD_AUTHORIZATION_PERSISTENCE),
    DEFINE_MD_MAP(MD_NTAUTHENTICATION_PROVIDERS),
    DEFINE_MD_MAP(MD_SCRIPT_TIMEOUT),
    DEFINE_MD_MAP(MD_CACHE_EXTENSIONS),
    DEFINE_MD_MAP(MD_CREATE_PROCESS_AS_USER),
    DEFINE_MD_MAP(MD_CREATE_PROC_NEW_CONSOLE),
    DEFINE_MD_MAP(MD_POOL_IDC_TIMEOUT),
    DEFINE_MD_MAP(MD_ALLOW_KEEPALIVES),
    DEFINE_MD_MAP(MD_IS_CONTENT_INDEXED),
    DEFINE_MD_MAP(MD_NOTIFY_EXAUTH),
    DEFINE_MD_MAP(MD_CC_NO_CACHE),
    DEFINE_MD_MAP(MD_CC_MAX_AGE),
    DEFINE_MD_MAP(MD_CC_OTHER),
    DEFINE_MD_MAP(MD_REDIRECT_HEADERS),
    DEFINE_MD_MAP(MD_UPLOAD_READAHEAD_SIZE),
    DEFINE_MD_MAP(MD_PUT_READ_SIZE)
};

CHAR *
MapMetaDataID(
    DWORD           dwMDID
    )
/*++

Routine Description:

    Map a DWORD metadata identifier to it's name as an ASCII string.
Arguments:

    dwMDID          - Identifier to be mapped.

Return value:

    String describing identifier

--*/
{
    DWORD           i;

    for (i = 0; i < (sizeof(MDIDMappingTable)/sizeof(struct MDIDMap)); i++)
    {
        if (MDIDMappingTable[i].MDID == dwMDID)
        {
            return MDIDMappingTable[i].IDName;
        }
    }

    return "an unknown metabase property";
}

BOOL
HTTP_REQUEST::SendMetaDataError(
    PMETADATA_ERROR_INFO        pErrorInfo
    )
/*++

Routine Description:

    Look at the error information returned from a previous call to
    ReadMetaData(), and format and send an appropriate error message.

Arguments:

    pErrorInfo          - Pointer to the returned error information.

Return value:

    TRUE if success, otherwise FALSE

--*/
{
    STACK_STR(strBody, 80);
    STACK_STR(strResp, 80);
    STACK_STR(strWin32Error, 80);
    DWORD       dwContentLength;
    BOOL        fDone;
    BOOL        bHaveCustomError = FALSE;
    BOOL        fRet;
    CHAR        *IDName;
    CHAR        szMDID[17];
    CHAR        szCL[17];
    CHAR        szWin32Error[17];
    DWORD       dwCurrentSize;
    DWORD       dwBytesNeeded;
    DWORD       dwCLLength;
    CHAR        *pszTail;

    if (!pErrorInfo->IsValid)
    {
        return FALSE;
    }

    //
    // First check to see if we've got a custom error handler set up for this.
    //

    if (CheckCustomError(&strBody, HT_SERVER_ERROR, 0, &fDone, &dwContentLength))
    {
        // Had at least some custom error processing. If we're done, we can
        // return, but set a flag telling our callers not to disconnect, since
        // we're still processing.

        if (fDone)
        {
            _fNoDisconnectOnError = TRUE;
           return TRUE;
        }

        bHaveCustomError = TRUE;

    }

    //
    // Build the error string and header fields. If we didn't have a custom
    // error, load an error body string from.

    if (!bHaveCustomError)
    {
        fRet = BuildStatusLine( &strResp, HT_SERVER_ERROR,
                            IDS_METADATA_CONFIG_ERROR + pErrorInfo->ErrorReason,
                            QueryURL(),
                            &strBody);

        dwContentLength = strBody.QueryCB();
    }
    else
    {
        fRet = BuildStatusLine( &strResp, HT_SERVER_ERROR, 0, QueryURL(), NULL );
    }

    if (!fRet)
    {
        // Trouble building the status line.
        return FALSE;
    }

    // Now build the various header fields.
    strResp.SetLen(strlen((CHAR *)strResp.QueryPtr()));
    SetKeepConn(FALSE);
    SetAuthenticationRequested(FALSE);

    fDone = FALSE;

    if ( !BuildBaseResponseHeader( QueryRespBuf(), &fDone, &strResp,
                                    HTTPH_NO_CUSTOM)
       )
    {
        // Couldn't build the headers, so return.
        return FALSE;
    }

    //
    // If it failed because of a Win32 error, load a descriptive string.
    //

    if (pErrorInfo->ErrorReason == METADATA_ERROR_WIN32)
    {
        if ( !g_pInetSvc->LoadStr( strWin32Error, pErrorInfo->Win32Error ))
        {
            // Couldn't load the string, convert the error number and
            // use that.
            _itoa(pErrorInfo->Win32Error, szWin32Error, 10);

            if (!strWin32Error.Copy(szWin32Error))
            {
                return FALSE;
            }
        }

        // Adjust content length for extra %s.
        dwContentLength -= sizeof("%s") - 1;
    }

    // OK, we've built everything. Map the metabase ID to a string, and
    // format the message.


    IDName = MapMetaDataID(pErrorInfo->ErrorParameter);
    _itoa( pErrorInfo->ErrorParameter, szMDID, 10 );

    // Adjust content length for size of strings we're adding in, and for
    // the formatting characters.

    dwContentLength += strlen(szMDID) + strlen(IDName) + strWin32Error.QueryCB();

    dwContentLength -= (sizeof("%s") - 1) * 2;

    _itoa( dwContentLength, szCL, 10 );

    dwCLLength = strlen(szCL);

    // Make sure we have enough room in the response buffer.

    dwCurrentSize = strlen(QueryRespBufPtr());

    dwBytesNeeded = dwCurrentSize + dwContentLength + dwCLLength +
                    sizeof("Content-Length: \r\n") - 1 +
                    sizeof("Content-Type: text/html\r\n") - 1;

    if (!QueryRespBuf()->Resize(dwBytesNeeded))
    {
        return FALSE;
    }

    // Everything's set up, go ahead and copy it into the buffer.

    pszTail = QueryRespBufPtr() + dwCurrentSize;

    APPEND_STRING(pszTail, "Content-Length: ");
    memcpy(pszTail, szCL, dwCLLength + 1);
    pszTail += dwCLLength;
    APPEND_STRING(pszTail, "\r\n");

    if (!bHaveCustomError)
    {
        APPEND_STRING(pszTail, "Content-Type: text/html\r\n\r\n");
    }


    pszTail += wsprintf(pszTail, strBody.QueryStr(), IDName, szMDID,
                                    strWin32Error.QueryStr());

    // Now send the header.
    if ( !SendHeader( QueryRespBufPtr(), (DWORD) (pszTail - QueryRespBufPtr()),
                      IO_FLAG_SYNC, &fDone ))
    {
        return FALSE;
    }

    _fDiscNoError = TRUE;

    return TRUE;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\wamexec.cxx ===
/*-----------------------------------------------------------------------------

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       wamexec.cxx

   Abstract:
       This module executes a wam request

   Author:
       David Kaplan    ( DaveK )     11-Mar-1997
       Lei Jin                  (leijin)         24-Apr-1997    (WamInfo & WamDictator)

   Environment:
       User Mode - Win32

   Project:
       W3 services DLL

-----------------------------------------------------------------------------*/

#include <w3p.hxx>
#include "wamexec.hxx"
#include "wamreq.hxx"
#include <wmrgexp.h>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <issched.hxx>

#define dwMDDefaultTimeOut 2000

#define PERIODIC_RESTART_TIME_DEFAULT       0
#define PERIODIC_RESTART_REQUESTS_DEFAULT	0
#define SHUTDOWN_TIME_LIMIT_DEFAULT			600

/*-----------------------------------------------------------------------------
 Globals
-----------------------------------------------------------------------------*/
WAM_DICTATOR *   g_pWamDictator;      // global wam dictator
PFN_INTERLOCKED_COMPARE_EXCHANGE g_pfnInterlockedCompareExchange = NULL;
static VOID UnloadNTApis(VOID);
static VOID LoadNTApis(VOID);

// Default Package name, defined in wamreg.h, shared by wamreg.dll.
WCHAR   g_szIISInProcWAMCLSID[]     = W3_INPROC_WAM_CLSID;
WCHAR   g_szIISOOPPoolWAMCLSID[]    = W3_OOP_POOL_WAM_CLSID;
WCHAR   g_szIISOOPPoolPackageID[]   = W3_OOP_POOL_PACKAGE_ID;
// Sink function at wamreg.dll
// This function will get called when user change application configuration on the fly.
//
HRESULT W3SVC_WamRegSink(       LPCSTR  szAppPath,
                                const DWORD     dwCommand,
                                DWORD*  pdwResult
                        );


/*-----------------------------------------------------------------------------
CreateWamRequestInstance
    Similar to CoCreateInstance followed by QueryInterface

Arguments:
    pHttpRequest - pointer to the HTTP REQUEST object containing all information
                   about the current request.
    pExec        - Execution descriptor block
    pstrPath     - Fully qualified path to Isapi DLL
    pWamInfo     - pointer to wam-info which will process this request
        ppWamRequestOut -pointer to a pointer that contains the return WamRequest.

Return Value:
    HRESULT

-----------------------------------------------------------------------------*/
HRESULT
CreateWamRequestInstance
(
HTTP_REQUEST    *       pHttpRequest,
EXEC_DESCRIPTOR *       pExec,
const STR *             pstrPath,
CWamInfo *              pWamInfo,
WAM_REQUEST **          ppWamRequestOut
)
    {
    HRESULT hr = NOERROR;
    WAM_REQUEST *   pWamRequest =
        new WAM_REQUEST(
                  pHttpRequest
                , pExec
                ,  pWamInfo
                );

    *ppWamRequestOut = NULL;
     if( pWamRequest == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    // Init the wam req
    hr = pWamRequest->InitWamRequest( pstrPath );

    if ( FAILED( hr ) )
        {

        DBGPRINTF((
              DBG_CONTEXT
            , "CreateWamRequestInstance - "
              "failed to init wam request. "
              "pHttpRequest(%08x) "
              "pWamInfo(%08x) "
              "pstrPath(%s) "
              "hr(%d) "
              "\n"
            , pHttpRequest
            , pWamInfo
            , pstrPath
            , hr
        ));

        delete pWamRequest;
        pWamRequest = NULL;
        goto LExit;

        }

    pWamRequest->AddRef();

    *ppWamRequestOut = pWamRequest;

LExit:
    return hr;
    }

/*-----------------------------------------------------------------------------
WAM_DICTATOR::ProcessWamRequest
    This function finds a WamInfo and makes a call to the WamInfo to process a Http Server
    Extension Request.
    It uses the HTTP_REQUEST passed in as well as the EXEC_DESCRIPTOR.

Arguments:
    pHttpRequest - pointer to the HTTP REQUEST object containing all information
                   about the current request.
    pExec        - Execution descriptor block
    pstrPath     - Fully qualified path to Module (DLL or ComIsapi ProgId)
    pfHandled    - Indicates we handled this request
    pfFinished   - Indicates no further processing is required

Return Value:
    HRESULT
-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::ProcessWamRequest
(
HTTP_REQUEST    *       pHttpRequest,
EXEC_DESCRIPTOR *       pExec,
const STR *             pstrPath,
BOOL *                  pfHandled,
BOOL *                  pfFinished
)
    {

    HRESULT                 hr = NOERROR;
    CWamInfo*               pWamInfo = NULL;
    STR     *                       pstrAppPath = NULL;
    CLSID                   clsidWam;
    BOOL                    fRet = FALSE;

    DBG_ASSERT(pHttpRequest);
    DBG_ASSERT(pExec);

    if (m_fShutdownInProgress)
        {
        DBGPRINTF((DBG_CONTEXT, "Wam Dictator: Shut down in progress, stops serving requests.\n"));

        // Signal the child event to indicate that the request should terminate.
        if ( pExec->IsChild() ) {
            pExec->SetChildEvent();
        }

        return E_FAIL;
        }

    pstrAppPath = pExec->QueryAppPath();

    if (pstrAppPath == NULL)
        {
        hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
        goto LExit;
        }

    hr = GetWamInfo( pstrAppPath, pHttpRequest, &pWamInfo );
    if ( FAILED(hr) )
        {
        DBGPRINTF(( DBG_CONTEXT,
                   "WAM_DICTATOR::ProcessWamRequest: GetWamInfo failed, hr = %08x\n",
                   hr
                   ));

        //
        //  For Child execution just return the error and don't
        //  disconnect, otherwise a race ensues between SSI and the disconnect
        //  cleanup
        //

        if ( pExec->IsChild() )
            {
            SetLastError( hr );
            goto LExit;
            }

        //
        // Since WAM_DICTATOR is going to send some message to the browser, we need
        // to set pfHandled = TRUE here.
        //
        *pfHandled = TRUE;

        if (W3PlatformType == PtWindows95)
            {
            pHttpRequest->SetLogStatus( HT_SERVER_ERROR, hr);
            // Win95 platform, no event log, special message without mention EventLog.
            pHttpRequest->Disconnect(HT_SERVER_ERROR, IDS_WAM_FAILTOLOADONW95_ERROR, TRUE, pfFinished);
            }
        else
            {
            //
            // Log to Event Log first.
            //
            const CHAR      *pszEventLog[2];
            CHAR szErrorDescription[2048];
            CHAR * pszErrorDescription = NULL;
            HANDLE hMetabase = GetModuleHandle( "METADATA.DLL" );

            if(FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    hMetabase,
                    hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &pszErrorDescription,
                    sizeof(szErrorDescription) - 1,
                    NULL
                    ) && pszErrorDescription )
            {
                strcpy(szErrorDescription, pszErrorDescription);
                LocalFree(pszErrorDescription);

            } else {
                wsprintf(szErrorDescription, "%08x", hr);
            }

            pszEventLog[0] = pstrAppPath->QueryStr();
            pszEventLog[1] = szErrorDescription;
            // Event log
            g_pInetSvc->LogEvent(W3_EVENT_FAIL_LOADWAM,
                                                    2,
                                                    pszEventLog,
                                                    0);

            pHttpRequest->SetLogStatus( HT_SERVER_ERROR, hr);
            pHttpRequest->Disconnect(HT_SERVER_ERROR, IDS_WAM_FAILTOLOAD_ERROR, TRUE, pfFinished);
            }
        //
        // Since we already called Disconnect, WAM_DICTATOR should return TRUE to high level.
        //
        hr = NOERROR;
        goto LExit;
        }

    hr = pWamInfo->ProcessWamRequest(pHttpRequest, pExec, pstrPath, pfHandled,pfFinished);

LExit:
    return hr;
    } // WAM_DICTATOR::ProcessWamRequest()

/*-----------------------------------------------------------------------------*
WAM_DICTATOR::WAM_DICTATOR
    Constructor

Arguments:
    None

Return Value:
    None
-----------------------------------------------------------------------------*/

WAM_DICTATOR::WAM_DICTATOR
(
)
:
//m_pPackageCtl(NULL),
m_cRef(0),
m_pMetabase(NULL),
m_fCleanupInProgress(FALSE),
m_fShutdownInProgress(FALSE),
m_hW3Svc ( (HANDLE)NULL ),
m_dwScheduledId (0),
m_strRootAppPath("/LM/W3SVC"),
m_HashTable(LK_DFLT_MAXLOAD, LK_DFLT_INITSIZE, LK_DFLT_NUM_SUBTBLS),
m_pidInetInfo(0)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::WAM_DICTATOR\n"));

    InitializeListHead(&m_DyingListHead);

    INITIALIZE_CRITICAL_SECTION(&m_csWamCreation);
    INITIALIZE_CRITICAL_SECTION(&m_csDyingList);

    m_PTable.Init();
    //
    // Init wamreq allocation cache
    //

    DBG_REQUIRE( WAM_REQUEST::InitClass() );

    }//WAM_DICTATOR::WAM_DICTATOR


/*-----------------------------------------------------------------------------*
WAM_DICTATOR::~WAM_DICTATOR
    Destructor

Arguments:
    None
                                                //      (only interesting if out of process)
Return Value:
    None

-----------------------------------------------------------------------------*/
WAM_DICTATOR::~WAM_DICTATOR
(
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::~WAM_DICTATOR\n"));

    DBG_ASSERT(m_cRef == 0);

    DeleteCriticalSection(&m_csWamCreation);
    DeleteCriticalSection(&m_csDyingList);

    m_PTable.UnInit();
    //
    // Uninit wamreq allocation cache
    //
    WAM_REQUEST::CleanupClass();
    }//WAM_DICTATOR::~WAMDICTATOR


/*-----------------------------------------------------------------------------
WAM_DICTATOR::InitWamDictator
    Initializes Wam dictator

Arguments:
    None

Return Value:
    HRESULT

-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::InitWamDictator
(
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::InitWamDictator\n"));

    HRESULT     hr = NOERROR;
    IMDCOM *    pMetabase;


    DBG_ASSERT(g_pInetSvc->QueryMDObject());

    m_pMetabase = new MB( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    if (m_pMetabase == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    // Save the handle of the W3Svc process for use when copying tokens to out of proc Wam's
    // NOTE: this is actually a "pseudo-handle", which is good enough.  Note that pseudo-handles
    // do NOT need to be closed.  CloseHandle is a no-op on a pseudo-handle.
    m_hW3Svc = GetCurrentProcess();

    
    //
    // Get the process id for inetinfo. Under some circumstances com 
    // svcs my get hosed. This causes object activation to happen in 
    // process even if the object is registered to be launched in the
    // surrogate. In order to prevent inetinfo from AV'ing we want to 
    // prevent these applications from running.
    //
    m_pidInetInfo = GetCurrentProcessId();

    DBG_REQUIRE( m_ServerVariableMap.Initialize() );

    // Register the Sink function at WamReg.
    WamReg_RegisterSinkNotify(W3SVC_WamRegSink);

    LoadNTApis();

    // Make the reference count to 1.
    Reference();
LExit:
    return hr;
    }//WAM_DICTATOR::InitWamDictator

/*-----------------------------------------------------------------------------
WAM_DICTATOR::



-----------------------------------------------------------------------------*/
LK_PREDICATE
WAM_DICTATOR::DeleteInShutdown
(
CWamInfo*       pWamInfo,
void*           pvState
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::DeleteInShutdown\n"));

    DWORD dwPriorState;

    dwPriorState = pWamInfo->ChangeToState(WIS_SHUTDOWN);

    DBGPRINTF((DBG_CONTEXT, "Start shutdown, change state to WIS_SHUTDOWN\n"));
    DBG_REQUIRE(dwPriorState == WIS_RUNNING || dwPriorState == WIS_PAUSE || dwPriorState == WIS_CPUPAUSE);

    // remove from the hash table here. and clean up later.
    g_pWamDictator->InsertDyingList(pWamInfo, TRUE);

    return LKP_PERFORM;
    }//WAM_DICTATOR::DeleteInShutdown



/*-----------------------------------------------------------------------------
WAM_DICTATOR::StartShutdown
    Starts to shutdown Wam dictator

Arguments:
    None

Return Value:
    HRESULT
-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::StartShutdown
(
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::StartShutdown\n"));

    HRESULT         hr = NOERROR;
    CWamInfo*       pWamInfo;
    DWORD           dwErr;
    DWORD           dwPriorState;

    InterlockedExchange((LPLONG)&m_fShutdownInProgress, (LONG)TRUE);

    WamReg_UnRegisterSinkNotify();

    m_HashTable.DeleteIf(DeleteInShutdown, NULL);

    return hr;
    }

/*-----------------------------------------------------------------------------*
WAM_DICTATOR::UninitWamDictator
    Un-initializes Wam dictator

Arguments:
    None

Return Value:
    HRESULT
-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::UninitWamDictator
(
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::UninitWamDictator\n"));

    HRESULT     hr = NOERROR;

    // UNDONE leijin thinks we can get rid of this RemoveWorkItem code???
    ScheduledId_Lock();
    if (m_dwScheduledId != 0)
        {
        DBGPRINTF((DBG_CONTEXT, "remove work item %d\n", m_dwScheduledId));
        // Cancel the ScheduleWorkItem
        RemoveWorkItem(m_dwScheduledId);
        m_dwScheduledId = 0;
        }
    ScheduledId_UnLock();
    DBG_ASSERT(m_dwScheduledId == 0);

    // Clean up the dying list.
    CleanUpDyingList();

    // After the CleanUpDyingList() call, this should be an empty list.
    //
    DBG_ASSERT(IsListEmpty(&m_DyingListHead));

    //
    // Allow all other references to WAM_DICTATOR to drain away.
    // This loop is especially important in shutdown during stress scenario.
    // Unload Application while w3svc is still running, a busy application might
    // still have some outstanding HTTPREQUEST unfinished which hold the reference to
    // this WAM_DICTATOR.
    //
    while (m_cRef != 1)
        {
        DBGPRINTF((DBG_CONTEXT, "Still have out-standing reference(%d) to this WAM_DICTATOR\n",
                m_cRef));
        Sleep(20);
        }

    // Delete m_pMetabase
    // pMetabase should be there
    DBG_REQUIRE(m_pMetabase);
    delete m_pMetabase;
    m_pMetabase = NULL;

    UnloadNTApis();

    //
    // Dereference to balance the reference in InitWamDictator. after
    // this Dereference, ref count of WAM_DICTATOR should be 0.
    //
    Dereference();
    DBGPRINTF((DBG_CONTEXT, "Wam Dictator Exits.\n"));
    return hr;
    }//WAM_DICTATOR::UninitWamDictator

/*-----------------------------------------------------------------------------
WAM_DICTATOR::MDGetAppVariables

Giving a Metabase Path, find out the Application Path, WAM CLSID, and Context of WAM object of
the application that apply to the metabase path.

Argument:
szMetabasePath: [in]    A metabase path.
pfAllowApptoRun:        [out]   True, if application is enabled to run.
pclsidWam:              [out]   a pointer to the buffer for WAM CLSID
pfInProcess:            [out]   a pointer to DWORD for Context
pfEnableTryExcept   [out]   a pointer to DWORD for EnableTryExcept flag

Return:
HRESULT
-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::MDGetAppVariables
(
LPCSTR  szMetabasePath,
BOOL*   pfAllowAppToRun,
CLSID*  pclsidWam,
BOOL*   pfInProcess,
BOOL*   pfInPool,
BOOL*   pfEnableTryExcept,
DWORD   *pdwOOPCrashThreshold,
BOOL*   pfJobEnabled,
WCHAR*  wszPackageID,
DWORD*	pdwPeriodicRestartRequests,
DWORD*	pdwPeriodicRestartTime,
MULTISZ*pmszPeriodicRestartSchedule,
DWORD*  pdwShutdownTimeLimit
)
    {
    HRESULT         hr = NOERROR;
    METADATA_RECORD recMetaData;
    DWORD           dwRequiredLen;
    CHAR            szclsidWam[uSizeCLSIDStr];
    WCHAR           wszclsidWam[uSizeCLSIDStr];
    BOOL            fKeyOpen = FALSE;
    DWORD           dwAppMode = 0;
    BOOL            fEnableTryExcept = TRUE;
    DWORD           dwAppState = 0;

    DBG_ASSERT(szMetabasePath);
    DBG_ASSERT(pfAllowAppToRun);
    DBG_ASSERT(pclsidWam);
    DBG_ASSERT(pfInProcess);
    DBG_ASSERT(pfInPool);
    DBG_ASSERT(pfEnableTryExcept);
    DBG_ASSERT(pdwOOPCrashThreshold);
    DBG_ASSERT(pfJobEnabled);
    DBG_ASSERT(m_pMetabase);
    DBG_ASSERT(wszPackageID);
	DBG_ASSERT(pdwPeriodicRestartRequests);
	DBG_ASSERT(pdwPeriodicRestartTime);
	DBG_ASSERT(pmszPeriodicRestartSchedule);
	DBG_ASSERT(pdwShutdownTimeLimit);

    wszPackageID[0] = L'\0';
    // Open Key
    if (!m_pMetabase->Open(szMetabasePath, METADATA_PERMISSION_READ))
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto LErrExit;
            }
    fKeyOpen = TRUE;

    // if MD_APP_STATE exists, and is defined with a value APPSTATUS_PAUSE,
    // then, fAllowAppToRun is set to FALSE
    // otherwise, fAllowAppToRun is set to TRUE
    if (m_pMetabase->GetDword("", MD_APP_STATE, IIS_MD_UT_WAM, (DWORD *)&dwAppState, METADATA_INHERIT))
        {
        if (dwAppState == APPSTATUS_PAUSE)
            {
            *pfAllowAppToRun = FALSE;
            goto LErrExit;
            }
        }

    *pfAllowAppToRun = TRUE;
    if (!m_pMetabase->GetDword("", MD_APP_ISOLATED, IIS_MD_UT_WAM, &dwAppMode, METADATA_INHERIT))
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto LErrExit;
        }

    *pfInProcess = ( dwAppMode == eAppInProc) ? TRUE : FALSE;
    *pfInPool = ( dwAppMode == eAppInProc || dwAppMode == eAppOOPPool ) ? TRUE : FALSE;

    if (dwAppMode == eAppOOPIsolated)
        {
        DWORD dwRet = 0;
        CHAR  szPackageID[uSizeCLSIDStr];

        //
        // Disable job objects for IIS5.1, original code would read the MD_CPU_APP_ENABLED 
        // property from metabase
        //
        *pfJobEnabled = FALSE;

        dwRequiredLen= uSizeCLSIDStr;
        if (!m_pMetabase->GetString("", MD_APP_PACKAGE_ID, IIS_MD_UT_WAM, szPackageID, &dwRequiredLen, METADATA_INHERIT))
            {
            DBG_ASSERT(dwRequiredLen <= uSizeCLSIDStr);
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto LErrExit;
            }

        dwRet = MultiByteToWideChar(CP_ACP, 0, szPackageID, -1, wszPackageID, uSizeCLSIDStr);
        DBG_ASSERT(dwRet != 0);
        }
    else if (dwAppMode == eAppOOPPool)
        {
        wcsncpy(wszPackageID, g_szIISOOPPoolPackageID, sizeof(g_szIISOOPPoolPackageID)/sizeof(WCHAR));
        // Always disable Job object for pool process.
        *pfJobEnabled = FALSE;
        }
    else
        {
        *pfJobEnabled = FALSE;
        }


    // If not present assume the default (TRUE) (For Debug builds set default to  FALSE)
    if (m_pMetabase->GetDword("", MD_ASP_EXCEPTIONCATCHENABLE, ASP_MD_UT_APP, (DWORD *)&fEnableTryExcept, METADATA_INHERIT))
        {
        *pfEnableTryExcept = fEnableTryExcept ? TRUE : FALSE;
        }
    else
        {
        #if DBG
            *pfEnableTryExcept = FALSE;
        #else
            *pfEnableTryExcept = TRUE;
        #endif
        }

    DWORD dwThreshold;

    if (dwAppMode == eAppInProc)
        {
        hr = CLSIDFromString((LPOLESTR) g_szIISInProcWAMCLSID, (LPCLSID)pclsidWam);
        }
    else if (dwAppMode == eAppOOPPool)
        {
        hr = CLSIDFromString((LPOLESTR) g_szIISOOPPoolWAMCLSID, (LPCLSID)pclsidWam);

        *pdwOOPCrashThreshold = 0XFFFFFFFF;
        }
    else
        {
        if (m_pMetabase->GetDword("", MD_APP_OOP_RECOVER_LIMIT, IIS_MD_UT_WAM, (DWORD *)&dwThreshold, METADATA_INHERIT))
            {
            // It used to be OOP_CRASH_LIMIT (range 1 - 5)
            // Now, the name is changed to RECOVER_LIMIT with range of (0-xxx).
            // 0 means no recovery, same as 1 in crash limit, 1 crash, and it's over, (0 recovery).
            // Add 1 because internally this threshold is implemented in crash_limit concept.
            // 0xFFFFFFFF is unlimited.

            // Changed to default to unlimited - Bug 240012. The idea of making this time
            // dependent seems much smarter than making it infinite. But no one was willing
            // to step up and decide what the right parameters were.
            if (dwThreshold != 0xFFFFFFFF)
                {
                dwThreshold++;
                }
            }
        else
            {
            dwThreshold = APP_OOP_RECOVER_LIMIT_DEFAULT;
            }

        *pdwOOPCrashThreshold = dwThreshold;

        dwRequiredLen= uSizeCLSIDStr;
        if (!m_pMetabase->GetString("", MD_APP_WAM_CLSID, IIS_MD_UT_WAM, szclsidWam, &dwRequiredLen, METADATA_INHERIT))
            {
            DBG_ASSERT(dwRequiredLen <= uSizeCLSIDStr);
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto LErrExit;
            }

        MultiByteToWideChar(CP_ACP, 0, szclsidWam, -1, wszclsidWam, uSizeCLSIDStr);

        hr = CLSIDFromString((LPOLESTR)wszclsidWam, (LPCLSID)pclsidWam);
        }

	if ( dwAppMode != eAppInProc )
	{
		//
		// Get the application recycle settings
		//
		
        //
        // Disable wam recycling for IIS5.1, original code would read these properties 
        // from metabase
        //
        *pdwPeriodicRestartTime = PERIODIC_RESTART_TIME_DEFAULT;

        *pdwPeriodicRestartRequests = PERIODIC_RESTART_REQUESTS_DEFAULT;

		*pdwShutdownTimeLimit = SHUTDOWN_TIME_LIMIT_DEFAULT;

		pmszPeriodicRestartSchedule->Reset();
	}

    if (FAILED(hr))
        goto LErrExit;

LErrExit:

    if (fKeyOpen)
        {
        m_pMetabase->Close();
        }

    return hr;
    }//WAM_DICTATOR::MDGetAppVariables


/*-----------------------------------------------------------------------------
WAM_DICTATOR::GetWamInfo
    Returns the interface pointer for a wam, NULL if wam not found

Arguments:
    pstrPath            [in]  wam key: path to extension dll, prog id, etc.
    fInProc             [in]  run the wam in-proc?
    ppIWam              [out] interface pointer for the wam

Return Value:
    TRUE or FALSE
-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::GetWamInfo
(
const STR*      pstrAppPath,
const HTTP_REQUEST * pHttpRequest,
CWamInfo **     ppWamInfo
)
    {
    HRESULT     hr = NOERROR;
    INT         AppState;
    CWamInfo*   pWamInfo = NULL;

    DBG_ASSERT(pstrAppPath);

    AppState = FindWamInfo(pstrAppPath, &pWamInfo);
    if (-1 == AppState)
        {
        //
        // Lock the Creation process
        // to avoid multiple threads try to create the same WAMInfo,
        // (init WAM object, very expensive in out-proc cases)
        //
        CreateWam_Lock();

        //
        // Try to find it again, in case another thread already created it.
        // This check is better that creating another WamInfo.
        //
        AppState = FindWamInfo(pstrAppPath, &pWamInfo);
        if (-1 == AppState)
            {
            //
            // We are out of luck in our search for a valid Wam Info
            // Let us just create a new one and make it happen.
            // Note: Creation also adds the WamInfo to the hashtable
            //
            DBG_ASSERT(pHttpRequest != NULL);
            hr = CreateWamInfo( *pstrAppPath, &pWamInfo, pHttpRequest->QueryW3Instance());
            }
        CreateWam_UnLock();
        }

    if (m_fShutdownInProgress && pWamInfo != NULL)
        {
        hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
        pWamInfo->Dereference();
        pWamInfo = NULL;
        }

    *ppWamInfo = pWamInfo;
    return hr;
    }//WAM_DICTATOR::GetWamInfo



/*-----------------------------------------------------------------------------

 WAM_DICTATOR::CreateWamInfo()

 Description:
   Creates a new CWamInfo object for the specified application root path.
   On successful creation, it adds the object to the hash table internal
     to the WAM_DICTATOR that contains the active WamInfos.
   Finally, it returns the object via the pointer supplied.

 Arguments:
   strAppRootPath - string containing the metabase path for for the
                    Application Root
   ppWamInfo      - pointer to pointer to CWamInfo object. On successful
                    return this contains the pointer to the new
                    created CWamInfo

 Returns:
    HRESULT
      NOERROR - on success
      and specific error codes on failure

 Note:
    This function should be called with the WAM_DICTATOR WamInfo lock held.
-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::CreateWamInfo
(
const STR & strAppRootPath,
CWamInfo ** ppWamInfo,
PW3_SERVER_INSTANCE pwsiInstance
)
    {
    HRESULT    hr = NOERROR;
    CLSID      clsidWam;
    BOOL       fInProcess;
    BOOL       fEnableTryExcept;
    CWamInfo * pWamInfo;
    DWORD      dwThreshold;    // OOP crash threshold
    BOOL       fAllowAppToRun;
    BOOL       fJobEnabled;
    BOOL       fInPool;
    WCHAR      wszPackageID[uSizeCLSIDStr];
	DWORD	   dwPeriodicRestartRequests;
	DWORD	   dwPeriodicRestartTime;
	DWORD	   dwShutdownTimeLimit;
	MULTISZ    mzPeriodicRestartSchedule;

    DBG_ASSERT( NULL != ppWamInfo );
    DBG_ASSERT( NULL == *ppWamInfo);

    // Get the latest Application path, CLSID, and inproc/out-of-proc flag
    hr = MDGetAppVariables(strAppRootPath.QueryStr(),
                           &fAllowAppToRun,
                           &clsidWam,
                           &fInProcess,
                           &fInPool,
                           &fEnableTryExcept,
                           &dwThreshold,
                           &fJobEnabled,
                           wszPackageID,
						   &dwPeriodicRestartRequests,
						   &dwPeriodicRestartTime,
						   &mzPeriodicRestartSchedule,
						   &dwShutdownTimeLimit
						   );

    if ( SUCCEEDED( hr) && fAllowAppToRun)
        {
        //
        // Create a New CWamInfo
        //
        if (fInProcess)
            {
            pWamInfo = new CWamInfo( strAppRootPath, 
                                     fInProcess,
                                     fInPool, 
                                     fEnableTryExcept, 
                                     clsidWam
                                     );
            }
        else
            {
            //
            // Check to see if we have scheduled restart times.  If so,
            // set the restart time to the earlier of the configured
            // restart time, or the earliest scheduled time.
            //

            if ( mzPeriodicRestartSchedule.QueryStringCount() )
            {
                SYSTEMTIME  st;
                DWORD       dwTimeOfDayInMinutes;
                DWORD       dwScheduleInMinutes;
                LPSTR       szHour;
                LPSTR       szMinute;

                GetLocalTime( &st );
                dwTimeOfDayInMinutes = st.wHour * 60 + st.wMinute;

                IF_DEBUG( WAM_ISA_CALLS )
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "Current Time is %d.\r\n",
                        dwTimeOfDayInMinutes
                        ));

                szHour = mzPeriodicRestartSchedule.QueryStrA();

                DBG_ASSERT( szHour );

                while ( *szHour )
                {
                    IF_DEBUG( WAM_ISA_CALLS )
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "Considering recycle at %s.\r\n",
                            szHour
                            ));
                    
                    szMinute = strchr( szHour, ':' );

                    if ( !szMinute )
                    {
                        //
                        // Parsing error - hour and minute not separated
                        // by a ':'
                        //

                        break;
                    }

                    szMinute++;

                    dwScheduleInMinutes = atol( szHour ) * 60;
                    dwScheduleInMinutes += atol( szMinute );

                    if ( dwScheduleInMinutes <= dwTimeOfDayInMinutes )
                    {
                        dwScheduleInMinutes += 24 * 60;
                    }

                    dwScheduleInMinutes -= dwTimeOfDayInMinutes;

                    IF_DEBUG( WAM_ISA_CALLS )
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "Scheduled time is %d minutes from now.\r\n",
                            dwScheduleInMinutes
                            ));

                    //
                    // If the scheduled time is earlier than the current
                    // dwPeriodicRestartTime, then replace the existing
                    // value.
                    //

                    if ( dwScheduleInMinutes < dwPeriodicRestartTime ||
                         dwPeriodicRestartTime == 0 )
                    {
                        dwPeriodicRestartTime = dwScheduleInMinutes;
                    }

                    szHour += strlen( szHour ) + 1;
                }
            }

            if ( dwPeriodicRestartRequests || dwPeriodicRestartTime )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Recycling will occur in %d minutes. or when %d requests have been served.\r\n",
                    dwPeriodicRestartTime,
                    dwPeriodicRestartRequests
                    ));
            }

            pWamInfo = new CWamInfoOutProc(strAppRootPath,
                                           fInProcess,
                                           fInPool, 
                                           fEnableTryExcept,
                                           clsidWam,
                                           dwThreshold,
                                           pwsiInstance,
                                           fJobEnabled,
										   dwPeriodicRestartRequests,
										   dwPeriodicRestartTime,
										   dwShutdownTimeLimit
                                           );
            }

        if (pWamInfo)
            {
			//
			// This is WAM_DICTATOR's reference on the CWamInfo.  In "normal"
			// operations, this will be the last reference.
			//

			pWamInfo->Reference();

            BOOL fInitialize = (fInProcess || !fJobEnabled || !pwsiInstance->AreProcsCPUStopped());
            if (fInitialize)
                {
                //
                //Init the CWamInfo.  this call will CoCreateInstance WAM object.
                //
                hr = pWamInfo->Init( wszPackageID, m_pidInetInfo );
                if (SUCCEEDED(hr))
                    {
                    pWamInfo->ChangeToState(WIS_RUNNING);
                    }
                else
                    {
                    pWamInfo->UnInit();
                    }
                }
            else
                {
                pWamInfo->ChangeToState(WIS_CPUPAUSE);
                }

            if (SUCCEEDED(hr))
                {

                if ( LK_SUCCESS != m_HashTable.InsertRecord(pWamInfo))
                    {
                    if (fInitialize)
                        {
                        pWamInfo->UnInit();
                        }
					pWamInfo->Dereference();	// should be last reference
                    //delete pWamInfo;
                    hr = E_FAIL;  // NYI: What is the right failure code?
                    }
                else
                    {

                    //
                    // Finally we are successful with a valid WAmInfo.
                    // Return this.  Will be balanced by a DeleteRecord
					// in CProcessTable::RemoveWamInfoFromProcessTable
                    //
                    pWamInfo->Reference();
                    *ppWamInfo = pWamInfo;
                    }
                }
            else
                {
                DBG_ASSERT( NOERROR != hr);
				pWamInfo->Dereference();
                //delete pWamInfo;
                }
            }
        else
            {
            // pWamInfo == NULL
            hr = E_OUTOFMEMORY;
            }
        }
    else
        {
        if (SUCCEEDED(hr))
            {
            hr = HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED);
            *ppWamInfo = NULL;
            }
        //
        // NYI: Isn't pstrNewPath going away?
        // Should I bother deleting pstrNewPath ??
        //
        }

    //
    // Either we should be returning an error or send back the proper pointer
    //
    DBG_ASSERT( (hr != NOERROR) || (*ppWamInfo != NULL));

    return ( hr);
    } // WAM_DICTATOR::CreateWamInfo()


/*-----------------------------------------------------------------------------
WAM_DICTATOR::FindWamInfo
    Returns the interface pointer for a wam, NULL if wam not found

Arguments:
    pstrPath    - [in]  wam key: path to extension dll, prog id, etc.
    ppIWam      - [out] interface pointer for the wam

Return Value:
    TRUE or FALSE

-----------------------------------------------------------------------------*/
INT
WAM_DICTATOR::FindWamInfo
(
const STR*      pstrMetabasePath,
CWamInfo**      ppWamInfo
)
    {
    INT         AppState = -1;
    CWamInfo*   pWamInfo = NULL;
    char*       pszKey;

    DBG_ASSERT(pstrMetabasePath);
    DBG_ASSERT(ppWamInfo);

    pszKey = pstrMetabasePath->QueryStr();

    HashReadLock();
    m_HashTable.FindKey(pszKey, &pWamInfo);
    HashReadUnlock();

    if (pWamInfo)
        {
        AppState = pWamInfo->QueryState();

        DBG_ASSERT(AppState != WIS_START || AppState != WIS_END);
        }

    *ppWamInfo = pWamInfo;
    return AppState;
    }//WAM_DICTATOR::FindWamInfo



/*-----------------------------------------------------------------------------
WAM_DICTATOR::UnLoadWamInfo
    Unload an OOP Wam.

Arguments:
    pstrWamPath    - [in]  wam key: path to extension dll, prog id, etc.
    fCPUPause      - [in]  If true, CPU pauses the WAM. Kills the process
                           but keeps the info around.
    pfAppCpuUnloaded - [out] If nonNULL, set to TRUE iff an app was killed.

Return Value:

    HRESULT        - Error code.

-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::UnLoadWamInfo
(
STR     *pstrAppPath,
BOOL    fCPUPause,
BOOL    *pfAppCpuUnloaded
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::UnLoadWamInfo\n"));

    int         iAppState;
    CWamInfo*   pWamInfo = NULL;
    DWORD       eWISPrevState;
    DWORD       eWISState;
    HRESULT     hr = NOERROR;
    BOOL        fInProc;
    BOOL        fAppCpuUnloaded = FALSE;

    CreateWam_Lock();

    iAppState = FindWamInfo(pstrAppPath,
                            &pWamInfo);

    CreateWam_UnLock();

    if (iAppState != -1)
        {
        bool fRet = FALSE;

        CProcessEntry* pProcEntry = NULL;


        fInProc = pWamInfo->FInProcess();
        pProcEntry = pWamInfo->QueryProcessEntry();
        DBG_ASSERT(pProcEntry != NULL);

        pProcEntry->AddRef();

        while (pWamInfo != NULL)
            {
            eWISState = (fCPUPause == TRUE) ? WIS_CPUPAUSE : WIS_SHUTDOWN;
            eWISPrevState = pWamInfo->ChangeToState(WIS_RUNNING, eWISState);
            //
            // Terminate process and kill off current requests.
            //

            if (WIS_RUNNING == eWISPrevState)
                {
                DBG_ASSERT(pWamInfo->HWamProcess() != NULL);

                hr = ShutdownWamInfo(pWamInfo,
                                    HASH_TABLE_REF + FIND_KEY_REF
                                    );

                if (!fCPUPause)
                    {
                    LK_RETCODE  LkReturn;

                    LkReturn = m_HashTable.DeleteKey(
                                    pWamInfo->QueryApplicationPath().QueryStr());
                    DBG_ASSERT(LK_SUCCESS == LkReturn);
                    //
                    // Release FIND_KEY_REF
                    //
                    pWamInfo->Dereference();
                    if (LK_SUCCESS == LkReturn)
                        {
						pWamInfo->Dereference();
                        //delete pWamInfo;
                        pWamInfo = NULL;
                        }
                    }
                else
                    {
                    //
                    // Application is running. Kill It
                    //
                    DBG_ASSERT(!pWamInfo->FInProcess());
                    //
                    // Get rid of the shutting down flag
                    //
                    pWamInfo->ClearMembers();
                    //
                    // Release FIND_KEY_REF
                    //
                    pWamInfo->Dereference();

                    fAppCpuUnloaded = TRUE;

                    }
                }

            if (fInProc)
                {
                pWamInfo = NULL;
                }
            else
                {
                fRet = m_PTable.FindWamInfo(pProcEntry,&pWamInfo);
                DBG_ASSERT(fRet == TRUE);
                }
            }

        pProcEntry->Release();
        }

    if (pfAppCpuUnloaded != NULL) {
        *pfAppCpuUnloaded = fAppCpuUnloaded;
    }
    return hr;
    }

/*-----------------------------------------------------------------------------
WAM_DICTATOR::CPUResumeWamInfo
    Resumes a CPU Paused OOP Wam.

Arguments:
    pstrWamPath    - [in]  wam key: path to extension dll, prog id, etc.

Return Value:

-----------------------------------------------------------------------------*/
VOID
WAM_DICTATOR::CPUResumeWamInfo
(
STR   *pstrWamPath
)
    {
    int         iAppState;
    CWamInfo*   pWICurrentApplication = NULL;
    DWORD       eWISPrevState;
    CLSID      clsidWam;
    BOOL       fInProcess;
    BOOL       fInPool;
    BOOL       fEnableTryExcept;
    DWORD      dwThreshold;    // OOP crash threshold
    BOOL       fAllowAppToRun;
    BOOL       fJobEnabled;
    WCHAR      wszPackageID[uSizeCLSIDStr];
	DWORD	   dwPeriodicRestartRequests;
	DWORD	   dwPeriodicRestartTime;
	DWORD	   dwShutdownTimeLimit;
	MULTISZ    mzPeriodicRestartSchedule;
    HRESULT    hr;


    CreateWam_Lock();

    iAppState = FindWamInfo(pstrWamPath,
                            &pWICurrentApplication);

    CreateWam_UnLock();

    if (iAppState != -1)
        {
        // Application may not be loaded. This method is called for every
        // application defined under the site being paused.

        // Get the latest Application path, CLSID, and inproc/out-of-proc flag
        hr = MDGetAppVariables(pWICurrentApplication->QueryApplicationPath().QueryStr(),
                               &fAllowAppToRun,
                               &clsidWam,
                               &fInProcess,
                               &fInPool,
                               &fEnableTryExcept,
                               &dwThreshold,
                               &fJobEnabled,
                               wszPackageID,
							   &dwPeriodicRestartRequests,
							   &dwPeriodicRestartTime,
							   &mzPeriodicRestartSchedule,
							   &dwShutdownTimeLimit);


        if (iAppState == WIS_CPUPAUSE && SUCCEEDED(hr))
            {
            if (SUCCEEDED(pWICurrentApplication->Init(wszPackageID, m_pidInetInfo)))
                {
                pWICurrentApplication->ChangeToState(WIS_CPUPAUSE, WIS_RUNNING);
                }
            }

        //
        // FindWamInfo References this, so dereference it.
        //
        pWICurrentApplication->Dereference();
        }

    }//WAM_DICTATOR::CPUResumeWamInfo

/*-----------------------------------------------------------------------------
WAM_DICTATOR::ShutdownWamInfo
    This function currently can only call a blocking method of WAM, UnInitWam.
    In the future, this function might support a non-blocking method provided by WAM in
    case of IIS shutdown.

Arguments:
    pWamInfo            [in]    a pointer to WamInfo
    cIgnoreRef          [in]    The reference count that need to be ignored in StartShutdown.

Return Value:
    TRUE or FALSE

-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::ShutdownWamInfo
(
CWamInfo*       pWamInfo,
INT             cIgnoreRefs
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::ShutdownWamInfo\n"));

    HRESULT     hr = NOERROR;
    WCHAR       szPackageID[uSizeCLSIDStr];

    DBG_ASSERT(pWamInfo);

    LPCSTR          pszAppPath = (pWamInfo->QueryApplicationPath()).QueryStr();


    // Might create IPackageUtil * for later use.
    DBGPRINTF((DBG_CONTEXT, "Shutting down WamInfo %08p, Inproc(%d), AppRoot(%s).\n",
            pWamInfo,
            pWamInfo->FInProcess(),
            pszAppPath));


    hr = pWamInfo->StartShutdown(cIgnoreRefs);
    hr = pWamInfo->UnInit();

    if (FAILED(hr))
        {
        const CHAR      *pszEventLog[2];
        char szErr[20];

        pszEventLog[0] = pszAppPath;
        wsprintf(szErr, "0x%08X", hr);
        pszEventLog[1] = szErr;

        // Event login
        g_pInetSvc->LogEvent(W3_EVENT_FAIL_SHUTDOWN,
                        2,
                        pszEventLog,
                        0);
        }

    //delete pWamInfo;
    //pWamInfo = NULL;
    return hr;
    } // wAM_DICTATOR::ShutdownWamInfo


/*-----------------------------------------------------------------------------
WAM_DICTATOR::CPUUpdateWamInfo
Arguments:

Return Value:
    TRUE or FALSE

-----------------------------------------------------------------------------*/
void
WAM_DICTATOR::CPUUpdateWamInfo
(
STR     *pstrAppPath
)
    {
    CWamInfo*       pWamInfo = NULL;
    INT             AppState;

    DBG_ASSERT(pstrAppPath != NULL);

    // Find the WamInfo.
    AppState = FindWamInfo(pstrAppPath, &pWamInfo);
    if (-1 != AppState)
        {
        BOOL            fWasShutDown = FALSE;
        DWORD           eWISPrevState;

        if ( !pWamInfo->FInProcess() )
            {
            //
            // It's out of process and the job state has changed
            // Shut it down so new value will get picked up
            //

            //
            // change the state of the WamInfo
            //

            eWISPrevState = pWamInfo->ChangeToState(WIS_RUNNING, WIS_SHUTDOWN);

            //
            // Need to shutdown the Application
            // remove from the hash table here. and clean up later.
            if (WIS_RUNNING == eWISPrevState)
                {

                ShutdownWamInfo(pWamInfo, HASH_TABLE_REF + FIND_KEY_REF);

                // NoNeed to go through the Dying List.
                // But since we already have the Dying List, we might just used those functions.
                // this means we might release other old WamInfo in the Dying List as well.
                m_HashTable.DeleteKey(pstrAppPath->QueryStr());

                fWasShutDown = TRUE;

                }
            }
        pWamInfo->Dereference();
        if (fWasShutDown)
            {
			pWamInfo->Dereference();
            //delete pWamInfo;
            }
        }
    }


/*-----------------------------------------------------------------------------
HRESULT
WAM_DICTATOR::WamRegSink
Argument:
szAppPath               [in]  Application Path.
dwCommand               [in]  Delete, Change, Stop..etc.

Return:
HRESULT
-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::WamRegSink
(
LPCSTR  szAppPath,
const DWORD     dwCommand,
DWORD*  pdwResult
)
    {
    CWamInfo*       pWamInfo = NULL;
    INT             AppState;
    HRESULT         hrReturn = NOERROR;

    DBG_ASSERT(szAppPath != NULL);

    *pdwResult = APPSTATUS_UnLoaded;

    //
    // Set up the Application Path
    //
    STR*    pstrAppPath  = new STR(szAppPath);

    if (NULL == pstrAppPath)
        {
        return E_OUTOFMEMORY;
        }

    Reference();
    DBGPRINTF((DBG_CONTEXT,
                "Wam Dictator received a SinkNotify on MD Path %s, cmd = %d\n",
                szAppPath,
                dwCommand));

    if (dwCommand == APPCMD_UNLOAD)
        {
        hrReturn = UnLoadWamInfo(pstrAppPath, FALSE);
        *pdwResult = (SUCCEEDED(hrReturn)) ? APPSTATUS_UnLoaded : APPSTATUS_Error;
        }
    else
        {
        // Find the WamInfo.
        AppState = FindWamInfo(pstrAppPath, &pWamInfo);
        if (-1 != AppState)
            {
            LK_RETCODE      LkReturn;
            DWORD           eWISPrevState;

            if (dwCommand == APPCMD_DELETE ||
                 dwCommand == APPCMD_CHANGETOINPROC ||
                 dwCommand == APPCMD_CHANGETOOUTPROC)
                {
                eWISPrevState = pWamInfo->ChangeToState(WIS_RUNNING, WIS_SHUTDOWN);

                if (WIS_RUNNING == eWISPrevState)
                {
                    LkReturn = m_HashTable.DeleteKey(pstrAppPath->QueryStr());
                    DBG_ASSERT(LK_SUCCESS == LkReturn);

                    if (LK_SUCCESS == LkReturn)
                        {
                        DyingList_Lock();
                        InsertDyingList(pWamInfo, FALSE);
                        DyingList_UnLock();

                        ScheduledId_Lock();
                        if (m_dwScheduledId == 0)
                            {
                                // DebugBreak();
                            m_dwScheduledId = ScheduleWorkItem
                                            (
                                            WAM_DICTATOR::CleanupScheduled,
                                            NULL,
                                            0,
                                            FALSE
                                            );
                            DBGPRINTF((DBG_CONTEXT, "add schedule item %d\n", m_dwScheduledId));
                            DBG_ASSERT(m_dwScheduledId);
                            }
                        ScheduledId_UnLock();

                        *pdwResult = (SUCCEEDED(hrReturn)) ? APPSTATUS_UnLoaded : APPSTATUS_Error;
                        }
                    }
                else
                    {
                    //
                    // Previous state is not running state.  Leave it alone.
                    //
                    pWamInfo->Dereference();
                    }
                }
            else
                {
                // AppGetStatus
                if (WIS_RUNNING == pWamInfo->QueryState())
                    {
                    *pdwResult = APPSTATUS_Running;
                    }
                else
                    {
                    *pdwResult = APPSTATUS_Stopped;
                    }

                pWamInfo->Dereference();
                }
            }
        else
            {
            //
            // This Application is not loaded.
            *pdwResult = APPSTATUS_NotFoundInW3SVC;
            }
        }

    Dereference();
    return hrReturn;
    }//WAM_DICTATOR::WamRegSink


/*-----------------------------------------------------------------------------
WAM_DICTATOR::InsertDyingList
    This function insert an invalid WamInfo into DyingList.  No blocking.

Arguments:
    pWamInfo         [in]    a pointer to WamInfo
    fNeedReference [in]     if TRUE, then we Rereference the WamInfo.  Because we get the WamInfo by
                            Hashtable's Interator or LookUp.  When we get a WamInfo from Hash Table by
                            hash table's interator or LookUp call, the Hash table does a AddRef to
                            WamInfo.  Therefore, this parameter tells whether we need to balance that
                            Addref or not.
    Return Value:
    NOERROR.
-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::InsertDyingList
(
CWamInfo* pWamInfo,
BOOL    fNeedReference
)
    {
    DBG_ASSERT(pWamInfo);

    DyingList_Lock();
    //
    // Note: Delete Dereference WamInfo.  This Dereference() within Delete() balances
    // the AddRef() in Insert() call to the hash table.
    //
    InsertHeadList(&m_DyingListHead, &pWamInfo->ListEntry);
    //
    // Unfortunately, I can not move this Dereference() out of Critical Section.
    // If I move the Dereference() after the Critical Section, then, since the WamInfo is
    // already on the DyingList.  therefore, any other thread happens to do the CleanUpDyingList()
    // call before this Dereference() will have an unbalanced reference to the CWamInfo.
    //
    if (fNeedReference)
        {
        pWamInfo->Reference();
        }

    DyingList_UnLock();

    return NOERROR;
    }//WAM_DICTATOR::InsertDyingList


/*-----------------------------------------------------------------------------
WAM_DICTATOR::CleanUpDyingList
    This function clean up any remaining WamInfo on the dying list.

Arguments:

Return Value:
        HRESULT

-----------------------------------------------------------------------------*/
HRESULT
WAM_DICTATOR::CleanUpDyingList
(
VOID
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::CleanUpDyingList\n"));

    CWamInfo *      pWamInfo = NULL;
    HRESULT         hr = NOERROR;
    PLIST_ENTRY     pleTemp;
    BOOL            fNeedCleanupAction = FALSE;

    DyingList_Lock();
    if (!IsListEmpty(&m_DyingListHead))
        {
        if (!m_fCleanupInProgress)
            {
            m_fCleanupInProgress = TRUE;
            fNeedCleanupAction = TRUE;
            }
        }

    DBGPRINTF((DBG_CONTEXT, "Clean up dying list. (ScheduledId:%d).\n",
                m_dwScheduledId));

    DyingList_UnLock();

    if (!fNeedCleanupAction)
        {
        goto Egress;
        }

    // From now on, only one thread is working on the killing dying list.
    while (!IsListEmpty(&m_DyingListHead))
        {
        DyingList_Lock();
        pleTemp = RemoveHeadList(&m_DyingListHead);
        DyingList_UnLock();

        DBG_ASSERT(pleTemp);
        pWamInfo = CONTAINING_RECORD(
                    pleTemp,
                    CWamInfo,
                    ListEntry);

        ShutdownWamInfo(pWamInfo, DYING_LIST_REF);

        pWamInfo->Dereference();

		pWamInfo->Dereference();
        //delete pWamInfo;
        pWamInfo = NULL;
        }

    InterlockedExchange((LPLONG)&m_fCleanupInProgress, (LONG)FALSE);

    DBGPRINTF((DBG_CONTEXT, "CleanupDyingList done, ScheduledId(%d)\n", m_dwScheduledId));

Egress:
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::CleanUpDyingList done\n"));

    m_dwScheduledId = 0;
    return hr;
    }//WAM_DICTATOR::CleanUpDyingList


/*-----------------------------------------------------------------------------
WAM_DICTATOR::StopAplicationsByInstance

Unload out-proc applications for a particular w3 server instance.

Arguments:
    W3_SERVER_INSTANCE *pInstance
        pointer to W3 Server Instance object.  Used to query the server instance
        metabase path.

Return Value:
    none

-----------------------------------------------------------------------------*/
VOID
WAM_DICTATOR::StopApplicationsByInstance
(
VOID *pContext //W3_SERVER_INSTANCE *pInstance
)
    {
    IF_DEBUG( WAM_ISA_CALLS )
        DBGPRINTF((DBG_CONTEXT, "WAM_DICTATOR::StopApplicationsByInstance\n"));

    BUFFER bufDataPaths;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    LPSTR   pszCurrentPath;
    STR     strPath;
    W3_SERVER_INSTANCE *pInstance;

    DBG_ASSERT(pContext != NULL);
    DBG_ASSERT(g_pWamDictator != NULL);

    pInstance = (W3_SERVER_INSTANCE *)pContext;

    g_pWamDictator->Reference();
    if (!g_pWamDictator->FIsShutdown())
        {
        if ( mb.Open( pInstance->QueryMDPath(),
                      METADATA_PERMISSION_READ ) )
            {
            //
            // First find the OOP Applications
            //
            if (mb.GetDataPaths(NULL,
                                MD_APP_WAM_CLSID,
                                STRING_METADATA,
                                &bufDataPaths))
                {
                //
                // For each OOP Application
                //
                mb.Close();
                for (pszCurrentPath = (LPSTR)bufDataPaths.QueryPtr();
                     *pszCurrentPath != '\0';
                     pszCurrentPath += (strlen(pszCurrentPath) + 1))
                    {
                    strPath.Copy(pInstance->QueryMDPath());
                    strPath.Append(pszCurrentPath);
                    strPath.SetLen(strlen(strPath.QueryStr()) - 1);
                    g_pWamDictator->UnLoadWamInfo(&strPath, FALSE);
                    }
                }
            else
                {
                mb.Close();
                }
            }
        } // WamDictator is in shutdown
        g_pWamDictator->Dereference();

    }

BOOL
WAM_DICTATOR::DeleteWamInfoFromHashTable
(
CWamInfo *  pWamInfo
)
{
    LK_RETCODE      lkReturn;
    const CHAR *    szKey;

    DBG_ASSERT( pWamInfo );

    szKey = m_HashTable.ExtractKey( pWamInfo );

    if ( !szKey )
    {
        return FALSE;
    }

    lkReturn = m_HashTable.DeleteKey( szKey );

    return ( lkReturn == LK_SUCCESS );
}

/*-----------------------------------------------------------------------------
WAM_DICTATOR::DumpWamDictatorInfo

  Description:
    This function dumps the stats on all WAMs for diagnostics

  Arguments:
    pchBuffer - pointer to buffer that will contain the html results
    lpcchBuffer - pointer to DWORD containing the size of buffer on entry
               On return this contains the # of bytes written out to buffer

  Return:
    TRUE for success and FALSE for failure
    Look at GetLastError() for the error code.
-----------------------------------------------------------------------------*/
BOOL
WAM_DICTATOR::DumpWamDictatorInfo
(
OUT CHAR *     pchBuffer,
IN OUT LPDWORD lpcchBuffer
)
    {
    LIST_ENTRY  * pEntry;
    DWORD  iCount, cch;
    BOOL   fRet = TRUE;

    if ( lpcchBuffer == NULL )
        {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
        }


    if ( 200 < *lpcchBuffer )
        {
        // Print the header blob
        cch = wsprintf( pchBuffer,
                        " Wam Director Table (%x)<br>"
                        "<TABLE BORDER> <TR> "
                        "<TH> Wam Instance </TH> "
                        "<TH> Total Reqs </TH> "
                        "<TH> Current Reqs </TH> "
                        "<TH> Max Reqs </TH> "
                        " </TR>"
                        ,
                        this
                        );
        }
    else
        {
        cch = 200;
        }

    //
    // For now there is only ONE WAM. Later use a loop to iterate thru WAMs
    //

    iCount = 0;

    CWamInfoHash::CIterator  iter;
    LK_RETCODE              lkReturn = m_HashTable.InitializeIterator(&iter);
    WAM_STATISTICS_INFO     wsi;
    CWamInfo*               pWamInfo;
    DWORD                   dwErr;
    HRESULT                 hr;

    ZeroMemory( (PVOID ) &wsi, sizeof(wsi));

    while (LK_SUCCESS == lkReturn)
        {
        CWamInfoHash::Record *pRec  = iter.Record();

        pWamInfo = (CWamInfo *)pRec;

        hr = pWamInfo->GetStatistics( 0, &wsi);

        if (SUCCEEDED(hr))
            {
            DBGPRINTF(( DBG_CONTEXT, " Wam(%08x)::GetStatistics( %08x) => %08x\n",
                    pWamInfo->QueryIWam(), &wsi, hr));

            if ( (cch + 150 ) < *lpcchBuffer)
                {
                cch += wsprintf( pchBuffer + cch,
                                 " <TR> <TD> [%d] %s </TD> "
                                 " <TD> %4d </TD>"
                                 " <TD> %4d </TD>"
                                 " <TD> %4d </TD>"
                                 " </TR>"
                                 ,
                                 iCount,
                                 pWamInfo->QueryKey(),
                                 wsi.WamStats0.TotalWamRequests,
                                 wsi.WamStats0.CurrentWamRequests,
                                 wsi.WamStats0.MaxWamRequests
                                 );
                iCount++;
                }
            else
                {
                cch += 150;
                }
            }

        lkReturn = m_HashTable.IncrementIterator(&iter);
    } // while()

    DBG_ASSERT(lkReturn == LK_NO_MORE_ELEMENTS);

    lkReturn = m_HashTable.CloseIterator(&iter);

    DBG_REQUIRE(lkReturn == LK_SUCCESS);

    //
    // dump the final summary
    //
    if ( (cch + 100 ) < *lpcchBuffer)
        {
        cch += wsprintf( pchBuffer + cch,
                         " </TABLE>"
                         );
        }
    else
        {
        cch += 100;
        }

    if ( *lpcchBuffer < cch )
        {
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fRet = FALSE;
        }

    *lpcchBuffer = cch;

    return (fRet);
} // WAM_DICTATOR::DumpWamDictatorInfo()


/*-----------------------------------------------------------------------------
Description:
    Thunk so that we can dll export DumpWamDictatorInfo.

-----------------------------------------------------------------------------*/
extern "C"
BOOL WamDictatorDumpInfo
(
OUT CHAR * pch,
IN OUT LPDWORD lpcchBuff
)
    {
    return ( g_pWamDictator->DumpWamDictatorInfo( pch, lpcchBuff));
    } // WamDictatorDumpInfo()

HRESULT W3SVC_WamRegSink
(
LPCSTR  szAppPath,
const DWORD     dwCommand,
DWORD*  pdwResult
)
    {
    return (g_pWamDictator->WamRegSink(szAppPath, dwCommand, pdwResult));
    } // W3SVCDictatorDumpInfo()


/*-----------------------------------------------------------------------------
  Thunks for Fake NT APIs
-----------------------------------------------------------------------------*/
CRITICAL_SECTION g_csNonNTAPIs;
LONG FakeInterlockedCompareExchange(
    LONG *Destination,
    LONG Exchange,
    LONG Comperand
   );

LONG
FakeInterlockedCompareExchange(
    LONG *Destination,
    LONG Exchange,
    LONG Comperand
   )
/*-----------------------------------------------------------------------------
Description:
  This function fakes the interlocked compare exchange operation for non NT
platforms
  See WAMLoadNTApis() for details

Returns:
   returns the old value at Destination
-----------------------------------------------------------------------------*/
{
    LONG oldValue;

    EnterCriticalSection( &g_csNonNTAPIs);

    oldValue = *Destination;

    if ( oldValue == Comperand ) {
        *Destination = Exchange;
    }

    LeaveCriticalSection( &g_csNonNTAPIs);

    return( oldValue);
} // FakeInterlockedCompareExchange()


static VOID
LoadNTApis(VOID)
/*-----------------------------------------------------------------------------
Description:
  This function loads the entry point for functions from
  Kernel32.dll. If the entry point is missing, the function
  pointer will point to a fake routine which does nothing. Otherwise,
  it will point to the real function.

  It dynamically loads the kernel32.dll to find the entry ponit and then
  unloads it after getting the address. For the resulting function
  pointer to work correctly one has to ensure that the kernel32.dll is
  linked with the dll/exe which links to this file.
-----------------------------------------------------------------------------*/
    {
    // Initialize the critical section for non NT API support, in case if we need this
    INITIALIZE_CRITICAL_SECTION( &g_csNonNTAPIs);

    if ( g_pfnInterlockedCompareExchange == NULL )
        {
        HINSTANCE tmpInstance;
        //
        // load kernel32 and get NT specific entry points
        //

        tmpInstance = LoadLibrary("kernel32.dll");
        if ( tmpInstance != NULL )
            {

            // For some reason the original function is _InterlockedCompareExchange!
            g_pfnInterlockedCompareExchange = (PFN_INTERLOCKED_COMPARE_EXCHANGE )
                GetProcAddress( tmpInstance, "InterlockedCompareExchange");

            if ( g_pfnInterlockedCompareExchange == NULL )
                {
                // the function is not available
                //  Just thunk it.
                g_pfnInterlockedCompareExchange = FakeInterlockedCompareExchange;
                }

            //
            // We can free this because we are statically linked to it
            //

            FreeLibrary(tmpInstance);
            }
        }

    return;
    } // WAMLoadNTApis()

static void
UnloadNTApis(VOID)
    {
    DeleteCriticalSection( &g_csNonNTAPIs);

    return;
    } // WAMUnloadNTApis()

VOID
RecycleCallback(
    VOID *  pvContext
    )
{
    CWamInfo *  pWamInfo = (CWamInfo*)pvContext;

    DBG_ASSERT( pWamInfo );

    pWamInfo->m_fRecycled = TRUE;

    if (!g_pWamDictator->m_PTable.RecycleWamInfo( pWamInfo ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "[RecycleCallback] failed to recycle CWamInfo 0x%08x.\r\n"
            ));
    }

	pWamInfo->Dereference();

    return;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\debug\w3dbg.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    w3dbg.c
    This is the main module for the W3 Server debugger extension DLL.
    This module contains the DLL initialization/termination code and a
    few utility functions.


    FILE HISTORY:
        KeithMo     18-May-1993 Created.

*/

#include "w3dbg.h"


//
//  Globals shared by all extension commands.
//

PNTSD_OUTPUT_ROUTINE  DebugPrint;
PNTSD_GET_EXPRESSION  DebugEval;
PNTSD_GET_SYMBOL      DebugGetSymbol;
PNTSD_DISASM          DebugDisassem;
PNTSD_CHECK_CONTROL_C DebugCheckCtrlC;


/*******************************************************************

    NAME:       W3DbgDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hDll                    - A handle to the DLL.

                nReason                 - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

    RETURNS:    BOOLEAN                 - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        KeithMo     18-May-1993 Created.

********************************************************************/
BOOLEAN W3DbgDllInitialize( HANDLE hDll,
                             DWORD  nReason,
                             LPVOID pReserved )
{
    BOOLEAN fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;

}   // W3DbgDllInitialize


/*******************************************************************

    NAME:       GrabDebugApis

    SYNOPSIS:   Initializes the global variables that hold pointers
                to the debugger API functions.

    ENTRY:      lpExtensionApis         - Points to a structure that
                                          contains pointers to the
                                          various debugger APIs.

    HISTORY:
        KeithMo     18-May-1993 Created.

********************************************************************/
VOID GrabDebugApis( LPVOID lpExtensionApis )
{
    PNTSD_EXTENSION_APIS lpNtsdApis = (PNTSD_EXTENSION_APIS)lpExtensionApis;

    DebugPrint      = lpNtsdApis->lpOutputRoutine;
    DebugEval       = lpNtsdApis->lpGetExpressionRoutine;
    DebugGetSymbol  = lpNtsdApis->lpGetSymbolRoutine;
    DebugDisassem   = lpNtsdApis->lpDisasmRoutine;
    DebugCheckCtrlC = lpNtsdApis->lpCheckControlCRoutine;

}   // GrabDebugApis
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\wamreq.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       wamreq.cxx

   Abstract:
       This module implements the WAM_REQUEST object

   Author:
       David Kaplan    ( DaveK )     26-Feb-1997

   Environment:
       User Mode - Win32

   Project:
       W3 services DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include <w3p.hxx>
#include "wamreq.hxx"
#include "iwr_i.c"
#include "WrcStIds.hxx"    // wamreq core string id's
#include "WrcFixed.hxx"
#include "WamExec.hxx"
#include "lonsi.hxx"       // IISDuplicateHandleEx
#include <tokenacl.hxx>
#include <malloc.h>


    /*******************************************
     *                                         *
     *  WAM_REQUEST allocation cache           *
     *                                         *
     *                                         *
     *******************************************/

ALLOC_CACHE_HANDLER * WAM_REQUEST::sm_pachWamRequest;
# define WAM_REQUEST_CACHE_THRESHOLD  (400) // UNDONE: Empirically vary

#if DBG
extern PTRACE_LOG   g_pDbgCCRefTraceLog;
PTRACE_LOG          WAM_REQUEST::sm_pDbgRefTraceLog;
#endif

DWORD               WAM_REQUEST::sm_dwRequestID;

inline BOOL 
DupTokenWithSameImpersonationLevel
( 
    HANDLE     hExistingToken,
    DWORD      dwDesiredAccess,
    TOKEN_TYPE TokenType,
    PHANDLE    phNewToken
)
/*++
Routine Description:

    Duplicate an impersionation token using the same ImpersonationLevel.
    
Arguments:

    hExistingToken - a handle to a valid impersionation token
    dwDesiredAccess - the access level to the new token (see DuplicateTokenEx)
    phNewToken - ptr to the new token handle, client must CloseHandle.

Return Value:

    Return value of DuplicateTokenEx
   
--*/
{
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD                        dwBytesReturned;

    if( !GetTokenInformation( hExistingToken,
                              TokenImpersonationLevel,
                              &ImpersonationLevel,
                              sizeof(ImpersonationLevel),
                              &dwBytesReturned
                              ) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "GetTokenInformation - failed to get TokenImpersonationLevel "
                   "LastError=%d, using SecurityImpersonation\n",
                   GetLastError()
                   ));
        
        ImpersonationLevel = SecurityImpersonation;
    }

    return DuplicateTokenEx( hExistingToken,
                             dwDesiredAccess,
                             NULL,
                             ImpersonationLevel,
                             TokenType,
                             phNewToken
                             );
}
                                    


BOOL IsStringTerminated( LPCSTR lpSz, DWORD cchMax )
/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process and that
    the string is zero-terminated.
    
    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access and termination.

    cchMax - Supplies the length in bytes to be checked (including terminator).

Return Value:

    TRUE - All bytes in the specified range are readable and the string is
        zero-terminated (or NULL pointer)

    FALSE - Either memory is not readable or there is no zero terminator.

--*/
{
    BOOL fSuccess = TRUE;
    DWORD i;
    
    //
    // We consider NULL pointer to be terminated
    //
    
    if( lpSz == NULL || cchMax == 0) {
    
        return TRUE;
    }
    
    //
    // Any non-NULL pointer we interrogate
    //
    
    __try {
    
        for( i = 0; i < cchMax && lpSz[i]; i++ ) {
        }
        
        return (i < cchMax);
        
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
    
        return FALSE;   
    }
    
    return TRUE;
}


    /*******************************************
     *                                         *
     *  Local WAM_REQUEST methods              *
     *                                         *
     *                                         *
     *******************************************/



/*---------------------------------------------------------------------*
WAM_REQUEST::WAM_REQUEST
    Constructor.

Arguments:
    None

Return Value:
    None

*/
WAM_REQUEST::WAM_REQUEST(
      HTTP_REQUEST *    pHttpRequest
    , EXEC_DESCRIPTOR * pExec
    , CWamInfo *        pWamInfo
)
:
  m_dwSignature     ( WAM_REQUEST_SIGNATURE )
, m_pHttpRequest    ( pHttpRequest )
, m_pWamInfo        ( pWamInfo )
, m_dwWamVersion    ( 0 )
, m_pWamExecInfo    ( NULL )
, m_pExec           ( pExec )
, m_cRefs           ( 0 )
, m_hFileTfi        ( INVALID_HANDLE_VALUE )
, m_fWriteHeaders   ( TRUE )
, m_fFinishWamRequest ( FALSE )
, m_pUnkFTM         (NULL)
, m_pszStatusTfi    (NULL)
, m_pszTailTfi      (NULL)
, m_pszHeadTfi      (NULL)
, m_fExpectCleanup  (FALSE)
, m_fPrepCleanupCalled (FALSE)
, m_fCleanupCalled  (FALSE)
, m_pbAsyncReadOopBuffer(NULL)
{

    DBG_ASSERT( m_pHttpRequest );
    DBG_ASSERT( m_pExec );
    DBG_ASSERT( m_pWamInfo );


    //
    //  init list pointers
    //

    InitializeListHead(&m_leOOP);

    //
    //  bind to our httpreq
    //

    BindHttpRequest();

#if DBG
    //
    // produce precise request ID for debbuging/perf work
    //
    m_dwRequestID = InterlockedIncrement( (LONG *) &sm_dwRequestID );
#else
    //
    // we can live with approximately correct result
    // (we don't want to pay the price of InterlockedIncrement)
    //
    m_dwRequestID = sm_dwRequestID++;
#endif
}


/*---------------------------------------------------------------------*
WAM_REQUEST::~WAM_REQUEST
    Destructor.

Arguments:
    None

Return Value:
    None

*/
WAM_REQUEST::~WAM_REQUEST(
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    // 
    // If waminfo is oop, then this call removes this from the active
    // list of wamreqests.
    //
    m_pWamInfo->LeaveOOPZone(this, TRUE);

    m_pWamInfo->Dereference();
        
    //
    //  if not a child request, take cleanup actions
    //
    //  NOTE we don't take cleanup actions on a child request
    //  because these actions are inherently 'connection-oriented',
    //  i.e. they should only be done once per client connection
    //  (for example, could result in disconnecting the client, etc)
    //

    if( DoCleanupOnDestroy() && !IsChild() )
    {
        //
        //  Write log record.
        //

        m_pHttpRequest->WriteLogRecord();


        //
        //  We must later call FinishWamRequest() from destructor
        //  if we are in non-error state - set m_fFinishWamRequest
        //  to tell us if we need to do this.
        //
        //  See bug 109159.
        //
        //  NOTE only here (and NOT in PrepCleanupWamRequest), do we
        //  potentially set flag true.  This is because mainline thread,
        //  which only calls PrepCleanupWamRequest, has its own restart
        //  logic, hence should never call FinishWamRequest().
        //


        m_fFinishWamRequest = (m_pHttpRequest->QueryIOStatus() == NO_ERROR);


        IF_DEBUG( ERROR ) {

            if ( !m_fFinishWamRequest ){

                DBGPRINTF((
                    DBG_CONTEXT
                    , "WAM_REQUEST[%p]::CleanupWamRequest "
                      "async i/o failed "
                      "m_pHttpRequest[%p] "
                      "pClientConn[%p] "
                      "m_pHttpRequest->QueryIOStatus()(%d) "
                      "\n"
                    , this
                    , m_pHttpRequest
                    , m_pHttpRequest->QueryClientConn()
                    , m_pHttpRequest->QueryIOStatus()
                ));

            }
        }

    }

    //
    //  ********* THREAD RACE ALERT ************************************
    //
    //  We do our final cleanup in this EXACT order:
    //
    //    1) unbind that which must be unbound before we can finish
    //       (i.e. that which would cause a race on the httpreq)
    //
    //    2) if required, finish the request
    //
    //    3) unbind that which was required to finish the request
    //
    //  ********* ANY OTHER USE VOIDS WARRANTY *************************
    //

    UnbindBeforeFinish();

    if ( m_fFinishWamRequest ) {

        FinishWamRequest();
    }

    UnbindAfterFinish();


    //
    //  Close file handle used for TransmitFile ops
    //  NOTE normally, handle will be closed (and invalid) by now.
    //  We do one last check to cover potential error cases.
    //

    if ( m_hFileTfi != INVALID_HANDLE_VALUE ) {

        DBG_ASSERT( !(m_pWamInfo->FInProcess()) );
        CloseHandle( m_hFileTfi );
        m_hFileTfi = INVALID_HANDLE_VALUE;
    }

    //
    //  Ditto for TFI strings (if any)
    //

    if ( m_pszStatusTfi != NULL )
    {
        LocalFree( m_pszStatusTfi );
        m_pszStatusTfi = NULL;
    }
    
    if ( m_pszTailTfi != NULL )
    {
        LocalFree( m_pszTailTfi );
        m_pszTailTfi = NULL;
    }
    
    if ( m_pszHeadTfi != NULL )
    {
        LocalFree( m_pszHeadTfi );
        m_pszHeadTfi = NULL;
    }

    //
    //  At last possible moment, right before we free the memory,
    //  set various object state that is useful for debugging
    //

    // set this object's signature to its 'free' value
    m_dwSignature = WAM_REQUEST_SIGNATURE_FREE;

#if DBG
    // write thread id into second dword of this object's memory
    // (alloc cache stores next-ptr in 1st dword, so we use 2nd slot)
    *( (DWORD *)this + 1 ) = GetCurrentThreadId();

#endif
    if (m_pUnkFTM != NULL)
        {
        m_pUnkFTM->Release();
        }

    m_leOOP.Flink = NULL;
    m_leOOP.Blink = NULL;
}



/*---------------------------------------------------------------------*
WAM_REQUEST::InitWamRequest
    Initializes WAM_REQUEST object.

Arguments:

Return Value:
    HRESULT

*/
HRESULT
WAM_REQUEST::InitWamRequest(
    const STR * pstrPath
)
{
    HRESULT hr;
    
    hr = CoCreateFreeThreadedMarshaler(this, &m_pUnkFTM);

    if ( FAILED(hr) ) {
        return hr;
    }
    
    //
    //  copy dll path and path-trans
    //

    if( !m_strISADllPath.Copy( *pstrPath ) ) {

        return HresultFromBool( FALSE );
    }


    if( !SetPathTrans() ) {

        return HresultFromBool( FALSE );
    }

    DBG_ASSERT( m_pHttpRequest );

    if( !m_pHttpRequest->GetInfo(
            "HTTP_USER_AGENT", 
            &m_strUserAgent
            ) ) 
    {
        m_strUserAgent.Reset();
    }

    if( !m_pHttpRequest->GetInfo( 
            "HTTP_COOKIE", 
            &m_strCookie
            ) ) 
    {
        m_strCookie.Reset();
    }

    // build the ExpireHeader

    LPSTR lpszExpires = NULL;
    CHAR        achTime[128];

    // obtain a pointer to the MetaData object

    PW3_METADATA  pMetaData = m_pHttpRequest->QueryMetaData();
    ASSERT(pMetaData);

    // switch on the mode.  One of STATIC or DYNAMIC

    switch(pMetaData->QueryExpireMode()) {
    
        // if STATIC, the ExpireHeader is already built up
            
        case EXPIRE_MODE_STATIC :

            lpszExpires = m_pHttpRequest->QueryExpireHeader();
            break;

        // if DYNAMIC, then the ExpireHeader must be built here.
        // The MetaData has the ExpireDelta which is added to the
        // current time and built up into a full Expires header.

        case EXPIRE_MODE_DYNAMIC :
            
            DWORD  dwDelta = pMetaData->QueryExpireDelta();
            SYSTEMTIME  SysTime;
            char  *p = achTime;
            
            ::IISGetCurrentTimeAsSystemTime( &SysTime );

            strcpy(p, "Expires: ");

            p += (sizeof("Expires: ") - 1);

            // if SystemTimeToGMTEx fails, silently fail leaving
            // lpszExpires as NULL

            if ( ::SystemTimeToGMTEx( SysTime,
                                       p,
                                       sizeof(achTime),
                                       dwDelta ))
            {
                lpszExpires = achTime;
                p += strlen(p);
                strcpy(p, "\r\n");
            }
            break;
    }

    if( lpszExpires ) {
        m_strExpires.Copy( lpszExpires );
    } else {
        m_strExpires.Reset();
    }
    
    return NOERROR;

}



/*---------------------------------------------------------------------*
WAM_REQUEST::BindHttpRequest
    "Binds" this wamreq to its associated httpreq and refs the httpreq.
    Bind ==
    1) ref httpreq
    2) set this wamreq's pointer into httpreq
    3) increment httpreq stats counter

    NOTE we invert this function in two phases, with UnbindBeforeFinish
    and UnbindAfterFinish.

Arguments:
    None

Return Value:
    None

*/
VOID
WAM_REQUEST::BindHttpRequest(
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    DBG_ASSERT( m_pHttpRequest );
    DBG_ASSERT( m_pExec );


    //
    // set httpreq's wamreq ptr to this wamreq
    // and ref httpreq (which actually refs client-conn)
    //
    // NOTE we set wamreq ptr first so that it will show
    // up in client-conn's ref trace log.
    //

    DBG_ASSERT( m_pHttpRequest->QueryWamRequest() == NULL );
    m_pHttpRequest->SetWamRequest( this );

    m_pHttpRequest->Reference();


    //
    //  Increment stats counter.
    //

    m_pHttpRequest->QueryW3StatsObj()->IncrBGIRequests();


    //
    //  The child request completion event is set in Unbind().
    //  Here in Bind() the fact that we got this far means that
    //  Unbind() will get executed, and thus we mark the child
    //  compeletion as 'must wait for'.
    //

    if (IsChild()) {

        m_pExec->SetMustWaitForChildEvent();
    }


}   // WAM_REQUEST::BindHttpRequest



/*-----------------------------------------------------------------------------*
WAM_REQUEST::UnbindBeforeFinish
    "Unbinds" the parts of the httpreq and its embedded exec descriptor
    which ***MUST*** be done before attempting to finish the request.

    NOTE include in this function any operation which would cause a race
    on the httpreq if we did it after another thread gets the httpreq.

Arguments:
    None

Returns:
    None
*/
VOID
WAM_REQUEST::UnbindBeforeFinish(
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    DBG_ASSERT( m_pHttpRequest != NULL );
    DBG_ASSERT( m_pExec != NULL );

    //
    // null out the wamreq ptr stored in httpreq,
    //

    DBG_ASSERT( m_pHttpRequest->QueryWamRequest() == this );
    m_pHttpRequest->SetWamRequest( NULL );


    return;

}   // WAM_REQUEST::UnbindBeforeFinish()



/*---------------------------------------------------------------------*
WAM_REQUEST::UnbindAfterFinish
    "Unbinds" the parts of the httpreq and its embedded exec descriptor
    which are required to finish the request, and which hence
    may not be done until after attempting to finish the request.

    NOTE ***DO NOT*** include in this function any operation which
    would cause a race on the httpreq if we did it after another thread
    gets the httpreq.


Arguments:
    None

Return Value:
    None

*/
VOID
WAM_REQUEST::UnbindAfterFinish(
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    DBG_ASSERT( m_pHttpRequest != NULL );

    //
    //  Decrement stats counter.
    //

    m_pHttpRequest->QueryW3StatsObj()->DecrCurrentBGIRequests();


    //
    //  If this is a child request, set its event,
    //  which allows parent request to continue processing
    //

    if ( IsChild() ) {

        m_pExec->SetChildEvent();
    }


    //
    //  Now that we are done with exec, null out our ptr
    //

    m_pExec = NULL;


    DBG_ASSERT( m_pWamInfo != NULL );

    //
    //  If this is a crashed oop request, disconnect
    //
    //  NOTE crashed ==> current wam version differs from
    //  the one we cached in this wamreq when it was created
    //

    if ( m_pWamInfo->FInProcess() == FALSE ) {

        if ( ((CWamInfoOutProc *)m_pWamInfo)
                ->GetWamVersion() != m_dwWamVersion ) {

            //
            //  NOTE this is safe even if we have already called Disconnect()
            //  because Disconnect() no-ops if it was already called
            //

            m_pHttpRequest->Disconnect(
                0
                , NO_ERROR
                , TRUE      // fShutdown
            );
        }

    }


    //
    //  Now that we are done with httpreq, deref it and null out our ptr
    //

    DereferenceConn( m_pHttpRequest->QueryClientConn() );
    m_pHttpRequest = NULL;

}   // WAM_REQUEST::UnbindAfterFinish

VOID 
WAM_REQUEST::DisconnectOnServerError( 
    DWORD dwHTHeader,
    DWORD dwError
) 
{
    m_pHttpRequest->Disconnect(dwHTHeader, dwError); 
}
    
/*---------------------------------------------------------------------*
WAM_REQUEST::FinishWamRequest

Description:
    Finishes this wam request - should only be call from destructor,
    and only if cleanup was done by isapi callback thread.

    ANY OTHER USE VOIDS WARRANTY.

Arguments:
    None

Returns:
    Nothing

*/
VOID
WAM_REQUEST::FinishWamRequest(
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    DBG_ASSERT( m_pHttpRequest );

    BOOL    fDoAgain = FALSE;   // do we need to post completion status?


    if ( !m_pHttpRequest->IsKeepConnSet() ) {

        //
        // If keep-alive is not set, disconnect.
        //

        m_pHttpRequest->Disconnect( 0, NO_ERROR, TRUE );

    } else {

        //
        //  If keep-alive is set, start up a new session
        //

        if ( !m_pHttpRequest->QueryClientConn()->OnSessionStartup(
                &fDoAgain ) ) {

            //
            //  Disconnect with error if startup failed
            //

            m_pHttpRequest->Disconnect(
                HT_SERVER_ERROR
                , GetLastError()
                , TRUE
            );

        }

    }


    //
    //  If OnSessionStartup returned do-again TRUE,
    //  post completion status.
    //

    if ( fDoAgain ) {

        if ( !m_pHttpRequest->QueryClientConn()->PostCompletionStatus(
                m_pHttpRequest->QueryBytesWritten() ) ) {

            //
            //  Disconnect with error if post failed
            //

            m_pHttpRequest->Disconnect(
                HT_SERVER_ERROR
                , GetLastError()
                , TRUE
            );

        }

    }

    return;

} // WAM_REQUEST::FinishWamRequest()



/*-----------------------------------------------------------------------------*
WAM_REQUEST::QueryInterface
    COM implementation

Arguments:
    The usual ones.

Returns:
    HRESULT
*/
HRESULT
WAM_REQUEST::QueryInterface
(
REFIID riid,
void __RPC_FAR *__RPC_FAR *ppvObject
)
    {

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    DBG_ASSERT( ppvObject );

    *ppvObject = NULL;

    IF_DEBUG( IID )
        {
        DBGPRINTF(( DBG_CONTEXT,
            "WAM_REQUEST::QueryInterface looking for ... ( " GUID_FORMAT " )\n",
            GUID_EXPAND( &riid) ));
        }

    if( riid == IID_IWamRequest )
        {
        *ppvObject = static_cast<IWamRequest *>( this );
        }
    else if ( riid == IID_IMarshal )
        {
        if (m_pUnkFTM == NULL)
            {
            DBG_ASSERT(FALSE);
            return E_NOINTERFACE;
            }
        else
            {
            return m_pUnkFTM->QueryInterface(riid, ppvObject);
            }
        }
    else if( riid == IID_IUnknown )
        {
        *ppvObject = static_cast<IWamRequest *>( this );
        }
    else if (m_pUnkFTM != NULL)
        {
        return m_pUnkFTM->QueryInterface(riid, ppvObject);
        }
    else
        {
        return E_NOINTERFACE;
        }

    DBG_ASSERT( *ppvObject );
        ((IUnknown *)*ppvObject)->AddRef();

    IF_DEBUG( IID )
        {
        DBGPRINTF(( DBG_CONTEXT,
            "WAM_REQUEST::QueryInterface found ( " GUID_FORMAT ", %p )\n",
            GUID_EXPAND( &riid),
            *ppvObject ));
        }
    
    return NOERROR;
    }

/*---------------------------------------------------------------------*

    Support for debug ref trace logging
*/

#define WR_LOG_REF_COUNT( cRefs )   \
                                    \
    if( sm_pDbgRefTraceLog != NULL ) {                  \
                                                        \
        WriteRefTraceLogEx(                             \
            sm_pDbgRefTraceLog                          \
            , cRefs                                     \
            , (PVOID) this                              \
            , m_pHttpRequest                            \
            , m_pExec                                   \
            , m_pHttpRequest                            \
              ? m_pHttpRequest->QueryClientConn()       \
              : NULL                                    \
        );                                              \
    }                                                   \


#define WR_SHARED_LOG_REF_COUNT( cRefs )    \
                                            \
    SHARED_LOG_REF_COUNT(                       \
        cRefs                                   \
        , m_pHttpRequest                        \
          ? m_pHttpRequest->QueryClientConn()   \
          : NULL                                \
        , m_pHttpRequest                        \
        , this                                  \
        , m_pHttpRequest                        \
          ? m_pHttpRequest->QueryState()        \
          : NULL                                \
    );                                          \



/*---------------------------------------------------------------------*
WAM_REQUEST::AddRef
    Addrefs wamreq

Arguments:
    None

Returns:
    Refcount
*/
ULONG
WAM_REQUEST::AddRef( )
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( BGI ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST(%p)  AddRef: %d -> %d\n"
            , this
            , m_cRefs
            , m_cRefs + 1
        ));
    }


    LONG cRefs = InterlockedIncrement( &m_cRefs );


#if DBG
    //
    // Write to both wamreq trace log and shared trace log
    //

    WR_LOG_REF_COUNT( cRefs );
    WR_SHARED_LOG_REF_COUNT( cRefs );

#endif

    return cRefs;
}



/*---------------------------------------------------------------------*
WAM_REQUEST::Release
    Releases wamreq

Arguments:
    None

Returns:
    Refcount
*/
ULONG
WAM_REQUEST::Release( )
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( BGI ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST(%p) Release: %d -> %d\n"
            , this
            , m_cRefs
            , m_cRefs - 1
        ));
    }

#if DBG

    LONG cRefsAfter = m_cRefs - 1;

    //
    // Write to both wamreq trace log and shared trace log
    //
    // NOTE write the trace log BEFORE the decrement operation :(
    // If we write it after the decrement, we will run into potential
    // race conditions in this object getting freed up accidentally
    // by another thread
    //
    // NOTE we write ref count AFTER decrement happens
    //

    WR_LOG_REF_COUNT( cRefsAfter );
    WR_SHARED_LOG_REF_COUNT( cRefsAfter );

#endif

    LONG cRefs = InterlockedDecrement( &m_cRefs );


    if( cRefs == 0 ) {

        IF_DEBUG( BGI ) {

            DBGPRINTF((
                DBG_CONTEXT
                , "WAM_REQUEST(%p) dying when ref = %d.\n"
                , this
                , cRefs
            ));
        }

        delete this;
        return 0;
    }

    return cRefs;
}

/*---------------------------------------------------------------------*
// Interlocked Increment only if non zero
//
// Returns 0 or value after increment
//
*/
LONG 
WAM_REQUEST::InterlockedNonZeroAddRef(VOID)
{
    while (TRUE) 
    {
    LONG l = m_cRefs;

    if (l == 0)
        {
        return 0;
        }
        
    if (g_pfnInterlockedCompareExchange(&m_cRefs, l+1, l) == l)
        {
        return l+1;
        }
    }
}

/*---------------------------------------------------------------------*
WAM_REQUEST::WriteLogInfo
    Writes information to the IIS log.

Arguments:
    None

Returns:
    None
*/
BOOL
WAM_REQUEST::WriteLogInfo(
    CHAR * szLogMessage
    , DWORD dwLogHttpResponse
    , DWORD dwLogWinError
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    if ( m_pHttpRequest == NULL ) {

        return FALSE;
    }


    if ( !m_pHttpRequest->AppendLogParameter( szLogMessage ) ) {

        return FALSE;
    }


    m_pHttpRequest->SetLogStatus( dwLogHttpResponse,dwLogWinError );


    return m_pHttpRequest->WriteLogRecord();

} // WAM_REQUEST::WriteLogInfo()



/*-----------------------------------------------------------------------------*

NOTE on PrepCleanupWamRequest and CleanupWamRequest:

    Our cleanup policy depends on whether the request gets cleaned up by
    the mainline thread or the isapi callback thread.

    If the mainline thread does cleanup, it calls PrepCleanupWamRequest
    and relies on its higher-level callers (DoWork et al) to handle the
    remaining cleanup tasks.

    If the isapi callback thread does cleanup, it calls CleanupWamRequest,
    which in turn calls PrepCleanupWamRequest, and does all cleanup tasks
    itself.  (In this case, of course, there are no higher-level callers
    to rely upon).

*/



/*-----------------------------------------------------------------------------*
WAM_REQUEST::PrepCleanupWamRequest

Description:
    Preps for CleanupWamRequest

Arguments:
    Below

Returns:
    HRESULT

*/
HRESULT
WAM_REQUEST::PrepCleanupWamRequest(
    unsigned char *  szLogData  // log data buffer
    , DWORD   cbLogData         // size of log data buffer
    , DWORD   dwHttpStatusCode  // HTTP Status code from ecb
    , DWORD dwIsaKeepConn       // keep/close/no-change connection?
)

{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    DBG_ASSERT( m_pHttpRequest );
    DBG_ASSERT( m_pExec );
    DBG_ASSERT( m_fFinishWamRequest == FALSE );
    
    m_fPrepCleanupCalled = TRUE;    

    //
    //  Append log info to logfile parameters and set log status
    //
    //  UNDONE This is a little bit bogus, we're not translating
    //  the win32 error code based on the HTTP status code
    //


    //
    // String should be zero-terminated (#157805)
    //

    if( IsStringTerminated( (LPCSTR) szLogData, cbLogData ) ) {
    
        m_pHttpRequest->AppendLogParameter( (char*) szLogData );
    }
    
    m_pHttpRequest->SetLogStatus( dwHttpStatusCode, NO_ERROR );


    /*

    Keep-conn logic works like this:

    If ISA asked us NOT to keep-conn, or if this is an old ISA
    (which implicitly assumed we would close the connection)
    set client keep-conn false.
    Else, leave client keep-conn unchanged.

    NOTE: At the end of the day we want the connection kept open
    if and only if BOTH the client and the ISA said to keep it open;
    and, the connection will be kept open or closed based on the
    state of the client's keep-conn flag when cleanup runs later on.

    This function accomplishes the goal as follows (Yes == keep-conn):

    Client  ISA     This function           End result
    ------  ---     -------------           ----------
    Yes     Yes     Does nothing            Connection will be kept open
    Yes     No      Sets client flag false  Connection will be closed
    No      Yes     Does nothing            Connection will be closed
    No      No      Sets client flag false  Connection will be closed

    */

    if ( dwIsaKeepConn == KEEPCONN_FALSE
         || dwIsaKeepConn == KEEPCONN_OLD_ISAPI ) {

        SetKeepConn( FALSE );
    }


    return NOERROR;

} // WAM_REQUEST::PrepCleanupWamRequest



/*---------------------------------------------------------------------*
WAM_REQUEST::CleanupWamRequest

Description:
    Cleans up wamreq.

    NOTE this function replaces cleanup code which in IIS 3.0
    resided in ServerSupportFunction and should be called
    ONLY from ServerSupportFunction on isapi callback thread.
    See comments in PrepCleanupWamRequest for more details.

    ANY OTHER USE VOIDS WARRANTY.

    [When mainline thread does cleanup, it happens elsewhere.]

Arguments:
    Below

Returns:
    HRESULT

*/
HRESULT
WAM_REQUEST::CleanupWamRequest(
    unsigned char *  szLogData  // log data buffer
    , DWORD   cbLogData         // size of log data buffer
    , DWORD   dwHttpStatusCode  // HTTP Status code from ecb
    , DWORD dwIsaKeepConn       // keep/close/no-change connection?
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    DBG_ASSERT( m_pHttpRequest );
    DBG_ASSERT( m_pExec );


#if CC_REF_TRACKING
    //
    //  log to our various ref logs
    //
    // NOTE negative indicates no change to ref count
    //

#if DBG

    WR_LOG_REF_COUNT( -m_cRefs );
    WR_SHARED_LOG_REF_COUNT( -m_cRefs );

#endif // DBG

    //
    //  log to local (per-object) CLIENT_CONN log
    //
    LogRefCountCCLocal(
          - m_cRefs
        , m_pHttpRequest
          ? m_pHttpRequest->QueryClientConn()
          : NULL
        , m_pHttpRequest
        , this
        , m_pHttpRequest
          ? m_pHttpRequest->QueryState()
          : NULL
    );
#endif // CC_REF_TRACKING

    m_fCleanupCalled = TRUE;

    PrepCleanupWamRequest(
        szLogData
        , cbLogData
        , dwHttpStatusCode
        , dwIsaKeepConn
    );

    return NOERROR;


} // WAM_REQUEST::CleanupWamRequest



/*-----------------------------------------------------------------------------*
WAM_REQUEST::IsChild
    Is this a child request?

Arguments:
    None

Returns:
    BOOL

*/
BOOL
WAM_REQUEST::IsChild( VOID ) const
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    return m_pExec && m_pExec->IsChild();
}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::QueryExecMetaData
    Metadata pointer from m_pExec member

Arguments:
    None

Returns:
    PW3_METADATA

*/
PW3_METADATA
WAM_REQUEST::QueryExecMetaData( VOID ) const
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    return m_pExec ? m_pExec->QueryMetaData() : NULL;
}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::SetPathTrans
    Sets path-trans member

Arguments:
    None

Returns:
    BOOL

*/
BOOL
WAM_REQUEST::SetPathTrans( )
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    DBG_ASSERT( m_pHttpRequest );
    DBG_ASSERT( m_pExec );
    DBG_ASSERT( m_pExec->_pstrPathInfo );
    DBG_ASSERT( m_pExec->_pstrPathInfo->QueryStr() );

    //
    // If path-info is identical to the URL, as will be the case when script
    // mapping is used (i.e. the image name is not in the URL),
    //   then path-tran is simply physical path, verbatim.
    // Else we need to get path-tran from vroot lookup.
    //

    DWORD  cchURL = m_pHttpRequest->QueryURLStr().QueryCCH();

    if( ( m_pExec->_pstrPathInfo->QueryCCH() == cchURL )
        && !memcmp( m_pExec->_pstrPathInfo->QueryStr(),
                    m_pHttpRequest->QueryURLStr().QueryStr(), cchURL ) )
        {

        if( !m_strPathTrans.Copy( m_pHttpRequest->QueryPhysicalPathStr() ) )
            {

            DBGPRINTF((
                DBG_CONTEXT
                , "WAM_REQUEST[%p]::SetPathTrans failed "
                  "due to STR::Copy failure\n"
                , this
            ));

            return FALSE;
            }

        }
    else
        {

            //
            // ISAPI Specifies that the pathTrans will contain the
            //  Path xlated for the path specified in 'PathInfo'
            // Do the Virtual Root Lookup now.
            //
            //  NOTE since we are passing in metadata ptrs,
            //  callee will not free, so we need to do this ourselves
            //  (we free in destructor)
            //

            if( !m_pHttpRequest->
                LookupVirtualRoot( &m_strPathTrans,
                                   m_pExec->_pstrPathInfo->QueryStr(),
                                   m_pExec->_pstrPathInfo->QueryCCH(),
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   FALSE,
                                   &m_pExec->_pPathInfoMetaData,
                                   &m_pExec->_pPathInfoURIBlob ) )
                {

                DBGPRINTF((
                    DBG_CONTEXT
                    , "WAM_REQUEST[%p]::SetPathTrans failed "
                      "due to LookupVirtualRoot failure\n"
                    , this
                ));

                return FALSE;
                }

        }

    return TRUE;

} // WAM_REQUEST::SetPathTrans()



/*-----------------------------------------------------------------------------*
WAM_REQUEST::CbWrcStrings
    Returns count of bytes required for wamreq core strings

Arguments:
    None

Returns:
    Count of bytes required for wamreq core strings, including null-terminators

*/
DWORD
WAM_REQUEST::CbWrcStrings
(
BOOL    fInProcess
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    DBG_ASSERT( m_pExec );
    DBG_ASSERT( m_pHttpRequest );

    /* sync WRC_STRINGS */
    DWORD   cbRet =     1 + m_pExec->_pstrPathInfo->QueryCCH()
                      + 1 + m_strPathTrans.QueryCCH()
                      + 1 + m_pHttpRequest->QueryMethodStr().QueryCCH()
                      + 1 + m_pHttpRequest->QueryContentTypeStr().QueryCCH()
                      + 1 + m_pHttpRequest->QueryURLStr().QueryCCH()
                      + 1 + m_strISADllPath.QueryCCH()
                      + 1 + m_pExec->_pstrURLParams->QueryCCH()
                      + 1 + m_pHttpRequest->GetWAMMetaData()->QueryAppPath()->QueryCCH()
                      + 1 + m_strUserAgent.QueryCCH()
                      + 1 + m_strCookie.QueryCCH()
                      + 1 + m_strExpires.QueryCCH()
                      ;

    /* sync WRC_STRINGS */
    if( !fInProcess )
    {
        // if out-of-proc, allow for entity body in buffer
        // NOTE no null terminator
        cbRet += m_pHttpRequest->QueryEntityBodyCB();

                
    }

    return cbRet;
}

DWORD
WAM_REQUEST::CbCachedSVStrings(
    IN  SV_CACHE_LIST::BUFFER_ITEM *    pCacheItems,
    IN  DWORD                           cItems
    )
{
    DWORD   dwTotalBytesRequired = 0;

    for( DWORD i = 0; i < cItems; ++i )
    {
        //
        // We store the number of characters required for each string
        // in dwOffset before we get the actual values. Once the values
        // are retrieved, dwOffset contains the offset into the value
        // buffer or an error code that should be returned to the client.
        //
        LPDWORD pcchRequired    = &(pCacheItems[i].dwOffset);
        DWORD   svid            = pCacheItems[i].svid;
        LPCSTR  pszVariableName = 
            g_pWamDictator->QueryServerVariableMap().FindName(svid);

        BOOL fSuccess = m_pHttpRequest->GetInfoForName( pszVariableName, 
                                                        NULL, 
                                                        pcchRequired 
                                                        );

        if( !fSuccess )
        {
            // This is really all debug code. Should remove...
            // But it will probably all optimize away.

            DWORD dwError = GetLastError();
            if( dwError != ERROR_INSUFFICIENT_BUFFER )
            {
                // This will happen for HTTP_ variables that were
                // not sent by the client, not a problem. We'll
                // handle in WAM_REQUEST::GetCachedSVStrings
                DBG_ASSERT( *pcchRequired == 0 );
            }
            else
            {
                // Normal case
                DBG_ASSERT( *pcchRequired > 0 );
            }
        }

        dwTotalBytesRequired += *pcchRequired;
    }
    return dwTotalBytesRequired;
}

HRESULT
WAM_REQUEST::GetCachedSVStrings(
    IN OUT  unsigned char *                 pbServerVariables,
    IN      DWORD                           cchAvailable,
    IN      SV_CACHE_LIST::BUFFER_ITEM *    pCacheItems,
    IN      DWORD                           cCacheItems
    )
{
    DBG_ASSERT( pbServerVariables );
    DBG_ASSERT( pCacheItems );

    HRESULT hr = NOERROR;

    DWORD   cchRemainingBuffer;
    DWORD   cchValue;
    DWORD   dwOffset = 0;

    for( DWORD i = 0; i < cCacheItems; ++i )
    {
        DWORD   svid            = pCacheItems[i].svid;
        LPCSTR  pszVariableName = 
            g_pWamDictator->QueryServerVariableMap().FindName(svid);

        // Test <= because the last server variable may be one that
        // produces an error. In that case cchRemainingBuffer will
        // be 0 which will still generate the correct result.
        if( dwOffset <= cchAvailable )
        {
            cchRemainingBuffer = cchAvailable - dwOffset;
            cchValue = pCacheItems[i].dwOffset;

            DBG_ASSERT( cchRemainingBuffer >= cchValue );

            if( m_pHttpRequest->GetInfoForName( pszVariableName, 
                                                (LPSTR)pbServerVariables + dwOffset, 
                                                &cchValue 
                                                ) )
            {
                pCacheItems[i].dwOffset = dwOffset;
                dwOffset += cchValue;

                // Buffer over run.
                DBG_ASSERT( dwOffset <= cchAvailable );
            }
            else
            {
                DWORD dwError = GetLastError();

                DBG_ASSERT( dwError != ERROR_SUCCESS );
                switch( dwError )
                {
                    // Could collapse these into two cases...

                    case ERROR_INVALID_INDEX:
                        //
                        // This is expected if the server variable
                        // is unknown. This should only happen
                        // for HTTP_ server variables that were not
                        // sent by the client. Set the error, so we
                        // can return this to the client
                        //
                        pCacheItems[i].dwOffset = HRESULT_FROM_WIN32(dwError);
                        break;
                    case ERROR_INSUFFICIENT_BUFFER:
                        //
                        // This shouldn't happen.
                        // Mark this as not cached.
                        //
                        DBG_ASSERT(FALSE);
                        pCacheItems[i].dwOffset = SV_DATA_INVALID_OFFSET;
                        break;
                    case ERROR_NO_DATA:
                        //
                        // According to the documentation, but not the code,
                        // we can return this value.
                        //
                        pCacheItems[i].dwOffset = HRESULT_FROM_WIN32(dwError);
                        break;
                    case ERROR_INVALID_PARAMETER:
                    default:
                        //
                        // Anything else is bogus.
                        //
                        DBG_ASSERT(FALSE);
                        pCacheItems[i].dwOffset = SV_DATA_INVALID_OFFSET;
                        break;
                }

                DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::GetCachedSVStrings - Failed on "
                    "m_pHttpRequest->GetInfoForName( %s, ,%d ) : %08x\n",
                    this,
                    pszVariableName,
                    cchValue,
                    dwError
                    ));
            }
        }
        else
        {
            // This should never happen
            DBGPRINTF(( DBG_CONTEXT,
                        "WAM_REQUEST[%p]::GetCachedSVStrings() - "
                        "Insufficient buffer - cchAvailable(%d) dwOffset(%d)\n",
                        this,
                        cchAvailable,
                        dwOffset
                        ));
            DBG_ASSERT(FALSE);
        }
    }

    return hr;
}

/*---------------------------------------------------------------------*
WAM_REQUEST::ProcessAsyncGatewayIO
    Processes async i/o for a pending wam request

Arguments:
    dwStatus    -   i/o status
    cbWritten   -   count of byte written

Returns:
    HRESULT

*/
HRESULT
WAM_REQUEST::ProcessAsyncGatewayIO(
    DWORD dwStatus
    , DWORD cbWritten
)
{

    HRESULT hr = NOERROR;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    DBG_ASSERT( m_cRefs > 0);
    DBG_ASSERT( m_pHttpRequest );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_REQUEST[%p]::ProcessAsyncGatewayIO\n"
            , this
        ));
    }

    DBG_ASSERT( m_pWamExecInfo );

    if( !m_fAsyncWrite && m_pHttpRequest->IsChunked() && cbWritten ) {

        //
        // decode chunked data
        // 

        DWORD cbToDecode = cbWritten;
        
        if( m_pHttpRequest->DecodeChunkedBytes( m_pAsyncReadBuffer, &cbWritten ) ) {

            if( cbWritten == 0 ) {

                if( !m_pHttpRequest->IsChunkedReadComplete() ) {
                
                    //
                    // All the bytes we've read were headers or footers.
                    // We need to restart reading...
                    //

                    m_pHttpRequest->SetState( 
                                     HTR_GATEWAY_ASYNC_IO, 
                                     m_pHttpRequest->QueryLogHttpResponse(), 
                                     m_pHttpRequest->QueryLogWinError() );

                    if( m_pHttpRequest->ReadFile(
                            m_pAsyncReadBuffer
                            , m_dwAsyncReadBufferSize
                            , NULL
                            , IO_FLAG_ASYNC
                            ) ) 
                    {                    
                        //
                        // Successfuly restarted reading. 
                        //

                        return NOERROR;

                    } else {

                        //
                        // Failed to restart reading -- undo the state change
                        //
                        
                        m_pHttpRequest->SetState( 
                            HTR_DOVERB, 
                            m_pHttpRequest->QueryLogHttpResponse(), 
                            ERROR_INVALID_PARAMETER 
                            );
                            
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "WAM_REQUEST[%p]::Failed to restart reading\n", this 
                            ));
         
                    }
                }
            }
        } else {
        
            //
            // Error decoding chunked data. 
            //                        
            m_pHttpRequest->SetState( 
                HTR_DOVERB, 
                m_pHttpRequest->QueryLogHttpResponse(), 
                ERROR_INVALID_PARAMETER 
                );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    }     

    //
    // If this is a read, let HTTP_REQUEST know how much we read for 
    // logging purposes.
    //

    if( !m_fAsyncWrite && dwStatus == STATUS_SUCCESS )
    {
        m_pHttpRequest->AddTotalEntityBodyCB( cbWritten );
    }

    //
    //  If we used file handle for async i/o, close it now.
    //

    if ( m_hFileTfi != INVALID_HANDLE_VALUE ) {

        DBG_ASSERT( !(m_pWamInfo->FInProcess()) );

        CloseHandle( m_hFileTfi );
        m_hFileTfi = INVALID_HANDLE_VALUE;
    }

    //
    //  Free TFI strings (if any)
    //

    if ( m_pszStatusTfi != NULL )
    {
        LocalFree( m_pszStatusTfi );
        m_pszStatusTfi = NULL;
    }
    
    if ( m_pszTailTfi != NULL )
    {
        LocalFree( m_pszTailTfi );
        m_pszTailTfi = NULL;
    }
    
    if ( m_pszHeadTfi != NULL )
    {
        LocalFree( m_pszHeadTfi );
        m_pszHeadTfi = NULL;
    }

    if( m_pbAsyncReadOopBuffer != NULL )
    {
        // Doing an out of process async read
        DBG_ASSERT( !m_fAsyncWrite );

        // Save a local copy of the read buffer before making callback. 
        // ISAPI may queue another async read.

        LPBYTE pbTemp = m_pbAsyncReadOopBuffer;
        m_pbAsyncReadOopBuffer = NULL;

        hr = m_pWamInfo->ProcessAsyncIO(
                this,
#ifdef _WIN64
                (UINT64) m_pWamExecInfo, 
#else
                (ULONG_PTR) m_pWamExecInfo, 
#endif
                dwStatus,
                cbWritten,
                pbTemp
                );

        LocalFree( pbTemp );
    }
    else
    {
        hr = m_pWamInfo->ProcessAsyncIO(
                this,
#ifdef _WIN64
                (UINT64) m_pWamExecInfo, 
#else
                (ULONG_PTR) m_pWamExecInfo, 
#endif
                dwStatus,
                cbWritten );
    }


    //
    //  Deref upon completing async i/o operation.
    //
    //  NOTE balances ref which must precede any async i/o operation.
    //
    //  NOTE this ref/deref scheme fixes 97842, wherein inetinfo crashed
    //       after oop isapi submited async readcli and then crashed
    //

    Release();

    return hr;

}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::SetDeniedFlags

    Cover function



*/
VOID
WAM_REQUEST::SetDeniedFlags
(
DWORD dwDeniedFlags
)
    {
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    m_pHttpRequest->SetDeniedFlags( dwDeniedFlags );
    }



/*---------------------------------------------------------------------*
WAM_REQUEST::SendEntireResponseFast

  Description:
    Sends an entire response (headers and body) as fast as possible
    by calling WSASend.

  Arguments:
    pHseResponseInfo - custom struct, see iisext.x

  Returns:
    HRESULT

*/
HRESULT
WAM_REQUEST::SendEntireResponseFast(
    HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo
)
{

    HRESULT hrRet = NOERROR;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
   
    //
    //  write status and header into buffer, but suppress actual send
    //  (by first setting m_fWriteHeaders = FALSE)
    //
    //  NOTE it is semi-hokey to use a member BOOL for this
    //  instead of passing an arg, but it saves cluttering the idl file
    //

    m_fWriteHeaders = FALSE;

    if ( FAILED( hrRet =
            SendHeader(
              (unsigned char *) pHseResponseInfo->HeaderInfo.pszStatus
              , pHseResponseInfo->HeaderInfo.cchStatus
              , (unsigned char *) pHseResponseInfo->HeaderInfo.pszHeader
              , pHseResponseInfo->HeaderInfo.cchHeader
              , pHseResponseInfo->HeaderInfo.fKeepConn
            ) ) ) {

        return hrRet;
    }

    m_fWriteHeaders = TRUE;


    //
    // NOTE: Caller must have allocated N+1 buffers
    // and filled buffers 1 through N with its data buffers.
    // We now fill the extra buffer (buffer 0) with header info,
    // generated by above SendHeader call.
    //
    //  NOTE we assert that empty array slot is 0'ed out.
    //  This is valid as long as this api stays private
    //  and all of its callers comply.
    //

    DBG_ASSERT( pHseResponseInfo->rgWsaBuf[0].len == 0 );
    DBG_ASSERT( pHseResponseInfo->rgWsaBuf[0].buf == NULL );

    pHseResponseInfo->rgWsaBuf[0].len = m_pHttpRequest->QueryRespBufCB();
    pHseResponseInfo->rgWsaBuf[0].buf = m_pHttpRequest->QueryRespBufPtr();


    //
    //  write wsa-buffer array:
    //

    return HresultFromBool(
                m_pHttpRequest->SyncWsaSend(
                    pHseResponseInfo->rgWsaBuf
                    , pHseResponseInfo->cWsaBuf
                    , &pHseResponseInfo->cbWritten
                ) );


} // WAM_REQUEST::SendEntireResponseFast()



/*---------------------------------------------------------------------*
WAM_REQUEST::SendEntireResponseNormal

  Description:
    Sends an entire response (headers and body) by surface mail.

  Arguments:
    pHseResponseInfo - custom struct, see iisext.x

  Returns:
    HRESULT

*/
HRESULT
WAM_REQUEST::SendEntireResponseNormal(
    HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo
)
{

    HRESULT hrRet = NOERROR;
    DWORD   cbWritten = 0;
    UINT    i;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    //
    //  init bytes-written count to 0 - we keep a running tally below
    //

    pHseResponseInfo->cbWritten = 0;


    //
    //  send headers
    //
    //  UNDONE need to get bytes-written back from SendHeader
    //

    DBG_ASSERT( m_fWriteHeaders );

    if ( FAILED( hrRet =
            SendHeader(
              (unsigned char *) pHseResponseInfo->HeaderInfo.pszStatus
              , pHseResponseInfo->HeaderInfo.cchStatus
              , (unsigned char *) pHseResponseInfo->HeaderInfo.pszHeader
              , pHseResponseInfo->HeaderInfo.cchHeader
              , pHseResponseInfo->HeaderInfo.fKeepConn
           /* , &cbWritten */
            ) ) ) {

        goto LExit;
    }


    pHseResponseInfo->cbWritten += cbWritten;


    //
    // Send body (data buffers)
    //
    // NOTE: Caller must have allocated N+1 buffers
    // and filled buffers 1 through N with its data buffers.
    // We ignore buffer 0 (unused in this case) and send
    // each data buffer by normal means.
    //

    for ( i = 1; i < pHseResponseInfo->cWsaBuf; i++ ) {

        if ( FAILED( hrRet =
                SyncWriteClient(
                   pHseResponseInfo->rgWsaBuf[i].len
                   , (unsigned char *) pHseResponseInfo->rgWsaBuf[i].buf
                   , &cbWritten,
                   0
                ) ) ) {

            goto LExit;
        }

        pHseResponseInfo->cbWritten += cbWritten;
    }


LExit:
    return hrRet;

} // WAM_REQUEST::SendEntireResponseNormal()



    /*******************************************
     *                                         *
     *  IWamRequest interface methods          *
     *                                         *
     *                                         *
     *******************************************/


/*-----------------------------------------------------------------------------*
    Support for WAM_REQUEST::GetCoreState


*/



/*-----------------------------------------------------------------------------*
HGetOopImpersonationToken

    Description

    Dup the handle for use in the hWam process.
    NOTE the WAM must release the handle after it is done with it.

    Arguments
        HANDLE hImpersonationToken - the impersonation token in this process
        HANDLE hWam - handle to wam process
        HANDLE *phOopImpersonationToken - Returned handle for use in the remote
               process

    Returns
        HRESULT

*/
HRESULT
HGetOopImpersonationToken(
    IN HANDLE hImpersonationToken,
    IN HANDLE hWam,
    OUT HANDLE *phOopImpersonationToken
    )
{
    HANDLE  hImpTokInChildProcessAddressSpace = NULL;
    HANDLE  hDuplicateToken = NULL;
    HRESULT hr = NOERROR;
    BOOL    fSuccess;

    DBG_ASSERT( hImpersonationToken != (HANDLE)0 );
    DBG_ASSERT( phOopImpersonationToken );

    *phOopImpersonationToken = NULL;

    do
    {
        fSuccess = 
            DupTokenWithSameImpersonationLevel( hImpersonationToken,
                                                TOKEN_ALL_ACCESS,
                                                TokenImpersonation,
                                                &hDuplicateToken
                                                );

        if( !fSuccess )
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d on DuplicateTokenEx\n",
                       GetLastError()
                       ));

            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        hr = GrantAllAccessToToken( hDuplicateToken );

        if( FAILED(hr) )
        {
            DBGPRINTF((DBG_CONTEXT,"Error %08x on GrantAllAccessToToken\n",
                       hr
                       ));
            DBG_ASSERT( SUCCEEDED(hr) );
            break;
        }

        fSuccess = DuplicateHandle(
                        g_pWamDictator->HW3SvcProcess(),         // Handle of W3Svc process
                        hDuplicateToken,                         // Handle to duplicate to remote process
                        hWam,                                    // Handle of Wam process
                        &hImpTokInChildProcessAddressSpace,      // Handle to token in remote process
                        0,                                       // ignored when DUPLICATE_SAME_ACCESS is passed
                        FALSE,                                   // inheritance flag
                        DUPLICATE_SAME_ACCESS                    // duplicate same access permissions as original
                        );

        if( !fSuccess )
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d on DuplicateHandle\n",
                       GetLastError()
                       ));

            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    
    } while( FALSE );

    if( hDuplicateToken )
    {
        CloseHandle( hDuplicateToken );
    }
    
    *phOopImpersonationToken = hImpTokInChildProcessAddressSpace;
    return hr;
}



#define APPEND_WRC_STRING( iString, pstr ) \
    DBG_ASSERT( pbWrcData );  \
    DBG_ASSERT( iString < WRC_C_STRINGS );  \
    DBG_ASSERT( (pstr) ); \
    cch = rgcchWrcStrings[ iString ] = (pstr)->QueryCCH();  \
    CopyMemory( pchCur, (pstr)->QueryStr(), cch+1 );    \
    rgcbWrcOffsets[ iString ] = DIFF(pchCur - pbWrcData);   \
    pchCur += cch+1;

/*-----------------------------------------------------------------------------*
WAM_REQUEST::GetCoreState
    Fills a caller-supplied buffer with wamreq core strings

Arguments:
    See below

Returns:
    HRESULT

*/
STDMETHODIMP
WAM_REQUEST::GetCoreState(
    DWORD           cbWrcData   // size of wamreq core data buffer
    , unsigned char * pbWrcData // ptr to address of wamreq core data buffer
    , DWORD           cbWRCF    // size of wamreq core fixed-length struct
    , unsigned char * pbWRCF    // ptr to address of struct - WAM_REQ_CORE_FIXED
)

{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::GetCoreState\n"
            , this
        ));
    }

    DBG_ASSERT( pbWrcData );
    DBG_ASSERT( pbWRCF );

    DBG_ASSERT( m_pExec );
    DBG_ASSERT( m_pHttpRequest );

    BOOL    fInProcess = m_pWamInfo->FInProcess();
    WAM_REQ_CORE_FIXED * pWamReqCoreFixed = reinterpret_cast< WAM_REQ_CORE_FIXED * >( pbWRCF );

    //
    // make sure the buffers are large enough (#157823)
    //
    if( cbWrcData < ( WRC_CB_FIXED_ARRAYS + CbWrcStrings( fInProcess ) ) 
        || cbWRCF < sizeof( WAM_REQ_CORE_FIXED) )
    {
        return ERROR_INVALID_PARAMETER;
    }


    /********************************************
     * Get variable-length (string) data
     *
     */


    /*
        Init string offsets array and string lengths array

        NOTE offsets to strings are stored at start of data buffer
        NOTE string lengths are stored immediately after offsets in data buffer

        sync WRC_DATA_LAYOUT
    */

    DWORD * rgcbWrcOffsets = (DWORD *) pbWrcData;
    DWORD * rgcchWrcStrings = ((DWORD *) pbWrcData) + WRC_C_STRINGS;

    // Init current copy ptr to start of strings section of buffer
    // sync WRC_DATA_LAYOUT
    unsigned char * pchCur = pbWrcData + WRC_CB_FIXED_ARRAYS;


    /* sync WRC_STRINGS */
    // NOTE append order MUST match WRC_I_ index order
    
    DWORD   cch = 0;
    APPEND_WRC_STRING( WRC_I_PATHINFO,    m_pExec->_pstrPathInfo )
    APPEND_WRC_STRING( WRC_I_PATHTRANS,   &m_strPathTrans )
    APPEND_WRC_STRING( WRC_I_METHOD,      (STR *) &m_pHttpRequest->QueryMethodStr() )
    APPEND_WRC_STRING( WRC_I_CONTENTTYPE, (STR *) &m_pHttpRequest->QueryContentTypeStr() )
    APPEND_WRC_STRING( WRC_I_URL,         (STR *) &m_pHttpRequest->QueryURLStr() )
    APPEND_WRC_STRING( WRC_I_ISADLLPATH,  &m_strISADllPath )
    APPEND_WRC_STRING( WRC_I_QUERY,       m_pExec->_pstrURLParams )
    APPEND_WRC_STRING( WRC_I_APPLMDPATH,  m_pHttpRequest->GetWAMMetaData()->QueryAppPath() )
    APPEND_WRC_STRING( WRC_I_USERAGENT,   &m_strUserAgent )
    APPEND_WRC_STRING( WRC_I_COOKIE,      &m_strCookie )
    APPEND_WRC_STRING( WRC_I_EXPIRES,     &m_strExpires )

    /********************************************
     * Get fixed-length data
     *
     */

    pWamReqCoreFixed->m_fAnonymous       = m_pHttpRequest->IsAnonymous();
    pWamReqCoreFixed->m_cbEntityBody     = m_pHttpRequest->QueryEntityBodyCB();
    pWamReqCoreFixed->m_cbClientContent  = m_pHttpRequest->QueryClientContentLength();
    pWamReqCoreFixed->m_fCacheISAPIApps  = m_pHttpRequest->QueryMetaData()->QueryCacheISAPIApps();
    pWamReqCoreFixed->m_dwChildExecFlags = m_pExec->_dwExecFlags;
    pWamReqCoreFixed->m_dwHttpVersion    = (m_pHttpRequest->QueryVersionMajor() << 16) |
                                            m_pHttpRequest->QueryVersionMinor();
    pWamReqCoreFixed->m_dwInstanceId     = m_pHttpRequest->QueryW3Instance()->QueryInstanceId();


    /********************************************
     * Get oop-dependent stuff
     *
     */

    if( fInProcess ) {

        //
        //  In-Proc: return the handle we already have
        //

        pWamReqCoreFixed->m_hUserToken = m_pExec->QueryImpersonationHandle();

    } else {

        //
        //  Out-Proc: duplicate and return a process-valid handle
        //  from the handle we already have
        //

        HRESULT hrTemp = HGetOopImpersonationToken(
                m_pExec->QueryImpersonationHandle(),
                m_pWamInfo->HWamProcess(),
                &(pWamReqCoreFixed->m_hUserToken)
                );

        if( FAILED(hrTemp) )
        {
            DBGPRINTF(( DBG_CONTEXT, 
                    "WAM_REQUEST[%p] HGetOopImpersonationToken() FAILED hr=%08x",
                    this, 
                    hrTemp
                    ));
            return hrTemp;
        }

        //
        //  Out-Proc: append entity body to end of strings
        //
        //  NOTE must do this here because it depends on
        //  pWamReqCoreFixed->m_cbEntityBody, which we fill above
        //

        DWORD cb = pWamReqCoreFixed->m_cbEntityBody;

        rgcchWrcStrings[ WRC_I_ENTITYBODY ] = cb;

        //
        // copy entity body into buffer
        // NOTE no null terminator
        //

        CopyMemory( pchCur, m_pHttpRequest->QueryEntityBody(), cb );

        //
        // set the offset from start of strings buffer to string we copied
        /* sync WRC_DATA_LAYOUT */
        //

        rgcbWrcOffsets[ WRC_I_ENTITYBODY ] = DIFF(pchCur - pbWrcData);

    }


    return NOERROR;

} // WAM_REQUEST::GetCoreState



/*-----------------------------------------------------------------------------*
WAM_REQUEST::QueryEntityBody

    Description
        Cover function

    Arguments


    Returns
        HRESULT

*/
STDMETHODIMP
WAM_REQUEST::QueryEntityBody
(
unsigned char ** ppbEntityBody
)
{

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::QueryEntityBody\n"
                    ,
                    this
                    ));
    }

    *ppbEntityBody = m_pHttpRequest->QueryEntityBody();
    return NOERROR;

}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::SetKeepConn

    Cover function



*/
STDMETHODIMP
WAM_REQUEST::SetKeepConn( int fKeepConn )
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::SetKeepConn\n"
                    ,
                    this
                    ));
    }

    m_pHttpRequest->SetKeepConn( fKeepConn );
    return NOERROR;

}


/*-----------------------------------------------------------------------------*
WAM_REQUEST::IsKeepConnSet

    Cover function



*/
STDMETHODIMP
WAM_REQUEST::IsKeepConnSet
(
BOOL *  pfKeepConn
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::IsKeepConnSet\n"
                    ,
                    this
                    ));
    }

    *pfKeepConn = m_pHttpRequest->IsKeepConnSet();
    return NOERROR;

}


/*-----------------------------------------------------------------------------*
WAM_REQUEST::GetInfoForName


*/
STDMETHODIMP
WAM_REQUEST::GetInfoForName
(
const unsigned char *   szVarName,
unsigned char *         pchBuffer,
DWORD                   cchBuffer,
DWORD *                 pcchRequired
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::GetInfoForName(%s)\n",
                    this,
                    szVarName
                    ));
    }


    BOOL fReturn = FALSE;

    DBG_ASSERT( m_pWamInfo );
    m_pWamInfo->NotifyGetInfoForName( (LPCSTR)szVarName );

    //
    //  set required buffer size to actual incoming size
    //  and do the look-up
    //

    *pcchRequired = cchBuffer;


    fReturn = m_pHttpRequest->GetInfoForName(   (const CHAR *) szVarName,
                                                (CHAR *) pchBuffer,
                                                pcchRequired );


    //
    // bail if buffer too small
    //

    if ( *pcchRequired > cchBuffer ) {

        return ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) );
    }


    return HresultFromBool( fReturn );

} // WAM_REQUEST::GetInfoForName()


/*-----------------------------------------------------------------------------*
WAM_REQUEST::AppendLogParameter

    Cover function



*/
STDMETHODIMP
WAM_REQUEST::AppendLogParameter
(
unsigned char * pszParam
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::AppendLogParameter\n"
                    ,
                    this
                    ));
    }

    return HresultFromBool( m_pHttpRequest->AppendLogParameter(
                                                        (CHAR *) pszParam ) );
}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::LookupVirtualRoot

Returns path-translated of a URL.

Arguments
    pchBuffer       - [in, out] contains URL coming in, path-tran going out
    cchBuffer       - [in]      size of buffer
    pcchRequired    - [out]     required size for path-tran

Returns:
    HRESULT

*/
STDMETHODIMP
WAM_REQUEST::LookupVirtualRoot
(
unsigned char * pchBuffer,
DWORD           cchBuffer,
DWORD *         pcchRequired
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::LookupVirtualRoot\n"
                    ,
                    this
                    ));
    }

    CanonURL((char *)pchBuffer, g_pInetSvc->IsSystemDBCS());
    
    // NOTE we pass buffer as both source and dest
    return LookupVirtualRootEx( pchBuffer,
                                pchBuffer,
                                cchBuffer,
                                pcchRequired,
                                NULL,
                                NULL,
                                NULL );

}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::LookupVirtualRootEx

Returns path-translated of a URL plus additional info

Arguments
    szURL           - [in]  URL string
    pchBuffer       - [out] buffer for returned path-tran
    cchBuffer       - [in]  size of path-tran buffer as passed
    pcchRequired    - [out] required size for path-tran buffer
    pcchMatchingPath- [out] number of matching chars in phys path - NULL to ignore
    pcchMatchingURL - [out] number of matching chars in URL - pass NULL to ignore
    pdwFlags        - [out] vroot attribute flags - pass NULL to ignore

Returns:
    HRESULT

*/
STDMETHODIMP
WAM_REQUEST::LookupVirtualRootEx
(
unsigned char * szURL,
unsigned char * pchBuffer,
DWORD           cchBuffer,
DWORD *         pcchRequired,
DWORD *         pcchMatchingPath,
DWORD *         pcchMatchingURL,
DWORD *         pdwFlags
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::LookupVirtualRootEx\n"
                    ,
                    this
                    ));
    }


    DBG_ASSERT( szURL );
    DBG_ASSERT( pchBuffer );
    DBG_ASSERT( pcchRequired );

    STACK_STR(  strPathTran, MAX_PATH);
    BOOL        fReturn = FALSE;

    fReturn = ( m_pHttpRequest->LookupVirtualRoot(
                                &strPathTran,
                                (const char *) szURL,
                                strlen((const char *) szURL),
                                pcchMatchingPath,       // pcchDirRoot,
                                pcchMatchingURL,        // pcchVRoot,
                                pdwFlags,               // pdwMask,
                                NULL,       // BOOL * pfFinished,
                                FALSE,      // BOOL fGetAcl,
                                NULL,       // PW3_METADATA * ppMetaData,
                                NULL        // PW3_URI_INFO * ppURIBlob
                            ) );


    if ( fReturn )
        {

        //
        //  Include one byte for the null terminator
        //
        *pcchRequired = strPathTran.QueryCB() + 1;

        if ( *pcchRequired <= cchBuffer )
            {

            // we have enough room in buffer so copy the str
            CopyMemory( pchBuffer, strPathTran.QueryStr(), *pcchRequired );

            }
        else
            {

            //
            // we don't have enough room in buffer
            // in normal case, we fail
            // in 'extended' case, we copy as much as buffer will hold
            //

            //
            // CHEESE ALERT
            // We check null-ness of the 'extended' dword ptrs
            // to determine whether we are in 'extended' or normal case
            // (cheaper than adding a BOOL to the interface)
            //
            // 'extended' <==> all ptrs are non-null
            //

            if ( !( pcchMatchingPath && pcchMatchingURL && pdwFlags ) )
                {

                // normal case - set error and bail
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                fReturn = FALSE;

                }
            else
                {

                // 'extended' case - copy as much as buffer will hold
                DWORD cch = min( *pcchRequired, cchBuffer );

                CopyMemory( pchBuffer, strPathTran.QueryStr(), cch );
                pchBuffer[cch - 1] = '\0';

                }

            }

        }

    return HresultFromBool( fReturn );

}   // WAM_REQUEST::LookupVirtualRootEx


/*-----------------------------------------------------------------------------*
WAM_REQUEST::GetVirtualPathToken

    Returns an impersonation token for the specified virtual path.
    
    WARNING: the token should be CloseHandle()d by caller.
    
Arguments
    See below

Returns:
    Nothing

*/
STDMETHODIMP
WAM_REQUEST::GetVirtualPathToken(
    IN  unsigned char * szURL,                  // virtual root 
#ifdef _WIN64
    OUT UINT64    * phToken                      // points to token (handle) placeholder
#else
    OUT ULONG_PTR * phToken                      // points to token (handle) placeholder
#endif
)
{
    PW3_METADATA pMD = NULL;
    BOOL fSuccess = FALSE;
    STACK_STR(  strPathTran, MAX_PATH);

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    DBG_ASSERT( szURL );
    DBG_ASSERT( phToken );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::GetVirtualPathToken(%s)\n"
                    ,
                    this,
                    szURL
                    ));
    }


    //
    // Get metabase data item pointer
    //

    fSuccess = m_pHttpRequest->LookupVirtualRoot(
                                  &strPathTran,
                                  (const char *) szURL,
                                  strlen((const char *) szURL),
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,   
                                  TRUE,       // BOOL fGetAcl,
                                  &pMD,       // PW3_METADATA * ppMetaData,
                                  NULL    
                                  );
    if(fSuccess) {

        //
        // We know this virtual root. Even if it may not have a token, we
        // could return TRUE to caller. Make sure they get a meaningful token.
        //

        *phToken = NULL;

        //
        // try to get access token for the specified URL
        //

        HANDLE hToken = pMD->QueryVrAccessToken();
        
        //
        // if we have it, make a duplicate. This is very expensive,
        // but we want to preserve transparency of inproc/out-of-proc,
        //

        if(hToken) 
        {
            // Client closes the handle we return

            HANDLE  hTokenLocalDuplicate = NULL;

            fSuccess = DupTokenWithSameImpersonationLevel( 
                hToken,
                MAXIMUM_ALLOWED,
                TokenPrimary,
                &hTokenLocalDuplicate
                );
                
            if( fSuccess )
            {
                if( m_pWamInfo->FInProcess() )
                {
#ifdef _WIN64
                    *phToken = (UINT64)hTokenLocalDuplicate;
#else
                    *phToken = (ULONG_PTR)hTokenLocalDuplicate;
#endif
                }
                else
                {
                    // In the oop case, duplicate the handle to the
                    // remote process.
                    HANDLE  hTokenRemote = NULL;

                    fSuccess = DuplicateHandle(
                                    g_pWamDictator->HW3SvcProcess(),
                                    hTokenLocalDuplicate,
                                    m_pWamInfo->HWamProcess(),
                                    &hTokenRemote,
                                    0,
                                    FALSE,
                                    DUPLICATE_SAME_ACCESS
                                    );

                    CloseHandle(hTokenLocalDuplicate);
#ifdef _WIN64
                    *phToken = (UINT64)hTokenRemote;
#else
                    *phToken = (ULONG_PTR)hTokenRemote;
#endif
                }
            }
        }
    }

    return HresultFromBool( fSuccess );
}

/*-----------------------------------------------------------------------------*
WAM_REQUEST::GetPrivatePtr
    Returns a 'private' ptr
    WARNING only for knowledgeable IN-PROC callers (ssinc, httpodbc, et al)

Arguments
    See below

Returns:
    Nothing

*/
STDMETHODIMP
WAM_REQUEST::GetPrivatePtr
(
DWORD       dwHSERequest,   // type of ServerSupportFunction request
unsigned char **    ppData  // [out] returned ptr
)
{

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::GetPrivatePtr\n"
                    ,
                    this
                    ));
    }


    switch( dwHSERequest ) {

        case HSE_PRIV_REQ_TSVCINFO: {
            *((PIIS_SERVICE *)*ppData) = g_pInetSvc;
            break;
        }

        case HSE_PRIV_REQ_HTTP_REQUEST: {
            *((HTTP_REQUEST **)*ppData) = m_pHttpRequest;
            break;
        }

        case HSE_PRIV_REQ_VROOT_TABLE: {

            //
            //  UNDONE we think no one uses this ???
            //  REMOVE this case if so
            //

            DBG_ASSERT( FALSE );
            *ppData = NULL;
            return HRESULT_FROM_WIN32( ERROR_INVALID_FUNCTION );

            *((PIIS_VROOT_TABLE *)*ppData) =
                m_pHttpRequest->QueryW3Instance()->QueryVrootTable();
            break;
        }

        case HSE_PRIV_REQ_TSVC_CACHE: {
            *((TSVC_CACHE **)*ppData) =
                &m_pHttpRequest->QueryW3Instance()->GetTsvcCache();
            break;
        }

        default: {
            DBG_ASSERT( FALSE );
        }

    }

    return NOERROR;
}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::AsyncReadClientExt
    This function exists simply to avoid cross-process calls.

Arguments:

    NOTE pWamExecInfo is passed as DWORD to fool the marshaller.
         We simply hold it in WAM_REQUEST::m_pWamExecInfo, do nothing with it,
         then pass it back to wam on i/o completion callback.

Returns:
    BOOL

*/
STDMETHODIMP
WAM_REQUEST::AsyncReadClientExt(
#ifdef _WIN64
    IN      UINT64    pWamExecInfo
#else
    IN      ULONG_PTR pWamExecInfo
#endif
    , OUT   unsigned char * lpBuffer
    , IN    DWORD   nBytesToRead
    )
{
    BOOL    fReturn = FALSE;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::AsyncReadClientExt\n"
                    ,
                    this
                    ));
    }


    m_pWamExecInfo = (WAM_EXEC_INFO *) pWamExecInfo;
    DBG_ASSERT( m_pWamExecInfo );


    //
    // If chunked read already complete, call notification routine 
    // and return success
    //
    if(m_pHttpRequest->IsChunked() && m_pHttpRequest->IsChunkedReadComplete()) {
#ifdef _WIN64
        m_pWamInfo->ProcessAsyncIO( this, (UINT64) m_pWamExecInfo, 0, 0 );
#else
        m_pWamInfo->ProcessAsyncIO( this, (ULONG_PTR) m_pWamExecInfo, 0, 0 );
#endif
        return HresultFromBool( TRUE );
    }

    m_pHttpRequest->SetState( HTR_GATEWAY_ASYNC_IO, HT_DONT_LOG, NO_ERROR );



    //
    //  Ref before starting async i/o operation
    //
    //  NOTE this is balanced by deref in ProcessAsyncGatewayIO
    //

    AddRef();

    //
    // Save buffer pointer and size in case we need to 
    // restart chunk-encoded transfer  
    // (when the decoded data has 0 bytes) 
    //
    
    m_pAsyncReadBuffer      = lpBuffer;
    m_dwAsyncReadBufferSize = nBytesToRead;

    //
    // Let the completion routine know that we do need to decode 
    //
    
    m_fAsyncWrite = FALSE;

    fReturn = m_pHttpRequest->ReadFile(
                    lpBuffer
                    , nBytesToRead
                    , NULL
                    , IO_FLAG_ASYNC
                    );


    if ( !fReturn ) {
        //
        //  Deref if async i/o operation failed (balances above ref)
        //

        Release();

        m_pHttpRequest->SetState( HTR_DOVERB, HT_DONT_LOG, NO_ERROR );
    }
    return HresultFromBool( fReturn );
}

STDMETHODIMP
WAM_REQUEST::AsyncReadClientOop(
#ifdef _WIN64
    IN      UINT64    pWamExecInfo
#else
    IN      ULONG_PTR pWamExecInfo
#endif
    , IN    DWORD   nBytesToRead
    )
{
    DBG_ASSERT( nBytesToRead > 0 );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::AsyncReadClientOop\n"
                    ,
                    this
                    ));
    }

    m_pbAsyncReadOopBuffer = (LPBYTE)LocalAlloc( LPTR, nBytesToRead );
    if( !m_pbAsyncReadOopBuffer )
    {
        return E_OUTOFMEMORY;
    }
    
    HRESULT hr = AsyncReadClientExt( pWamExecInfo, m_pbAsyncReadOopBuffer, nBytesToRead );

    if( FAILED(hr) )
    {
        // If this call fails then the async callback should never be made.
        DBG_ASSERT( m_pbAsyncReadOopBuffer );
        
        LocalFree( m_pbAsyncReadOopBuffer );
        m_pbAsyncReadOopBuffer = NULL;
    }
    
    return hr;
}

/*-----------------------------------------------------------------------------*
WAM_REQUEST::AsyncWriteClient

Arguments:

    NOTE pWamExecInfo is passed as ULONG_PTR to fool the marshaller.
         We simply hold it in WAM_REQUEST::m_pWamExecInfo, do nothing with it,
         then pass it back to wam on i/o completion callback.

Returns:
    HRESULT

*/
STDMETHODIMP
WAM_REQUEST::AsyncWriteClient(
#ifdef _WIN64
    UINT64            pWamExecInfo
#else
    ULONG_PTR            pWamExecInfo
#endif
    , unsigned char *   lpBuffer
    , DWORD             nBytesToWrite
    , DWORD             dwFlags
)
{

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::AsyncWriteClient\n"
            , this
        ));

    }


    m_pHttpRequest->SetState(
        HTR_GATEWAY_ASYNC_IO
        , HT_DONT_LOG
        , NO_ERROR
    );


    m_pWamExecInfo = (WAM_EXEC_INFO *) pWamExecInfo;
    DBG_ASSERT( m_pWamExecInfo );


    //
    //  Ref before starting async i/o operation
    //
    //  NOTE this is balanced by deref in ProcessAsyncGatewayIO
    //

    AddRef();

    //
    // Mark the operation as "WRITE" so if we are in the process of
    // decoding chunked upload, we won't attempt to decode on 
    // a completion of THIS async write
    //
    
    m_fAsyncWrite = TRUE;

    //
    // Strip off undefined flags
    //
    
    dwFlags &= IO_FLAG_NO_DELAY;

    BOOL fReturn = m_pHttpRequest->WriteFile(
                        (LPVOID) lpBuffer
                        , nBytesToWrite
                        , NULL
                        , IO_FLAG_ASYNC | dwFlags
                    );


    if ( !fReturn ) {

        //
        //  Deref if async i/o operation failed (balances above ref)
        //

        Release();

        m_pHttpRequest->SetState(
            HTR_DOVERB
            , HT_DONT_LOG
            , NO_ERROR
        );

    }


    return HresultFromBool( fReturn );
}



/*---------------------------------------------------------------------*
WAM_REQUEST::TransmitFileInProc
    Interface to TransmitFile which works in-proc only

Arguments:
    pWamExecInfo    - ptr to this wamreq's wamexecinfo (in wam process)
    pHseTfIn        - ptr to transmit-file-info struct

    NOTE pWamExecInfo is passed as ULONG_PTR to fool the marshaller.
         We simply hold it in WAM_REQUEST::m_pWamExecInfo, do nothing with it,
         then pass it back to wam on i/o completion callback.

Returns:
    HRESULT

*/
STDMETHODIMP
WAM_REQUEST::TransmitFileInProc(
#ifdef _WIN64
    IN UINT64                pWamExecInfo
#else
    IN ULONG_PTR             pWamExecInfo
#endif
    , IN unsigned char *    pHseTfIn
)
{

    HRESULT         hrRet = NOERROR;
    HSE_TF_INFO *   pHseTfi = reinterpret_cast<HSE_TF_INFO *>(pHseTfIn);
    DWORD           dwFlags = IO_FLAG_ASYNC;
    PVOID           pHead = NULL;
    DWORD           cbHead = 0;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::TransmitFileInProc\n"
            , this
        ));

    }


    //
    // Don't disconnect the socket after the transmit if we need
    // to notify a filter about the end of a request
    //

    if ( !m_pHttpRequest->QueryFilter()->IsNotificationNeeded(
            SF_NOTIFY_END_OF_REQUEST
            , m_pHttpRequest->IsSecurePort()
          )
          && (pHseTfi->dwFlags & HSE_IO_DISCONNECT_AFTER_SEND) ) {

        // suggests fast close & reuse of data socket
        dwFlags |= (TF_DISCONNECT | TF_REUSE_SOCKET);
    }

    //
    // Honor the HSE_IO_NODELAY flag. HTTP_REQ_BASE::WriteClient will 
    // handle this flag for WriteClient. Note: Both of these calls will
    // have the effect of leaving the flag set or unset on the socket.
    // This shouldn't really be an issue as it is not likely that the
    // user would want same client connection to change settings.
    //
    AtqSetSocketOption( m_pHttpRequest->QueryClientConn()->QueryAtqContext(), 
                        TCP_NODELAY, 
                        (pHseTfi->dwFlags & HSE_IO_NODELAY) ? 1 : 0
                        );

    //
    // Check if ISAPI requests us to send headers
    // If we need to send headers, we will call upon BuildHttpHeader()
    //  to construct a custom header for the client.
    // It is the application's responsibility not to use
    //   HSE_REQ_SEND_RESOPNSE_HEADER if it chooses to use
    //   the header option HSE_IO_SEND_HEADERS.
    //

    if ( pHseTfi->dwFlags & HSE_IO_SEND_HEADERS) {

        BOOL fFinished = FALSE;

        //
        // Format the header using the pszStatusCode and
        //  extra headers specified in pHseTfi->pHead.
        //

        if ( pHseTfi->pszStatusCode 
             && ( (!strncmp( (char *) pHseTfi->pszStatusCode, "401 ", sizeof("401 ")-1 ) ) ||
                  (!strncmp( (char *) pHseTfi->pszStatusCode, "407 ", sizeof("407 ")-1 ) ) )
            ) {

            m_pHttpRequest->SetDeniedFlags( SF_DENIED_APPLICATION );
            m_pHttpRequest->SetAuthenticationRequested( TRUE );
        }

        // 
        // BuildHttpHeader doesn't provide the \r\n final terminator for
        // the header block. If pHead contains nothing, then the response
        // will be malformed.
        //
        if ( !m_pHttpRequest->BuildHttpHeader(
                                &fFinished
                                , (CHAR * )  pHseTfi->pszStatusCode
                                , (CHAR * )  pHseTfi->pHead
                              ) ) {

            hrRet = E_FAIL; // UNDONE something besides E_FAIL???
            goto LExit;
        }

        pHead  = m_pHttpRequest->QueryRespBufPtr();
        cbHead = m_pHttpRequest->QueryRespBufCB();

        //
        // Check if any filters are to be notified about the headers
        //
        if ( m_pHttpRequest->QueryFilter()->IsNotificationNeeded( SF_NOTIFY_SEND_RESPONSE,
                                                               m_pHttpRequest->IsSecurePort() ) )
        {
            BOOL fFinished = FALSE;
            BOOL fAnyChanges = FALSE;

            if ( !m_pHttpRequest->QueryFilter()->NotifySendHeaders( (const CHAR*) pHead,
                                                                    &fFinished,
                                                                    &fAnyChanges,
                                                                m_pHttpRequest->QueryRespBuf() ) )
            {
                hrRet = E_FAIL;
                goto LExit;
            }

            pHead = m_pHttpRequest->QueryRespBufPtr();
            cbHead = m_pHttpRequest->QueryRespBufCB();
        }

    } else {

        pHead  = pHseTfi->pHead;
        cbHead = pHseTfi->HeadLength;
    }

    //
    // Setup stage for and execute TransmitFile operation
    //

    //
    //  1. Set Request state to be async IO from ISAPI client
    //  2. Cache wamexec info ptr in member
    //  3. Submit Async IOP
    //  4. return to the ISAPI application
    //

    m_pHttpRequest->SetState(
        HTR_GATEWAY_ASYNC_IO
        , HT_DONT_LOG
        , NO_ERROR
    );

    m_pWamExecInfo = (WAM_EXEC_INFO *) pWamExecInfo;
    DBG_ASSERT( m_pWamExecInfo );


    //
    //  Ref before starting async i/o operation
    //
    //  NOTE this is balanced by deref in ProcessAsyncGatewayIO
    //

    AddRef();

    //
    // Mark the operation as "WRITE" so if we are in the process of
    // decoding chunked upload, we won't attempt to decode on 
    // a completion of THIS async write
    //
    m_fAsyncWrite = TRUE;

    hrRet = HresultFromBool( m_pHttpRequest->TransmitFile(
                                NULL,
                                pHseTfi->hFile
                                , pHseTfi->Offset
                                , pHseTfi->BytesToWrite
                                , dwFlags | IO_FLAG_NO_RECV
                                , (PVOID) pHead
                                , cbHead
                                , (PVOID) pHseTfi->pTail
                                , pHseTfi->TailLength
                            ) );


    if ( FAILED( hrRet ) ) {

        //
        //  Deref if async i/o operation failed (balances above ref)
        //

        Release();

        m_pHttpRequest->SetState(
            HTR_DOVERB
            , HT_DONT_LOG
            , NO_ERROR
        );
    }


LExit:
    return hrRet;

}   // WAM_REQUEST::TransmitFileInProc



/*---------------------------------------------------------------------*
WAM_REQUEST::TransmitFileOutProc
    Interface to TransmitFile, recommended for out-of-proc only
    (works in-proc, but is slower than TransmitFileInProc).

    This function is a simple cover over TransmitFileInProc.
    It does the following:
    - dups the file handle into this process
    - creates a local TransmitFile-info struct from the in-args
    - calls TransmitFileInProc to do the real work

Arguments:
    pWamExecInfo    - ptr to this wamreq's wamexecinfo (in wam process)
    other params    - transmit-file-info struct, as individual args

    NOTE pWamExecInfo is passed as DWORD to fool the marshaller.
         We simply hold it in WAM_REQUEST::m_pWamExecInfo, do nothing with it,
         then pass it back to wam on i/o completion callback.

Returns:
    HRESULT

*/
STDMETHODIMP
WAM_REQUEST::TransmitFileOutProc(
#ifdef _WIN64
    IN UINT64              pWamExecInfo
    , IN UINT64            hFile    // file handle valid in WAM process
#else
    IN ULONG_PTR           pWamExecInfo
    , IN ULONG_PTR         hFile    // file handle valid in WAM process
#endif
    , IN unsigned char *   pszStatusCode
    , IN DWORD             cbStatusCode
    , IN DWORD             BytesToWrite
    , IN DWORD             Offset
    , IN unsigned char *   pHead
    , IN DWORD             HeadLength
    , IN unsigned char *   pTail
    , IN DWORD             TailLength
    , IN DWORD             dwFlags
)
{

    HSE_TF_INFO     HseTfi;         // TransmitFile-info struct
    HRESULT         hr;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::TransmitFileOutProc\n"
            , this
        ));

    }


    if( hFile != NULL )
    {
        //
        //  Dup file handle into member to keep it around
        //  throughout async i/o operation.
        //
        //  NOTE we close file handle elsewhere, once we know
        //  it is no longer needed
        //
        //  CONSIDER don't dup handle when not needed
        //  Is handle not needed when BytesToWrite > 0 ???
        //

        if ( !DuplicateHandle(
                m_pWamInfo->HWamProcess()         // source process handle
                , (HANDLE) hFile                  // handle to duplicate
                , g_pWamDictator->HW3SvcProcess() // target process handle
                , &m_hFileTfi                     // ptr to duplicate handle
                , 0 // dwDesiredAccess - ignored with DUPLICATE_SAME_ACCESS
                , FALSE                           // non-inheritable
                , DUPLICATE_SAME_ACCESS           // optional actions
            ) ) {

            return HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE );
        }


        DBG_ASSERT( m_hFileTfi != INVALID_HANDLE_VALUE );
    }
    else
    {
        // No file handle only the head and tail buffers will be
        // sent.

        DBG_ASSERT( BytesToWrite == 0 );
        DBG_ASSERT( Offset == 0 );
    }


    //
    //  Copy in-args into TransmitFile-info struct,
    //  making sure that any custom heads and tails are zero-terminated
    //

    if( pszStatusCode != NULL ) {
        if( cbStatusCode != 0 ) {
            if( pszStatusCode[cbStatusCode - 1] != '\0') {
                m_pszStatusTfi = (unsigned char *) 
                    LocalAlloc( LMEM_FIXED, cbStatusCode + 1 );
                if ( m_pszStatusTfi ) {
                    memcpy( m_pszStatusTfi, pszStatusCode, cbStatusCode );
                    m_pszStatusTfi[cbStatusCode] = '\0';
                    pszStatusCode = m_pszStatusTfi;
                }
            }
        } else {
            // there is a pointer, but 0 length -- sanitize it
            pszStatusCode = (unsigned char *) "";
        }
    }

    if( pHead != NULL ) {
        if( HeadLength != 0 ) {
            if ( pHead[HeadLength - 1] != '\0' ) { 
                m_pszHeadTfi = (unsigned char *) 
                    LocalAlloc( LMEM_FIXED, HeadLength + 1 );
                if( m_pszHeadTfi ) {
                    memcpy( m_pszHeadTfi, pHead, HeadLength );
                    m_pszHeadTfi[HeadLength] = '\0';
                    pHead = m_pszHeadTfi;
                }    
            }
        } else {
            pHead = (unsigned char *) "";
        }
    }

    if( pTail != NULL ) {
        if ( TailLength != 0 ) {
            if( pTail[TailLength - 1] != '\0')  {
                m_pszTailTfi = (unsigned char *) 
                    LocalAlloc( LMEM_FIXED, TailLength + 1 );
                if( m_pszTailTfi ) {
                    memcpy( m_pszTailTfi, pTail, TailLength );
                    m_pszTailTfi[TailLength] = '\0';
                    pTail = m_pszTailTfi;
                }
             }
         } else {
            pTail = (unsigned char *)"";
         }
    }

    HseTfi.hFile = ( hFile ) ? (HANDLE) m_hFileTfi : NULL;
    HseTfi.pszStatusCode = (const char *) pszStatusCode;
    HseTfi.BytesToWrite = BytesToWrite;
    HseTfi.Offset = Offset;
    HseTfi.pHead = pHead;
    HseTfi.HeadLength = HeadLength;
    HseTfi.pTail = pTail;
    HseTfi.TailLength = TailLength;
    HseTfi.dwFlags = dwFlags;


    //
    //  Invoke in-proc function to do the real work
    //

    hr = TransmitFileInProc(
             pWamExecInfo
             , (unsigned char *) &HseTfi
            );

    if ( FAILED( hr ) )
    {
        if( m_pszStatusTfi ) 
        {
            LocalFree( m_pszStatusTfi );
            m_pszStatusTfi = NULL;
        }

        if( m_pszHeadTfi ) 
        {
            LocalFree( m_pszHeadTfi );
            m_pszHeadTfi = NULL;
        }

        if( m_pszTailTfi ) 
        {
            LocalFree( m_pszTailTfi );
            m_pszTailTfi = NULL;
        }
    }
    
    return hr;

}   // WAM_REQUEST::TransmitFileOutProc



/*-----------------------------------------------------------------------------*
WAM_REQUEST::SyncReadClient

  Description:
    This function is a wrapper for the sychronous read from the client.
    It is separated from the async case because no async state changes
     need to be done here => cleaner function

  Arguments:
    lpBuffer - pointer to buffer into which the contents have to be read-in
    nBytesToRead - number of bytes the buffer can accomodate
    pnBytesRead - pointer to location that will contain the # of bytes returned

  Returns:
    TRUE for success and FALSE for failure

*/
STDMETHODIMP
WAM_REQUEST::SyncReadClient
(
unsigned char * lpBuffer,   // LPVOID  lpBuffer,
DWORD   nBytesToRead,
DWORD * pnBytesRead
)
{
    BOOL fSuccess;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    DBG_ASSERT( m_pHttpRequest->QueryClientConn()->CheckSignature() );
    


    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT, "WAM_REQUEST[%p]::"
                    "SyncReadClient( %p, %d, %p)\n",
                    this, lpBuffer, nBytesToRead, pnBytesRead));
    }

retry:

    //
    // Handle the case when Chunked read was complete.
    //
    
    if( m_pHttpRequest->IsChunked() && m_pHttpRequest->IsChunkedReadComplete() ) {
        *pnBytesRead = 0;
        fSuccess = TRUE;
        goto done;
    }

    fSuccess = m_pHttpRequest->ReadFile( lpBuffer,
                                          nBytesToRead,
                                          pnBytesRead,
                                          IO_FLAG_SYNC );
                                          
    if(fSuccess && m_pHttpRequest->IsChunked() && *pnBytesRead) {
    
        //
        // Decode read bytes
        // 

        DWORD cbToDecode = *pnBytesRead;
        
        if( m_pHttpRequest->DecodeChunkedBytes( lpBuffer, pnBytesRead ) ) {

            DBGPRINTF(( DBG_CONTEXT, "WAM_REQUEST[%p]::"
                        "DecodeChunkedBytes got %d out of %d bytes\n",
                    this, *pnBytesRead, cbToDecode ));
            
        
            if( *pnBytesRead == 0 && !m_pHttpRequest->IsChunkedReadComplete()) {
            
                //
                // We decoded zero bytes. This means that all bytes 
                // that we've read were chunk headers or footers.
                // 
                // We can't return THAT to the caller, because it will
                // think that we are done with reading. 
                // 
                // We'll have to initiate another read.
                //
                
                goto retry;
            }
            
        }
        
    }
    
    //
    // Increment the count of request entity body bytes read. This
    // is used in logging how many bytes the client sent, etc.
    //

    m_pHttpRequest->AddTotalEntityBodyCB( *pnBytesRead );
    
done:
    return HresultFromBool( fSuccess );

} // WAM_REQUEST::SyncReadClient()




/*-----------------------------------------------------------------------------*
WAM_REQUEST::SyncWriteClient

  Description:
    This function is a wrapper for the sychronous write to the client.
    It is separated from the async case because no async state changes
     need to be done here => cleaner function

  Arguments:
    lpBuffer - pointer to buffer that has contents to be written out
    nBytesToWrite   - number of bytes to write to client
    pnBytesWritten  - pointer to number of bytes written to client

  Returns:
    TRUE for success and FALSE for failure

*/
STDMETHODIMP
WAM_REQUEST::SyncWriteClient
(
DWORD   nBytesToWrite,
unsigned char * lpBuffer,   // LPVOID  lpBuffer,
DWORD * pnBytesWritten,
DWORD dwFlags
)
    {
    
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    DBG_ASSERT( m_pHttpRequest->QueryClientConn()->CheckSignature() );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT, "WAM_REQUEST[%p]::"
                    "SyncWriteClient( %p, %d)\n",
                    this, lpBuffer, nBytesToWrite));
    }

    // strip off undefined flags
    dwFlags &= IO_FLAG_NO_DELAY;

    return HresultFromBool( m_pHttpRequest->WriteFile( lpBuffer,
                                    nBytesToWrite,
                                    pnBytesWritten,
                                    IO_FLAG_SYNC | dwFlags ) );

    } // WAM_REQUEST::SyncWriteClient()



/*---------------------------------------------------------------------*
WAM_REQUEST::SendHeader

  Description:

  Arguments:
    szStatus        - status string
    cchStatus       - length of status string
    szHeader        - header string
    cchHeader       - length of header string
    dwIsaKeepConn   - keep/close/no-change connection?

  Returns:
    HRESULT

*/
STDMETHODIMP
WAM_REQUEST::SendHeader(
    IN    unsigned char * szStatus
    , IN  DWORD           cchStatus
    , IN  unsigned char * szHeader
    , IN  DWORD           cchHeader
    , IN  DWORD           dwIsaKeepConn
)
{

    HRESULT     hrRet = NOERROR;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    //
    // Make sure the strings are zero-terminated (#157805)
    //
    
    if( !IsStringTerminated( (LPCSTR) szStatus, cchStatus ) || 
        !IsStringTerminated( (LPCSTR) szHeader, cchHeader ) ) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::SendHeader( %s, %s)"
              "\n"
            , this
            , szStatus
            , szHeader
        ));

        DBGPRINTF(( DBG_CONTEXT,
            "WAM_REQUEST::SendHeader: "
            "Intended keep-conn = %d "
            "\n"
            , dwIsaKeepConn
        ));

    }

    DBG_ASSERT( m_pExec );
    DBG_ASSERT( m_pHttpRequest );


    //
    //  If this is a child ISA, we may not want to send any headers
    //

    if ( m_pExec->NoHeaders() || m_pExec->RedirectOnly() ) {

        DWORD       cbSent;
        BYTE *      pbTextToSend;

        //
        //  If no headers needed, just send everything past the
        //  "\r\n\r\n"
        //

        pbTextToSend = ScanForTerminator( (char *) szHeader );
        pbTextToSend = ( pbTextToSend == NULL )
                        ? (BYTE * ) szHeader
                        : pbTextToSend;

        cbSent = lstrlen( (CHAR*) pbTextToSend );
        hrRet = SyncWriteClient( cbSent, pbTextToSend, &cbSent, 
                                 IO_FLAG_NO_DELAY );

        goto LExit;

    } else {

        BOOL  fFinished;

        //
        //  If ISA specified a keep-conn change:
        //  Set request's keep-conn state to AND of ISA setting
        //  and client setting (which is request's current setting)
        //
        //  NOTE this means that if ISA said KEEPCONN_TRUE or
        //  KEEPCONN_OLD_ISAPI we no-op.
        //
        //  NOTE we do this before building headers to ensure
        //  correct keep-alive behavior.
        //

        if ( dwIsaKeepConn == KEEPCONN_FALSE
             || dwIsaKeepConn == KEEPCONN_OLD_ISAPI ) {

            m_pHttpRequest->SetKeepConn( FALSE );
        }


        IF_DEBUG( WAM_ISA_CALLS ) {

            DBGPRINTF(( DBG_CONTEXT,
                "WAM_REQUEST::SendHeader: "
                "Actual keep-conn = %d "
                "\n"
                , m_pHttpRequest->IsKeepConnSet()
            ));
        }


        //
        //  Build the typical server response headers for the extension DLL
        //

        if ( szStatus
             && ( (!strncmp( (char *) szStatus, "401 ", sizeof("401 ")-1 ) ) ||
                  (!strncmp( (char *) szStatus, "407 ", sizeof("407 ")-1 ) ) )
            ) {

            m_pHttpRequest->SetDeniedFlags( SF_DENIED_APPLICATION );
            m_pHttpRequest->SetAuthenticationRequested( TRUE );
        }


        if ( szHeader ) {

            // NYI: Ugly cast of const char * to "char *"
            m_pHttpRequest->CheckForBasicAuthenticationHeader(
                (char * ) szHeader
            );
        }


        // NYI: Ugly cast of const char * to "char *"
        hrRet = HresultFromBool( m_pHttpRequest->SendHeader(
                                    (char * ) szStatus
                                    , (char * ) (( szHeader)
                                      ? ( szHeader)
                                      : (unsigned char * ) "\r\n")
                                    , IO_FLAG_SYNC
                                    , &fFinished
                                    , 0 // dwOptions
                                    , m_fWriteHeaders
                                ));


        // NYI: I need to figure out what this fFinished was there for
        //  borrowed from ext\isplocal.cxx::ServerSupportFunction()
        DBG_ASSERT( !fFinished );

    }


LExit:
    return hrRet;

} // WAM_REQUEST::SendHeader()



/*---------------------------------------------------------------------*
WAM_REQUEST::SendEntireResponse

  Description:
    Sends an entire response (headers and body).

    NOTE this is a private api provided as a performance optimization
    for ASP

    NOTE Works only in-process.
    [would be LOTS of work to support oop - must marshal all buffers]

  Arguments:
    pvHseResponseInfo - custom struct, see iisext.x

  Returns:
    HRESULT

*/
STDMETHODIMP
WAM_REQUEST::SendEntireResponse(
    unsigned char * pvHseResponseInfo    // HSE_SEND_ENTIRE_RESPONSE_INFO *
)
{

    HRESULT hrRet = NOERROR;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    //
    //  figure out whether we need to invoke filter(s) or not.
    //  we need to invoke filter(s) if either the raw-data-notify
    //  or headers-notify flag is set.
    //
    //  if yes, we use normal code path to invoke filter(s).
    //
    //  if no, we use fastpath.
    //
    //  CONSIDER support filters in fastpath code as well
    //

    BOOL fMustUseFilter =
        m_pHttpRequest->QueryFilter()->IsNotificationNeeded(
            SF_NOTIFY_SEND_RAW_DATA | SF_NOTIFY_SEND_RESPONSE
            , m_pHttpRequest->IsSecurePort()
        );


    if ( fMustUseFilter ) {

        hrRet = SendEntireResponseNormal(
                    reinterpret_cast
                        <HSE_SEND_ENTIRE_RESPONSE_INFO *>
                            (pvHseResponseInfo)
                );

    } else {

        hrRet = SendEntireResponseFast(
                    reinterpret_cast
                        <HSE_SEND_ENTIRE_RESPONSE_INFO *>
                            (pvHseResponseInfo)
                );

    }


    return hrRet;


} // WAM_REQUEST::SendEntireResponse()

/*++
    WAM_REQUEST::SendEntireResponseAndCleanup

    Description:

        This routine is designed to provide the same functionality as
        the SendEntireResponse method for oop applications but will do
        the CleanupWamRequest call, so that no additional RPC calls are
        needed.

        This will enable oop asp to send the request and cleanup in
        a single RPC call. Currently oop asp requests use multiple
        RPC calls that do synchronous IO:

        1. SendHeaders
        2. WriteClient * number of response buffers
        3. CleanupWamRequest
        4. Release

        This interface will collapse this to two RPC calls.
        
    Possible additional work:

        1. Do writes asyncronously.
        2. Use shared memory handles to pass the data.


    Other Notes:

        Possible ISAP race conditions. The _FirstThread synch
        method was removed for ease of implementation on the
        WAM side. This may need to be put into place and that
        code reworked if there are regressions.

        Figure out what paramter types make sense thoughout
        the code path. Right now I'm constantly casting from
        char * to unsigned char * and back. Ick.

    Arguments:

    Returns:

--*/
STDMETHODIMP
WAM_REQUEST::SendEntireResponseAndCleanup
( 
      IN  unsigned char *       szStatus
    , IN  DWORD                 cbStatus
    , IN  unsigned char *       szHeader
    , IN  DWORD                 cbHeader
    , IN  OOP_RESPONSE_INFO *   pOopResponseInfo
    , IN  unsigned char *       szLogData
    , IN  DWORD                 cbLogData
    , IN  DWORD                 dwIsaKeepConn
    , OUT BOOL *                pfDisconnected
)
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    DBG_ASSERT( m_pHttpRequest->QueryClientConn()->CheckSignature() );

    DBG_ASSERT( szStatus );
    DBG_ASSERT( szHeader );
    DBG_ASSERT( szLogData );
    DBG_ASSERT( pOopResponseInfo );
    DBG_ASSERT( pfDisconnected );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT, 
                    "WAM_REQUEST[%p]::SendEntireResponseAndCleanup()\n"
                    "szStatus: %s; cbHeader: %x;\n",
                    this, 
                    szStatus,
                    cbHeader
                    ));
    }

    // Assume that we will not do the cleanup inline
    *pfDisconnected = FALSE;

    //
    // The most obvious thing to do with the send entire response
    // for out of process is to repack the marshalled data into 
    // the format used by in the in process call and use that
    // call.
    //

    HSE_SEND_ENTIRE_RESPONSE_INFO   hseResponseInfo;
    
    // populate struct with header info
    hseResponseInfo.HeaderInfo.pszStatus = (LPCSTR)szStatus;
    hseResponseInfo.HeaderInfo.cchStatus = cbStatus;
    hseResponseInfo.HeaderInfo.pszHeader = (LPCSTR)szHeader;
    hseResponseInfo.HeaderInfo.cchHeader = cbHeader;
    hseResponseInfo.HeaderInfo.fKeepConn = 
        (dwIsaKeepConn == KEEPCONN_TRUE) ? TRUE : FALSE;

    
    // populate the wsa buffers
    hseResponseInfo.cWsaBuf = 1 + pOopResponseInfo->cBuffers;
    hseResponseInfo.rgWsaBuf = 
        (WSABUF *)(_alloca(hseResponseInfo.cWsaBuf * sizeof(WSABUF)));

    // first buffer is empty
    hseResponseInfo.rgWsaBuf[0].len = 0;
    hseResponseInfo.rgWsaBuf[0].buf = NULL;

    for ( DWORD i = 0; i < pOopResponseInfo->cBuffers; i++ )
    {
        hseResponseInfo.rgWsaBuf[i+1].len = pOopResponseInfo->rgBuffers[i].cbBuffer;
        hseResponseInfo.rgWsaBuf[i+1].buf = (LPSTR)pOopResponseInfo->rgBuffers[i].pbBuffer;
    }
    
    hr = SendEntireResponse( (LPBYTE)&hseResponseInfo );

    if( SUCCEEDED(hr) )
    {
        *pfDisconnected = TRUE;

        DWORD   dwStatus = atol( (LPSTR)szStatus );

        // We want to only do the cleanup on success and send back a failure 
        // indication to the WAM_EXEC_INFO this would allow normal
        // termination in the event that the client is disconnected, etc.
        HRESULT hrCleanup = CleanupWamRequest( szLogData, 
                                               cbLogData, 
                                               dwStatus, 
                                               dwIsaKeepConn 
                                               );
        DBG_ASSERT(SUCCEEDED(hrCleanup));
    }

    return hr;
}

/*-----------------------------------------------------------------------------*
WAM_REQUEST::SendURLRedirectResponse

    Descrption:
      Send an URL redirect message to the browser client

    Input:
      pData - pointer to buffer that contains the location to
                 redirect the client to.

    Return:
      BOOL

*/
STDMETHODIMP
WAM_REQUEST::SendURLRedirectResponse
(
unsigned char * pData
)
{
    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::SendURLRedirectResponse\n"
                    ,
                    this
                    ));
    }

    DBG_ASSERT( m_pExec );
    DBG_ASSERT( m_pHttpRequest );


    HRESULT     hrRet = NOERROR;

    if ( m_pExec->RedirectOnly() )
        {

        DWORD           cbLen;
        STACK_STR( strMessageString, 256 );
        STACK_STR( strOutputString, 512 );

        cbLen = LoadString( GetModuleHandle( W3_MODULE_NAME ),
                            IDS_URL_MOVED,
                            strMessageString.QueryStr(),
                            256 );
        if ( !cbLen )
            {
            hrRet = E_FAIL; // UNDONE can we be more explicit than E_FAIL
            goto LExit;
            }

        // NYI: Check for overflows!
        cbLen = wsprintf( strOutputString.QueryStr(),
                          strMessageString.QueryStr(),
                          (CHAR*) pData );

        hrRet = SyncWriteClient(
                    cbLen,
                    (unsigned char *) strOutputString.QueryStr(),
                    &cbLen, 
                    0 );
        }
    else
        {
        hrRet = SendRedirectMessage( (unsigned char *) pData);
        }

LExit:
    return hrRet;

}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::SendRedirectMessage

  Description:

  Arguments:

  Returns:

*/
STDMETHODIMP
WAM_REQUEST::SendRedirectMessage
(
unsigned char * szRedirect      // LPCSTR pszRedirect
)
{
    STACK_STR( strURL, 512);
    DWORD   cb;
    BOOL fFinished = FALSE;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    
    IF_DEBUG( WAM_ISA_CALLS ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::SendRedirectMessage( %s)\n",
                    this, szRedirect));
    }

    //
    // Construct a redirect message and send it synchronously
    //

    // UNDONE cleanup
    if ( strURL.Copy( (LPCSTR) szRedirect )             &&
         m_pHttpRequest->
           BuildURLMovedResponse( m_pHttpRequest->QueryRespBuf(),
                                  &strURL,
                                  HT_REDIRECT ) &&
         m_pHttpRequest->SendHeader( m_pHttpRequest->QueryRespBufPtr(),
                                     m_pHttpRequest->QueryRespBufCB(),
                                     IO_FLAG_SYNC,
                                     &fFinished ) ) {
        return NOERROR;
    }

    return E_FAIL;  // UNDONE can we say more than E_FAIL?

} // WAM_REQUEST::SendRedirectMessage()



//  UNDONE remove unused ???
/*-----------------------------------------------------------------------------*
WAM_REQUEST::GetSslCtxt

  Description:

  Arguments:

  Returns:

*/
STDMETHODIMP
WAM_REQUEST::GetSslCtxt
(
DWORD           cbCtxtHandle,
unsigned char * pbCtxtHandle    // PBYTE   pbCtxtHandle
)
{
    HRESULT hrRet = NOERROR;    // UNDONE not reset anywhere???

   DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
   
   IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT, "WAM_REQUEST[%p]::GetSslCtxt( %d, %p)\n",
                    this, cbCtxtHandle, pbCtxtHandle));
    }

    //
    // QuerySslCtxtHandle() returns a handle to certificate info.
    // This handle will be copied to the caller if cert is available
    // otherwise a NULL handle will be returned ( this is not considered
    // an error)
    //

    if ( m_pHttpRequest->QueryAuthenticationObj()->QuerySslCtxtHandle() ) {

        memcpy( pbCtxtHandle,
                m_pHttpRequest->QueryAuthenticationObj()->QuerySslCtxtHandle(),
                    sizeof( CtxtHandle ));
    } else {
        //  UNDONE: I need to send/set proper error code
        memset( pbCtxtHandle, 0, sizeof( CtxtHandle ));
    }

    return hrRet;

} // WAM_REQUEST::GetSslCtxt()



/*-----------------------------------------------------------------------------*
WAM_REQUEST::GetClientCertInfoEx

  Description:

  Arguments:

  Returns:

*/
STDMETHODIMP
WAM_REQUEST::GetClientCertInfoEx
(
IN  DWORD           cbAllocated,
OUT DWORD *         pdwCertEncodingType,
OUT unsigned char * pbCertEncoded,
OUT DWORD *         pcbCertEncoded,
OUT DWORD *         pdwCertificateFlags
)
{
    HRESULT         hrRet = NOERROR;

    DBG_ASSERT( m_dwSignature == WAM_REQUEST_SIGNATURE );
    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::GetClientCertInfoEx( %d, %p)\n",
                    this, cbAllocated, pbCertEncoded));
    }


    if ( !m_pHttpRequest->QueryAuthenticationObj()->GetClientCertBlob(
                                                cbAllocated,
                                                pdwCertEncodingType,
                                                pbCertEncoded,
                                                pcbCertEncoded,
                                                pdwCertificateFlags ) ) {

        //
        //  if get call failed, return last error (set by callee)
        //

        hrRet = HRESULT_FROM_WIN32( GetLastError() );
    }


    return hrRet;

} // WAM_REQUEST::GetClientCertInfoEx()



/*-----------------------------------------------------------------------------*
WAM_REQUEST::GetSspiInfo

  Description:

  Arguments:

  Returns:

*/
STDMETHODIMP
WAM_REQUEST::GetSspiInfo
(
DWORD  cbCtxtHandle,
unsigned char * pbCtxtHandle,   // PBYTE   pbCtxtHandle
DWORD  cbCredHandle,
unsigned char * pbCredHandle    // PBYTE   pbCredHandle
)
    {
    HRESULT hrRet = NOERROR;

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::GetSspiInfo( %d, %p, %d, %d)\n",
                    this, cbCtxtHandle, pbCtxtHandle,
                    cbCredHandle, pbCredHandle));
    }

    if ( m_pHttpRequest->IsClearTextPassword() ) {

        hrRet = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto LExit;
    }

    DBG_ASSERT( cbCtxtHandle == sizeof( CtxtHandle));

    if ( m_pHttpRequest->QueryAuthenticationObj()->QueryCtxtHandle() ) {

        memcpy( pbCtxtHandle,
                m_pHttpRequest->QueryAuthenticationObj()->QueryCtxtHandle(),
                sizeof( CtxtHandle ));
    } else {

        memset( pbCtxtHandle, 0, sizeof( CtxtHandle ));
    }

    DBG_ASSERT( cbCredHandle == sizeof( CredHandle));
    if ( m_pHttpRequest->QueryAuthenticationObj()->QueryCredHandle() ) {

        memcpy( pbCredHandle,
                m_pHttpRequest->QueryAuthenticationObj()->QueryCredHandle(),
                sizeof( CredHandle ));
    } else {
        memset( pbCredHandle, 0, sizeof( CredHandle ));
    }

LExit:
    return hrRet;
    } // WAM_REQUEST::GetSspiInfo()



/*-----------------------------------------------------------------------------*
WAM_REQUEST::RequestAbortiveClose

    Cover function



*/
STDMETHODIMP
WAM_REQUEST::RequestAbortiveClose( VOID )
{

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::RequestAbortiveClose\n"
                    ,
                    this
                    ));
    }

    return HresultFromBool( m_pHttpRequest->RequestAbortiveClose() );

}

/*-----------------------------------------------------------------------------*
WAM_REQUEST::CloseConnection
        
*/
STDMETHODIMP
WAM_REQUEST::CloseConnection( VOID )
{

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::CloseConnection\n",
                    this
                    ));
    }
    
    return HresultFromBool( m_pHttpRequest->CloseConnection() );

}


/*-----------------------------------------------------------------------------*
WAM_REQUEST::LogEvent
        
*/
STDMETHODIMP
WAM_REQUEST::LogEvent( DWORD dwEventId, unsigned char * szText )
{

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    szText ? 
                        "WAM_REQUEST[%p]::LogEvent: %d %s\n" :
                        "WAM_REQUEST[%p]::LogEvent: %d\n",
                    this,
                    dwEventId,
                    szText
                    ));
    }


    //
    // per KB Q129126, only SYSTEM can write to event log
    // temporarily revert to self.
    //

    HANDLE hToken = 0;
    OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &hToken );        


    //
    // Drop to SYSTEM context, but only if we have user token to return to
    //
    
    if( hToken ) {
        RevertToSelf( );
    }        

    //
    // We don't instantiate event log until needed - do it now
    //

    if( g_pWamEventLog == NULL ) {
    
        g_pWamEventLog = new EVENT_LOG( "WAM" );
        if( (g_pWamEventLog == NULL) || !g_pWamEventLog->Success() ) {
            DWORD dwError = g_pWamEventLog ? 
                g_pWamEventLog->GetErrorCode() : ERROR_NOT_ENOUGH_MEMORY;
            DBGPRINTF(( DBG_CONTEXT, 
                        "Failure to init WAM event log (%d)\n",
                        dwError
                        ));
            if(g_pWamEventLog) {
                delete g_pWamEventLog;
                g_pWamEventLog = NULL;
            }
        }
    }

    if( g_pWamEventLog != NULL ) {

        //
        // We let EVENT_LOG object handle any problems that may occur here 
        //

        const CHAR * apsz[1];
        apsz[0] = (const CHAR *)szText;
        g_pWamEventLog->LogEvent( dwEventId, 1, apsz, 0 );
    }

    if( hToken ) {
        SetThreadToken(NULL, hToken);
    }        
    
    //
    // There is really no point in returning any error from here --
    // our callers have enough problems already 
    //
    
    return HresultFromBool( TRUE );
}



/*-----------------------------------------------------------------------------*
WAM_REQUEST::SSIncExec

    Descrption:
      Executes SSInc #exec

    Input:
      szCommand     - command
      dwExecFlags   - HSE_EXEC_???
      pszVerb       - verb

    Return:
      HRESULT

*/
STDMETHODIMP
WAM_REQUEST::SSIncExec
(
unsigned char *szCommand,
DWORD dwExecFlags,
unsigned char *szVerb
)
{

    HRESULT hrRet = NOERROR;

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "WAM_REQUEST[%p]::SSIncExec\n"
                    ,
                    this
                    ));
    }

    //
    //  Ref before child exec operation, in case child exec
    //  introduces an asynchronicity.
    //

    AddRef();

    //
    // temporarily reset the binding of the WAM_REQUEST to HTTP_REQUEST
    // this will ensure that we do not tramp on rebinding a new WAM_REQUEST
    //  to the same HTTP_REQUEST
    //

    DBG_ASSERT( m_pHttpRequest->QueryWamRequest() == this );
    m_pHttpRequest->SetWamRequest( NULL );


    if ( dwExecFlags & HSE_EXEC_COMMAND ) {

        hrRet = HresultFromBool( m_pHttpRequest->ExecuteChildCommand(
                                        (char *)szCommand,
                                        dwExecFlags ));

    } else {

        hrRet = HresultFromBool( m_pHttpRequest->ExecuteChildCGIBGI(
                                        (char *)szCommand,
                                        dwExecFlags,
                                        (char *)szVerb ));

    }

    //
    // Restore the binding back.
    //

    DBG_ASSERT( m_pHttpRequest->QueryWamRequest() == NULL );
    m_pHttpRequest->SetWamRequest( this );

    //
    //  Deref after child exec operation
    //

    Release();

    return hrRet;

}



/*---------------------------------------------------------------------*
WAM_REQUEST::GetAspMDAllData

    Descrption:
      Private api for ASP that returns asp metadata in a buffer.  Equivalent
      of MD GetAllData.

    Parameters:

    Return:
      HRESULT

*/
STDMETHODIMP
WAM_REQUEST::GetAspMDAllData(
    IN      unsigned char * pszMDPath
    , IN    DWORD           dwMDUserType
    , IN    DWORD           dwDefaultBufferSize
    , OUT   unsigned char * pBuffer
    , OUT   DWORD *         pdwRequiredBufferSize
    , OUT   DWORD *         pdwNumDataEntries
)
{

    HRESULT hr = NOERROR, hrT;
    BOOL fT;
    METADATA_GETALL_RECORD  *pMDGetAllRec = (METADATA_GETALL_RECORD *)pBuffer;
    DWORD                   dwDataSetNumber = 0;
    IMDCOM* pMetabase = g_pWamDictator->PMetabase()->QueryPMDCOM();
    METADATA_HANDLE         hMetabase = NULL;
    const DWORD dwMDDefaultTimeOut  = 2000;

    DBG_ASSERT(pMetabase != NULL);

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::GetAspMDAllData\n"
            , this
        ));
    }

    // Only allow the return of the data that ASP needs.  Dont allow anything else
    if (dwMDUserType != IIS_MD_UT_WAM && dwMDUserType != ASP_MD_UT_APP)
        return(E_ACCESSDENIED);

    // Open the metabase key
    hr = pMetabase->ComMDOpenMetaObjectA(METADATA_MASTER_ROOT_HANDLE, pszMDPath,
                            METADATA_PERMISSION_READ, dwMDDefaultTimeOut, &hMetabase);
    if (FAILED(hr)) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::Metadata open failed %x\n"
            , this
            , hr
        ));

        return E_FAIL;
    }

    DBG_ASSERT( hMetabase );

    hr = pMetabase->ComMDGetAllMetaDataW( hMetabase,
                                L"",
                                METADATA_INHERIT,
                                dwMDUserType,
                                ALL_METADATA,
                                pdwNumDataEntries,
                                &dwDataSetNumber,
                                dwDefaultBufferSize,
                                (unsigned char *)pBuffer,
                                pdwRequiredBufferSize
                                );

    hrT = pMetabase->ComMDCloseMetaObject(hMetabase);
    DBG_ASSERT(SUCCEEDED(hrT));

    return hr;

}   // WAM_REQUEST::GetAspMDAllData


/*---------------------------------------------------------------------*
WAM_REQUEST::GetAspMDData

    Descrption:
      Private api for ASP that returns asp metadata in a buffer.  Equivalent
      of MD GetAllData.

    Parameters:

    Return:
      HRESULT

*/
STDMETHODIMP
WAM_REQUEST::GetAspMDData(
    IN      unsigned char * pszMDPath
    , IN    DWORD dwMDIdentifier
    , IN    DWORD dwMDAttributes
    , IN    DWORD dwMDUserType
    , IN    DWORD dwMDDataType
    , IN    DWORD dwMDDataLen
    , IN    DWORD dwMDDataTag
    , OUT   unsigned char * pbMDData
    , OUT   DWORD *         pdwRequiredBufferSize
)
{

    HRESULT hr = NOERROR, hrT;
    BOOL fT;
    IMDCOM* pMetabase = g_pWamDictator->PMetabase()->QueryPMDCOM();
    METADATA_HANDLE         hMetabase = NULL;
    const DWORD dwMDDefaultTimeOut  = 2000;
    METADATA_RECORD MDRec;

    DBG_ASSERT(pMetabase != NULL);

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::GetAspMDData\n"
            , this
        ));
    }

    // Only allow the return of the data that ASP needs.  Dont allow anything else
    if (dwMDIdentifier != MD_SERVER_COMMENT &&          // used by ASP debugger
            dwMDIdentifier != MD_APP_FRIENDLY_NAME &&   // used by ASP debugger
            dwMDIdentifier != MD_APP_WAM_CLSID &&
            dwMDIdentifier != MD_APP_ISOLATED)
        return(E_ACCESSDENIED);

    // Open the metabase key
    hr = pMetabase->ComMDOpenMetaObjectA(METADATA_MASTER_ROOT_HANDLE, pszMDPath,
                            METADATA_PERMISSION_READ, dwMDDefaultTimeOut, &hMetabase);
    if (FAILED(hr)) {

        DBGPRINTF((
            DBG_CONTEXT
            , "WAM_REQUEST[%p]::Metadata open failed %x\n"
            , this
            , hr
        ));

        return E_FAIL;
    }

    DBG_ASSERT( hMetabase );

    MDRec.dwMDIdentifier = dwMDIdentifier;
    MDRec.dwMDAttributes = dwMDAttributes;
    MDRec.dwMDUserType = dwMDUserType;
    MDRec.dwMDDataType = dwMDDataType;
    MDRec.dwMDDataLen = dwMDDataLen;
    MDRec.pbMDData = pbMDData;
    MDRec.dwMDDataTag = dwMDDataTag;

    hr = pMetabase->ComMDGetMetaDataW( hMetabase,
                                L"",
                                &MDRec,
                                pdwRequiredBufferSize
                                );

    hrT = pMetabase->ComMDCloseMetaObject(hMetabase);
    DBG_ASSERT(SUCCEEDED(hrT));

    return hr;

}   // WAM_REQUEST::GetAspMDAllData


/*---------------------------------------------------------------------*
WAM_REQUEST::GetCustomError

    Description:
      Private API for ASP that returns custom error.

    Parameters:
        dwError                 error code
        dwSubError              sub error code
        dwBufferSize            supplied buffer size for URL/file
        pbBuffer                supplied buffer for URL/file
                                in case of file, mime type gets
                                concatinated to the file path
        pdwRequiredBufferSize   [out] required buffer size
        pfIsFileError           [out] flag: is file? (not URL)

    Return:
      HRESULT

*/
STDMETHODIMP
WAM_REQUEST::GetCustomError
(
    DWORD dwError,
    DWORD dwSubError,
    DWORD dwBufferSize,
    unsigned char *pbBuffer,
    DWORD *pdwRequiredBufferSize,
    BOOL  *pfIsFileError
)
{
    HRESULT hr = NOERROR;
    PCUSTOM_ERROR_ENTRY pceError;

    DBG_ASSERT( m_pHttpRequest );

    pceError = m_pHttpRequest->GetWAMMetaData()->LookupCustomError(
                                                        dwError,
                                                        dwSubError
                                                    );
    if ( pceError) {

        CHAR *szError = NULL;       // URL or file
        DWORD cchError = 0;         // count of chars

        STR   strMimeType;          // file mime type STR
        CHAR *szMimeType = NULL;    // file mime type CHAR*
        DWORD cchMimeType = 0;      // count of chars

        if ( pceError->IsFileError()) {
            *pfIsFileError = TRUE;
            szError = pceError->QueryErrorFileName();

            // get the mimetype
            if ( SelectMimeMapping( &strMimeType,
                                    szError,
                                    m_pHttpRequest->GetWAMMetaData(),
                                    MIMEMAP_MIME_TYPE)) {

                szMimeType = strMimeType.QueryStr();
                cchMimeType = strMimeType.QueryCCH();
            }

            // mime type is required -- no mime type = bad custom error
            if ( NULL == szMimeType) {
                szError = NULL;
            }
        }
        else {
            // URL
            *pfIsFileError = FALSE;
            szError = pceError->QueryErrorURL();
        }

        if ( szError) {

            cchError = strlen( szError);
            *pdwRequiredBufferSize = cchError + 1 + cchMimeType + 1;

            if ( dwBufferSize >= *pdwRequiredBufferSize) {

                memcpy( pbBuffer, szError, cchError+1);

                if ( szMimeType) {
                    memcpy( pbBuffer+cchError+1, szMimeType, cchMimeType+1);
                }
                else {
                    pbBuffer[cchError+1] = '\0';
                }
            }
            else {

                // doesn't fit into supplied buffer
                hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER);
            }
        }
        else {

            // malformed custom error
            hr = E_FAIL;
        }
    }
    else {

        // custom error not found
        hr = TYPE_E_ELEMENTNOTFOUND;
    }

    return hr;

}   // WAM_REQUEST::GetCustomError


/*---------------------------------------------------------------------*
WAM_REQUEST::TestConnection

    Description:
      Private API for ASP that tests the IP connection to the client.

    Parameters:
        pfIsConnected           [out] flag: is [probably] connected?

    Return:
      HRESULT

*/
STDMETHODIMP
WAM_REQUEST::TestConnection(
    BOOL  *pfIsConnected
)
{

    *pfIsConnected = m_pHttpRequest->TestConnection();

    return NOERROR;

}   // WAM_REQUEST::TestConnection

STDMETHODIMP
WAM_REQUEST::ExtensionTrigger(
    unsigned char *             pvContext,
    DWORD                       dwTriggerType
)
/*++

Routine Description:

    Invoke ISAPI filters waiting on SF_NOTIFY_EXTENSION_TRIGGER

Arguments:

    pvContext - Trigger context pointer
    dwTriggerType - Type of trigger

Returns:

    HRESULT

--*/
{
    BOOL                fRet;
    
    fRet = m_pHttpRequest->QueryFilter()->NotifyExtensionTriggerFilters( 
                                                            (PVOID)pvContext,
                                                            dwTriggerType );

    return HresultFromBool( fRet );
} 


/************************************************************
 *  Static Member Functions of WAM_REQUEST
 ************************************************************/

/*-----------------------------------------------------------------------------*
Support for WAM_REQUEST allocation cache

*/

BOOL
WAM_REQUEST::InitClass( VOID)
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, WAM_REQUEST_CACHE_THRESHOLD,
                                            sizeof(WAM_REQUEST)};

    if ( NULL != sm_pachWamRequest) {

        // already initialized
        return ( TRUE);
    }

    sm_pachWamRequest = new ALLOC_CACHE_HANDLER( "WamRequest",
                                                 &acConfig);

#if DBG
    sm_pDbgRefTraceLog = CreateRefTraceLog( C_REFTRACES_GLOBAL, 0 );
#endif

    //
    // Initialize class static request ID
    //
    sm_dwRequestID = 0;

    return ( NULL != sm_pachWamRequest);
} // WAM_REQUEST::InitClass()


VOID
WAM_REQUEST::CleanupClass( VOID)
{
    if ( NULL != sm_pachWamRequest) {

        delete sm_pachWamRequest;
        sm_pachWamRequest = NULL;
    }

#if DBG
    DestroyRefTraceLog( sm_pDbgRefTraceLog );
#endif

    return;
} // WAM_REQUEST::CleanupClass()


void *
WAM_REQUEST::operator new( size_t s)
{
    DBG_ASSERT( s == sizeof( WAM_REQUEST));

    // allocate from allocation cache.
    DBG_ASSERT( NULL != sm_pachWamRequest);
    return (sm_pachWamRequest->Alloc());
} // WAM_REQUEST::operator new()

void
WAM_REQUEST::operator delete( void * pwr)
{
    DBG_ASSERT( NULL != pwr);

    // free to the allocation pool
    DBG_ASSERT( NULL != sm_pachWamRequest);
    DBG_REQUIRE( sm_pachWamRequest->Free(pwr));

    return;
} // WAM_REQUEST::operator delete()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\oplock\doput.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    doput.cxx

    This module contains the code for the PUT verb


    FILE HISTORY:
        Henrysa     08-May-1996     Created from doget.cxx

*/

#include "w3p.hxx"

#include <stdlib.h>

//
//  Private constants.
//


//
//  Private globals.
//

CHAR    cPutDeleteBody[] = "<body><h1>%s was %s successfully.</h1></body>";

DWORD   dwPutNumCPU;
DWORD   dwPutBlockedCount;

//
//  Private prototypes.
//

BOOL
W95MoveFileEx(
    IN LPCSTR lpExistingFile,
    IN LPCSTR lpNewFile
    );


class FILENAME_LOCK;

typedef class FILENAME_LOCK     *PFILENAME_LOCK;

typedef struct _FN_LOCK_TABLE_ENTRY
{
    LIST_ENTRY          ListHead;
    CRITICAL_SECTION    csCritSec;
} FN_LOCK_TABLE_ENTRY, *PFN_LOCK_TABLE_ENTRY;

class FILENAME_LOCK
{
public:

    FILENAME_LOCK(STR                   *pstrFileName,
                  PFN_LOCK_TABLE_ENTRY  pTableEntry) :
        hEvent(NULL),
        dwWaitCount(0)
    {
        if (!strFileName.Copy(*pstrFileName))
        {
            return;
        }

        hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (hEvent == NULL)
        {
            return;
        }

        // It's important that we not insert this into the table until
        // we know if the event was created OK, because the validity
        // check only checks for the event handle, and this object
        // will be freed without being pulled from the table if
        // the validity check fails.

        pLockTableEntry = pTableEntry;

        InsertHeadList(&pTableEntry->ListHead, &ListEntry);

    }

    ~FILENAME_LOCK(VOID)
    {
        DBG_ASSERT(dwWaitCount == 0);

        if (hEvent != NULL)
        {
            CloseHandle(hEvent);
        }
    }

    BOOL IsValid(VOID)
    { return hEvent != NULL; }

    DWORD Acquire(VOID);

    VOID Release(VOID);

    PLIST_ENTRY     Next(VOID)
    {
        return ListEntry.Flink;
    }

    BOOL IsEqual(STR    *Name)
    {
        if (Name->QueryCB() == strFileName.QueryCB() &&
            _strnicmp(Name->QueryStr(), strFileName.QueryStr(), Name->QueryCB() ) == 0)
        {
            return TRUE;
        }

        return FALSE;
    }

    LIST_ENTRY              ListEntry;

private:

    HANDLE                  hEvent;
    STR                     strFileName;
    PFN_LOCK_TABLE_ENTRY    pLockTableEntry;
    DWORD                   dwWaitCount;
};

#define MAX_FN_LOCK_BUCKETS     64

FN_LOCK_TABLE_ENTRY     FNLockTable[MAX_FN_LOCK_BUCKETS];



//
//  Public functions.
//

VOID
FILENAME_LOCK::Release(
    VOID
    )
/*++

Routine Description:

    Release a filename lock. If there's noone waiting on the lock, then we're
    done with it, and we can go ahead and delete it. Otherwise signal the
    waiter so he can continue.

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection(&pLockTableEntry->csCritSec);

    if (dwWaitCount == 0)
    {
        // Nobody's waiting. Pull this guy from the list and delete him.

        RemoveEntryList(&ListEntry);
        LeaveCriticalSection(&pLockTableEntry->csCritSec);

        delete this;

    }
    else
    {
        DWORD           dwRet;

        // Someone's waiting, so set the event to let then go.
        LeaveCriticalSection(&pLockTableEntry->csCritSec);

        dwRet = SetEvent(hEvent);

        DBG_ASSERT(dwRet != 0);
    }
}

DWORD
FILENAME_LOCK::Acquire(
    VOID
    )
/*++

Routine Description:

    Acquire a filename lock. This routine is called if a filename lock is
    already held by another thread. Increment the wait count, and then
    block on an event. The holder of the lock will signal the event when
    they're done.

    This routine is called with the lock table bucket critical section
    held, and will free it before returning.

Arguments:

    None

Return Value:

    None

--*/
{
        DWORD       dwRet;
        DWORD       dwMaxThreads;
        DWORD       dwAlreadyBlocked;

        // First, make sure we can block. We can block if no more than
        // 3/4ths of the total number of available threads are already
        // blocked in us. Note that we don't do this at all under Win95.

        if (g_fIsWindows95)
        {
            LeaveCriticalSection(&pLockTableEntry->csCritSec);
            return WAIT_TIMEOUT;
        }

        dwMaxThreads = AtqGetInfo(AtqMaxPoolThreads) * dwPutNumCPU;

        dwAlreadyBlocked = InterlockedIncrement((LPLONG)&dwPutBlockedCount) - 1;

        if (dwAlreadyBlocked < ((dwMaxThreads * 3) / 4))
        {
            // It's OK to block this guy.

            // Increment the wait count so the holder knows someone is
            // waiting.

            dwWaitCount++;

            LeaveCriticalSection(&pLockTableEntry->csCritSec);

            // Block on the event until we're signalled or time out.

            dwRet = WaitForSingleObject(hEvent, g_dwPutEventTimeout * 1000);

            // We're done waiting. Enter the critical section and decrement
            // the wait count. We can't do this with interlocked instructions
            // because because other parts of this package use the critical
            // section to serialize with the wait count and other actions
            // atomically.

            EnterCriticalSection(&pLockTableEntry->csCritSec);

            dwWaitCount--;


        }
        else
        {
            dwRet = WAIT_TIMEOUT;
        }

        InterlockedDecrement((LPLONG)&dwPutBlockedCount);
        LeaveCriticalSection(&pLockTableEntry->csCritSec);

        return dwRet;

    }


//
//  Private functions.
//

PFILENAME_LOCK
AcquireFileNameLock(
    STR     *pstrFileName
    )
/*++

Routine Description:

    Acquire a file name lock after looking it up in the table. We hash the file
    name, search the appropriate bucket for it, and acquire it. If we don't
    find one we create a new one.

Arguments:

    strFileName     - Name of the file name we're "locking".

Return Value:

    Pointer to the file name lock we return.

--*/
{
    DWORD           dwHash;
    CHAR            *pchTemp;
    PLIST_ENTRY     pCurrentEntry;
    PFILENAME_LOCK  pFNLock;

    // First, hash the file name.

    dwHash = 0;

    pchTemp = pstrFileName->QueryStr();

    while (*pchTemp != '\0')
    {
        dwHash += (DWORD) *pchTemp;

        dwHash = _rotr(dwHash, 1);

        pchTemp++;
    }

    dwHash = ( (dwHash & 0xff) +
               ((dwHash >> 8) & 0xff) +
               ((dwHash >> 16) & 0xff) +
               ((dwHash >> 24) & 0xff) ) % MAX_FN_LOCK_BUCKETS;

    // We've hashed it, now take the critical section for this bucket.

    EnterCriticalSection(&FNLockTable[dwHash].csCritSec);

    // Walk down the bucket, looking for an existing lock structure.
    pCurrentEntry = FNLockTable[dwHash].ListHead.Flink;

    while (pCurrentEntry != &FNLockTable[dwHash].ListHead)
    {
        pFNLock = CONTAINING_RECORD(pCurrentEntry, FILENAME_LOCK, ListEntry);

        // See if this one matches.

        if (pFNLock->IsEqual(pstrFileName))
        {
            DWORD       dwRet;

            // It is, so try to acquire this one. The acquire routine will free
            // the critical section for us.

            dwRet = pFNLock->Acquire();

            // Here we're done waiting. If we succeeded, return a pointer to
            // the lock, otherwise return NULL.


            if (dwRet == WAIT_OBJECT_0)
            {
                return pFNLock;
            }
            else
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return NULL;
            }
        }

        // Wasn't this one, try the next one.
        pCurrentEntry = pFNLock->Next();
    }

    // If we get here there is no filename lock currently existing, so create
    // a new one.

    pFNLock = new FILENAME_LOCK(pstrFileName, &FNLockTable[dwHash]);

    // Don't need the crit sec anymore, so let it go.

    LeaveCriticalSection(&FNLockTable[dwHash].csCritSec);

    if (pFNLock == NULL)
    {
        // Couldn't get it.
        return NULL;
    }

    // Make sure the initialization worked.
    if (!pFNLock->IsValid())
    {
        // It didn't.

        delete pFNLock;
        return NULL;
    }

    // Otherwise, we're cool, and we own the newly created lock, so we're done.

    return pFNLock;
}

BOOL
HTTP_REQUEST::BuildPutDeleteHeader(
    enum WRITE_TYPE Action
    )
/*++

Routine Description:

    This is a utility routine to build a response header and body appropriate
    for a put or delete response.

Arguments:

    Action          - The action we just took.

Return Value:

    None

--*/
{
    BOOL            fFinished;
    CHAR            *pszTail;
    CHAR            *pszResp;
    DWORD           cbRespBytes;
    DWORD           cbRespBytesNeeded;
    CHAR            *pszURL;
    DWORD           cbURLLength;

    pszURL = _strURL.QueryStr();
    cbURLLength = strlen(pszURL);

    if (Action == WTYPE_CREATE)
    {
        CHAR        *pszHostName;
        CHAR        *pszProtocol;
        DWORD       cbProtocolLength;
        DWORD       cbHostNameLength;
        BOOL        bNeedPort;

        if (!BuildHttpHeader(&fFinished, "201 Created", NULL))
        {
            return FALSE;
        }

        pszResp  = (CHAR *)QueryRespBufPtr();
        cbRespBytes = strlen(pszResp);

        pszTail = pszResp + cbRespBytes;

        pszHostName = QueryHostAddr();
        cbHostNameLength = strlen(pszHostName);


        // Now we need to add the Location header, which means fully
        // qualifying the URL. First figure out how many bytes we might
        // need, then build the Location header.

        if (IsSecurePort())
        {
            pszProtocol = "https://";
            cbProtocolLength = sizeof("https://") - 1;
            bNeedPort = (INT) QueryClientConn()->QueryPort() != HTTP_SSL_PORT;
        }
        else
        {
            pszProtocol = "http://";
            cbProtocolLength = sizeof("http://") - 1;
            bNeedPort = (INT) QueryClientConn()->QueryPort() != 80;
        }


        cbRespBytesNeeded = cbRespBytes +
                            (sizeof("Location: ")) - 1 +
                            cbProtocolLength +
                            cbHostNameLength +
                            (bNeedPort ? 6 : 0) +       // For :port, if needed
                            cbURLLength +
                            sizeof("\r\n")  - 1;

        if (!QueryRespBuf()->Resize(cbRespBytesNeeded))
        {
            return FALSE;
        }

        APPEND_STRING(pszTail, "Location: ");

        memcpy(pszTail, pszProtocol, cbProtocolLength);
        pszTail += cbProtocolLength;

        memcpy(pszTail, pszHostName, cbHostNameLength);
        pszTail += cbHostNameLength;

        // Append :port if we need to.
        if (bNeedPort)
        {
            APPEND_STRING(pszTail, ":");

            pszTail += sprintf(pszTail, "%u",
                                (UINT)(QueryClientConn()->QueryPort()));
        }

        memcpy(pszTail, pszURL, cbURLLength);
        pszTail += cbURLLength;

        APPEND_STRING(pszTail, "\r\n");

        cbRespBytes = cbRespBytesNeeded;

    }
    else
    {
        if (!BuildBaseResponseHeader(QueryRespBuf(),
                                        &fFinished,
                                        NULL,
                                        0))
        {
            return FALSE;
        }

        pszResp  = (CHAR *)QueryRespBufPtr();
        cbRespBytes = strlen(pszResp);

        pszTail = pszResp + cbRespBytes;
    }

    cbRespBytesNeeded = cbRespBytes +
                        sizeof("Content-Type: text/html\r\n") - 1 +
                        sizeof("Content-Length: ") - 1 +
                        5 +                     // For content length digits
                        cbURLLength +
                        sizeof("\r\n\r\n") - 1 +
                        7 +             // "written"/"deleted"/"created"
                        sizeof(cPutDeleteBody);

    if (!QueryRespBuf()->Resize(cbRespBytesNeeded))
    {
        return FALSE;
    }

    APPEND_STRING(pszTail, "Content-Type: text/html\r\n");
    APPEND_STRING(pszTail, "Content-Length: ");
    pszTail += sprintf(pszTail, "%u", sizeof(cPutDeleteBody) - 1 +
                                    cbURLLength + sizeof("deleted") - 1 -
                                    (sizeof("%s") - 1) -
                                    (sizeof("%s") - 1));

    APPEND_STRING(pszTail, "\r\n\r\n");

    sprintf(pszTail, cPutDeleteBody, pszURL,
        (Action == WTYPE_CREATE ? "created" :
            (Action == WTYPE_WRITE ? "written" : "deleted")));

    return TRUE;
}

VOID
HTTP_REQUEST::CleanupTempFile(
    VOID )
/*++

Routine Description:

    Utility routine to close the temp file handle and delete the file.

Arguments:

    None

Return Value:

    None

--*/
{
    // Impersonate the user who opened the file. If the temp file handle
    // is still valid, close it and delete the file.

    if ( ImpersonateUser( ) )
    {
        if ( _hTempFileHandle != INVALID_HANDLE_VALUE )
        {
            ::CloseHandle( _hTempFileHandle );

            ::DeleteFile( _strTempFileName.QueryStr( ) );

            _hTempFileHandle = INVALID_HANDLE_VALUE;
        }

        RevertUser( );
    }
}

VOID
HTTP_REQUEST::VerifyMimeType(
    VOID
    )
/*++

Routine Description:

    Make sure that the mime type specified for the current file
    matches that specified by the client. If it doesn't, create
    a custom mime mapping for this URL.

Arguments:

    None.

Return Value:



--*/
{
    STACK_STR(strMimeType, 80);
    CHAR        *pszClientMimeType;
    BOOL        bHaveMapping;

    // See if the client specified a mime type. If he didn't,
    // we're done.
    //
    pszClientMimeType = (CHAR * ) _HeaderList.FastMapQueryValue(HM_CTY);

    if (pszClientMimeType == NULL)
    {
        return;     // No mime type, system default is OK.
    }

    //
    // Client specified a mime type. See if it matches what we already
    // have.
    //

    bHaveMapping = SelectMimeMapping(   &strMimeType,
                                        _strPhysicalPath.QueryStr(),
                                        _pMetaData);

    if (!bHaveMapping || _stricmp(strMimeType.QueryStr(), pszClientMimeType))
    {
        //
        // Either the mime type lookup failed, or what we have doesn't match what
        // the client specified. In either case create a custom mime map entry
        // for the specified URL. The custom mime map we create is a default
        // one, since it's on a specific file.
        //

        MB                  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
        STACK_STR(strFullMDPath, 128);
        STACK_STR(strCustomMime, 80);

        if (!strCustomMime.Copy(pszClientMimeType) ||
            !strCustomMime.Append(",", sizeof(",") - 1) ||
            !strCustomMime.Append("*", sizeof("*") - 1) )
        {
            return;
        }

        // Append the extra NULL.
        if (!strCustomMime.Resize(strCustomMime.QueryCCH() + 2))
        {
            return;
        }

        if (!strCustomMime.SetLen(strCustomMime.QueryCB() + 1))
        {
            return;
        }

        //
        // Construct the full path to the URL, and try and open it.
        //
        if (!strFullMDPath.Copy(QueryW3Instance()->QueryMDVRPath(),
                                QueryW3Instance()->QueryMDVRPathLen() - 1) ||
            !strFullMDPath.Append(_strURL))
        {
            //
            // Couldn't construct the path.
            //
            return;
        }

        // Now try and open it.

        if ( !mb.Open( strFullMDPath.QueryStr(),
                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )
            )
        {
            // See what the error was.
            if (GetLastError() != ERROR_PATH_NOT_FOUND)
            {
                // Some error other than not exist, so quit.
                return;
            }

            // The path doesn't exist, so add it.
            if (!mb.Open(QueryW3Instance()->QueryMDVRPath(),
                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE)
                )
            {
                return;
            }

            if (!mb.AddObject(_strURL.QueryStr()) &&
                GetLastError() != ERROR_ALREADY_EXISTS
                )
            {
                return;
            }

            // We added it. Close the handle so the next guy can get in.
            DBG_REQUIRE(mb.Close());

            //
            // Now try again to open the full path.
            //
            if ( !mb.Open( strFullMDPath.QueryStr(),
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )
                )
            {
                return;
            }
        }

        mb.SetMultiSZ( "",
              MD_MIME_MAP,
              IIS_MD_UT_FILE,
              strCustomMime.QueryStr());
    }


}

BOOL
HTTP_REQUEST::DoPut(
    BOOL * pfFinished
    )
/*++

Routine Description:

    Handle a PUT request ( cf HTTP 1.1 spec )
    Check the URL being put, read the entity body and write it to disk, etc.

Arguments:

    pfFinished - Set to TRUE if no further processings is needed for this
        request

Return Value:

    TRUE if success, else FALSE

--*/
{
    HANDLE              hFile;
    SECURITY_ATTRIBUTES sa;
    TCHAR               szTempFileName[MAX_PATH/sizeof(TCHAR)];
    DWORD               err;
    BOOL                fDone = FALSE;
    BOOL                fFileSuccess;
    DWORD               cbFileBytesWritten;
    DWORD               dwFileCreateError;
    BOOL                fReturn;
    BOOL                bPrecondWorked;
    CHAR                *pszContentType;



    switch (_putstate)
    {

    case PSTATE_START:

        //
        // Make sure the virtual root allows write access
        //

        if ( !IS_ACCESS_ALLOWED(WRITE) )
        {
            SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );

            Disconnect( HT_FORBIDDEN,
                        IDS_WRITE_ACCESS_DENIED,
                        FALSE,
                        pfFinished );

            return TRUE;
        }

        //
        // Check what we're trying to PUT, make sure we have permission.
        //

        if ( !VrootAccessCheck( _pMetaData, FILE_GENERIC_WRITE ) )
        {
            SetDeniedFlags( SF_DENIED_RESOURCE );
            return FALSE;
        }

        // We don't support Range requests on PUTs.
        if (
            QueryHeaderList()->FindValueInChunks("Content-Range:",
                               sizeof("Content-Range:") - 1)
                != NULL
            )
        {
            SetState( HTR_DONE, HT_NOT_SUPPORTED, ERROR_NOT_SUPPORTED );

            Disconnect( HT_NOT_SUPPORTED, IDS_PUT_RANGE_UNSUPPORTED, FALSE, pfFinished );
            return TRUE;
        }

        //
        // Make sure we support this content type. We don't understand how to
        // handle composite MIME types, so fail if it's a message/ content type.
        //

        pszContentType = (CHAR * ) _HeaderList.FastMapQueryValue(HM_CTY);

        if (pszContentType != NULL)
        {
            if (!_strnicmp(pszContentType,
                            "message/",
                            sizeof("message/") - 1)
               )
            {
                SetState( HTR_DONE, HT_NOT_SUPPORTED, ERROR_NOT_SUPPORTED );

                Disconnect( HT_NOT_SUPPORTED, IDS_UNSUPPORTED_CONTENT_TYPE, FALSE, pfFinished );
                return TRUE;
            }
        }


        // If we don't have a content length or chunked transfer encoding,
        // fail.
        if (!_fHaveContentLength && !IsChunked())
        {
            SetState( HTR_DONE, HT_BAD_REQUEST, ERROR_NOT_SUPPORTED );

            Disconnect( HT_BAD_REQUEST, IDS_CANNOT_DETERMINE_LENGTH, FALSE, pfFinished );
            return TRUE;
        }

        // Now get the filename lock.

        _pFileNameLock = AcquireFileNameLock(&_strPhysicalPath);

        if (_pFileNameLock == NULL)
        {
            // Couldn't get it, return 'resource busy'.
            Disconnect( HT_SVC_UNAVAILABLE, IDS_PUT_CONTENTION, FALSE, pfFinished );
            return TRUE;
        }

        if ( !ImpersonateUser( ) )
        {

            return (FALSE);

        }

        sa.nLength              = sizeof(sa);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle       = FALSE;

        hFile = ::CreateFile( _strPhysicalPath.QueryStr(),
                                GENERIC_READ | GENERIC_WRITE,
                                g_fIsWindows95 ?
                                    (FILE_SHARE_READ | FILE_SHARE_WRITE) :
                                    (FILE_SHARE_READ | FILE_SHARE_WRITE |
                                     FILE_SHARE_DELETE),
                                &sa,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        dwFileCreateError = ::GetLastError();

        if ( hFile == INVALID_HANDLE_VALUE)
        {
            // Some sort of error opening the file.


            RevertUser();

            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            if ( dwFileCreateError == ERROR_FILE_NOT_FOUND ||
                 dwFileCreateError == ERROR_PATH_NOT_FOUND)
            {
                // The path or filename itself is bad, fail the request.

                SetState( HTR_DONE, HT_NOT_FOUND, GetLastError() );
                Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                return TRUE;

            }

            if ( dwFileCreateError == ERROR_INVALID_NAME )
            {
                // An invalid name.

                SetState( HTR_DONE, HT_BAD_REQUEST, GetLastError() );
                Disconnect( HT_BAD_REQUEST, NO_ERROR, FALSE, pfFinished );
                return TRUE;
            }
            else
            {

                // A 'bad' error has occured, so return FALSE.

                if ( dwFileCreateError == ERROR_ACCESS_DENIED )
                {
                    SetDeniedFlags( SF_DENIED_RESOURCE );
                }

            }

            return FALSE;
        }
        else
        {

            // The create worked. If this isn't a directory and it's not
            // hidden or readonly we're OK. If we just created it now, delete
            // it so we don't have to remember to if the put fails later.

            BY_HANDLE_FILE_INFORMATION      FileInfo;


            // Get file information and check for a directory or hidden file.
            fReturn = GetFileInformationByHandle(
                                                hFile,
                                                &FileInfo
                                                );


            // See if this file is accessible. If not, fail.
            if ( fReturn)
            {

                // We got the information.

                if ( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    DBG_REQUIRE( ::CloseHandle( hFile ));
                    if ( dwFileCreateError != ERROR_ALREADY_EXISTS)
                    {

                        ::DeleteFile(  _strPhysicalPath.QueryStr() );
                    }

                    // Don't allow puts to directory.
                    RevertUser();

                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;

                    SetState( HTR_DONE, HT_BAD_REQUEST, GetLastError() );
                    Disconnect( HT_BAD_REQUEST, NO_ERROR, FALSE, pfFinished );
                    return TRUE;
                }

                if ( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
                {

                    // Pretend we can't see hidden files.
                    DBG_REQUIRE( ::CloseHandle( hFile ));
                    if ( dwFileCreateError != ERROR_ALREADY_EXISTS)
                    {

                        ::DeleteFile(  _strPhysicalPath.QueryStr() );
                    }

                    RevertUser();

                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;

                    SetState( HTR_DONE, HT_NOT_FOUND, GetLastError() );
                    Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                    return TRUE;

                }

            } else
            {
                // Some sort of fatal error.
                DBG_REQUIRE( ::CloseHandle( hFile ));
                if ( dwFileCreateError != ERROR_ALREADY_EXISTS)
                {

                    ::DeleteFile(  _strPhysicalPath.QueryStr() );
                }

                RevertUser();

                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                return FALSE;
            }

        }


        // Check the preconditions on this file, if there are any. It's
        // possible that it would be better to do this at the very end,
        // right before we rename the file, but for not we do it here.

        bPrecondWorked = FALSE;

        _bFileExisted = (dwFileCreateError == ERROR_ALREADY_EXISTS);

        if (_fIfModifier)
        {
            bPrecondWorked =  CheckPreconditions(hFile,
                                    _bFileExisted,
                                    pfFinished,
                                    &fReturn
                                    );

        }

        // Close the handle now, since we know longer need it.
        DBG_REQUIRE( ::CloseHandle( hFile ));

        if (!_bFileExisted)
        {
            // File didn't originally exist, so delete the one we just created.
            ::DeleteFile(  _strPhysicalPath.QueryStr() );
        }


        if (bPrecondWorked)
        {
            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            if (!fReturn)
            {
                return fReturn;
            }

            // We had a precondition work. If we're read the entire entity
            // body, we're done. Otherwise we need to keep reading and
            // discarding the data. The call above to CheckPreconditions
            // may have gotten an async send going, in which case we
            // won't be able to get another read going until that completes.

            if (QueryClientContentLength() <= QueryTotalEntityBodyCB())
            {
                // All done.
                return fReturn;
            }

            // Otherwise we ned to start reading and discarding. See if
            // we can do that now.

            SetState( HTR_DOVERB, _dwLogHttpResponse, NO_ERROR );

            _putstate = PSTATE_DISCARD_CHUNK;
            if (*pfFinished)
            {
                // No send pending. Call ourselves recursively to get another
                // read going.

                *pfFinished = FALSE;

                return DoPut(pfFinished);

            }
            else
            {
                return TRUE;
            }

        }

        // At this point we've verified the request. We need to generate a
        // temporary file name and if this is a 1.1 or greater client send
        // back a 100 Continue response.

        err = ::GetTempFileName(
                            g_pszW3TempDirName,
                            W3_TEMP_PREFIX,
                            0,
                            szTempFileName
                            );

        if ( err == 0 ||  !_strTempFileName.Copy( szTempFileName ) )
        {
            //
            // Couldn't create or copy a temporary file name.
            //

            RevertUser();
            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            return FALSE;

        }

        // Now open the temp file. We specify OPEN_EXISTING because we
        // want to fail if someone's deleted the temp file name before we
        // opened it. If that's happened we have no real guarantee that the
        // file is still unique. We don't specify any sharing as we don't
        // want anyone else to write into while we are.

        _hTempFileHandle =  ::CreateFile( szTempFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                g_fIsWindows95 ? 0 : FILE_SHARE_DELETE,
                                &sa,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);

        RevertUser();

        if (_hTempFileHandle == INVALID_HANDLE_VALUE)
        {
            // Uh-oh. Couldn't open the temp file we just created. This is bad,
            // return FALSE to fail the request rudely.

            DBGPRINTF((DBG_CONTEXT,"CreateFile[%s] failed with %d\n",
                szTempFileName, GetLastError()));

            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            return FALSE;
        }

        // Now everything's good. If this is a 1.1 client or greater send
        // back the 100 Continue response, otherwise skip that.

        if ( IsAtLeastOneOne() )
        {
            if ( !SendHeader( "100 Continue", "\r\n", IO_FLAG_SYNC, pfFinished,
                              HTTPH_NO_CONNECTION) )
            {
                // An error on the header send. Abort this request.

                CleanupTempFile( );

                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                return FALSE;
            }

            if ( *pfFinished )
            {
                CleanupTempFile();
            }
        }


        // Set out put state to reading, and begin reading the entity body.

        _putstate = PSTATE_READING;

        if ( !ReadEntityBody( &fDone, TRUE, QueryMetaData()->QueryPutReadSize() ))
        {
            // Had some sort of problem reading the entity body. This is
            // fatal.

            CleanupTempFile( );

            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            return FALSE;
        }

        if ( !fDone )
        {
            return TRUE;
        }

        DBG_ASSERT((QueryEntityBodyCB() >= QueryMetaData()->QueryPutReadSize())
                    || (QueryEntityBodyCB() == QueryClientContentLength()));

        // Fall through to the PSTATE_READING handler.

    case PSTATE_READING:

        // When we get here, we've completed a read. If this isn't the
        // fall through case call ReadEntityBody again to find out if
        // we're done with the current chunk.

        if ( !fDone )
        {
            if ( !ReadEntityBody( &fDone, FALSE,
                                    QueryMetaData()->QueryPutReadSize() ))
            {
                // Had some sort of problem reading the entity body. This is
                // fatal.

                CleanupTempFile( );
                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                return FALSE;
            }

            if ( !fDone )
            {
                return TRUE;
            }
        }

        // Right here we know we've read the current chunk, so we want
        // to set our state to writing and write this to the temp file.

        do
        {

            DWORD       dwAmountToWrite;

            // Since there could be extra slop in the buffer, we need to
            // figure out how much to actually write. TotalEntityBodyCB
            // is the total number of bytes we've read into the buffer
            // for this request, and EntityBodyCB is the number of bytes
            // in the buffer for this chunk. Therefore TEBCB - EBCB is the
            // amount we've already read and written to the file. We want to
            // write the minimum of the ContentLength - this amount and
            // EBCB.

            dwAmountToWrite = min ( QueryClientContentLength() -
                                        (QueryTotalEntityBodyCB() -
                                        QueryEntityBodyCB()),
                                    QueryEntityBodyCB() );


            //
            // Check to see if the amount we're to write is 0, and skip if it
            // is. This can happen in the chunked case where all we got on
            // the last read is the 0 terminator.
            //

            if (dwAmountToWrite != 0)
            {

                fFileSuccess = ::WriteFile( _hTempFileHandle,
                                                QueryEntityBody(),
                                                dwAmountToWrite,
                                                &cbFileBytesWritten,
                                                NULL
                                            );
                if ( !fFileSuccess || cbFileBytesWritten != dwAmountToWrite )
                {

                    // Some sort of problem with the write. Abort the request.

                    CleanupTempFile( );
                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;

                    return FALSE;
                }
            }

            _cbEntityBody = 0;
            _cbBytesWritten = 0;

            // Now, if we haven't read all of the entity body try to read some more.

            if ( QueryClientContentLength() > QueryTotalEntityBodyCB() )
            {
                if ( !ReadEntityBody( &fDone, TRUE,
                                        QueryMetaData()->QueryPutReadSize() ))
                {
                    // Had some sort of problem reading the entity body. This is
                    // fatal.

                    CleanupTempFile( );
                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;

                    return FALSE;
                }
            } else
            {

                // We've read and written all of the entity body. Rename the
                // temp file now, close the temp file handle (causing a delete),
                // flush the atq cache and we're done.

                if ( !ImpersonateUser( ) )
                {
                    CleanupTempFile( );

                    _pFileNameLock->Release();
                    _pFileNameLock = NULL;
                    return (FALSE);
                }

                //
                // If the file we're PUTing already exists, rename it to
                // another name before we move the other one over.

                if ( _bFileExisted )
                {

                    err = ::GetTempFileName(
                                        g_pszW3TempDirName,
                                        W3_TEMP_PREFIX,
                                        0,
                                        szTempFileName
                                        );

                    if ( err == 0 )
                    {
                        //
                        // Couldn't create a temporary file name.
                        //

                        RevertUser();
                        CleanupTempFile();
                        _pFileNameLock->Release();
                        _pFileNameLock = NULL;

                        return FALSE;
                    }

                    // Now do the actual rename. GetTempFileName() will
                    // have created the file.
                    if ( g_fIsWindows95 ) {
                        fFileSuccess = ::W95MoveFileEx( _strPhysicalPath.QueryStr(),
                                                        szTempFileName
                                                    );
                    } else {
                        fFileSuccess = ::MoveFileEx(_strPhysicalPath.QueryStr(),
                                                    szTempFileName,
                                                    MOVEFILE_REPLACE_EXISTING |
                                                    MOVEFILE_COPY_ALLOWED
                                                    );
                    }

                    if ( !fFileSuccess )
                    {
                        // Couldn't move the file!
                        RevertUser();
                        CleanupTempFile();
                        _pFileNameLock->Release();
                        _pFileNameLock = NULL;

                        return FALSE;
                    }
                }


                ::CloseHandle( _hTempFileHandle );

                _hTempFileHandle = INVALID_HANDLE_VALUE;

                // Now rename the temp file to the file we're PUTing. The file
                // shouldn't already exist (since we'd have renamed it if it
                // did), so this should fail if it does.

                if ( g_fIsWindows95 ) {
                    fFileSuccess = ::W95MoveFileEx(_strTempFileName.QueryStr(),
                                               _strPhysicalPath.QueryStr()
                                                );
                } else {
                    fFileSuccess = ::MoveFileEx(_strTempFileName.QueryStr(),
                                               _strPhysicalPath.QueryStr(),
                                                MOVEFILE_COPY_ALLOWED
                                                );
                }

                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                if ( fFileSuccess ) {

                    BOOL        fHandled;
                    DWORD       cbDummy;

                    // The rename worked. Cleanup the renamed copy of the
                    // original file if it exists, and flush the cache.

                    if (_bFileExisted)
                    {
                        ::DeleteFile( szTempFileName );
                    }

                    RevertUser( );

                    _cFilesReceived++;

                    // Flush the atq cache here.
                    TsFlushURL(QueryW3Instance()->GetTsvcCache(),
                                _strURL.QueryStr(),
                                _strURL.QueryCB(),
                                RESERVED_DEMUX_URI_INFO);

                    //
                    // Now see if the mime type we currently have
                    // matches the mimetype the client requested. If
                    // it does, or the client requested one, we're
                    // good. Otherwise we need to create a custom
                    // mimetype entry for this file.
                    //
                    VerifyMimeType();

                    // Build and send the response.
                    if ( !BuildPutDeleteHeader( _bFileExisted ?
                                WTYPE_WRITE : WTYPE_CREATE ))
                    {
                        return FALSE;
                    }

                    SetState( HTR_DONE, HT_OK, NO_ERROR );

                    return SendHeader( QueryRespBufPtr(),
                                       (DWORD) -1,
                                       IO_FLAG_ASYNC,
                                       pfFinished );
                } else
                {
                    // The rename failed. There's no easy way to tell why.
                    // Leave a backup copy around, and log it so that an admin
                    // can restore it.

                    const   CHAR    *pszFileName[3];

                    err = GetLastError();

                    pszFileName[0] = _strRawURL.QueryStr();
                    pszFileName[1] = _strPhysicalPath.QueryStr();

                    if (_bFileExisted)
                    {
                        pszFileName[2] = szTempFileName;
                        g_pInetSvc->LogEvent(  W3_EVENT_CANNOT_PUT_RENAME,
                                               3,
                                               pszFileName,
                                               0 );
                    }
                    else
                    {
                        g_pInetSvc->LogEvent(  W3_EVENT_CANNOT_PUT,
                                               2,
                                               pszFileName,
                                               0 );
                    }

                    IF_DEBUG(ERROR) {
                        DBGPRINTF((DBG_CONTEXT,
                            "MoveFileEx[%s to %s] failed with %d\n",
                            _strTempFileName.QueryStr(),
                            _strPhysicalPath.QueryStr(),
                            err));
                    }

                    ::DeleteFile( _strTempFileName.QueryStr( ));
                    RevertUser( );

                    //
                    // Rename failed somehow.
                    //

                    SetLastError(err);
                    return FALSE;

                }
            }

        } while ( fDone );

        return TRUE;

        break;

    case PSTATE_DISCARD_READ:

        // Just had a read complete. See if we've read all of the data for
        // this chunk. If not, wait until the next read completes. Otherwise
        // see if we're done reading and discarding.
        if ( !ReadEntityBody( &fDone, FALSE,
                QueryMetaData()->QueryPutReadSize() ))
        {
            return FALSE;
        }

        if (!fDone)
        {
            // Another read pending, so wait for it to complete.
            return TRUE;
        }

        // Otherwise we're read one chunk. Fall through to the discard chunk
        // code, to see if we're done overall and possibly get another
        // read going.

    case PSTATE_DISCARD_CHUNK:

        do {
            if ( QueryClientContentLength() <= QueryTotalEntityBodyCB() )
            {
                // We're read all of the data, so we're done.
                SetState( HTR_DONE, _dwLogHttpResponse, NO_ERROR );

                *pfFinished = TRUE;
                return TRUE;
            }

            // Haven't read it all yet, get another read going.
            _putstate = PSTATE_DISCARD_READ;
            _cbEntityBody = 0;
            _cbBytesWritten = 0;

            DBG_ASSERT(QueryClientContentLength() > QueryTotalEntityBodyCB());

            if ( !ReadEntityBody( &fDone, TRUE,
                    QueryMetaData()->QueryPutReadSize() ))
            {
                return FALSE;
            }


        } while ( fDone );

        return TRUE;

    default:

        break;


    }

    return FALSE;


}

BOOL
HTTP_REQUEST::DoDelete(
    BOOL * pfFinished
    )
/*++

Routine Description:

    Handle a DELETE request ( cf HTTP 1.1 spec )
    Check the URL being deleted, make sure we have permission, and
    delete it.

    In order to be safe we need to be sure we can both delete the file and
    send a response header. To make this work we'll open the file with delete
    access. If that works we'll try and build and send the response header, and
    iff that works we'll actually try to delete the file.

Arguments:

    None

Return Value:

    TRUE if success, else
    FALSE

--*/
{
    HANDLE              hFile;
    SECURITY_ATTRIBUTES sa;
    DWORD               err;
    STR                 ResponseStr;
    BOOL                fDone;
    BOOL                fReturn;
    BOOL                fDeleted = FALSE;


    //
    // Make sure the virtual root allows write access
    //

    if ( !IS_ACCESS_ALLOWED(WRITE) )
    {
        SetState( HTR_DONE, HT_FORBIDDEN, ERROR_ACCESS_DENIED );

        Disconnect( HT_FORBIDDEN, IDS_WRITE_ACCESS_DENIED, FALSE, pfFinished );
        return TRUE;
    }

    // Now get the filename lock.

    _pFileNameLock = AcquireFileNameLock(&_strPhysicalPath);

    if (_pFileNameLock == NULL)
    {
        // Couldn't get it, return 'resource busy'.
        return FALSE;
    }

    if ( !ImpersonateUser( ) )
    {
        _pFileNameLock->Release();
        _pFileNameLock = NULL;

        return (FALSE);
    }

    if (!fDeleted) {

        sa.nLength              = sizeof(sa);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle       = FALSE;

        hFile = ::CreateFile( _strPhysicalPath.QueryStr(),
                                GENERIC_READ | GENERIC_WRITE,
                                g_fIsWindows95 ?
                                    (FILE_SHARE_READ | FILE_SHARE_WRITE) :
                                    (FILE_SHARE_READ | FILE_SHARE_WRITE |
                                     FILE_SHARE_DELETE),
                                &sa,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

        if ( hFile == INVALID_HANDLE_VALUE)
        {
            // Some sort of error opening the file.

            err = ::GetLastError();

            RevertUser();

            _pFileNameLock->Release();
            _pFileNameLock = NULL;

            if ( err == ERROR_FILE_NOT_FOUND ||
                 err == ERROR_PATH_NOT_FOUND)
            {
                // The path or filename itself is bad, fail the request.

                SetState( HTR_DONE, HT_NOT_FOUND, GetLastError() );
                Disconnect( HT_NOT_FOUND, NO_ERROR, FALSE, pfFinished );
                return TRUE;

            }

            if ( err == ERROR_INVALID_NAME )
            {
                // An invalid name.

                SetState( HTR_DONE, HT_BAD_REQUEST, GetLastError() );
                Disconnect( HT_BAD_REQUEST, NO_ERROR, FALSE, pfFinished );
                return TRUE;
            }
            else
            {

                // A 'bad' error has occured, so return FALSE.

                if ( err == ERROR_ACCESS_DENIED )
                {
                    SetDeniedFlags( SF_DENIED_RESOURCE );
                }

            }

            return FALSE;
        }
        else
        {
            // We should be able to delete it, so just close the handle.

            if (_fIfModifier)
            {
                fDone =  CheckPreconditions(hFile,
                                        TRUE,
                                        pfFinished,
                                        &fReturn
                                        );
            }
            else
            {
                fDone = FALSE;
            }

            ::CloseHandle(hFile);

            if (fDone)
            {
                _pFileNameLock->Release();
                _pFileNameLock = NULL;

                return fReturn;
            }
        }

        TsFlushURL(QueryW3Instance()->GetTsvcCache(),
                    _strURL.QueryStr(),
                    _strURL.QueryCB(),
                    RESERVED_DEMUX_URI_INFO);

        // Try to build and send the HTTP response header.

        if (!BuildPutDeleteHeader(WTYPE_DELETE))
         {
            RevertUser();
            _pFileNameLock->Release();
            _pFileNameLock = NULL;
            return FALSE;
        }

        // We built the successful response, now delete the actual file.

        fDeleted = ::DeleteFile( _strPhysicalPath.QueryStr() );
    }

    RevertUser();

    _pFileNameLock->Release();
    _pFileNameLock = NULL;

    if ( !fDeleted) {

        return FALSE;
    }

    SetState( HTR_DONE, HT_NO_CONTENT, NO_ERROR );

    if ( !SendHeader( QueryRespBufPtr(),
                      (DWORD) -1,
                      IO_FLAG_ASYNC,
                      pfFinished ))
    {
        // Presumably if the WriteFile fails something serious has gone wrong,
        // and the connection is about to die.
        return FALSE;
    }


    // Here we should go ahead and purge this from the Tsunami cache

    return TRUE;

}


BOOL
W95MoveFileEx(
    IN LPCSTR lpExistingFile,
    IN LPCSTR lpNewFile
    )
{
    BOOL fRet;

    fRet = ::CopyFile( lpExistingFile, lpNewFile, FALSE );
    if ( fRet ) {
        ::DeleteFile(lpExistingFile);
    } else {
        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,
                "Error %d in CopyFile[%s to %s]\n",
                GetLastError(), lpExistingFile, lpNewFile));
        }
    }
    return(fRet);

} // W95MoveFileEx

VOID
HTTP_REQUEST::CleanupWriteState(
    VOID
    )
/*++

Routine Description:

    Cleanup any of the write methods (PUT, DELETE) state when a request is
    completed.

Arguments:

    None

Return Value:

    None.

--*/
{
    if (_pFileNameLock != NULL)
    {
        _pFileNameLock->Release();
        _pFileNameLock = NULL;
    }

    if (_hTempFileHandle != INVALID_HANDLE_VALUE)
    {
        CleanupTempFile();
    }
}


DWORD
InitializeWriteState(
    VOID
    )
/*++

Routine Description:

    Initialize the global state we need in order to do write methods such as
    PUT and DELETE.

Arguments:

    None

Return Value:

    NO_ERROR on success, or error code if we fail.

--*/
{
    DWORD           i;

    for (i = 0; i < MAX_FN_LOCK_BUCKETS; i++)
    {
        InitializeListHead(&FNLockTable[i].ListHead);
        InitializeCriticalSection(&FNLockTable[i].csCritSec);
    }

    if ( !InetIsNtServer( IISGetPlatformType() ) )
    {
        dwPutNumCPU = 1;

    } else
    {

        SYSTEM_INFO si;

        //
        // get the count of CPUs for Thread Tuning.
        //

        GetSystemInfo( &si );
        dwPutNumCPU = si.dwNumberOfProcessors;
    }

    dwPutBlockedCount = 0;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\debug\user.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    user.c
    This module implements the "user" command of the W3 Server
    debugger extension DLL.

    The "user" command dumps the info pertaining to a specific user.
    There is one parameter to this command.  If this parameter is
    positive, it is assumed to be the address of a USER_DATA structure
    for a specific user.  If the parameter is negative, its absolute
    value is assumed to be a user ID.  If no parameter is given, info
    for all connected users is dumped.


    FILE HISTORY:
        KeithMo     13-Aug-1992 Created.

*/


#include "w3dbg.h"


//
//  Private prototypes.
//

VOID DumpUserInfo( HANDLE      hCurrentProcess,
                   USER_DATA * puser );

CHAR * InterpretState( USER_STATE state );

CHAR * InterpretXferType( XFER_TYPE xferType );

CHAR * InterpretXferMode( XFER_MODE xferMode );

VOID InterpretFlags( DWORD dwFlags );



/*******************************************************************

    NAME:       user

    SYNOPSIS:   Displays the info for a specific user.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    NOTES:      The argument string must contain either the address of
                a USER_DATA structure (if positive) or a user ID (if
                negative).

    HISTORY:
        KeithMo     13-Aug-1992 Created.

********************************************************************/
VOID user( HANDLE hCurrentProcess,
           HANDLE hCurrentThread,
           DWORD  dwCurrentPc,
           LPVOID lpExtensionApis,
           LPSTR  lpArgumentString )
{
    LONG         lParam;
    USER_DATA    user;

    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Evaluate the parameter (if present).
    //

    if( ( lpArgumentString == NULL ) || ( *lpArgumentString == '\0' ) )
    {
        lParam = 0;
    }
    else
    {
        lParam = (LONG)DebugEval( lpArgumentString );
    }

    //
    //  Interpret the parameter.
    //

    if( lParam > 0 )
    {
        //
        //  User specified an address.  Dump the user info
        //  at that address.
        //

        ReadProcessMemory( hCurrentProcess,
                           (LPVOID)lParam,
                           (LPVOID)&user,
                           sizeof(user),
                           (LPDWORD)NULL );

        DumpUserInfo( hCurrentProcess, &user );
    }
    else
    {
        //
        //  User specified either nothing (0) or a user ID (< 0).
        //

        LIST_ENTRY   list;
        LIST_ENTRY * plist;
        LIST_ENTRY * plistHead;

        lParam = -lParam;

        plistHead = (LIST_ENTRY *)DebugEval( "listUserData" );

        ReadProcessMemory( hCurrentProcess,
                           (LPVOID)plistHead,
                           (LPVOID)&list,
                           sizeof(list),
                           (LPDWORD)NULL );

        plist = list.Flink;

        while( plist != plistHead )
        {
            ReadProcessMemory( hCurrentProcess,
                               (LPVOID)CONTAINING_RECORD( plist,
                                                          USER_DATA,
                                                          link ),
                               (LPVOID)&user,
                               sizeof(user),
                               (LPDWORD)NULL );

            if( ( lParam == 0 ) || ( user.idUser == (DWORD)lParam ) )
            {
                DumpUserInfo( hCurrentProcess, &user );

                if( lParam != 0 )
                {
                    break;
                }
            }

            plist = user.link.Flink;

            //
            //  Check for CTRL-C, to let the user bag-out early.
            //

            if( DebugCheckCtrlC() )
            {
                break;
            }
        }

        if( ( lParam != 0 ) && ( plist == plistHead ) )
        {
            DebugPrint( "user ID %ld not found\n", lParam );
        }
    }

}   // user


VOID DumpUserInfo( HANDLE      hCurrentProcess,
                   USER_DATA * puser )
{
    char szDir[MAX_PATH];
    int  i;

    DebugPrint( "user @ %08lX:\n", puser );
    DebugPrint( "    link.Flink = %08lX\n", puser->link.Flink );
    DebugPrint( "    link.Blink = %08lX\n", puser->link.Blink );
    DebugPrint( "    dwFlags    = %08lX\n", puser->dwFlags );
    InterpretFlags( puser->dwFlags );
    DebugPrint( "    sControl   = %d\n",    puser->sControl );
    DebugPrint( "    sData      = %d\n",    puser->sData );
    DebugPrint( "    hToken     = %08lX\n", puser->hToken );
    DebugPrint( "    state      = %s\n",    InterpretState( puser->state ) );
    DebugPrint( "    idUser     = %lu\n",   puser->idUser );
    DebugPrint( "    tConnect   = %08lX\n", puser->tConnect );
    DebugPrint( "    tAccess    = %08lX\n", puser->tAccess );
    DebugPrint( "    xferType   = %s\n",    InterpretXferType( puser->xferType ) );
    DebugPrint( "    xferMode   = %s\n",    InterpretXferMode( puser->xferMode ) );
    DebugPrint( "    inetLocal  = %s\n",    inet_ntoa( puser->inetLocal ) );
    DebugPrint( "    inetHost   = %s\n",    inet_ntoa( puser->inetHost ) );
    DebugPrint( "    inetData   = %s\n",    inet_ntoa( puser->inetData ) );
    DebugPrint( "    portData   = %u\n",    puser->portData );
    DebugPrint( "    hDir       = %08lX\n", puser->hDir );
    DebugPrint( "    pIoBuffer  = %08lX\n", puser->pIoBuffer );
    DebugPrint( "    pszRename  = %s\n",    puser->pszRename );
    for( i = 0 ; i < 26 ; i++ )
    {
        if( puser->apszDirs[i] != NULL )
        {
            ReadProcessMemory( hCurrentProcess,
                               puser->apszDirs[i],
                               szDir,
                               sizeof(szDir),
                               (LPDWORD)NULL );

            DebugPrint( "    dir %c:     = %s\n", 'A'+i, szDir );
        }
    }
    DebugPrint( "    szDir      = %s\n",    puser->szDir );
    DebugPrint( "    szUser     = %s\n",    puser->szUser );
    DebugPrint( "    idThread   = %lu\n",   puser->idThread );

    DebugPrint( "\n" );

}   // DumpUserInfo


CHAR * InterpretState( USER_STATE state )
{
    CHAR * pszResult = "unknown";

    switch( state )
    {
    case Embryonic :
        pszResult = "Embryonic";
        break;

    case WaitingForUser :
        pszResult = "WaitingForUser";
        break;

    case WaitingForPass :
        pszResult = "WaitingForPass";
        break;

    case LoggedOn :
        pszResult = "LoggedOn";
        break;

    case Disconnected :
        pszResult = "Disconnected";
        break;

    default :
        break;
    }

    return pszResult;

}   // InterpretState


CHAR * InterpretXferType( XFER_TYPE xferType )
{
    CHAR * pszResult = "unknown";

    switch( xferType )
    {
    case AsciiType :
        pszResult = "ASCII";
        break;

    case BinaryType :
        pszResult = "BINARY";
        break;

    default :
        break;
    }

    return pszResult;

}   // InterpretXferType


CHAR * InterpretXferMode( XFER_MODE xferMode )
{
    CHAR * pszResult = "unknown";

    switch( xferMode )
    {
    case StreamMode :
        pszResult = "STREAM";
        break;

    case BlockMode :
        pszResult = "BLOCK";
        break;

    default :
        break;
    }

    return pszResult;

}   // InterpretXferMode


typedef struct FLAG_MAP
{
    DWORD   flag;
    CHAR  * pszName;

} FLAG_MAP;

FLAG_MAP flag_map[] =
    {
        { UF_MSDOS_DIR_OUTPUT, "UF_MSDOS_DIR_OUTPUT" },
        { UF_ANNOTATE_DIRS,    "UF_ANNOTATE_DIRS"    },
        { UF_READ_ACCESS,      "UF_READ_ACCESS"      },
        { UF_WRITE_ACCESS,     "UF_WRITE_ACCESS"     },
        { UF_OOB_ABORT,        "UF_OOB_ABORT"        },
        { UF_RENAME,           "UF_RENAME"           },
        { UF_PASSIVE,          "UF_PASSIVE"          },
        { UF_ANONYMOUS,        "UF_ANONYMOUS"        },
        { UF_TRANSFER,         "UF_TRANSFER"         },
        { UF_OOB_DATA,         "UF_OOB_DATA"         }
    };
#define NUM_FLAG_MAP (sizeof(flag_map) / sizeof(flag_map[0]))


VOID InterpretFlags( DWORD dwFlags )
{
    INT        i;
    FLAG_MAP * pmap = flag_map;

    for( i = 0 ; i < NUM_FLAG_MAP ; i++ )
    {
        if( dwFlags & pmap->flag )
        {
            DebugPrint( "                 %s\n", pmap->pszName );
            dwFlags &= ~pmap->flag;
        }

        pmap++;
    }

    if( dwFlags != 0 )
    {
        DebugPrint( "                 Remaining flags = %08lX\n", dwFlags );
    }

}   // InterpretFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\httpauth\const.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    const.h

Abstract:

    Constants

Author:

    Sam Patton (sampa) 05-Jan-1996

Environment:

    Internet

Revision History:

    dd-mmm-yyy <email>

--*/

#define VERBOSE 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\debug\w3dbg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    w3dbg.h
    This include file contains the prototypes & manifest constants
    used by the W3 Server debugger extension DLL.


    FILE HISTORY:
        KeithMo     18-May-1993 Created.

*/


#ifndef _W3DBG_H_
#define _W3DBG_H_


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <wdbgexts.h>

#include <w3p.hxx>


//
//  Globals shared by all extension commands.
//

extern PNTSD_OUTPUT_ROUTINE  DebugPrint;
extern PNTSD_GET_EXPRESSION  DebugEval;
extern PNTSD_GET_SYMBOL      DebugGetSymbol;
extern PNTSD_DISASM          DebugDisassem;
extern PNTSD_CHECK_CONTROL_C DebugCheckCtrlC;


//
//  Utility functions.
//

VOID GrabDebugApis( LPVOID lpExtensionApis );


//
//  DLL entrypoint.
//
//

BOOLEAN W3DbgDllInitialize( HANDLE hDll,
                             DWORD  nReason,
                             LPVOID pReserved );


#ifdef __cplusplus
}       // extern "C"
#endif  // __cplusplus


#endif  // _W3DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\cmdline\httpcmd.cxx ===
//
//  Command line HTTP client application
//


extern "C" {

#include <windows.h>
#include <winsock2.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <nspapi.h>
#include <svcguid.h>
#include <inetcom.h>
#include <svcloc.h>

} // extern "C"

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//
#define HEXDIGIT( nDigit )                              \
    (TCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
          : (nDigit) + '0')

//
//  Converts a single hex digit to its decimal equivalent
//
#define TOHEX( ch )                                     \
    ((ch) > '9' ?                                       \
        (ch) >= 'a' ?                                   \
            (ch) - 'a' + 10 :                           \
            (ch) - 'A' + 10                             \
        : (ch) - '0')

#define W3SVC_GUID { 0x585908c0, 0x6305, 0x11ce, { 0xae,0x00,0,0xaa,0,0x4a,0x38,0xb9 } }

CHAR * SkipWhite( CHAR * pch );
#define ISWHITE( ch )       ((ch) == ' ' || (ch) == '\t' || (ch) == '\r')

DWORD PrintHeaders( BOOL * pfAllHeaders );
BOOL ReadRequest( VOID );
BOOL SendRequest( VOID );
BOOL ReadReply( VOID );
void PrintUsage( void );
BOOL FillAddr( PSOCKADDR psin,
               BOOL bConnect);
CHAR * SkipComments( CHAR * pch );
CHAR * BuildNextRequest( VOID );
BOOL AddAuthorizeHeaders( CHAR * pch );
VOID DumpAuthBuffer( VOID * pbuff, char * pchSrc );


#define HTTPCMD_VERSION         "1.1"
#define HTTP_REQ_TERM           "$END"

char      buff[65535];
int       cbRequest;
char *    pchCurrentReq;           // Current location of request
SOCKET    sock     = INVALID_SOCKET;
int       portno   =   80;         // HTTP port number
char *    pchServer;               // Server to make the request to
char * pchInputFile;          // Input file to read from
char *    pchUserName = NULL;      // Username to user for authentication
char *    pchPassword = NULL;      // Password to use for authentication
BOOL      fKeepConnection = FALSE; // Pass "Pragma: Keep-connection" ?
BOOL      fEchoSends = FALSE;      // Print send requests to stdout?
BOOL      fDumpAuth = FALSE;       // Dump raw authorization data
BOOL      fDontEchoHeaders = FALSE;// Don't print received headers
BOOL      fHexTranslation = FALSE; // Simulate for encryption filters
BOOL      fReadHeaders = FALSE;    // On translated reply, have we read HTTP headers?
BOOL      fProxyRequest = FALSE;   // Is this a proxy request?
DWORD     cbContentLength = 0xffffffff; // Number of bytes in server reply
char      achAuth[256];            // Authentication schemes to support
char *    pchAuth = achAuth;       // Current position in achAuth
char      bufftmp[65535];          // Temporary buffer
#if TCP_AUTHENT
TCP_AUTHENT * pTcpAuth = NULL;     // NT Authentication class
#endif
char      achAuthData[512];        // Server response authentication blob
BOOL      fLoggedOn = FALSE;       // Has the server accepted our request?
BOOL      fPipelined = FALSE;

//
//  Default field names for authorization
//

char * pchAuthSendHeader = "Authorization: ";
char * pchAuthRecvHeader = "WWW-Authenticate: ";


int __cdecl 
main( int argc, char * argv[], char * envp[] )
{
    CHAR * pch;

    if ( argc < 3 )
    {
        PrintUsage();
        return 0;
    }

    pchServer = argv[1];
    pchInputFile = argv[2];
    memset( achAuth, 0, sizeof( achAuth ));

    for ( int i = 4; i < (argc + 1); i++ )
    {
        switch ( *(pch = (argv[i-1] + 1) ))
        {
        case 'k':
        case 'K':
            fKeepConnection = TRUE;
            break;


        case 'x':
        case 'X':
            fPipelined = TRUE;
            break;
        case 'e':
        case 'E':
            fEchoSends = TRUE;
            break;

        case 'd':
        case 'D':
            fDumpAuth = TRUE;
            break;

        //
        //  -u:username:password
        //

        case 'u':
        case 'U':
            if ( *(++pch) != ':' )
            {
                PrintUsage();
                return 0;
            }

            pch++;

            pchUserName = pch;

            if ( pch = strchr( pch, ':' ) )
            {
                *pch = '\0';
                pchPassword = pch+1;
            }
            else
            {
                pchPassword = "";
            }
            break;

        //
        //  Authentication schemes
        //
        //  -a:NTLM -a:Basic
        //

        case 'a':
        case 'A':
            if ( *(++pch) != ':' )
            {
                PrintUsage();
                return 0;
            }

            pch++;

            strcpy( pchAuth, pch );
            pchAuth += strlen( pch ) + 1;
            break;

        //
        // translation schemes
        //

        case 't':
        case 'T':
            //
            //  Assume hex conversion for time being
            //

            fHexTranslation = TRUE;
            break;

        case 'H':
        case 'h':
            fDontEchoHeaders = TRUE;
            break;

        case 'P':
        case 'p':
            pchAuthSendHeader = "Proxy-Authorization: ";
            pchAuthRecvHeader = "Proxy-Authenticate: ";
            break;
        }
    }

    if ( !ReadRequest() )
        return -1;

    while ( TRUE )
    {
        if ( !SendRequest() ||
             !ReadReply()     )
        {
            break;
        }
    }

    return 0;
}

//
//  ReadRequest - Reads stdin for an HTTP request
//

BOOL ReadRequest( void )
{
    int    i;
    char * pch;
    FILE *stream;

    cbRequest = 0;

    if( (stream = fopen( pchInputFile, "rb" )) != NULL )
        cbRequest = fread( buff, 1, sizeof(buff), stream );

    if ( !cbRequest )
    {
        fprintf( stderr, "failed to read anything from %s, quitting\n", pchInputFile);
        return FALSE;
    }

    buff[cbRequest] = '\0';

    pchCurrentReq = SkipComments( buff );
    return TRUE;
}

//
//  SendRequest - Sends the request to the specified server
//

BOOL SendRequest( VOID )
{
    WSADATA     WSAData;
    int         status;
    SOCKADDR dest_sin;

    if ( sock == INVALID_SOCKET )
    {
        if ((status = WSAStartup(MAKEWORD(1,1), &WSAData)) != 0)
        {
            fprintf( stderr, "WSAStartup failed, status = %d\n", status);
            return FALSE;
        }

        sock = socket( AF_INET, SOCK_STREAM, 0);

        if (sock == INVALID_SOCKET)
        {
            fprintf( stderr, "socket() failed, error %u\n", GetLastError());
            return FALSE;
        }

        //
        //    Retrieve the IP address and TCP Port number
        //    Global variable szBuff contains the remote host name.
        //

        if (!FillAddr( &dest_sin, TRUE))
        {
           closesocket( sock );
           return FALSE;
        }

        if ( connect( sock, (PSOCKADDR) &dest_sin, sizeof( dest_sin)) < 0)
        {
           fprintf( stderr, "connect() failed, error %d", WSAGetLastError());
           closesocket( sock );
           return FALSE;
        }
    }

    CHAR * pch = BuildNextRequest();

    if ( !pch )
        return FALSE;

    int cb = strlen( pch );

    if ( fEchoSends )
    {
        printf( pch );
        printf("==========================End=of=Request=====================================\n");
    }

    if ( send( sock, pch, cb, 0 ) != cb )
    {
        closesocket( sock );
        fprintf( stderr, "send() failed, error %d", WSAGetLastError());
        return FALSE;
    }

    return TRUE;
}

//
//  ReadReply - Read's the server's reply and outputs it to stdout
//

BOOL ReadReply( VOID )
{
    int  cb;
    DWORD  cbTotal = 0;
    BOOL fReadAny = FALSE;
    CHAR * pchAuthField;

    while ( (cb = recv( sock, bufftmp, sizeof(bufftmp), 0 )) > 0 )
    {
        DWORD cbHeaders = 0;
        CHAR * pch;
        CHAR * pchtmp;

        fReadAny = TRUE;
        bufftmp[cb] = '\0';

        //
        //  Are we expecting a translated reply?
        //

        if ( fHexTranslation )
        {
            BOOL fAllHeaders;

            //
            //  Print out the special HTTP headers
            //

            if ( !fReadHeaders )
            {
                //
                //  We currently assume we'll always get all of the
                //  HEX-HTTP headers
                //

                cbHeaders = PrintHeaders( &fAllHeaders );
            }

            //
            //  Now translate the data in place
            //

            pch = bufftmp + cbHeaders;
            pchtmp = bufftmp;

            while ( *pch )
            {
                *pchtmp = TOHEX( *pch ) * 16 + TOHEX( pch[1]);
                pchtmp++;
                pch += 2;
            }

            *(pchtmp) = '\0';
            cb = pchtmp - bufftmp;
        }

        //
        //  Print out the regular HTTP headers if we haven't already
        //

        if ( !fReadHeaders )
        {
            cbHeaders = PrintHeaders( &fReadHeaders );
        }

        cbTotal += cb - cbHeaders;
        fwrite( bufftmp + cbHeaders, 1, cb - cbHeaders, stdout );

        //
        //  Get the content length field
        //

        if ( pch = strstr( bufftmp, "Content-Length:" ))
        {
            pch = strchr( pch, ':' );
            pch++;
            while ( *pch == ' ' )
                pch++;

            cbContentLength = (DWORD) atoi( pch );
        }

        //
        //  Did we successfully get the response?
        //

        if ( !fLoggedOn && strstr( bufftmp, " 200 OK\r\n" ))
        {
            fLoggedOn = TRUE;
        }

        //
        //  Were we denied access from a new response?
        //

        if ( fLoggedOn && strstr( bufftmp, " 401 Access Denied" ))
        {
            fLoggedOn = FALSE;
        }

        //
        //  Need to grab the first WWW-Authenticate headers and grab the server
        //  authentication response blob
        //

        pch = bufftmp;

        while ( pch = strstr( pch, pchAuthRecvHeader ) )
        {
            //
            // Skip the field name
            //
            CHAR * pchtmp = strchr( pch, ':');
            pchtmp++;

            //
            //  Get the scheme name (and ignore it)
            //

            int i = 0;
            while ( *pchtmp == ' ' ) pchtmp++;

            while ( *pchtmp != ' ' &&
                    *pchtmp )
            {
                //achScheme[i++] = *pchtmp;
                pchtmp++;
            }

            //
            //  Note we copy a bunch of extra stuff here, uuencode stops
            //  after the first non-printable character
            //

            strncpy( achAuthData, pchtmp, sizeof( achAuthData ) );
            achAuthData[sizeof(achAuthData)-1] = '\0';

            //
            //  We only handle one authentication scheme
            //

            goto Exit;

        }

        if ( cbTotal >= cbContentLength )
        {
            if (!fPipelined) 
            {
                break;
            }
        }
    }

Exit:

    if ( !fReadAny )
        return FALSE;

    if ( fEchoSends )
        printf("\n==========================End=of=Reply=====================================\n");
    return TRUE;
}

CHAR * BuildNextRequest( VOID )
{
    //
    //  Are we done?
    //

    if ( !pchCurrentReq || !*pchCurrentReq )
        return NULL;

    //
    //  Expect a large chunk of data unless we here otherwise
    //

    cbContentLength = (DWORD) -1;

    //
    //  If this isn't the first request, skip the HTTP terminator
    //

    if ( !strncmp( pchCurrentReq, HTTP_REQ_TERM, sizeof( HTTP_REQ_TERM ) - 1))
    {
        pchCurrentReq += sizeof(HTTP_REQ_TERM) + 1;
    }

    pchCurrentReq = SkipComments( pchCurrentReq );

    //
    //  Look for the request terminator or end of file
    //

    CHAR * pchEnd = strstr( pchCurrentReq, HTTP_REQ_TERM );
    UINT cb;
    char ch;

    if ( !pchEnd )
    {
        cb = strlen( pchCurrentReq );
    }
    else
    {
        ch = *pchEnd;
        *pchEnd = '\0';
        cb = pchEnd - pchCurrentReq;
    }

    //
    //  Watch for the case where the last request ends in $END
    //

    if ( !cb )
        return FALSE;

    CHAR * pch = pchCurrentReq;

    //
    //  Copy the first line
    //

    pch = strchr( pch, '\n' );
    strncpy( bufftmp, pchCurrentReq, pch - pchCurrentReq + 1);
    bufftmp[pch - pchCurrentReq + 1] = '\0';
    pch++;

    //
    //  Add any optional lines (authentication, pragmas etc)
    //

    if ( fKeepConnection )
    {
        strcat( bufftmp, "Connection: keep-alive\r\n");
    }

    if ( !fLoggedOn )
    {
        if ( !AddAuthorizeHeaders( bufftmp ) )
            return NULL;
    }

    //
    //  Append the rest of the request
    //

    strcat( bufftmp, pch );

    //
    //  Do any translations on the outgoing data
    //

#define HEX_HTTP_HEADER      "GET * HEX-HTTP/1.0\r\n\r\n"

    if ( fHexTranslation )
    {
        DWORD cbHdr = strlen( bufftmp );

        bufftmp[cbHdr*2] = '\0';

        while ( cbHdr > 0 )
        {
            CHAR ch = bufftmp[cbHdr-1];

            bufftmp[(cbHdr-1)*2 + 1] = HEXDIGIT( ch % 16 );

            ch /= 16;

            bufftmp[(cbHdr-1)*2] = HEXDIGIT( ch % 16 );

            cbHdr--;
        }

        //
        //  Copy the new HTTP header
        //

        memmove( bufftmp + sizeof(HEX_HTTP_HEADER) - 1,
                 bufftmp,
                 strlen(bufftmp) );

        memcpy( bufftmp,
                HEX_HTTP_HEADER,
                sizeof(HEX_HTTP_HEADER) - 1 );
    }


    //
    //  Set up for the next request
    //

    if ( pchEnd )
        *pchEnd = ch;

    pchCurrentReq = pchEnd;

    return bufftmp;
}


BOOL AddAuthorizeHeaders( CHAR * pch )
{
#ifdef TCP_AUTH
    CHAR * pchSchemes = achAuth;
    BUFFER buff;
    CHAR   achUserAndPass[256];
    DWORD  cbOut;
    BOOL   fNeedMoreData;

    while ( *pchSchemes )
    {
        if ( !_stricmp( pchSchemes, "Basic" ))
        {
            strcpy( achUserAndPass, pchUserName );
            strcat( achUserAndPass, ":" );
            strcat( achUserAndPass, pchPassword );

            uuencode( (BYTE *) achUserAndPass,
                      strlen( achUserAndPass ),
                      &buff );
            strcat( pch, pchAuthSendHeader );
            strcat( pch, "Basic " );
            strcat( pch, achUserAndPass ),
            strcat( pch, "\r\n");
        }
        else
        {
            if ( !pTcpAuth )
            {
                pTcpAuth = new TCP_AUTHENT( TCPAUTH_CLIENT | TCPAUTH_UUENCODE );
            }
            else
            {
                if ( fDumpAuth )
                    DumpAuthBuffer( achAuthData, "Server" );
            }

            //
            //  Assume this is an NT authentication scheme
            //

            if ( !pTcpAuth->Converse( (void *) achAuthData,
                                      0,
                                      &buff,
                                      &cbOut,
                                      &fNeedMoreData,
                                      pchSchemes,
                                      pchUserName,
                                      pchPassword ))
            {
                printf("SSP conversation failed, error %x, scheme %s\n",
                        GetLastError(),
                        pchSchemes );
                return FALSE;
            }

            if ( fDumpAuth )
            {
                DumpAuthBuffer( buff.QueryPtr(), "Client" );
            }

            strcat( pch, pchAuthSendHeader );
            strcat( pch, pchSchemes );
            strcat( pch, " " );
            strcat( pch, (CHAR *) buff.QueryPtr() );
            strcat( pch, "\r\n" );
        }

        pchSchemes += strlen(pchSchemes) + 1;
    }
#endif
    return TRUE;
}

//
//  PrintUsage - Usage information
//

void PrintUsage( void )
{
    printf("\n\nhttpcmd version %s - Command line HTTP client\n", HTTPCMD_VERSION );
    printf("usage: httpcmd server input.file [options] \n\n");
    printf("Where input.file contains a full HTTP request\n");
    printf("The server's reply is sent to stdout");
    printf("Options:\n"
           "    -k  - Send Pragma: Keep-connection, input.file contains multiple requests\n"
           "          seperated by " HTTP_REQ_TERM " on a blank line\n"
           "\n"
           "    -u:username:password - Use the specified user name and password for\n"
           "                           authentication purposes\n"
           "\n"
           "    -a:<authentication scheme>, can be \"Basic\", \"NTLM\" or \"MS-KERBEROS\"\n"
           "          Only one NT authentication scheme is currently supported\n"
           "\n"
           "    -e  - Echo send requests to stdout.  Shows what's being requested\n"
           "\n"
           "    -t  - Do HEX-HTTP for filter testing\n"
           "\n"
           "    -h  - Don't echo HTTP headers\n"
           "\n");

}

BOOL FillAddr( PSOCKADDR psin,
               BOOL bConnect)
{
   DWORD dwSize;
   char szTemp[200];
   int protocols[2];

   BYTE buffer[2048];
   DWORD bufferSize;
   char aliasBuffer[512];
   DWORD aliasBufferSize;
   int count;
   PCSADDR_INFO csaddrInfo;
   GUID TcpGuid = SVCID_HOSTNAME;
   GUID *pGuid;
   bufferSize = sizeof(buffer);
   aliasBufferSize = sizeof(aliasBuffer);
   LPINET_SERVER_INFO pInetServerInfo;
   DWORD err;

       /*
       *   If we are setting up for a listen() call (bConnect = FALSE),
       *   fill servent with our address.
       */
       if (!bConnect) {

         /*
          *   Retrieve my ip address.  Assuming the hosts file in
          *   in %systemroot%/system/drivers/etc/hosts contains my computer name.
          */

         dwSize = sizeof(szTemp);
         GetComputerName(szTemp, &dwSize);
      }
      else
      {
         strcpy( szTemp, pchServer );
      }

   protocols[0] = IPPROTO_TCP;
   pGuid = &TcpGuid;

   protocols[1] = 0;

   count = GetAddressByName(
               NS_DEFAULT,
               pGuid,
               szTemp,
               protocols,
               0,
               NULL,
               buffer,
               &bufferSize,
               aliasBuffer,
               &aliasBufferSize
               );

   if (count <= 0) {
       fprintf( stderr,
               "GetAddressByName for machine %s failed with error %d.",
               szTemp,
               GetLastError());

      return FALSE;
   }

   csaddrInfo = (PCSADDR_INFO)buffer;
   memcpy((char FAR *)psin,
           (char FAR *)(csaddrInfo->RemoteAddr.lpSockaddr),
           csaddrInfo->RemoteAddr.iSockaddrLength);

   ((PSOCKADDR_IN) psin)->sin_port = htons(portno);

   return TRUE;
}


//
//  Skip comments.  Comments (marked with "//") must be the first thing
//  in the file and must be at the beginning of the line
//

CHAR * SkipComments( CHAR * pch )
{
    while ( TRUE )
    {
        if ( *pch == '/' )
        {
            pch = strchr( pch, '\n' );
            pch++;
        }
        else
        {
            break;
        }
    }

    return pch;
 }

#if TCP_AUTH
 VOID DumpAuthBuffer( VOID * pbuff, char * pchSrc )
 {
#define NUM_CHARS 16
    BUFFER buftmp;
    DWORD  cb;
    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr;

    if ( !pbuff )
    {
        printf("No Authorization return buffer\n");
        return;
    }

    TCP_REQUIRE( uudecode( (char *) pbuff,
                           &buftmp,
                           &cb ));

    BufferPtr = (LPBYTE) buftmp.QueryPtr();

    printf("%s: Authorization data - %d bytes:\n", pchSrc, cb );


    //
    // Hex dump of the bytes
    //
    limit = ((cb - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < cb) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("   ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }
 }
#endif

DWORD PrintHeaders( BOOL * pfAllHeaders )
{
    CHAR * pch;
    DWORD  cbHeaders;

    //
    //  Find the end of the headers
    //

    pch = bufftmp;
    while ( pch = strchr( pch, '\n' ))
    {
        if ( *(pch = SkipWhite( pch + 1)) == '\n' )
            break;
    }

    if ( pch )
    {
        pch++;
        cbHeaders = pch - bufftmp;
        *pfAllHeaders = TRUE;
    }
    else
    {
        //
        //  We don't have all of the headers yet
        //

        cbHeaders = strlen( bufftmp );
        *pfAllHeaders = FALSE;
    }

    if ( !fDontEchoHeaders )
        fwrite( bufftmp, 1, cbHeaders, stdout );

    return cbHeaders;
}

CHAR * SkipWhite( CHAR * pch )
{
    while ( ISWHITE( *pch ) )
    {
        pch++;
    }

    return pch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\httpauth\get_sock.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    get_sock.c

Abstract:

    This does a get using raw sockets

History:

    09-Nov-1995     Created
    15-Feb-1996     Added authentication support

--*/

#include <windows.h>
#include <winsock2.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <io.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "httpauth.h"

// globals

#define HD_AUTHENTICATE         "WWW-Authenticate:"
#define HD_LENGTH               "Content-Length:"
#define HD_CONNECTION           "Connection:"

// list of Authentication methods to support

char      achAuth[256];


// Helper functions

void SkipWhite(PSTR *ppS )
{
    PSTR pS = *ppS;

    while ( *pS && isspace(*pS) )
        ++pS;

    *ppS = pS;
}


void SkipNonWhite(PSTR *ppS )
{
    PSTR pS = *ppS;

    while ( *pS && !isspace(*pS) )
        ++pS;

    *ppS = pS;
}



BOOL
HttpGetSocket(
    char * Verb,
    char * Server,
    char * URL,
    BOOL   DisplayHeaders,
    DWORD  ClientDataSize,
    PSTR   pchUserName,
    PSTR   pchPassword,
    PSTR   pszStore,
    PSTR   pszPref
    )
/*++

 Routine Description:

    Issue a command to a HTTP server using authentication

 Arguments:

    Verb                HTTP command : GET / HEAD / ...
    Server              server name
    URL                 URL to send to the server
    DisplayHeaders      TRUE to display headers as received
    ClientDataSize      number of bytes to send in the request
    pchUserName         user name for authentication
    pchPassword         password for authentication
    pszStore            file name where to dump reply from server

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    char               ReceiveBuffer[8*1024];
    int                Error;
    BYTE               Request[1024];
    int                RequestSize;
    char *             AcceptTypes[2] = {"*/*", NULL};
    SOCKET             Socket = INVALID_SOCKET;
    WSADATA            WsaData;
    struct sockaddr_in Address;
    struct sockaddr_in AddressC;
    struct hostent *   HostEntry;
    char               Headers[] =
                           "HTTP/1.0\r\n"
                           "User-Agent: AuthClient\r\n"
                           "Accept: */*\r\n";
    char               CrLf[] = "\r\n";
    BYTE               ClientData[64*1024];
    BOOL               fKeepAlive = FALSE;
    int                cRec;
    DWORD              cLen;
    BOOL               fInHeader;
    CHAR               achAuthData[512];
    BOOL               fServerKeepAlive = FALSE;
    BOOL               fNeedMoreData;
    BOOL               fNeedAuthenticate;
    PSTR               pH;
    PSTR               pN;
    BOOL               fStatusLine;
    int                Status = -1;
    DWORD              cToRead;
    PSTR               paAuth = achAuth;
    BOOL               fSt = FALSE;
    int                hnd = EOF;
    PSTR               pAuth;

    Error = WSAStartup (0x101, &WsaData);

    if (Error == SOCKET_ERROR)
    {
        fprintf(stderr, "Error in WSAStartup = %d\n", GetLastError());
        return FALSE;
    }

    if ( !InitAuthorizationHeader() )
    {
        fprintf(stderr, "Cannot initialize security module\n" );
        return FALSE;
    }

    memset( achAuth, '\0', sizeof(achAuth) );
    achAuthData[0] = '\0';
    fNeedAuthenticate = FALSE;

    AddressC.sin_addr.s_addr = (unsigned long)-1;

    //
    // Connect to the server
    //

    if  ( pszStore != NULL )
        if ( (hnd = _open( pszStore, _O_BINARY | _O_CREAT | _O_TRUNC | _O_RDWR, S_IREAD|S_IWRITE )) == EOF )
        {
            fprintf( stderr, "Can't create file %s\n", pszStore );
            return FALSE;
        }

again:

    if ( Socket == INVALID_SOCKET )
    {
        Socket = socket(AF_INET, SOCK_STREAM, 0);

        if (Socket == INVALID_SOCKET)
        {
            fprintf(stderr, "Error creating socket = %d\n", GetLastError());
            fSt = FALSE;
            goto ex;
        }

        Address.sin_family = AF_INET;
        Address.sin_port = 0;
        Address.sin_addr.s_addr = INADDR_ANY;

        Error =
        bind(
            Socket,
            (struct sockaddr *) &Address,
            sizeof(Address));

        if (Error)
        {
            fprintf(stderr, "Error in bind = %d\n", GetLastError());
            fSt = FALSE;
            goto ex;
        }

        if ( AddressC.sin_addr.s_addr == -1 )
        {
            AddressC.sin_family = AF_INET;
            AddressC.sin_port = htons(80);
            AddressC.sin_addr.s_addr = inet_addr(Server);

            if (AddressC.sin_addr.s_addr == -1)
            {
                //
                // Must be a server name
                //

                HostEntry = gethostbyname(Server);

                if (HostEntry == NULL)
                {
                    printf("unable to resolve %s\n", Server);
                    fSt = FALSE;
                    goto ex;
                } else
                {
                    AddressC.sin_addr.s_addr = *((unsigned long *) HostEntry->h_addr);
                }
            }
        }

        Error =
        connect(
            Socket,
            (struct sockaddr *) &AddressC,
            sizeof(AddressC));

        if (Error)
        {
            fprintf(stderr, "Error connecting to %s = %d\n", Server, GetLastError());
            fSt = FALSE;
            goto ex;
        }
    }

    //
    // Send the client request
    //

    strcpy(Request, Verb);
    strcat(Request, " ");
    strcat(Request, URL);
    strcat(Request, " ");
    strcat(Request, Headers);
    if (ClientDataSize)
    {
        sprintf(ClientData, "Content-Length: %d\r\n", ClientDataSize);
        strcat(Request, ClientData);
    }
    if ( fKeepAlive )
    {
        strcat(Request, "Connection: Keep-Alive\r\n" );
    }

    if ( !AddAuthorizationHeader( Request + strlen(Request),
                achAuth,
                achAuthData[0] == '\0' ? NULL : achAuthData,
                Verb,
                URL,
                pchUserName,
                pchPassword,
                &fNeedMoreData ) )
    {
        printf( "Authentication failed\n" );
        fSt = FALSE;
        goto ex;
    }

    strcat(Request, CrLf);

    RequestSize = strlen(Request);

    Error =
    send(
        Socket,
        Request,
        RequestSize,
        0);

    if (Error != RequestSize)
    {
        printf("Error in client send = %d, %d\n", Error, GetLastError());
        fSt = FALSE;
        goto ex;
    }

    if (ClientDataSize)
    {
        memset( ClientData, ' ', ClientDataSize );

        //
        // Send the client data
        //

        Error =
        send(
            Socket,
            ClientData,
            ClientDataSize,
            0);

        if ( (DWORD)Error != ClientDataSize)
        {
            printf("Error in client send = %d, %d\n", Error, GetLastError());
            fSt = FALSE;
            goto ex;
        }
    }

    // parse status & header

    cLen = (DWORD)-1;
    fInHeader = TRUE;
    fServerKeepAlive = FALSE;
    fNeedAuthenticate = FALSE;

    for ( pH = ReceiveBuffer, fStatusLine = TRUE ; fInHeader ; )
    {
        cRec = recv( Socket, pH, ReceiveBuffer+sizeof(ReceiveBuffer)-pH, 0 );
        if ( cRec <= 0 )
        {
            closesocket( Socket );
            Socket = INVALID_SOCKET;
            break;
        }
        pH[ cRec ] = '\0';

        // Iterate on header fields

        while ( pN = strstr(pH, "\r\n" ) )
        {
            *pN = '\0';

            if ( DisplayHeaders )
            {
                printf( "%s\n", pH );
            }

            if ( fStatusLine )
            {
                // This is the status line, decode status

                SkipNonWhite( &pH );
                SkipWhite( &pH );
                Status = atoi( pH );
                if ( Status == 401 )
                {
                    fNeedAuthenticate = TRUE;
                }
                fStatusLine = FALSE;
            }
            else if ( pN == pH )    // end of header fields
            {
                if ( hnd != EOF )
                    _write( hnd, pH+2, ReceiveBuffer+cRec-pH-2 );

                cLen -= ( ReceiveBuffer+cRec-pH-2 );
                fInHeader = FALSE;
                break;
            }
            else if ( !_strnicmp( pH, HD_AUTHENTICATE, sizeof(HD_AUTHENTICATE)-1 ) )
            {
                SkipNonWhite( &pH );
                SkipWhite( &pH );

                // check if we are already in the authentication sequence
                if ( !IsInAuthorizationSequence() )
                {
                    // append to list of supported authentication methods

                    if ( (pAuth = strchr( pH, ' ' )) )
                    {
                        *pAuth = '\0';
                        strcpy( achAuthData, pAuth + 1);
                    }
                    else
                    {
                        achAuthData[0] = '\0';
                    }
                    strcpy( paAuth, pH );
                    paAuth += strlen( pH ) + 1;
                }
                else
                {
                    // store pointer to authenticate blob

                    SkipNonWhite( &pH );
                    if ( *pH == ' ' )
                    {
                        *pH++ = '\0';
                    }
                    SkipWhite( &pH );
                    strcpy( achAuthData, pH);
                }
            }
            else if ( !_strnicmp( pH, HD_LENGTH, sizeof(HD_LENGTH)-1 ) )
            {
                // get content length

                SkipNonWhite( &pH );
                SkipWhite( &pH );
                cLen = atoi( pH );
            }
            else if ( !_strnicmp( pH, HD_CONNECTION, sizeof(HD_CONNECTION)-1 ) )
            {
                // check for keep-alive flag

                SkipNonWhite( &pH );
                SkipWhite( &pH );
                if ( !_strnicmp( pH, "Keep-Alive", sizeof("Keep-Alive")-1 ) )
                    fServerKeepAlive = TRUE;
            }

            pH = pN + 2;
        }
    }

    // add final delimiter to list of supported authentication methods

    if ( !IsInAuthorizationSequence() && fNeedAuthenticate )
    {
        *paAuth = '\0';

        // Insure specified methods are supported localy

        if ( !ValidateAuthenticationMethods( achAuth, pszPref ) )
        {
            // None of the server specified authentication methods
            // are supported localy.

            SetLastError( ERROR_ACCESS_DENIED );

            fprintf( stderr, "No supported authentication method\n" );

            fSt = FALSE;
            goto ex;
        }
    }

    // read message body

    if ( Socket != INVALID_SOCKET )
    {
        for ( ; cLen ; )
        {
            if ( (cToRead = sizeof(ReceiveBuffer)) > cLen )
                cToRead = cLen;
            cRec = recv( Socket, ReceiveBuffer, cToRead, 0 );

            if ( cRec <= 0 )
            {
                closesocket( Socket );
                Socket = INVALID_SOCKET;
                break;
            }
            if ( hnd != EOF )
                _write( hnd, ReceiveBuffer, cRec );

            cLen -= cRec;
        }
    }

    if ( !fServerKeepAlive )
    {
        if ( IsInAuthorizationSequence() )
        {
            fprintf( stderr, "Authentication rejected by server\n" );

            fNeedAuthenticate = FALSE;  // authentication failed
        }

        closesocket( Socket );
        Socket = INVALID_SOCKET;
    }

    if ( fNeedAuthenticate )
    {
        fKeepAlive = TRUE;
        goto again;
    }

    if ( Socket != INVALID_SOCKET )
        closesocket(Socket);

    fSt = Status == 200;

ex:
    TerminateAuthorizationHeader();

    if ( hnd != EOF )
        _close( hnd );

    return fSt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\httpauth\httpauth.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    httpauth.c

Abstract:

    Handles authentication sequence ( Basic & SSPI )

History:

    Created     15-Feb-1996


Revision History:

--*/

/************************************************************
 *    Include Headers
 ************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <rpc.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <fcntl.h>

#include <ntsam.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <crypt.h>
#include <logonmsv.h>

#define SECURITY_WIN32
#include <sspi.h>
#include <issperr.h>
#include <md5.h>


// declaration for this module

#include "httpauth.h"

#define SEC_SUCCESS(Status) ((Status) >= 0)
#define SIZE_MD5_DIGEST     32

// Target name for the security package

#define TOKEN_SOURCE_NAME       "InetSvcs"

// header fields for Digest authentication

enum MD5_AUTH_NAME
{
    MD5_AUTH_USERNAME,
    MD5_AUTH_URI,
    MD5_AUTH_REALM,
    MD5_AUTH_NONCE,
    MD5_AUTH_RESPONSE,
    MD5_AUTH_ALGORITHM,
    MD5_AUTH_DIGEST,
    MD5_AUTH_OPAQUE,
    MD5_AUTH_LAST,
};

//
// value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAME
//

PSTR MD5_AUTH_NAMES[] = {
    "username",
    "uri",
    "realm",
    "nonce",
    "response",
    "algorithm",
    "digest",
    "opaque"
} ;


// general purpose dynamic buffer structure

typedef struct _BUFFER {
    PBYTE pBuf;
    DWORD cLen;
} BUFFER ;


// structure storing the state of the authentication sequence

typedef struct _AUTH_SEQ {
    BOOL _fNewConversation;
    CredHandle _hcred;
    BOOL _fHaveCredHandle;
    DWORD _cbMaxToken;
    BOOL _fHaveCtxtHandle;
    struct _SecHandle  _hctxt;
    BOOL _fUUEncodeData;
} AUTH_SEQ;

// entry points in the security DLL

typedef struct _SEC_FUNC {
    FREE_CREDENTIALS_HANDLE_FN pFreeCredentialsHandle;
    ACQUIRE_CREDENTIALS_HANDLE_FN pAcquireCredentialsHandle;
    QUERY_SECURITY_PACKAGE_INFO_FN pQuerySecurityPackageInfo;   // A
    FREE_CONTEXT_BUFFER_FN pFreeContextBuffer;
    INITIALIZE_SECURITY_CONTEXT_FN pInitializeSecurityContext;  // A
    COMPLETE_AUTH_TOKEN_FN pCompleteAuthToken;
    ENUMERATE_SECURITY_PACKAGES_FN pEnumerateSecurityPackages;  // A
} SEC_FUNC;

// local functions

BOOL CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    );

BOOL AuthConverse(
    AUTH_SEQ *pAS,
    VOID   * pBuffIn,
    DWORD    cbBuffIn,
    BUFFER * pbuffOut,
    DWORD  * pcbBuffOut,
    BOOL   * pfNeedMoreData,
    CHAR   * pszPackage,
    CHAR   * pszUser,
    CHAR   * pszPassword
    );

BOOL AuthInit( AUTH_SEQ *pAS );

void AuthTerminate( AUTH_SEQ *pAS );


// uuencode/decode routines declaration
// used to code the authentication blob

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded );
BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded );


/************************************************************
 *    Globals for this module
 ************************************************************/

static BOOL g_fAuth = FALSE;
static BOOL g_fBasic = FALSE;
static AUTH_SEQ g_Auth;
static HINSTANCE g_hSecLib = NULL;
static SEC_FUNC sfProcs;


/************************************************************
 *    Helper functions
 ************************************************************/

VOID
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )
/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/
{
    UINT x;
    UINT y;

#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}


LPSTR
ParseSkipWhite(
    LPSTR p
    )
/*++

Routine Description:

    Skip white spaces and ','

Arguments:

    p - ptr to string

Return Value:

    updated ptr after skiping white space

--*/
{
    while ( isspace(*p) || *p == ',' )
    {
        ++p;
    }

    return p;
}


BOOL ParseForName(
    PSTR pszStr,
    PSTR *pNameTable,
    UINT cNameTable,
    PSTR *pValueTable
    )
/*++

Routine Description:

    Parse list of name=value pairs for known names

Arguments:

    pszStr - line to parse ( '\0' delimited )
    pNameTable - table of known names
    cNameTable - number of known names
    pValueTable - updated with ptr to parsed value for corresponding name

Return Value:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    PSTR pszBeginName;
    PSTR pszEndName;
    PSTR pszBeginVal;
    PSTR pszEndVal;
    UINT iN;
    int ch;


    for ( iN = 0 ; iN < cNameTable ; ++iN )
    {
        pValueTable[iN] = NULL;
    }

    for ( ; *pszStr && fSt ; )
    {
        pszStr = ParseSkipWhite( pszStr );

        pszBeginName = pszStr;

        for ( pszEndName = pszStr ; (ch=*pszEndName) && ch != '=' && ch != ' ' ; ++pszEndName )
        {
        }

        if ( *pszEndName )
        {
            *pszEndName = '\0';

            for ( pszBeginVal = ++pszEndName ; (ch=*pszBeginVal) && ch != '"' ; ++pszBeginVal )
            {
            }
            if ( *pszBeginVal == '"' )
            {
                ++pszBeginVal;
                for ( pszEndVal = pszBeginVal ; (ch=*pszEndVal) ; ++pszEndVal )
                {
                    if ( ch == '"' )
                    {
                        break;
                    }
                }
                if ( *pszEndVal == '"' )
                {
                    // find name in table
                    for ( iN = 0 ; iN < cNameTable ; ++iN )
                    {
                        if ( !_stricmp( pNameTable[iN], pszBeginName ) )
                        {
                            break;
                        }
                    }
                    if ( iN < cNameTable )
                    {
                        pValueTable[iN] = pszBeginVal;
                        *pszEndVal = '\0';
                    }
                    pszStr = ++pszEndVal;
                    continue;
                }
            }
        }

        fSt = FALSE;
    }

    return fSt;
}


BOOL BufferInit( BUFFER *pB )
{
    pB->pBuf = NULL;
    pB->cLen = 0;

    return TRUE;
}


void BufferTerminate( BUFFER *pB )
{
    if ( pB->pBuf != NULL )
    {
        free( pB->pBuf );
        pB->pBuf = NULL;
        pB->cLen = 0;
    }
}


PBYTE BufferQueryPtr( BUFFER * pB )
{
    return pB->pBuf;
}


BOOL BufferResize( BUFFER *pB, DWORD cNewL )
{
    PBYTE pN;
    if ( cNewL > pB->cLen )
    {
        pN = malloc( cNewL );
        if ( pB->pBuf )
        {
            memcpy( pN, pB->pBuf, pB->cLen );
            free( pB->pBuf );
        }
        pB->pBuf = pN;
        pB->cLen = cNewL;
    }

    return TRUE;
}


/************************************************************
 *    Authentication functions
 ************************************************************/


BOOL
InitAuthorizationHeader(
    )
/*++

 Routine Description:

    Initialize the authentication package

 Arguments:

    None

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    OSVERSIONINFO   VerInfo;
    UCHAR lpszDLL[MAX_PATH];

    //
    //  Find out which security DLL to use, depending on
    //  whether we are on NT or Win95
    //
    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&VerInfo))   // If this fails, something has gone wrong
    {
        return FALSE;
    }

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        strcpy (lpszDLL, "security.dll" );
    }
    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        strcpy (lpszDLL, "secur32.dll" );
    }
    else
    {
        return FALSE;
    }

    //
    //  Load Security DLL
    //

    g_hSecLib = LoadLibrary (lpszDLL);
    if (g_hSecLib == NULL)
    {
        return FALSE;
    }

    // Get all entry points we care about

    sfProcs.pFreeCredentialsHandle
            = (FREE_CREDENTIALS_HANDLE_FN) GetProcAddress(
                    g_hSecLib,
                    "FreeCredentialsHandle" );

    sfProcs.pQuerySecurityPackageInfo
            = (QUERY_SECURITY_PACKAGE_INFO_FN) GetProcAddress(
                    g_hSecLib,
                    "QuerySecurityPackageInfoA" );

    sfProcs.pAcquireCredentialsHandle
            = (ACQUIRE_CREDENTIALS_HANDLE_FN) GetProcAddress(
                    g_hSecLib,
                    "AcquireCredentialsHandleA" );

    sfProcs.pFreeContextBuffer
            = (FREE_CONTEXT_BUFFER_FN) GetProcAddress(
                    g_hSecLib,
                    "FreeContextBuffer" );

    sfProcs.pInitializeSecurityContext
            = (INITIALIZE_SECURITY_CONTEXT_FN) GetProcAddress(
                    g_hSecLib,
                    "InitializeSecurityContextA" );

    sfProcs.pCompleteAuthToken
            = (COMPLETE_AUTH_TOKEN_FN) GetProcAddress(
                    g_hSecLib,
                    "CompleteAuthToken" );

    sfProcs.pEnumerateSecurityPackages
            = (ENUMERATE_SECURITY_PACKAGES_FN) GetProcAddress(
                    g_hSecLib,
                    "EnumerateSecurityPackagesA" );

    if ( sfProcs.pFreeCredentialsHandle == NULL
            || sfProcs.pQuerySecurityPackageInfo == NULL
            || sfProcs.pAcquireCredentialsHandle == NULL
            || sfProcs.pFreeContextBuffer == NULL
            || sfProcs.pInitializeSecurityContext == NULL
            || sfProcs.pEnumerateSecurityPackages == NULL )
    {
        FreeLibrary( g_hSecLib );
        g_hSecLib = NULL;
        return FALSE;
    }

    g_fAuth = g_fBasic = FALSE;

    return TRUE;
}


void
TerminateAuthorizationHeader(
    )
/*++

 Routine Description:

    Terminate the authentication package

 Arguments:

    None

 Return Value:

    None

--*/
{
    if ( g_fAuth )
    {
        AuthTerminate( &g_Auth );
        g_fAuth = FALSE;
    }

    g_fBasic = FALSE;

    if ( g_hSecLib != NULL )
    {
        FreeLibrary( g_hSecLib );
        g_hSecLib = NULL;
    }
}


BOOL
IsInAuthorizationSequence(
    )
/*++

 Routine Description:

    Indicates if in authentication sequence

 Arguments:

    None

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    return g_fAuth || g_fBasic;
}


BOOL
ValidateAuthenticationMethods(
    PSTR pszMet,
    PSTR pszPreferedMet
    )
/*++

 Routine Description:

    Filter the supplied authentication list for supported
    methods ( Basic and all local security packages )

 Arguments:

    None

 Return Value:

    Returns TRUE if at least one authentication method supported,
    otherwise FALSE is returned.

--*/
{
    PSecPkgInfo pSec;
    ULONG cSec, iS;
    BOOL fValid;
    PSTR p,t;
    SECURITY_STATUS ss;


    // access local security packages list

    if ( (ss = sfProcs.pEnumerateSecurityPackages( &cSec, &pSec ))
            == STATUS_SUCCESS )
    {
        for ( t = p = pszMet ; *p ; )
        {
            // Valid methods are "Basic", "Digest", "NT-Digest"
            // and all SSPI based security packages

            if ( !_stricmp( p , "Basic" ) )
            {
                fValid = TRUE;
            }
            else if ( !_stricmp( p , "Digest" ) )
            {
                fValid = TRUE;
            }
            else if ( !_stricmp( p , "NT-Digest" ) )
            {
                fValid = TRUE;
            }
            else for ( iS = 0 ; iS < cSec ; ++iS )
            {
                if ( !_stricmp( pSec[iS].Name, p ) )
                {
                    break;
                }
            }

            if ( fValid )
            {
                if ( t != p )
                    memmove( t, p, strlen(p)+1 );
                p += strlen( p ) + 1;
                t += strlen( t ) + 1;
            }
        }
        *t = '\0';
    }

    // check for prefered method

    if ( pszPreferedMet != NULL )
    {
        PSTR pP;

        for ( pP = strtok( pszPreferedMet, "," ) ;
                pP != NULL ;
                pP = strtok( NULL, "," ) )
        {
            // scan list of validated methods for the current
            // prefered method

            for ( p = pszMet ; *p ; )
            {
                if ( !_stricmp( pP, p ) )
                {
                    memmove( pszMet, p, strlen(p) + 1 );
                    return TRUE;
                }
                p += strlen( p ) + 1;
            }
        }

        // no method in the prefered method list is supported

        return FALSE;
    }

    // no prefered method list supplied

    return *pszMet ? TRUE : FALSE;
}


BOOL
AddAuthorizationHeader(
    PSTR pch,
    PSTR pchSchemes,
    PSTR pchAuthData,
    PSTR pchMethod,
    PSTR pchUri,
    PSTR pchUserName,
    PSTR pchPassword,
    BOOL *pfNeedMoreData
    )
/*++

 Routine Description:

    Generates an authentication header to be sent to the server.
    An authentication sequence will be initiated if none is in
    use and at least one of the authentication scheme specified
    in pchSchemes is recognized.
    Otherwise the current authentication sequence will proceed.

 Arguments:

    pch                 where to append authentication header
    pchSchemes          list of null-delimited authentication methods
    pchAuthData         incoming blob from server
    pchUserName         user name ( possibly prefixed with domain )
    pchPassword         password
    pfNeedMoreData      Out: TRUE if authentication sequence to continue

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    CHAR    achUserAndPass[256];
    LPSTR   aValueTable[ MD5_AUTH_LAST ];
    BUFFER  buff;
    BOOL    fSt = TRUE;
    DWORD   cbOut;
    LPSTR   pszA1;
    LPSTR   pszA2;
    LPSTR   pszH;
    MD5_CTX md5;
    BOOL    fNtDigest = FALSE;
    UNICODE_STRING  UnicodePassword;
    NT_OWF_PASSWORD PasswordHash;

    BufferInit( &buff );

    while ( *pchSchemes )
    {
        if ( !_stricmp( pchSchemes, "Basic" ))
        {
            // if already in authentication sequence, it failed.

            if ( g_fBasic )
            {
                SetLastError( ERROR_ACCESS_DENIED );
                fSt = FALSE;
                break;
            }

            strcpy( achUserAndPass, pchUserName );
            strcat( achUserAndPass, ":" );
            strcat( achUserAndPass, pchPassword );

            uuencode( (BYTE *) achUserAndPass,
                      strlen( achUserAndPass ),
                      &buff );
            strcat( pch, "Authorization: " );
            strcat( pch, "Basic " );
            strcat( pch, BufferQueryPtr( &buff ));
            strcat( pch, "\r\n");
            g_fBasic = TRUE;
            break;
        }
        else if ( !_stricmp( pchSchemes, "NT-Digest" ) )
        {
            fNtDigest = TRUE;
            goto as_digest;
        }
        else if ( !_stricmp( pchSchemes, "Digest" ) )
        {
as_digest:
            if ( !_memicmp( pchUri, "http://", sizeof("http://")-1 ) )
            {
                pchUri += sizeof("http://")-1;
                pchUri = strchr( pchUri, '/' );
                if  ( !pchUri )
                {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    fSt = FALSE;
                    break;
                }
            }

            if ( !ParseForName( pchAuthData,
                                MD5_AUTH_NAMES,
                                MD5_AUTH_LAST,
                                aValueTable ) ||
                 aValueTable[MD5_AUTH_REALM] == NULL ||
                 aValueTable[MD5_AUTH_NONCE] == NULL )
            {
                SetLastError( ERROR_ACCESS_DENIED );
                fSt = FALSE;
                break;
            }

            if ( aValueTable[MD5_AUTH_REALM] != NULL &&
                 !_stricmp( aValueTable[MD5_AUTH_REALM], "false" ) )
            {
                aValueTable[MD5_AUTH_REALM] = NULL;
            }

            // if already in authentication sequence, it failed.

            if ( g_fBasic && aValueTable[MD5_AUTH_REALM]==NULL )
            {
                SetLastError( ERROR_ACCESS_DENIED );
                fSt = FALSE;
                break;
            }

            if ( (pszA1 = LocalAlloc( LMEM_FIXED,
                                      strlen(aValueTable[MD5_AUTH_REALM]) + 1
                                      + strlen(pchUserName) + 1
                                      + strlen(pchPassword)
                                      + 1 + SIZE_MD5_DIGEST)) == NULL )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                fSt = FALSE;
                break;
            }
            strcpy( pszA1, pchUserName );
            strcat( pszA1, ":" );
            strcat( pszA1, aValueTable[MD5_AUTH_REALM] );
            strcat( pszA1, ":" );
            if ( fNtDigest )
            {
                UnicodePassword.MaximumLength = (strlen(pchPassword)+1);
                UnicodePassword.Buffer = LocalAlloc( LMEM_FIXED, UnicodePassword.MaximumLength*sizeof(WCHAR));
                if ( UnicodePassword.Buffer == NULL )
                {
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    fSt = FALSE;
                    break;
                }
                UnicodePassword.Length = MultiByteToWideChar( CP_ACP, 
                                     0, 
                                     pchPassword, 
                                     strlen(pchPassword), 
                                     UnicodePassword.Buffer, 
                                     UnicodePassword.MaximumLength ) * sizeof(WCHAR);
                RtlCalculateNtOwfPassword(
                    & UnicodePassword,
                    & PasswordHash );
                ToHex( (LPBYTE)&PasswordHash, sizeof(PasswordHash), pszA1+strlen(pszA1) );

                LocalFree( UnicodePassword.Buffer );
            }
            else
            {
                strcat( pszA1, pchPassword );
            }
            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)pszA1, strlen(pszA1) );
            MD5Final( &md5 );
            ToHex( md5.digest, sizeof(md5.digest), pszA1 );

            if ( (pszA2 = LocalAlloc( LMEM_FIXED,
                                      strlen(pchMethod) + 1
                                      + strlen(pchUri)
                                      + 1 + SIZE_MD5_DIGEST)) == NULL )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                fSt = FALSE;
                break;
            }
            strcpy( pszA2, pchMethod );
            strcat( pszA2, ":" );
            strcat( pszA2, pchUri );
            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)pszA2, strlen(pszA2) );
            MD5Final( &md5 );
            ToHex( md5.digest, sizeof(md5.digest), pszA2 );

            if ( (pszH = LocalAlloc( LMEM_FIXED,
                                     strlen(pszA1) + 1
                                     + strlen(aValueTable[MD5_AUTH_NONCE])
                                     + 1 + strlen(pszA2) + 1
                                     + SIZE_MD5_DIGEST)) == NULL )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                fSt = FALSE;
                break;
            }
            strcpy( pszH, pszA1 );
            strcat( pszH, ":" );
            strcat( pszH, aValueTable[MD5_AUTH_NONCE] );
            strcat( pszH, ":" );
            strcat( pszH, pszA2 );
            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)pszH, strlen(pszH) );
            MD5Final( &md5 );
            ToHex( md5.digest, sizeof(md5.digest), pszH );

            wsprintf( pch,
                      "Authorization: %sDigest username=\"%s\","
                      " realm=\"%s\","
                      " nonce=\"%s\","
                      " uri=\"%s\","
                      " response=\"%s\"",
                      fNtDigest ? "NT-" : "",
                      pchUserName,
                      aValueTable[MD5_AUTH_REALM],
                      aValueTable[MD5_AUTH_NONCE],
                      pchUri,
                      pszH
                    );
            if ( aValueTable[MD5_AUTH_OPAQUE] )
            {
                wsprintf( pch+strlen(pch), ", opaque=\"%s\"",
                          aValueTable[MD5_AUTH_OPAQUE] );
            }
            strcat( pch, "\r\n" );

            LocalFree( pszA1 );
            LocalFree( pszA2 );
            LocalFree( pszH );

            g_fBasic = TRUE;
            break;
        }
        else
        {
            // SSPI package ( assuming methods list have been validated )

            if ( !g_fAuth )
            {
                if ( !AuthInit( &g_Auth ) )
                {
                    fSt = FALSE;
                    goto ex;
                }
            }
            else if ( pchAuthData == NULL || *pchAuthData == '\0' )
            {
                // no blob while in authentication sequence : it failed

                SetLastError( ERROR_ACCESS_DENIED );
                fSt = FALSE;
                break;
            }

            if ( !AuthConverse( &g_Auth,
                  (void *) pchAuthData,
                  0,
                  &buff,
                  &cbOut,
                  pfNeedMoreData,
                  pchSchemes,
                  pchUserName,
                  pchPassword ))
            {
                fSt = FALSE;
                goto ex;
            }

            strcat( pch, "Authorization: " );
            strcat( pch, pchSchemes );
            strcat( pch, " " );
            strcat( pch, (CHAR *) BufferQueryPtr( &buff ) );
            strcat( pch, "\r\n" );
            break;
        }

        pchSchemes += strlen(pchSchemes) + 1;
    }
ex:
    BufferTerminate( &buff );

    return fSt;
}


BOOL
AuthInit(
    AUTH_SEQ *pAS )
/*++

 Routine Description:

    Initialize a SSP authentication sequence

 Arguments:

    None

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    pAS->_fNewConversation = TRUE;
    pAS->_fHaveCredHandle = FALSE;
    pAS->_fHaveCtxtHandle = FALSE;
    pAS->_fUUEncodeData = TRUE;

    g_fAuth = TRUE;

    return TRUE;
}


void
AuthTerminate(
    AUTH_SEQ *pAS )
/*++

 Routine Description:

    Terminate a SSP authentication sequence

 Arguments:

    None

 Return Value:

    None

--*/
{
    if ( pAS->_fHaveCredHandle )
        sfProcs.pFreeCredentialsHandle( &pAS->_hcred );

    pAS->_fHaveCredHandle = FALSE;
    pAS->_fHaveCtxtHandle = FALSE;
}


BOOL
AuthConverse(
    AUTH_SEQ *pAS,
    VOID   * pBuffIn,
    DWORD    cbBuffIn,
    BUFFER * pbuffOut,
    DWORD  * pcbBuffOut,
    BOOL   * pfNeedMoreData,
    CHAR   * pszPackage,
    CHAR   * pszUser,
    CHAR   * pszPassword
    )
/*++

Routine Description:

    Initiates or continues a previously initiated authentication conversation

    Client calls this first to get the negotiation message which
    it then sends to the server.  The server calls this with the
    client result and sends back the result.  The conversation
    continues until *pfNeedMoreData is FALSE.

    On the first call, pszPackage must point to the zero terminated
    authentication package name to be used and pszUser and pszPassword
    should point to the user name and password to authenticated with
    on the client side (server side will always be NULL).

Arguments:

    pBuffIn - Points to SSP message received from the
        client.  If UUENCODE is used, then this must point to a
        zero terminated uuencoded string (except for the first call).
    cbBuffIn - Number of bytes in pBuffIn or zero if pBuffIn points to a
        zero terminated, uuencoded string.
    pbuffOut - If *pfDone is not set to TRUE, this buffer contains the data
        that should be sent to the other side.  If this is zero, then no
        data needs to be sent.
    pcbBuffOut - Number of bytes in pbuffOut
    pfNeedMoreData - Set to TRUE while this side of the conversation is
        expecting more data from the remote side.
    pszPackage - On the first call points to a zero terminate string indicating
        the security package to use
    pszUser - Specifies user or domain\user the first time the client calls
        this method (client side only)
    pszPassword - Specifies the password for pszUser the first time the
        client calls this method (client side only)

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError).  Access is
    denied if FALSE is returned and GetLastError is ERROR_ACCESS_DENIED.

--*/
{
    SECURITY_STATUS       ss;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    SecBufferDesc         InBuffDesc;
    SecBuffer             InSecBuff;
    ULONG                 ContextAttributes;
    BUFFER                buffData;
    BUFFER                buff;
    BOOL                  fSt;
    BOOL                  fReply;

    BufferInit( &buffData );
    BufferInit( &buff );

    //
    //  Decode the data if there's something to decode
    //

    if ( pAS->_fUUEncodeData && pBuffIn )
    {
        if ( !uudecode( (CHAR *) pBuffIn,
                        &buffData,
                        &cbBuffIn ))
        {
            fSt = FALSE;
            goto ex;
        }

        pBuffIn = BufferQueryPtr( &buffData );
    }

    //
    //  If this is a new conversation, then we need to get the credential
    //  handle and find out the maximum token size
    //

    if ( pAS->_fNewConversation )
    {
        SecPkgInfo *              pspkg;
        SEC_WINNT_AUTH_IDENTITY   AuthIdentity;
        SEC_WINNT_AUTH_IDENTITY * pAuthIdentity;
        CHAR *                    pszDomain = NULL;
        CHAR                      szDomainAndUser[DNLEN+UNLEN+2];


        //
        //  fill out the authentication information
        //

        if ( ((pszUser != NULL) ||
              (pszPassword != NULL)) )
        {
            pAuthIdentity = &AuthIdentity;

            //
            //  Break out the domain from the username if one was specified
            //

            if ( pszUser != NULL )
            {
                strcpy( szDomainAndUser, pszUser );
                if ( !CrackUserAndDomain( szDomainAndUser,
                                          &pszUser,
                                          &pszDomain ))
                {
                    return FALSE;
                }
            }

            memset( &AuthIdentity,
                    0,
                    sizeof( AuthIdentity ));

            if ( pszUser != NULL )
            {
                AuthIdentity.User       = (unsigned char *) pszUser;
                AuthIdentity.UserLength = strlen( pszUser );
            }

            if ( pszPassword != NULL )
            {
                AuthIdentity.Password       = (unsigned char *) pszPassword;
                AuthIdentity.PasswordLength = strlen( pszPassword );
            }

            if ( pszDomain != NULL )
            {
                AuthIdentity.Domain       = (unsigned char *) pszDomain;
                AuthIdentity.DomainLength = strlen( pszDomain );
            }

            AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
        }
        else
        {
            pAuthIdentity = NULL;
        }

        ss = sfProcs.pAcquireCredentialsHandle( NULL,    // New principal
                                       pszPackage,       // Package name
                                       SECPKG_CRED_OUTBOUND,
                                       NULL,             // Logon ID
                                       pAuthIdentity,    // Auth Data
                                       NULL,             // Get key func
                                       NULL,             // Get key arg
                                       &pAS->_hcred,
                                       &Lifetime );

        //
        //  Need to determine the max token size for this package
        //

        if ( ss == STATUS_SUCCESS )
        {
            pAS->_fHaveCredHandle = TRUE;
            ss = sfProcs.pQuerySecurityPackageInfo(
                        (char *) pszPackage,
                        &pspkg );
        }

        if ( ss != STATUS_SUCCESS )
        {
            SetLastError( ss );
            return FALSE;
        }

        pAS->_cbMaxToken = pspkg->cbMaxToken;

        sfProcs.pFreeContextBuffer( pspkg );

    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //

    if ( !BufferResize( &buff, pAS->_cbMaxToken ))
    {
        fSt = FALSE;
        goto ex;
    }

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = pAS->_cbMaxToken;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = BufferQueryPtr( &buff );

    //
    //  Prepare our Input buffer - Note the server is expecting the client's
    //  negotiation packet on the first call
    //

    if ( pBuffIn )
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers  = 1;
        InBuffDesc.pBuffers  = &InSecBuff;

        InSecBuff.cbBuffer   = cbBuffIn;
        InSecBuff.BufferType = SECBUFFER_TOKEN;
        InSecBuff.pvBuffer   = pBuffIn;
    }

    {
        //
        //  will return success when its done but we still
        //  need to send the out buffer if there are bytes to send
        //

        ss = sfProcs.pInitializeSecurityContext(
                                        &pAS->_hcred,
                                        pAS->_fNewConversation ? NULL :
                                                &pAS->_hctxt,
                                        TOKEN_SOURCE_NAME,
                                        0,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        pAS->_fNewConversation ? NULL :
                                                &InBuffDesc,
                                        0,
                                        &pAS->_hctxt,
                                        &OutBuffDesc,
                                        &ContextAttributes,
                                        &Lifetime );
    }

    if ( !SEC_SUCCESS( ss ) )
    {
        if ( ss == SEC_E_LOGON_DENIED )
            ss = ERROR_LOGON_FAILURE;

        SetLastError( ss );
        fSt = FALSE;
        goto ex;
    }

    pAS->_fHaveCtxtHandle = TRUE;

    //
    //  Now we just need to complete the token (if requested) and prepare
    //  it for shipping to the other side if needed
    //

    fReply = !!OutSecBuff.cbBuffer;

    if ( (ss == SEC_I_COMPLETE_NEEDED) ||
         (ss == SEC_I_COMPLETE_AND_CONTINUE) )
    {
        if ( sfProcs.pCompleteAuthToken != NULL )
        {
            ss = sfProcs.pCompleteAuthToken( &pAS->_hctxt,
                                    &OutBuffDesc );

            if ( !SEC_SUCCESS( ss ))
            {
                fSt = FALSE;
                goto ex;
            }
        }
        else
        {
            // if not supported

            fSt = FALSE;
            goto ex;
        }
    }

    //
    //  Format or copy to the output buffer if we need to reply
    //

    if ( fReply )
    {
        if ( pAS->_fUUEncodeData )
        {
            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer,
                            OutSecBuff.cbBuffer,
                            pbuffOut ))
            {
                fSt = FALSE;
                goto ex;
            }

            *pcbBuffOut = strlen( (CHAR *) BufferQueryPtr(pbuffOut) );
        }
        else
        {
            if ( !BufferResize( pbuffOut, OutSecBuff.cbBuffer ))
            {
                fSt = FALSE;
                goto ex;
            }

            memcpy( BufferQueryPtr(pbuffOut),
                    OutSecBuff.pvBuffer,
                    OutSecBuff.cbBuffer );

            *pcbBuffOut = OutSecBuff.cbBuffer;
        }
    }

    if ( pAS->_fNewConversation )
        pAS->_fNewConversation = FALSE;

    *pfNeedMoreData = ((ss == SEC_I_CONTINUE_NEEDED) ||
                       (ss == SEC_I_COMPLETE_AND_CONTINUE));

    fSt = TRUE;

ex:
    BufferTerminate( &buffData );
    BufferTerminate( &buff );

    return fSt;
}


BOOL CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    )
/*++

Routine Description:

    Given a user name potentially in the form domain\user, zero terminates
    the domain name and returns pointers to the domain name and the user name

Arguments:

    pszDomainAndUser - Pointer to user name or domain and user name
    ppszUser - Receives pointer to user portion of name
    ppszDomain - Receives pointer to domain portion of name

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    static CHAR szDefaultDomain[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cbN;

    //
    //  Crack the name into domain/user components.
    //

    *ppszDomain = pszDomainAndUser;
    *ppszUser   = strpbrk( pszDomainAndUser, "/\\" );

    if( *ppszUser == NULL )
    {
        //
        //  No domain name specified, just the username so we assume the
        //  user is on the local machine
        //

        if ( !*szDefaultDomain )
        {
            cbN = sizeof(szDefaultDomain);
            GetComputerName( szDefaultDomain, &cbN );
        }

        *ppszDomain = szDefaultDomain;
        *ppszUser   = pszDomainAndUser;
    }
    else
    {
        //
        //  Both domain & user specified, skip delimiter.
        //

        **ppszUser = '\0';
        (*ppszUser)++;

        if( ( **ppszUser == '\0' ) ||
            ( **ppszUser == '\\' ) ||
            ( **ppszUser == '/' ) )
        {
            //
            //  Name is of one of the following (invalid) forms:
            //
            //      "domain\"
            //      "domain\\..."
            //      "domain/..."
            //

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    return TRUE;
}


/************************************************************
 *    uuencode/decode functions
 ************************************************************/

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


BOOL
uudecode(
    char   * bufcoded,
    BUFFER * pbuffdecoded,
    DWORD  * pcbDecoded )
/*++

 Routine Description:

    uudecode a string of data

 Arguments:

    bufcoded            pointer to uuencoded data
    pbuffdecoded        pointer to output BUFFER structure
    pcbDecoded          number of decode bytes

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = bufin - bufcoded - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !BufferResize( pbuffdecoded, nbytesdecoded + 4 ))
        return FALSE;

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    bufout = (unsigned char *) BufferQueryPtr(pbuffdecoded);

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)BufferQueryPtr(pbuffdecoded))[nbytesdecoded] = '\0';

    return TRUE;
}


BOOL
uuencode(
    BYTE *   bufin,
    DWORD    nbytes,
    BUFFER * pbuffEncoded )
/*++

 Routine Description:

    uuencode a string of data

 Arguments:

    bufin           pointer to data to encode
    nbytes          number of bytes to encode
    pbuffEncoded    pointer to output BUFFER structure

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
   unsigned char *outptr;
   unsigned int i;

   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !BufferResize( pbuffEncoded, nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) BufferQueryPtr(pbuffEncoded);

   for (i=0; i<nbytes; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   /* If nbytes was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
   if(i == nbytes+1) {
      /* There were only 2 bytes in that last group */
      outptr[-1] = '=';
   } else if(i == nbytes+2) {
      /* There was only 1 byte in that last group */
      outptr[-1] = '=';
      outptr[-2] = '=';
   }

   *outptr = '\0';

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\httpauth\proto.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    proto.h

Abstract:

    prototypes

Author:

    Sam Patton (sampa) 28-Nov-1995

Environment:

    Internet

Revision History:

    dd-mmm-yyy <email>

--*/

BOOL
HttpGetSocket(
    char * Verb,
    char * Server,
    char * URL,
    BOOL   DisplayHeaders,
    DWORD  ClientDataSize,
    PSTR   pszUserName,
    PSTR   pszPassword,
    PSTR   pszStore,
    PSTR   pszPref );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\httpauth\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved



#include <nt.h>
#define UINT4   ULONG

#include "md5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#if CT_COMPILER == CT_MPW

/* MPW doesn't compile the macro correctly, so use a procedure. */
static UINT4 RotateLeft (UINT4, unsigned int);
#define ROTATE_LEFT RotateLeft

#else
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#endif

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

#if CT_COMPILER == CT_MPW
static UINT4 RotateLeft (x, n)
UINT4 x;
unsigned int n;
{
  return (((x) << (n)) | ((x) >> (32-(n))));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\httpauth\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
} MD5_CTX;

#define MD5_LEN 16

#define PROTO_LIST(list)    list


void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((MD5_CTX *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\httpauth\httpauth.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    httpauth.h

Abstract:

    Functions for authentication sequence ( Basic & NTLM )

Author:

    Philipe Choquier    15-Feb-1996


Revision History:

--*/

BOOL AddAuthorizationHeader(PSTR pch, PSTR pchSchemes, PSTR pchAuthData, PSTR pchMethod, PSTR pchUri, PSTR pchUserName, PSTR pchPassword, BOOL *pfNeedMoreData );
BOOL InitAuthorizationHeader();
void TerminateAuthorizationHeader();
BOOL IsInAuthorizationSequence();
BOOL ValidateAuthenticationMethods( PSTR pszMet, PSTR pszPref );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\iisamap\iisamap.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    iismeta.cxx

Abstract:

    Test for Mapper DLL list management

Author:

    Philippe Choquier (phillich)    03-july-1996

--*/

#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <wincrypt.h>
#include    <xbf.hxx>
#include    <immd5.h>
#include    <iismap.hxx>
#include    <iiscmr.hxx>

#define DBL_CHAR_CMD(a,b) (((a)<<8)|(b))
#define AscToHex(a) ( (a)>='a' ? ((a)-'a'+10) : ((a)>='A' ? (a)-'A'+10 : (a)-'0') )

char HEXTOA[] = "0123456789abcdef";

typedef struct _BinaryObject {
    LPBYTE  pB;
    UINT    cB;
} BinaryObject;

class UnivMap {
public:
    BOOL Init( CIisAcctMapper *pM ) { pMap = pM; BOOL f; return pMap->Unserialize(); }
    BOOL Load() {  return pMap->Load(); }
    BOOL Terminate() { return TRUE; }
    BOOL Save() { return pMap->Save() && pMap->Serialize(); }
    BOOL List();
    BOOL LocateBase( LPSTR*, DWORD );
    //
    //CIisMapping* CreateNewMapping() { return pMap->CreateNewMapping(); }
    virtual BOOL Map( LPSTR* ) { return FALSE; }
    virtual BOOL Add( LPSTR* ) { return FALSE; }
    virtual BOOL AddBinary( BinaryObject*, UINT ) { return FALSE; }
    virtual BOOL Locate( LPSTR* ) { return FALSE; }
    virtual BOOL IsBinary() { return FALSE; }
    virtual BOOL IsBinary( DWORD ) { return FALSE; }
    virtual LPSTR SubjectFieldDisplay() { return FALSE; }
    virtual BOOL SubjectFieldSet( LPSTR ) { return FALSE; }
    virtual LPSTR DomainDisplay() { return FALSE; }
    virtual BOOL DomainSet( LPSTR ) { return FALSE; }
    BOOL ListCurrent();
    BOOL DeleteCurrent() { return m_iCurrent == 0xffffffff ? FALSE : pMap->Delete( m_iCurrent ); }
    BOOL SetCurrent( DWORD dwC ) 
        { if ( dwC < pMap->GetNbMapping() ) 
            {m_iCurrent = dwC; return TRUE;} 
          else {return FALSE;} }
protected:
    CIisAcctMapper *pMap;
    CIisMapping *pMapping;
    DWORD m_iCurrent;
} ;


class CertMap : public UnivMap {
public:
    BOOL IsBinary() { return FALSE; }
    BOOL Map( LPSTR* );
    BOOL Add( LPSTR* );
    BOOL Locate( LPSTR* pF ) { return LocateBase( pF, IISMDB_INDEX_NB ); }
} ;


class Cert11Map : public UnivMap {
public:
    BOOL IsBinary() { return TRUE; }
    BOOL Map( LPSTR* );
    BOOL Add( LPSTR* );
    BOOL AddBinary( BinaryObject*, UINT );
    BOOL Locate( LPSTR* pF ) 
        { return LocateBase( pF, IISMDB_INDEX_CERT11_NB ); }
    BOOL IsBinary( DWORD i ) 
        { return i != IISMDB_INDEX_CERT11_NT_ACCT; }
    LPSTR SubjectFieldDisplay() 
        { return ((CIisCert11Mapper*)pMap)->GetSubjectSource(); }
    BOOL SubjectFieldSet( LPSTR psz )  
        { return ((CIisCert11Mapper*)pMap)->SetSubjectSource(psz); }
    LPSTR DomainDisplay() 
        { return ((CIisCert11Mapper*)pMap)->GetDefaultDomain(); }
    BOOL DomainSet( LPSTR psz ) 
        { return ((CIisCert11Mapper*)pMap)->SetDefaultDomain(psz); }
} ;


class ItaMap : public UnivMap {
public:
    BOOL IsBinary() { return FALSE; }
    BOOL Map( LPSTR* );
    BOOL Add( LPSTR* );
    BOOL Locate( LPSTR* pF ) { return LocateBase( pF, IISIMDB_INDEX_NB ); }
} ;


class Md5Map : public UnivMap {
public:
    BOOL IsBinary() { return FALSE; }
    BOOL Map( LPSTR* );
    BOOL Add( LPSTR* );
    BOOL Locate( LPSTR* pF ) { return LocateBase( pF, IISMMDB_INDEX_NB ); }
};


BOOL
UnivMap::List(
    VOID
    )
{
    DWORD i;
    DWORD iM = pMap->GetNbMapping();

    for ( i = 0 ; i < iM ; ++i )
    {
        m_iCurrent = i;
        ListCurrent();
    }

    return TRUE;
}


BOOL
UnivMap::ListCurrent(
    VOID
    )
{
    DWORD i;
    CIisMapping *pI;
    DWORD cF;
    IISMDB_Fields *pFi;


    if ( m_iCurrent == 0xffffffff )
    {
        return FALSE;
    }

    printf( "%5d: ", m_iCurrent + 1 );

    pMap->MappingGetFieldList( &pFi, &cF );

    if ( pMap->GetMapping( m_iCurrent, &pI ) )
    {
        for ( DWORD i = 0 ; i < cF ; ++i )
        {
            LPSTR   pS;
            DWORD   dwS;
            LPSTR   pAllocS = NULL;
            UINT    x;

            if ( IsBinary() )
            {
#if defined(DISPLAY_UUENCODED )

                pI->MappingGetField( i, &pS, &dwS, IsBinary(i) );
                if ( IsBinary(i) 
                     && dwS == sizeof("Kj==")-1 
                     && !memcmp( pS, "Kj==", sizeof("Kj==")-1 ) )
                {
                    pS = "*";
                    dwS = 1;
                }
#else

                pI->MappingGetField( i, &pS, &dwS, FALSE );
                if ( IsBinary(i) )
                {
                    pAllocS = (LPSTR)LocalAlloc( LMEM_FIXED, dwS*2 );
                    for ( x = 0 ; x < dwS ; ++x )
                    {
                        pAllocS[x*2] = HEXTOA[ ((LPBYTE)pS)[x]>>4 ];
                        pAllocS[x*2+1] = HEXTOA[ ((LPBYTE)pS)[x] & 0x0f ];
                    }
                    dwS *= 2;
                    pS = pAllocS;
                }

#endif
                printf( "%*.*s%s", dwS, dwS, pS, i==cF-1 ? "\n" : ", " );
                if ( pAllocS != NULL )
                {
                    LocalFree( pAllocS );
                    pAllocS = NULL;
                }
            }
            else
            {
                pI->MappingGetField( i, &pS );
                printf( "%s%s", pS, i==cF-1 ? "\n" : ", " );
            }
        }
    }

    return TRUE;
}



BOOL 
UnivMap::LocateBase(
    LPSTR* pF,
    DWORD cF
    )
{
    DWORD i;
    DWORD iM = pMap->GetNbMapping();
    CIisMapping *pI;

    if ( pMapping = pMap->CreateNewMapping() )
    {
        for ( i = 0 ; i < cF ; ++i )
        {
            if ( pF[i] == NULL )
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                pMap->DeleteMappingObject( pMapping );
                return FALSE;
            }
            pMapping->MappingSetField( i, pF[i] );
        }

        for ( i = 0 ; i < iM ; ++i )
        {
            if ( pMap->GetMapping( i, &pI ) )
            {
                DWORD iF;
                for ( iF = 0 ; iF < cF ; ++iF )
                {
                    LPSTR pS1;
                    LPSTR pS2;
                    pMapping->MappingGetField( iF, &pS1 );
                    pI->MappingGetField( iF, &pS2 );
                    if ( strcmp( pS1, pS2 ) )
                    {
                        break;
                    }
                }
                if ( iF == cF )
                {
                    m_iCurrent = i;
                    pMap->DeleteMappingObject( pMapping );
                    return TRUE;
                }
            }
        }
        pMap->DeleteMappingObject( pMapping );
    }

    return FALSE;
}


BOOL 
CertMap::Map( 
    LPSTR* pF 
    )
{
    BOOL fSt = FALSE;
    CIisMapping* pMi;

    if ( !pF[0] || !pF[1] || !pF[2] || !pF[3] || !pF[4] || !pF[5] || !pF[6] )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
        pMapping->MappingSetField( IISMDB_INDEX_ISSUER_O, pF[0] );
        pMapping->MappingSetField( IISMDB_INDEX_ISSUER_OU, pF[1] );
        pMapping->MappingSetField( IISMDB_INDEX_ISSUER_C, pF[2] );
        pMapping->MappingSetField( IISMDB_INDEX_SUBJECT_O, pF[3] );
        pMapping->MappingSetField( IISMDB_INDEX_SUBJECT_OU, pF[4] );
        pMapping->MappingSetField( IISMDB_INDEX_SUBJECT_C, pF[5] );
        pMapping->MappingSetField( IISMDB_INDEX_SUBJECT_CN, pF[6] );

        m_iCurrent = 0xffffffff;
        fSt = pMap->FindMatch( pMapping, &pMi, &m_iCurrent );
        pMap->DeleteMappingObject( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


BOOL
CertMap::Add( 
    LPSTR* pF 
    )
{
    BOOL fSt = FALSE;

    if ( !pF[0] || !pF[1] || !pF[2] || !pF[3] || !pF[4] || !pF[5] || !pF[6] || !pF[7] )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
        pMapping->MappingSetField( IISMDB_INDEX_ISSUER_O, pF[0] );
        pMapping->MappingSetField( IISMDB_INDEX_ISSUER_OU, pF[1] );
        pMapping->MappingSetField( IISMDB_INDEX_ISSUER_C, pF[2] );
        pMapping->MappingSetField( IISMDB_INDEX_SUBJECT_O, pF[3] );
        pMapping->MappingSetField( IISMDB_INDEX_SUBJECT_OU, pF[4] );
        pMapping->MappingSetField( IISMDB_INDEX_SUBJECT_C, pF[5] );
        pMapping->MappingSetField( IISMDB_INDEX_SUBJECT_CN, pF[6] );
        pMapping->MappingSetField( IISMDB_INDEX_NT_ACCT, pF[7] );

        fSt = pMap->Add( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


BOOL 
Cert11Map::Map( 
    LPSTR* pF 
    )
{
    BOOL fSt = FALSE;
    CIisMapping* pMi;

    if ( !pF[0] 
#if !defined(CERT11_FULL_CERT)
         || !pF[1] 
#endif
       )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
#if defined(CERT11_FULL_CERT)
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_CERT, pF[0], strlen(pF[0]), TRUE );
#else
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_SUBJECT, pF[0], strlen(pF[0]), TRUE );
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_ISSUER, pF[1], strlen(pF[1]), TRUE );
#endif
        m_iCurrent = 0xffffffff;
        fSt = pMap->FindMatch( pMapping, &pMi, &m_iCurrent );
        pMap->DeleteMappingObject( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


BOOL
Cert11Map::Add( 
    LPSTR* pF 
    )
{
    BOOL fSt = FALSE;

    if ( !pF[0] || !pF[1] 
#if !defined(CERT11_FULL_CERT)
         || !pF[2] 
#endif
       )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
#if defined(CERT11_FULL_CERT)
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_CERT, pF[0], strlen(pF[0]), TRUE );
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_NT_ACCT, pF[1], strlen(pF[1]), FALSE );
#else
        // if subject is '*' store it as is ( it is not uuencoded )
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_SUBJECT, 
                                   pF[0], 
                                   strlen(pF[0]), 
                                   strcmp( pF[0], "*") ? TRUE : FALSE );

        pMapping->MappingSetField( IISMDB_INDEX_CERT11_ISSUER, pF[1], strlen(pF[1]), TRUE );
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_NT_ACCT, pF[2], strlen(pF[2]), FALSE );
#endif

        fSt = pMap->Add( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


BOOL
Cert11Map::AddBinary( 
    BinaryObject* pF,
    UINT          cF
    )
{
    BOOL fSt = FALSE;

    if ( cF != 2 )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_CERT, (LPSTR)pF[0].pB, pF[0].cB, FALSE );
        pMapping->MappingSetField( IISMDB_INDEX_CERT11_NT_ACCT, (LPSTR)pF[1].pB, pF[1].cB, FALSE );

        fSt = pMap->Add( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


BOOL 
Md5Map::Map( 
    LPSTR* pF 
    )
{
    BOOL fSt = FALSE;
    CIisMapping* pMi;

    if ( !pF[0] || !pF[1] )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
        pMapping->MappingSetField( IISMMDB_INDEX_IT_REALM, pF[0] );
        pMapping->MappingSetField( IISMMDB_INDEX_IT_ACCT, pF[1] );

        m_iCurrent = 0xffffffff;
        fSt = pMap->FindMatch( pMapping, &pMi, &m_iCurrent );
        pMap->DeleteMappingObject( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


BOOL 
Md5Map::Add( 
    LPSTR* pF 
    )
{
    BOOL fSt = FALSE;

    if ( !pF[0] || !pF[1] || !pF[2] || !pF[3] )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
        pMapping->MappingSetField( IISMMDB_INDEX_IT_REALM, pF[0] );
        pMapping->MappingSetField( IISMMDB_INDEX_IT_ACCT, pF[1] );
        pMapping->MappingSetField( IISMMDB_INDEX_IT_MD5PWD, pF[2] );
        pMapping->MappingSetField( IISMMDB_INDEX_NT_ACCT, pF[3] );

        fSt = pMap->Add( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


BOOL 
ItaMap::Map( 
    LPSTR* pF 
    )
{
    BOOL fSt = FALSE;
    CIisMapping* pMi;

    if ( !pF[0] || !pF[1] )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
        pMapping->MappingSetField( IISIMDB_INDEX_IT_ACCT, pF[0] );
        pMapping->MappingSetField( IISIMDB_INDEX_IT_PWD, pF[1] );

        m_iCurrent = 0xffffffff;
        fSt = pMap->FindMatch( pMapping, &pMi, &m_iCurrent );
        pMap->DeleteMappingObject( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


BOOL 
ItaMap::Add( 
    LPSTR* pF 
    )
{
    BOOL fSt = FALSE;

    if ( !pF[0] || !pF[1] || !pF[2] )
    {
        return FALSE;
    }

    if ( pMapping = pMap->CreateNewMapping() )
    {
        pMapping->MappingSetField( IISIMDB_INDEX_IT_ACCT, pF[0] );
        pMapping->MappingSetField( IISIMDB_INDEX_IT_PWD, pF[1] );
        pMapping->MappingSetField( IISIMDB_INDEX_NT_ACCT, pF[2] );

        fSt = pMap->Add( pMapping );
        pMapping = NULL;
    }

    return fSt;
}


CIisCertMapper      mpCert;
CIisCert11Mapper    mpCert11;
CIisItaMapper       mpIta;
CIisMd5Mapper       mpMd5;

CertMap             umCert;
Cert11Map           umCert11;
ItaMap              umIta;
Md5Map              umMd5;

#if 0
CIssuerStore        isIssuers1;
CIssuerStore        isIssuers2;
CIisRuleMapper      irmRules1;
CIisRuleMapper      irmRules2;
CStoreXBF           ser(1024);


BYTE RuleElem1[] = "\x1" "VeriSign";
BYTE RuleElem2[] = "\x2" "VeriSign";


void
testcmr(
    VOID
    )
{
    DWORD           dwI;
    CCertMapRule    *pR;
    LPBYTE          pContent;
    DWORD           cContent;
    LPSTR           pID;
    LPSTR           pMatch;
    LPBYTE          pBin;
    DWORD           dwBin;

    isIssuers1.LoadServerAcceptedIssuers();
    isIssuers1.Serialize( &ser );
    isIssuers2.Unserialize( &ser );

    isIssuers2.GetIssuer( 2, &pID, &pContent, &cContent );
    isIssuers2.GetIssuerByName( pID, &pContent, &cContent );

    // 1st rule
    
    dwI = irmRules1.AddRule();
    pR = irmRules1.GetRule( dwI );
    printf( "%d\n", irmRules1.GetRuleCount() );

    pR->SetRuleName( "Rule1" );
    pR->SetRuleAccount( "Account" );
    pR->SetRuleDenyAccess( FALSE );
    pR->SetRuleEnabled( TRUE );
    pR->AddRuleElem( 0xffffffff, 
        CERT_FIELD_ISSUER, 
        irmRules1.MapSubFieldToAsn1( "OU" ),
        RuleElem1,
        sizeof(RuleElem1)-1 );
    pR->AddRuleElem( 0xffffffff, 
        CERT_FIELD_ISSUER, 
        irmRules1.MapSubFieldToAsn1( "O" ),
        RuleElem1,
        sizeof(RuleElem1)-1 );
    pR->DeleteRuleElem( 0 );
    pR->SetMatchAllIssuer( TRUE );

    ser.Clear();
    pR->Serialize( &ser );
    pR->Unserialize( &ser );

    // 2nd rule

    dwI = irmRules1.AddRule();
    pR = irmRules1.GetRule( dwI );
    pR->SetRuleName( "Rule2" );
    pR->SetRuleAccount( "Account2" );
    pR->SetRuleDenyAccess( FALSE );
    pR->SetRuleEnabled( TRUE );
    pR->AddRuleElem( 0xffffffff, 
        CERT_FIELD_ISSUER, 
        irmRules1.MapSubFieldToAsn1( "OU" ),
        RuleElem2,
        sizeof(RuleElem2)-1 );
    pR->AddRuleElem( 0xffffffff, 
        CERT_FIELD_ISSUER, 
        irmRules1.MapSubFieldToAsn1( "O" ),
        RuleElem2,
        sizeof(RuleElem2)-1 );
    pR->SetMatchAllIssuer( FALSE );
    pR->AddIssuerEntry( pID, TRUE );

    irmRules1.Save( "a" );
    irmRules2.Load( "a" );
    pR = irmRules2.GetRule( 1 );
    printf( "%s\n", pR->GetRuleName() );

    irmRules1.MatchRequestToBinary( "*first", &pBin, &dwBin );
    irmRules1.BinaryToMatchRequest( pBin, dwBin, &pMatch );
    irmRules1.FreeMatchConversion( pBin );
    irmRules1.FreeMatchConversion( pMatch );

    irmRules1.MatchRequestToBinary( "last*", &pBin, &dwBin );
    irmRules1.BinaryToMatchRequest( pBin, dwBin, &pMatch );
    irmRules1.FreeMatchConversion( pBin );
    irmRules1.FreeMatchConversion( pMatch );

    irmRules1.MatchRequestToBinary( "all", &pBin, &dwBin );
    irmRules1.BinaryToMatchRequest( pBin, dwBin, &pMatch );
    irmRules1.FreeMatchConversion( pBin );
    irmRules1.FreeMatchConversion( pMatch );

    irmRules1.MatchRequestToBinary( "*in*", &pBin, &dwBin );
    irmRules1.BinaryToMatchRequest( pBin, dwBin, &pMatch );
    irmRules1.FreeMatchConversion( pBin );
    irmRules1.FreeMatchConversion( pMatch );
}
#endif


BOOL
AddFromFile(
    CIisAcctMapper *pMap,
    UnivMap        *pU,
    LPSTR           pszFileName
    )
{
    FILE*           f;
    BinaryObject    bo[16];
    UINT            cBo;
    char            buf[8192];
    BOOL            fSt = FALSE;
    LPSTR           p;
    LPSTR           pN;
    LPSTR           pH;
    LPSTR           pDH;
    BOOL            fLast;

    if ( !(f = fopen( pszFileName, "r" )) )
    {
        return FALSE;
    }

    // build array of ptr to arg for Add

    for ( ; fgets( buf, sizeof(buf), f ) ; )
    {
        if ( p = strchr(buf,'\n') )
        {
            *p = '\0';
        }

        p = buf;

        if ( !_memicmp( p, "map ", sizeof("map ")-1 ) )
        {
            p += sizeof("map ")-1;
            cBo = 0;
            for ( ; *p ; )
            {
                if ( (pN = strchr( p, ' ' )) == NULL )
                {
                    pN = p + strlen( p );
                    fLast = TRUE;
                }
                else
                {
                    *pN = '\0';
                    fLast = FALSE;
                }

                if ( !_memicmp( p, "hex:", sizeof("hex:")-1 ) )
                {
                    pH = p + sizeof("hex:")-1;
                    pDH = p;
                    while ( pH+1 < pN )
                    {
                        *pDH++ = (AscToHex(pH[0])<<4) | AscToHex(pH[1]) ;
                        pH += 2;
                    }
                    bo[cBo].pB = (LPBYTE)p;
                    bo[cBo].cB = pDH - p;
                }
                else
                {
                    bo[cBo].pB = (LPBYTE)p;
                    bo[cBo].cB = pN - p;
                }
                ++cBo;

                if ( !fLast )
                {
                    p = pN + 1;
                }
                else
                {
                    break;
                }
            }

            if ( pU->AddBinary( bo, cBo ) )
            {
                fSt = TRUE;
                printf( "Certificate added\n" );
            }
            else
            {
                printf( "Error adding certificate\n" );
            }
        }
    }

    fclose( f );

    return fSt;
}


void 
Usage(
    VOID
    )
{
    printf( "Usage:\n"
//            "iisamap (md5|ita|cert|cert11)\n"
            "iisamap cert11\n"
            "        [-a map_info] : add mapping\n"
            "        [-d map_info] : delete mapping\n"
            "        [-D#]         : delete mapping\n"
//            "        [-e map_info] : check mapping exist\n"
//            "        [-m match_info] : display match\n"
            "        [-l] : list mappings\n"
            "        [-L#] : list mapping\n"
//            "        [-pfg : get subject field used as acct source (cert11 only)\n"
//            "        [-pfs field_name: set subject field used as acct source (cert11 only)\n"
//            "        [-pdg : get domain used in acct (cert11 only)\n"
//            "        [-pds domain: set domain used in acct  (cert11 only)\n"
          );
}


int __cdecl 
main( 
    int argc, 
    char*argv[] 
    )
{
    int             arg;
    int             cnt;
    CIisAcctMapper *pMap = NULL;
    UnivMap        *pU = NULL;
    BOOL            fUpdate = FALSE;
    LPSTR           pF;
    int             st = 0;

    if ( argc < 2 )
    {
        Usage();
        return 1;
    }

    for ( cnt = 0, arg = 1 ; arg < argc ; ++ arg )
    {
        if ( argv[arg][0] == '-' )
        {
            if ( pMap == NULL )
            {
                Usage();
                return 1;
            }

            switch ( argv[arg][1] )
            {
                case 'a':
                    if ( !pU->Add( argv+arg+1 ) )
                    {
                        printf( "Error adding mapping\n" );
                        st = 3;
                        goto ex;
                    }
                    fUpdate = TRUE;
                    break;

                case 'A':   // add from file
                    if ( !AddFromFile( pMap, pU, argv[arg]+2 ) )
                    {
                        st = 3;
                        goto ex;
                    }
                    fUpdate = TRUE;
                    break;

                case 'm':
                    if ( !pU->Map( argv+arg+1 ) )
                    {
                        printf( "Error locating mapping\n" );
                        st = 3;
                        goto ex;
                    }
                    pU->ListCurrent();
                    break;

                case 'd':
                    if ( !pU->Locate( argv+arg+1 ) )
                    {
                        printf( "Error locating mapping\n" );
                        st = 3;
                        goto ex;
                    }
                    if ( !pU->DeleteCurrent() )
                    {
                        printf( "Error deleting mapping\n" );
                        st = 3;
                        goto ex;
                    }
                    fUpdate = TRUE;
                    break;

                case 'D':
                    if ( !pU->SetCurrent( atoi((LPCTSTR)(argv[arg]+2))-1 ) )
                    {
                        printf( "Error accessing mapping %d\n", atoi((LPCTSTR)(argv+arg+1)) );
                        st = 3;
                        goto ex;
                    }
                    if ( !pU->DeleteCurrent() )
                    {
                        printf( "Error deleting mapping\n" );
                        st = 3;
                        goto ex;
                    }
                    fUpdate = TRUE;
                    break;

                case 'e':
                    if ( !pU->Locate( argv+arg+1 ) )
                    {
                        printf( "Error locating mapping\n" );
                        st = 3;
                        goto ex;
                    }
                    if ( !pU->ListCurrent() )
                    {
                        printf( "Error listing mapping\n" );
                        st = 3;
                        goto ex;
                    }
                    break;

                case 'l':
                    pU->List();
                    break;

                case 'L':
                    if ( !pU->SetCurrent( atoi((LPCTSTR)(argv[arg]+2))-1 ) )
                    {
                        printf( "Error accessing mapping %d\n", atoi((LPCTSTR)(argv[arg]+2)) );
                        st = 3;
                        goto ex;
                    }
                    if ( !pU->ListCurrent() )
                    {
                        printf( "Error listing mapping\n" );
                        st = 3;
                        goto ex;
                    }
                    break;

                case 'p':
                    switch( DBL_CHAR_CMD( argv[arg][2], argv[arg][3]) )
                    {
                        case DBL_CHAR_CMD( 'f', 'g' ):
                            if ( !(pF = pU->SubjectFieldDisplay()) )
                            {
                                printf( "Error accessing subject field\n" );
                                st = 3;
                                goto ex;
                            }
                            printf( "Subject field : %s\b", pF );
                            break;

                        case DBL_CHAR_CMD( 'f', 's' ):
                            if ( !pU->SubjectFieldSet( argv[++arg] ) )
                            {
                                printf( "Error setting subject field\n" );
                                st = 3;
                                goto ex;
                            }
                            fUpdate = TRUE;
                            break;

                        case DBL_CHAR_CMD( 'd', 'g' ):
                            if ( !(pF = pU->DomainDisplay()) )
                            {
                                printf( "Error accessing domain\n" );
                                st = 3;
                                goto ex;
                            }
                            printf( "Domain : %s\b", pF );
                            break;

                        case DBL_CHAR_CMD( 'd', 's' ):
                            if ( !pU->DomainSet( argv[++arg] ) )
                            {
                                printf( "Error setting domain\n" );
                                st = 3;
                                goto ex;
                            }
                            fUpdate = TRUE;
                            break;

                        default:
                            Usage();
                            st = 1;
                            goto ex;
                    }
                    break;

                default:
                    Usage();
                    st = 1;
                    goto ex;
            }
            if ( fUpdate )
            {
                if ( !pU->Save() )
                {
                    printf( "Can't save mappings\n" );
                }
            }
            break;
        }
        else 
        {
            switch ( cnt )
            {
                case 0:
                    if ( !_stricmp( argv[arg], "md5" ) )
                    {
                        pMap = (CIisAcctMapper*)&mpMd5;
                        pU = (UnivMap*)&umMd5;
                    }
                    else if ( !_stricmp( argv[arg], "ita" ) )
                    {
                        pMap = (CIisAcctMapper*)&mpIta;
                        pU = (UnivMap*)&umIta;
                    }
                    else if ( !_stricmp( argv[arg], "cert" ) )
                    {
                        pMap = (CIisAcctMapper*)&mpCert;
                        pU = (UnivMap*)&umCert;
                    }
                    else if ( !_stricmp( argv[arg], "cert11" ) )
                    {
                        pMap = (CIisAcctMapper*)&mpCert11;
                        pU = (UnivMap*)&umCert11;
                    }
                    break;
            }

            if ( !pU->Init( pMap ) )
            {
                printf( "Can't initialize mapper\n" );
                pU = NULL;
                return 2;
            }

            if ( !pU->Load() )
            {
                printf( "Failed to load mappings: mappings erased\n" );
            }
            ++cnt;
        }
    }

ex:
    if ( pU != NULL )
    {
        pU->Terminate();
    }

    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\test\w3t.c ===
/*****************************************************************************

    w3t.c

*****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <lm.h>
#include <inetcom.h>
#include <iisinfo.h>
#include <lmapibuf.h>



/*****************************************************************************

    globals

*****************************************************************************/
UINT _cchNumberPadding;



/*****************************************************************************

    prototypes

*****************************************************************************/
INT __cdecl main( INT    cArgs,
                   char * pArgs[] );

VOID Usage();

VOID DoEnum( WCHAR * pszServer );

VOID DoQuery( WCHAR * pszServer );

VOID DoSet( WCHAR * pszServer,
            CHAR * pszPassword );

VOID DoNuke( WCHAR * pszServer,
             CHAR  * pszUserId );

VOID DoStats( WCHAR * pszServer );

VOID DoClear( WCHAR * pszServer );

CHAR * MakeCommaString( CHAR * pszNumber );

CHAR * MakeCommaNumber( DWORD  dwNumber  );



/*****************************************************************************

    main

*****************************************************************************/
INT __cdecl main( INT    cArgs,
                   char * pArgs[] )
{
    WCHAR   szServer[MAX_PATH];
    WCHAR * pszServer = NULL;
    INT     iArg;

    if( cArgs < 2 )
    {
        Usage();
        return 1;
    }

    iArg = 1;

    if( *pArgs[iArg] == '\\' )
    {
        wsprintfW( szServer, L"%S", pArgs[iArg++] );
        pszServer = szServer;
        cArgs--;
    }

    if( _stricmp( pArgs[iArg], "stats" ) == 0 )
    {
        if( cArgs != 2 )
        {
            printf( "use: w3t stats\n" );
            return 1;
        }

        DoStats( pszServer );
    }
    else
    if( _stricmp( pArgs[iArg], "clear" ) == 0 )
    {
        if( cArgs != 2 )
        {
            printf( "use: w3t clear\n" );
            return 1;
        }

        DoClear( pszServer );
    }
    else
    if( _stricmp( pArgs[iArg], "enum" ) == 0 )
    {
        if( cArgs != 2 )
        {
            printf( "use: w3t enum\n" );
            return 1;
        }

        DoEnum( pszServer );
    }
    else
    if( _stricmp( pArgs[iArg], "query" ) == 0 )
    {
        if( cArgs != 2 )
        {
            printf( "use: w3t query\n" );
            return 1;
        }

        DoQuery( pszServer );
    }
    else
    if( _stricmp( pArgs[iArg], "set" ) == 0 )
    {
        CHAR * pszPassword;

        if ( cArgs == 3 )
        {
            pszPassword = pArgs[++iArg];
        }
        else
            pszPassword = NULL;

        DoSet( pszServer,
               pszPassword );


    }
    else
    if( _stricmp( pArgs[iArg], "nuke" ) == 0 )
    {
        CHAR * pszUserId;

        if( cArgs != 3 )
        {
            printf( "use: w3t nuke user_id\n" );
            return 1;
        }

        pszUserId = pArgs[++iArg];

        DoNuke( pszServer,
                pszUserId );
    }
    else
    {
        Usage();
        return 1;
    }
    return 0;

}   // main



/*****************************************************************************

    Usage

*****************************************************************************/
VOID Usage( VOID )
{
    printf( "use: w3t [\\\\server] command [options]\n" );
    printf( "Valid commands are:\n" );
    printf( "        enum  - Enumerates connected users.\n" );
    printf( "        query - Queries volume security masks.\n" );
    printf( "        set [Catapult user password]  - Sets admin info.\n" );
    printf( "        nuke  - Disconnect a user.\n" );
    printf( "        stats - Display server statistics.\n" );
    printf( "        clear - Clear server statistics.\n" );

}   // Usage



/*****************************************************************************

    DoEnum

*****************************************************************************/
VOID DoEnum( WCHAR * pszServer )
{
    NET_API_STATUS   err;
    LPIIS_USER_INFO_1 pUserInfo;
    DWORD            cEntries;

    printf( "Invoking W3EnumerateUsers..." );

    err = IISEnumerateUsers(
                        pszServer,
                        1,
                        INET_HTTP_SVC_ID,
                        1,
                        &cEntries,
                        (LPBYTE*)&pUserInfo );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
    }
    else
    {
        printf( "done\n" );
        printf( "read %lu connected users\n", cEntries );

        while( cEntries-- )
        {
            IN_ADDR addr;

            addr.s_addr = (u_long)pUserInfo->inetHost;

            printf( "idUser     = %lu\n", pUserInfo->idUser     );
            printf( "pszUser    = %S\n",  pUserInfo->pszUser    );
            printf( "fAnonymous = %lu\n", pUserInfo->fAnonymous );
            printf( "inetHost   = %s\n",  inet_ntoa( addr )     );
            printf( "tConnect   = %lu\n", pUserInfo->tConnect   );
            printf( "\n" );

            pUserInfo++;
        }
    }

}   // DoEnum



/*****************************************************************************

    DoQuery

*****************************************************************************/
VOID DoQuery( WCHAR * pszServer )
{
    NET_API_STATUS   err;
    W3_CONFIG_INFO * pConfig;
    DWORD            i;

    printf( "Invoking W3GetAdminInformation..." );


    err = W3GetAdminInformation(
                            pszServer,
                            &pConfig
                            );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
        return;
    }

    printf("DirBrowseControl = %x\n", pConfig->dwDirBrowseControl );
    printf("fCheckForWAISDB  = %d\n", pConfig->fCheckForWAISDB );
    printf("Default Load File= %S\n", pConfig->lpszDefaultLoadFile );
    printf("Directory Image  = %S\n", pConfig->lpszDirectoryImage );
    printf("Catapult user    = %S\n", pConfig->lpszCatapultUser );
    printf("Catapult user pwd= %S\n", pConfig->szCatapultUserPwd );
    printf("Server Side Includes Enabled = %d\n", pConfig->fSSIEnabled );
    printf("Server Side Extension =        %S\n", pConfig->lpszSSIExtension );
    printf("Global Expire    = %d seconds\n", pConfig->csecGlobalExpire );

    printf("Script Mappings:\n");


    for ( i = 0; pConfig->ScriptMap && i < pConfig->ScriptMap->cEntries; i++ )
    {
        printf("\t%S\t=> %S\n",
               pConfig->ScriptMap->aScriptMap[i].lpszExtension,
               pConfig->ScriptMap->aScriptMap[i].lpszImage );
    }

}   // DoQuery



/*****************************************************************************

    DoSet

*****************************************************************************/
VOID DoSet( WCHAR * pszServer, CHAR * pszPassword )
{
    NET_API_STATUS   err;
    W3_CONFIG_INFO * pConfig;
    WCHAR            achPassword[PWLEN+1];

    printf( "Invoking W3GetAdminInformation..." );

    err = W3GetAdminInformation(
                            pszServer,
                            &pConfig );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
        return;
    }

    printf( "Invoking W3SetAdminInformation..." );

    if ( pszPassword )
    {
        wsprintfW( achPassword, L"%S", pszPassword );
        wcscpy( pConfig->szCatapultUserPwd, achPassword );
    }

    err = W3SetAdminInformation(
                                pszServer,
                                pConfig
                                );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
        return;
    }

    printf( "done!\n" );

    NetApiBufferFree( pConfig );

}   // DoSet



/*****************************************************************************

    DoNuke

*****************************************************************************/
VOID DoNuke( WCHAR * pszServer,
             CHAR  * pszUserId )
{
    NET_API_STATUS   err;
    DWORD            idUser;

    idUser = (DWORD)strtoul( pszUserId, NULL, 0 );

    printf( "Invoking W3DisconnectUser..." );

    err = IISDisconnectUser(
                        pszServer,
                        INET_HTTP_SVC_ID,
                        1,
                        idUser
                        );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
    }
    else
    {
        printf( "done\n" );
    }

}   // DoNuke



/*****************************************************************************

    DoStats

*****************************************************************************/
VOID DoStats( WCHAR * pszServer )
{
    NET_API_STATUS    err;
    W3_STATISTICS_0 * pstats;

    printf( "Invoking W3QueryStatistics..." );

    err = W3QueryStatistics2( pszServer,
                                0,
                                INET_INSTANCE_GLOBAL,
                                0,
                                (LPBYTE *)&pstats );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
    }
    else
    {
        CHAR szLargeInt[64];

        printf( "done\n" );

        _cchNumberPadding = 13;

        if( ( pstats->TotalBytesSent.HighPart != 0 ) ||
            ( pstats->TotalBytesReceived.HighPart != 0 ) )
        {
            _cchNumberPadding = 26;
        }

        RtlLargeIntegerToChar( &pstats->TotalBytesSent,
                               10,
                               sizeof(szLargeInt),
                               szLargeInt );

        printf( "TotalBytesSent           = %s\n",
                MakeCommaString( szLargeInt )                              );

        RtlLargeIntegerToChar( &pstats->TotalBytesReceived,
                               10,
                               sizeof(szLargeInt),
                               szLargeInt );

        printf( "TotalBytesReceived       = %s\n",
                MakeCommaString( szLargeInt )                              );

        printf( "TotalFilesSent           = %s\n",
                MakeCommaNumber( pstats->TotalFilesSent )                  );

        printf( "TotalFilesReceived       = %s\n",
                MakeCommaNumber( pstats->TotalFilesReceived )              );

        printf( "CurrentAnonymousUsers    = %s\n",
                MakeCommaNumber( pstats->CurrentAnonymousUsers )           );

        printf( "CurrentNonAnonymousUsers = %s\n",
                MakeCommaNumber( pstats->CurrentNonAnonymousUsers )        );

        printf( "TotalAnonymousUsers      = %s\n",
                MakeCommaNumber( pstats->TotalAnonymousUsers )             );

        printf( "TotalNonAnonymousUsers   = %s\n",
                MakeCommaNumber( pstats->TotalNonAnonymousUsers )          );

        printf( "MaxAnonymousUsers        = %s\n",
                MakeCommaNumber( pstats->MaxAnonymousUsers )               );

        printf( "MaxNonAnonymousUsers     = %s\n",
                MakeCommaNumber( pstats->MaxNonAnonymousUsers )            );

        printf( "CurrentConnections       = %s\n",
                MakeCommaNumber( pstats->CurrentConnections )              );

        printf( "MaxConnections           = %s\n",
                MakeCommaNumber( pstats->MaxConnections )                  );

        printf( "ConnectionAttempts       = %s\n",
                MakeCommaNumber( pstats->ConnectionAttempts )              );

        printf( "LogonAttempts            = %s\n",
                MakeCommaNumber( pstats->LogonAttempts )                   );

        printf( "TotalGets                = %s\n",
                MakeCommaNumber( pstats->TotalGets )                            );

        printf( "TotalHeads               = %s\n",
                MakeCommaNumber( pstats->TotalHeads )                            );

        printf( "TotalPosts               = %s\n",
                MakeCommaNumber( pstats->TotalPosts )                            );

        printf( "TotalOthers              = %s\n",
                MakeCommaNumber( pstats->TotalOthers )                            );

        printf( "TotalCGIRequests         = %s\n",
                MakeCommaNumber( pstats->TotalCGIRequests )                );

        printf( "TotalBGIRequests         = %s\n",
                MakeCommaNumber( pstats->TotalBGIRequests )                );

        printf( "CurrentCGIRequests       = %s\n",
                MakeCommaNumber( pstats->CurrentCGIRequests )              );

        printf( "CurrentBGIRequests       = %s\n",
                MakeCommaNumber( pstats->CurrentBGIRequests )              );

        printf( "MaxCGIRequests           = %s\n",
                MakeCommaNumber( pstats->MaxCGIRequests )                  );

        printf( "MaxBGIRequests           = %s\n",
                MakeCommaNumber( pstats->MaxBGIRequests )                  );

        printf( "TotalNotFoundErrors      = %s\n",
                MakeCommaNumber( pstats->TotalNotFoundErrors )             );

        printf( "TimeOfLastClear          = %s\n",
                asctime( localtime( (time_t *)&pstats->TimeOfLastClear ) ) );
    }

}   // DoStats



/*****************************************************************************

    DoClear

*****************************************************************************/
VOID DoClear( WCHAR * pszServer )
{
    NET_API_STATUS   err;

    printf( "Invoking W3ClearStatistics..." );

    err = W3ClearStatistics2( pszServer, 0 );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
    }
    else
    {
        printf( "done\n" );
    }

}   // DoClear



/*****************************************************************************

    MakeCommaString

*****************************************************************************/
CHAR * MakeCommaString( CHAR * pszNumber )
{
    static CHAR   szBuffer[26];
    CHAR        * psz;
    UINT          cchNumber;
    UINT          cchNextComma;

    cchNumber  = strlen( pszNumber );
    pszNumber += cchNumber - 1;

    psz = szBuffer + _cchNumberPadding;

    *psz-- = '\0';

    cchNextComma = 3;

    while( cchNumber-- )
    {
        if( cchNextComma-- == 0 )
        {
            *psz-- = ',';
            cchNextComma = 2;
        }

        *psz-- = *pszNumber--;
    }

    while( psz >= szBuffer )
    {
        *psz-- = ' ';
    }

    return szBuffer;

}   // MakeCommaString



/*****************************************************************************

    MakeCommaNumber

*****************************************************************************/
CHAR * MakeCommaNumber( DWORD  dwNumber  )
{
    CHAR szBuffer[32];

    wsprintf( szBuffer, "%lu", dwNumber );

    return MakeCommaString( szBuffer );

}   // MakeCommaNumber
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\httpauth\httpget.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    httpget.c

Abstract:

    This is a web command line application.  It will allow a user to get a 
    html document from the command line.

Environment:

    console app

--*/

#include <windows.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include "const.h"
#include "proto.h"

void
PrintUsage(void);

#define SOCKETS_METHOD 1

void
__cdecl
main(
    int argc,
    char * argv[])
{
    char *        Server;
    char *        URL;
    char *        Verb = "GET";
    char *        Gateway = NULL;
    char *        AcceptTypes[2] = {"*/*", NULL};
    char          Headers[] = 
                      "Accept: */*\r\n"
                      "User-Agent: Httpget\r\n"
                      "Referer: Httpget\r\n"
                      "\r\n";
    int           Method = SOCKETS_METHOD;
    BOOL          DisplayHeaders = FALSE;
    DWORD         ClientDataSize = 0;
    PSTR          pszUserName = "";
    PSTR          pszPassword = "";
    PSTR          pszStore = NULL;
    PSTR          pszPref = NULL;

    //
    // Parse the command line
    //

    if (argc < 3) 
    {
        PrintUsage();
        return;
    }

    while (argc > 3) 
    {
        //
        // parse options
        //

        if (argv[1][0] == '-') 
        {
            switch (argv[1][1]) 
            {
            case 'V' :
            case 'v' :
                //
                // Input verb
                //

                Verb = &argv[1][3];

                break;

            case 'H' :
            case 'h' :
                //
                // Display headers
                //

                DisplayHeaders = TRUE;

                break;

            case 'D' :
            case 'd' :
                //
                // Amount of data to send
                //

                if (sscanf(&argv[1][3], "%u", &ClientDataSize) != 1) 
                {
                    PrintUsage();
                    return;
                }
                break;

            case 'G' :
            case 'g' :
                //
                // Gateway
                //

                Gateway = &argv[1][3];

                break;

            case 'M':
            case 'm':
                // User name
                pszPref = &argv[1][3];
                break;

            case 'N':
            case 'n':
                // User name
                pszUserName = &argv[1][3];
                break;

            case 'P':
            case 'p':
                // Password
                pszPassword = &argv[1][3];
                break;

            case 'S':
            case 's':
                pszStore = &argv[1][3];
                break;

            default:
                PrintUsage();
                return;
                break;
            }
        } 
        else 
        {
            PrintUsage();
            return;
        }

        argc --;
        argv ++;
    }

    Server = argv[1];

    URL = argv[2];

    switch (Method) 
    {
    case SOCKETS_METHOD:
        HttpGetSocket(
            Verb,
            Server,
            URL,
            DisplayHeaders,
            ClientDataSize,
            pszUserName,
            pszPassword,
            pszStore,
            pszPref );
        break;
    }

    return;
}

void
PrintUsage()
{
    fprintf(stderr,
        "httpauth  [-h] [-d:<size>] [-m:<methodlist>] [-v:<verb>] [-n:<username>]\n"
		"\t  [-p:<password>] [-g:gateway] [-s:storefile] <server> <path>\n"
        "\t-h           - display result headers\n"
        "\t<size>       - amount of client data to send\n"
        "\t<verb>       - HTTP verb to use (default is GET)\n"
        "\t<username>   - user name for authentication\n"
        "\t<password>   - password for authentication\n"
        "\t<methodlist> - comma separated list of authentication methods in order\n"
        "\t               of preference (Default is to use first supported method\n"
        "\t               returned by the HTTP server (e.g., -m:NTLM,BASIC)\n"
        "\t<storefile>  - file where to store result message body\n"
        "\t<server>     - web server to connect to (without http:)\n"
        "\t<path>       - resource to get (e.g., /default.htm)\n"
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\tests\iismeta\iismeta.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    iismeta.cxx

Abstract:

    Test for IP/DNS access list management

Author:

    Philippe Choquier (phillich)    27-june-1996

--*/

#define INITGUID
#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "dbgutil.h"

//
//  Project include files.
//

#include <inetcom.h>
#include <inetamsg.h>
#include <tcpproc.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#define  _RDNS_STANDALONE
#include <rdns.hxx>
#include <buffer.hxx>
#include <iadm.h>
#include <iiscnfg.h>

#define ILIST_DENY      0
#define ILIST_GRANT     1

#define ITYPE_DNS       0
#define ITYPE_IP        1

#define LANMAN_ACLS     "System\\CurrentControlSet\\Services\\LanmanServer\\Shares\\Security"

//
// Metadata access
//

class CMdIf
{
public:
	CMdIf() { m_pcAdmCom = NULL; m_hmd = NULL; }
	~CMdIf() { Terminate(); }
	BOOL Init( LPSTR pszComputer );
    BOOL Open( LPWSTR pszOpen = L"", DWORD dwAttr = METADATA_PERMISSION_READ );
    BOOL Close();
    BOOL Save()
    {
        m_pcAdmCom->SaveData();
        return TRUE;
    }
    BOOL Terminate();
    BOOL GetData( LPWSTR pszPath, DWORD dwPropId, DWORD dwDataType, DWORD dwUserType, LPBYTE *ppData, LPDWORD pdwLen, DWORD dwFlags = METADATA_INHERIT )
    {
        METADATA_RECORD md;
        HRESULT         hRes;
        DWORD           dwRequired;
        
        md.dwMDDataType = dwDataType;
        md.dwMDUserType = dwUserType;
        md.dwMDIdentifier = dwPropId;
        md.dwMDAttributes  = dwFlags;
        md.dwMDDataLen = 0;
        md.pbMDData = (LPBYTE)NULL;
    
        *ppData = NULL;
        *pdwLen = 0;

        hRes = m_pcAdmCom->GetData( m_hmd, pszPath, &md, &dwRequired );
        if ( hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
        {
            *ppData = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired );
            if ( !*ppData )
            {
                return FALSE;
            }
            md.pbMDData = *ppData;
            *pdwLen = md.dwMDDataLen = dwRequired;
            hRes = m_pcAdmCom->GetData( m_hmd, pszPath, &md, &dwRequired );
        }

        if ( FAILED(hRes) )
        {
            SetLastError( HRESULTTOWIN32(hRes) );
            return FALSE;
        }
        return TRUE;
    }
    BOOL SetData( LPWSTR pszPath, DWORD dwPropId, DWORD dwDataType, DWORD dwUserType, LPBYTE pData, DWORD dwLen, DWORD dwFlags = METADATA_INHERIT )
    {
        METADATA_RECORD md;
        HRESULT         hRes;

        md.dwMDDataType = dwDataType;
        md.dwMDUserType = dwUserType;
        md.dwMDIdentifier = dwPropId;
        md.dwMDAttributes  = dwFlags;
        md.dwMDDataLen = dwLen;
        md.pbMDData = pData;

        hRes = m_pcAdmCom->SetData( m_hmd, pszPath, &md );
        if ( FAILED( hRes ) )
        {
            SetLastError( HRESULTTOWIN32(hRes) );
            return FALSE;
        }
        return TRUE;
    }

private:
	
    IMSAdminBaseW *     m_pcAdmCom;   //interface pointer
    METADATA_HANDLE     m_hmd;
} ;

#define TIMEOUT_VALUE   5000

//
//  Global Data
//

DECLARE_DEBUG_PRINTS_OBJECT()
DECLARE_DEBUG_VARIABLE();

BOOL
GetCtx(
    LPSTR*  pArg,
    int     iArg,
    int *   piType,
    int *   piList
    )
{
    switch ( pArg[iArg][2])
    {
        case 'd':
        case 'D':
            *piType = ITYPE_DNS;
            break;

        case 'i':
        case 'I':
            *piType = ITYPE_IP;
            break;

        default:
            return FALSE;
    }

    switch ( pArg[iArg][3] )
    {
        case 'd':
        case 'D':
            *piList = ILIST_DENY;
            break;

        case 'g':
        case 'G':
            *piList = ILIST_GRANT;
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


LPBYTE 
GetIp(
    LPSTR *             pArg,
    int *               piArg
    )
{
    LPSTR pS;

    if ( pS = pArg[++*piArg] )
    {
        LPBYTE p;
        if ( p = (LPBYTE)LocalAlloc( LMEM_FIXED, 4 ) )
        {
            if ( sscanf( pS, "%u.%u.%u.%u", p, p+1, p+2, p+3 ) == 4 )
            {
                return p;
            }
            LocalFree( p );
            return NULL;
        }
    }

    return NULL;
}


BOOL
FreeIp(
    LPBYTE              pIp
    )
{
    if ( pIp )
    {
        LocalFree( pIp );
    }

    return TRUE;
}


BOOL
LocateInList(
    ADDRESS_CHECK *     pAc,
    int                 iType,
    int                 iList,
    LPSTR *             pArg,
    int *               piArg,
    int *               piIdx
    )
{
    LPBYTE      pMask = NULL;
    LPBYTE      pAddr = NULL;
    BOOL        fSt = FALSE;
    UINT        i;
    UINT        x;

    switch ( iType )
    {
        case ITYPE_IP:
            if ( (pMask = GetIp( pArg, piArg )) &&
                 (pAddr = GetIp( pArg, piArg )) )
            {
                i = pAc->GetNbAddr( iList );
                for ( x = 0 ; x < i ; ++x )
                {
                    LPBYTE pM;
                    LPBYTE pA;
                    DWORD dwF;
                    pAc->GetAddr( iList, x, &dwF, &pM, &pA );

                    if ( dwF == AF_INET &&
                         !memcmp( pM, pMask, 4 ) &&
                         !memcmp( pA, pAddr, 4 ) )
                    {
                        *piIdx = x;
                        fSt = TRUE;
                        break;
                    }
                }
            }
            FreeIp( pMask );
            FreeIp( pAddr );
            break;

        case ITYPE_DNS:
            i = pAc->GetNbName( iList );
            if ( pArg[++*piArg] )
            {
                for ( x = 0 ; x < i ; ++x )
                {
                    LPSTR pN;
                    pAc->GetName( iList, x, &pN );
                    if ( !strcmp( pN, pArg[*piArg] ) )
                    {
                        *piIdx = x;
                        fSt = TRUE;
                        break;
                    }
                }
            }
            break;
    }

    return fSt;
}


BOOL
DeleteFromList(
    ADDRESS_CHECK *     pAc,
    int                 iType,
    int                 iList,
    LPSTR *             pArg,
    int *               piArg
    )
{
    int iIdx;

    if ( LocateInList( pAc, iType, iList, pArg, piArg, &iIdx ) )
    {
        switch ( iType )
        {
            case ITYPE_IP:
                return pAc->DeleteAddr( iList, iIdx );

            case ITYPE_DNS:
                return pAc->DeleteName( iList, iIdx );
        }
    }

    return FALSE;
}


BOOL
AddToList(
    ADDRESS_CHECK *     pAc,
    int                 iType,
    int                 iList,
    LPSTR *             pArg,
    int *               piArg
    )
{
    BOOL        fSt;
    LPBYTE      pMask = NULL;
    LPBYTE      pAddr = NULL;
    DWORD       dwFlags = 0;
    LPSTR       p;    


    switch ( iType )
    {
        case ITYPE_IP:
            if ( (pMask = GetIp( pArg, piArg )) &&
                 (pAddr = GetIp( pArg, piArg )) )
            {
                fSt = pAc->AddAddr( iList, AF_INET, pMask, pAddr );
            }
            else
            {
                fSt = FALSE;
            }
            FreeIp( pMask );
            FreeIp( pAddr );
            return fSt;

        case ITYPE_DNS:
            if ( p = pArg[++*piArg] )
            {
                if ( !strncmp( p, "*.", 2 ) )
                {
                    p += 2;
                }
                else
                {
                    dwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;
                }
                return pAc->AddName( iList, p, dwFlags );
            }
            break;
    }

    return FALSE;
}


BOOL
DisplayList(
    ADDRESS_CHECK *     pAc,
    int                 iType,
    int                 iList
    )
{
    UINT    i;
    UINT    x;
    DWORD   dwF;

    switch ( iType )
    {
        case ITYPE_IP:
            i = pAc->GetNbAddr( iList );
            for ( x = 0 ; x < i ; ++x )
            {
                LPBYTE pM;
                LPBYTE pA;
                DWORD dwF;
                pAc->GetAddr( iList, x, &dwF, &pM, &pA );

                CHAR achE[80];
                wsprintf( achE, "%d.%d.%d.%d %d.%d.%d.%d",
                    pM[0], pM[1], pM[2], pM[3], 
                    pA[0], pA[1], pA[2], pA[3] );
                puts( achE );
            }
            return TRUE;

        case ITYPE_DNS:
            i = pAc->GetNbName( iList );
            for ( x = 0 ; x < i ; ++x )
            {
                LPSTR pN;
                pAc->GetName( iList, x, &pN, &dwF );
                if ( !(dwF & DNSLIST_FLAG_NOSUBDOMAIN ) )
                {
                    fputs( "*.", stdout );
                }
                puts( pN );
            }
            return TRUE;
    }
    
    return FALSE;
}


BOOL
SaveObject(
    LPWSTR          pszFilename,
    LPBYTE          pBin,
    DWORD           cBin
    )
{
    CMdIf   mdif;
    BOOL    fSt = FALSE;

    if ( mdif.Init( NULL ) )
    {
        if ( mdif.Open( pszFilename, METADATA_PERMISSION_WRITE ) )
        {
            if ( mdif.SetData( L"", MD_IP_SEC, BINARY_METADATA, IIS_MD_UT_FILE, pBin, cBin, METADATA_INHERIT|METADATA_REFERENCE ) )
            {
                fSt = TRUE;
            }
            mdif.Close();
        }
        mdif.Terminate();
    }

    return fSt;
}


BOOL
LoadObject(
    LPWSTR          pszFilename,
    LPBYTE *        ppBin,
    LPDWORD         pcBin
    )
{
    CMdIf   mdif;
    BOOL    fSt = FALSE;

    if ( mdif.Init( NULL ) )
    {
        if ( mdif.Open( pszFilename, METADATA_PERMISSION_READ ) )
        {
            if ( mdif.GetData( L"", MD_IP_SEC, BINARY_METADATA, IIS_MD_UT_FILE, ppBin, pcBin ) )
            {
                fSt = TRUE;
            }
            mdif.Close();
        }
        mdif.Terminate();
    }

    return fSt;
}


int __cdecl main( int argc, char*argv[] )
{
    int             arg;
    int             cnt;
    ADDRESS_CHECK   ac;
    int             iType;
    int             iList;
    DWORD           dwS;
    LPWSTR          pPath = NULL;
    BOOL            fNotPresent = TRUE;
    LPBYTE          pStore = NULL;
    LPSTR           pObj;
    LPSTR           pDel;
    DWORD           dwDataLen = 0;
    BOOL            fAccessListLoaded = FALSE;
    BOOL            fAclLoaded = FALSE;
    int             iStatus = 0;
    HKEY            hKey;
    DWORD           dwType;
    LPBYTE          pData;
    DWORD           cData;
    WCHAR           awchPath[128];


    if ( argc < 2 )
    {
        printf( "Usage:\n"
                "iismeta metapath \n"
                "        [-a(i|d)(d|g) address] : add address\n"
                "           where (i|d) is 'i' for IP, 'd' for DNS\n"
                "                 (d|g) is 'd' for deny list, 'g' for grant list\n"
                "                 address is \"mask addr\" for IP address\n"
                "                 in '.' form ( e.g. 255.255.0.0 185.65.34.23)\n"
                "                 and DNS name for DNS address\n"
                "        [-d(i|d)(d|g) address] : delete address\n"
                "        [-l(i|d)(d|g)] : list address\n"
                "        [-s share_name] : copy ACL from LanMan share\n"
                "                          to metadata\n"
              );
        return 9;
    }

    // -[adl][id][dg]
    // a:add d:delete l:list
    // i:IP d:DNS
    // d:deny g:grant
    // if IP then addr is [mask addr]
    // if DNS then addr is [addr]

    ac.BindCheckList();

    for ( cnt = 0, arg = 1 ; arg < argc ; ++ arg )
    {
        if ( argv[arg][0] == '-' )
        {
            if ( cnt < 1)
            {
                puts( "must specify metadata path" );
                iStatus = 2;
                goto cleanup;
            }

            switch ( argv[arg][1] )
            {
                case 'a':
                    if ( !fAccessListLoaded )
                    {
                        if ( LoadObject( pPath, &pStore, &dwDataLen) )
                        {
                            ac.BindCheckList( pStore, dwDataLen );
                            fNotPresent = FALSE;
                        }
                        fAccessListLoaded = TRUE;
                    }
                    if ( GetCtx( argv, arg, &iType, &iList ) )
                    {
                        if ( !AddToList( &ac, iType, iList, argv, &arg ) )
                        {
                            puts( "invalid address" );
                            iStatus = 3;
                            goto cleanup;
                        }
                    }
                    else
                    {
                        printf( "invalid command \"%s\"", argv[arg] );
                        iStatus = 4;
                        goto cleanup;
                    }
                    break;

                case 'd':
                    if ( !fAccessListLoaded )
                    {
                        if ( LoadObject( pPath, &pStore, &dwDataLen) )
                        {
                            ac.BindCheckList( pStore, dwDataLen );
                            fNotPresent = FALSE;
                        }
                        fAccessListLoaded = TRUE;
                    }
                    if ( GetCtx( argv, arg, &iType, &iList ) )
                    {
                        if ( !DeleteFromList( &ac, iType, iList, argv, &arg ) )
                        {
                            puts( "No such address" );
                            iStatus = 3;
                            goto cleanup;
                        }
                    }
                    else
                    {
                        printf( "invalid command \"%s\"", argv[arg] );
                        iStatus = 4;
                        goto cleanup;
                    }
                    break;

                case 'l':
                    if ( !fAccessListLoaded )
                    {
                        if ( LoadObject( pPath, &pStore, &dwDataLen) )
                        {
                            ac.BindCheckList( pStore, dwDataLen );
                            fNotPresent = FALSE;
                        }
                        fAccessListLoaded = TRUE;
                    }
                    if ( GetCtx( argv, arg, &iType, &iList ) )
                    {
                        DisplayList( &ac, iType, iList );
                    }
                    else
                    {
                        printf( "invalid command \"%s\"", argv[arg] );
                        iStatus = 4;
                        goto cleanup;
                    }
                    break;

                case 's':       //set acl
                    if ( argv[++arg] != NULL &&
                         RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                LANMAN_ACLS, 
                                NULL, 
                                KEY_ALL_ACCESS, 
                                &hKey ) == ERROR_SUCCESS )
                    {
                        dwDataLen = 0;
                        if ( ((dwS = RegQueryValueEx( hKey, 
                                            argv[arg], 
                                            NULL, 
                                            &dwType, 
                                            pStore, 
                                            &dwDataLen )) == ERROR_MORE_DATA ||
                                    dwS == ERROR_SUCCESS ) &&
                             dwType == REG_BINARY &&
                             ( pStore = (LPBYTE)LocalAlloc( LMEM_FIXED, 
                                    dwDataLen) ) &&
                             RegQueryValueEx( hKey, 
                                    argv[arg], 
                                    NULL, 
                                    &dwType, 
                                    pStore, 
                                    &dwDataLen ) == ERROR_SUCCESS )
                        {
                            fAclLoaded = TRUE;
                        }
                        else
                        {
                            printf( "Can't access security from LanMan for share %s : %d\n",
                                    argv[arg], GetLastError() );
                            iStatus = 9;
                            goto cleanup;
                        }
                        RegCloseKey( hKey );
                    }
                    break;

                default:
                    printf( "invalid command \"%s\"", argv[arg] );
                    iStatus = 4;
                    goto cleanup;
                    break;

            }
        }
        else 
        {
            switch ( cnt )
            {
                case 0:
                    if ( !MultiByteToWideChar( CP_ACP,
                                               MB_PRECOMPOSED,
                                               argv[arg],
                                               -1,
                                               awchPath,
                                               sizeof(awchPath) ) )
                    {
                        return 8;
                    }

                    pPath = awchPath;
                    break;
            }
            ++cnt;
        }
    }

    //
    // must create object in path
    //

    pData = NULL;
    cData = 0;

    if ( fAccessListLoaded )
    {
        cData = ac.QueryCheckListSize();
        pData = ac.QueryCheckListPtr();
    }
    else if ( fAclLoaded )
    {
        pData = pStore;
        cData = dwDataLen;
    }

    if ( pData )
    {
        if ( !SaveObject( pPath, pData, cData ) )
        {
            printf( "Error %08x setting data for %S\n",
                    pPath );
            iStatus = 7;
            goto cleanup;
        }
    }

cleanup:

    ac.UnbindCheckList();

    if ( pStore != NULL )
    {
        LocalFree( pStore );
    }

    return iStatus;
}

BOOL
CMdIf::Init(
    LPSTR   pszComputer
    )
/*++

Routine Description:

    Initialize metabase admin interface :
        get interface pointer, call Initialize()

Arguments:

    pszComputer - computer name, NULL for local computer

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    IClassFactory *     pcsfFactory;
    COSERVERINFO        csiMachineName;
    HRESULT             hresError;
    BOOL                fSt = FALSE;
    WCHAR               awchComputer[64];
    WCHAR*              pwchComputer = NULL;

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    //fill the structure for CoGetClassObject
    csiMachineName.pAuthInfo = NULL;
    csiMachineName.dwReserved1 = 0;
    csiMachineName.dwReserved2 = 0;

    if ( pszComputer )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszComputer,
                                   -1,
                                   awchComputer,
                                   sizeof(awchComputer) ) )
        {
            return FALSE;
        }

        pwchComputer = awchComputer;
    }

    csiMachineName.pwszName =  pwchComputer;

    hresError = CoGetClassObject(
                        CLSID_MSAdminBase_W,
                        CLSCTX_SERVER,
                        &csiMachineName,
                        IID_IClassFactory,
                        (void**) &pcsfFactory );

    if ( SUCCEEDED(hresError) )
    {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase_W, (void **) &m_pcAdmCom);
        if (SUCCEEDED(hresError) )
        {
                fSt = TRUE;
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
            m_pcAdmCom = NULL;
        }

        pcsfFactory->Release();
    }
    else
    {
        if ( hresError == REGDB_E_CLASSNOTREG )
        {
            SetLastError( ERROR_SERVICE_DOES_NOT_EXIST );
        }
        else
        {
            SetLastError( HRESULTTOWIN32(hresError) );
        }
        m_pcAdmCom = NULL;
    }

    return fSt;
}


BOOL
CMdIf::Open(
    LPWSTR  pszOpenPath,
    DWORD   dwPermission
    )
/*++

Routine Description:

    Open path in metabase

Arguments:

    pszOpenPath - path in metadata
    dwPermission - metadata permission

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    HRESULT hresError;

    hresError = m_pcAdmCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
        pszOpenPath, dwPermission, TIMEOUT_VALUE, &m_hmd );

    if ( FAILED(hresError) )
    {
        m_hmd = NULL;
        return FALSE;
    }

    return TRUE;
}


BOOL
CMdIf::Close(
    )
/*++

Routine Description:

    Close path in metabase

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pcAdmCom && m_hmd )
    {
        m_pcAdmCom->CloseKey(m_hmd);
    }

    m_hmd = NULL;

    return TRUE;
}


BOOL
CMdIf::Terminate(
    )
/*++

Routine Description:

    Terminate metabase admin interface :
        call Terminate, release interface pointer

Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pcAdmCom )
    {
        m_pcAdmCom->Release();
        m_hmd = NULL;
        m_pcAdmCom = NULL;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\w3subs\w3subs.cxx ===
/*++

   Copyright    (c)    1998        Microsoft Corporation

   Module Name:

        w3subs.hxx

   Abstract:

        This module provides the code for w3 subroutines.
        The main reason this code is in a separate file and directory is
        to avoid the precompiled header in w3/server, so INITGUID and
        UNICODE can be defined. This module declares CLSID_MSAdminBase_W and
        IID_IMSAdminBase_W.

   Author:

        Michael Thomas    (michth)      Feb-16-1998

--*/

#define INITGUID
#define UNICODE

#ifdef __cplusplus
extern "C" {
#endif


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
};
#endif

#include  <w3subs.hxx>


#include "dbgutil.h"
#include <ole2.h>
#include <stdio.h>
#include <iadmw.h>

/*++

Routine Description:

    Gets a resource string.

Arguments:

    hInsance    The instance or module handle to the dll conainint the resource.

    dwStringID  The ID of the desired resource.

    wpszBuffer  The buffer to store the string in.

    dwBufferLen The lenghth of wpszBuffer, in Unicode characters.

Return Value:

    HRESULT - ERROR_SUCCESS
              Errors returned by LoadString converted to HRESULT

--*/

HRESULT
GetUnicodeResourceString(HINSTANCE hInstance,
                         DWORD dwStringID,
                         LPWSTR wpszBuffer,
                         DWORD  dwBufferLen)
{
    HRESULT hresReturn = ERROR_SUCCESS;

     if (LoadString(hInstance,
                    dwStringID,
                    wpszBuffer,
                    dwBufferLen) == 0) {
         hresReturn = HRESULT_FROM_WIN32(GetLastError());
     }


    return hresReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\gip.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.cpp

Owner: DmitryR

This is the GIP source file.
===================================================================*/

#include "isapip.hxx"
#include "gip.h"

/*===================================================================
  Globals
===================================================================*/

CGlobalInterfaceAPI g_GIPAPI;

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

/*===================================================================
CGlobalInterfaceAPI::CGlobalInterfaceAPI

CGlobalInterfaceAPI constructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::CGlobalInterfaceAPI() 
    : m_fInited(FALSE), m_pGIT(NULL)
    {
    }
    
/*===================================================================
CGlobalInterfaceAPI::~CGlobalInterfaceAPI

CGlobalInterfaceAPI destructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::~CGlobalInterfaceAPI()
    {
    UnInit();
    }

/*===================================================================
CGlobalInterfaceAPI::Init

Creates instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CGlobalInterfaceAPI::Init()
    {
    DBG_ASSERT(!m_fInited); // don't init twice
    
    HRESULT hr = CoCreateInstance
        (
        CLSID_StdGlobalInterfaceTable,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGlobalInterfaceTable,
        (void **)&m_pGIT
        );
        
    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        m_pGIT = NULL;

    return hr;
    }

/*===================================================================
CGlobalInterfaceAPI::UnInit

Releases instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT (NOERROR)
===================================================================*/	
HRESULT CGlobalInterfaceAPI::UnInit()
    {
    if (m_pGIT)
        {
        m_pGIT->Release();
        m_pGIT = NULL;
        }

    m_fInited = FALSE;
    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\makefile.inc ===
#
# Supplemental rules for generating message file.
#

$(O)\wammsg.h $(O)\wammsg.rc $(O)\msg00001.bin: wammsg.mc ..\..\..\inc\inetamsg.mc
    copy /a ..\..\..\inc\inetamsg.mc + /a wammsg.mc $(O)\tmp.mc
    mc -v -h .\$(O) -r .\$(O) $(O)\tmp.mc
    -del $(O)\wammsg.h $(O)\tmp.mc $(O)\tmp.rc 
    copy $(O)\tmp.h $(O)\wammsg.h
    del $(O)\tmp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\gip.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.h

Owner: DmitryR

This is the GIP header file.
===================================================================*/

#ifndef _ASP_GIP_H
#define _ASP_GIP_H

// ***********************************************************************
// =======================================================================
// -----------------------------------------------------------------------
// START OF SP3 1.78 SDK Additions
// -----------------------------------------------------------------------
// The following are SP3 1.78 Additions from Rick Hill (rickhi)
// extracted from CGUID.H and OBJIDL.H
// -----------------------------------------------------------------------
// UNDONE: Once the new SDK is available the stuff below will be gone
// -----------------------------------------------------------------------
// =======================================================================
// ***********************************************************************

EXTERN_C const CLSID CLSID_StdGlobalInterfaceTable;


#ifndef __IGlobalInterfaceTable_FWD_DEFINED__
#define __IGlobalInterfaceTable_FWD_DEFINED__
typedef interface IGlobalInterfaceTable IGlobalInterfaceTable;
#endif 	/* __IGlobalInterfaceTable_FWD_DEFINED__ */

#ifndef __IGlobalInterfaceTable_INTERFACE_DEFINED__
#define __IGlobalInterfaceTable_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGlobalInterfaceTable
 * at Fri Apr 04 10:36:42 1997
 * using MIDL 3.00.44
 ****************************************/
/* [uuid][object][local] */ 


typedef /* [unique] */ __RPC_FAR *LPGLOBALINTERFACETABLE;


EXTERN_C const IID IID_IGlobalInterfaceTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IGlobalInterfaceTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterInterfaceInGlobal( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeInterfaceFromGlobal( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceFromGlobal( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGlobalInterfaceTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGlobalInterfaceTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGlobalInterfaceTable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterInterfaceInGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ REFIID riid,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RevokeInterfaceFromGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfaceFromGlobal )( 
            IGlobalInterfaceTable __RPC_FAR * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        END_INTERFACE
    } IGlobalInterfaceTableVtbl;

    interface IGlobalInterfaceTable
    {
        CONST_VTBL struct IGlobalInterfaceTableVtbl __RPC_FAR *lpVtbl;
    };

#ifdef COBJMACROS

#define IGlobalInterfaceTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGlobalInterfaceTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGlobalInterfaceTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGlobalInterfaceTable_RegisterInterfaceInGlobal(This,pUnk,riid,
pdwCookie)	\
    (This)->lpVtbl -> RegisterInterfaceInGlobal(This,pUnk,riid,pdwCookie)

#define IGlobalInterfaceTable_RevokeInterfaceFromGlobal(This,dwCookie)	\
    (This)->lpVtbl -> RevokeInterfaceFromGlobal(This,dwCookie)

#define IGlobalInterfaceTable_GetInterfaceFromGlobal(This,dwCookie,riid,ppv)	\
    (This)->lpVtbl -> GetInterfaceFromGlobal(This,dwCookie,riid,ppv)

#endif /* COBJMACROS */

#endif 	/* C style interface */

HRESULT STDMETHODCALLTYPE 
IGlobalInterfaceTable_RegisterInterfaceInGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ REFIID riid,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IGlobalInterfaceTable_RegisterInterfaceInGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE 
IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IGlobalInterfaceTable_RevokeInterfaceFromGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGlobalInterfaceTable_GetInterfaceFromGlobal_Proxy( 
    IGlobalInterfaceTable __RPC_FAR * This,
    /* [in] */ DWORD dwCookie,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IGlobalInterfaceTable_GetInterfaceFromGlobal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IGlobalInterfaceTable_INTERFACE_DEFINED__ */

// ***********************************************************************
// =======================================================================
// -----------------------------------------------------------------------
// END OF SP3 1.78 SDK Additions
// -----------------------------------------------------------------------
// =======================================================================
// ***********************************************************************

/*===================================================================
  Includes
===================================================================*/


/*===================================================================
  Defines
===================================================================*/

#define NULL_GIP_COOKIE  0xFFFFFFFF

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

class CGlobalInterfaceAPI
    {
private:
    // Is inited?
    DWORD m_fInited : 1;
    
    // Pointer to the COM object
    IGlobalInterfaceTable *m_pGIT;

public:
    CGlobalInterfaceAPI();
    ~CGlobalInterfaceAPI();

    HRESULT Init();
    HRESULT UnInit();

    // inlines for the real API calls:
    HRESULT Register(IUnknown *pUnk, REFIID riid, DWORD *pdwCookie);
    HRESULT Get(DWORD dwCookie, REFIID riid, void **ppv);
    HRESULT Revoke(DWORD dwCookie);
    
public:
#if DBG
	inline void AssertValid() const
	    {
        DBG_ASSERT(m_fInited);
        DBG_ASSERT(m_pGIT);
	    }
#else
	inline void AssertValid() const {}
#endif
    };

/*===================================================================
  CGlobalInterfaceAPI inlines
===================================================================*/

inline HRESULT CGlobalInterfaceAPI::Register
(
IUnknown *pUnk,
REFIID riid,
DWORD *pdwCookie
)
    {
    AssertValid();
    return m_pGIT->RegisterInterfaceInGlobal(pUnk, riid, pdwCookie);
    }

inline HRESULT CGlobalInterfaceAPI::Get
(
DWORD dwCookie,
REFIID riid, 
void **ppv
)
    {
    AssertValid();
    return m_pGIT->GetInterfaceFromGlobal(dwCookie, riid, ppv);
    }
        
inline HRESULT CGlobalInterfaceAPI::Revoke
(
DWORD dwCookie
)
    {
    AssertValid();
    return m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
    }

/*===================================================================
  Globals
===================================================================*/

extern CGlobalInterfaceAPI g_GIPAPI;

#endif  // _ASP_GIP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000
# define DEBUG_BGI                 0x00008000

# define DEBUG_SETABLE             0x00010000
# define DEBUG_WAM                 0x00020000
# define DEBUG_WAM_EXEC            0x00040000
# define DEBUG_WAM_REFCOUNTS       0x00080000

# define DEBUG_WAM_FILENAMES       0x00100000
# define DEBUG_WAM_IWAMREQ_REFS    0x00200000
# define DEBUG_WAM_THREADID        0x00400000

# define DEBUG_WAM_ISA_CALLS       0x80000000

//
// Following macros are useful for formatting and printing out GUIDs
//

# define GUID_FORMAT   "{%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])

    // Usage:  DBGPRINTF(( DBG_CONTEXT, " My Guid: " GUID_FORMAT " \n", 
    //                     GUID_EXPAND( pMyGuid)));


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\ooptoken.h ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
       ooptoken.h

   Abstract:
       Header file for the CWamOopTokenInfo object

   Author:
       Taylor Weiss    ( TaylorW )     15-Feb-1999

   Environment:
       User Mode - Win32

   Project:
       iis\svcs\wam\object

--*/

# ifndef _OOP_TOKEN_H_
# define _OOP_TOKEN_H_

class CWamOopTokenInfo
/*++

Class description:

    Class enables modifcation of the impersonation token used for
    OOP applications. Holds SIDs for the WAM_* user account and the 
    system account. And provides ModifyTokenForOop() to add access
    allowed aces to the token's default dacl. See NT Bug 259045 for
    details on why this is necessary.

    Singleton object. The Create/Destroy methods initilize a static
    instance.

Public Interface:

    static Create       : Create the instance. Should be called once
                          from global initialization code.
    static Destroy      : Clean up the instance. Should be called once
                          from global cleanup code.
    
    static QueryInstance/HasInstance : intance accessors

    ModifyTokenForOop   : Do the work of modifying the tokens default
                          DACL.

--*/
{
public:
    
    static 
    HRESULT             Create( VOID );
    
    static 
    VOID                Destroy( VOID )
    {
        DBG_ASSERT( ms_pInstance != NULL );
        
        delete ms_pInstance;
        ms_pInstance = NULL;
    }
    
    static 
    CWamOopTokenInfo *  QueryInstance( VOID )
    {
        DBG_ASSERT( ms_pInstance != NULL );
        return ms_pInstance;
    }

    static
    BOOL                HasInstance( VOID )
    {
        return ( ms_pInstance != NULL );
    }

    HRESULT             ModifyTokenForOop
                        ( 
                            HANDLE hThreadToken
                        );

private:

    CWamOopTokenInfo()
        : m_pIWAMUserSid( NULL ),
          m_cbIWAMUserSid( 0 ),
          m_pSystemSid( NULL ),
          m_cbSystemSid( 0 )
    {
    }

    ~CWamOopTokenInfo()
    {
        DBG_ASSERT( m_pIWAMUserSid );
        if( m_pIWAMUserSid )
        {
            LocalFree( m_pIWAMUserSid );
        }
    
        DBG_ASSERT( m_pSystemSid );
        if( m_pSystemSid )
        {
            LocalFree( m_pSystemSid );
        }
    }

    HRESULT             SetIWAMUserSid
                        (
                             PSID pSid 
                        );
    
    HRESULT             SetSystemSid
                        ( 
                            PSID pSid 
                        );

private:

    PSID    m_pIWAMUserSid;
    DWORD   m_cbIWAMUserSid;

    PSID    m_pSystemSid;
    DWORD   m_cbSystemSid;

    static CWamOopTokenInfo * ms_pInstance;
};

#endif _OOP_TOKEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\ooptoken.cpp ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
       ooptoken.cpp

   Abstract:
       Implementation of the CWamOopTokenInfo object

   Author:
       Taylor Weiss    ( TaylorW )     15-Feb-1999

   Environment:
       User Mode - Win32

   Project:
       iis\svcs\wam\object

--*/

#include <isapip.hxx>
#include "ooptoken.h"

/************************ CWamOopTokenInfo ****************************/

CWamOopTokenInfo * CWamOopTokenInfo::ms_pInstance = NULL;

HRESULT
CWamOopTokenInfo::Create( VOID )
/*++
Routine Description:

    Create and initialize ms_pInstance. Get the wam and system SIDs.

    The IWAM_* user sid is obtained from the process token. This
    only works if we are running OOP. The alternative is to put this
    in w3svc or infocomm and get the SID from the metabase. The downside
    to that is the account for the application package is exposed
    through the com+ UI, so it can be changed without a metabase update.

Parameters

Return Value

    HRESULT

--*/
{
    DBG_ASSERT( CWamOopTokenInfo::ms_pInstance == NULL );
    
    HRESULT             hr = NOERROR;
    HANDLE              hProcessToken = NULL;
    LPVOID              pvUserBuffer = NULL;
    PSID                pSidSys = NULL;
    CWamOopTokenInfo *  pInstance = NULL;

    do
    {
        BOOL            fNoError = FALSE;
        DWORD           cbUserBuffer = 0;

        // Allocate instance
        pInstance = new CWamOopTokenInfo();

        DBG_ASSERT( pInstance != NULL );
        if( !pInstance )
        {
            DBG_ASSERT( pInstance );
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Get a SID for the IWAM_* user.
        //
        fNoError = OpenProcessToken( GetCurrentProcess(), 
                                     TOKEN_QUERY, 
                                     &hProcessToken 
                                     );
        if( !fNoError )
        {
            DBG_ASSERT( fNoError );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        // Get buffer size
        fNoError = GetTokenInformation(  hProcessToken,
                                         TokenUser,
                                         NULL,
                                         0,
                                         &cbUserBuffer
                                         );
        DBG_ASSERT( fNoError == FALSE );

        pvUserBuffer = LocalAlloc( LPTR, cbUserBuffer );
        DBG_ASSERT( pvUserBuffer != NULL );
        if( !pvUserBuffer )
        {
            DBG_ASSERT( pvUserBuffer );
            hr = E_OUTOFMEMORY;
            break;
        }

        // Get user info
        fNoError = GetTokenInformation(  hProcessToken,
                                         TokenUser,
                                         pvUserBuffer,
                                         cbUserBuffer,
                                         &cbUserBuffer
                                         );
        if( !fNoError )
        {
            DBG_ASSERT( fNoError );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        hr = pInstance->SetIWAMUserSid( ((TOKEN_USER *)pvUserBuffer)->User.Sid );
        if( FAILED(hr) ) break;

        //
        // Create a SID for the local system
        //
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY; 
        fNoError = AllocateAndInitializeSid( &siaNtAuthority,
                                             1,
                                             SECURITY_LOCAL_SYSTEM_RID,
                                             0, 0, 0, 0, 0, 0, 0,
                                             &pSidSys
                                             );
        if( !fNoError )
        {
            DBG_ASSERT( fNoError );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        hr = pInstance->SetSystemSid( pSidSys );
        if( FAILED(hr) ) break;

        CWamOopTokenInfo::ms_pInstance = pInstance;
    
    } while( FALSE );

    if( hProcessToken )
    {
        CloseHandle( hProcessToken );
    }
    if( pvUserBuffer )
    {
        LocalFree( pvUserBuffer );
    }
    if( pSidSys )
    {
        FreeSid( pSidSys );
    }
    if( CWamOopTokenInfo::ms_pInstance == NULL )
    {
        // We hit some break, need to dealloc local pointer
        delete pInstance;
    }

    DBG_ASSERT( CWamOopTokenInfo::ms_pInstance != NULL );
    DBG_ASSERT( SUCCEEDED(hr) );

    return hr;
}

HRESULT
CWamOopTokenInfo::SetIWAMUserSid( PSID pSid )
/*++
Routine Description:

    Make a local copy of the SID. Called during instance create.
    
    Probably should avoid the extra duplication.

Parameters

    pSid        - The IWAM_* user sid.

Return Value

    HRESULT

--*/
{
    DBG_ASSERT( pSid );
    DBG_ASSERT( m_pIWAMUserSid == NULL );
    DBG_ASSERT( m_cbIWAMUserSid == 0 );

    HRESULT hr = NOERROR;

    m_cbIWAMUserSid = GetLengthSid( pSid );
    
    m_pIWAMUserSid = LocalAlloc( LPTR, m_cbIWAMUserSid );

    if( m_pIWAMUserSid )
    {
        if( !CopySid( m_cbIWAMUserSid, m_pIWAMUserSid, pSid ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        m_cbIWAMUserSid = 0;
    }

    DBG_ASSERT( m_pIWAMUserSid );
    DBG_ASSERT( m_cbIWAMUserSid > 0 );
    DBG_ASSERT( SUCCEEDED(hr) );

    return hr;
}

HRESULT
CWamOopTokenInfo::SetSystemSid( PSID pSid )
/*++
Routine Description:

    Make a local copy of the SID. Called during instance create.
    
    Probably should avoid the extra duplication.

Parameters

    pSid        - The system sid.

Return Value

    HRESULT

--*/
{
    DBG_ASSERT( pSid );
    DBG_ASSERT( m_pSystemSid == NULL );
    DBG_ASSERT( m_cbSystemSid == 0 );

    HRESULT hr = NOERROR;

    m_cbSystemSid = GetLengthSid( pSid );
    
    m_pSystemSid = LocalAlloc( LPTR, m_cbSystemSid );

    if( m_pSystemSid )
    {
        if( !CopySid( m_cbSystemSid, m_pSystemSid, pSid ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        m_cbSystemSid = 0;
    }

    DBG_ASSERT( m_pSystemSid );
    DBG_ASSERT( m_cbSystemSid > 0 );
    DBG_ASSERT( SUCCEEDED(hr) );

    return hr;
}


HRESULT
CWamOopTokenInfo::ModifyTokenForOop
( 
HANDLE hThreadToken
)
/*++
Routine Description

    Add the IWAM_* ace to the token.

Prameters

    HANDLE hThreadToken         - The token to modify.

Return Value

    HRESULT

--*/
{
    DBG_ASSERT( m_pIWAMUserSid );
    DBG_ASSERT( m_pSystemSid );

    HRESULT     hr = NOERROR;

    DWORD       cbTokenUserBuffer = 0;
    LPVOID      pvTokenUserBuffer = NULL;
    
    DWORD       cbNewAcl = 0;
    PACL        pNewAcl = NULL;

    do
    {
        BOOL    bRet;

        //
        // Get the User SID from the token
        //

        // Get buffer size
        bRet = GetTokenInformation(  hThreadToken,
                                     TokenUser,
                                     NULL,
                                     0,
                                     &cbTokenUserBuffer
                                     );
        DBG_ASSERT( bRet == FALSE );

        pvTokenUserBuffer = LocalAlloc( LPTR, cbTokenUserBuffer );
        if( !pvTokenUserBuffer )
        {
            DBG_ASSERT( pvTokenUserBuffer );
            hr = E_OUTOFMEMORY;
            break;
        }

        // Get TokenUser
        bRet = GetTokenInformation(  hThreadToken,
                                     TokenUser,
                                     pvTokenUserBuffer,
                                     cbTokenUserBuffer,
                                     &cbTokenUserBuffer
                                     );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        PSID pSidUser = ((TOKEN_USER *)pvTokenUserBuffer)->User.Sid;
        
        DBG_ASSERT( pSidUser );

        //
        // Allocate and init our new ACL
        //
        cbNewAcl = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pSidUser) - sizeof(DWORD) +
                   sizeof(ACCESS_ALLOWED_ACE) + m_cbSystemSid - sizeof(DWORD) +
                   sizeof(ACCESS_ALLOWED_ACE) + m_cbIWAMUserSid - sizeof(DWORD);

        pNewAcl = (PACL)LocalAlloc( LPTR, cbNewAcl );
        if( !pNewAcl )
        {
            DBG_ASSERT( pNewAcl );
            hr = E_OUTOFMEMORY;
            break;
        }

        bRet = InitializeAcl( pNewAcl, cbNewAcl, ACL_REVISION );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        //
        // Add the aces
        //
        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    pSidUser
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    m_pSystemSid
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        bRet = AddAccessAllowedAce( pNewAcl,
                                    ACL_REVISION,
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL,
                                    m_pIWAMUserSid
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        // Blast the new DACL into our token
        TOKEN_DEFAULT_DACL tddNew;
        tddNew.DefaultDacl = pNewAcl;

        bRet = SetTokenInformation( hThreadToken,
                                    TokenDefaultDacl,
                                    &tddNew,
                                    cbNewAcl
                                    );
        if( !bRet )
        {
            DBG_ASSERT( bRet );
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

    }while(FALSE);

    if( pvTokenUserBuffer )
    {
        LocalFree( pvTokenUserBuffer );
    }
    if( pNewAcl )
    {
        LocalFree( pNewAcl );
    }

    DBG_ASSERT( SUCCEEDED(hr) );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wam.rc
//
#define IDS_PROJNAME                    100
#define IDR_WAM                         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\wam\object\isplocal.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       isplocal.cxx

   Abstract:
       This module declares the functions for Local ISAPI handler
       as well as the global table of all ISAPI applications loaded

   Author:

       Murali R. Krishnan    ( MuraliK )     17-July-1996

   Environment:

       User Mode - Win32

   Project:

       W3 Services DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <isapip.hxx>
# include <irtlmisc.h>
# include "isapidll.hxx"
# include "setable.hxx"
# include "gip.h"
# include "iwr.h"
# include "WamW3.hxx"

/************************************************************
 *     Global Data
 ************************************************************/


//
//  Generic mapping for Application access check
//

GENERIC_MAPPING sg_FileGenericMapping =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

/************************************************************
 *    Functions
 ************************************************************/

BOOL
CallChildCompletionProc(
    IN WAM_EXEC_INFO *        pWamExecInfo,
    DWORD               dwBytes,
    DWORD               dwLastError
)
/*++

Routine Description:

    Call the async IO completion routine of the child ISA.

Arguments:

    pWamExecInfo - WAM_EXEC_INFO of the child
    dwBytes - Bytes for read/write
    dwLastError - Last error (used for status of IO request)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BOOL                fRet = TRUE;

    DBG_ASSERT( pWamExecInfo->_AsyncIoInfo._pfnHseIO != NULL);

    __try
    {
        (*pWamExecInfo->_AsyncIoInfo._pfnHseIO)( &(pWamExecInfo->ecb),
                            pWamExecInfo->_AsyncIoInfo._pvHseIOContext,
                            dwBytes,
                            dwLastError );
    }
    __except ( g_fEnableTryExcept ? 
                WAMExceptionFilter( GetExceptionInformation(), 
                                    WAM_EVENT_EXTENSION_EXCEPTION,
                                    pWamExecInfo ) :
                EXCEPTION_CONTINUE_SEARCH )
    {
        fRet = FALSE;
    }

    return fRet;
}


/**************************************************
 *   Member functions of HSE_APPDLL
 **************************************************/




/* class static */
PHSE
HSE_APPDLL::LoadModule( IN const char * pchModuleName,
                      IN HANDLE       hImpersonation,
                      IN BOOL         fCache )
{
    PFN_HTTPEXTENSIONPROC   pfnSEProc;
    HMODULE                 hMod;
    PFN_GETEXTENSIONVERSION pfnGetExtVer;
    PFN_TERMINATEEXTENSION  pfnTerminate;
    HSE_VERSION_INFO        ExtensionVersion;
    HSE_APPDLL   *          pExtension = NULL;

    hMod = LoadLibraryEx( pchModuleName,
                          NULL,
                          LOAD_WITH_ALTERED_SEARCH_PATH );

    if ( hMod == NULL ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "[SEGetEntryPoint] LoadLibrary %s failed with error %d\n",
                    pchModuleName, GetLastError()));

        return NULL;
    }

    //
    // check machine type from header
    //

    LPBYTE pImg = (LPBYTE)hMod;

    //
    // skip possible DOS header
    //

    if ( ((IMAGE_DOS_HEADER*)pImg)->e_magic == IMAGE_DOS_SIGNATURE )
    {
        pImg += ((IMAGE_DOS_HEADER*)pImg)->e_lfanew;
    }

    //
    // test only if NT header detected
    //

    if ( !TsIsWindows95() ) {
        if ( *(DWORD*)pImg == IMAGE_NT_SIGNATURE
                && ( ((IMAGE_FILE_HEADER*)(pImg+sizeof(DWORD)))->Machine
                        < USER_SHARED_DATA->ImageNumberLow
                || ((IMAGE_FILE_HEADER*)(pImg+sizeof(DWORD)))->Machine
                        > USER_SHARED_DATA->ImageNumberHigh ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[SEGetEntryPoint] LoadLibrary loaded bad "
                        " format exe type %d, valid range %d-%d\n",
                        ((IMAGE_FILE_HEADER*)(pImg+sizeof(DWORD)))->Machine,
                        USER_SHARED_DATA->ImageNumberLow,
                        USER_SHARED_DATA->ImageNumberHigh
                        ));

            SetLastError( ERROR_BAD_EXE_FORMAT );
            FreeLibrary( hMod );

            return NULL;
        }
    }

    //
    //  Retrieve the entry points
    //

    pfnSEProc = (PFN_HTTPEXTENSIONPROC) GetProcAddress(
                                                       hMod,
                                                       SE_DEFAULT_ENTRY );

    pfnGetExtVer = (PFN_GETEXTENSIONVERSION) GetProcAddress(
                                                            hMod,
                                                            SE_INIT_ENTRY );
    //
    // Note that there is no harm done 
    // even if ISAPI is old and does not have TerminateExtension
    //
    
    pfnTerminate =
        (PFN_TERMINATEEXTENSION) GetProcAddress( hMod, SE_TERM_ENTRY );

    //
    // Revert our security context, so that GetExtensionVersion()
    // can be called in the system context
    //

    RevertToSelf();

    if ( !pfnSEProc  ||
         !pfnGetExtVer ||
         !pfnGetExtVer( &ExtensionVersion )) {

        DBGPRINTF(( DBG_CONTEXT,
                "SE_TABLE::LoadModule() GetExtVer failed, Error %d\n",
                GetLastError() ));

        FreeLibrary( hMod );
        return NULL;
    }

    //
    //  Re-impersonate before for Loading ACLs which is called in
    //  the constructor of HSE_APPDLL
    //

    if ( !ImpersonateLoggedOnUser( hImpersonation )) {

        DWORD dwError = GetLastError();

        //
        // since this call is not implemented on win95, ignore it.
        //

        if ( !TsIsWindows95() ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "SE_TABLE::LoadModule() Re-impersonation failed,"
                        " Error %d\n",
                        GetLastError() ));

            //
            // tell the extension that we are shutting down :(
            //

            if ( pfnTerminate ) {
                pfnTerminate( HSE_TERM_MUST_UNLOAD );
            }

            FreeLibrary( hMod);
            SetLastError( dwError);
            return ( NULL);
        }
    }

    pExtension = new HSE_APPDLL( pchModuleName,
                               hMod,
                               pfnSEProc,
                               pfnTerminate,
                               fCache );

    if ( !pExtension  || !pExtension->IsValid()) {

        if ( pfnTerminate ) {
            pfnTerminate( HSE_TERM_MUST_UNLOAD );
        }

        if ( pExtension != NULL) {
            delete pExtension;
            pExtension = NULL;
        }

        FreeLibrary( hMod );
        return NULL;
    }

    DBGPRINTF(( DBG_CONTEXT,
                "SE_TABLE::LoadModule() Loaded extension %s, "
                " description \"%s\"\n",
                pchModuleName,
                ExtensionVersion.lpszExtensionDesc ));

    return ( (HSE_BASE * ) pExtension);
} // HSE_APPDLL::LoadModule()





HSE_APPDLL::~HSE_APPDLL(VOID)
{
    Unload();
    
    if ( _hMod) {
        DBG_REQUIRE( FreeLibrary( _hMod ) );
        _hMod = NULL;
    }

} // HSE_APPDLL::~HSE_APPDLL()



BOOL
HSE_APPDLL::LoadAcl(VOID)
{
    DWORD cbSecDesc = _buffSD.QuerySize();

    DBG_ASSERT( IsValid());

    //
    //  Force an access check on the next request
    //

    SetLastSuccessfulUser( NULL );

    //
    // Chicago does not have GetFileSecurity call
    //

    if ( TsIsWindows95() ) {
        return(TRUE);
    }

    if ( GetFileSecurity( QueryModuleName(),
                          (OWNER_SECURITY_INFORMATION |
                           GROUP_SECURITY_INFORMATION |
                           DACL_SECURITY_INFORMATION),
                          NULL,
                          0,
                          &cbSecDesc ))
        {
            return TRUE;
        }

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            return FALSE;
        }

TryAgain:
    if ( !_buffSD.Resize( cbSecDesc ) ||
         !GetFileSecurity( QueryModuleName(),
                           (OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION),
                           _buffSD.QueryPtr(),
                           cbSecDesc,
                           &cbSecDesc ))
        {
            //
            //  A new ACL may have been written since we checked the old
            //  one, so try it again
            //

            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    goto TryAgain;
                }

            return FALSE;
        }

    return TRUE;
} // HSE_APPDLL::LoadAcl()




BOOL
HSE_APPDLL::AccessCheck( IN HANDLE hImpersonation,
                         IN BOOL   fCacheImpersonation
                         )
{
    BOOL          fRet = TRUE;

    // NOTE we call IsKindaValid() because caller may dereference before calling us
    // (causing IsValid() to return false).
    DBG_ASSERT( IsKindaValid() );

    //
    //  Optimize for the anonymous user and only do the access
    //  check if this is a different user then the last successful
    //  user
    //

    if ( !TsIsWindows95() ) {
        if ( !fCacheImpersonation ||
             (hImpersonation != QueryLastSuccessfulUser())  ) {

            DWORD         dwGrantedAccess;
            BYTE          PrivSet[400];
            DWORD         cbPrivilegeSet = sizeof(PrivSet);
            BOOL          fAccessGranted;

            fRet = ( ::AccessCheck( QuerySecDesc(),
                                    hImpersonation,
                                    FILE_GENERIC_EXECUTE,
                                    &sg_FileGenericMapping,
                                    (PRIVILEGE_SET *) &PrivSet,
                                    &cbPrivilegeSet,
                                    &dwGrantedAccess,
                                    &fAccessGranted )
                     && fAccessGranted);
            if ( fRet && fCacheImpersonation )  {
                SetLastSuccessfulUser( hImpersonation );
            }
        }

    }

    return ( fRet);

} // HSE_APPDLL::AccessCheck()



DWORD
HSE_APPDLL::ExecuteRequest(
    WAM_EXEC_INFO *       pWamExecInfo
    )
{
    DWORD   dwIsaRet;   // return value from ISA

    DBG_ASSERT( pWamExecInfo );

    EXTENSION_CONTROL_BLOCK * pecb = &(pWamExecInfo->ecb);

    pecb->GetServerVariable= GetServerVariable;
    pecb->WriteClient      = WriteClient;
    pecb->ReadClient       = ReadClient;
    pecb->ServerSupportFunction = ServerSupportFunction;


    DBG_ASSERT( IsValid());

    // addref the context before we hand it to ISA
    pWamExecInfo->AddRef();

    IF_DEBUG( WAM_FILENAMES ) {

        DBGPRINTF(( DBG_CONTEXT, "Dll: %s\tScript: %s\n",
                    WRC_GET_SZ( WRC_I_ISADLLPATH ),
                    WRC_GET_SZ( WRC_I_PATHINFO ) ));
    }

    DBG_WAMREQ_REFCOUNTS(( "HSE_APPDLL::ExecuteRequest before ISA call ...", pWamExecInfo ));

    // call the extension proc ...
    dwIsaRet = ( _pfnEntryPoint( pecb ) );

    // release the context upon return from ISA
    pWamExecInfo->Release( );

    DBG_WAMREQ_REFCOUNTS(( "HSE_APPDLL::ExecuteRequest after ISA call ...", pWamExecInfo ));

    return dwIsaRet;

} // HSE_APPDLL::ExecuteRequest()





BOOL
HSE_APPDLL::Cleanup(VOID)
{

    return (TRUE);

} // HSE_APPDLL::Cleanup()


DWORD
HSE_APPDLL::Unload(VOID)
{
    // Unload can be called before the ref count hits zero
    // This will force all the requests inside ISAPI DLL to exit
    //    DBG_ASSERT( RefCount() == 0);

    DBG_REQUIRE( Cleanup());

    if ( _pfnTerminate ) {

        //
        // From the old code :(
        //  The return value from Terminate() is ignored!
        //
        _pfnTerminate( HSE_TERM_MUST_UNLOAD );
        _pfnTerminate = NULL;
    }

    SetValid( FALSE);

    return (NO_ERROR);

} // HSE_APPDLL::Unload()



/*-----------------------------------------------------------------------------*
    Support for ISAPI Callback Functions
*/


/*-----------------------------------------------------------------------------*
GetISAContext

    Gets the ISA context from the ISA-supplied connection handle.

    NOTE caller must balance calls to GetISAContext and ReleaseISAContext

    Arguments:
        See below

    Returns:
        BOOL

*/
BOOL
GetISAContext(
    IN  HCONN                       hConn,
    OUT EXTENSION_CONTROL_BLOCK **  ppecb,
    OUT WAM_EXEC_INFO **            ppWamExecInfo,
    OUT IWamRequest **              ppIWamRequest
    )
{

    IF_DEBUG( MISC ) {
        DBGPRINTF(( DBG_CONTEXT, "GetISAContext(%08x)\n", hConn ));
    }


    *ppecb = (EXTENSION_CONTROL_BLOCK *) hConn;
    *ppWamExecInfo = (WAM_EXEC_INFO *) hConn;

    DBG_ASSERT( *ppecb );
    DBG_ASSERT( *ppWamExecInfo );


    if ( !*ppecb || (*ppecb)->cbSize != sizeof(EXTENSION_CONTROL_BLOCK) ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "[GetISAContext]: Invalid ECB\r\n"));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }


    if ( !( (*ppWamExecInfo)->IsValid() ) ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "[GetISAContext]: Invalid WAM_EXEC_INFO.\r\n"));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }


    //
    //  Get iwamreq
    //
    
    if ( FAILED( (*ppWamExecInfo)->GetIWamRequest( ppIWamRequest ) ) ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "[GetISAContext]: GetIWamRequest failed.\r\n"));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Addref wamexec-info
    //

    (*ppWamExecInfo)->AddRef();

    DBG_ASSERT( *ppIWamRequest );
    return TRUE;

}   // GetISAContext



/*-----------------------------------------------------------------------------*
ReleaseISAContext

    Releases the ISA context.

    NOTE caller must balance calls to GetISAContext and ReleaseISAContext

    Arguments:
        See below

    Returns:
        Nothing

*/
VOID
ReleaseISAContext(
    OUT EXTENSION_CONTROL_BLOCK **  ppecb,
    OUT WAM_EXEC_INFO **            ppWamExecInfo,
    OUT IWamRequest **              ppIWamRequest
    )
{

    IF_DEBUG( MISC ) {

        DBGPRINTF((
            DBG_CONTEXT
            , "ReleaseISAContext(%08x)\n"
            , *ppecb
        ));

    }


    DBG_ASSERT( *ppecb );
    DBG_ASSERT( *ppWamExecInfo );
    DBG_ASSERT( *ppIWamRequest );


    //
    //  Release iwamreq - balances Get in GetISAContext
    //
    
    (*ppWamExecInfo)->ReleaseIWamRequest( *ppIWamRequest );

    //
    //  Release wamexec-info - balances Addref in GetISAContext
    //

    (*ppWamExecInfo)->Release();


    *ppIWamRequest = NULL;
    *ppWamExecInfo = NULL;
    *ppecb = NULL;

    return;

}   // ReleaseISAContext



/************************************************************
 *   ISAPI Callback Functions
 ************************************************************/




/*-----------------------------------------------------------------------------*
ServerSupportFunction

Routine Description:

    This method handles a gateway request to a server extension DLL

Arguments:

    hConn - Connection context (pointer to WAM_EXEC_INFO)
    dwHSERequest - Request type
    lpvBuffer - Buffer for request
    lpdwSize -
    lpdwDataType

Return Value:

    TRUE on success, FALSE on failure

*/
BOOL
WINAPI
ServerSupportFunction(
    HCONN               hConn,
    DWORD               dwHSERequest,
    LPVOID              lpvBuffer,
    LPDWORD             lpdwSize,
    LPDWORD             lpdwDataType
    )
{
    BOOL    fReturn = FALSE;            // this function's return value
    BOOL    fNotSupportedOOP = FALSE;   // is the hse request supported OOP?


    EXTENSION_CONTROL_BLOCK *   pecb = NULL;
    WAM_EXEC_INFO *             pWamExecInfo = NULL;
    IWamRequest *               pIWamRequest = NULL;
    HANDLE                      hCurrentUser = NULL;

    IF_DEBUG( WAM_ISA_CALLS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "ServerSupportFunction:\n\t"
                    "hConn = (%p)\t"
                    "dwHSERequest = (%p)\t"
                    "lpvBuffer = (%p)\t"
                    "lpdwSize = (%p)\t"
                    "lpdwDataType = (%p)\t"
                    "\n"
                    ,
                    hConn,
                    dwHSERequest,
                    lpvBuffer,
                    lpdwSize,
                    lpdwDataType
                    ));
    }


    //
    //  Get ISA context from connection handle - bail if bogus
    //  - if this succeeds, we have usable WAM_EXEC_INFO and IWamRequest ptrs
    //  - if this fails, GetISAContext calls SetLastError so we don't need to
    //

    if( !GetISAContext( hConn,
                        &pecb,
                        &pWamExecInfo,
                        &pIWamRequest ) ) {
        return FALSE;
    }

    if ( !pWamExecInfo->QueryPWam()->FInProcess() )
    {
        hCurrentUser = INVALID_HANDLE_VALUE;
    }

    //
    //  Fast path send response headers - will be called on almost every
    //  request
    //

    //
    //  New send-header api.  Fixes send-header/keep-alive bug.
    //  Also recommended for best performance.
    //

    if ( dwHSERequest == HSE_REQ_SEND_RESPONSE_HEADER_EX ) {

        if ( lpvBuffer == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            goto LExit;
        }

        if ( pWamExecInfo->NoHeaders() ) {

            fReturn = TRUE;
            goto LExit;
        }

        HSE_SEND_HEADER_EX_INFO * pSendHeaderExInfo = 
            reinterpret_cast<HSE_SEND_HEADER_EX_INFO *>( lpvBuffer );


        //
        //  null strings are permitted
        //  (preserves semantics of old send-header api)
        //

        DWORD   cchStatus = (
                  pSendHeaderExInfo->cchStatus
                  ? pSendHeaderExInfo->cchStatus + 1
                  : pSendHeaderExInfo->pszStatus
                    ? lstrlen( pSendHeaderExInfo->pszStatus ) + 1
                    : 0
                );

        DWORD   cchHeader = (
                  pSendHeaderExInfo->cchHeader
                  ? pSendHeaderExInfo->cchHeader + 1
                  : pSendHeaderExInfo->pszHeader
                    ? lstrlen( pSendHeaderExInfo->pszHeader ) + 1
                    : 0
                );

        //
        //  set keep-conn state explicitly based on caller's boolean
        //  (since boolean itself is explicit)
        //

        if ( pSendHeaderExInfo->fKeepConn == FALSE ) {

            pWamExecInfo->_dwIsaKeepConn = KEEPCONN_FALSE;

        } else {

            pWamExecInfo->_dwIsaKeepConn = KEEPCONN_TRUE;

        }

        DoRevertHack( &hCurrentUser );

        fReturn =
        BoolFromHresult( pIWamRequest->SendHeader(
            (unsigned char *) pSendHeaderExInfo->pszStatus
            , cchStatus
            , (unsigned char *) pSendHeaderExInfo->pszHeader
            , cchHeader
            , pWamExecInfo->_dwIsaKeepConn
        ));
        
        UndoRevertHack( &hCurrentUser );

        goto LExit;
    }

    //
    //  Old send-header api, exists purely for back-compatibility
    //
    //  Not recommended because ISA has no way to communicate
    //  its keep-conn strategy to us before we send headers.
    //  We infer it from header string, which is slow.
    //

    if ( dwHSERequest == HSE_REQ_SEND_RESPONSE_HEADER ) {

        if ( pWamExecInfo->NoHeaders() ) {

            fReturn = TRUE;
            goto LExit;
        }
        

        //
        //  lpvBuffer points to status string
        //  status string is optional (null is permitted)
        //

        DWORD   cchStatus = ( 
                      lpvBuffer
                    ? lstrlen( (char *) lpvBuffer ) + 1
                    : 0
                );

        //
        //  lpdwDataType points to header string
        //  header string is optional (null is permitted)
        //

        DWORD   cchHeader = (
                      lpdwDataType
                    ? lstrlen( (char *) lpdwDataType ) + 1
                    : 0
                );


        //
        //  if status or header string contains "Content-Length:",
        //  we assume ISA wants connection kept alive.
        //
        //  NOTE we don't set keep-conn state false in opposite case,
        //  since old caller may not intend to close connection.
        //  
        //

        if ( (lpvBuffer && stristr((const char *)lpvBuffer, "Content-Length:"))
             ||
             (lpdwDataType
              && stristr((const char *)lpdwDataType, "Content-Length:"))
           ) {

            pWamExecInfo->_dwIsaKeepConn = KEEPCONN_TRUE;

        } else {

            pWamExecInfo->_dwIsaKeepConn = KEEPCONN_FALSE;

        }

        IF_DEBUG( WAM_ISA_CALLS ) {

            DBGPRINTF(( DBG_CONTEXT,
                "SSF SendHeader: "
                "Status = %s "
                "Header = %s "
                "Keep-conn = %d "
                "\n"
                , (unsigned char *) lpvBuffer
                , (unsigned char *) lpdwDataType
                , pWamExecInfo->_dwIsaKeepConn
            ));
        }

        DoRevertHack( &hCurrentUser );
    
        fReturn =
        BoolFromHresult( pIWamRequest->SendHeader(
            (unsigned char *) lpvBuffer
            , cchStatus
            , (unsigned char *) lpdwDataType
            , cchHeader
            , pWamExecInfo->_dwIsaKeepConn
        ));
        
        UndoRevertHack( &hCurrentUser );

        goto LExit;
    }


    //
    //  Handle the server extension's request
    //

    switch ( dwHSERequest ) {

    //
    // IO Completion routine is provided.
    //

    case HSE_REQ_IO_COMPLETION:

        //
        // We don't check the pointer because we dont' want to mask 
        // application coding errors
        //

        if ( lpvBuffer != NULL) {

            //
            // Set the callback function and its ecb ptr argument
            // NOTE setting the ptr seems a bit cheesy, but is probably the quickest way
            // to make new out-of-proc wam suport our old code path
            //

            pWamExecInfo->_AsyncIoInfo._pfnHseIO = (PFN_HSE_IO_COMPLETION ) lpvBuffer;
        }

        pWamExecInfo->_AsyncIoInfo._pvHseIOContext = (PVOID ) lpdwDataType;

        fReturn = TRUE;
        break;

    case HSE_REQ_TRANSMIT_FILE:

        if ( lpvBuffer == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        // NOTE lpvBuffer == pHseTfInfo
        fReturn = pWamExecInfo->TransmitFile((LPHSE_TF_INFO ) lpvBuffer);
        break;

    case HSE_REQ_ASYNC_READ_CLIENT: {

        DWORD   dwFlags;

        if ( lpvBuffer == NULL || lpdwSize == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        dwFlags = lpdwDataType ? *lpdwDataType : HSE_IO_ASYNC;

        fReturn = pWamExecInfo->AsyncReadClient( lpvBuffer,
                                  lpdwSize,
                                  dwFlags );

        break;
    }

    case HSE_REQ_SEND_URL_REDIRECT_RESP: {

        //
        //  Descrption:
        //    Send an URL  redirect message to the browser client
        //
        //  Input:
        //    lpvBuffer - pointer to buffer that contains the location to
        //               redirect the client to.
        //    lpdwSize - pointer to DWORD containing size (UnUsed)
        //    lpdwDataType - Unused
        //
        //  Return:
        //    None
        //
        //  Notes:
        //   Works In-Process and Out-Of-Process

        if ( lpvBuffer == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }


        //
        //  bug 117107: don't change keep-conn setting
        //  on redirected responses.
        //
        //  NOTE old behavior had been that we closed
        //  the connection by default
        //

        pWamExecInfo->_dwIsaKeepConn = KEEPCONN_DONT_CHANGE;

        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult(
                    pIWamRequest->SendURLRedirectResponse(
                        (unsigned char *) lpvBuffer
                    ) );
                    
        UndoRevertHack( &hCurrentUser );
                    
        break;
    } // case HSE_REQ_SEND_URL_REDIRECT_RESP:


    //
    // HSE_REQ_SEND_URL functionality is broken (especially if the URL
    // to be sent is another ISA.  In this case, we are overwriting state of
    // the parent ISA by the child )
    //
    // For now, just treat HSE_REQ_SEND_URL as a redirect.  If enough people
    // complain, then a new HTTP_REQUEST object must be created in order to
    // handle the new request.
    //

    case HSE_REQ_SEND_URL: {

        if ( lpvBuffer == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }


        //
        //  bug 117107: don't change keep-conn setting
        //  on redirected responses.
        //
        //  NOTE old behavior had been that we closed
        //  the connection by default
        //

        pWamExecInfo->_dwIsaKeepConn = KEEPCONN_DONT_CHANGE;

        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult( pIWamRequest->SendRedirectMessage( (unsigned char *) lpvBuffer ) );

        UndoRevertHack( &hCurrentUser );

        break;
    } // case HSE_REQ_SEND_URL:


    //
    //  This is an async callback from the extension dll indicating
    //  they are done with the socket
    //

    case HSE_REQ_DONE_WITH_SESSION: {

        DBG_WAMREQ_REFCOUNTS((  "ServerSupportFunction DONE_WITH_SESSION",
                                pWamExecInfo));

        //  DBG_ASSERT( pWamExecInfo->_AsyncIoInfo._dwOutstandingIO == FALSE);


        //
        //  A multi-threaded extension may indicate they
        //  are done before returning pending.
        //  Thus, we always return success.
        //

        fReturn = TRUE;

        //
        //  Remember if the ISA wanted to keep the session open
        //

        if ( lpvBuffer &&
             *((DWORD *) lpvBuffer) == HSE_STATUS_SUCCESS_AND_KEEP_CONN ) {

            pWamExecInfo->_dwIsaKeepConn = KEEPCONN_TRUE;
        }

        //
        // FDisconnected is only true for ASP when it is sending a buffered
        // oop response. That call has already been made when we
        // get here and the flag is either set (cleanup has already
        // happened) or not (cleanup needs to happen here)
        //
        if( !pWamExecInfo->FDisconnected() )
        {
            //
            //  Figure out whether mainline thread or this callback thread
            //  hit its cleanup code first.
            //
            //  This protects somewhat against isapis that disobey the async 
            //  rules. The isapi should be in one of two modes:
            //
            //  1. It return HSE_STATUS_PENDING in the mainline thread and 
            //  always calls HSE_DONE_WITH_SESSION.
            //
            //  2. It returns any other status code from the mainline and
            //  NEVER calls HSE_DONE_WITH_SESSION.
            //
            //  Unfortunately isapi writers frequently do bad things to good
            //  servers. This code will prevent an AV (accessing a deleted
            //  ecb when the isapi calls HSE_DONE_WITH_SESSION from the
            //  the mainline thread. If the call occurs on another thread
            //  then all bets are off and only thread scheduling can save
            //  us.
            //
            //  This protection was disabled for a while, but some internal
            //  ISAPI writers were having problems.
            //
            //  NOTE return value is initial value of the destination
            //

            LONG FirstThread = INTERLOCKED_COMPARE_EXCHANGE(
                                    (LONG *) &pWamExecInfo->_FirstThread
                                    , (LONG) FT_CALLBACK
                                    , (LONG) FT_NULL
                                );

            if( FirstThread == (LONG) FT_NULL )
            {
                // Do nothing. Save the final release for the
                // mainline thread.
                ;
            }
            else
            {
                //
                //  Mainline thread executed first, so this callback thread
                //  now must cleanup the wamreq and release wamexecinfo.
                //
                DoRevertHack( &hCurrentUser );

                pIWamRequest->CleanupWamRequest(
                    (unsigned char*) pecb->lpszLogData
                    , lstrlen( pecb->lpszLogData ) + 1
                    , pecb->dwHttpStatusCode
                    , pWamExecInfo->_dwIsaKeepConn
                );
            
                UndoRevertHack( &hCurrentUser );

                pWamExecInfo->Release( );
            }
        }
        else
        {
            // we do need to release even if asp is disconnected
            pWamExecInfo->Release( );
        }

        break;
    } // case HSE_REQ_DONE_WITH_SESSION:

    case HSE_REQ_EXECUTE_CHILD: {
    
        //
        //  Descrption:
        //    SSI Execute functions
        //
        //  Input:
        //    lpvBuffer        - pointer to the URL (or Command string)
        //                   to be executed.
        //    lpdwSize     - NULL or points to verb to do request under
        //    lpdwDataType - Points to DWORD containing flags
        //
        //    Flags (OR'd) and their meanings:
        //
        //      HSE_EXEC_NO_HEADERS - When set, suppresses sending of the
        //                            child request's headers. Needed to 
        //                            be set if the parent request sends
        //                            its own headers.
        //
        //      HSE_EXEC_COMMAND    - When set, lpvBuffer contains command
        //                            string to execute, as opposed to URL.
        //                            SSINC uses it for <!--#EXEC CMD=...
        //
        //      HSE_EXEC_NO_ISA_WILDCARDS
        //                          - When set, disables wildcard ISAPI
        //                            file extension mapping during the
        //                            child execution. DAVFS sets this flag
        //                            to avoid recursions.
        //
        //      HSE_EXEC_CUSTOM_ERROR
        //                          - Set to indicate that this is a custom
        //                            error URL.  DAV code uses this junk.
        //
        //  Return:
        //    TRUE = SUCCESS
        //
        //  Notes:
        //    Works In-Process and Out-Of-Process
        //

        if ( lpvBuffer == NULL || lpdwDataType == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        DWORD dwExecFlags = *lpdwDataType;

        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult( pIWamRequest->SSIncExec(
                                                (unsigned char *)lpvBuffer,
                                                dwExecFlags,
                                                lpdwSize ? 
                                                (unsigned char *)lpdwSize : NULL ) );
        UndoRevertHack( &hCurrentUser );
        
        break;
        
    } // case HSE_REQ_EXECUTE_CHILD

    //
    //  These are Microsoft specific extensions
    //

    case HSE_REQ_MAP_URL_TO_PATH: {

        //
        //  Descrption:
        //    Simple api for looking up path-translated for a vroot
        //
        //  Input:
        //    lpvBuffer    - ptr to buffer which contains URL
        //                   (will contain path-translated on return)
        //    lpdwDataType - ignored
        //    lpdwSize     - ptr to buffer size
        //
        //  Return:
        //    lpvBuffer    - contains path-translated on return
        //    lpdwDataType - ignored, unchanged
        //    lpdwSize     - unchanged
        //

        DWORD   cchRequired = 0;

        if ( lpvBuffer == NULL || lpdwSize == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult( pIWamRequest->LookupVirtualRoot(
                                                    (unsigned char *) lpvBuffer,
                                                    (*lpdwSize),
                                                    &cchRequired ) );

        UndoRevertHack( &hCurrentUser );

        *lpdwSize = cchRequired;

        break;

    } // case HSE_REQ_MAP_URL_TO_PATH:


    case HSE_REQ_MAP_URL_TO_PATH_EX: {


        //
        //  Descrption:
        //    Extended api for looking up path-translated for a vroot
        //
        //  Input:
        //    lpvBuffer    - ptr to buffer which contains URL
        //    lpdwDataType - ptr to HSE_URL_MAPEX_INFO struct (see iisext.x)
        //    lpdwSize     - (optional) ptr to buffer size
        //
        //  Return:
        //    lpvBuffer    - unchanged
        //    lpdwDataType - ptr to HSE_URL_MAPEX_INFO struct, which now has
        //                   its parameters filled in
        //    lpdwSize     - if supplied, ptr to size of returned buffer
        //                   within HSE_URL_MAPEX_INFO struct
        //

        DWORD   cchRequired = 0;
        HSE_URL_MAPEX_INFO * purlmap = (HSE_URL_MAPEX_INFO *) lpdwDataType;

        if ( lpvBuffer == NULL || lpdwDataType == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult( pIWamRequest->LookupVirtualRootEx(
                        (unsigned char *) lpvBuffer,            // [in] szURL
                        (unsigned char *)purlmap->lpszPath, // [out] pchBuffer
                        sizeof( purlmap->lpszPath ),
                        &cchRequired,
                        &purlmap->cchMatchingPath,
                        &purlmap->cchMatchingURL,
                        &purlmap->dwFlags ) );

        UndoRevertHack( &hCurrentUser );

        if ( lpdwSize != NULL )
            {
            *lpdwSize = cchRequired;
            }

        if ( fReturn )
            {

            //
            // Bug38264 - Don't reflect a trailing backslash
            // in the URL in the cchMatchingURL value.  This
            // check must be done against the original URL in
            // lpvBuffer because the string doesn't exist in
            // any of the HSE_URL_MAPEX_INFO members.
            //

            DWORD cchOriginalURL = lstrlen( (LPSTR)lpvBuffer );
            
            if ( cchOriginalURL < purlmap->cchMatchingURL )
            {
                purlmap->cchMatchingURL = cchOriginalURL;
            }

            purlmap->dwFlags &= HSE_URL_FLAGS_MASK;
            purlmap->dwReserved1 = 0;
            purlmap->dwReserved2 = 0;

            }

        break;

    } // case HSE_REQ_MAP_URL_TO_PATH_EX:


    case HSE_REQ_ABORTIVE_CLOSE: {
        //
        //  Descrption:
        //    request an abortive close on disconnect for this connection
        //
        
        DoRevertHack( &hCurrentUser );
        fReturn = BoolFromHresult( pIWamRequest->RequestAbortiveClose() );
        UndoRevertHack( &hCurrentUser );

        break;
    } // case HSE_REQ_ABORTIVE_CLOSE

    case HSE_REQ_CLOSE_CONNECTION: {
        //
        //  Descrption:
        //    close the connection socket
        //

        DoRevertHack( &hCurrentUser );
        fReturn = BoolFromHresult( pIWamRequest->CloseConnection() );
        UndoRevertHack( &hCurrentUser );

        break;
    } // case HSE_REQ_CLOSE_CONNECTION

    case HSE_REQ_GET_CERT_INFO: {

        //
        //  this call is obsolete - use HSE_REQ_GET_CERT_INFO_EX instead
        //

        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );

        fReturn = FALSE;
        break;
    } // case HSE_REQ_GET_CERT_INFO:


    case HSE_REQ_GET_CERT_INFO_EX: {

        //
        //  Descrption:
        //    Returns the first cert in the request's cert-chain,
        //    only used if using an SSPI package
        //
        //  Input:
        //    lpvBuffer -   ISA-provided struct
        //              NOTE ISA must allocate buffer within struct
        //
        //  Notes:
        //    Works in-proc or out-of-proc
        //

        //
        // cast ISA-provided ptr to our cert struct
        //

        CERT_CONTEXT_EX *  pCertContextEx = reinterpret_cast
                                                <CERT_CONTEXT_EX *>
                                                ( lpvBuffer );

        if ( lpvBuffer == NULL ) {

            DBG_ASSERT( FALSE );

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        //
        // pass struct members as individual parameters
        //
        
        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult( pIWamRequest->GetClientCertInfoEx(
                        pCertContextEx->cbAllocated,
                        &( pCertContextEx->CertContext.dwCertEncodingType ),
                        pCertContextEx->CertContext.pbCertEncoded,
                        &( pCertContextEx->CertContext.cbCertEncoded ),
                        &( pCertContextEx->dwCertificateFlags ) ) );

        UndoRevertHack( &hCurrentUser );

        break;
    } // case HSE_REQ_GET_CERT_INFO_EX:


    case HSE_REQ_GET_SSPI_INFO: {

        //
        //  Descrption:
        //    Retrieves the SSPI context and credential handles, only used if
        //    using an SSPI package
        //
        //  Input:
        //    lpvBuffer - pointer to buffer that will contain the CtxtHandle
        //             on return
        //    lpdwSize - pointer to DWORD containing size (UnUsed)
        //    lpdwDataType - pointer to buffer that will contain the
        //             CredHandle on return
        //
        //  Return:
        //    CtxtHandle    - in *lpvBuffer
        //    CredHandle    - in *lpdwDataType
        //
        //  Notes:
        //   Works In-Process
        //   Fails out-of-process, by design
        //      (security 'handles' won't duplicate cross-process)
        //
        //
        // NOTE: ISA must ensure that lpvBuffer & lpdwDataType point to buffers
        //     of appropriate sizes sizeof(CtxtHandle) & sizeof(CredHandle)
        //

        if( !pWamExecInfo->QueryPWam()->FInProcess() ) {
            fNotSupportedOOP = TRUE;
            break;
        }

        if ( lpvBuffer == NULL || lpdwDataType == NULL ) {

            DBG_ASSERT( FALSE );

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        DoRevertHack( &hCurrentUser );
        
        fReturn = BoolFromHresult(
                    pIWamRequest->GetSspiInfo(
                        8 /* UNDONE sizeof( CtxtHandle) */
                        , (PBYTE ) lpvBuffer
                        , 8 /* UNDONE sizeof( CredHandle) */
                        , (PBYTE ) lpdwDataType
                    ));
            
        UndoRevertHack( &hCurrentUser );

        break;
    } // case HSE_REQ_GET_SSPI_INFO:


    case HSE_APPEND_LOG_PARAMETER: {

        //
        //  Descrption:
        //    Appends a certain string to the log record written out.
        //
        //  Input:
        //    lpvBuffer - string containing the log data to be appended
        //    lpdwSize - pointer to DWORD containing size (UnUsed)
        //    lpdwDataType - pointer to Data type value (Unused)
        //
        //  Return:
        //    None
        //
        //  Notes:
        //   Works Out-Of-Process & In-Process
        //   Good candidate for being marshalled into calling process.

        if ( lpvBuffer == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        DoRevertHack( &hCurrentUser );
        
        fReturn = BoolFromHresult( pIWamRequest->AppendLogParameter( (unsigned char *) lpvBuffer ) );
        
        UndoRevertHack( &hCurrentUser );
        break;

    } // case HSE_APPEND_LOG_PARAMETER:


    case HSE_REQ_REFRESH_ISAPI_ACL: {

        //
        //  Descrption:
        //    Refreshes the ACLs for the ISAPI dll specified
        //    It forces the server to re-read the ACL for the ISAPI dll
        //
        //  Input:
        //    lpvBuffer - string containing the name of the ISAPI dll
        //    lpdwSize - pointer to DWORD containing size (UnUsed)
        //    lpdwDataType - pointer to Data type value (Unused)
        //
        //  Return:
        //    None
        //
        //  Notes:
        //   This is local to the WAM process

        if ( lpvBuffer == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        fReturn = (g_psextensions->RefreshAcl( (LPSTR) lpvBuffer ));
        break;

    } // case HSE_REQ_REFRESH_ISAPI_ACL:


    case HSE_REQ_IS_KEEP_CONN: {

        //
        //  Descrption:
        //    Obtains the state if this connection is keep-alive or not.
        //
        //  Input:
        //    lpvBuffer - pointer to BOOL which will contain the state on return
        //    lpdwSize - pointer to DWORD containing size (UnUsed)
        //    lpdwDataType - pointer to Data type value (Unused)
        //
        //  Return:
        //    *lpvBuffer  contains the value (TRUE=>keep-alive, FALSE=>non-KA)
        //
        //  Notes:
        //   Works Out-Of-Process & In-Process
        //   Good candidate for being marshalled into calling process.
        //
        //   We need this function here in ServerSupportFunction
        //   (vs. fetching the BOOL up front) because a script, for example,
        //   could change the state of keep-conn then later query it.
        //

        if ( lpvBuffer == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        DBG_ASSERT( NULL != lpvBuffer );
        
        DoRevertHack( &hCurrentUser );
        
        fReturn = BoolFromHresult( pIWamRequest->IsKeepConnSet( (LPBOOL)lpvBuffer ) );
    
        UndoRevertHack( &hCurrentUser );
        break;

    } // case HSE_REQ_IS_KEEP_CONN:


    case HSE_REQ_GET_IMPERSONATION_TOKEN: {

        //
        //  Descrption:
        //    Obtains the impersonation token for the current user
        //
        //  Input:
        //    lpvBuffer - pointer to HANDLE that will contain the impersonation
        //            token on return
        //    lpdwSize - pointer to DWORD containing size (UnUsed)
        //    lpdwDataType - pointer to Data type value (Unused)
        //
        //  Return:
        //    *lpvBuffer  contains the value
        //

        if ( lpvBuffer == NULL ) {

            DBG_ASSERT( FALSE );

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        *((HANDLE *)lpvBuffer) = WRC_GET_FIX.m_hUserToken;
        fReturn = TRUE;
        break;

    } // case HSE_REQ_GET_IMPERSONATION_TOKEN:

    case HSE_REQ_GET_VIRTUAL_PATH_TOKEN: 

        //
        //  Descrption:
        //    Obtains the impersonation token for the specified virtual path
        //
        //  Input:
        //    lpvBuffer - points to virtual path for which UNC impersonation
        //                token is sought
        //    lpdwSize - points to a HANDLE which will be set on return
        //    lpdwDataType - pointer to Data type value (Unused)
        //
        //  Return:
        //    *lpdwSize  contains the token
        //

    
        if( lpvBuffer == NULL || lpdwSize == NULL ) {
            DBG_ASSERT( FALSE );
            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
        }

        DoRevertHack( &hCurrentUser );

        fReturn = BoolFromHresult( pIWamRequest->GetVirtualPathToken( 
            (unsigned char *) lpvBuffer,
#ifdef _WIN64
            (UINT64 *)lpdwSize ) );
#else
            (ULONG_PTR *)lpdwSize ) );
#endif
            
        UndoRevertHack( &hCurrentUser );
        
        break;

    case HSE_REQ_IS_CONNECTED:
        
        //
        //  Description:
        //    Attempts to determine if the if the client is still connected.
        //    Works by doing a "peek" on the socket.
        //
        //  Input:
        //    lpvBuffer - pointer to BOOL which will contain the state on return
        //    lpdwSize - pointer to DWORD containing size (UnUsed)
        //    lpdwDataType - pointer to Data type value (Unused)
        //
        //  Return:
        //    *lpvBuffer  contains the value 
        //          TRUE    connected 
        //          FALSE   socket closed or unreadable
        //

        if ( lpvBuffer == NULL ) {

            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }

        DBG_ASSERT( NULL != lpvBuffer );
        
        DoRevertHack( &hCurrentUser );
        
        fReturn = BoolFromHresult( pIWamRequest->TestConnection( (LPBOOL)lpvBuffer ) );
    
        UndoRevertHack( &hCurrentUser );
        break;
   
    case HSE_REQ_GET_EXECUTE_FLAGS:
    
        //
        //  Descrption:
        //    Gets the execute descriptor flags used for this request
        //
        //  Input:
        //    None
        //
        //  Return:
        //    *lpdwDataType contains the flags
        //
    
        if ( lpdwDataType == NULL )
        {
            DBG_ASSERT( FALSE );
            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }
        
        *lpdwDataType = pWamExecInfo->_dwChildExecFlags;
        
        fReturn = TRUE;
        break;

    case HSE_REQ_EXTENSION_TRIGGER:
        
        //
        //  Description:
        //    Notify any filters waiting on SF_NOTIFY_EXTENSION_TRIGGER
        //
        //  Input:
        //    lpvBuffer - Context pointer
        //    lpdwDataType - Points to trigger type
        //
       
        //
        // Only works in-proc.
        // 
        
        if ( !lpdwDataType )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            fReturn = FALSE;
            break;
        }
        
        if ( !pWamExecInfo->QueryPWam()->FInProcess() ) 
        {
            SetLastError( ERROR_NOT_SUPPORTED );
            fReturn = FALSE;
            break;
        }
        
        fReturn = BoolFromHresult( pIWamRequest->Extens