    out     dx,al                   ;

        mov     al,[ebx].Latch0         ;Latch 0 value
        mov     [ecx],al

        mov     al,1                    ;set plane 1
        out     dx,al                   ;

        mov     al,[ebx].Latch1         ;Latch 1 value
        mov     [ecx],al

        mov     al,2                    ;set plane 2
        out     dx,al                   ;

        mov     al,[ebx].Latch2         ;Latch 2 value
        mov     [ecx],al

        mov     al,3                    ;set plane 3
        out     dx,al                   ;

        mov     al,[ebx].Latch3         ;Latch 3 value
        mov     [ecx],al

        mov     al,[ecx]                ;load the latches!

        rol     eax,8                   ;get saved GC[4] value
        out     dx,al                   ;restore GR[4]

        dec     edx                     ;EDX --> GC index register
        rol     eax,8                   ; 
        out     dx,al                   ;restore index

        call    MiniVDD_ResetLatchBank

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_RestoreLatches
;
;
subttl          Enable and Disable BLTer Register Trapping
page +
public  MiniVDD_EnableTraps
BeginProc MiniVDD_EnableTraps, DOSVM
;
;As stated elsewhere, the VDD needs to set traps on the BLTer registers used
;by the display driver whenever it is using the off-screen memory to
;virtualize VGA graphics mode in the background or in a window.  The reason
;the VDD does this is to receive notification on the first access to a
;BLTer register AFTER returning to the Windows VM.  Then, the VDD switches
;the state of the hardware back to that appropriate for running Windows
;HiRes mode.  In this routine, all you need to do is call the VMM service
;Enable_Global_Trapping for each of the ports that you registered at
;MiniVDD_Device_Init.  Then, the VDD will receive notification at the
;proper time and will switch states properly.
;
;Entry:
;       Nothing assumed.
;Exit:
;       Just Preserve EBX, and ESI.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_EnableTraps", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_EnableTraps
;
;
public  MiniVDD_DisableTraps
BeginProc MiniVDD_DisableTraps, DOSVM
;
;See comment at EnableTraps.
;
;Entry:
;       Nothing assumed.
;Exit:
;       Just Preserve EBX and ESI.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_DisableTraps", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_DisableTraps
;
;
subttl          Set Hardware to a Not Busy State
page +
public  MiniVDD_MakeHardwareNotBusy
BeginProc MiniVDD_MakeHardwareNotBusy, DOSVM
;
;Quite often, we need to make sure that the hardware state is not busy
;before changing the MemC mode from the Windows HiRes state to VGA state
;or vice-versa.  This routine allows you to do this (to the best of your
;ability).  You should try to return a state where the hardware BLTer
;isn't busy.
;
;Entry:
;       EAX contains the CRTC owner's VM handle.
;       EBX contains the currently running VM handle.
;       ECX contains the MemC owner's VM handle.
;       EDX contains the CRTC index register.
;Exit:
;       You must save all registers that you destroy except for EAX & ECX.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_MakeHardwareNotBusy", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":CRTC:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", ecx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", edx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    edx                     ;save registers that we use for test
        cmp     eax,WindowsVMHandle     ;is CRTC VM Windows?
        jne     MHNBBoardNotBusy        ;nope, skip this entire mess!
;For NVidia, the MemC state does not affect the accelerator, so we never have
;to wait!!
; MSK - TODO - Remove this whole routine!!!!??
;
public  MHNBBoardNotBusy
MHNBBoardNotBusy:
        pop     edx                     ;restore CRTC port number
;
MHNBExit:
        ret                             ;
EndProc MiniVDD_MakeHardwareNotBusy
;
;
subttl          Display Driver Is Being Disabled Notification
page +
public  MiniVDD_DisplayDriverDisabling
BeginProc       MiniVDD_DisplayDriverDisabling, RARE
;
;The display driver is in its Disable routine and is about to set the
;hardware back into VGA text mode.  Since this could either mean that
;the Windows session is ending or that some Windows application is switching
;to a VGA mode to display something full screen (such as MediaPlayer), we
;need to disable our MiniVDD_RestoreRegisters code because we're liable
;to restore a Windows HiRes state when we shouldn't!  Thus, clear the
;DisplayEnabledFlag to prevent this:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_DisplayDriverDisabling", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        mov     DisplayEnabledFlag,0    ;don't do a RestoreRegState
        push    ax
        push    dx
;
;   tell the BIOS to program the TV encoder
        call    TellBIOSProgramTV
        pop     ax
        pop     dx       
;
;       if we are about to exit Windows to restart in DOS mode, we need to stop
;       trapping real mode access registers so the BIOS can do a mode set.

MDDDExit:
        ret                             ;
EndProc MiniVDD_DisplayDriverDisabling
;
;
subttl          Virtualize Sequencer Register Extensions
page +
public  MiniVDD_VirtSeqOut
BeginProc MiniVDD_VirtSeqOut, DOSVM
;
;This routine is called when the Sequencer or data register (3C5H) is trapped
;when a VM is being virtualized.  It gives you the opportunity to special
;case virtualization of the Sequencer registers for your particular
;device's needs.
;
;Entry:
;       AL contains the byte to output to port.
;       EBX contains the VM Handle for this Sequencer output.
;       ECX contains the Sequencer index of the port to virtualize.
;       EDX contains the physical register to write or virtualize.
;Exit:
;       AL contains the byte to output to port.
;       Set CY to tell caller that WE handled this Sequencer output.
;       Set NC to tell caller (Main VDD) to handle this Sequencer output
;               in whatever way it normally does
;       EBX, ECX, and EDX should be preserved.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VirtSeqOut", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                ;
                push    esi
                push    edi
                VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI for debugging!!!!
                Debug_Printf    ":CRTC:%08lX", edi, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                pop     edi
                pop     esi
                ;
                Debug_Printf    ":P:%04lX", edx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", ecx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                and     eax,0FFh
                Debug_Printf    ":D:%02lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     cl,006h                 ;is it Sequencer register 6?
        jne     VSOExit                 ;nope, let the main VDD handle it
        push    eax
        push    esi
        push    edi
;
; MSK - TODO - Which way???!!!!
IF 0
        ; Why did Cirrus do this?  Shouldn't we use the current VM?
        VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI
ELSE ; 0
        mov     esi,ebx
ENDIF ; 0
;
;Save the new state of SR06 here.
;
        add     esi,OurCBDataPointer    ;
        .if (al != 057h)              ;is this the unlock value?
                xor     al,al           ;signal locked
        .endif
        mov     [esi].SeqReg06,al       ;save this state
        pop     edi
        pop     esi
        pop     eax
        
        ; CANOPUS Code
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      @f
            cmp     InFullScreen, 0     ; Full screen mode ?
            jne     VSOExit                         ; yes, let VDD do I/O
@@:        
        
;JohnH
                cmp             DoNotSimulate,1                 ;if Windows exit, we should go to hardware
        jz              VSOExit                                 ;let VDD do I/O
; check VM; if we are in Windows, don't bother to do output
; else, we are in DOS, so let VDD update register

                VMMCall Test_Sys_VM_Handle              ;is it the system VM?
        jnz             VSOExit                                 ;no, let VDD do update
;JohnH
        stc                             ;we did the virtualization
        jmp     VSOExit2
;
VSOExit:
        clc                             ;tell Main VDD to handle these normally
VSOExit2:
        ret                             ;
EndProc MiniVDD_VirtSeqOut

page +
public  MiniVDD_VirtSeqIn
BeginProc MiniVDD_VirtSeqIn, DOSVM
;
;This routine is called when the Sequencer or data register (3C5H) is trapped
;when a VM is being virtualized.  It gives you the opportunity to special
;case virtualization of the Sequencer registers for your particular
;device's needs.
;
;Entry:
;       EBX contains the VM Handle for this Sequencer input.
;       ECX contains the Sequencer index of the port to virtualize.
;       EDX contains the physical register to write or virtualize.
;Exit:
;       Set CY to tell caller that we virtualized the port and AL has the value.
;       EBX, ECX, and EDX should be preserved.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VirtSeqIn", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                ;
                push    esi
                push    edi
                VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI for debugging!!!!
                Debug_Printf    ":CRTC:%08lX", edi, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                pop     edi
                pop     esi
                ;
                Debug_Printf    ":P:%04lX", edx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     cl,006h                 ;is it Sequencer register 6?
        jne     VSIExit2                ;nope, let the main VDD handle it
        push    esi
        push    edi
;
; MSK - TODO - Which way???!!!!
IF 0
        ; Why did Cirrus do this?  Shouldn't we use the current VM?
        VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI
ELSE ; 0
        mov     esi,ebx
ENDIF ; 0
;
;Save the new state of SR06 here.
;
        add     esi,OurCBDataPointer    ;
        mov     al,[esi].SeqReg06       ;get this state
        .if (al != 057h)              ;is this the unlock value?
                mov     al,1            ;signal unlocked
        .else
                xor     al,al           ;signal locked
        .endif
        stc                             ;we did the virtualization        
        pop     edi
        pop     esi
        jmp     VSIExit
VSIExit2:
        clc                             ;we did not do virtualization
VSIExit:
        ret                             ;
EndProc MiniVDD_VirtSeqIn
;
;
subttl          Virtualize CRTC Register Extensions
page +
public  MiniVDD_VirtCRTCOut
BeginProc MiniVDD_VirtCRTCOut, DOSVM
;
;This routine is called when the CRTC or data register (3C5H) is trapped
;when a VM is being virtualized.  It gives you the opportunity to special
;case virtualization of the CRTC registers for your particular
;device's needs.
;
;Entry:
;       AL contains the byte to output to port.
;       EBX contains the VM Handle for this CRTC output.
;       ECX contains the CRTC index of the port to virtualize.
;       EDX contains the physical register to write or virtualize.
;Exit:
;       AL contains the byte to output to port.
;       Set CY to tell caller that WE handled this CRTC output.
;       Set NC to tell caller (Main VDD) to handle this CRTC output
;               in whatever way it normally does
;       EBX, ECX, and EDX should be preserved.
;
; MSK - TODO - We should perhaps perform the I/O instead if the current VM is
; the CRTC owner from some registers, or if the current VM is the MemC owner
; for other registers.
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VirtCRTCOut", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                ;
                push    esi
                push    edi
                VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI for debugging!!!!
                Debug_Printf    ":CRTC:%08lX", edi, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                pop     edi
                pop     esi
                ;
                Debug_Printf    ":P:%04lX", edx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", ecx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                and     eax,0FFh
                Debug_Printf    ":D:%02lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx                     ; save EBX for later
        cmp     cl,19h                  ; CRTC extension register?
        jb      VCO_NotHandled          ; No, do normal processing

        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area

        cmp     cl,19h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_Repaint0NV,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Ah                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_Repaint1NV,al
                                        ;signal that this register is valid
        mov     [ebx].PerVMData.EXT_Repaint1NVSet,0FFh
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Bh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_FifoBurst,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Ch                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_Repaint3NV,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Dh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_WriteBank,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Eh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_ReadBank,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,20h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_FifoLowWaterMark,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,25h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_ExtraBits,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,28h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_PixelFormat,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,29h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_TVDecimation,al
        jmp     VCO_SpecialExit         ;signal we handled it
;

        ; CANOPUS TV Code
@@:
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      skip_canopus_vco1
CANOPUS_VirtCRTCOut:
        cmp     cl, bCanopusTVReg       ; Shadow register?
        jnz     @F                      ; no, check next register
        and     al, NOT TVF_INACTIVE    ; we won't save/restore bit 7 (inactive bit)
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_CanopusTVReg, al
        jmp     VCO_SpecialExit         ;signal we handled it
skip_canopus_vco1:    

@@:
        cmp     cl,2Ah                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_OverscanHigh,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,2Dh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_HorizontalExtra,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,30h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_HWCursorAddress0,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,31h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_HWCursorAddress1,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,32h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_VideoWindow0,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,33h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_VideoWindow1,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,39h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;save current value over save/restore
        mov     [ebx].PerVMData.EXT_Interlace,al
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,38h                  ; Is this the real mode control register?
        jnz     @F

        mov     [ebx].PerVMData.EXT_RealModeAccess,al
        jmp     VCO_SpecialExit         ;signal we handled it
@@:
;
; all other extended registers come here
;
        push    eax                     ; save original eax
        xchg    ah,al                   ; Save value to write in ah
        dec     edx                     ; EDX --> CRTC index register
        in      al,dx
        ror     eax,8                   ; save index, data to output moves to al

        mov     ah,al                   ; data to output to AH
        mov     al,cl                   ; index to AL for output
        out     dx,ax                   ; output the data

        rol     eax,8                   ; this puts the result in AH, AL=index
        out     dx,al                   ; restore index
        inc     edx                     ; EDX --> CRTC data register
        pop     eax                     ; restore original eax
VCO_SpecialExit:

; CANOPUS
    test nvCustomer, NVCUSTOMER_CANOPUS
    jz   VCO_Can01
;; When in full screen, always let the VDD output
        cmp     InFullScreen, 0
        jne     VCO_NotHandled

;; If Windows exit, we should go to hardware too...
        cmp     DoNotSimulate,1         
        je      VCO_NotHandled
    
; check VM; if we are in Windows, don't bother to do output
; else, let VDD update register
    VMMCall Test_Sys_VM_Handle              ;is it the system VM?
    jz             VCO_NotHandled           ;yes, let VDD do update (NOTE THIS IS OPPOSITE LOGIC FROM BELOW)
    jmp VCO_Can02    
VCO_Can01:

;JohnH
; check VM; if we are in Windows, don't bother to do output
; else, let VDD update register
                VMMCall Test_Sys_VM_Handle              ;is it the system VM?
        jnz             VCO_NotHandled                  ;no, let VDD do update
;JohnH
VCO_Can02:
        stc                             ; say we did it, so the output isn't done
        jmp     VCOExit

VCO_NotHandled:
        clc                             ;tell caller we didn't do output
VCOExit:
        pop     ebx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_VirtCRTCOut
;
;
page +
public  MiniVDD_VirtCRTCIn
BeginProc MiniVDD_VirtCRTCIn, DOSVM
;
;This routine is called when the CRTC or data register (3C5H) is trapped
;when a VM is being virtualized.  It gives you the opportunity to special
;case virtualization of the CRTC registers for your particular
;device's needs.
;
;Entry:
;       EBX contains the VM Handle for this CRTC input.
;       ECX contains the CRTC index of the port to virtualize.
;       EDX contains the physical register to write or virtualize.
;Exit:
;       Set CY to tell caller that we virtualized the port and AL has the value.
;       EBX, ECX, and EDX should be preserved.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VirtCRTCIn", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                ;
                push    esi
                push    edi
                VxDCall VDD_Get_VM_Info         ;get MemC owner VM handle in ESI for debugging!!!!
                Debug_Printf    ":CRTC:%08lX", edi, DEBLEVELMAX
                Debug_Printf    ":MemC:%08lX", esi, DEBLEVELMAX
                pop     edi
                pop     esi
                ;
                Debug_Printf    ":P:%04lX", edx, DEBLEVELMAX
                Debug_Printf    ":I:%02lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx                     ; save EBX for later
        cmp     cl,19h                  ; CRTC extension register?
        jb      VCI_NotHandled          ; No, do normal processing

        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area

        cmp     cl,19h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_Repaint0NV
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Ah                  ; Shadow register?
        jnz     @F                      ; no, check next register
;During a set mode, the NVidia BIOS first reads 01Ah, and then only changes
;some of the bits. If this is a new VM, then this saved value is 0, which
;will cause the compatible text mode bit to be cleared.  To tell if this
;is a non-initialized value, we have a flag that we set in MiniVDD_VirtCRTCOut
;and in MiniVDD_SaveRegisters.
                                        ; see if value was ever set or saved
        mov     al,[ebx].PerVMData.EXT_Repaint1NVSet
        .if (al == 0)
                mov     al,03Fh                 ; return power on value
        .else
                                                ;read saved value
                mov     al,[ebx].PerVMData.EXT_Repaint1NV
        .endif
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Bh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_FifoBurst
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Ch                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_Repaint3NV
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Dh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_WriteBank
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,1Eh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_ReadBank
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,20h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_FifoLowWaterMark
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,25h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_ExtraBits
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,28h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_PixelFormat
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,29h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_TVDecimation
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:

;
; CANOPUS TV Code
    test    nvCustomer, NVCUSTOMER_CANOPUS
    jz      VCO_can50
CANOPUS_VirtCRTCIn:
        cmp     cl, bCanopusTVReg       ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
;;   One big problem is, that the boot value initial value for a VM is always zero,
;;       and the bios only reads this register!!!
;;       So we use the bit 6 to mark if we have this bit already initialized 
;;       for the current VM or not...
        dec     dx                      ;-- first get bit 7  (inactive bit)
        mov     al, cl
        out     dx, al                  ; set index register (perhaps it's not done now)
        inc     dx                      ; restore dx
        in      al, dx                  ; 
        test    [ebx].PerVMData.EXT_CanopusTVReg, TVF_WINDOWS
        jz      VCI_TvReg               ; is an initial value, use current register state

        and     al, TVF_INACTIVE        ; because we won't save/restore it
                                        ;read saved value
        or      al, [ebx].PerVMData.EXT_CanopusTVReg
        jmp     VCI_SpecialExit         ;signal we handled it

VCI_TvReg:                              ; The VM is new, so we need to initialize the value...
        or      al, TVF_WINDOWS         ; mark value initialized
        push    ax
        and     al, NOT TVF_INACTIVE
        mov     [ebx].PerVMData.EXT_CanopusTVReg, al    ; save and return
        pop     ax
        jmp     VCI_SpecialExit         ;signal we handled it
VCO_can50:
@@:
        cmp     cl,2Ah                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_OverscanHigh
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,2Dh                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_HorizontalExtra
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,30h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_HWCursorAddress0
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,31h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_HWCursorAddress1
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,32h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_VideoWindow0
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,33h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_VideoWindow1
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,39h                  ; Shadow register?
        jnz     @F                      ; no, check next register
                                        ;read saved value
        mov     al,[ebx].PerVMData.EXT_Interlace
        jmp     VCO_SpecialExit         ;signal we handled it
;
@@:
        cmp     cl,38h                  ; Is this the real mode control register?
        jnz     @F

        mov     al,[ebx].PerVMData.EXT_RealModeAccess
        jmp     VCO_SpecialExit         ;signal we handled it
@@:
;
; all other extended registers come here
;
VCI_Physical:
        push    ecx
        push    eax
        dec     edx                     ; EDX --> CRTC index register
        in      al,dx
        ror     eax,8                   ; save index

        mov     al,cl                   ; index to AL for output
        out     dx,al                   ; set the index
        inc     edx                     ; EDX --> CRTC data register
        in      al,dx                   ; get the data register
        mov     ch,al                   ; save value we read
        dec     edx                     ; EDX --> CRTC index register

        rol     eax,8                   ; this puts the result in AH, AL=index
        out     dx,al                   ; restore index
        inc     edx                     ; EDX --> CRTC data register
        pop     eax
        mov     al,ch                   ; restore value we read
        pop     ecx
VCI_SpecialExit:
;JohnH
;               VMMCall Test_Sys_VM_Handle              ;is it the system VM?
;        jnz            VCI_NotHandled                  ;no, let VDD update
;JohnH
        stc                             ; tell caller WE did the input
        jmp     VCOExit

VCI_NotHandled:
        clc                             ;tell caller we didn't do input
VCI_Exit:
        pop     ebx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_VirtCRTCIn
;
;
IFDEF NVIDIA_COMMON
subttl          Virtualize I/O To Ports 003D0h-003D3h
page +
public  SimulateNVRead
BeginProc SimulateNVRead
; ebx = OurCBDataPointer
; eax = NV address
; returns
; eax = data
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVRead", DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":NV Address:%08lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        .if (eax == NV_PRAMDAC_PLL_COEFF_SELECT)
                mov     eax,[ebx].PerVMData.EXT_NV_PRAMDAC
        .elseif (eax == NV_PRAMDAC_VPLL_COEFF)
                mov     eax,[ebx].PerVMData.EXT_NV_VPLL_COEFF
        .elseif (eax == NV_PRAMDAC_GENERAL_CONTROL)
                mov     eax,[ebx].PerVMData.EXT_NV_PDAC_GEN_CTRL
        .elseif (eax == NV_PFB_CONFIG_0)
                mov     eax,[ebx].PerVMData.EXT_NV_PFB_CONFIG_0
        .else
                ; MSK - TODO - for debugging, we should record what
                ; the hell we were trying to read
                call    Beep
                push    esi
                                        ; if we don't know what it is
                REG_RD32(eax)           ; read the real thing
                pop     esi
        .endif
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVRead
;
;
public  SimulateNVWrite
BeginProc SimulateNVWrite
; ebx = OurCBDataPointer
; eax = NV address
; ecx = data
        ; Write Data to NV register
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVRead", DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":NV Address:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":Data:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        .if (eax == NV_PRAMDAC_PLL_COEFF_SELECT)
                mov     [ebx].EXT_NV_PRAMDAC,ecx
        .elseif (eax == NV_PRAMDAC_VPLL_COEFF)
                mov     [ebx].PerVMData.EXT_NV_VPLL_COEFF,ecx
        .elseif (eax == NV_PRAMDAC_GENERAL_CONTROL)
                mov     [ebx].PerVMData.EXT_NV_PDAC_GEN_CTRL,ecx
        .elseif (eax == NV_PFB_CONFIG_0)
                mov     [ebx].PerVMData.EXT_NV_PFB_CONFIG_0,ecx
        .else
                ; MSK - TODO - for debugging, we should record what
                ; the hell we were trying to write
                call    Beep
                push    esi
                mov     esi,eax         ; put address to write in esi
                                        ; if we don't know what it is
                REG_WR32(esi,ecx)       ; write the real thing
                pop     esi
        .endif
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVWrite
;
;
public  SimulateNVInByte
BeginProc SimulateNVInByte
; ebx = vm handle
; edx = port to read
; returns
; al = data
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVInByte", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX", edx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx
        push    ecx
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl,[ebx].PerVMData.EXT_RealModeAccess

        test    cl,NVRM_ACCESS_MASK     ; Test if windows are open
        .if (zero?)
;                xor     al,al
;                call    Beep
                        mov     al, 0ffh        ; Don't Beep!!  CANOPUS

        .else
                ;now read the proper register
                and     cl,NVRM_SELECT_MASK
                .if (cl == NVRM_ADDRESS)
                        mov     eax,[ebx].EXT_RealModeAddress
                .elseif (cl == NVRM_DATA)
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                .elseif (cl == NVRM_DATA32)
                        .if (dx < 003D2h)
                                xor     eax,eax                 ;read 0
                                mov     ax,[ebx].EXT_RealModeData32     ; load latched LSW
                        .else
;                                xor     eax,eax                 ;read 0
;                                call    Beep                    ;only low word works
                                        mov     ax, 0ffh                    ; Don't Beep!!  CANOPUS
                        .endif
                .else
                        mov     eax,02B16D065h          ; return the identifier
                .endif
                mov     cl,dl
                and     cl,003h         ; Do decode of which byte
                shl     cl,3            ; * 8
                shr     eax,cl          ; Put into lower byte
                and     eax,0FFh        ; mask        
        .endif
        pop     ecx
        pop     ebx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVInByte
;
;
public  SimulateNVInWord
BeginProc SimulateNVInWord
; Seperate SimulateNVInWord exists to allow atomic word reads to occur
; note that atomic dword reads can not occur because Windows 95 splits up
; dword i/o into word accesses.
; ebx = vm handle
; edx = port to read
; returns
; al = data
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVInWord", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX", edx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx
        push    ecx
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl,[ebx].PerVMData.EXT_RealModeAccess

        test    cl,NVRM_ACCESS_MASK     ; Test if windows are open
        .if (zero?)
                xor     al,al
                call    Beep
        .else
                ;now read the proper register
                and     cl,NVRM_SELECT_MASK
                .if (cl == NVRM_ADDRESS)
                        mov     eax,[ebx].EXT_RealModeAddress
                .elseif (cl == NVRM_DATA)
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                .elseif (cl == NVRM_DATA32)
                        .if (dx == 003D0h)
                                mov     ax,[ebx].EXT_RealModeData32     ; load latched LSW
                        .else
                                xor     eax,eax                 ;read 0
                                call    Beep                    ;only word reads from 3D0 work
                        .endif
                .else
                        mov     eax,02B16D065h          ; return the identifier
                .endif
                mov     cl,dl
                and     cl,003h         ; Do decode of which word
                shl     cl,3            ; * 8
                shr     eax,cl          ; Put into lower word
                and     eax,0FFFFh      ; mask out word
        .endif
        pop     ecx
        pop     ebx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVInWord
;
;
public  SimulateNVOutByte
BeginProc SimulateNVOutByte
; ebx = vm handle
; eax = value to be written
; edx = port to write
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVOutByte", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX:Port:%08lX:Data:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX:Data:%08lX", edx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":Data:%08lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        pushad
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl,[ebx].PerVMData.EXT_RealModeAccess

        test    cl,NVRM_ACCESS_MASK     ; Test if windows are open
        .if (!zero?)
                ;now write the proper register
                and     cl,NVRM_SELECT_MASK
                .if (cl == NVRM_ADDRESS)
                                                ; Get the dword value into eax
                        mov     edi,[ebx].EXT_RealModeAddress
                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which byte
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFh       ; make mask
                        and     eax, esi        ; make sure we only have a byte
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new byte
                                                ; Store new dword value
                        mov     [ebx].EXT_RealModeAddress,eax
                .elseif (cl == NVRM_DATA)
                        call    Beep            ; BIOS should not be writing here
                        ; but it should still write the byte if it is done
                        ; in ax = byte to write
                        ; edx = port addresss
                        ; ebx = OurCBPointer
                        push    eax             ; save byte to write
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                        mov     edi,eax         ; put original in edi
                        pop     eax             ; restore byte to write

                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which byte
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFh       ; make mask
                        and     eax, esi        ; make sure we only have a word
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new byte

                        ; Write Data to NV register
                        mov     ecx,eax
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVWrite
                .elseif (cl == NVRM_DATA32)
                        ; in al = byte to write
                        ; edx = port addresss
                        ; ebx = OurCBPointer
                        push    eax             ; save byte to write
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                        mov     edi,eax         ; put original in edi
                        pop     eax             ; restore byte to write

                        mov     di,[ebx].EXT_RealModeData32     ; load latched LSW

                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which byte
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFh       ; make mask
                        and     eax, esi        ; make sure we only have a word
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new byte

                        .if (dx < 003D2h)
                                mov     [ebx].EXT_RealModeData32,ax     ; save latched LSW
                        .else
                                ; Write Data to NV register
                                mov     ecx,eax
                                mov     eax,[ebx].EXT_RealModeAddress
                                call    SimulateNVWrite
                        .endif
                .else                   ; identifier register
                        call    Beep    ; Should not be writing here
                .endif
        .endif
        popad
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVOutByte
;
;
public  SimulateNVOutWord
BeginProc SimulateNVOutWord
; ebx = vm handle
; eax = value to be written
; edx = port to write
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVOutWord", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX:Port:%08lX:Data:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX:Data:%08lX", edx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":Data:%08lX", eax, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        pushad
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl,[ebx].PerVMData.EXT_RealModeAccess

        test    cl,NVRM_ACCESS_MASK     ; Test if windows are open
        .if (!zero?)
                ;now write the proper register
                and     cl,NVRM_SELECT_MASK
                .if (cl == NVRM_ADDRESS)
                                                ; Get the dword value into eax
                        mov     edi,[ebx].EXT_RealModeAddress
                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which word
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFFFh     ; make mask
                        and     eax, esi        ; make sure we only have a word
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new word
                                                ; Store new dword value
                        mov     [ebx].EXT_RealModeAddress,eax

                .elseif (cl == NVRM_DATA)
                        call    Beep            ; BIOS should not be writing here
                        ; but it should still write the word if it is done
                        ; in ax = byte to write
                        ; edx = port addresss
                        ; ebx = OurCBPointer
                        push    eax             ; save word to write
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVRead
                        mov     edi,eax         ; put original in edi
                        pop     eax             ; restore word to write

                        mov     cl, dl
                        and     cl, 003h        ; Do decode of which word
                        shl     cl, 3           ; * 8
                        mov     esi, 0FFFFh     ; make mask
                        and     eax, esi        ; make sure we only have a word
                        shl     esi, cl
                        not     esi
                        and     edi, esi        ; Mask out value
                        shl     eax, cl         ; Put byte into proper place
                        or      eax, edi        ; Insert new byte

                        ; Write Data to NV register
                        mov     ecx,eax
                        mov     eax,[ebx].EXT_RealModeAddress
                        call    SimulateNVWrite
                .elseif (cl == NVRM_DATA32)
                        ; in ax = word to write
                        ; edx = port addresss
                        ; ebx = OurCBPointer
                        .if ((dx == 003D1h) || (dx == 003D3h))
                                call    Beep            ; only aligned accesses do anything!
                        .elseif (dx == 003D0h)
                                mov     [ebx].EXT_RealModeData32,ax     ; save latched LSW
                        .else
                                mov     cx,ax
                                shl     ecx,16          ; put word into upper half
                                mov     cx,[ebx].EXT_RealModeData32     ; load latched LSW

                                ; Write Data to NV register
                                mov     eax,[ebx].EXT_RealModeAddress
                                call    SimulateNVWrite
                        .endif
                .else                   ; identifier register
                        call    Beep    ; Should not be writing here
                .endif
        .endif
        popad
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc SimulateNVOutWord
;
;
public  MiniVDD_VirtualRealModeAccess
BeginProc MiniVDD_VirtualRealModeAccess
;
;NVidia has a 32-bit wide port at 003D0h that allows access to the NV register
;space.  This routine virtualizes access to that port.
;NOTE:  The VDD chops up all accesses into bytes. Since our ports support word access,
;               we must remember the first byte until we get the second byte, and put them
;               together to do the actual I/O.
;
;Entry:
;       EAX contains value to be written to port.
;       EBX contains the VM Handle for which this I/O is being done.
;       ECX contains the I/O type flags (see VMM.INC for details).
;       EDX contains the port number.
;Exit:
;       CY clear means that we didn't handle the I/O (let caller do it).
;               -- All registers MUST be preserved in this case.
;       CY set means that we handled the I/O completely.
;               -- Preserve EBX only in this case.
;       EAX contains result of an IN operation.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SimulateNVOutByte", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Port:%08lX", edx, DEBLEVELMAX
                pop     eax
                ;
                push    eax
                Debug_Printf    ":Data:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":Type:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        cmp     edx,03D0h               ;are we interested?
        jb      MVBINotInterested       ;below 03D0h, so no
        cmp     edx,03D3h               ;are we interested?
        ja      MVBINotInterested       ;above 03D3h, so no
        cmp     ecx,BYTE_OUTPUT         ;doing an OUT from a byte?
        je      MVBIByteOutput          ;yes! go handle it!
        cmp     ecx,WORD_OUTPUT         ;doing an OUT from a word?
        je      MVBIWordOutput          ;yes! go handle it!
        cmp     ecx,BYTE_INPUT          ;doing an IN from a byte?
        je      MVBIByteInput           ;yes! go handle it!
        cmp     ecx,WORD_INPUT          ;doing an IN from a word?
        jne     MVBINotInterested       ;nope, we're not interested!
;
public  MVBIWordInput
MVBIWordInput:
        cmp     edx,003D2h              ;do we do the full word
        jle     MVBIWordInputTotal
        call    SimulateNVInByte        ;simulate in byte
        jmp     MVBIWeHandledIt         ;done, (003D4h gets ignored)
public  MVBIWordInputTotal                
MVBIWordInputTotal:
        call    SimulateNVInWord        ;simulate in word
        jmp     MVBIWeHandledIt         ;and pretend that we handled it
;
public  MVBIWordOutput
MVBIWordOutput:
        cmp     edx,003D2h
        jle     MVBIInRange
        call    SimulateNVOutByte       ;only do the byte at 003D3h
        jmp     MVBIWeHandledIt         ;done, (003D4h gets ignored)
MVBIInRange:
        call    SimulateNVOutWord       ;simulate out word
        jmp     MVBIWeHandledIt         ;and pretend that we handled it

;--------------------------------------------------------------------------------------------
;BYTE INPUT of real mode access register (3d0-3d3)
;the VDD splits up our word accesses into bytes.
;input word and return the appropriate byte.
;JohnH
public  MVBIByteInput
MVBIByteInput:

; CANOPUS Check for TV fullscreen
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      MVBIBI_can01
        
            cmp InFullScreen, 0         ; Full screen mode ?
            jne @f

        ;If we are not windowed, we may need to do actual I/O
        VMMCall Test_Sys_VM_Handle              ;is it the system VM?
        jnz     SimNvInByte             ;No, simulate (we are windowed)
        jmp @f
MVBIBI_can01:        

        cmp             DoNotSimulate,1                 ;if Windows exit, we should go to hardware
        je              @f              
;If we are not windowed, we may need to do actual I/O
        VMMCall Test_Sys_VM_Handle              ;is it the system VM?
        jz              SimNvInByte                             ;yes, simulate (we are windowed)
@@:     push    dx
;do the input and return the byte referenced
                push    dx
        and             dl,0feh                                 ;input word (from even port)
        in              ax,dx
        pop             dx
        bt              dx,0                                    ;high or low byte?
        jnc             ByteInDone
        shr             ax,8
ByteInDone:
                pop             dx
        jmp             MVBIWeHandledIt                 ;return with word in ax if second byte
SimNvInByte:
        call    SimulateNVInByte        ;simulate in byte
        jmp             MVBIWeHandledIt
        
;--------------------------------------------------------------------------------------------
;BYTE OUTPUT of real mode access register (3d0-3d3)
;the VDD splits up our word accesses into bytes.
;We need to check for consecutive accesses to a word register and put the bytes back together.
;We also need to save valid real-mode access sequences to the per-VM data area.
;The sequence is: 
;       write access mode (address) at CRTC 38.
;       write NV ptr at 3d2, 3d0. 
;       write access mode (data) at CRTC 38
;       write NV data at 3d2, 3d0. 
;We must save the address and data so we can check for interesting addresses
;and write the data to the per-VM data area.
public  MVBIByteOutput
MVBIByteOutput:

        ; CANOPUS TV Check
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      MVBIBO_can01

            cmp     InFullScreen, 0             ; Full screen mode ?
            jne     @f
        cmp     DoNotSimulate,1     ;if Windows exit, we should go to hardware
        je      @f              
        VMMCall Test_Sys_VM_Handle  ;is it the system VM?
            jnz     SimNvOutByte                ;No, simulate (we are windowed)
        jmp     @f

MVBIBO_can01:
        cmp             DoNotSimulate,1                 ;if Windows exit, we should go to hardware
        je              @f              
        VMMCall         Test_Sys_VM_Handle              ;is it the system VM?
        jz              SimNvOutByte                    ;yes, simulate (we are windowed)
;If we are not windowed, we may need to do actual I/O
@@:     push    ax
        push    cx
        push    dx
        bt              dx,0                                    ;second byte (possibly)
        jnc             FirstByteOut                    ;jmp if even
        cmp             dx,LastByteOutAddr              ;second byte of same register?
        jnz             ByteOutDone                             ;no, operation is useless                

;ODD address. second byte of the word
                shl             ax,8
        mov             al,LastByteOut
                dec             dx                                              ;back to even addr
        out             dx,ax                                   ;do I/O
;save data in temp array until we have address and data
                push    ebx
                xor             ebx,ebx
                mov             bl,rmState
                cmp             bl,3
        ja              @f                                              ;something is wrong
                shl             bx,1                                    ;word index
                mov             word ptr rmArray[ebx],ax        ;save it, address in low dword, data in high dword
                shr             bx,1
@@:             pop             ebx
        cmp             rmState,3                               ;all 4 words done? (data must be after address)
        jne             ByteOutDone                             ;no, wait for more

;we have all 8 bytes of address/data. save data in register data area
        mov             rmState,0                               ;start over
                ; bx = vm handle
                call    SaveNVPrivReg                   ;sort it out and write it to per VM data area
                xor             ax,ax
        mov             LastByteOutAddr,ax              ;clear out address to end cycle
        mov             LastByteOut,al
                jmp             ByteOutDone        

FirstByteOut:
;EVEN address. check for address/data sequence
;set state: 0=lsw of address, 1=msw of address, 2=lsw of data, 3=msw of data
        call    getAccessState
                cmp             cl,3                                    ;NV ptr?
                jne             @f
        mov             rmState,0                               ;flag address sequence
                jmp             mswlsw                                  ;first or second word?
@@:             cmp             cl,7
                je              @f
                cmp             cl,5
                jne     ignore
@@:             mov             rmState,2                               ;flag data sequence
                jmp             mswlsw
ignore:
                mov             rmState,4                               ;ignore
                jmp             SaveEven

;check MSW or LSW                        
;we're assuming LSW comes first. Can this get us in trouble? rmState is used to index into the array where we save it.
mswlsw: cmp             dx,3d0h                                 ;lsw?
        jz              SaveEven
                inc             rmState                                 ;msw, bump state

;save data and port until next byte comes thru
SaveEven:
                inc     dx
                mov             LastByteOutAddr,dx
        mov             LastByteOut,al
ByteOutDone:
                pop             dx
                pop             cx
        pop             ax
        jmp             MVBIWeHandledIt
        
SimNvOutByte:
        call    SimulateNVOutByte       ;simulate out byte
;
public  MVBIWeHandledIt
MVBIWeHandledIt:
        stc                             ;return that we handled it
        jmp     MVBIExit                ;and return IN data in AL/AX to caller
;
public  MVBINotInterested
MVBINotInterested:
        clc                             ;return to let caller handle it!
;
MVBIExit:
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_VirtualRealModeAccess
;--------------------------------------------------------------------------------------------
;
;               get the access state bits for realmode access registers
;EXIT:  cl = access state
BeginProc               GetAccessState
                push    dx
                push    ax
        ;
        ; CANOPUS TV Check
        test    nvCustomer, NVCUSTOMER_CANOPUS
        jz      GAS_direct                
         
        VMMCall Test_Sys_VM_Handle      ;is it the system VM?
        jz      GAS_direct              ;yes, get the current state

;// We also need to virtualize this register... ;)
GAS_virtual:
        push    ebx
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        mov     cl, [ebx].PerVMData.EXT_RealModeAccess
        pop     ebx
        and     cl, 07h
        jmp     GAS_end

GAS_direct:
                
        call    GetCRTCPort
        in              al,dx           ;read crtc index
        mov             ch,al
        mov             al,38h          ;access bits in reg 38h
        out             dx,al
        inc             dx
        in              al,dx           ;read access state
                and             al,7
                mov             cl,al           ;save access state for return
        mov             al,ch           ;restore crtc index
        dec             dx
        out             dx,al           ;restore crtc index
        
GAS_end:        
        pop             ax
        pop             dx
        ret        
EndProc                 GetAccessState

;--------------------------------------------------------------------------------------------
;               save data written to critical NV register in the per-VM CB
;Entry: EBX = VM handle
BeginProc               SaveNVPrivReg
                push    ebx
        add     ebx,OurCBDataPointer            ;EBX --> CRTC's CB data
;if the address is one of our 4 interesting registers, save the data
                mov             eax, dword ptr NvData
                cmp             dword ptr NvPtr,NV_PRAMDAC_VPLL_COEFF
        jne             @f
        mov     [ebx].PerVMData.EXT_NV_VPLL_COEFF,eax
                jmp             nv_save_done
@@:             cmp             dword ptr NvPtr,NV_PRAMDAC_PLL_COEFF_SELECT
                jne             @f
        mov     [ebx].PerVMData.EXT_NV_PRAMDAC,eax
                jmp             nv_save_done
@@:             cmp             dword ptr NvPtr,NV_PRAMDAC_GENERAL_CONTROL
                jne             @f
        mov     [ebx].PerVMData.EXT_NV_PDAC_GEN_CTRL,eax
                jmp             nv_save_done
@@:             cmp             dword ptr NvPtr,NV_PFB_CONFIG_0
                jne             nv_save_done
        mov     [ebx].PerVMData.EXT_NV_PFB_CONFIG_0,eax
      
nv_save_done:
                pop             ebx
                ret
EndProc                 SaveNVPrivReg

;
ENDIF ; NVIDIA_COMMON
subttl          Save Message Mode State For NVidia Extended Registers
page +
public  MiniVDD_SaveMessageModeState
BeginProc MiniVDD_SaveMessageModeState, RARE
;
;This routine allows the MiniVDD to copy virtualized states and save them in
;a special Message Mode state structure.  When this routine is called, the
;Main VDD has executed a totally virtualized mode change to the blue-screen
;Message Mode state (ie: Mode 3 in SBCS Windows and Mode 12H in Far East
;Windows).  Therefore, no screen changes are evident but the states have
;been saved in the CB data structure for the Windows VM (since the virtualized
;mode change was done when the Windows VM was the "Currently executing VM".
;Thus, when this routine is called, we have the Message Mode state for all
;of the NVidia Extension Registers saved in the CB data structure for the
;Windows VM.  We simply copy this state into the special Message Mode state
;data structure.
;
;Entry:
;       EBX --> Windows VM.
;       DS --> Windows VM's BIOS data area.
;Exit:
;       Save everything that you use!
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SaveMessageModeState", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax                     ;
        push    ebx                     ;
        push    ecx                     ;
        push    edx                     ;
;       push    edi                     ;

        cld                             ;make sure direction is set forward
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        VMMCall _lmemcpy, <OFFSET32 MessageModeCBData, ebx, size PerVMData>

        mov     MsgModeInitDone,0ffh    ;flag that we're done collecting states
;
SMMSExit:
;       pop     edi                     ;restore saved registers
        pop     edx                     ;
        pop     ecx                     ;
        pop     ebx                     ;
        pop     eax                     ;
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;we're done
EndProc MiniVDD_SaveMessageModeState
;
;
subttl          Save Forced Planar State For NVidia Extended Registers
page +
public  MiniVDD_SaveForcedPlanarState
BeginProc MiniVDD_SaveForcedPlanarState, RARE
;
;This routine allows the MiniVDD to copy virtualized states and save them in
;a special Forced Planar state structure.  When this routine is called, the
;Main VDD has executed a totally virtualized mode change to the planar state
;(ie: Mode 12H).  Therefore, no screen changes are evident but the states have
;been saved in the CB data structure for the Windows VM (since the virtualized
;mode change was done when the Windows VM was the "Currently executing VM".
;Thus, when this routine is called, we have the planar state for all
;of the NVidia Extension Registers saved in the CB data structure for the
;Windows VM.  We simply copy this state into the special Planar State
;data structure.
;
;Entry:
;       Nothing assumed.
;Exit:
;       Save everything that you use!
;
;The source of our state save copy is the Windows VM's CB data structure:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SaveForcedPlanarState", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax                     ;
        push    ebx                     ;
        push    ecx                     ;
        push    edx                     ;
;       push    edi                     ;

        cld                             ;make sure direction is set forward
        add     ebx,OurCBDataPointer    ; EBX --> VM's CB data area
        VMMCall _lmemcpy, <OFFSET32 ForcedPlanarCBData, ebx, size PerVMData>

;       pop     edi                     ;restore saved registers
        pop     edx                     ;
        pop     ecx                     ;
        pop     ebx                     ;
        pop     eax                     ;
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;we're done
EndProc MiniVDD_SaveForcedPlanarState
;
;
subttl          Return Total Memory Size on Card
page +
public  MiniVDD_GetTotalVRAMSize
BeginProc MiniVDD_GetTotalVRAMSize, DOSVM
;
;Entry:
;       EBX contains the Current VM Handle (which is also the CRTC owner's
;       VM Handle).
;       EBP --> VM's Client Registers.
;Exit:
;       CY is returned upon success.
;       All registers (except ECX) must be preserved over the call.
;       ECX will contain the total VRAM size in bytes.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetTotalVRAMSize", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax
        push    esi                     ; Uses REG_RD32 macros

        mov     ecx,800000h             ; default = 8M

        REG_RD32(NV_PFB_BOOT_0)  
        test    ax,40h
        jnz     @f        
        shr     ecx,1                   ; 4M?
        test    ax,4
        jnz     @f
        shr     ecx,1                   ; must be 2M
@@:     mov     TotalMemorySize,ecx     ; probably won't use this
        stc                             ;
        pop     esi
        pop     eax
        ret                             ;return to caller
EndProc MiniVDD_GetTotalVRAMSize
;
;
subttl          Return The Current Write Bank
page +
public  MiniVDD_GetCurrentBankWrite
BeginProc MiniVDD_GetCurrentBankWrite, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers (except EDX & EAX) must be preserved over the call.
;       EDX will contain the current write bank (bank A) set in hardware.
;
;NOTE: We really don't care whether these banks are configured as write or
;      read banks.  The reason that we use this terminology is because the
;      VESA standard defines two "windows" that can be set separately.
;      This routine gives back the first window.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetCurrentBankWrite", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
IFDEF FAST_HIRES_SAVE_RESTORE
        xor     edx,edx
ELSE ; FAST_HIRES_SAVE_RESTORE
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current index register value
        ror     eax,8                   ;save it in top byte of EAX
        mov     al,01Dh                 ;this is index for bank register A
        out     dx,al                   ;
        inc     dl                      ;EDX --> CRTC data register
        in      al,dx                   ;
        dec     dl                      ;EDX --> CRTC index register
        shr     al,1                    ;convert from 32KB banks to 64KB banks
        rol     eax,8                   ;restore previous contents of CRTC index
        out     dx,al                   ;
        movzx   edx,ah                  ;return bank in EDX register
ENDIF ; FAST_HIRES_SAVE_RESTORE
;
MGBWExit:
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_GetCurrentBankWrite
;
;
subttl          Return The Current Read Bank
page +
public  MiniVDD_GetCurrentBankRead
BeginProc MiniVDD_GetCurrentBankRead, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers (except EDX & EAX) must be preserved over the call.
;       EDX will contain the current read bank (bank A) set in hardware.
;
;NOTE: We really don't care whether these banks are configured as write or
;      read banks.  The reason that we use this terminology is because the
;      VESA standard defines two "windows" that can be set separately.
;      This routine gives back the second window.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetCurrentBankRead", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
IFDEF FAST_HIRES_SAVE_RESTORE
        xor     edx,edx
ELSE ; FAST_HIRES_SAVE_RESTORE
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current index register value
        ror     eax,8                   ;save it in top byte of EAX
        mov     al,01Eh                 ;set to extensions register index
        out     dx,al                   ;
        inc     dl                      ;EDX --> CRTC data register
        in      al,dx                   ;get banking register
        dec     dl                      ;EDX --> CRTC index register
        shr     al,1                    ;convert from 32KB banks to 64KB banks
        rol     eax,8                   ;restore previous contents of CRTC index
        out     dx,al                   ;
        movzx   edx,ah                  ;return bank value in EDX
ENDIF ; FAST_HIRES_SAVE_RESTORE
;
MGBRExit:
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_GetCurrentBankRead
;
;
subttl          Return the Bank Size
page +
public  MiniVDD_GetBankSize
BeginProc MiniVDD_GetBankSize, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       ECX contains the BIOS mode number that we're currently in.
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers (except EDX & EAX) must be preserved over the call.
;       EDX will contain the current bank size.
;       EAX will contain the physical address of the memory aperture or
;               zero to indicate VRAM at A000H.
;
;Our bank size (for HiRes save/restore purposes) is 64K.
;
; MSK - TODO - should we instead return the linear address with a size that is huge?!!!
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_GetBankSize", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Mode:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
IFDEF FAST_HIRES_SAVE_RESTORE
        mov     edx,TotalMemorySize
;        call    GetLinearAddress        ;indicate where linear frame buffer is
        mov     eax,_fbAddr
ELSE ; FAST_HIRES_SAVE_RESTORE
        mov     edx,64*1024             ;assume 4K banks
        xor     eax,eax                 ;indicate VRAM is at A000H
ENDIF ; FAST_HIRES_SAVE_RESTORE
;
MGBSExit:
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_GetBankSize
;
;
subttl          Prepare For a HiRes Screen Save/Restore
page +
public  MiniVDD_CheckScreenSwitchOK
BeginProc MiniVDD_CheckScreenSwitchOK, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       ECX contains the BIOS mode number that we're currently in.
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned if mode can not be switched.
;       All registers must be preserved over the call.
;
;Our bank size (for HiRes save/restore purposes) is 64K.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_CheckScreenSwitchOK", DEBLEVELMAX
                pop     eax
                push    eax
                Debug_Printf    ":VESA:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Mode:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
                clc                     ; return OK

        ret                            
EndProc MiniVDD_CheckScreenSwitchOK
;
;
public  MiniVDD_PreHiResSaveRestore
BeginProc MiniVDD_PreHiResSaveRestore, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       ECX contains the BIOS mode number that we're currently in.
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers must be preserved over the call.
;
;Our bank size (for HiRes save/restore purposes) is 64K.
;
; MSK - TODO - eliminate?
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PreHiResSaveRestore", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Mode:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
; MSK - TODO - we probably need to call save registers here and restore registers in PostHiResSaveRestore if
; they aren't called automatically.  Even if the VDD sets the VBE mode again for the DOS box, it will not
; be able to do the refresh rate.  This only maters if the app forced its own refresh rate!
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_PreHiResSaveRestore
;
;
subttl          Clean Up After a HiRes Screen Save/Restore
page +
public  MiniVDD_PostHiResSaveRestore
BeginProc MiniVDD_PostHiResSaveRestore, DOSVM
;
;Entry:
;       EBX contains the VM Handle (Always the "CurrentVM").
;       ECX contains the BIOS mode number that we're currently in.
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers must be preserved over the call.
;
;Our bank size (for HiRes save/restore purposes) is 64K.
;
; MSK - TODO - eliminate?
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PostHiResSaveRestore", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":Mode:%08lX", ecx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        stc                             ;return success to caller
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_PostHiResSaveRestore
;
;
subttl          Set the Bank During a HiRes Save/Restore
page +
public  MiniVDD_SetBank
BeginProc MiniVDD_SetBank, DOSVM
;
;Entry:
;       EAX contains the read bank to set.
;       EDX contains the write bank to set.
;       EBX contains the VM Handle (Always the "CurrentVM").
;       EBP --> Client Register structure for VM
;Exit:
;       CY is returned upon success.
;       All registers must be preserved over the call.
;       EDX will contain the current write bank (bank A) set in hardware.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_SetBank", DEBLEVELMAX
                Debug_Printf    ":VM:%08lX", ebx, DEBLEVELMAX
                Debug_Printf    ":RBank:%08lX", eax, DEBLEVELMAX
                Debug_Printf    ":WBank:%08lX", edx, DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
IFNDEF FAST_HIRES_SAVE_RESTORE
        push    ecx                     ;save this over call
        push    edx                     ;
        push    eax                     ;
;JohnH - need to unlock or we can't change banks!
        mov     cl,al                   ;get read bank to set into CL
        mov     ch,dl                   ;get write bank value in CH
        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get current index register value
        ror     eax,8                   ;save it in top byte of EAX

;               unlock_extension_regs
                call    unlock_ext
                
;
        mov     ah,ch                   ;get write bank value into AH
        shl     ah,1                    ;convert from 64KB banks to 32KB banks
        mov     al,01Dh                 ;set CRTC index to register 01Dh
        out     dx,ax                   ;set the write bank

        mov     ah,cl                   ;get read bank value into AH
        shl     ah,1                    ;convert from 64KB banks to 32KB banks
        mov     al,01Eh                 ;set CRTC index to register 01Eh
        out     dx,ax                   ;set the read bank
;
                call    restore_lock

        rol     eax,8                   ;restore GCR index register
        out     dx,al                   ;
        pop     eax                     ;
        pop     edx                     ;
        pop     ecx                     ;restore saved ECX
ENDIF ; FAST_HIRES_SAVE_RESTORE
        stc                             ;return success to caller
        ret                             ;
EndProc MiniVDD_SetBank
;
;
subttl          Temperary debug routines
page +
public  MiniVDD_PreCRTCModeChange
BeginProc MiniVDD_PreCRTCModeChange, DOSVM
;
;Entry:
;Exit:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PreCRTCModeChange", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_PreCRTCModeChange
;
;
;       RM callback after a mode switch
;Entry: parameter on stack. If non-zero, the display has changed (e.g. from CRT to TV)
public  MiniVDD_PostCRTCModeChange
BeginProc MiniVDD_PostCRTCModeChange, DOSVM
;
;Entry:
;Exit:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PostCRTCModeChange", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

;       We need to indicate the NVIDIA drivers are running, not VGA.DRV.
        mov     DisplayEnabledFlag,0ffh

        mov     eax,[esp+4]
        cmp     eax,1                   ; check parameter for display change
        jne     @f
        mov     DisplayChanged,1 ; flag it for PostHiresToVga
@@:
        ; signal BIOS not to change encoder while in hires
        call    TellBIOSNotProgramTV

;       We need to save registers after the resource manager does a mode change.
;       or else the VDD will restore the wrong registers (i.e., our extended registers). This can happen when closing
;       a windowed DOS box, or ending a full-srcreen app such as an AVI player.
;       This wasn't a problem when we used the BIOS for mode sets, because the I/O got trapped and the VDD called SaveRegisters.
        push    ebx
        mov     ebx,WindowsVMHandle
        call    MiniVDD_SaveRegisters
        pop     ebx
        
        ret
EndProc MiniVDD_PostCRTCModeChange
;
;
subttl          Handle refresh rate support for VESA setmode calls
page +
public MiniVDD_VESASupport
BeginProc MiniVDD_VESASupport
;
;
; MiniVDD_VESASupport
;       Our VBE handler. It processes non-refresh set mode calls and turns them
;       into refresh rate calls.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_VESASupport", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        pushad
IFDEF INCLUDE_REFRESH

; MSK - TODO - Add support for doing VESA calls in protected mode using VBE 3.0!!!
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_AX
        cmp     ax,VESA_SET_MODE        ; Is this a Set Mode call?
        je      VESASupportSetMode
ifdef VESA_DDC
        cmp     ax,4F15h                ; Is this a VBE/DDC call?
        je      VESADDC
endif ; VESA_DDC
        jmp     VESASupportPassDown    ; Pass call on down

VESASupportSetMode:
        mov     al,InRefreshSetMode     ; check if we are already doing this
        or      al,al
        jnz     VESASupportPassDown     ; just pass it down if we are

;NVidia uses VBE 3.0 to set the refresh rate.
;First see if this is a refresh rate aware set mode and just pass it on if it is.
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        test    ax,00800h
        jnz     VESASupportPassDown

;Is this the Windows VM or a DOS VM?
        cmp     ebx,WindowsVMHandle
        jne     VESASupportVM

        ;Determine current windows refresh rate setting
;The Main VDD has already retrieved the Refresh_Rate= and X_Resolution entries
;from SYSTEM.INI and will return those values if the registry has nothing
;better to offer.
;
; MSK - TODO - Add DDC/EDID refresh rate support!!!
; MSK - TODO - Add GTF refresh rate support!!!!
        mov     eax,OFFSET32 DisplayInfoStructure
        mov     ecx,SIZE DISPLAYINFO    ;pass size in ECX, address in EAX
        mov     [eax].diHdrSize,cx      ;fill in this entry
        push    eax                     ;save EAX --> DisplayInfoStructure
        VxDCall VDD_Get_DISPLAYINFO     ;get information from the VDD
        pop     edi                     ;restore EAX --> DisplayInfoStructure
        test    [edi].diInfoFlags,MONITOR_INFO_DISABLED_BY_USER OR \
                        MONITOR_INFO_NOT_VALID OR REGISTRY_RESOLUTION_NOT_VALID

; until BIOS correctly supports refresh, bypass this
IFDEF SUPPORT_VESA_REFRESH
        jnz     VESASupportPassDown     ;we are not to set the refresh rate!
ELSE
                jmp             VESASupportPassDown
ENDIF

;
;Since this is a normal setmode, tack on the refresh rate info
;
; MSK - TODO - make sure that we handle the fact that we can't call this until after
; DeviceInit, any set modes before then should just be regular
;
;First, dispatch to the correct resolution handler:
;
        movzx   edx,[edi].diYRes        ;
        or      edx,edx                 ;any Y-resolution in the structure?
        jz      VESASupportPassDown     ;nope, blow out of here!

; Determine if match between resolution and color depth with mode being set
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; load new values
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_SP
        sub     ax,size VBE_ModeInfoBlock
        mov     [ebp].Client_Word_Reg_Struc.Client_SP,ax
        mov     [ebp].Client_Word_Reg_Struc.Client_DI,ax
        mov     ax,[ebp].Client_Reg_Struc.Client_SS
        mov     [ebp].Client_Word_Reg_Struc.Client_ES,ax
        mov     ax,04F01h
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        ; copy mode number to cx
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        and     ax,001FFh
        mov     [ebp].Client_Word_Reg_Struc.Client_CX,ax

        ; copy block to VM stack
        Client_Ptr_Flat esi, ES, DI, USES_EAX

        .if (esi == -1)         ; -1 if error
                mov     ax, TRUE                ; assume its GUI as default in this case
        .else
                ; get the mode info
                mov     eax,010h
                VMMCall Exec_Int

                mov     ax,FALSE                ;assume no match?
                movzx   edx,[edi].diYRes        ;load y resolution
                .if (dx == [esi].VBE_ModeInfoBlock.YResolution)
                        movzx   edx,[edi].diXRes        ;load x resolution
                        .if (dx == [esi].VBE_ModeInfoBlock.XResolution)
                                movzx   edx,[edi].diBpp         ;load bpp
                                .if (dl == [esi].VBE_ModeInfoBlock.BitsPerPixel)
                                        mov     ax,TRUE                 ; do we match?
                                .endif
                        .endif
                .endif
        .endif

        VMMCall End_Nest_Exec
        Pop_Client_State

        cmp     ax,TRUE
        jne     VESASupportPassDown

        movzx   edx,[edi].diYRes        ;reload y resolution
        mov     eax,0                   ;start at 480
        cmp     edx,480                 ;running 640x480?
        je      MVS_Common              ;yes, go handle it
        inc     eax
        cmp     edx,600                 ;running 800x600?
        je      MVS_Common              ;yes, go handle it
        inc     eax
        cmp     edx,768                 ;running 1024x768?
        je      MVS_Common              ;yes, go handle it
        inc     eax
;
public  MVS_Common
MVS_Common:
        shl     eax,2
        mov     edx,refreshRates[eax]
        mov     eax,[edx].RefreshRateStruct.VetricalRefreshRate
MVS_Loop:
        movzx   esi,[edi].diRefreshRateMax
        cmp     eax,esi
        jg      MVS_NextRate
        test    [edi].diInfoFlags,REFRESH_RATE_MAX_ONLY
                                        ;did we not get horizontal rate data?
        jnz     MVS_MaxOnly             ;nope, do simplied method
        movzx   eax,[edi].diHighHorz    ;get high horizontal value into EAX
        jz      MVS_SkipTest
        cmp     [edx].RefreshRateStruct.HorizontalRefreshRate,eax
        jg      MVS_NextRate
MVS_SkipTest:
        movzx   eax,[edi].diLowHorz     ;get low horizontal value into EAX
        jz      MVS_MaxOnly
        cmp     [edx].RefreshRateStruct.HorizontalRefreshRate,eax
        jl      MVS_NextRate
MVS_MaxOnly:
        jmp     MVS_Found
;
MVS_NextRate:
        add     edx,size RefreshRateStruct
        mov     eax,[edx].RefreshRateStruct.VetricalRefreshRate
        jnz     MVS_Loop
;
        sub     edx,size RefreshRateStruct
;
MVS_Found:
        lea     esi,[edx].RefreshRateStruct.crtcInfoBlockForced
        ;
        jmp     VESASupportCommon

VESASupportVM:
        
IFDEF DOS_REFRESH
        ; scan for mode
        mov     edi,OFFSET32 DefaultRefreshModes
        ; load mode number
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        mov     ecx,DefaultRefreshCount
        or      ecx,ecx
        jz      VESASupportPassDown
        repne   scasw
        jne     VESASupportPassDown
        inc     ecx                     ; Back up one
        mov     edi,DefaultRefreshCount
        sub     edi,ecx                 ; Convert to index
        mov     eax,TYPE CRTCInfoBlock
        mul     edi
        mov     esi,eax
        add     esi,OFFSET32 DefaultRefreshTable
ELSE ; DOS_REFRESH
        jmp     VESASupportPassDown    ; Pass call on down
ENDIF ; DOS_REFRESH
       

VESASupportCommon:
IFDEF OLD_VESA30_REFRESH
        ; Find closest match of a frequency
        mov     edi,OFFSET32 ClockFrequencies
        mov     ax,word ptr [edi]
        mov     dx,ax                   ; initialize dx in case of empty list
        mov     cx,07FFFh               ; biggest possible distance
        .while   (ax != 0FFFFh)
                sub     ax,[esi].CRTCInfoBlock.PhysDotClock
                .if (SWORD PTR ax < 0)
                        neg     ax
                .endif
                .if (ax < cx)
                        mov     cx,ax
                        mov     dx,word ptr [edi]
                .endif
                inc     edi
                inc     edi
                mov     ax,word ptr [edi]
        .endw

        ; Did we find the closest clock?
        cmp     dx,0FFFFh
        je      VESASupportPassDown
ELSE ; OLD_VESA30_REFRESH
        ; Call VESA function 0C to get closest clock frequency to what we want
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; load new values
        mov     ax,04F0Ch
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,ax
        xor     ax,ax
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,ax
        mov     ax,[esi].CRTCInfoBlock.PhysDotClock
        mov     [ebp].Client_Word_Reg_Struc.Client_CX,ax

        ; do the setmode
        mov     eax,010h
        VMMCall Exec_Int

        mov     dx,[ebp].Client_Word_Reg_Struc.Client_CX
        mov     cx,[ebp].Client_Word_Reg_Struc.Client_AX
        VMMCall End_Nest_Exec
        Pop_Client_State

        cmp     cx,0004Fh               ; did we do the clock call?
        jne     VESASupportPassDown     ; no, pass it down
ENDIF ; OLD_VESA30_REFRESH
        ;
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; load new values
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_SP
        sub     ax,((size CRTCInfoBlock + 1)/ 2) * 2
        mov     [ebp].Client_Word_Reg_Struc.Client_SP,ax
        mov     [ebp].Client_Word_Reg_Struc.Client_DI,ax
        mov     ax,[ebp].Client_Reg_Struc.Client_SS
        mov     [ebp].Client_Word_Reg_Struc.Client_ES,ax
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        or      ax,00800h               ;set refresh rate flag
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,ax

        ; copy block to VM stack
        Client_Ptr_Flat eax, SS, SP, USES_EAX

        .if (eax == -1)         ; -1 if error
                mov     ax, FALSE
        .else
                ;
                push    edx
                cld
                VMMcall _lmemcpy, <eax, esi, size CRTCInfoBlock>
                pop     edx

                ; Replace dot clock with the closest one found in the BIOS
                mov     edi,eax
                mov     [edi].CRTCInfoBlock.PhysDotClock,dx

                mov     InRefreshSetMode,0FFh

                ; do the setmode
                mov     eax,010h
                VMMCall Exec_Int
                ;push    10h
                ;VMMCall Exec_VxD_Int

                mov     InRefreshSetMode,000h

                mov     ax,TRUE                 ; did we do the setmode?
        .endif

        mov     cx,[ebp].Client_Word_Reg_Struc.Client_AX
        VMMCall End_Nest_Exec
        Pop_Client_State
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,cx

        cmp     ax,TRUE                 ; did we do the setmode?
        jne     VESASupportPassDown     ; no, pass it down
;
VESASupportComplete:
        stc                             ; We completely handled the call
        mov     ax,VESA_SUCCESS         ; Return success
        jmp     VESASupportExit

ENDIF ; INCLUDE_REFRESH
        ;
        ; Hook out all VBE/DDC calls.  If we are currently running on a flat panel
        ; through the second I2C port, force the CX to 1.  Since the BIOS supports
        ; DDC3 it will accept the Monitor port # parameter (CX).
        ;
ifdef VESA_DDC
VESADDC:
        cmp     DontRecurse, 0          ;if we did an exec_int 10 4f15, we'll come right back here
        jne     VESASupportPassDown

;       Win98 does not recognize devices at address > A0.
;       It also does not recognize EDID 2.0.
;       We'll hack around these limitations.

        call    GetCRTCPort             ;EDX --> CRTC index register
        in      al,dx                   ;get and save current CRTC index ...
        ror     eax,8                   ;in high byte of EAX

;        unlock_extension_regs
        call    unlock_ext
;
        mov     al, 33h                 ;set to CRTC index 033h
        out     dx,al                   ;
        inc     edx                     ;EDX --> CRTC data register
        in      al,dx                   ;get data from CRTC register 033h
        dec     edx                     ;EDX --> CRTC index register

        test    al, 02h                 ;Check bit1, the current fp/crt bit
        jz      VESAMonitorActive       ;If 1, we are running a fp

;       if we are on DFP, what DDC port is it using?
        cmp             fpDDC,0
        je              VESAMonitorActive

        mov     [ebp].Client_Word_Reg_Struc.Client_CX, 1 ; Force to Monitor Port 1

VESAMonitorActive:
        call    restore_lock

;Restore the CRTC index register saved in the high byte of EAX:
;
        rol     eax,8                   ;
        out     dx,al                   ;

if VESA20   ; This code intercepts the VESA DDC calls to handle EDID 2.0 
            ; and device addresses other than A0, two cases which Win98 doesn't handle.
            ; We'll have to see if Millennium does this correctly, and bypass this if so.

        mov     bx,[ebp].Client_Word_Reg_Struc.Client_BX
        cmp     bl,0
        jz      VESAGetCaps
        cmp     bl,1
        jz      VESAReadEDID
        jmp     VESASupportPassDown
                
VESAGetCaps:
; Call into the BIOS, and check the return. If the device uses address > A0,
; change the return value to indicate A0, and set a flag to indicate we are tricking
; the OS and we should intercept the EDID read to get the correct device.
; No, we will always read the EDID, because we can't know if it is a version 2.
        mov     DontRecurse, 0ffh       ; we'll come right back to VESADDCSupport, pass it down
        
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec
        mov     eax,010h
        VMMCall Exec_Int
        VMMCall End_Nest_Exec

        mov     DontRecurse, 0
        mov     DDCAddrFake,0          
        mov     bx,[ebp].Client_Word_Reg_Struc.Client_BX ; check the device address
        Pop_Client_State
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,bx
        mov     DDCAddrFake,bx          ; save the DDC address map
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,04fh

        test    bx,DDC_ADDR_A0          ; address A0 is OK, A2 & A6 Win98 can't handle
        jnz     VESASupportDone
        mov     bl,2                    ; make address A0
        mov     [ebp].Client_Word_Reg_Struc.Client_BX,bx
        jmp     VESASupportDone
        
VESAReadEDID:
; If we changed the previous GetCaps call to look like it was address A0 when it was actually 
; A2, we need to change the call to subfunction 3 -- Read EDID at A2.
; Because the monitor may have a version 2.0 EDID, we must always do the EDID read ourselves.
;        cmp     DDCAddrFake,0           ; are we tricking Windows?
;        jz      VESASupportPassDown

; save the caller's buffer pointer (possibly only 128 byte buffer)
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_DI
        mov     BuffOff,ax
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_ES
        mov     BuffSeg,ax

; alloc a 256 byte V86 buffer 
        VMMcall Get_Cur_VM_Handle       ; get the current vm handle into ebx
        mov     ecx, EDID2_SIZE         ; EDID 2 buffer size
        clc                             ; set carry flag to copy, clear otherwise
        VxDcall V86MMGR_Allocate_Buffer
        mov     eax,edi                 ; edi = (16 bits of seg, 16 bits of off)
        xor     ax,ax
        shr     eax,12
        or      ax,di
        mov     pEdid2,eax
                                        
        cmp     ecx, EDID2_SIZE
        jz      @f
        mov     ax,4f15h
        jmp     VESASupportPassDown

@@:     mov     eax, edi                ; Break the v86 address into ax:di
        and     edi, 0FFFFh
        shr     eax, 16

        mov     TempEdidBufOff,di
        mov     TempEdidBufSeg,ax
        
; Call into the BIOS, and check the return

; Set the device address, based on what we got from the Get DDC Caps call
; What is the proper address to use in the case of multiple addresses?
; A 256 byte device may indicate it supports A0, but the call will fail, since it returns
; the first 128 bytes, and the block will not checksum. (Seen on Gateway flat panel.)
; A 128 byte device will never indicate it supports A2 or A6.
; Therefore, if the device indicates it supports A2 or A6, use one of these, not A0.
        mov     EdidAddress, DDC_SUBF_4         ; read at A6
        test    DDCAddrFake,DDC_ADDR_A6
        jnz     DDC_Read_Exec_Int               ; use A6
EdidA2:        
        mov     EdidAddress, DDC_SUBF_3         ; read at A2
        test    DDCAddrFake,DDC_ADDR_A2
        jnz     DDC_Read_Exec_Int               ; use A2
EdidA0:        
        mov     EdidAddress, DDC_SUBF_1         ; read at A0
        
DDC_Read_Exec_Int:
        Push_Client_State                       ; preserve original state while we alter client register struct
; Insert our buffer pointer into the client state
        mov     ax,TempEdidBufOff
        mov     [ebp].Client_Word_Reg_Struc.Client_DI, ax
        mov     ax,TempEdidBufSeg
        mov     [ebp].Client_Word_Reg_Struc.Client_ES, ax
       
        mov     al,EdidAddress
        mov     [ebp].Client_Word_Reg_Struc.Client_BL,al
        mov     DontRecurse, 0ffh
        mov     [ebp].Client_Word_Reg_Struc.Client_AX, 4f15h
        
        VMMcall Begin_Nest_V86_Exec
        
        mov     eax,010h
        VMMCall Exec_Int
        VMMCall End_Nest_Exec
        mov     DontRecurse, 0
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_AX        ; get return
        Pop_Client_State                        ; restore original state

        mov     [ebp].Client_Word_Reg_Struc.Client_AX, ax
        cmp     ax,04fh                                         ; put back return val
        jnz     Next_Edid_Addr

; Verify the function really succeeded
; In some cases, the monitor will respond to an address (ACK) but not return an EDID. The BIOS
; will then return Caps which are not true, and also report the EDID read succeeded when it did not.
; We will test the header data, and if it's not valid, retry using the next available address.
        mov     esi,pEdid2
        lea     edi,EDID1_HEADER
        mov     ecx,8
        repe    cmpsb           ; EDID 1?
        jz      Xlat_Edid_Buffer
        mov     esi,pEdid2
        cmp     byte ptr [esi],2 ; EDID 2?
        jz      Xlat_Edid_Buffer

; Try next address
Next_Edid_Addr:        
        cmp     EdidAddress,DDC_SUBF_1
        je      EdidDone
        cmp     EdidAddress,DDC_SUBF_4
        je      EdidA2
        cmp     EdidAddress,DDC_SUBF_3
        je      EdidA0
        jmp     DDC_Read_Exec_Int
                 
Xlat_Edid_Buffer:
; Get flat address for the caller's buffer
        xor     eax,eax
        mov     ax,BuffSeg
        shl     eax,4
        xor     ecx,ecx
        mov     cx,BuffOff
        add     eax,ecx
        mov     pEdid1,eax
                
; If it was a version 2.0 EDID, make up a fake version 1.x
        mov     esi,pEdid2
        mov     al,[esi]
        cmp     al,20h      ; version 2.0?
        je      Edid2

; Copy version 1 EDID into caller's buffer
        mov     cx,EDID1_SIZE
        mov     edi,pEdid1
        mov     esi,pEdid2
        rep movsb                
        jmp     EdidDone    

; We have a version 2 EDID. Translate into version 1 and return to caller.
; We do the minimum work required to make the VDD happy.
; This includes the product/vendor ID and some detailed timings.
Edid2:
        ; copy template
        mov     edi,pEdid1
        mov     esi,offset32 EdidTemp
        mov     ecx,EDID1_SIZE
        rep movsb
        ; copy vendor/product ID
        mov     esi,pEdid2
        mov     edi,pEdid1
        mov     ax,[esi+EDID2_VENDOR]
        mov     [edi+EDID1_VENDOR],ax

        ; Copy detailed timings. We have to parse a bunch of fields to find them first.
        mov     ax,[esi+EDID2_MAP]      ; map of timing info tells where to start
        mov     Edid2Map,ax
        mov     ecx,EDID2_TIMING_START   
        test    al, EDID2_LUM_TABLE_EXIST ; any lum tables?
        jz      Edid_rl
        ; advance beyond lum table
        mov     ah,[esi+ecx]            ; get 1st byte of timing table
        mov     al,ah
        and     al,EDID2_LUM_ENTRIES    ; get # of lum tables entries
        test    ah,EDID2_LUMX3          ; triple lum tables?
        jz      @f
        mov     bl,3
        mul     bl                      ; triple entries
@@:     add     al,1                    ; bump index beyond lum table
        add     cl,al                
Edid_rl:
        mov     ax,Edid2Map
        and     al,EDID2_RL             ; any range limits?
        jz      Edid_drl
        ; advance beyond range limits        
        shr     al,EDID2_RL_SHIFT
        mov     bl,8
        mul     bl                      ; 8-byte range limits
        add     cl,al
Edid_drl:
        mov     ax,Edid2Map
        test    al,EDID2_DRL            ; any detailed range limits?
        jz      Edid_tc
        ; advance beyond detailed range limits
        and     al,EDID2_DRL
        mov     bl,27
        mul     bl                      ; 27-byte detailed range limits
        add     cl,al
Edid_tc:
        mov     ax,Edid2Map             ; get 2nd byte of map
        and     ah,EDID2_TIMING_CODES
        jz      Edid2_dt
        shr     ah,EDID2_TC_SHIFT
        mov     al,ah
        mov     bl,4
        mul     bl                      ; 4-byte timing codes
        add     cl,al
        ; now we are finally at the detailed timings
Edid2_dt:
        mov     ax,Edid2Map
        and     ah,EDID2_DET_TIMINGS
        mov     al,ah
        mov     bl,18
        mul     bl                      ; 18-byte detailed timings
        mov     nDetTim,al
        mov     DetTimOff,cx            ; offset within edid2 struct to detailed timings
        ; copy all detailed timings to edid1
        add     edi,EDID1_DET_TIMING    ; point to edid1 detailed timings
        add     esi,ecx                 ; point to edid2 detailed timings
        xor     ecx,ecx
        mov     cl,nDetTim
        rep movsb
        
        ; generate 8 bit checksum
        mov     ecx,EDID1_SIZE
        mov     edi,pEdid1
        xor     ax,ax
EdidCs: add     al,[edi+ecx-1]
        loop    EdidCs
        neg     al
        mov     [edi+EDID1_SIZE-1],al
;debug - fail the call to see if the system hangs
;        mov     [ebp].Client_Word_Reg_Struc.Client_AX,014fh

EdidDone:
; Free the V86 buffer
        VMMcall Get_Cur_VM_Handle       ; get the current vm handle into ebx
        mov     ecx,EDID2_SIZE
        clc                             ; no copy back required
        VxDcall V86MMGR_Free_Buffer
        jmp     VESASupportDone
endif ; VESA_DDC

VESASupportDone:
        stc                             ; we handled it
        jmp     VESASupportExit

endif ; VESA20

VESASupportPassDown:
        clc                             ; We didn't completely handle the call, pass down to BIOS

VESASupportExit:
        popad
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_VESASupport
;
;


;       Hook Int 10
;       Check for VESA DDC function and direct it to the appropriate controller
BeginProc    MiniVDD_Int10Handler
        pushad
      
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_AX
        
        ; Don't let VGA.DRV on secondary do a modeset when our driver is running on primary
        cmp     NumUnits,2              ; TwinView?
        jne     @f                      ; no, act normally
        cmp     DisplayEnabledFlag,0    ; display driver up?
        jz      @f                      ; no, it's not a problem
        cmp     DosBoxActive,0          ; running FS DOS?
        jne     @f                      ; yes, let it go thru
        cmp     ax,12h                  ; VGA driver modeset?
        jnz     @f                      ; yes, this is what we want to prevent

        ; We should skip modeset call from Windows VM only. This is workaround of Windows bug
        ; when VGA display driver on the secondary device (Display settings tab multimon) calls
        ; INT10 because it thinks we are in VGA mode but it does not assume it executes
        ; on the secondary device. VBIOS INT10 always executes on primary device so we'll change
        ; timings on primary by mistake.
        VMMCall Get_Cur_VM_Handle
        push    ebx
        VMMCall Get_Sys_VM_Handle
        pop     edx
        cmp     ebx,edx                 ; Bug #33723
        jne     @F                      ; Do not skip modeset if not Windows WM

        ; This may be a problem for Asian language DOS, which uses mode 12.
        ; Does a virtualized DOS session do a mode 12, and if we swallow it, what happens?
        jmp     Int10_Handled            ; Then swallow the interrupt

@@:
        ; Check for DDC functions
        cmp     ax,4F15h                ; Is this a VBE/DDC call?
        jne     Int10_Not_Handled

        ; We'll let the BIOS handle the report DDC caps call (BL = 0),
        ; and we'll handle the read EDID (BL = 1),

ifndef RM_GET_DDC_CAPS
        ; if we let the RM handle GET_DDC_CAPS, we don't need to do this
        ; Make sure that CRTC "A" owns I2C, since that is the head the BIOS will use to do DDC.
        ; unlock_extension_regs
        call    unlock_ext
        mov     dx,3d4h
        mov     ax,044h                 ; point to head A
        out     dx,ax
        mov     al,49h                  ; Engine Control reg
        out     dx,al
        inc     dx
        in      al,dx
        or      al,04h                 ; head A claims I2C (takes precedence over head B claiming it, so no need to set the other CR49)
        out     dx,al
        call    restore_lock
endif

        mov     bx,[ebp].Client_Word_Reg_Struc.Client_BX

        cmp     bl,01h                  ; Read Edid ?
        je      VESA_Read_EDID

ifndef  RM_GET_DDC_CAPS
        jmp     Int10_Not_Handled       ; let BIOS do it
else
        cmp     bl, 0
        jne     Int10_Not_Handled
                                        ; let RM do it
        mov     eax, NVRM_API_GET_DDC_CAPS
        mov     ebx, DEFAULT_PRIMARY_HDEV ; primary device
        call    CallRM                  ; returns status in ax
        mov     [ebp].Client_Word_Reg_Struc.Client_BX, bx
        mov     [ebp].Client_Word_Reg_Struc.Client_AX, 4fh
        jmp     Int10_Handled
endif

VESA_Read_EDID:
        ; This is a trick. Windows enabled EDID PNP support
        ; if it read EDID by the VESA int10 call AND it
        ; receives a valid EDID. Just let it go through
        ; here until it gets one good EDID and then we will
        ; stop punting to here from GetMonitorInfo.

        ; If GetMonInfoCount < 0 then that is either SBIOS call
        ; or that some DOS app is issuing the VESA call
        ; and not the main VDD I suppose.
        cmp     GetMonInfoCount,0
        js      Int10_Not_Handled

        ; Get flat address for the caller's buffer
        xor     edi,edi
        mov     di,[ebp].Client_Word_Reg_Struc.Client_ES
        shl     edi,4
        xor     eax,eax
        mov     ax,[ebp].Client_Word_Reg_Struc.Client_DI
        add     edi,eax

        ; ecx = Head number
        inc     dwInt10EntryCount
        jne     Int10_Entry_Count_Not_Handled

        push    edi
        push    GetMonInfoCount
        push    dwDisplayDevnodeHandle
        call    GetEdidAndRemapIt
        add     esp,0CH

        dec     dwInt10EntryCount

        ; Assume that there was an EDID
        mov     GetMonInfoCount,-2
        mov     eax,[edi]
        or      eax,eax
        jne     @F

        ; Reset GetMonInfoCount because it might be non DDC
        ; monitor on the head 0. Windows will not enable EDID
        ; PNP support unless it uses the int10 call AND it
        ; receives a valid EDID.
        mov     GetMonInfoCount,-1

        ; if fail, return VESA DDC fail status
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,014Fh
        jmp     Int10_Handled

@@:
        mov     [ebp].Client_Word_Reg_Struc.Client_AX,004Fh

Int10_Handled:
        clc                            ; clear carry to show we handled it
        jmp     Int10_Done

Int10_Entry_Count_Not_Handled:
        dec     dwInt10EntryCount      ; fallthrough to stc
Int10_Not_Handled:
        stc                            ; set carry to show we didn't handle it
Int10_Done:
        popad
        ret
EndProc MiniVDD_Int10Handler


public  SaveNVAccessState
BeginProc SaveNVAccessState
;
;       SaveNVAccessState - Save the state of the NV real mode access registers
;
;       Entry:  Extended CRTC registers unlocked
;       Exit:   esi = 32-bit NV address
;               al  = real mode access control bits
;               dx  = LSW of 32-bit data register
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "SaveNVAccessState", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ecx
        push    eax
        push    edx
        ;
        call    GetCRTCPort
        mov     al, NVRM_ACCESS
        SIM_NO  dx,al
        inc     edx                                     ; edx -> CRTC data
        SIM_NI  al,dx
        ror     eax,8                                   ; Save access bits in high byte of eax
        dec     edx                                     ; edx -> CRTC index
        mov     al, NVRM_ACCESS
        mov     ah, NVRM_ACCESS_MASK OR NVRM_DATA32     ; Get LSW of 32-bit write
        SIM_NO  dx, ax
        ror     edx,16                                  ; save CRTC index in upper word of edx
        mov     dx,003D0h
        SIM_NI  ax,dx
        push    ax                                      ; Save LSW of 32-bit write
        mov     al, NVRM_ACCESS
        mov     ah, NVRM_ACCESS_MASK OR NVRM_ADDRESS
        rol     edx,16                                  ; restore CRTC index
        SIM_NO  dx, ax
        ror     edx,16                                  ; save CRTC index in upper word of edx
        mov     dx, 003D0h
        SIM_NI  ax,dx
        push    ax                                      ; Save LSW of address
        inc     dx
        inc     dx
        SIM_NI  ax,dx
        mov     si,ax                                   ; move MSW of address into si
        shl     esi, 16
        pop     si                                      ; now ESI has whole address
        rol     edx,16                                  ; restore CRTC index
        rol     eax,8                                   ; restore access bits
        inc     edx                                     ; DX -> CRTC data register
        SIM_NO  dx,al
        ;
        pop     cx                                      ; restore LSW of 32-bit write
        pop     edx                                     ; restore original edx
        mov     dx,cx                                   ; now edx is all set
        ;
        mov     cl,al                                   ; save control bits into cl
        pop     eax                                     ; restore original eax
        mov     al,cl                                   ; now eax is all set
        ;
        pop     ecx                                     ; restore original ecx
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc SaveNVAccessState
;
;
public  RestoreNVAccessState
BeginProc RestoreNVAccessState
;
;       RestoreNVAccessState - Restore the state of the NV real mode access registers
;
;       Entry:  Extended CRTC registers unlocked
;               esi = 32-bit NV address
;               al  = real mode access control bits
;               dx  = LSW of 32-bit data register
;       Exit:   none
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf "RestoreNVAccessState", DEBLEVELMAX
                push    ecx
                and     ecx,0FFFFh
                Debug_Printf ":CRTC:%04X", ecx, DEBLEVELMAX
                pop     ecx
                pop     eax
                ;
                push    eax
                Debug_Printf ":NV Address:%08lX:RM Control:%04X:RM Reg:%04X:LSW Data32:%04X", eax, DEBLEVELMAX
                push    ebx
                mov     bl,bh
                and     ebx,0FFh
                Debug_Printf ":RM Control:%04X:RM Reg:%04X:LSW Data32:%04X", ebx, DEBLEVELMAX
                pop     ebx
                push    ebx
                and     ebx,0FFh
                Debug_Printf ":RM Reg:%04X:LSW Data32:%04X", ebx, DEBLEVELMAX
                pop     ebx
                push    edx
                and     edx,0FFFFh
                Debug_Printf ":LSW Data32:%04X", edx, DEBLEVELMAX
                pop     edx
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    eax
        push    edx
        ;
        push    ax                                      ; we need to use these
        push    dx
        ;
        call    GetCRTCPort
        mov     al, NVRM_ACCESS
        mov     ah, NVRM_ACCESS_MASK OR NVRM_ADDRESS
        SIM_NO  dx, ax
        ror     edx,16                                  ; save CRTC index in upper word of edx
        mov     dx, 003D2h                              ; Write MSW of address first
        mov     eax, esi
        shr     eax, 16
        SIM_NO  dx, ax
        dec     dx                                      ; Now write LSW of address
        dec     dx
        mov     ax, si
        SIM_NO  dx, ax
        mov     al, NVRM_ACCESS
        mov     ah, NVRM_ACCESS_MASK OR NVRM_DATA32     ; LSW of 32-bit write
        rol     edx,16                                  ; restore CRTC index
        SIM_NO  dx, ax
        ror     edx,16                                  ; save CRTC index in upper word of edx
        mov     dx,003D0h
        pop     ax                                      ; Restore LSW of 32-bit write
        SIM_NO  dx, ax
        rol     edx,16                                  ; restore CRTC index
        pop     ax                                      ; Restore access bits
        mov     ah, al
        mov     al, NVRM_ACCESS
        SIM_NO  dx, ax
        ;
        pop     edx
        pop     eax
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc RestoreNVAccessState
;
;
IFDEF DOS_REFRESH
subttl          Handle refresh rate support for PM OEM VESA calls
page +
public MiniVDD_Xlat_Int10
BeginProc MiniVDD_Xlat_Int10
;BeginProc MiniVDD_Xlat_Int10, VMCREATE
;
;
;* need to map pm to real mode int 10, 4f14,41
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_PMHandler", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        VMMcall Simulate_Iret                   ; Eat the int right now

        mov     eax, [ebp.Client_EAX]           ; Get entry EAX

        cmp     ax, 4F14h                       ; Q: Get/Set palette?
        jne     SHORT MVXI10_Reflect_Int_EDX    ;    N: Just reflect it now

        mov     ax,[ebp].Client_Word_Reg_Struc.Client_BX
        cmp     al,041h                         ; OEM set default refresh rate
        jne     SHORT MVXI10_Reflect_Int_EDX    ;    N: Just reflect it now

        mov     edx, OFFSET32 MiniVDD_OEM_Refresh_API
        VxDjmp  V86MMGR_Xlat_API

public MVXI10_Reflect_Int_EDX
MVXI10_Reflect_Int_EDX:
        mov     edx, OFFSET32 MiniVDD_Default_API
        VxDjmp  V86MMGR_Xlat_API

IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_Xlat_Int10
ENDIF ; DOS_REFRESH

IFDEF   I2C
;       I2COpen
;
;Entry: args on stack (stdcall)
;
;Exit:  status
public  MiniVDD_I2COpen
BeginProc       MiniVDD_I2COpen, DOSVM
;       args are passed to us on the stack as stdcall
        call    _vddI2COpen
        ret 12
EndProc         MiniVDD_I2COpen

;       I2CAccess
;
;Entry: args on stack (stdcall)
;
;Exit:  status
;
public  MiniVDD_I2CAccess
BeginProc       MiniVDD_I2CAccess, DOSVM
;       args are passed to us on the stack as stdcall
        call    _vddI2cAccess
        ret 8
EndProc         MiniVDD_I2CAccess

ENDIF   ;I2C

IFDEF   DIOC
subttl      WIN32 Device IO Control
page +
public  MiniVDD_W32_DIOC

BeginProc MiniVDD_W32_DIOC
;-----------------------------------------------------------------
;       D E V I C E I O C O N T R O L   I N T E R F A C E
;-----------------------------------------------------------------
;  ENTRY :
;        ESI -> address of DIOC structure

        pushad
        mov  ecx, [ esi ].dwIoControlCode

        cmp  ecx,20000700H
        je   DevCtl_SetFSDOSPtr

        cmp  ecx, DIOC_CLOSEHANDLE
        je   DevCtl_CloseHandle

        cmp  ecx, DIOC_GETVERSION
        je   DevCtl_GetVersion

        cmp  ecx, VDD_IOCTL_NV_GETSETCALLBACK
        jnz  Next0
        call NVGetSetCallback
        jmp  MiniVDDDone

Next0:
        cmp  ecx, VDD_IOCTL_NV_FILLTABLE
        jnz  Next1
        call NvFillTable
        jmp  MiniVDDDone
Next1:
        cmp  ecx, VDD_IOCTL_GET_DDHAL
        jnz  Next2
        call GetDDHAL
        jmp  MiniVDDDone
Next2:
        cmp  ecx, VDD_IOCTL_NV_SETVIDTEXSURF
        jnz  Next3
        call NVSetVidTexSuf
        jmp  MiniVDDDone
Next3:
IFDEF NVPE
        cmp  ecx, VDD_IOCTL_NVPE_COMMAND
        jnz  MiniVDDDone
        push esi
        call _nvpeVDDCmdHandler
        pop  esi
ENDIF

MiniVDDDone:
        cmp  eax,1
        jae  DevCtl_Fails

;----------------------------------------------------------------
;
;  ECX = -1 ( DIOC_CLOSEHANDLE )
;
;----------------------------------------------------------------

DevCtl_CloseHandle      :

        jmp  DevCtl_OKey

DevCtl_SetFSDOSPtr:
        mov  eax,[esi].lpvInBuffer
        mov  pDDrawFullScreenDOSActive,eax
        jmp  DevCtl_OKey

;----------------------------------------------------------------
;
;  ECX = 0 ( DIOC_GETVERSION )
;
;----------------------------------------------------------------
DevCtl_GetVersion :

        jmp  DevCtl_OKey

DevCtl_Fails :

        mov DevCtlRet, 50    ; ERROR_NOT_SUPPORTED
        stc                  ; indicate error
        jmp DevCtl_Exit

DevCtl_OKey :

        mov DevCtlRet, 0
        clc
        jmp DevCtl_Exit

DevCtl_Exit :

        popad
        mov eax, DevCtlRet
        ret
EndProc MiniVDD_W32_DIOC
endif   ;DIOC


public  WaitTicks
BeginProc WaitTicks
;
;       WaitTicks - Wait a given number of timer ticks
;
;       Entry:  CX = Number of ticks to wait
;       Exit:   None
;
;       All registers are preserved
;
        pushad
;
        VMMCall Get_System_Time
        mov     ebx,eax
@@:
        VMMCall Get_System_Time
        sub     eax,ebx
        cmp     ax,cx
        jl      @b
;
        popad
        ret
EndProc WaitTicks
;
;
public  Beep
BeginProc Beep
;
;       Beep - Beep the speaker once
;
;       Entry:  None
;       Exit:   None
;
;       All registers are preserved.
;
;
IFDEF   DEBUG_BEEP
        pushad
;
        mov     al,0B6h
        out     43h,al
        mov     al,033h
        out     42h,al
        mov     al,005h
        out     42h,al
        in      al,061h
        push    ax
        or      al,003h
        out     61h,al
        mov     cx,4*18
        call    WaitTicks
        pop     ax
        out     61h,al
;
        popad
ENDIF   ; DEBUG_BEEP
        ret
EndProc Beep
;
;
; Call the resource manager.
;

BeginProc       CALLRM          
;               push everything onto stack so we have the top of a client reg struct. (see VMM.H)

        push    esi
        mov     esi, offset callrm_rmusrapi
        mov     dword ptr [esi].minivdd_CALLRM_rmusrapi_Struct.rmusrapi_function, eax
        dec     ebx
        mov     dword ptr [esi].minivdd_CALLRM_rmusrapi_Struct.rmusrapi_device, ebx
        mov     eax,esi
        pop     esi 

        
        push    eax
        push    ecx
        push    edx
        push    ebx
        push    eax                             ; res0, documented as "ESP at pushall"
        push    ebp
        push    esi
        push    edi
        
        mov     ebp, esp                ; point ebp to client reg struct 
        call    DWORD PTR ResManAPI
        pop     edi
        pop     esi
        pop             ebp
        pop             eax                             ; res0
        pop     ebx
        pop     edx
        pop     ecx
        pop     eax
        ret     
EndProc CALLRM

;               save lock value and unlock chip
;               we must save lock value. CRTC index should be saved in calling routine
BeginProc       unlock_ext
        push    eax
        push    edx
        call    GetCRTCPort             ;EDX --> CRTC index register
                mov             al,1fh
                out             dx,al
                inc             dx
                in              al,dx
                mov             LockValue,al
                mov             al,57h
                out             dx,al
sl_exit:
        pop     edx
        pop     eax
        ret
                                
EndProc unlock_ext






;               restore lock state
BeginProc       restore_lock
        push    eax
        push    edx
        call    GetCRTCPort             ;EDX --> CRTC index register
;       NV4 - locked, unlocked, or read-only
                mov             ah,57h
                cmp             LockValue,3             ;read 1 if unlocked
                je              @f
                mov             ah,75h
                cmp             LockValue,1             ;read 1 if read-only (NV4 or later)
                je              @f
                mov             ah,99h                  ;must be locked
@@:         ;NV4
                mov             al,1fh
                out             dx,ax                   ;restore lock
rl_exit:
        pop     edx
        pop     eax
        ret
EndProc         restore_lock


;; ReadCr44 - BIOS copied script for reading CR44
;; INPUTS
;;    DX - CRTC access (3d4)
;; OUTPUT
;;    AL - Cr44 read value
;;    DX - restored
BeginProc       ReadCr44
        ; TODO: We probably should read the Resman copy
        ; since I'm not sure if this io read works
        ;
        ; Read Cr44 using 8 bit IO - Output will be in AL
        mov     al,44h          ; Address CR44/0 AH for default
        out     dx,al           ; send 44 as index
        inc     edx             ; set to 3d5
        in      al,dx
        dec     edx             ; set back to 3d4
        
        ; Read the mirror bit. If this is on, we know we're in Broadcast mode
;        push    ebx
;        xchg    eax,ebx         ; store eax in ebx for now
        ; get the mirror bit (28)
;        REG_RD32(NV_PBUS_DEBUG_1)
;        xchg    eax,ebx         ; restore eax, PBUS_DEBUG_1 is in ebx
        ; is the mirror bit set
;        .if (ebx & 10000000h)
;                mov     al,04h  ; return Broadcast mode
;        .endif
;        pop     ebx
        
        ret
EndProc         ReadCr44
        
;;
;; WriteCr44 - BIOS copied script for writing CR44
;; INPUTS
;;    DX - CRTC access (3d4)
;;    AL - Cr44 write value value
;; OUTPUT
;;    DX - restored
BeginProc       WriteCr44
        ; Using MMIO to write CR44
        ; This works for the Resman!
        push    eax
        mov     al,44h
        REG_WR08(NV_PRMCIO_CRX__COLOR)
        pop     eax
        REG_WR08(NV_PRMCIO_CRE__COLOR)

        ret
EndProc         WriteCr44





; Procedures for setting BIOS TV programming flag
; Use memory mapped access because we can assure access to head A on multihead devices, without having to switch CR44.
BeginProc TellBIOSProgramTV
;   tell the BIOS to program the TV encoder
        push    eax
        push    edx
        push    ecx
        push    esi                     ; used in REG_RD/REG_WR macros

            ; unlock
        mov al, 1Fh                     ; Get current CR1F
        REG_WR08(NV_PRMCIO_CRX__COLOR)
        REG_RD08(NV_PRMCIO_CRE__COLOR)  ; Save it
        mov cl, al
        mov al,57h
        REG_WR08(NV_PRMCIO_CRE__COLOR)  ; unlock

        mov al, BIOS_SCRATCH1
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        REG_RD08(NV_PRMCIO_CRE__COLOR)  
        and al,NOT BIOS_PGRM_TV         ; clear bit 1 (OK to program TV encoder)
        REG_WR08(NV_PRMCIO_CRE__COLOR)  

        mov al, 1Fh                     ; Get current CR1F
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        ; restore lock
        mov             al,57h
        cmp             cl,3             ;read 1 if unlocked
        je              @f
        mov             al,75h
        cmp             cl,1             ;read 1 if read-only (NV4 or later)
        je              @f
        mov             al,99h           ;must be locked
@@:     
        REG_WR08(NV_PRMCIO_CRE__COLOR)  

        pop     esi                     ; used in REG_RD/REG_WR macros
        pop     ecx
        pop     edx
        pop     eax
        ret
EndProc TellBIOSProgramTV


BeginProc TellBIOSNotProgramTV
;   tell the BIOS to not program the TV encoder
        push    eax
        push    edx
        push    ecx
        push    esi                     ; used in REG_RD/REG_WR macros

        ; unlock
        mov al, 1Fh                     ; Get current CR1F
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        REG_RD08(NV_PRMCIO_CRE__COLOR)  ; Save it
        mov cl, al
        mov al,57h
        REG_WR08(NV_PRMCIO_CRE__COLOR)  ; unlock

        mov al, BIOS_SCRATCH1
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        REG_RD08(NV_PRMCIO_CRE__COLOR)  
        or  al, BIOS_PGRM_TV            ; set bit 1 (not OK to program TV encoder)
        REG_WR08(NV_PRMCIO_CRE__COLOR)  

        mov al, 1Fh                     ; Get current CR1F
        REG_WR08(NV_PRMCIO_CRX__COLOR)  
        ; restore lock
        mov             al,57h
        cmp             cl,3             ;read 1 if unlocked
        je              @f
        mov             al,75h
        cmp             cl,1             ;read 1 if read-only (NV4 or later)
        je              @f
        mov             al,99h           ;must be locked
@@:     
        REG_WR08(NV_PRMCIO_CRE__COLOR)  
        
        pop     esi                     ; used in REG_RD/REG_WR macros
        pop     ecx
        pop     edx
        pop     eax
        ret
EndProc TellBIOSNotProgramTV
;
VxD_LOCKED_CODE_ENDS
;
;
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nvmini2.asm ===
;       (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
;       Portions Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.
;
;       NV3MINI2.ASM - NVidia secondary Mini-VDD for NV3
;
;       Written by:     JohnH
;       Date:           12/17/97
;
;
;
page            ,132
title           NVidia NV3 Secondary Mini-VDD Support Functions
.386p
;

;
.xlist
MINIVDD                 EQU             1               ; this must be defined for minivdd.inc

include         VMM.INC
include         VWIN32.INC                      ; used for IOCTL for KMVT
include                 VXDLDR.INC
include         DEBUG.INC
include         MINIVDD.INC
include         configmg.inc
include         VNVRMD.INC
include         V86MMGR.INC
include         NVDEF.INC
include         VBE30.INC
include         NVIDIA.INC
IFDEF NVIDIA_COMMON
include         NV_REF.INC
include         NV_MAC.INC
include         NV_SIM.INC
ENDIF ; NVIDIA_COMMON
include                  SURFACES.INC

IFDEF   DIOC
extrn           GetDDHAL:near
extrn                            NvFillTable:near
extern                   NVGetSetCallback:near
extern          NVSetVidTexSuf:near
ENDIF   ;DIOC

.list

;**************************************************************************************************************************
subttl          Virtual Device Declaration
page +
;       Then MiniVDD must have the UNDEFINED_DEVICE_ID
;       and it is a dynamic load VxD, so it cannot have a service table.
Declare_Virtual_Device  NVMINI2, \
                        3,      \
                        1,      \
                        MiniVDD_Control,        \
                        UNDEFINED_DEVICE_ID,    \
                        VDD_INIT_ORDER,         \
                                                ,                                               \
                        ,                                       \
                        ,

;
;
;**************************************************************************************************************************
subttl          Initialization Data
page +
VxD_IDATA_SEG
NVRM_String            db      'NVCORE.VXD',0
VxD_IDATA_ENDS
;
;**************************************************************************************************************************
subttl          Locked Data Area
page +
VxD_LOCKED_DATA_SEG
TotalMemorySize dd              400000h
VxD_LOCKED_DATA_ENDS
;
;**************************************************************************************************************************
subttl          General Data Area
page +
VxD_DATA_SEG
;
OSVersion       dw      0
ResManAPI       dd      0
devNode         dd      0
nvAddr          dd      0
nvPhys          dd      0
fbPhys          dd      0
fbLength        dd      0
nvIRQ           dd      0
hDev            dd      0
DevCtlRet       dd      0
NumUnits	dd      0               ; number of "units" or heads
;
public  VGAModeFlag
VGAModeFlag             db      0               ;=FFh when in 16 color mode (VGA driver)


; JJV-MM
; This Minivdd must handle up to 8 secondary devices (7 if the primary is also an NV4).
minivdd_instance_Struct struct
  instance_devNode          dd      0
  instance_nvAddr           dd      0
  instance_nvPhys           dd      0
  instance_fbPhys           dd      0
  instance_fbLength         dd      0
  instance_nvIRQ            dd      0
  instance_hDev             dd      0
  instance_ACPI_state       dd      0
minivdd_instance_Struct ends
; Static structures for each instance.
device1_instance minivdd_instance_Struct <>
device2_instance minivdd_instance_Struct <>
device3_instance minivdd_instance_Struct <>
device4_instance minivdd_instance_Struct <>
device5_instance minivdd_instance_Struct <>
device6_instance minivdd_instance_Struct <>
device7_instance minivdd_instance_Struct <>
device8_instance minivdd_instance_Struct <>

; resource manager parameter passing structure.
minivdd_RM_Parameter_Struct struct
  callrm_device_handle        dd      0
  callrm_modechange_callback  dd      0
  callrm_irq_bus              dd      0
  callrm_fbphys               dd      0
  callrm_nvphys               dd      0
  callrm_registry_path        dd      0
minivdd_RM_Parameter_Struct ends
callrm_struct minivdd_RM_Parameter_Struct <>
callrm_rmusrapi minivdd_CALLRM_rmusrapi_Struct <>

public  DisplayInfoStructure
DisplayInfoStructure    DISPLAYINFO     <>

PUBLIC  dwCreatingVM
dwCreatingVM            DD      0

JIMK1   EQU     <1>

IF JIMK1
PUBLIC  dwDisplayDevnodeHandle
dwDisplayDevnodeHandle  DD      0

PUBLIC  szEnumAndMore
szEnumAndMore   DB      "Enum\"
szAndMore       DB      128 DUP(0)

PUBLIC  szLocalDisplayPath, szLocalDisplayPathEnd
szLocalDisplayPath      DB      "System\CurrentControlSet\Services\Class\"
szLocalDisplayPathEnd   DB      32 DUP(0)

PUBLIC  szDriver
szDriver        DB      "Driver",0

PUBLIC  szDisplayEndPath
szDisplayEndPath        DB      32 DUP(0)

ALIGN 4
PUBLIC  dwCBType, dwCBLen, hKey
dwCBType        DD      0
dwCBLen         DD      0
hKey            DD      0
ENDIF

VxD_DATA_ENDS
;
;
;**************************************************************************************************************************
subttl          Device Initialization
page +
VxD_ICODE_SEG

public  MiniVDD_Dynamic_Exit
BeginProc MiniVDD_Dynamic_Exit
   xor eax, eax
   ret
EndProc MiniVDD_Dynamic_Exit

;
public  MiniVDD_Dynamic_Init
BeginProc MiniVDD_Dynamic_Init
;
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:
;       If success, return NC.
;       If failure, return CY.
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_Dyanmic_Init", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG
        push    ebx                     ;save Windows VM handle in EBX
        push    ebp
;
;               Load the resource manager. If already loaded, this will just return the entry point.
                mov             edx, OFFSET32 NVRM_String
                mov             eax, VXDLDR_INIT_DEVICE
                VxDcall VXDLDR_LoadDevice
        jnc     @f
                jmp             MVDIErrorExit                   ;failed, nothing we can do

@@:
;       returns DDB address in eax and device handle in edx
;       save the API entry
                mov             eax, [eax].DDB_PM_API_Proc
                mov             ResManAPI, eax
;

;	Correct the string for multihead configuration
;	Change %s\Unit%d --> %s\U%d
	push	ecx
	push	edx
	push	edi
	mov	eax,0ah
	xor	edi,edi
	VMMCall	Get_DDB
	or	ecx,ecx
	jz	@F
	lea	edi,[ecx+18h]
	mov	edx,ASSERT_RANGE_NO_DEBUG OR ASSERT_RANGE_NULL_BAD
	VMMCall	_Assert_Range,<edi,4,0,0,edx>
	or	eax,eax
	jz	@F
	mov	edi,[edi]
	lea	edi,[edi+13fch]
	VMMCall	_Assert_Range,<edi,4,2574696eh,0,edx>
	or	eax,eax
	jz	@F
	mov	ecx,6425h		; '%d'
	mov	[edi],ecx
@@:
	pop	edi
	pop	edx
	pop	ecx
;
public  MVDIDispatch
MVDIDispatch:
;
;
;Fill in the addresses of all the functions that we need to handle in this
;mini-VDD in the table provided by the "master" VDD whose address is
;contained in EDI.  Note that if you do not need to support a function,
;you do not need to fill in the dispatch table entry for that function.
;If you do not fill in an entry, the "master" VDD won't try to call
;this mini-VDD to support the function.  It'll just handle it in a
;default manner.
;
        VxDCall VDD_Get_Mini_Dispatch_Table
        cmp     ecx,NBR_MINI_VDD_FUNCTIONS      ;perform a cursory version check
        jb      MVDIErrorExit                   ;oops, versions don't match!
;
public  MVDI_FillInTable
MVDI_FillInTable:
        MiniVDDDispatch REGISTER_DISPLAY_DRIVER,RegisterDisplayDriver
        MiniVDDDispatch GET_TOTAL_VRAM_SIZE,GetTotalVRAMSize
        ;
        ; new Win98 functions...
        ;
        VMMcall Get_VMM_Version
;        .if (!(carry?) && (ax == 040ah))
        jc  PreWin98
        mov   OSVersion,ax
        cmp   ax,VERS_WIN98
        jb    PreWin98
;       The primary needs to support these
        MiniVDDDispatch TURN_VGA_OFF,TurnVgaOff
        MiniVDDDispatch TURN_VGA_ON,TurnVgaOn

;       This is required if the device supports multiple displays (NV4?)
        MiniVDDDispatch GET_NUM_UNITS,GetNumUnits

         ;These are for power management. We don't need the monitor functions, since Windows will use VESA calls
         ; if we don't hook them.
;ifdef ON_NOW
          MiniVDDDispatch SET_ADAPTER_POWER_STATE,SetAdapterPowerState
          MiniVDDDispatch GET_ADAPTER_POWER_STATE_CAPS,GetAdapterPowerStateCaps
;endif
;          MiniVDDDispatch SET_MONITOR_POWER_STATE,SetMonitorPowerState
;          MiniVDDDispatch GET_MONITOR_POWER_STATE_CAPS,GetMonitorPowerStateCaps
;        .endif
PreWin98:

;
MVDIGoodExit:
        clc                             ;return success
        jmp     MVDIExit                ;
;
MVDIErrorExit:
        stc
;
MVDIExit:
        pop     ebp
        pop     ebx                     ;restore Windows VM handle to EBX
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret
EndProc MiniVDD_Dynamic_Init
;

;
VxD_ICODE_ENDS
;
;**************************************************************************************************************************
subttl          Dispatch Table for VMM Calling This Mini-VDD
page +
VxD_LOCKED_CODE_SEG
;
;
Begin_Control_Dispatch  MiniVDD
        Control_Dispatch SYS_DYNAMIC_DEVICE_INIT, MiniVDD_Dynamic_Init  ;init function for dynamic VXD
        Control_Dispatch PnP_New_DevNode, MiniVDD_PnP_New_DevNode ;init function for new pnp devnode
                Control_Dispatch SYS_VM_TERMINATE, MiniVDD_Sys_VM_Terminate             ;try to release traps here
                ;Control_Dispatch SYS_DYNAMIC_DEVICE_EXIT, MiniVDD_Dynamic_Exit  ;try to release traps here
            Control_Dispatch W32_DEVICEIOCONTROL, MiniVDD_W32_DIOC
        ;
End_Control_Dispatch MiniVDD

public  MiniVDD_W32_DIOC
BeginProc MiniVDD_W32_DIOC
;-----------------------------------------------------------------
;       D E V I C E I O C O N T R O L   I N T E R F A C E
;-----------------------------------------------------------------
;  ENTRY :
;        ESI -> address of DIOC structure

        pushad

        mov  ecx, [ esi ].dwIoControlCode
        cmp  ecx, DIOC_CLOSEHANDLE
        je   DevCtl_CloseHandle

        cmp  ecx, DIOC_GETVERSION
        je   DevCtl_GetVersion

        cmp  ecx, VDD_IOCTL_NV_GETSETCALLBACK
        jnz  Next0
        call NVGetSetCallback
        jmp  MiniVDDDone

Next0:
        cmp  ecx, VDD_IOCTL_NV_FILLTABLE
        jnz  Next1
        call   NvFillTable
        jmp     MiniVDDDone
Next1:
        cmp  ecx, VDD_IOCTL_GET_DDHAL
        jnz  Next2
        call GetDDHAL
        jmp  MiniVDDDone
Next2:
   cmp  ecx, VDD_IOCTL_NV_SETVIDTEXSURF
        jnz  MiniVDDDone
        call NVSetVidTexSuf


MiniVDDDone:
        cmp     eax,1
        jae  DevCtl_Fails

;----------------------------------------------------------------
;
;  ECX = -1 ( DIOC_CLOSEHANDLE )
;
;----------------------------------------------------------------

DevCtl_CloseHandle      :

        jmp  DevCtl_OKey

;----------------------------------------------------------------
;
;  ECX = 0 ( DIOC_GETVERSION )
;
;----------------------------------------------------------------
DevCtl_GetVersion :

        jmp  DevCtl_OKey

DevCtl_Fails :

        mov DevCtlRet, 50    ; ERROR_NOT_SUPPORTED
        stc                  ; indicate error
        jmp DevCtl_Exit

DevCtl_OKey :

        mov DevCtlRet, 0
        clc
        jmp DevCtl_Exit

DevCtl_Exit :

        popad
        mov eax, DevCtlRet
        ret
EndProc MiniVDD_W32_DIOC

;
;--------------------------------------------------------------------------
public  MiniVDD_TurnVgaOff
BeginProc       MiniVDD_TurnVgaOff, DOSVM

                push    eax
                push    esi

                ;Disable VGA through the VGA Enable IO register.
                REG_RD08(NV_PRMVIO_VSE2)
                and al,0feh
                REG_WR08(NV_PRMVIO_VSE2)

                ;Disable NV PCI IO, bit0 = 0.
                REG_RD32(NV_PBUS_PCI_NV_1)
                and     al,0feh
                REG_WR32(NV_PBUS_PCI_NV_1)

                ;Disable NV interrupts.
;;                xor     eax,eax
;;                REG_WR32(NV_PMC_INTR_EN_0)

                pop     esi
                pop     eax

                ret
EndProc         MiniVDD_TurnVgaOff
;
;--------------------------------------------------------------------------
public  MiniVDD_TurnVgaOn
BeginProc       MiniVDD_TurnVgaOn, DOSVM

                push    eax
                push    esi

                ;We may not be mapped into the linear address space.
                ;If not, make it so.
                REG_RD32(NV_PBUS_PCI_NV_4)      ;get Bar 0 thru linear space
                cmp     eax,nvPhys              ;are we still here?
                jz      @f
                
                ;Go out to PCI space and reenable
                mov     edx,0cf8h
                mov     esi, offset callrm_struct
                mov     eax, dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_irq_bus
                and     eax,0ffffff00h          ;clear lower byte (IRQ)
                or      eax,80000004h           ;enable config space mapping, reg 4 = command reg
                out     dx,eax
                mov     dx,0cfch
                in      eax,dx
                or      eax,3                   ;enable mem + I/O
                out     dx,eax
@@:                
                ;Enable NV PCI IO, bit0 = 1.
                REG_RD32(NV_PBUS_PCI_NV_1)
                or      al,01h
                REG_WR32(NV_PBUS_PCI_NV_1)

                ;Enable VGA through the VGA Enable IO register.
;This comment is here because the assembler was giving "line too long" error--comment fixes it. Very strange!
                REG_RD08(NV_PRMVIO_VSE2)
;
                or al,01h
                REG_WR08(NV_PRMVIO_VSE2)

                ;Enable NV interrupts.
                xor     eax,eax
                mov     al,1
                REG_WR32(NV_PMC_INTR_EN_0)

                pop     esi
                pop     eax

                ret
EndProc         MiniVDD_TurnVgaOn

;----------------------------------------
;Entry: none
;Exit:  ax = number of heads (crtc's)
public MiniVDD_GetNumUnits
BeginProc       MiniVDD_GetNumUnits, DOSVM
                pushad
;               Ask the RM how many heads are supported
                mov     ebx, DEFAULT_PRIMARY_HDEV
                mov     eax, NVRM_API_NUM_HEADS     ; load up the function number
                call    CallRM                      ; go to RM's API procedure
                mov     eax,ebx                     ; return in eax
                mov     NumUnits,eax                ; save in static area

;               We cannot run dual heads in VGA mode. Find out if we are in 16 color mode.
                cmp     eax,2                   ; dual CRTC device?
                jl      NumUnitsGotten          ; no, then the mode doesn't matter

;               Get Display Info from VDD
                push    ecx
                push    edi
                mov     eax,OFFSET32 DisplayInfoStructure
                mov     ecx,SIZE DISPLAYINFO    ;pass size in ECX, address in EAX
                mov     [eax].diHdrSize,cx      ;fill in this entry
                push    eax                     ;save EAX --> DisplayInfoStructure
                VxDCall VDD_Get_DISPLAYINFO     ;get information from the VDD
                pop     edi                     ;restore EAX --> DisplayInfoStructure
                mov     VGAModeFlag,0
                cmp     [edi].diBpp,4           ;16 color?
                jne     @f
                mov     VGAModeFlag,0FFh
                mov     NumUnits,1              ;Don't allow dual head if VGA.DRV is running!
@@:
                pop     edi
                pop     ecx
NumUnitsGotten:

                popad
                mov     eax, NumUnits
                ret
EndProc         MiniVDD_GetNumUnits

;******************************************************************************
;
;   GetBusDeviceAndFunctionNumber
;
;   DESCRIPTION:
;       Locates the device on the PCI Bus and returns the Bus, Device and Function Numbers.
;
;   ENTRY:
;       EBX = nvPhys
;       ECX = fbPhys
;       EDX = nvIRQ
;
;   EXIT:
;       EAX = EDX will now contain the needed info.
;         EDX xxxxxxxx xxxxxxxx xxxxx  xxx  xxxxxxxx
;             00000000    Bus # Device Func        IRQ #
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================
BASE0_OFFSET EQU 10h
BASE1_OFFSET EQU 14h
IRQ_OFFSET       EQU 3ch
BeginProc GetBusDeviceAndFunctionNumber

  local bus_number:BYTE
  local device_number:BYTE
  local function_number:BYTE
  local base0:DWORD
  local base1:DWORD
  local irq:BYTE
  local return_val:DWORD

  pushad

  mov   base0, ebx
  mov   base1, ecx
  mov   irq, dl
  ; Check all buses devices and functions for the memory windows and IRQ input.
  mov   bus_number,0
  .repeat
    mov   device_number,0
    .repeat
      mov   function_number,0
      .repeat
        ; Read the PCI bus and check if we have a match.
        xor   eax,eax
        mov   al, bus_number
        shl   eax,16
        mov   ah, device_number
        shl   ah,3
        or    ah, function_number
        mov   al, BASE0_OFFSET
        or    eax, 80000000h           ; eax will now contain the configuration address for the PCI read.
        ReadPCI                                ; Returns the Dword read from the PCI Config space in edx.
        and   dl,0
        .if(edx == base0)
          mov   al, BASE1_OFFSET
          ReadPCI                                  ; Returns the Dword read from the PCI Config space in edx.
          and   dl,0
          .if(edx == base1)
            mov   al, IRQ_OFFSET
            ReadPCI                                ; Returns the Dword read from the PCI Config space in edx.
            .if(dl == irq)
              ; WOW ! It works. Lets get out and return this stuff
              and   eax,00FFFF00h          ; AND off the config bit and offset.
              mov   al, irq                        ; OR in the irq
              mov   return_val, eax
              jmp   we_gots_a_match
            .endif
          .endif
        .endif
        inc   function_number
      .until function_number == 08h
      inc   device_number
    .until device_number == 01fh
    inc   bus_number
  .until bus_number == 0ffh

  mov  return_val,-1

  we_gots_a_match:
  exit_out:

  popad
  mov  edx, return_val
  ret

EndProc   GetBusDeviceAndFunctionNumber

;==============================================================================
;   findDevNode
;
;   DESCRIPTION:
;   Finds the array that matches the devNode.
;
;   ENTRY:
;       EBX = Devnode handle
;
;   EXIT:
;   Sets carry on error. On Success, sets ESI to point to the correct instance.
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================
BeginProc findDevNode

    mov   esi, offset device1_instance
    .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
        mov   esi, offset device2_instance
        .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
            mov   esi, offset device3_instance
           .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
               mov   esi, offset device4_instance
              .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                  mov   esi, offset device5_instance
                  .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                      mov   esi, offset device6_instance
                      .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                          mov   esi, offset device7_instance
                          .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                              mov   esi, offset device8_instance
                              .IF (dword ptr [esi].minivdd_instance_Struct.instance_devNode != ebx)
                                  ; Did not find a match
                                  stc
                                  ret
                              .ENDIF
                          .ENDIF
                      .ENDIF
                  .ENDIF
              .ENDIF
           .ENDIF
        .ENDIF
    .ENDIF

    ; Found the devNode. ESI is setup to point to that instance
    clc
    ret
EndProc findDevNode

;==============================================================================
;   DoConfigRemove
;
;   DESCRIPTION:
;       Handles the CONFIG_REMOVE message. In reality it handles any message that
;   gives us a hint that the device is going to be removed. We never get a CONFIG_REMOVE!
;
;   ENTRY:
;       EBX = Devnode handle
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================
BeginProc DoConfigRemove

    mov  devNode, ebx
    call findDevNode  ; ebx has the devnode.
    .IF (carry?)
       mov eax, CR_FAILURE
    .ELSE
       ; Found the device to be removed
       mov      eax, NVRM_API_EXIT          ; load up the function number
       mov      ebx, dword ptr [esi].minivdd_instance_Struct.instance_hDev
       call     CallRM                                      ; go to RM's API procedure

       ; Zero out the instance
       xor     ebx, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_devNode, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_nvAddr, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_nvPhys, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_fbPhys, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_fbLength, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_nvIRQ, ebx
       mov     dword ptr [esi].minivdd_instance_Struct.instance_hDev, ebx

       mov      eax, CR_SUCCESS

    .ENDIF


    ret
EndProc DoConfigRemove

;==============================================================================
;   DoConfigStart
;
;   DESCRIPTION:
;       Handles the CONFIG_START message.
;
;   ENTRY:
;       EBX = Devnode handle
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================

BeginProc DoConfigStart

        .ERRNZ  SIZE Config_Buff_s MOD 4

        sub     esp, SIZE Config_Buff_s
        mov     edi, esp                ; alloc buffer on stack

        xor eax, eax
        mov devNode, ebx

IF JIMK1
    mov     dwDisplayDevnodeHandle,ebx
ENDIF

;       call the Configuration Manager to get the device config.
        VxDcall _CONFIGMG_Get_Alloc_Log_Conf, <edi, ebx, CM_GET_ALLOC_LOG_CONF_ALLOC>
        test    eax, eax
        jz      @F
        Debug_Out "MiniVDD:  Unexpected config manager error #EAX"
        jmp     DoConfigStartDone

@@:

IF JIMK1
    ; Here we determine the local registry path
    push    edi

    ; Get the correct display path in the registry
    mov     eax,[ebx + 4]
    mov     esi,OFFSET szAndMore

    ; eax now points to a string that we concatenate onto
    ; "Enum\\".  We look up this path in HKEY_LOCAL_MACHINE
@@: mov     cl,[eax]
    inc     eax
    mov     [esi],cl
    inc     esi
    or      cl,cl
    jne     @B

    ; Now open the key
    mov     hKey,0
    mov     esi,OFFSET szEnumAndMore
    mov     eax,OFFSET hkey
    VMMCall _RegOpenKey, <HKEY_LOCAL_MACHINE,esi,eax>
    or      eax,eax
    jne     UseDefaultKey

    ; Now Read the display sub path
    mov     szDisplayEndPath,0
    mov     dwCBType,REG_SZ
    mov     dwCBLen,32
    mov     eax,OFFSET dwCBType
    mov     ebx,OFFSET szDisplayEndPath
    mov     ecx,OFFSET dwCBLen
    mov     edx,OFFSET szDriver
    VMMCall _RegQueryValueEx, <hKey, edx, 0, eax, ebx, ecx>

    ; CLose the key and zero it out.
    VMMCall _RegCloseKey, <hKey>
    mov     hKey,0

    ; Now, did we get a valid string (like "DISPLAY\0005")
    cmp     szDisplayEndPath,0
    je      UseDefaultKey

    ; Make the complete path
    mov     eax,OFFSET szDisplayEndPath
    mov     ebx,OFFSET szLocalDisplayPathEnd
@@:
    mov     cl,[eax]
    inc     eax
    mov     [ebx],cl
    inc     ebx
    or      cl,cl
    jne     @B
    jmp     GotRegPath

UseDefaultKey:
    mov     eax,OFFSET szLocalDisplayPathEnd
    mov     dword ptr [eax + 0],'PSID'
    mov     dword ptr [eax + 4],'\YAL'
    mov     dword ptr [eax + 8],'0000'
    mov     byte ptr [eax + 12],0

GotRegPath:
    pop     edi
    mov     ebx,dwDisplayDevnodeHandle
    ; The local registry path is in szLocalDisplayPath
ENDIF

;       We got the device config; now parse the info and call the resource manager to map it.

        ;mov    esi, [dwRefData]        ; ESI -> adapter reference data

    ;
    ; NV3 should be given four or five memory windows
    ;
    ;   two for VGA (A0000 and B0000)
    ;   two for the PCI Bars (NV and FB)
    ;   one for AGP aperture/ROM (optional)
    ;
    ; We should find NV at index 2 and FB at index 3, but let's
    ; parse to make sure.
    ;
    ; Zero out the globals to start with.
    mov     nvPhys, 0
    mov     fbPhys, 0
    mov     fbLength, 0
    mov     nvIRQ, 0

    xor     ebx, ebx
start_1:
    ; starting with NV 4.5, we may optionally have a 32 MB fb
    ; NV10 goes up to 128MB, so we'll check for that size too
    cmp     [edi.dMemLength][ebx*4], 08000000h      ; don't expect to find fb first, but just in case
    je      found_fb
    cmp     [edi.dMemLength][ebx*4], 02000000h      ; don't expect to find fb first, but just in case
    je      found_fb
    cmp     [edi.dMemLength][ebx*4], 01000000h
    je      @F
    inc     ebx
    cmp     bx, [edi.wNumMemWindows]
    jl      start_1
    mov     eax, CR_DEVICE_NOT_THERE
    jmp     DoConfigStartDone

@@:
    ;
    ; Found a 16meg window.  Which one is it?
    ; We should always find nv first and fb second--this is the order in the PCI config
    ; BUT -- we won't rely on this order.
        ; The config manager doesn't always return attrib = 5 (prefetchable) for fb, although this is set in PCI space,
        ; so we won't depend on it. Problem with win98 beta only? Maybe we can rely on this.
        ; We will test which window is which by reading some nv register in InitMapping (in the resource manager).
;    cmp     [edi.wMemAttrib][ebx*2], 0005h
    mov     eax, [edi.dMemBase][ebx*4]
;    je      @F
    mov     nvPhys, eax                ; nv has attrib of 1
    jmp     short start_2
;@@:
;    mov     fbPhys, eax                ; fb has attrib of 5 (PF)

; 32 or 128MB window -- must be fb
found_fb:
    mov     eax, [edi.dMemBase][ebx*4]
    mov     fbPhys, eax                ; fb has attrib of 5 (PF)
    mov     eax, [edi.dMemLength][ebx*4]
    mov     fbLength, eax

start_2:
    ;
    ; Find the next nv window
    ;
    inc     ebx
    cmp     bx, [edi.wNumMemWindows]    ; at end?
    jl      @F
    mov     eax, CR_DEVICE_NOT_THERE    ; fail
    jmp     DoConfigStartDone

@@:
    cmp     [edi.dMemLength][ebx*4], 08000000h      ; NV10
    je      @f
    cmp     [edi.dMemLength][ebx*4], 04000000h      ; NV20
    je      @f
    cmp     [edi.dMemLength][ebx*4], 02000000h      ; NV5
    je      @f
    cmp     [edi.dMemLength][ebx*4], 01000000h      ; NV4
    jne     start_2
    ;
    ; Found another 16/32 meg window.  Which one is it?
    ;
@@:
; Don't count on attrib = 5!
;    cmp     [edi.wMemAttrib][ebx*2], 0005h
    mov     eax, [edi.dMemBase][ebx*4]
;    je      @F
;       jne             @f                                                      ; yes, it must be fb
;    mov     nvPhys, eax                ; nv has attrib of 1
;    jmp     short start_3
    cmp     fbPhys, 0                   ; did we find fb already? (unlikely)
    je      @f
    mov     nvPhys, eax                 ; already have fb, must be nv
    jmp     start_3
@@:
    mov     fbPhys, eax
    mov     eax, [edi.dMemLength][ebx*4]
    mov     fbLength, eax

start_3:
    ;
    ; We now have our two memory windows.  Let's look for the IRQ.
    ;
    cmp     [edi.wNumIRQs], 1
    je      @F
    ; If none, go to PCI space and find it. We can do this in InitMapping, after nvAddr is mapped
    ;
;    mov     eax, CR_DEVICE_NOT_THERE    ; more than one irq?  ooops.
;       jmp             MiniVDD_PnP_Done
@@:
    xor     eax, eax
    mov     al, [edi.bIRQRegisters][0]
    mov     nvIRQ, eax

;       check that we got something (shouldn't ever be 0 unless PCI error)
    mov     eax, CR_DEVICE_NOT_THERE    ; assume failure
    cmp             nvPhys, 0
    jz              DoConfigStartDone
    cmp             fbPhys, 0
    jz              DoConfigStartDone
;   just getting the addresses is enough for now
;       cmp             _nvIRQ, 0
;       jz              DoConfigStartDone

;
;       Map the physical addresses to linear addresses and install interrupt
;       Addresses should be in correct order, but we'll check in InitMapping.
map_config:
    push    ebx
    push    ecx
    push    edx
    push    edi

    mov     edx, nvIRQ
    mov     ecx, fbPhys
    mov     ebx, nvPhys                                     ; pass physical config to RM
    ; Before we initialize in the RM, Lets pass in the Bus, Device and Function numbers along with the IRQ.
    ; This will be helpful later when we may need to turn on the device.
    ; This function will fill edx with the PCI bus, device and function info along with the IRQ.
    call    GetBusDeviceAndFunctionNumber

    mov     eax, fbLength
    shr     eax, 16
    or      ecx, eax                    ; put the upper word of the length (ie # of 64k blocks) in the lower word
    push    esi
    xor     esi, esi

    mov     esi, offset callrm_struct
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_device_handle, 2
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_modechange_callback, 0
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_irq_bus, edx
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_fbphys, ecx
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_nvphys, ebx
    lea     eax, szLocalDisplayPath
    mov     dword ptr [esi].minivdd_RM_Parameter_Struct.callrm_registry_path, eax
    mov     eax, NVRM_API_INIT                      ; load up the function number
    mov     ebx, DEFAULT_PRIMARY_HDEV
    call    CallRM                                  ; go to RM's API procedure
                                                    ; do mapping to logical addresses and installing interrupt
    pop     esi
    mov     nvAddr, ebx                 ; return with logical address to NV
    mov     hDev, ecx                   ; and a RM handle to the device.

    .IF     (eax == RM_OK)

        ; save off all these values for this devnode
        .if hDev == 1
          mov   esi, offset device1_instance
        .elseif hDev == 2
          mov   esi, offset device2_instance
        .elseif hDev == 3
          mov   esi, offset device3_instance
        .elseif hDev == 4
          mov   esi, offset device4_instance
        .elseif hDev == 5
          mov   esi, offset device5_instance
        .elseif hDev == 6
          mov   esi, offset device6_instance
        .elseif hDev == 7
          mov   esi, offset device7_instance
        .elseif hDev == 8
          mov   esi, offset device8_instance
        .else
          ; Too many devices !
          int 3h
        .endif

        mov     eax, devNode
        mov     dword ptr [esi].minivdd_instance_Struct.instance_devNode, eax

        mov     eax, nvAddr
        mov     dword ptr [esi].minivdd_instance_Struct.instance_nvAddr, eax
        mov     eax, nvPhys
        mov     dword ptr [esi].minivdd_instance_Struct.instance_nvPhys, eax
        mov     eax, fbPhys
        mov     dword ptr [esi].minivdd_instance_Struct.instance_fbPhys, eax
        mov     eax, fbLength
        mov     dword ptr [esi].minivdd_instance_Struct.instance_fbLength, eax
        mov     eax, nvIRQ
        mov     dword ptr [esi].minivdd_instance_Struct.instance_nvIRQ, eax
        mov     eax, hDev
        mov     dword ptr [esi].minivdd_instance_Struct.instance_hDev, eax

        mov     eax, CR_SUCCESS

    .ENDIF

    pop     edi
    pop             edx
    pop             ecx
    pop             ebx


;       end up here after success or fail
DoConfigStartDone:
    add     esp, SIZE Config_Buff_s                 ; adjust stack
    cmp     eax, CR_SUCCESS
    je      DoConfigStartExit

DoConfigStartError:
    Debug_Out "MiniVDD:  MiniVDD PnP_New_Devnode failed"
    stc

DoConfigStartExit:
    ret

EndProc DoConfigStart

;******************************************************************************
;
;   MiniVDD_PnP_New_DevNode
;
;   DESCRIPTION:
;       Handles system control calls for PnP_NEW_DEVNODE.  This routine
;       allocates the reference data for the adapter, and registers as the
;       driver for the devnode.
;
;   ENTRY:
;       EBX = Devnode handle
;       EDX = Subfunction (should always be LOAD_DRIVER)
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       Can use all registers and flags
;
;==============================================================================

BeginProc MiniVDD_PnP_New_DevNode

        cmp     edx, DLVXD_LOAD_DRIVER  ; Q: Is this the driver?
        jne     SSND_Error              ;    N: Strange!!!

;       It seems CM_Register_Device_Driver causes a problem in the Win95 VDD. The VDD won't do the VESA DDC call (4F15).
;       Avoid doing it (CM_Register_Device_Driver) in Win95.

;   Well. It does not work on Win98 also! So Just do it the old way. The code to register for
;   config manager messages is left here commented out. Maybe someday Microsoft will fix this
;   and we can do it the documented way :-)

    VMMcall     Get_VMM_Version
    .IF (!(carry?) && (ax == 040ah))
       ; This is win98. Register to get config messages.
       VxDcall _CONFIGMG_Register_Device_Driver, <ebx, OFFSET32 MiniVDD_Config_Handler, 0, CM_REGISTER_DEVICE_DRIVER_DISABLEABLE OR CM_REGISTER_DEVICE_DRIVER_REMOVABLE>
           .ERRNZ       CR_SUCCESS
           test eax, eax
           jnz  SSND_Couldnt_Reg_Driver

       ; Register succeeded.
    .ENDIF

    ; Just do the init here for both win95 and win98.
    ; On win98, eventhough we get the CONFIG_START message, we get it multiple times
    ; for each devNode. To avoid hassles, just do the handling here and ignore the CONFIG_START
    ; messages.
    call DoConfigStart
    cmp eax, CR_SUCCESS
    jne SSND_Error
    jmp MiniVDD_new_devnode_Exit

;   Unable to register driver.
SSND_Couldnt_Reg_Driver:
        Debug_Out "MiniVDD:  Register device driver failed for devnode #EDI"

SSND_Error:
        Debug_Out "MiniVDD:  MiniVDD PnP_New_Devnode failed"
        mov     eax, CR_FAILURE
        stc
MiniVDD_new_devnode_Exit:
        ret

EndProc MiniVDD_PnP_New_Devnode

;******************************************************************************
;
;   MiniVDD_Config_Handler
;
;   DESCRIPTION:
;       This is the plug and play driver entry point for the MiniVDD.
;       This routine is called by the config manager to notify this driver
;       of configuration related actions.
;
;   THIS PROC IS NOT USED NOW. To enable this procedure, uncomment the code
;   to register for config manager messages in MiniVDD_PnP_New_Devnode.
;
;   ENTRY:
;       cfFuncName = The function to perform.
;       sbfSubFuncName = The subfunction to perform.
;       dnToDevNode = Handle of the devnode being called.
;       dnAboutDevNode = Handle of the subject of the event.
;       ulFlags = Flags value.
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

BeginProc MiniVDD_Config_Handler, CCALL

ArgVar  cfFuncName, DWORD
ArgVar  scfSubFuncName, DWORD
ArgVar  dnDevNode, DWORD
ArgVar  dwRefData, DWORD
ArgVar  ulFlags, DWORD

        EnterProc
        push    ebx
        push    esi
        push    edi

        .IF ([cfFuncName] == CONFIG_FILTER)

           ;> Filter logical configurations for controller.
           ;> This is called before start and may not be required.

           mov eax, CR_SUCCESS

        .ELSEIF ([cfFuncName] == CONFIG_START)

           Debug_Out "MiniVDD:  PnP Start"
       ; We should called twice with CONFIG_START. Once with a subfunction of CONFIG_START_FIRST_START
       ; and once with a subfunction of CONFIG_START_DYNAMIC_START.
       ; But both times we get CONFIG_START_FIRST_START. So the handling of this message is already
       ; done in pnp_new_devnode.
       mov eax, CR_SUCCESS

        .ELSEIF ([cfFuncName] == CONFIG_STOP)

       Debug_Out "MiniVDD:  PnP Stop"
       ; need to add code to handle this.
       mov eax, CR_SUCCESS

        .ELSEIF ([cfFuncName] == CONFIG_TEST)

           Debug_Out "MiniVDD:  PnP Test"
           mov  eax, CR_SUCCESS         ; Secondary device can be removed.

        .ELSEIF ([cfFuncName] == CONFIG_TEST_SUCCEEDED)

           Debug_Out "MiniVDD:  PnP Test succeeded"
       mov ebx, dnDevNode
       call DoConfigRemove

        .ELSEIF ([cfFuncName] == CONFIG_REMOVE)

       Debug_Out "MiniVDD:  PnP Remove"
           ;> The controller devnode is being removed, this driver must stop
           ;> using the allocated configuration.  Any allocated data for this
           ;> devnode should be freed.  If the driver is dynamically loaded it
           ;> will be unloaded by the config manager.  This driver will not be
           ;> called again after this call.

           ; If the user removes the device from the registry via the Device Manager,
           ; and we are the primary display, we can't just unload. We should keep displaying and the Config Manager should
           ; take care of the registry and ask if we want to restart.
       ;        call    _rmConfigStop
           ;VMMcall _HeapFree, <dwRefData, 0>
       ;        jmp     MiniVDDPnP_Success
       ;        mov     eax, CR_REMOVE_VETOED           ; if we are primary display, we can't be removed now
       ;        jmp MiniVDDPnP_Exit

       ; need to add code to handle this.
           mov  eax, CR_FAILURE         ; don't allow removal

    .ELSEIF ([cfFuncName] == CONFIG_PRESHUTDOWN)
       Debug_Out "MiniVDD:  PnP PreShutdown"
       ; need to add code to handle this.
       mov eax, CR_SUCCESS

    .ELSE
       mov eax, CR_DEFAULT

    .ENDIF

        .ERRNZ CR_SUCCESS

; Exit with eax = status
        pop     edi
        pop     esi
        pop     ebx
        LeaveProc
        Return

EndProc MiniVDD_Config_Handler

;******************************************************************************
;
;   MiniVDD_Sys_VM_Terminate
;
;   DESCRIPTION:        Windows is shutting down. We set a mode 3 to prepare for the Windows shutting down message
;
;   ENTRY:
;
;   EXIT:
;       EAX = CR_RESULT
;
;   USES:
;       EAX, ECX, EDX
;
;==============================================================================

public  MiniVDD_Sys_VM_Terminate
BeginProc MiniVDD_Sys_VM_Terminate
;We are leaving Windows and going to text mode
;Entry:
;       EBX contains the VM handle of the Windows VM.
;Exit:

;               Nothing to do?
;               Tell the SysVM we did it successfully then
                clc
                ret
EndProc MiniVDD_Sys_VM_Terminate
;

;
subttl          Display Driver Is Being Disabled Notification
page +
public  MiniVDD_DisplayDriverDisabling
BeginProc       MiniVDD_DisplayDriverDisabling, RARE
;
;The display driver is in its Disable routine and is about to set the
;hardware back into VGA text mode.  Since this could either mean that
;the Windows session is ending or that some Windows application is switching
;to a VGA mode to display something full screen (such as MediaPlayer), we
;need to disable our MiniVDD_RestoreRegisters code because we're liable
;to restore a Windows HiRes state when we shouldn't!  Thus, clear the
;DisplayEnabledFlag to prevent this:
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_DisplayDriverDisabling", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

MDDDExit:
IFDEF DEBUG_LOG
        pushf
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "\n\r", DEBLEVELMAX
                pop     eax
        .endif
        popf
ENDIF ; DEBUG_LOG
        ret                             ;
EndProc MiniVDD_DisplayDriverDisabling
;

subttl          Register Display Driver Dependent Data
page +
public  MiniVDD_RegisterDisplayDriver
BeginProc MiniVDD_RegisterDisplayDriver, RARE
;
;Oft-times, the display driver must set flags whenever it is doing
;certain things to a hardware BLTer (such as "I'm in the middle of
;transferring a source bitmap").  This routine is called to allow
;this mini-VDD to get data (usually containing addresses inside the
;display driver's Data segment) directly from the display driver.
;We can also save appropriately needed states here.
;
;       The only client registers that are reserved (and cannot be used
;to pass data in) are EAX (which contains the function code which the
;display driver uses to call the "main" VDD) and EBX (which contains the
;Windows VM handle).  When we get called by the "main" VDD, we'll be
;passed a flag in Client_AL which will be set to non-zero if the VFLATD
;VxD is being used for banked support or zero if VFLATD is NOT involved in
;this session.
;
;NVIDIA: we use this function to pass the device handle to the resource manager. If running multiple devices, we need
;       to know which device (from the display driver's point of view), is associated with which address (the RM's
;       point of view). The miniVDD is the link between these entities.
;Entry:
;       EBP --> the Client Register Structure (documented in VMM.INC)
;
IFDEF DEBUG_LOG
        .if (DebugOn != 0)
                push    eax
                Debug_Printf    "MiniVDD_RegisterDisplayDriver", DEBLEVELMAX
                pop     eax
        .endif
ENDIF ; DEBUG_LOG

MRDDExit:

;
        ; This is no longer used.
        ret                             ;
EndProc MiniVDD_RegisterDisplayDriver


;******************************************************************************
;       Any use for this function?
public  MiniVDD_GetTotalVRAMsize
BeginProc       MiniVDD_GetTotalVRAMsize, DOSVM
        push    eax
        mov     ecx,800000h             ; default = 8M
        REG_RD32(NV_PFB_BOOT_0)
        test    ax,40h
        jnz     @f
        shr     ecx,1                   ; 4M?
        test    ax,4
        jnz     @f
        shr     ecx,1                   ; must be 2M
@@:     mov     TotalMemorySize,ecx     ; probably won't use this
        stc                             ;
        pop     eax

                ret
EndProc         MiniVDD_GetTotalVRAMsize

;******************************************************************************
;
;   MiniVDD_GetAdpaterPowerState
;
;   DESCRIPTION:        ACPI power capabilities
;
;   ENTRY:  Device Node (stack)
;
;   EXIT:
;       EAX = Capabilities (bit 0-3 set if D0-D3 supported)
;
;==============================================================================
public  MiniVdd_GetAdapterPowerStateCaps
BeginProc MiniVdd_GetAdapterPowerStateCaps, RARE
;
;Entry:
;       DevNode.
;Exit:
;       The CAPS of adapter
        ArgVar  DeviceNode, DWORD               ;message number
        EnterProc
        cmp     OSVersion,VERS_MILLENNIUM       ;Win98 or Millennium?
        jb      OSVer_Win98
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D3 or CM_POWERSTATE_D1 or CM_POWERSTATE_HIBERNATE)
        jmp     GAPSC_Done
OSVer_Win98:
        mov     eax, (CM_POWERSTATE_D0 or CM_POWERSTATE_D3 or CM_POWERSTATE_D1)
GAPSC_Done:
        LeaveProc
        Return
EndProc MiniVdd_GetAdapterPowerStateCaps

subttl          Set adapter Power State
page +

;******************************************************************************
;
;   MiniVDD_SetAdpaterPowerState
;
;   DESCRIPTION:        ACPI power state transition
;
;   ENTRY:  Device Node, Power State (stack)
;
;   EXIT:
;       EAX = CR_RESULT
;
;==============================================================================
public  MiniVdd_SetAdapterPowerState
BeginProc MiniVdd_SetAdapterPowerState, RARE
;Entry:
;       DevNode.
;       PowerState.
;Exit:
;       CR_DEFAULT  - OS should POST the device
;   CR_SUCCESS  - OS should do nothing
        ArgVar  DeviceNode, DWORD
        ArgVar  PowerState, DWORD
        ArgVar  DevInstance, DWORD

        EnterProc
        pushad
; Find the device instance and the current state
        mov     ebx,DeviceNode
        call    findDevNode
        jc      SAPS_Ret    ; find it?

        mov     ebx, [esi].minivdd_instance_Struct.instance_hDev
        mov     DevInstance,ebx
        mov     ebx, [esi].minivdd_instance_Struct.instance_ACPI_state
        mov     ebx,PowerState  ; requested state
;
; Check for restoring to D0, if not we must be going to D1, D2, or D3.
;
; state n = bit n
        test    ebx,CM_POWERSTATE_D3
        jnz     SAPS_D3
        test    ebx,CM_POWERSTATE_D2
        jnz     SAPS_D2
        test    ebx,CM_POWERSTATE_D1
        jnz     SAPS_D1
        test    ebx,CM_POWERSTATE_HIBERNATE
        jnz     SAPS_D3

;   if we are going to state 3, we shut down.
;   if we are coming back to state 0, we must start up.
SAPS_D0:
        mov     ebx,PowerState
        cmp     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx
        je      SAPS_Ret
        mov     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx   ; save new state
;       call RM to start up (use API)
        mov     ebx,DevInstance     ; device instance
        mov     eax, NVRM_API_POWER_UP
        call    CallRM
        jmp     SAPS_Ret

SAPS_D3:
        mov     ebx,PowerState
        cmp     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx
        je      SAPS_Ret
        mov     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx   ; save new state
;       call RM to shut down (use API)
        mov     ebx,DevInstance     ; device instance
        mov     eax, NVRM_API_POWER_DOWN
        call    CallRM
        jmp     SAPS_Ret

SAPS_D2:
;   not supported
if 0
        mov     ebx,PowerState
        cmp     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx
        je      SAPS_Ret
        mov     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx   ; save new state
;       call RM to shut down (use API)
        mov     ebx,DevInstance     ; device instance
        mov     eax, NVRM_API_POWER_D2
        call    CallRM
endif
        jmp     SAPS_Ret

SAPS_D1:
        mov     ebx,PowerState
        cmp     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx
        je      SAPS_Ret
        mov     [esi].minivdd_instance_Struct.instance_ACPI_state, ebx   ; save new state
;       call RM to shut down (use API)
        mov     ebx,DevInstance     ; device instance
        mov     eax, NVRM_API_POWER_D1
        call    CallRM

SAPS_Ret:
        popad
        mov     eax,CR_DEFAULT
        LeaveProc
        Return
EndProc MiniVdd_SetAdapterPowerState
;
; Call the resource manager.
;
BeginProc       CALLRM
;               push everything onto stack so we have the top of a client reg struct. (see VMM.H)
        push    esi
        mov     esi, offset callrm_rmusrapi
        mov     dword ptr [esi].minivdd_CALLRM_rmusrapi_Struct.rmusrapi_function, eax
	dec     ebx
        mov     dword ptr [esi].minivdd_CALLRM_rmusrapi_Struct.rmusrapi_device, ebx
        mov     eax,esi
        pop     esi

        push    eax
        push    ecx
        push    edx
        push    ebx
        push    eax                             ; res0, documented as "ESP at pushall"
        push    ebp
        push    esi
        push    edi
        mov     ebp, esp                ; point ebp to client reg struct
        call    DWORD PTR ResManAPI
        pop     edi
        pop     esi
        pop     ebp
        pop     eax                             ; res0
        pop     ebx
        pop     edx
        pop     ecx
        pop     eax
        ret
EndProc CALLRM

;
VxD_LOCKED_CODE_ENDS
;
;
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\dtrace.h ===
//
// low overhead tracing facility
//

// add "#define DEFINE_GLOBALS" in only 1 file!
#ifdef DEFINE_GLOBALS
#define	GLOBAL
#define	INIT(_x_)	= _x_
#else
#define	GLOBAL	extern
#define	INIT(_x_)
#endif

#define DTRACE	1

#ifdef DTRACE

#undef DTRACE
#define DTRACE(val)	do_dtrace((unsigned int) val, 0)
#define	DTRACE_CC(val)	do_dtrace((unsigned int) val, 1)
#define	DTRACE_RC(rc)	if ( (rc) != 0 ) { DTRACE_CC('EEEE'); DTRACE(rc); }
#define DTRACE_CYCLE_DELTA()  dtraceCycleDelta()
#define DTRACE_CYCLE_COUNT_AND_DELTA()  dtraceCycleCountAndDelta()
#define	DTRACING

#else // no trace support

#define DTRACE(val)
#define	DTRACE_CC(val)
#define	DTRACE_RC(rc)
#define DTRACE_CYCLE_DELTA()
#define DTRACE_CYCLE_COUNT_AND_DELTA()
#undef	DTRACING

#endif

#ifdef DTRACING

#define DTRACE_ENTRIES	1024	// must be power of two
GLOBAL unsigned int	dtrace_buf[DTRACE_ENTRIES+1];
GLOBAL int          dtrace_idx INIT(0);

static void
do_dtrace( unsigned int val, int char_const )
{

    /*
     * Some compilers "reverse" long character constants from their
     * readable forms.  Detect and fix that here.
     */

    if ( char_const && ('\0\0\0\1' != 1) )
	val = ((val & 0xff) << 24) +
	      (((val >> 8) & 0xff) << 16) +
	      (((val >> 16) & 0xff) << 8) +
	      ((val >> 24) & 0xff);

    /* XXX enter critical section */

    dtrace_buf[dtrace_idx++] = val;
    dtrace_idx &= (DTRACE_ENTRIES - 1);
    dtrace_buf[dtrace_idx] = '***\0';

    /* XXX exit critical section */

    return;

}

#endif /* DTRACING */

//
// cycle count stuff
//

GLOBAL unsigned int prevHi INIT(0);
GLOBAL unsigned int prevLo INIT(0);

static unsigned int getCycleCount( unsigned int* pHi, unsigned int* pLo )
{

    unsigned int        hi, lo;

    /* emit RDTSC instruction to get clock count */
    __asm
    {
        _emit   0x0f 
        _emit   0x31
        mov         hi, edx
        mov         lo, eax
    }

    *pHi = hi;
    *pLo = lo;

    return(lo);

}

static unsigned int getDeltaCycles( 
    unsigned int endHi, 
    unsigned int endLo, 
    unsigned int startHi, 
    unsigned int startLo)
{

    unsigned int resultHi, resultLo;

    if ( endLo > startLo ) {
        resultLo = endLo - startLo;
    }
    else {
        resultLo = 4294967295 - (startLo-endLo);
        endHi--;
    }

    // resultHi = endHi - endLo;
    
    return(resultLo);

}

static void dtraceCycleDelta()
{
    unsigned int    currentHi, currentLo, deltaLo;
    
    getCycleCount(&currentHi,&currentLo);
    deltaLo = getDeltaCycles(currentHi, currentLo, prevHi, prevLo);
    
    DTRACE(deltaLo);

    prevHi = currentHi;
    prevLo = currentLo;
    
}

static void dtraceCycleCountAndDelta()
{
    unsigned int    currentHi, currentLo, deltaLo;
    
    getCycleCount(&currentHi,&currentLo);
    deltaLo = getDeltaCycles(currentHi, currentLo, prevHi, prevLo);
    
    DTRACE(currentLo);
    DTRACE(deltaLo);

    prevHi = currentHi;
    prevLo = currentLo;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\nvpeos.inc ===
;
; nvpeos.inc
;
; Include file for miniVDD side of NVPE.
;

ifndef _NVPEVDD_INC
_NVPEVDD_INC   EQU     1

;
; IOCTL defines (must mirror ioctl defines in nvpeos.h
;
VDD_IOCTL_NVPE_COMMAND     EQU     300CAFE0H

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\timing.c ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: timing.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           9/23/98                                          *
*                                                                           *
\***************************************************************************/
#define RESMANSIDE
#define INVDDCODE

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

// MS includes
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"

#include "vmm.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"

// unit specific includes
#include "surfaces.h"
#include "vddsurfs.h"
#include "vpvdd.h"

#include "timing.h"

#ifndef DPF
#define  DPF(a) _Debug_Printf_Service(a)
#endif

extern vpSurfaces 			MySurfaces;

void InitTiming() {

	
}

U032 CheckExclude(TIMINGTYPES timingType) {
  // when this function returns TRUE then this timing mark is NOT recorded...

  switch (timingType) {
		case TRANSFERLAUNCH :
		case NOTIFYTRAN :
//		case NOTIFYIMG :
//		case OVFLIPREQ :
//  	case OVFLIPNOT :
		case TRANSFERRECRE :
		case TRANSBUFTYPE :
//		case OVERLAYFAIL :
		case PROGRAMVBI :
//		case PROGRAMIMG :
		case NOTIFYVBI :
		case CHECKCURBUF :
		case CHECKLASTBUF :
		case CHECKCURFLD :
		case ENTERCOLORCTL :
		case LEAVECOLORCTL :
		case WAITOCCCOLORCTL :
		case WAITCHROMAARRIVE :
		case WAITCHROMARETURN :
		case WAITLUMAARIVE :
		case WAITLUMARETURN :
        return 1;
  		default:		
  			break;
  }
  

  return 0;
}

//#define NOLOOPTIMING

void MarkTimingNot(TIMINGTYPES timingType,NvNotification*  pNot, U032 pSurf, U032 Indices) {

	U032 Time0;
	U032 Time1;
	U032 count;
	
  if (CheckExclude(timingType)) return;

	Time0 =	pNot->timeStamp.nanoseconds[0];
	Time1 =	pNot->timeStamp.nanoseconds[1];
			
	count = MySurfaces.Timings.LoopCount;
	MySurfaces.Timings.Time0[count] = Time0;
	MySurfaces.Timings.Time1[count] = Time1;
	MySurfaces.Timings.SurfDat[count] = timingType;
	MySurfaces.Timings.SurfIndex[count] = Indices;
	MySurfaces.Timings.SurfPtr[count] = pSurf;
	
	count++;
	if(count >= MAXDATASTORE ) {
#ifdef NOLOOPTIMING
		count = MAXDATASTORE-1;
#else 
		count = 0;
#endif
	}

	MySurfaces.Timings.LoopCount = count;

	return;
}
			

void	MarkTiming(TIMINGTYPES timingType,U032 pSurf, U032 Indices) {
	U032 Time0;
	U032 Time1;
	U032 count;
	
	if (CheckExclude(timingType)) return;

	if(MySurfaces.pNvTimer != NULL) {
		Time0 = *(MySurfaces.pNvTimer);
		Time1 = *((U032*)(((U032)(MySurfaces.pNvTimer))+0x10));
	} else {
		Time0 = 0;
		Time1 = 0;
	}
	
	count = MySurfaces.Timings.LoopCount;
	MySurfaces.Timings.Time0[count] = Time0;
	MySurfaces.Timings.Time1[count] = Time1;
	MySurfaces.Timings.SurfDat[count] = timingType;
	MySurfaces.Timings.SurfIndex[count] = Indices;
	MySurfaces.Timings.SurfPtr[count] = pSurf;
	
	count++;
	if(count >= MAXDATASTORE ) {
#ifdef NOLOOPTIMING
		count = MAXDATASTORE-1;
#else 
		count = 0;
#endif
	}

	MySurfaces.Timings.LoopCount = count;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\vpvdd.h ===
#ifndef _VP_VDD_H_
#define _VP_VDD_H_


U032	vddGetIRQInfo(U032 dwMiniVDDContext, U032 dummy, DDGETIRQINFO* pGetIrgInfo);
U032	vddIsOurIRQ(U032 dwMiniVDDContext, U032 dummy);
U032	vddEnableIRQ(U032 dwMiniVDDContext, DDENABLEIRQINFO* pEnableIrqInfo, U032 dummy);
U032	vddSkipNextField(U032 dwMiniVDDContext, DDSKIPINFO* pSkipInfo, U032 dummy);
U032	vddBobNextField(U032 dwMiniVDDContext, DDBOBINFO* pBobInfo, U032 dummy);
U032	vddSetState(U032 dwMiniVDDContext, DDSTATEININFO* pSetStateInfo, DDSTATEOUTINFO* pSetStateInfoOut);
U032	vddLock(U032 dwMiniVDDContext, DDLOCKININFO* pLockInfoIn, DDLOCKOUTINFO* pLockInfoOut);
U032	vddFlipOverlay(U032 dwMiniVDDContext, DDFLIPOVERLAYINFO* pFlipOverlayInfo, U032 dummy);


U032	vddGetFieldPolarity(U032 dwMiniVDDContext, DDPOLARITYININFO* pGetPolarityInInfo, DDPOLARITYOUTINFO* pGetPolarityOutInfo);



// for whatever reason the "real" definition won't work here so no big deal since we don't
// really USE this function, but it goes to show that MS headers are CRAP
//U032	vddFlipVideoPort(U032 dwMiniVDDContext, DDFLIPVIDEOPORT* pFlipVideoPort,U032 dummy);
U032	vddFlipVideoPort(U032 dwMiniVDDContext, U032* pFlipVideoPort, U032 dummy);


U032	vddSetSkipPattern(U032 dwMiniVDDContext, DDSETSKIPINFO* pSetSkipInfo, U032 dummy);
U032	vddGetCurrentAutoFlip(U032 dwMiniVDDContext, DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut);
U032	vddGetPreviousAutoFlip(U032 dwMiniVDDContext, DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut);


U032	vddTransfer(U032 dwMiniVddContext, DDTRANSFERININFO* pTransferInInfo, DDTRANSFEROUTINFO* pTransferOutInfo );

U032 vddGetTransferStatus(U032 dwMiniVddContext, U032 dummy, DDGETTRANSFERSTATUSOUTINFO* pGetTransStatusInfo );


#endif //_VP_VDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\vddsurfs.h ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: vddsurfs.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/21/98                                          *
*                                                                           *
\***************************************************************************/

#ifndef VDDSURFS_H
#define VDDSURFS_H

#define  MYCHECKFREECOUNT(a,b)								\
	ASSERT(b < NV06A_FIFO_GUARANTEED_SIZE );			\
	while (MySurfaces.myFreeCount < b)								\
		MySurfaces.myFreeCount = NvGetFreeCount(a, 0);			\
	MySurfaces.myFreeCount -= b;										


typedef VOID (*ACALLBACKTYPEPROC)(void);


U032 vddhandleBufferInterrupts(U032 dummy1, U032 dummy2, U032 dummy3);

U032 startSurfaces(U032	bInterleave, VPSTATE*	pVideoPortStatus );

U032 	scheduleFlipToSurface(DDSURFACEDATA* pCurSurf,FIELDTYPE	fieldType);

void Overlay0NotifyProc(void);
void Overlay1NotifyProc(void);

void    reportError(U032 interruptingBuffer,U032 oldSurface);


#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)
#define NV_VFM_FORMAT_BOBFROMINTERLEAVE           (0x08000000)

#endif // VDDSURFS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\vpvdd.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: vpvdd.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           4/22/98                                          *
*                                                                           *
\***************************************************************************/

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

// MS includes
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
#include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"


// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
// unit specific includes
#define RESMANSIDE
#include "surfaces.h"
#include "vddsurfs.h"
#include "vpvdd.h"
#include "vddsurfs.h"
#include "transfer.h"
#include "nvrmr0api.h"


extern vpSurfaces 			MySurfaces;
extern NvNotification		nvMyVPNotifiers[NUMVPNOTIFIERS];

U032 vddWriteVPEPrescale(U032 ulX, U032 ulY, U032 ulCap, U032 ulVPUseOverlay, U032 ulFlag);

U032	vddGetIRQInfo(U032 dwMiniVDDContext, U032 dummy, DDGETIRQINFO* pGetIrgInfo) {
/*
;   DESCRIPTION: If the Mini VDD is already managing the IRQ, this
;          function returns that information; otherwise, it returns the
;          IRQ number assigned to the device so DDraw can manage the IRQ.
;
;          The returning the IRQ number, it is important that it get the
;          value assigned by the Config Manager rather than simply get
;          the value from the hardware (since it can be remapped by PCI).
*/
	// Not gonna do it.... 
	pGetIrgInfo->dwFlags =IRQINFO_HANDLED;
	
	return 0;
}

U032	vddIsOurIRQ(U032 dwMiniVDDContext, U032 dummy) {
/*
;   DESCRIPTION: Called when the VDD's IRQ handled is triggered.  This
;          determines if the IRQ was caused by our VGA and if so, it
;          clears the IRQ and returns which event(s) generated the IRQ.
*/

	return 1;
}

U032	vddEnableIRQ(U032 dwMiniVDDContext, DDENABLEIRQINFO* pEnableIrqInfo, U032 dummy) {
/*
;   DESCRIPTION: Notifies the Mini VDD which IRQs should be enabled.  If
;          a previously enabled IRQ is not specified in this call,
;          it should be disabled.
*/


  //  Here's where we're going to call NvRmR0interrupt()  
  // the purpose is so that the APIEntry variable will get filled
  // now instead of in the future where we're possibly inside an ISR
  #define NV_WIN_DEVICE                            0x00002002
  if(MySurfaces.pDriverData != 0 ) {
    if(MySurfaces.pDriverData->dwRootHandle != 0 ) { 
      NvRmR0Interrupt (MySurfaces.pDriverData->dwRootHandle, NV_WIN_DEVICE);   
    }
  }                         
  
	// just remember these guys, and check them AFTER we've done the real flips in vddsurfs
#define KMVTON
#ifdef KMVTON
	MySurfaces.DXIRQCallbackSources = pEnableIrqInfo->dwIRQSources;
	MySurfaces.pDXIRQCallback = pEnableIrqInfo->IRQCallback;
	MySurfaces.dwIrqContext = pEnableIrqInfo->dwContext;
	return 0;
#else
	return 1;
#endif

}

U032	vddSkipNextField(U032 dwMiniVDDContext, DDSKIPINFO* pSkipInfo, U032 dummy) {
/*
;   DESCRIPTION: Called when they want to skip the next field, usually
;       to undo a 3:2 pulldown but also for decreasing the frame rate.
;       The driver should not lose the VBI lines if dwVBIHeight contains
;       a valid value.
;
*/
	// heh this one is easy!
	if(pSkipInfo->dwSkipFlags & DDSKIP_SKIPNEXT )
		MySurfaces.bSkipNextField = TRUE;
	else if(pSkipInfo->dwSkipFlags & DDSKIP_ENABLENEXT )
		MySurfaces.bSkipNextField = FALSE;
	else 
		return 1;
	return 0;
}


U032	vddBobNextField(U032 dwMiniVDDContext, DDBOBINFO* pBobInfo, U032 dummy) {
/*
;   DESCRIPTION: Called when "bob" is used and a VPORT VSYNC occurs that does
;       not cause a flip to occur (e.g. bobbing while interleaved).  When
;       bobbing, the overlay must adjust itself on every VSYNC, so this
;       function notifies it of the VSYNCs that it doesn't already know
;       about (e.g. VSYNCs that trigger a flip to occur).
*/

	// this is used to change to the next bob in bob from interleaved...
	// however only really useful during software autoflipping.
	
	// we do hardware, so this does not have utility.

	return 1;
}

U032	vddSetState(U032 dwMiniVDDContext, DDSTATEININFO* pSetStateInfo, DDSTATEOUTINFO* pSetStateInfoOut) {
/*
;   DESCRIPTION: Called when the client wants to switch from bob to weave.
;	The overlay flags indicate which state to use. Only called for interleaved
;   surfaces.
;
;	NOTE: When this is called, the specified surface may not be
;	displaying the overlay (due to a flip).  Instead of failing
;	the call, change the bob/weave state for the overlay that would
;	be used if the overlay was flipped again to the specified surface.
*/
	U032	dwSrcHeight;
	U032	dwDstHeight;
	U032	dwDstWidth;
	U032	dwSrcWidth;
	U032	showInterleavedFields = 0;
	long	srcDeltaX;
	long	srcDeltaY;
	U032 	index;
	U032	dwFormat;
	
	
	DDSURFACEDATA* pCurSurf = (DDSURFACEDATA*) pSetStateInfo->lpSurfaceData;
	//pSetStateInfo->lpVideoPortData;

	pCurSurf->dwOverlayFlags;			// may change
	pCurSurf->dwOverlayOffset;				// what the hell is this?  X,Y  or offset from base, or it's it Precalced from X,Y
													// golly gee I love these docs!
	pCurSurf->lPitch;

	dwSrcHeight = pCurSurf->dwOverlaySrcHeight;
	dwDstHeight = pCurSurf->dwOverlayDestHeight;
	dwDstWidth = pCurSurf->dwOverlayDestWidth;
	dwSrcWidth = pCurSurf->dwOverlaySrcWidth;

	if (!(pCurSurf->dwOverlayFlags & DDOVER_AUTOFLIP)) {
		// we only work in auto flip mode so this is bad!
		
		return 0;
	}
	
	(MySurfaces.pDriverData)->dwOverlaySrcHeight = dwSrcHeight;
	(MySurfaces.pDriverData)->dwOverlayDstHeight = dwDstHeight;
	
	if (dwSrcHeight > dwDstHeight) {
		dwSrcHeight >>= 1; /* We only support vertical shrinking and it can't be by more than .5 */
		if (dwSrcHeight > dwDstHeight) {
 				return DDERR_UNSUPPORTED;
		}    
	}

	
	if ((pCurSurf->dwOverlayFlags & DDOVER_INTERLEAVED) &&
		(pCurSurf->dwOverlayFlags & DDOVER_BOB)) {
 				showInterleavedFields = 1;
 				dwSrcHeight >>= 1;
	}
	
	dwDstWidth = (dwDstWidth + 2) & ~1L;
	dwDstHeight = (dwDstHeight + 2) & ~1L;
	
	srcDeltaX = (dwSrcWidth - 1) << 16;
	srcDeltaX /= dwDstWidth - 1;
	srcDeltaX <<= 4;
	
	srcDeltaY = (dwSrcHeight - 1) << 16;
	srcDeltaY /= dwDstHeight - 1;
	srcDeltaY <<= 4;

	index = 0;

#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)
#define NV_VFM_FORMAT_BOBFROMINTERLEAVE           (0x08000000)
	
	dwFormat = NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8;

	if((pCurSurf->dwOverlayFlags & DDOVER_BOB) && (pCurSurf->dwOverlayFlags & DDOVER_INTERLEAVED) ){
		dwFormat = dwFormat | NV_VFM_FORMAT_BOBFROMINTERLEAVE;
	}

	if (pCurSurf->dwOverlayFlags & DDOVER_AUTOFLIP) {
		dwFormat |= (index ? NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 : 
			NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0);
	}

	(MySurfaces.pDriverData)->OverlayFormat = dwFormat;

	// output
	/*
	typedef struct _DDSTATEOUTINFO {
    DWORD dwSize;
    DWORD dwSoftwareAutoflip;
    DWORD dwSurfaceIndex;
    DWORD dwVBISurfaceIndex;
	} DDSTATEOUTINFO;
	*/

	pSetStateInfoOut->dwSoftwareAutoflip = 0;
	pSetStateInfoOut->dwSurfaceIndex = 0;
	pSetStateInfoOut->dwVBISurfaceIndex = 0;

	// this is called to switch from bob to weave or back again
	return 0;
}

U032	vddLock(U032 dwMiniVDDContext, DDLOCKININFO* pLockInfoIn, DDLOCKOUTINFO* pLockInfoOut) {
/*
;   DESCRIPTION: Called when the client wants to lock the surface to
;	access the frame buffer. The driver doens't have to do anything,
;       but it can if it needs to.
*/

	// we don't need to do anything here because of the way we work
	return 0;
}

U032	vddFlipOverlay(U032 dwMiniVDDContext, DDFLIPOVERLAYINFO* pFlipOverlayInfo, U032 dummy) {
/*
;   DESCRIPTION: Flips the overlay to the target surface.
*/	
	vpSurfaces*	pTheSurfaces = (vpSurfaces*) dwMiniVDDContext;
	DDSURFACEDATA* pCurSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpCurrentSurface;
	DDSURFACEDATA* pTargSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpTargetSurface;
	DWORD daFlags = pFlipOverlayInfo->dwFlags;
	FIELDTYPE	fieldType = UNKNOWN;
/* 
	YIKES   Ok, until I can break throught the mind lock of BMAC and be able to modify some of his code to acheieve
	      a sharing of the overlay class object, I'm just going to hacks something together here which will hit registers
			to get this done.   First part will attempt to get 
			
			We might be able to use the infamous "reserved" fields to get things down into here
*/
	//  We do Autoflip pretty much exclusively!
	// but jonka says that dell's gonna want this for their cheesier bt 848 card.  so oh well.
	
	
	// we need to figure out which index the pCurSurf is, and then pass this in
	// also we need to determine if we're doing bob from Interleave
	//U032 	scheduleOverlayFlip(U032 oldSurface,  U032 bIsBobFromInterleave) {
	
	if(daFlags & DDFLIP_EVEN  ) fieldType = EVEN;
	else if(daFlags & DDFLIP_ODD  ) fieldType = ODD;
	
	return scheduleFlipToSurface( pTargSurf, fieldType);

}

U032	vddFlipVideoPort(U032 dwMiniVDDContext, U032* pFlipVideoPort, U032 dummy) {
/*
;   DESCRIPTION: Flips the video port to the target surface.
*/
	//  We do Autoflip pretty much exclusively!
	return 1;
}

U032	vddGetFieldPolarity(U032 dwMiniVDDContext, DDPOLARITYININFO* pGetPolarityInInfo, DDPOLARITYOUTINFO* pGetPolarityOutInfo) {
	U032	returnval;
	
/*
;
;   DESCRIPTION: Returns the polarity of the current field being written
;	to the specified video port.
*/	

//	DPF(" vvv  vddGetFieldPolarity ");
	
	
	
	// we think that EVEN should be true...
	if( GetField() ) {
		pGetPolarityOutInfo->bPolarity = TRUE;
		returnval = 0;
	} else {
		pGetPolarityOutInfo->bPolarity = FALSE;
		returnval = 0;
	}
	MarkTiming (CHECKCURFLD,0, makeInd(INCNOTAP,pGetPolarityOutInfo->bPolarity,INCNOTAP,MySurfaces.curImageSurf));

	return returnval;
}


U032	vddSetSkipPattern(U032 dwMiniVDDContext, DDSETSKIPINFO* pSetSkipInfo, U032 dummy) {
/*
;
;   DESCRIPTION: Sets the skip pattern in hardware
;
*/
	return 1;
}

U032	vddGetCurrentAutoFlip(U032 dwMiniVDDContext, DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut) {
/*
;   DESCRIPTION: Returns the current surface receiving data from the
;	video port while autoflipping is taking palce.  Only called when
;   hardware autoflipping.
;
*/
#if 0
	pGetAutoFlipInfoOut->dwSurfaceIndex = MySurfaces.curImageSurf;
	pGetAutoFlipInfoOut->dwVBISurfaceIndex = MySurfaces.curVBISurf  - MySurfaces.VBIstart;
#endif //0

	// first count the number of buffers that we have "in progress"
	// there should always be at least one in progress, and possibly two.
	// if there are zero in progress, then we're not capturing at this moment
	// so it's ok to return a faulty value
	long curIMG;
	long curVBI;
	long countVBI = -1;
	long countIMG = -1;

#ifndef NV4
	if( nvMyVPNotifiers[notifyIndexFromBuffer(0)].status == NV_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(1)].status == NV_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(2)].status == NV_STATUS_IN_PROGRESS )
		countVBI++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(3)].status == NV_STATUS_IN_PROGRESS )
		countVBI++;
#else
	if( nvMyVPNotifiers[notifyIndexFromBuffer(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(2)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countVBI++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(3)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countVBI++;
#endif

	// now subtract this from 	the official current count, but add one since it's not the "next" buffer but the "current"
	curIMG = MySurfaces.curImageSurf - countIMG;
	curVBI = MySurfaces.curVBISurf - MySurfaces.VBIstart - countVBI;
	// now check for reverse wraparound
	if( MySurfaces.VBIstart > 0 )
		while(curIMG < 0 )
			curIMG = curIMG + MySurfaces.VBIstart;
	if( (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart) > 0 )
		while(curVBI < 0 )
			curVBI = curVBI + (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart);
		
	pGetAutoFlipInfoOut->dwSurfaceIndex = curIMG;
	pGetAutoFlipInfoOut->dwVBISurfaceIndex = curVBI;

	MarkTiming (CHECKCURBUF,0, makeInd(INCNOTAP,curVBI,INCNOTAP,curIMG));

	
	return 0;
}

U032	vddGetPreviousAutoFlip(U032 dwMiniVDDContext, DDGETAUTOFLIPININFO* pGetAutoFlipInfoIn, DDGETAUTOFLIPOUTINFO* pGetAutoFlipInfoOut) {
/*
;   DESCRIPTION: Returns the surface that received the data from the
;	previous field of video port while autoflipping is taking palce. Only
;   called for hardware autoflipping.
;
*/
	
	// This code is not quite working right....
	
	// first count the number of buffers that we have "in progress"
	// there should always be at least one in progress, and possibly two.
	// if there are zero in progress, then we're not capturing at this moment
	// so it's ok to return a faulty value
	long curIMG;
	long curVBI;
	long countVBI = -1;
	long countIMG = -1;
#ifndef NV4
	if( nvMyVPNotifiers[notifyIndexFromBuffer(0)].status == NV_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(1)].status == NV_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(2)].status == NV_STATUS_IN_PROGRESS )
		countVBI++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(3)].status == NV_STATUS_IN_PROGRESS )
		countVBI++;
#else
	if( nvMyVPNotifiers[notifyIndexFromBuffer(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countIMG++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(2)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countVBI++;
	if( nvMyVPNotifiers[notifyIndexFromBuffer(3)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS )
		countVBI++;
#endif
	// now subtract this from 	the official current count but subtract an additional since this is
	// the "previous" autoflip
	
	curIMG = MySurfaces.curImageSurf - countIMG -1;
	curVBI = MySurfaces.curImageSurf - MySurfaces.VBIstart - countVBI -1;
	// now check for reverse wraparound
	while(curIMG < 0 )
		curIMG = curIMG + MySurfaces.VBIstart;
	while(curVBI < 0 )
		curVBI = curVBI + (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart);
		
	pGetAutoFlipInfoOut->dwSurfaceIndex = curIMG;
	pGetAutoFlipInfoOut->dwVBISurfaceIndex = curVBI;


	MarkTiming (CHECKLASTBUF,0, makeInd(INCNOTAP,curVBI,INCNOTAP,curIMG) );
	return 0;
}


		

U032	vddTransfer(U032 dwMiniVddContext, DDTRANSFERININFO* pTransferInInfo, DDTRANSFEROUTINFO* pTransferOutInfo ) {
	pTransfer	pNewTransfer;
	U032			surfIndex = 99;

	// we don't do AGP transfers
	if(DDTRANSFER_NONLOCALVIDMEM & pTransferInInfo->dwTransferFlags ) {
		return 1;
	}
	
	// we DO handle cancels for things not yet queued
	if(DDTRANSFER_CANCEL & pTransferInInfo->dwTransferFlags ) {
		return CancelTransfer(pTransferInInfo);
	}
	
	ASSERT(pTransferInInfo != NULL );
	ASSERT(pTransferInInfo->dwSize == sizeof(DDTRANSFERININFO));

	NULL;
	
	pNewTransfer = AddTransfer(pTransferInInfo->dwTransferID);
	if(pNewTransfer == NULL )
		return 1;
		
	NULL;
	

#ifndef DDTRANSFER_HALFLINES
#define DDTRANSFER_HALFLINES 0x00000100
#endif
	
	if(DDTRANSFER_HALFLINES & pTransferInInfo->dwTransferFlags ) {
		pNewTransfer->StartLine = pTransferInInfo->dwStartLine;
		pNewTransfer->EndLine = pTransferInInfo->dwEndLine;
	} else {
		pNewTransfer->StartLine = pTransferInInfo->dwStartLine+1;
		pNewTransfer->EndLine = pTransferInInfo->dwEndLine+1;
	}
	
	pNewTransfer->SurfaceData = pTransferInInfo->lpSurfaceData;
	pNewTransfer->TransferFlags = pTransferInInfo->dwTransferFlags;
	pNewTransfer->DestMDL = pTransferInInfo->lpDestMDL;
	pNewTransfer->transferStatus = QUEUED;
			
	CheckForLaunch();
	{
		surfIndex = getSurfaceIndex(((DDSURFACEDATA*) pTransferInInfo->lpSurfaceData)->fpLockPtr);
		
		if(surfIndex != 99 ) {
			if( MySurfaces.Surfaces[surfIndex]->field == EVEN ) {
				pTransferOutInfo->dwBufferPolarity = TRUE;
			} else {
				pTransferOutInfo->dwBufferPolarity = FALSE;
			}
		} else {
			// can't tell what surface we were on... just report one
			pTransferOutInfo->dwBufferPolarity = TRUE;
		}
		
		// Hack.... for whatever reason, then VBI surface polarities appear to be reversed... hack the fix in
		if (surfIndex < MySurfaces.VBIstart) {
			// do nothing... 'tho these may be reversed as well
		} else {
			if( pTransferOutInfo->dwBufferPolarity )
				pTransferOutInfo->dwBufferPolarity = FALSE;
			else 
				pTransferOutInfo->dwBufferPolarity = TRUE;
		}
		
	}
	//pTransferOutInfo->dwBufferPolarity = 0;
	if (surfIndex < MySurfaces.VBIstart) {
		MarkTiming(TRANSBUFTYPE,(U032)pTransferInInfo->lpDestMDL->lpMappedSystemVa,makeInd2(INCNOTAP,INCNOTAP, INCNOTAP,surfIndex,MySurfaces.Surfaces[surfIndex]->field) );
	} else if(surfIndex < MySurfaces.numberOfSurfaces){
		MarkTiming(TRANSBUFTYPE,(U032)pTransferInInfo->lpDestMDL->lpMappedSystemVa,makeInd2(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP, MySurfaces.Surfaces[surfIndex]->field,) );
	} else {
		MarkTiming(TRANSBUFTYPE,(U032)pTransferInInfo->lpDestMDL->lpMappedSystemVa,makeInd2(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP,UNKNOWN) );
	}
	
	return 0;
}

U032 vddGetTransferStatus(U032 dwMiniVddContext, U032 dummy, DDGETTRANSFERSTATUSOUTINFO* pGetTransStatusInfo ) {
	U032 retValue;
	// return 0 means everything ok  1 means not good.

#if 0
// Input to vddGetTransferStatus
typedef struct _DDGETTRANSFERSTATUSOUTINFO {
    DWORD dwSize;
    DWORD dwTransferID;
} DDGETTRANSFERSTATUSOUTINFO;

	
#endif
	pTransfer pTheTransfer;
	pTheTransfer = FindTransfer(MySurfaces.dwMostRecentFinishTransferId);
	retValue = 1;
	if(pTheTransfer != NULL ) {
		switch (pTheTransfer->transferStatus) {
				case QUEUED:	
					pGetTransStatusInfo->dwTransferID = MySurfaces.dwMostRecentFinishTransferId;			
					retValue = 1;
				case PROGRAMMED:				
					pGetTransStatusInfo->dwTransferID = MySurfaces.dwMostRecentFinishTransferId;			
					retValue = 1;
				case FINISHED:	
					pGetTransStatusInfo->dwTransferID = MySurfaces.dwMostRecentFinishTransferId;			
					retValue = 0;
					
		}
		RemoveTransfer(MySurfaces.dwMostRecentFinishTransferId);
		MySurfaces.dwMostRecentFinishTransferId = TRANSFERNOTINUSE;
	} else {
		retValue = 1;
	}
	
	// this should error as well
	return retValue;
} 


/*
 * nvVPECommand() is a backdoor function to allow other Ring0 programs (like WDM)
 * to change or request various VPE functions.
 */

#define NV_VPE_CMD_SET_PRESCALE_MODE    1
#define NV_VPE_CMD_SET_CROP_MODE        2

ULONG nvVPECommand (
    ULONG cmd,
    PVOID pData )
{

    switch ( cmd ) {

    case NV_VPE_CMD_SET_PRESCALE_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to prescale
         * as oppose to cropping.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl	pI2CCtrl = pData;

            /*
             * set prescale flag and size
             */
			//Data(lower nibble)	=	0	not capturing
			//							1	capturing
			//Data(upper nibble)	=	2	X scale
			//							4	Y scale
			//Status	=	prescale/height * 1000
			if((pI2CCtrl->Data)& 0x40){
				vddWriteVPEPrescale(0, 
									((PI2CControl)pI2CCtrl)->Status,//set Y-prescale 
									((PI2CControl)pI2CCtrl)->Data,	//capture flag
									0, 
									6);								//prog. y-pre & cap. flag
			}else if((pI2CCtrl->Data)& 0x20){
				vddWriteVPEPrescale(((PI2CControl)pI2CCtrl)->Status,//set X-prescale
									0, 
									((PI2CControl)pI2CCtrl)->Data,	//capture flag
									0, 
									0xa);							//prog. x-pre & cap.flag
			}else{
				//error
			}
        }
        break;

    case NV_VPE_CMD_SET_CROP_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to crop
         * as oppose to prescaling.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl	pI2CCtrl = pData;

            /*
             * turn off prescale flag
             */

        }
        break;

    default:
        return 1;   
    }

    return 0;
}

void vddVPEInit()
{
	//Initialize VPE capture hack for WDM
	vddWriteVPEPrescale(1000,	//setting ME X-prescale factor. 1000=no scale
						1000,	//setting ME Y-prescale factor. 1000=no scale
						0,		//set default VP surf type = overlay  
						1,		//set to not vpe capture mode
						0xf);	//use all values

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\vddVP.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: vddsurfs.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           5/22/98                                          *
*                                                                           *
\***************************************************************************/

#define RESMANSIDE
#define INVDDCODE

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"

#include "vmm.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"

#include "nvddobj.h"

// This is here because it is defined in nvrmarch.inc. We can't include that file here.
#define NV_WIN_DEVICE                            0x00002002

// unit specific includes
#include "surfaces.h"
#include "vddsurfs.h"
#include "VPcallbk.h"

#ifdef NV4
#include "VidTex.h"
#endif

//#define  DPF(a)    /* a */
#ifndef DPF

#if 1
#define  DPF(a) _Debug_Printf_Service(a)
#else
#define START_STR  ("VDDSURF - ")
#define END_STR ("\n")

void __cdecl DPF(LPSTR szFormat, ...)
{
    char str[256];

    lstrcpy(str, START_STR);
    wvsprintf(str+lstrlen(str), szFormat, (LPVOID)(&szFormat+1));
    lstrcat(str, END_STR);
    OutputDebugString(str);
}
#endif  // if 1
#endif  // #ifndef DPF
//  things needing entry points
//        ProgramBufferWithSurface

#ifdef ASSERT
#undef ASSERT

#if 0
#define ASSERT(a)  NULL;
#else


#ifndef NV06A_FIFO_GUARANTEED_SIZE
#define NV06A_FIFO_GUARANTEED_SIZE  (NV_GUARANTEED_FIFO_SIZE)
#endif

#define ASSERT(a,b)   \
    if(a) {         \
    } else {        \
        DPF(b);   \
    }                
    
#endif  // 1

#endif  // ASSERT


#define NV3FBLIMIT  (0x3E8000)
void AssertFail(void) {
    DPF("AssertFail\n");
}

vpSurfaces             MySurfaces;
NvNotification        nvMyVPNotifiers[NUMVPNOTIFIERS];


FIELDTYPE    getFieldFromBuffer(U032 dwBuffIndex) {
    U032 daField;
    
    switch (MySurfaces.CurrentCaptureMode) {
            case EVENODD:
              if(dwBuffIndex == 0 ) {
                  daField = ODD;
                } else if(dwBuffIndex == 1 ) {
                  daField = EVEN;
                } else {
                  daField = UNKNOWN;
                }
                break;
            case EVENEVEN:
                daField = EVEN;
                break;
            case ODDODD:
                daField = ODD;
                break;
            default:
                ASSERT(MySurfaces.CurrentCaptureMode == ODDODD,"unknown field ASSERT failed\n" );
                daField = ODD;
    }
  return daField;
}
               
FIELDTYPE    getNextFieldType(FIELDTYPE lastFieldType,U032 dwBuffIndex) {

    switch (MySurfaces.CurrentCaptureMode) {
            case EVENODD:
// this is a fix which _SHOULD_ be benign for nv4 ( need to check it )
// but which protects us from NV10 behavior where field captures can start
// in the middle which can then set us into toxic behavior
// in which the buffer capture order is 0,0,1,1,0,0. and there are weird latency
// problems
#if 0

                if(lastFieldType ==EVEN ) {
                    return ODD;
                } else if( lastFieldType ==ODD ) {
                    return EVEN;
                } else {
                    return EVEN;
                }
                break;
#else
                if (dwBuffIndex == 0 ) {
                    return ODD;
                } else {
                    return EVEN;
                }
                break;
#endif
            case EVENEVEN:
                if(lastFieldType ==EVEN ) {
                    return EVEN;
                } else {
                    return EVEN;
                }    
                break;
            case ODDODD:
                if(lastFieldType ==ODD ) {
                    return ODD;
                } else {
                    return ODD;
                }    
                break;
            default:
                ASSERT(MySurfaces.CurrentCaptureMode == ODDODD,"unknown field ASSERT failed\n" );
                return ODD;
    }
}

U032  getSurfaceIndex(U032 pSurf ) {
    U032 i;
    // check for exact match
    for(i=0;i<MySurfaces.numberOfSurfaces;i++) {
        if((U032)(MySurfaces.Surfaces[i]->pVidMem) == ((U032) pSurf)) {
            return i;
        }
    }
    // check for something "within"
    for(i=0;i<MySurfaces.numberOfSurfaces;i++) {
        if( ((U032)(MySurfaces.Surfaces[i]->pVidMem) <= ((U032) pSurf))  &&
             ((U032)(MySurfaces.Surfaces[i]->pVidMem)+MySurfaces.Surfaces[i]->dwLength >= ((U032) pSurf)  )) {
                    return i;
        }
    }
    
    return 99;
}


U032    notifyIndexFromBuffer(U032 dwBuffer) {
    switch (dwBuffer) {
            case 0:
                return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
                break;
            case 1:
                return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
                break;
            case 2:
                return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
                break;
            case 3:
                return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
                break;
            default:
                {
                    DPF ("   Problem... trying get an index for an unknown buffer notify\n");
                    return UNKNOWNBUF;
                }
    }
}


U032    getNextSurface(U032 currentSurface, U032 bSingleAdvance) {
    U032    nextSurface;
    
    ASSERT(currentSurface < MAXVPSURFACES,"current surface to big ASSERT failed\n" );
    
    //Generally you are going to want to jump two surfaces ahead of the one you are on, but 
    // with a wrap around depending on what typeof surface you are
    // interleaved surface should only move ahead ONE buffer since both DMA engines are pointing
    // to the same surface
    if( currentSurface < MySurfaces.VBIstart ) {
        // we are an ImageSurface
        if(MySurfaces.CurrentScanMode == INTERLEAVBUF ) {
            if(bSingleAdvance) {
                // hopefully we don't get here....  this means our drop frame strategy for interelaved buffers is notworking
            }
            nextSurface = currentSurface + 1;
        } else {    
            if(bSingleAdvance) {
                nextSurface = currentSurface + 1;
            } else {
                nextSurface = currentSurface + 2;
            }
        }
        while(nextSurface >= MySurfaces.VBIstart) 
            nextSurface = nextSurface - MySurfaces.VBIstart;    
    } else {
        U032    temp;
        //we are a VBI surface
        nextSurface = currentSurface + 2 - MySurfaces.VBIstart;
        temp = MySurfaces.numberOfSurfaces - MySurfaces.VBIstart;
        while(nextSurface >= temp) 
            nextSurface = nextSurface - temp;
        nextSurface = nextSurface + MySurfaces.VBIstart;
    }
    return nextSurface;
}


U032    getPrevSurface(U032 currentSurface) {
    long    nextSurface;
    
    ASSERT(currentSurface < MAXVPSURFACES ,"current Surface to big ASSERT FAILED\n");
    
    //Generally you are going to want to jump two surfaces ahead of the one you are on, but 
    // with a wrap around depending on what typeof surface you are
    // interleaved surface should only move ahead ONE buffer since both DMA engines are pointing
    // to the same surface
    if( currentSurface < MySurfaces.VBIstart ) {
        // we are an ImageSurface
        if(MySurfaces.CurrentScanMode == INTERLEAVBUF ) {
            nextSurface = currentSurface - 1;
        } else {    
            nextSurface = currentSurface - 2;
        }
        while(nextSurface < 0) 
            nextSurface = nextSurface + MySurfaces.VBIstart;    
    } else {
        long    numVBI;
        //we are a VBI surface - never interleaved.. always subtract 2
        nextSurface = currentSurface - 2 - MySurfaces.VBIstart;
        numVBI = MySurfaces.numberOfSurfaces - MySurfaces.VBIstart;
        while(nextSurface < 0) 
            nextSurface = nextSurface + numVBI;
        nextSurface = nextSurface + MySurfaces.VBIstart;
    }
    return nextSurface;
}


U032    getPrevOverlaySurface(U032 currentSurface) {
    long    nextSurface;
    
    ASSERT(currentSurface < MAXVPSURFACES ,"ASSERT FAILED\n");
    
    //Generally you are going to want to jump two surfaces ahead of the one you are on, but 
    // with a wrap around depending on what typeof surface you are
    // interleaved surface should only move ahead ONE buffer since both DMA engines are pointing
    // to the same surface
    if( currentSurface < MySurfaces.VBIstart ) {
        // we are an ImageSurface
        nextSurface = currentSurface - 1;
        while(nextSurface < 0) 
            nextSurface = nextSurface + MySurfaces.VBIstart;    
    } else {
        ASSERT(1==0,"we should never try to flip the overlay on a VBI surface you numskull\n");
        DPF("we should never try to flip the overlay on a VBI surface you numskull\n");
    }
    return nextSurface;
}



BOOLEAN checkScalingOk(U032 in, U032 out ) {
    U032 xIn,yIn,xOut,yOut;
    U032    xRatio;
    /*  Scaling works like this... the output MUST be smaller than the input, and the X ratio must be an integer value
         there is no limit on the Y ratio since it's just a line dropping system
    */
    
    xIn  = in & 0xFFFF;
    yIn  = in >> 16;
    xOut = out & 0xFFFF;
    yOut = out >> 16;
    
    if( xOut <= 0 ) {
        return FALSE;
    }
    
    if( xIn < xOut ) {
        //DPF ("   In dimension X is SMALLER than out X dimension %d, %d",xIn,xOut);
        return FALSE;
    }
    if( yIn < yOut ) {
        //DPF ("   In dimension Y is SMALLER than out Y dimension %d, %d",xIn,xOut);
        return FALSE;
    }
    if( xIn % xOut != 0 ) {
        //DPF ("   X dimension In does not evenly divide by X out %d, %d",xIn,xOut);
        return FALSE;
    }    
    xRatio = xIn / xOut;
    
    switch (xRatio) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 6:
            case 8:
            case 12:
            case 16:
            case 24:
                break;
            default:
                {
                    //DPF ("   Not one of the good scale factors %d, %d, %d",xIn,xOut,xRatio);
                    return FALSE;
                }            
                break;
    }
    
    
    return TRUE;
}



U032    ProgramBufferWithSurface(U032    dwBufferIndex,U032    newSurfaceIndex, U032 bZeroLength) {
    // This function is responsible for programming up and then launching buffer/surface combination
    // This will finish Asyncronously, and either be relaunched in the case of auto-flip, or be able 
    // to report back usefully with the VPE functions
    U032    nextField;
    U032  nextVBIField;
    U032    dwInterleaveAddition;
    vpSurfaceInfo*        pSurface;
    NvChannel*    pMyNvChan = MySurfaces.pVPChanPtr;
    
    pSurface = MySurfaces.Surfaces[newSurfaceIndex];
    
        
    MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);
    
    ASSERT(dwBufferIndex < 4 ,"ASSERT FAILED\n");
    ASSERT(newSurfaceIndex < MAXVPSURFACES ,"ASSERT FAILED\n");
    //Update the surface structures
        // notify
    
    MySurfaces.Surfaces[newSurfaceIndex]->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)]);
    MySurfaces.CurrentBufferSurface[dwBufferIndex] = newSurfaceIndex;    
    
    // Figure out the whole field thing
    if( dwBufferIndex < 2 ) {
        // this is image
        nextField = getNextFieldType(MySurfaces.lastField, dwBufferIndex);
        MySurfaces.Surfaces[newSurfaceIndex]->field = nextField;
        MySurfaces.lastField = nextField;

        // if we're interleaving AND we're on the EVEN field then move everything down a bit
        //   OOD field is on top
        if(( MySurfaces.CurrentScanMode == INTERLEAVBUF) && (nextField == EVEN ) ) {
            dwInterleaveAddition = MySurfaces.Surfaces[newSurfaceIndex]->dwPitch/2;
        } else {
            dwInterleaveAddition = 0;
        }

        MySurfaces.curImageSurf = newSurfaceIndex;
    } else {
        // this is VBI
        nextVBIField = getNextFieldType(MySurfaces.lastField,dwBufferIndex-2);
        MySurfaces.Surfaces[newSurfaceIndex]->field = nextVBIField;
        MySurfaces.lastVBIField = nextVBIField;
        MySurfaces.curVBISurf = newSurfaceIndex;
    }
    
    MySurfaces.curSurf = newSurfaceIndex;
    
    // choose which type of surface this is

        // Put decoder object into the channel
        

    ASSERT(2*4 < NV06A_FIFO_GUARANTEED_SIZE ,"ASSERT FAILED\n");            
               
    while (MySurfaces.myFreeCount < 2*4) {
        NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);
    }            
    MySurfaces.myFreeCount -= 2*4;                                        

        

    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;

        // these lines end up being the Y-Crop value.
        // therefore they're the deviding line between VBI and Image
    
        // check if VBI is running
    if(MySurfaces.VBIstart < MySurfaces.numberOfSurfaces ) {
        if( dwBufferIndex >= 2 ) {
        // VBI is running
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = 
                (MySurfaces.Surfaces[newSurfaceIndex]->dwHeight) +
                (MySurfaces.Surfaces[newSurfaceIndex]->dwStartLine) + 2;
        }
    } else {
        if( dwBufferIndex < 2) {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = 
                MySurfaces.Surfaces[newSurfaceIndex]->dwStartLine;
        }
    }

    if( dwBufferIndex <2 ) {
        

        // Image surface
         // setup the field polarity, offset and fire it off

        // if prescale is not on 2:1 integer boundaries from output, then fail...
        {
            BOOL bScale = checkScalingOk((MySurfaces.Surfaces[newSurfaceIndex]->dwWidth) | 
                                                    (MySurfaces.Surfaces[newSurfaceIndex]->dwHeight << 16)
                            ,MySurfaces.Surfaces[newSurfaceIndex]->dwPreScaleSize);
            
            if(! bScale ) {
                DPF("   Invalid Scaling parameters in use...\n");
    
                return (-7);        
            }
        }
        

        ASSERT(5*4 < NV06A_FIFO_GUARANTEED_SIZE ,"ASSERT FAILED\n");            

        while (MySurfaces.myFreeCount < 5*4) {
            NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
            MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);
        }            
        MySurfaces.myFreeCount -= 5*4;                                        
        if( bZeroLength) {
          MarkTiming(PROGRAMIMG,MySurfaces.Surfaces[newSurfaceIndex]->pVidMem, makeInd2(0,INCNOTAP,dwBufferIndex,newSurfaceIndex,( ( nextField == ODD ) ? 0 : 1)));
        } else {
          MarkTiming(PROGRAMIMG,MySurfaces.Surfaces[newSurfaceIndex]->pVidMem, makeInd2(0 | 0x80,INCNOTAP,dwBufferIndex,newSurfaceIndex,( ( nextField == ODD ) ? 0 : 1)));
        }

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeIn =
            (MySurfaces.dwInWidth) | (MySurfaces.dwInHeight << 16);
        if( bZeroLength ) {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 0;
        } else {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 
                MySurfaces.Surfaces[newSurfaceIndex]->dwPreScaleSize;        
        }
        
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].offset    =
                MySurfaces.Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition;
        // There is some sly behavior in the field statement...
        // since progressive fields are expected to be delivered in the EVEN fields we only check for ODD
        // and then everything else is considered to be even
        nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].format =        
                ( MySurfaces.Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
                ((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
                ((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;
           

        
        
                
    } else {
        //MYCHECKFREECOUNT(pMyNvChan,4*4);
        

        ASSERT(4*4 < NV06A_FIFO_GUARANTEED_SIZE,"ASSERT FAILED\n" );            

        while (MySurfaces.myFreeCount < 4*4) {
            NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
            MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);
        }            
        MySurfaces.myFreeCount -= 4*4;                                        
        MarkTiming(PROGRAMVBI,MySurfaces.Surfaces[newSurfaceIndex]->pVidMem, makeInd(dwBufferIndex,newSurfaceIndex,INCNOTAP,INCNOTAP));

        // these lines end up being the Y-Crop value.
        // therefore they're the deviding line between VBI and Image
        
        

        // VBI surface    
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].size    =
            ((MySurfaces.Surfaces[newSurfaceIndex]->dwHeight+1) << 16) | (MySurfaces.Surfaces[newSurfaceIndex]->dwStartLine) ;
        
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].offset    =
            MySurfaces.Surfaces[newSurfaceIndex]->dwOffset;
        
        nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].format =        
            ( MySurfaces.Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
            ((( ( nextVBIField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
            ((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;

    }
    //Update the Capture Class
    // hopefully make sure stuff REALLY get to the registers
    NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
    
    return 0;
}

    
void CheckAndDoCallbacks(U032        interruptingBuffer, U032 oldsurface){
    U032 newSurface = getNextSurface(oldsurface,FALSE);
    
    if(interruptingBuffer < 2) {
        if(MySurfaces.ImageCallbackRoutine != NULL ) {
            if( MySurfaces.Surfaces[oldsurface]->field == EVEN )
                MySurfaces.myIMGCallbackInfo.dwFlags = USINGFLAGS | IMAGESURFACE | BUFFADRLIN | EVENFIELD;
            else
                MySurfaces.myIMGCallbackInfo.dwFlags = USINGFLAGS | IMAGESURFACE | BUFFADRLIN | ODDFIELD;

            MySurfaces.myIMGCallbackInfo.lastBufferAddr = MySurfaces.Surfaces[oldsurface]->pVidMem;    // address of just finished buffer ( the one the client should unload )
            MySurfaces.myIMGCallbackInfo.curBufferAddr = MySurfaces.Surfaces[newSurface]->pVidMem;    // address of current input buffer ( one that is now being written to by MP )
            MySurfaces.myIMGCallbackInfo.intCount++;
        
            MySurfaces.ImageCallbackRoutine(&MySurfaces.myIMGCallbackInfo);
        }
    } else {
        if(MySurfaces.VBICallbackRoutine != NULL ) {
            if( MySurfaces.Surfaces[oldsurface]->field == EVEN )
                MySurfaces.myVBICallbackInfo.dwFlags = USINGFLAGS | VBISURFACE | BUFFADRLIN | EVENFIELD;
            else
                MySurfaces.myVBICallbackInfo.dwFlags = USINGFLAGS | VBISURFACE | BUFFADRLIN | ODDFIELD;
            
            MySurfaces.myVBICallbackInfo.lastBufferAddr = MySurfaces.Surfaces[oldsurface]->pVidMem;;    // address of just finished buffer ( the one the client should unload )
            MySurfaces.myVBICallbackInfo.curBufferAddr = MySurfaces.Surfaces[newSurface]->pVidMem;    // address of current input buffer ( one that is now being written to by MP )
            MySurfaces.myVBICallbackInfo.intCount++;
            MySurfaces.VBICallbackRoutine(&MySurfaces.myVBICallbackInfo);
        }
    }
}



U032 startSurfaces(U032    bInterleave, VPSTATE*    pVideoPortStatus ) {
    U032    rValue = DD_OK;
    VPSTATE    myState = *pVideoPortStatus;
    // figure out which buffers to program up and launch them...

    // zero out the last overlay scaler size so we're sure it gets reprogrammed
    MySurfaces.bThreadRunning = TRUE;
            
    MySurfaces.DropSystem.dwTargetSurface = 0;
    MySurfaces.DropSystem.dwbIsBobFromInterleave = 0;
    MySurfaces.DropSystem.dwFieldType = 0;
    MySurfaces.DropSystem.dwFullBool = 0;
    MySurfaces.DropSystem.dwDropFields = 0;

    if(MySurfaces.bInvertedFields ) {    
        MySurfaces.lastVBIField = ODD;
        MySurfaces.lastField = ODD;    // this should be even so we'll always start on odd ( hopefully... :-)
    } else { 
        MySurfaces.lastField = EVEN;
        MySurfaces.lastVBIField = EVEN;
    }
    MySurfaces.lastsrcDeltaY = 0;
    MySurfaces.bStopVP = FALSE;    

    // start first vbi
    if( (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart) > 0 ) {
        if( ProgramBufferWithSurface(2,MySurfaces.VBIstart,FALSE))
                rValue = DDERR_INVALIDPARAMS;
        myState |= VP_VBI_CAPTURING;
    }
    
    //start first image
    if( (MySurfaces.VBIstart > 0 ) ) {
        // there is at last one image surface
        if( ProgramBufferWithSurface(0,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
            myState |= VP_IMAGE_CAPTURING;
    }
    // start second VBI
    if( (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart) > 0 ) {
    
        // now check to see if we have another surface
        if( (MySurfaces.numberOfSurfaces - MySurfaces.VBIstart) > 1 ) {
            if( ProgramBufferWithSurface(3,MySurfaces.VBIstart+1,FALSE))
                    rValue = DDERR_INVALIDPARAMS;
        } else {
            // set second buffer to first surface
            if( ProgramBufferWithSurface(3,MySurfaces.VBIstart+0,FALSE))
                    rValue = DDERR_INVALIDPARAMS;
        }
    }    
    // start second image
    if( (MySurfaces.VBIstart > 0 ) ) {
        
        if( bInterleave) {
            // since this is interleave always start the second buffer with the first surface
            if( ProgramBufferWithSurface(1,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
            myState |= VP_IMAGE_CAPTURING;
        } else {    
            if( MySurfaces.CurrentCaptureMode == EVENODD ) {
              // if we're odd/even and not interleaved then we're seperate bob, which is where the
              // potential problem occurs
              MySurfaces.bFirstTime = TRUE;
            }
            // check for another surface
            if( MySurfaces.VBIstart > 1 ) {
                if( ProgramBufferWithSurface(1,1,FALSE) )
                    rValue = DDERR_INVALIDPARAMS;
            } else {
                // fire up the second buffer at the first surface
                DPF("this is kinda odd, only one surface, but also non-interleaved...");
                if( ProgramBufferWithSurface(1,0,FALSE) )
                    rValue = DDERR_INVALIDPARAMS;
            }
        }
    }
                    
    *pVideoPortStatus = myState;
    
    return rValue;
}



#define NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET               (0x0001)


BOOL GetField(void) {
    BOOL    retvalue = TRUE;
    U032    whiletime = 0;
    FIELDTYPE aField = UNKNOWN;
    NvChannel*    pMyNvChan = MySurfaces.pVPChanPtr;
        
    // we're not hitting the channel
    //INIT_FREE_COUNT(0);

    

    ASSERT(3*4 < NV06A_FIFO_GUARANTEED_SIZE,"ASSERT FAILED\n" );            

    while (MySurfaces.myFreeCount < 3*4)    {    
        NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);    
    }        
    MySurfaces.myFreeCount -= 3*4;                                        

    // clear the notifiers
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // put the object into the channel
    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;

    // fire off the command
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    
    // wait for completion

    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))    &&
                (whiletime++ < WHILETIMEOUT) )
                NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        ;
    
    // only one of these should be running right now....
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
        aField = MySurfaces.Surfaces[MySurfaces.CurrentBufferSurface[0]]->field;
    }
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
        aField = MySurfaces.Surfaces[MySurfaces.CurrentBufferSurface[1]]->field;
    }
    if(aField == EVEN ) {
        retvalue = TRUE;
    } else {
        retvalue = FALSE;
    }
    
    return retvalue;
}


BOOL GetCurrentBuffers(void) {
    BOOL    retvalue = TRUE;
    U032    whiletime = 0;
    FIELDTYPE aField = UNKNOWN;
    NvChannel*    pMyNvChan = MySurfaces.pVPChanPtr;
        
    // we're not hitting the channel
    //INIT_FREE_COUNT(0);

    
    ASSERT(5*4 < NV06A_FIFO_GUARANTEED_SIZE ,"ASSERT FAILED\n");            
    while (MySurfaces.myFreeCount < 5*4)    {    
        NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        MySurfaces.myFreeCount = NvGetFreeCount(pMyNvChan, 0);    
    }        
    MySurfaces.myFreeCount -= 5*4;                                        

    // clear the notifiers
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
//    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
//    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // put the object into the channel
    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;

    // fire off the command

    // NOTE we only need half of these since they return the same data as it stands now

    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
//    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetVbiOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
//    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetVbiOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    
    // wait for completion

    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) &&
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))    &&
                (whiletime++ < WHILETIMEOUT) )
                NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);                            
        ;
    
    // only one of these should be running right now....
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
        aField = MySurfaces.Surfaces[MySurfaces.CurrentBufferSurface[0]]->field;
    }
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
        aField = MySurfaces.Surfaces[MySurfaces.CurrentBufferSurface[1]]->field;
    }
    if(aField == EVEN ) {
        retvalue = TRUE;
    } else {
        retvalue = FALSE;
    }
    
    return retvalue;
}


U032 vddhandleBufferInterrupts(U032 whichBuffer, U032 dummy2, U032 dummy3) {


    U032    i;
    U032    foundSomething;
    U032    reprogram;
    U032 interruptingBuffer = STARTINGBUF;
    U032 oldSurface;
    U032 newSurface;
    
    MySurfaces.myFreeCount = 0;

    // 15 long words is a bit arbitrary, but is based on the number of long words pushed in 
    // a normal update ie a VP reprogram and an overlay flip
    if (MySurfaces.myFreeCount < 15*4)                                
        MySurfaces.myFreeCount = NvGetFreeCount(MySurfaces.pVPChanPtr, 0);            
    
    {
        U032 aCount=0;
        while( MySurfaces.myFreeCount < 15*4 ) {
            DPF("No room on fifo.. try NVR0interrupt\n");
            NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);    
            MySurfaces.myFreeCount = NvGetFreeCount(MySurfaces.pVPChanPtr, 0);            
            aCount++;
            if(aCount > 5){
                DPF("STILL No room on fifo.. bail outta here... there's probably something wrong\n");
                return 0;
            }
        
        }
    }
    // I'm really NOT sure what sort of information I'm going to be getting at this point...
    // I need to determine which of the four possible buffers just finished...
    do  {
        U032    time0old = 0xFFFFFFFF;
        U032    time1old = 0xFFFFFFFF;
        U032  oldestBuffer = NOSURFACEPROGRAMED;
        
        reprogram = FALSE;
        foundSomething = FALSE;
        // check for GOOD completions and deal with these first

        // search for the oldest finished buffer
        for(i=0;i<4;i++) {
            
            if(( nvMyVPNotifiers[notifyIndexFromBuffer(i)].status != NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) && 
                ( nvMyVPNotifiers[notifyIndexFromBuffer(i)].status != NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED )  ) 
            {
                // ok we've found one of the notifiers which has finished
                // now check the completion times to find the "oldest" one to preserve order
                U032 time1 = nvMyVPNotifiers[notifyIndexFromBuffer(i)].timeStamp.nanoseconds[1];
                U032 time0 = nvMyVPNotifiers[notifyIndexFromBuffer(i)].timeStamp.nanoseconds[0];
                
                // if the new time is not greater than the old time
                if( time1 <= time1old ) {
                    if( (( time1 == time1old ) && (time0 < time0old)) || ( time1 < time1old)) {
                        // we have a new winner
                        time0old = time0;
                        time1old = time1;
                        oldestBuffer = i;
                    }
                }
            }
        }
        
        
        if( oldestBuffer != whichBuffer ) {
            //DPF("Buffer callbacks are out of order\n");
        };
// This is an experiment.  check the free count.  if we have room, then process this request.  otherwise return
// now and deal with this notifier next time we get to this routine...
// this is put in to prevent a dead-lock between programmbufferswithsurface which is spinning waiting for room
// and the software method which is supposed to be MAKING room.                    
        if( oldestBuffer != NOSURFACEPROGRAMED ) {
            if (MySurfaces.myFreeCount < 15*4)                                
                MySurfaces.myFreeCount = NvGetFreeCount(MySurfaces.pVPChanPtr, 0);            
            {
                U032 aCount=0;
                while( MySurfaces.myFreeCount < 15*4 ) {
                    DPF("No room on fifo.. try NVR0interrupt\n");
                    NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);    
                    MySurfaces.myFreeCount = NvGetFreeCount(MySurfaces.pVPChanPtr, 0);            
                    aCount++;
                    if(aCount > 5){
                        DPF("STILL No room on fifo.. bail outta here... there's probably something wrong\n");
                        return 0;
                    }
                
                }
            }
            // now verify that it was completed successfully
            if( nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)].status == NV04D_NOTIFICATION_STATUS_DONE_SUCCESS ) 
            {
                                         
                interruptingBuffer = oldestBuffer;
                oldSurface = MySurfaces.CurrentBufferSurface[interruptingBuffer];
                if( oldSurface != NOSURFACEPROGRAMED ) {

                    if(interruptingBuffer < 2)  {
                        //MarkTiming(NOTIFYIMG,MySurfaces.Surfaces[oldSurface]->pVidMem,makeInd(INCNOTAP,INCNOTAP,interruptingBuffer,oldSurface));
                        //MarkTimingNot(RMIMGPROG,&(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(oldestBuffer)]),
                        //              nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(oldestBuffer)].info32,
                        //              makeInd(INCNOTAP,INCNOTAP,interruptingBuffer,oldSurface));
                        MarkTimingNot(NOTIFYIMG,&(nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)]),MySurfaces.Surfaces[oldSurface]->pVidMem,makeInd(INCNOTAP,INCNOTAP,interruptingBuffer,oldSurface));
                        //RecordImageNotify(nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)].timeStamp.nanoseconds[0],
                        //                  nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)].timeStamp.nanoseconds[1] );
                        
                    } else {
                        //MarkTiming(NOTIFYVBI,MySurfaces.Surfaces[oldSurface]->pVidMem,makeInd(interruptingBuffer,oldSurface,INCNOTAP,INCNOTAP));
                        MarkTimingNot(NOTIFYVBI,&(nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)]),MySurfaces.Surfaces[oldSurface]->pVidMem,makeInd(interruptingBuffer,oldSurface,INCNOTAP,INCNOTAP));
                    }
                    // onward
                    if(oldSurface == NOSURFACEPROGRAMED) {
                        //DPF("... that buffer should have had a surface..buffer =%d",interruptingBuffer);
                    }
                    nvMyVPNotifiers[notifyIndexFromBuffer(interruptingBuffer)].status = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
                    foundSomething = TRUE;
                    if((oldSurface != NOSURFACEPROGRAMED ) & (!MySurfaces.bStopVP) )
                         reprogram = TRUE;
                } else {
                    DPF("spurious interrupt, with unrecognized surface");
                }
            } else {
                // completed with an error most likely
                oldSurface = MySurfaces.CurrentBufferSurface[oldestBuffer];
                reportError(interruptingBuffer,oldSurface);
                nvMyVPNotifiers[notifyIndexFromBuffer(oldestBuffer)].status = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
                if( MySurfaces.Surfaces[oldSurface] == NULL )
                        foundSomething = FALSE;
                    else 
                        foundSomething = TRUE;    
                // for now do nothing
            }
        }

        // on the NV10, the buffers don't have a fixed capture order because of a bug in the HW
        // since I WANT a particular buffer to finish first, the only way to ensure this is to see if
        // the WRONG buffer finished first and if so reprogram it with the SAME settings.
        
        if((MySurfaces.bFirstTime) && (interruptingBuffer == 1)) {
            MarkTiming(ALMEMRESTART,MySurfaces.Surfaces[oldSurface]->pVidMem, makeInd2(0,INCNOTAP,interruptingBuffer,7,0));

            if( MySurfaces.VBIstart > 1 ) {
                ProgramBufferWithSurface(1,1,FALSE);
            } else {
                // fire up the second buffer at the first surface
                DPF("this is kinda odd, only one surface, but also non-interleaved...");
                ProgramBufferWithSurface(1,0,FALSE);
            }
            MySurfaces.bFirstTime = FALSE;
            // since we're going to pretend that this _didn't_ occur, we'll just return right now!
            return 0;
        }
        
        MySurfaces.bFirstTime = FALSE;
        // no go on with life as usual.

        if( reprogram) {
            U032 overlayFlipError = 0;
            
            // check if we're an image buffer and see if we need to schedule an overlay flip
            if( interruptingBuffer < 2 ) {
                FIELDTYPE interruptingField = UNKNOWN;
                
                interruptingField = getFieldFromBuffer(interruptingBuffer);
                
                
                if( MySurfaces.CurrentScanMode == SEPERATEBUF ) {
                    // scheduele flip!
                    // overlayFlipError = scheduleOverlayFlip(oldSurface,FALSE, interruptingField);
                    
                } else {
                    // we're in interleaved mode... 
                    
                    // Check to see if we're doing "bob from interleaved"
                    if ((MySurfaces.pDriverData)->vpp.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE) {
                        //Bob from interleaved
                        // we don't want the overlay to follow the surface, instead the one just behind
                        // this surface
        //                scheduleOverlayFlip(getPrevSurface(oldSurface),TRUE, interruptingField);

                        // this is an odd situation where we should delay one field on our updates...
                        // this causes overlay flip to a surface to occur only after BOTH fields in the surface
                        // have been received.
                        if( MySurfaces.lastSurface != NOSURFACEPROGRAMED) {
                            //overlayFlipError = scheduleOverlayFlip(MySurfaces.lastSurface,TRUE, interruptingField);
                            //overlayFlipError = scheduleOverlayFlip(oldSurface,TRUE, interruptingField);
                        }
                        MySurfaces.lastSurface = oldSurface;
                        MySurfaces.lastBuffer = interruptingBuffer;

                        if ( overlayFlipError == 15 ) {
                           // this indicates that we need to go into DropFrame mode.
                           // we need to prevent the flipping of the NEXT field to complete
                           // and we need to reprogram the NEXT TWO fields to have lengths of zero
                           MySurfaces.DropSystem.dwDropFields = 2;
                           
                        }
                    } else {
                        // weave from interleaved
                        // Check to see if the other buffer is working on this surface, if it is then don't flip
                        // flip only when ODD field was the last programmed. which likey means this is an EVEN
                        // field which completed and therefore is the second field in the surface
                        if(  MySurfaces.lastField == ODD ) {
                            // overlayFlipError = scheduleOverlayFlip(oldSurface,FALSE, interruptingField);
                        } else {
                        }
                    }
                }
                
            // however smac@microsoft.com ( head VPE guru )
            // says that autoflip means we should continue capturing fields but they should end up in the SAME surface
            // so off we go to reprogram
        
                if( MySurfaces.DropSystem.dwDropFields > 0  ){
                    
                    // then call ProgramBuffer with Surface
                    // program up this buffer to send to a "null" surface
                    // reprogram the old surface, but with a zero length so nothing get written into
                    // the surface, and things can progress properly if needed
                    
                    //  I think this might be throwing out the field just following the field
                    // that we want to throw out, because I'm programming one field ahead...
                    ProgramBufferWithSurface(interruptingBuffer,oldSurface, TRUE);
                    
                    // we'll only drop two of these count them down
                    MySurfaces.DropSystem.dwDropFields--;
                    
                } else if( MySurfaces.bSkipNextField ) {
                    // then call getNextSurface
                    if( MySurfaces.Surfaces[oldSurface]->bAutoFlip ) {
                        newSurface = getNextSurface(oldSurface,FALSE);
                    } else {
                        MySurfaces.bFlipRequested = FALSE;
                        newSurface = oldSurface;
                    }
                    // then call ProgramBuffer with Surface
                    // program up this buffer to send to a "null" surface
                    // reprogram the old surface, but with a zero length so nothing get written into
                    // the surface, and things can progress properly if needed
                    
                    //  I think this might be throwing out the field just following the field
                    // that we want to throw out, because I'm programming one field ahead...
                    ProgramBufferWithSurface(interruptingBuffer,oldSurface, TRUE);
                    MySurfaces.bSkipNextField = FALSE;
                } else {
                  // this is the normal calm pathway
                  if( MySurfaces.Surfaces[oldSurface]->bAutoFlip ) {
                      newSurface = getNextSurface(oldSurface,FALSE);
                  } else {
                      MySurfaces.bFlipRequested = FALSE;
                      newSurface = oldSurface;
                  }// then call ProgramBuffer with Surface
                  ProgramBufferWithSurface(interruptingBuffer,newSurface, FALSE);
                    
                }
                 
                // Do Vid Texture now...  this will be purely field based. and only ODD field
                if(  MySurfaces.lastField == ODD ) {

                    // until this code is written
                }
                
            } else {
                // this is a VBI buffer... so just check if it's autoflip or not
                if( MySurfaces.Surfaces[oldSurface]->bAutoFlip ) {
                    newSurface = getNextSurface(oldSurface,FALSE);
                } else {
                    MySurfaces.bFlipRequested = FALSE;
                    newSurface = oldSurface;
                }
                // then call ProgramBuffer with Surface
                ProgramBufferWithSurface(interruptingBuffer,newSurface, FALSE);
            
            }
            CheckAndDoCallbacks(interruptingBuffer,oldSurface);
            
            
            // At this pointer we've checked and call the 3rd party callbacks.
            //   then we've flipped the overlay if we determined that to be important
            //   finally we've reprogrammed our hardware to go off and do whatever
            
            // now we'll call MS's callback to tell them that something has happened.
            
            // we should ONLY do this ONCE per field on the LAST of the two notifies.
            // So if it's VBI only then that's when the vbi is done
            // otherwise when IMAGE is done
            
            if( (( MySurfaces.VBIstart == 0 ) && ((whichBuffer == 2) || (whichBuffer == 3))) ||
                (( MySurfaces.VBIstart != 0 ) &&((whichBuffer == 0) || (whichBuffer == 1)))   ){
                if((void*)MySurfaces.pDXIRQCallback != NULL) {
                    if( MySurfaces.DXIRQCallbackSources & DDIRQ_VPORT0_VSYNC ) {
                        // basically since we're auto flipping, we're only going to tell them when this is done and nothing else
                            if(MySurfaces.pDXIRQCallback != 0) {
                                // here's the one line of docs that we have:
                                // When calling the IRQCallback, EAX should contain the DDIRQ_xxxx flags indicating 
                                // what caused the IRQ and EBX should contain the specified dwContext. 
                                
                                
                                U032 temp1 = MySurfaces.dwIrqContext;        //  the same context which dd gave me before
                                U032 temp2 = DDIRQ_VPORT0_VSYNC;                // at this point we only have an interrupt for ONE event
    
    // to allow chris's editor to deal with funky assembly code
#define SKIPOMPARSE
#ifdef SKIPOMPARSE        
                            
                                // push register values
                                _asm mov EAX, temp2
                                _asm mov EBX, temp1
#endif                            
                                // call the callback
                                ((ACALLBACKTYPEPROC)MySurfaces.pDXIRQCallback)();
                            };
    
                    }
                
                }
            }
        } else {
            if(interruptingBuffer == STARTINGBUF ) {
                //DPF ("   We got an interrupt but no buffer's were in state STATUS_DONE_SUCCESS \n");
            //    DPF ("           or had ERRORS.  We may be trying to terminate\n");
            }
            interruptingBuffer = UNKNOWNBUF;
            if(oldSurface == NOSURFACEPROGRAMED) {
                DPF ("   We got an event wherein the surface which we just claimed to  \n");
                DPF ("           have filled was invalid\n");
            }
        }
        
        
        
//    } while (foundSomething);
    } while (FALSE);
    
    return 0;
}



void timerNotifyProc(void) {
    // this gets called when we want to start the video on NV3
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->dwGlobalStructSize != sizeof(GLOBALDATA) ) {
        U032 size = sizeof(GLOBALDATA);
        
        DPF("Warning Warning Warning  -  Globaldata structure compiled with different length prepare to die!");
        return;
    }
    
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }

    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    startSurfaces(MySurfaces.dwVPFlags & DDVP_INTERLEAVE, &(MySurfaces.dwVideoPortStatus) );

    return;
}

void wrapperProcI0(void) {
    
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    // only do something here if we know that the "thread is running"
    if(MySurfaces.bThreadRunning)
        vddhandleBufferInterrupts(0,0,0);
    return;
}

void wrapperProcI1(void) {
    
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    // only do something here if we know that the "thread is running"
    if(MySurfaces.bThreadRunning)
        vddhandleBufferInterrupts(1,0,0);
    return;
}

void wrapperProcV0(void) {
    
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    // only do something here if we know that the "thread is running"
    if(MySurfaces.bThreadRunning)
        vddhandleBufferInterrupts(2,0,0);
    return;
}

void wrapperProcV1(void) {
    
    // check for null channel pointer
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    if( (MySurfaces.pDriverData)->NvDevVideoFlatPio == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    
    // only do something here if we know that the "thread is running"
    if(MySurfaces.bThreadRunning)
        vddhandleBufferInterrupts(3,0,0);
    return;
}

void MTMNotifyProc(void) {
    if( (MySurfaces.pDriverData)->NvDevFlatVPE == (U032)NULL ) {
        // how do we indicate error here?  uh I don't know yet
        return ; 
    }
    // Uh... is there more to do here?  Probably we should check and update the status field...
    if( UpdateStatus() ) {
        // something completed... see if we want to launch another
        CheckForLaunch();
    } else {
        // it's still running this is a superflous interrupt!
    }
}


U032 vddSetCallback(inSCBStruct*    inbuffer, outSCBStruct* outbuffer) {

    // remember in  buffer is 4 bytes
    //          out buffer is 4 bytes

    
    // ignore incoming value
    
    // setout outgoing value to the function pointer
    
    
        

    if(((U032*)inbuffer)[0] == IMAGESURFACE ) {
        // this is the IMAGE callback
        if(MySurfaces.ImageCallbackRoutine == NULL ) {
            MySurfaces.ImageCallbackRoutine = (CALLBPROC) ((U032*)inbuffer)[1];
            ((U032*)outbuffer)[0] = 0;
        } else {
            ((U032*)outbuffer)[0] = 13;
        }
    } else if(((U032*)inbuffer)[0] == VBISURFACE  ) {
        // this is the VBI callback
        if(MySurfaces.VBICallbackRoutine == NULL ) {
            MySurfaces.VBICallbackRoutine = (CALLBPROC)  ((U032*)inbuffer)[1];
            ((U032*)outbuffer)[0] = 0;
        } else {
            ((U032*)outbuffer)[0] = 13;
        }
    } else {
        // we don't recognize the surface type... let's bail with an error
            ((U032*)outbuffer)[0] = 13;
    }
    
    return 0;
}



U032 GetFlatCodeSelector()
{
    DWORD    Selector;
// to allow chris's editor to deal with funky assembly code
#define SKIPOMPARSE
#ifdef SKIPOMPARSE        
    _asm xor eax, eax
    _asm mov ax, cs
    _asm mov Selector, eax
#endif
    return (Selector);
}



U032 vddgetStoragePointer(U032 dummy1, U032 dummy2, U032 dummy3) {
//    MySurfaces.marker = 0xDEADBEEF;
//    MySurfaces.storCount = MAXDATASTORE;
    MySurfaces.lastSurfaceFlippedTo = 1000;    // for the overlay
    
    MySurfaces.pTimerNotifyProc = (U032) timerNotifyProc;
    MySurfaces.pNotifyCallbackProcI0 = (U032) wrapperProcI0;
    MySurfaces.pNotifyCallbackProcI1 = (U032) wrapperProcI1;
    MySurfaces.pNotifyCallbackProcV0 = (U032) wrapperProcV0;
    MySurfaces.pNotifyCallbackProcV1 = (U032) wrapperProcV1;
    // MySurfaces.pNotifyOverlay0NotifyProc = (U032) Overlay0NotifyProc;
    // MySurfaces.pNotifyOverlay1NotifyProc = (U032) Overlay1NotifyProc;
    MySurfaces.CallbackSelector = GetFlatCodeSelector();
    MySurfaces.pTheNotifiers = nvMyVPNotifiers;
    MySurfaces.pMTMNotifyCallback = (U032) MTMNotifyProc;
    return ((U032)&MySurfaces);
}



void    reportError(U032 interruptingBuffer,U032 oldSurface) {
    V016    status;
    V032 info32;                  
     V016 info16;

    info32 = nvMyVPNotifiers[notifyIndexFromBuffer(interruptingBuffer)].info32;
    info16 = nvMyVPNotifiers[notifyIndexFromBuffer(interruptingBuffer)].info16;

    status = nvMyVPNotifiers[notifyIndexFromBuffer(interruptingBuffer)].status;

    if( NV04D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: ERROR_PROTECTION_FAULT\n");
    }
    if( NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: ERROR_BAD_ARGUMENT\n");
    }
    if( NV04D_NOTIFICATION_STATUS_ERROR_INVALID_STATE & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: ERROR_INVALID_STATE\n");
    }
    if( NV04D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: ERROR_STATE_IN_USE\n");
    }
    if( NV04D_NOTIFICATION_STATUS_WARNING_INVALID_DATA & status ) {
        DPF ("   ERROR DETECTED BY NOTIFICATION:              Error Type: WARNING_INVALID_DATA\n");
    }

    switch (info32) {
            case MY_EXTERNAL_DECODER_OBJECT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_EXTERNAL_DECODER_OBJECT\n");    
                break;
            case MY_EXTERNAL_DECODER_NOTIFIER:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_EXTERNAL_DECODER_NOTIFIER\n");
                break;
            case MY_IMAGE0_BUFFER_CONTEXT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_IMAGE0_BUFFER_CONTEXT\n");
                break;
            case MY_IMAGE1_BUFFER_CONTEXT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_IMAGE1_BUFFER_CONTEXT\n");
                break;
            case MY_VBI0_BUFFER_CONTEXT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_VBI0_BUFFER_CONTEXT\n");
                break;
            case MY_VBI1_BUFFER_CONTEXT:
                DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: MY_VBI1_BUFFER_CONTEXT\n");
                break;
            default:        
                //DPF ("   ERROR DETECTED BY NOTIFICATION:    Error Class Instance: Unknown Class Instance: %x",info32);        
                break;
    }
    
    //DPF ("   ERROR DETECTED BY NOTIFICATION:     Error Method Number: %x",info16);
    //DPF ("   ERROR DETECTED BY NOTIFICATION:     Interrupting Buffer: %x",interruptingBuffer);
    if( oldSurface == NOSURFACEPROGRAMED) {
        //DPF ("   ERROR DETECTED BY NOTIFICATION:       Surface Attempted: SURFACE NOT PROGRAMMED\n");
    } else {
        //DPF ("   ERROR DETECTED BY NOTIFICATION:       Surface Attempted: %x",oldSurface);
    }    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\texsurf.c ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: texsurf.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           11/16/98                                          *
*                                                                           *
\***************************************************************************/

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

// to make the references to channel data cool here in ring0
#define INVDDCODE



// MS includes
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
// #include "nvPusher.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"
#include "nvos.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"
#include "nvrmarch.inc"

#include "surfaces.h"
#include "VidTex.h"

// unit specific includes
#define RESMANSIDE

#define USERING0LIBRARY
#ifndef  USERING0LIBRARY
//
//
//
#include "nvkrmapi.c"

#endif //USERING0LIBRARY

extern  vpSurfaces 			MySurfaces;		
extern  NvNotification		nvMyVPNotifiers[NUMVPNOTIFIERS];


U032 vddSetVidTexSuf(U032 pInputPtr, U032 pOutputPtr ) {
	
	VidTexSurf* daPtr = (VidTexSurf*)pInputPtr;
	if(daPtr != NULL )
		//if(daPtr->frameBufferOffsetConv <  32*1024*1024 ) 
			if(daPtr->frameBufferOffsetSwiz <  32*1024*1024 ) 
			  if((daPtr->width <= 2048) && (daPtr->width > 0));
				if((daPtr->height <= 2048) && (daPtr->height > 0));
					if(daPtr->pitch <= 2048 )
						if(daPtr->format    ) {
							daPtr->dwFrameCount = 0;
							MySurfaces.pVidTexSurf = daPtr;
							(MySurfaces.pVidTexSurf)->bUpdateSystem = TRUE;
							return 0;
						}
	return 1;
}

void fillVidTexSurface(DWORD surface ) {
	Nv04ChannelPio* pMyNvChan = (Nv04ChannelPio*)MySurfaces.pVPChanPtr; 
	if(MySurfaces.pVidTexSurf == NULL ) {
		return;
	}
	// the pointer has been created.... start filling

	while (NvGetFreeCount(MySurfaces.pVPChanPtr, 4) < (17)*4)	 {
		NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	
	};
	// Allocate the intermediate buffer context DMA
	pMyNvChan->subchannel[4].nv04ContextSurfaceSwizzled.SetContextDmaImage = MY_IMAGE0_BUFFER_CONTEXT;
	pMyNvChan->subchannel[4].nv04ContextSurfaceSwizzled.SetFormat = (MySurfaces.pVidTexSurf)->format;
	pMyNvChan->subchannel[4].nv04ContextSurfaceSwizzled.SetOffset = (MySurfaces.pVidTexSurf)->frameBufferOffsetSwiz;
	
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.SetContextDmaImage = MY_IMAGE0_BUFFER_CONTEXT;
	
	
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.SetContextDmaImage = MY_IMAGE0_BUFFER_CONTEXT;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.SetColorFormat = NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ClipPoint = 0;
	
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ClipPoint = 0;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ClipSize = 0xFFFFFFFF;		//mega big clip
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageOutPoint = 0;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageOutSize = ((MySurfaces.pVidTexSurf)->height << 16) ||
																							(MySurfaces.pVidTexSurf)->width ;;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.DeltaDuDx = ((MySurfaces.Surfaces[surface]->dwWidth ) << 20 )/((MySurfaces.pVidTexSurf)->width);
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.DeltaDvDy = ((MySurfaces.Surfaces[surface]->dwHeight ) << 20 )/((MySurfaces.pVidTexSurf)->height);
	
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageInSize = ((MySurfaces.Surfaces[surface]->dwHeight ) < 16 )  ||
																							((MySurfaces.Surfaces[surface]->dwWidth )   );
		
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageInFormat = (MySurfaces.Surfaces[surface]->dwWidth && 0x0FFFF) ||
																							( 1 << 24 );
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageInOffset = MySurfaces.Surfaces[surface]->dwOffset;
	pMyNvChan->subchannel[3].nv04ScaledImageFromMemory.ImageInPoint = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\common\transfer.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: transfer.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/17/98                                          *
*                                                                           *
\***************************************************************************/

#ifdef NV4_HW
#define NV4
#endif
#ifdef NV10_HW
#define NV4
#endif

// to make the references to channel data cool here in ring0
#define INVDDCODE

// MS includes
#include "windows.h"
#include "ddraw.h"
#include "Ddrawp.h"
#include "ddrawi.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"

//  vdd specific MS includes
#include "minivdd.h"
#include "ddkmmini.h"
#include "nvos.h"

// NV includes
#include "nvwin32.h"
#include "nvhw.h"
#include <nv_ref.h>
#include "nvrmr0api.h"

// This is here because it is defined in nvrmarch.inc. We can't include that file here.
#define NV_WIN_DEVICE                            0x00002002

// unit specific includes
#define RESMANSIDE
#include "surfaces.h"
#include "vddsurfs.h"
#include "vpvdd.h"

#include "transfer.h"
#include "timing.h"
#define USERING0LIBRARY
#ifndef  USERING0LIBRARY

#include "nvkrmapi.c"

#endif //USERING0LIBRARY

//
// prototypes
//
U032    getSurfaceIndex     (U032);

//#define  DPF(a) _Debug_Printf_Service(a)

//
// Use static storage for now.  assume no more than MAXTRANSFERS transfers queued.
//
extern  vpSurfaces 			MySurfaces;		
extern  NvNotification		nvMyVPNotifiers[NUMVPNOTIFIERS];

#ifndef DPF
#define DPF(a) NULL
#endif

U032 checkNvAllocArchError(U032 error) {
	// returns true if there IS an error
	// otherwise false
	switch (error) {
			case NVOS04_STATUS_SUCCESS:
				return 0;
//				DPF("NVOS04_STATUS_SUCCESS");
				break;
			case NVOS04_STATUS_ERROR_OPERATING_SYSTEM:
				DPF("NVOS04_STATUS_ERROR_OPERATING_SYSTEM");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_NEW:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_NEW");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_CLASS:
				DPF("NVOS04_STATUS_ERROR_BAD_CLASS");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_FLAGS:
				DPF("NVOS04_STATUS_ERROR_BAD_FLAGS");
				return error;
				break;
			case NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES:
				DPF("NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES");
				return error;
				break;
			default:
					DPF("UNKNOWN ERROR");
					return 1;
	}
	
	return 0;
}


pTransfer AddTransfer(U032 TransferID) {
	pTransfer	pMyTransfer;
	U032 i;
	// check for duplicate transfer ID
	for(i=0;i<MAXTRANSFERS;i++) {
		if(MySurfaces.MyTransfers[i].TransferID == TransferID) {
			DPF("That ID already in use!");
			return NULL;
		}
	}
	
	// check for room in queue?
	
	if(MySurfaces.dwNextEmpty == MySurfaces.dwLastEmpty ) {
		return NULL;
	}
	
	
	pMyTransfer = &(MySurfaces.MyTransfers[MySurfaces.dwNextEmpty]);
	pMyTransfer->TransferID = TransferID;
	
	MySurfaces.dwNextEmpty = MySurfaces.dwNextEmpty+1;
	if(MySurfaces.dwNextEmpty >= MAXTRANSFERS )
		MySurfaces.dwNextEmpty = 0;
		
	return pMyTransfer;
#if 0	
	for(i=0;i<MAXTRANSFERS;i++) {
		if(MySurfaces.MyTransfers[i].TransferID == TRANSFERNOTINUSE ) {
			U032 temp =i +1;
			pMyTransfer = &(MySurfaces.MyTransfers[i]);
			pMyTransfer->TransferID = TransferID;
			
			if(temp >= MAXTRANSFERS ) {
				temp = 0;
			}
			pMyTransfer->pNextTransfer = (U032*) &(MySurfaces.MyTransfers[temp]);
			return pMyTransfer;
		}
	}
#endif
	// couldn't find an empty Transfer to use
	DPF("couldn't find an empty Transfer to use");
	return NULL;	
}


U032 DeleteTransfer(pTransfer pTrans) {
	U032	temp;
	// theoretically the one we're deleting here should be the same as the "last full"
	// unless we're the first 
	// find the transfer that's one ahead of the nextEmpty zone
	temp = MySurfaces.dwLastEmpty +1;
	if(temp >= MAXTRANSFERS ) {
		temp = 0;
	}
	// make sure it's the one we want to delete;
	if(pTrans != &(MySurfaces.MyTransfers[temp]) ) {
		DPF("Major error here. the one we're trying to delete is NOT in order ");
	}
	// delete it!
	pTrans->TransferID = TRANSFERNOTINUSE;
	pTrans->SurfaceData = 0;
	pTrans->StartLine =0;
	pTrans->EndLine = 0;
	pTrans->DestMDL = NULL;
	pTrans->TransferFlags = 0;
	pTrans->pNextTransfer = NULL;
	MySurfaces.dwLastEmpty = temp;
	
	
	return 0	;
}


pTransfer GetNextTransfer() {
	pTransfer pRetValue;
	U032	temp;
	
	// find the transfer that's one ahead of the nextEmpty zone
	temp = MySurfaces.dwLastEmpty +1;
	if(temp >= MAXTRANSFERS ) {
		temp = 0;
	}
	// get a pointer to it
	pRetValue = &MySurfaces.MyTransfers[temp];
	// make sure it's QUEUED
	if(pRetValue->transferStatus != QUEUED) { 
		// if not return NULL;
		return NULL;
	}
	// else return that one!
	MySurfaces.pCurrentTransfer = pRetValue;
	return pRetValue;
	
}


void ReCreateContext(PMDL aDestMDL) {
	U032	error;
	U032	start;
	U032	limit;
	NvChannel*	pMyNvChan = MySurfaces.pVPChanPtr;
	
	// first check to see if we can reuse the OLD context... since context creation is expensive.
	start = (U032)(aDestMDL->lpMappedSystemVa);
	limit = (aDestMDL->ByteCount  ) -1;
	
	if(MySurfaces.bContextCreated) {
		if((start == MySurfaces.savedStart) && (limit == MySurfaces.savedLimit) ) {
			// no problem this is the same thing, so don't recreate
			return;
		}
	}
	ASSERT(4*4 < NV06A_FIFO_GUARANTEED_SIZE );			
	while (NvGetFreeCount(pMyNvChan, 5) < 4*4 )	{
			NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	
	}					
	
	if(MySurfaces.bContextCreated) {
		// set context on MTM to NULLOBJECT
		
#ifdef NV3_HW
		pMyNvChan->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
		pMyNvChan->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif // NV3_HW

#ifdef NV3_HW
		pMyNvChan->subchannel[5].memoryToMemoryFormat.SetBufferOutCtxDma = 0;
#else
		pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#endif
		// FREE the context first
		//   DO A SOFTWARE METHOD FLUSH HERE
		
#ifdef NV3_HW
		while (NvGetFreeCount(pMyNvChan, 5) < NV_GUARANTEED_FIFO_SIZE )	{
#else
		while (NvGetFreeCount(pMyNvChan, 5) < NV06A_FIFO_GUARANTEED_SIZE )	{
#endif
				NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	
		}

		error = NvRmR0Free((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_TO_CONTEXT);

		checkNvAllocArchError(error);

		MySurfaces.bContextCreated = FALSE;
	}
	
	// ALLOC the context
	// allocate the TO context
//	DPF("ReCreateContext: Now creating a context which starts at %x",(U032)(aDestMDL->lpStartVa));
//	DPF("ReCreateContext:                            and runs to %x",(U032)((aDestMDL->ByteCount + aDestMDL->ByteOffset ) -1));
	
	
	error = NvRmR0AllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_MTM_TO_CONTEXT,
	                     		NV01_CONTEXT_DMA,		//NV_CONTEXT_DMA_FROM_MEMORY ?
	                     		(	NVOS03_FLAGS_ACCESS_READ_WRITE |
                        				NVOS03_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)start,
	                     //		(aDestMDL->ByteCount + aDestMDL->ByteOffset ) -1
	                     		limit
	                     );

	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot re-allocate MTM TO context object ");
		MySurfaces.bContextCreated = FALSE;
	} else {
		// set context on MTM to real object

#ifdef NV3_HW
		pMyNvChan->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
		pMyNvChan->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif // NV3_HW

#ifdef NV3_HW
	pMyNvChan->subchannel[5].memoryToMemoryFormat.SetBufferOutCtxDma = MY_MTM_TO_CONTEXT;
#else
	pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = MY_MTM_TO_CONTEXT;
#endif // NV3_HW

		MySurfaces.bContextCreated = TRUE;
		
		//   DO A SOFTWARE METHOD FLUSH HERE
		NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	

	}

}

U032 UpdateStatus(void) {
	// check the notifiers and see if thing completed ok
	// then fill in the status field and be on your way
#ifdef NV3_HW
	if( nvMyVPNotifiers[NUM039OFFSET + 1].status == NV_STATUS_IN_PROGRESS ) {
#else
	if( nvMyVPNotifiers[NUM039OFFSET + NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif
		// still in progress
		return FALSE;
	} else {
#ifdef NV3_HW
		if( nvMyVPNotifiers[NUM039OFFSET + 1].status == NV_STATUS_DONE_OK ) {
#else
		if( nvMyVPNotifiers[NUM039OFFSET + NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS ) {
#endif
			// finished ok!
			if( MySurfaces.pCurrentTransfer->transferStatus == PROGRAMMED) { 
				U032 temp = ((LPDDSURFACEDATA)(MySurfaces.pCurrentTransfer->SurfaceData))->fpLockPtr;
				U032 surfIndex = getSurfaceIndex(temp);
				MySurfaces.pCurrentTransfer->transferStatus = FINISHED;
				if( surfIndex < MySurfaces.VBIstart ) 
					MarkTiming(NOTIFYTRAN,temp, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
				else
					MarkTiming(NOTIFYTRAN,temp, makeInd(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP));
			}
			// Do the callback to MS here
			if(MySurfaces.pDXIRQCallback != 0) {
				//if( MySurfaces.DXIRQCallbackSources & DDIRQ_BUSMASTER ) {
				// BUG in MS code... they should have set this flag but didn't for some reason...
				if(1) {			
					// CODE  -  this is where we'd do the callback
					
					// for now let's just get STUCK here
					// is it a void fun(void)   function?	
					
					// here's the one line of docs that we have:
					// When calling the IRQCallback, EAX should contain the DDIRQ_xxxx flags indicating 
					// what caused the IRQ and EBX should contain the specified dwContext. 
					
					
					U032 temp1 = MySurfaces.dwIrqContext;		//  the same context which dd gave me before
					U032 temp2 = DDIRQ_BUSMASTER;				// at this point we only have an interrupt for ONE event
					MySurfaces.dwMostRecentFinishTransferId = MySurfaces.pCurrentTransfer->TransferID;
				
	// to allow chris's editor to deal with funky assembly code
#define SKIPOMPARSE
#ifdef SKIPOMPARSE		
			
					// push register values
					_asm mov EAX, temp2
					_asm mov EBX, temp1
#endif							
					// call the callback  --- this will call vddGetTransferStatus......talk about TWISTED!!!!
					((ACALLBACKTYPEPROC)MySurfaces.pDXIRQCallback)();
				}
			};

			
		} else {
			// probably finished with an error!
			if( MySurfaces.pCurrentTransfer->transferStatus == PROGRAMMED) { 
				U032 temp = ((LPDDSURFACEDATA)(MySurfaces.pCurrentTransfer->SurfaceData))->fpLockPtr;
				U032 surfIndex = getSurfaceIndex(temp);
				MySurfaces.pCurrentTransfer->transferStatus = ERRORED;
				if( surfIndex < MySurfaces.VBIstart ) 
					MarkTiming(NOTIFYTRAN,temp, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
				else
					MarkTiming(NOTIFYTRAN,temp, makeInd(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP));
							
			}
			// Do the callback to MS here
			if(MySurfaces.pDXIRQCallback != 0) {
				//if( MySurfaces.DXIRQCallbackSources & DDIRQ_BUSMASTER ) {
				// BUG in MS code... they should have set this flag but didn't for some reason...
				if(1) {		
					// CODE  -  this is where we'd do the callback
					
					// for now let's just get STUCK here
					// is it a void fun(void)   function?	
					
					// here's the one line of docs that we have:
					// When calling the IRQCallback, EAX should contain the DDIRQ_xxxx flags indicating 
					// what caused the IRQ and EBX should contain the specified dwContext. 
					
					
					U032 temp1 = MySurfaces.dwIrqContext;		//  the same context which dd gave me before
					U032 temp2 = DDIRQ_BUSMASTER;				// at this point we only have an interrupt for ONE event
					MySurfaces.dwMostRecentFinishTransferId = MySurfaces.pCurrentTransfer->TransferID;
				
	// to allow chris's editor to deal with funky assembly code
#define SKIPOMPARSE
#ifdef SKIPOMPARSE		
			
					// push register values
					_asm mov EAX, temp2
					_asm mov EBX, temp1
#endif							
					// call the callback
					((ACALLBACKTYPEPROC)MySurfaces.pDXIRQCallback)();
				}
			};
		}
	
		return TRUE;
	}
	
}

U032 CancelTransfer(DDTRANSFERININFO* pTransferInInfo) {
	pTransfer pATransfer;
	
	pATransfer = FindTransfer(pTransferInInfo->dwTransferID);
	
	if( pATransfer == NULL ) {
		return 1;
	}
	
	if( pATransfer->transferStatus == QUEUED ) {
		
		DeleteTransfer(pATransfer);
		return 0;
	} 
	return 1;
	
}



void CheckForLaunch(void) {
	NvChannel*	pMyNvChan = MySurfaces.pVPChanPtr;
	pTransfer pTheTransfer;
	U032 offsetStartByte;
	U032 lineCount;
	U032 lineLength;
	long linePitch;
	LPDDSURFACEDATA pSurfaceData;
	U032 bVbiSurf = FALSE;
	
	// Determine if the MTM engine is free, and attempt to launch a transfer
	
	
	// check for free engine
#ifdef NV3_HW
	if( nvMyVPNotifiers[NUM039OFFSET + 1].status == NV_STATUS_IN_PROGRESS ) {
#else
	if( nvMyVPNotifiers[NUM039OFFSET + NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif

		// no free engine to start transfer on...
		
		return;
	} else {
		//  program up the MTM
		pTheTransfer = GetNextTransfer();
		if(pTheTransfer != NULL ) {
			U032 surfIndex;
			pSurfaceData = ((LPDDSURFACEDATA)(pTheTransfer->SurfaceData));
			
			surfIndex = getSurfaceIndex(pSurfaceData->fpLockPtr);
			if( surfIndex < MySurfaces.VBIstart ) 
				MarkTiming(TRANSFERLAUNCH,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
			else
				MarkTiming(TRANSFERLAUNCH,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP));
						
			ReCreateContext(pTheTransfer->DestMDL);
			
			if(surfIndex < MySurfaces.VBIstart ) 
				MarkTiming(TRANSFERRECRE,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
			else if(surfIndex < MySurfaces.numberOfSurfaces ) 
				MarkTiming(TRANSFERRECRE,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,INCNOTAP,INCNOTAP,surfIndex));
			else
				MarkTiming(TRANSFERRECRE,(U032)pSurfaceData->fpLockPtr, makeInd(INCNOTAP,surfIndex,INCNOTAP,INCNOTAP));
			
#ifdef NV3_HW
			nvMyVPNotifiers[NUM039OFFSET + 1].status = NV_STATUS_IN_PROGRESS;
#else
			nvMyVPNotifiers[NUM039OFFSET + NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
#endif
			
			
			MYCHECKFREECOUNT(pMyNvChan,9*4);
	
					
#ifdef NV3_HW
			pMyNvChan->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
			pMyNvChan->subchannel[5].SetObject = MY_MTM_OBJECT;
#endif // NV3_HW
			
			
			if (pSurfaceData->dwFormatFourCC == mmioFOURCC('R','A','W','8') ) {
				bVbiSurf = TRUE;
			} else if (pSurfaceData->dwFormatFourCC == mmioFOURCC('U','Y','V','Y') ) {
				bVbiSurf = FALSE;
			} else {
				bVbiSurf = FALSE;
			}
			
//			offsetStartByte = pSurfaceData->dwSurfaceOffset
//					+ pSurfaceData->lPitch * pTheTransfer->StartLine;
			// assume 1 based numbering for now...
			if(!bVbiSurf) {
				offsetStartByte =  ( pSurfaceData->fpLockPtr - (U032)((GLOBALDATA*)(MySurfaces.pDriverData))->BaseAddress)
						+ pSurfaceData->lPitch * (pTheTransfer->StartLine );
			} else {
				offsetStartByte =  ( pSurfaceData->fpLockPtr - (U032)((GLOBALDATA*)(MySurfaces.pDriverData))->BaseAddress)
						+ pSurfaceData->lPitch * (pTheTransfer->StartLine - 1);
			}

			//lineLength = pSurfaceData->dwWidth * 2;
			// apparently this width is already in bytes
			lineLength = pSurfaceData->dwWidth;
			linePitch = pSurfaceData->lPitch;
			
// WARNING THIS IS A HACK HACK HACK...			

// after developing this emprically it looks like it's an anti-interleaved factor... 
// we should probably check to make sure that the surface is interleaved before we impose it!
			
			if( (surfIndex < MySurfaces.VBIstart ) && (MySurfaces.dwVPFlags & DDVP_INTERLEAVE ) ) {
				

			
				if( lineLength < 90 ) {
					// 80X60
					linePitch = linePitch *2;
				} else if( lineLength < 170 ) {
					// 160X120
					linePitch = linePitch *2 ;
				} else if( lineLength < 330 ) {
					// 320X240
					linePitch = linePitch * 2;
				} else if( lineLength < 650 ) {
					// 640X480
					linePitch = linePitch ;
				} else {
					// this is some weird 720 things... do the same as 640 for now
					// 720X480
					linePitch = linePitch ;
				} 
			
			}			
			lineCount = ( pTheTransfer->EndLine - pTheTransfer->StartLine + 1 );	
				// SMAC@microsoft.com  :  Yes, you should transfer the end line.  
				// Therefore, if we only wanted you to
				// transfer a single line, start line would equal end line.	
			if( pTheTransfer->TransferFlags & DDTRANSFER_INVERT ) {
				// if we want to invert things, then we should 
				// negate the pitch and put the start offset at the end.
				
				offsetStartByte = offsetStartByte + linePitch * (lineCount - 1 );
				linePitch = -linePitch;
			}
			if(!bVbiSurf) {
				if((pTheTransfer->DestMDL->ByteCount  )  < (lineLength * 2 * lineCount )  ) { 
					DPF("Destination memory is not large enough to hold this image, truncating line count");
				//	lineCount = (pTheTransfer->DestMDL->ByteCount + pTheTransfer->DestMDL->ByteOffset ) / 	lineLength; 
					lineCount = (pTheTransfer->DestMDL->ByteCount ) / 	(lineLength * 2); 
				}
			} else {			
				if((pTheTransfer->DestMDL->ByteCount  )  < (lineLength * lineCount )  ) { 
					DPF("Destination memory is not large enough to hold this image, truncating line count");
				//	lineCount = (pTheTransfer->DestMDL->ByteCount + pTheTransfer->DestMDL->ByteOffset ) / 	lineLength; 
					lineCount = (pTheTransfer->DestMDL->ByteCount ) / 	(lineLength ); 
				}
			}			
			
			ASSERT(8*4 < NV06A_FIFO_GUARANTEED_SIZE );			
			while (NvGetFreeCount(pMyNvChan, 5) < 8*4 )	{
				NvRmR0Interrupt ((GLOBDATAPTR)->ROOTHANDLE, NV_WIN_DEVICE);	
			}					
			
			
#ifdef NV3_HW
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.offsetin	= offsetStartByte;
			//pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.offsetout = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.offsetout = 0;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.pitchin	= linePitch;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.pitchout	= lineLength * 2;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.linelengthin = lineLength *2;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.linecount = lineCount;
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.format	=  ( 1 | 1 << 8 );
			pMyNvChan->subchannel[5].memoryToMemoryFormat.BufferTransfer.notify	= NV_OS_WRITE_THEN_AWAKEN;
#else 


			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.OffsetIn	= offsetStartByte;
			//pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.OffsetOut = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.OffsetOut = 0;
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.PitchIn	= linePitch;	// use the pitch in so that we can do interleaved
			if(!bVbiSurf) {
				pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.PitchOut	= lineLength * 2;  // use line lenght on pitch out so that it squishes together
				pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.LineLengthIn = lineLength * 2;	// remember there are two bytes per pixel 
			} else {
				pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.PitchOut	= lineLength;  // use line lenght on pitch out so that it squishes together
				pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.LineLengthIn = lineLength;	// remember there are two bytes per pixel 
			} 
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.LineCount = lineCount;
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.Format	=  ( 1 | 1 << 8 );
			pMyNvChan->subchannel[5].nv03MemoryToMemoryFormat.BufferNotify	= NV039_NOTIFY_WRITE_THEN_AWAKEN_1;
#endif // NV3_HW
			
			pTheTransfer->transferStatus = PROGRAMMED;
		} else {
			// there are no more transfers in the queue. or something bad happened
		
		}
		return;
	}
}

pTransfer FindTransfer(U032 TransferID) {
	U032 i;
	for(i=0;i<MAXTRANSFERS;i++) {
		if(MySurfaces.MyTransfers[i].TransferID == TransferID ) {
			return &(MySurfaces.MyTransfers[i]);
		}
	}
	return NULL;
}

U032 RemoveTransfer(U032 TransferID) {
	U032 i;
	for(i=0;i<MAXTRANSFERS;i++) {
		if(MySurfaces.MyTransfers[i].TransferID == TransferID ) {
			DeleteTransfer(&MySurfaces.MyTransfers[i]);
			return 0;
		}
	}
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nv4\vddi2c.h ===
/*----------------------------------------------------------------------------*/
/*
 * vddi2c.h
 *
 */

/* 
 * common defines and typedefs so we don't have to include all the windows stuff 8
 */

#ifndef FALSE
#define	FALSE	0
#endif

#ifndef TRUE
#define	TRUE	1
#endif

typedef unsigned int	UINT;
typedef unsigned char	UCHAR;
typedef unsigned short	USHORT;
typedef unsigned long	ULONG;

typedef long		NTSTATUS;	/* from ntdef.h in Win98 DDK */
typedef void*		PDEVICE_OBJECT; /* since we don't use this object */

/* from ntstatus.h */
#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L) // ntsubauth
#define STATUS_OPEN_FAILED               ((NTSTATUS)0xC0000136L)
#define STATUS_INVALID_HANDLE            ((NTSTATUS)0xC0000008L)    // winnt
#define STATUS_ADAPTER_HARDWARE_ERROR    ((NTSTATUS)0xC00000C2L)
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)
#define STATUS_DEVICE_BUSY               ((NTSTATUS)0x80000011L)


/*----------------------------------------------------------------------------*/
/*
 * XXX	The relevant portion of i2c.h (from either the nt5 ddk or win98 ddk) is 
 *	copied here so we don't have to include i2c.h explicitly.  This is not 
 *	good but including i2c.h is difficult.
 */

// used below if neccessary
#ifndef BYTE
#define BYTE UCHAR
#endif
#ifndef DWORD
#define DWORD ULONG
#endif

//
// I2C section
//
// I2C Commands
#define I2C_COMMAND_NULL         0X0000
#define I2C_COMMAND_READ         0X0001
#define I2C_COMMAND_WRITE        0X0002
#define I2C_COMMAND_STATUS       0X0004
#define I2C_COMMAND_RESET        0X0008

// The following flags are provided on a READ or WRITE command
#define I2C_FLAGS_START          0X0001 // START + addx
#define I2C_FLAGS_STOP           0X0002 // STOP
#define I2C_FLAGS_DATACHAINING   0X0004 // STOP, START + addx 
#define I2C_FLAGS_ACK            0X0010 // ACKNOWLEDGE (normally set)

// The following status flags are returned on completion of the operation
#define I2C_STATUS_NOERROR       0X0000  
#define I2C_STATUS_BUSY          0X0001
#define I2C_STATUS_ERROR         0X0002

typedef struct _I2CControl {
        ULONG Command;          // I2C_COMMAND_*
        DWORD dwCookie;         // Context identifier returned on Open
        BYTE  Data;             // Data to write, or returned byte
        BYTE  Reserved[3];      // Filler
        ULONG Flags;            // I2C_FLAGS_*
        ULONG Status;           // I2C_STATUS_*
        ULONG ClockRate;        // Bus clockrate in Hz.
} I2CControl, *PI2CControl;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vdd\nv4\vddi2c.c ===
/*----------------------------------------------------------------------------*/
/*
 * vddi2c.c
 *
 *  I2C functionality for the miniVDD
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>

/* NV includes */
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>

#include "nvmisc.h"
#include "nvrmr0api.h"
#include "vddi2c.h"

/*----------------------------------------------------------------------------*/
/*
 * misc defines and prototypes
 */

//
// prototypes
//
U032    vddWriteVPEPrescale     (U032, U032, U032, U032, U032);

#define VDD_I2C_UNINITIALIZED   0
#define VDD_I2C_INITIALIZED     1
#define VDD_I2C_ACQUIRED        2
#define VDD_I2C_BASE_INST       0x55a50001
#define WDM_TO_VPE_COMMAND_MASK 0xdead0000

// backdoor VPE command function
ULONG nvVPECommand ( ULONG, void*);

/*
 * globals
 */

ULONG       vddI2Cstate;
ULONG       ourRoot;
ULONG       ourDevice = VDD_I2C_BASE_INST;  // for lack of better device instance

NVRM_I2C_ACCESS_CONTROL rmI2CCtrl;

static oneTimeInit = 0;

/*----------------------------------------------------------------------------*/
/*
 * vddI2COpen() - NV version of I2COpen()
 */

NTSTATUS vddI2COpen (
    DWORD           dummyReturnPtr, 
    PDEVICE_OBJECT  pDev,
    UINT        acquire,
    PI2CControl     pI2CCtrl )
{

    UINT                    rc;
    NTSTATUS                result = STATUS_SUCCESS;
    char                    devName[32];

    /*
     * check for WDM backdoor to VPE request  (This is allow WDM drivers to set
     * some VPE parameters that aren't or can't be set by WDM's overlay mixer.)
     */

    if ( (pI2CCtrl->Command & 0xffff0000) == WDM_TO_VPE_COMMAND_MASK ) {
        rc = nvVPECommand ( (pI2CCtrl->Command & 0x0000ffff), (void*) pI2CCtrl );
        pI2CCtrl->Status = rc;
        return rc;
    }


    /*
     * acquire/release I2C service
     */

    if ( acquire == TRUE ) {

        if ( vddI2Cstate == VDD_I2C_ACQUIRED ) {

            /* 
             * I2C has already been acquired, return error 
             */

            pI2CCtrl->dwCookie = 0;
            pI2CCtrl->Status = I2C_STATUS_BUSY;

            result = STATUS_OPEN_FAILED;

        }
        else {

            /* 
             * I2C is available so acquire it 
             */

            if ( oneTimeInit == 0 ) {
                /* get root and device */
                rc = NvRmR0AllocRoot(&ourRoot);
                if ( rc != NVOS01_STATUS_SUCCESS ) {
                    pI2CCtrl->dwCookie = 0;
                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_OPEN_FAILED;
                    return(result);
                }

                rc = NvRmR0AllocDevice(ourRoot, ourDevice, NV01_DEVICE_0, devName);
                if ( rc != NVOS06_STATUS_SUCCESS ) {
                    pI2CCtrl->dwCookie = 0;
                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_OPEN_FAILED;
                    NvRmR0Free(ourRoot, ourRoot, ourRoot);
                    return(result);
                }

                oneTimeInit = 1;
            }

            rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_ACQUIRE;
            rmI2CCtrl.port = NVRM_I2C_ACCESS_PORT_SECONDARY;
            rmI2CCtrl.flags = 0;

            rc = NvRmR0I2CAccess ( ourRoot, ourDevice, &rmI2CCtrl );

            if ( rc != 0 ) {

                /* unable to get I2C service */
                pI2CCtrl->dwCookie = 0;
                pI2CCtrl->Status = I2C_STATUS_ERROR;
                result = STATUS_OPEN_FAILED;

            }
            else {

                /* I2C service was obtained */
                pI2CCtrl->dwCookie = VDD_I2C_BASE_INST; /* for lack of better cookie */
                pI2CCtrl->Status = I2C_STATUS_NOERROR;
                vddI2Cstate = VDD_I2C_ACQUIRED;
                result = STATUS_SUCCESS;

            }

        }

    }
    else {

        if ( (vddI2Cstate != VDD_I2C_ACQUIRED) || (pI2CCtrl->dwCookie != VDD_I2C_BASE_INST) ) {

            /* 
             * I2C has not been previously "acquired" or cookie is wrong 
             */

            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_INVALID_HANDLE;

        }
        else {

            /* 
             * I2C was previously acquired and cookie is valid, so ok to "release" 
             */

            rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_RELEASE;
            rmI2CCtrl.port = NVRM_I2C_ACCESS_PORT_SECONDARY;
            rmI2CCtrl.flags = 0;

            rc = NvRmR0I2CAccess ( ourRoot, ourDevice, &rmI2CCtrl );

            if ( rc != 0 ) {

                /* error in releasing I2C */
                pI2CCtrl->dwCookie = 0;
                pI2CCtrl->Status = I2C_STATUS_ERROR;
                result = STATUS_OPEN_FAILED;

            }
            else {

                /* I2C released */
                pI2CCtrl->dwCookie = 0;
                pI2CCtrl->Status = I2C_STATUS_NOERROR;
                result = STATUS_SUCCESS;
                vddI2Cstate = VDD_I2C_INITIALIZED;  /* ready to be acquired again */

            }

        }

    }

    return(result);

}

/*----------------------------------------------------------------------------*/
/*
 * vddI2CAccess - NV version of I2CAccess()
 */

NTSTATUS vddI2CAccess (
    DWORD           dummyReturnPtr, 
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{

    UINT            rc;
    ULONG           startFlag;
    ULONG           stopFlag;
    ULONG           ackFlag;
    NTSTATUS        result = STATUS_SUCCESS;

    /*
     * make sure I2C has been acquired
     */

    if ( (vddI2Cstate == VDD_I2C_UNINITIALIZED) || 
         (vddI2Cstate == VDD_I2C_INITIALIZED) ||
         (pI2CCtrl->dwCookie != VDD_I2C_BASE_INST) ) {

        pI2CCtrl->Status = I2C_STATUS_ERROR;
        return(STATUS_INVALID_HANDLE);

    }

    /*
     * retrieve the flags we can deal with
     */

    startFlag = pI2CCtrl->Flags & I2C_FLAGS_START;
    stopFlag = pI2CCtrl->Flags & I2C_FLAGS_STOP;
    ackFlag = pI2CCtrl->Flags & I2C_FLAGS_ACK;

    rmI2CCtrl.flags = 0;

    if ( startFlag ) {
        rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_START;
    }

    if ( stopFlag ) {
        rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_STOP;
    }

    if ( ackFlag ) {
        rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_ACK;
    }

    /*
     * handle the command
     */

    rmI2CCtrl.port = NVRM_I2C_ACCESS_PORT_SECONDARY;

    switch ( pI2CCtrl->Command ) {

      case I2C_COMMAND_WRITE:

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_WRITE_BYTE;
        rmI2CCtrl.data = pI2CCtrl->Data;
        rc = NvRmR0I2CAccess(ourRoot, ourDevice, &rmI2CCtrl);

        if ( rc == 0 ) {
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_ADAPTER_HARDWARE_ERROR;
        }

        break;

      case I2C_COMMAND_READ:

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_READ_BYTE;
        rmI2CCtrl.data = pI2CCtrl->Data;
        rc = NvRmR0I2CAccess(ourRoot, ourDevice, &rmI2CCtrl);

        if ( rc == 0 ) {
            pI2CCtrl->Data = (U008) rmI2CCtrl.data;
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_ADAPTER_HARDWARE_ERROR;
        }

        break;

      case I2C_COMMAND_NULL:

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_NULL;
        rmI2CCtrl.data = pI2CCtrl->Data;
        rc = NvRmR0I2CAccess(ourRoot, ourDevice, &rmI2CCtrl);

        if ( rc == 0 ) {
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_ADAPTER_HARDWARE_ERROR;
        }

        break;

      case I2C_COMMAND_STATUS:

        if ( vddI2Cstate == VDD_I2C_ACQUIRED ) {
            /* nothing is going on just return success */
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            /* not applicable since we're synchronous but return something reasonable just in case */
            pI2CCtrl->Status = I2C_STATUS_BUSY;
            result = STATUS_DEVICE_BUSY;
        }

        break;

      case I2C_COMMAND_RESET:

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_NULL;
        rmI2CCtrl.data = pI2CCtrl->Data;
        rc = NvRmR0I2CAccess(ourRoot, ourDevice, &rmI2CCtrl);

        if ( rc == 0 ) {
            pI2CCtrl->Status = I2C_STATUS_NOERROR;
            result = STATUS_SUCCESS;
        }
        else {
            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_ADAPTER_HARDWARE_ERROR;
        }

        break;

      default:
    
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_INVALID_PARAMETER;

        break;

    }

    return(result);

}

/*
 * nvVPECommand() is a backdoor function to allow other Ring0 programs (like WDM)
 * to change or request various VPE functions.
 */

#define NV_VPE_CMD_SET_PRESCALE_MODE    1
#define NV_VPE_CMD_SET_CROP_MODE        2

ULONG nvVPECommand (
    ULONG cmd,
    PVOID pData )
{

    switch ( cmd ) {

    case NV_VPE_CMD_SET_PRESCALE_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to prescale
         * as oppose to cropping.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * set prescale flag and size
             */
            //Data(lower nibble)    =   0   not capturing
            //                          1   capturing
            //Data(upper nibble)    =   2   X scale
            //                          4   Y scale
            //Status    =   prescale/height * 1000
            if((pI2CCtrl->Data)& 0x40){
                vddWriteVPEPrescale(0, 
                                    ((PI2CControl)pI2CCtrl)->Status,//set Y-prescale 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    6);                             //prog. y-pre & cap. flag
            }else if((pI2CCtrl->Data)& 0x20){
                vddWriteVPEPrescale(((PI2CControl)pI2CCtrl)->Status,//set X-prescale
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    0xa);                           //prog. x-pre & cap.flag
            }else if(!((pI2CCtrl->Data)& 0x1)){
                vddWriteVPEPrescale(0,
                                    0, 
                                    0,  //capture flag=0 (not capturing)
                                    0, 
                                    0x2);   
            }
        }
        break;

    case NV_VPE_CMD_SET_CROP_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to crop
         * as oppose to prescaling.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * turn off prescale flag
             */

        }
        break;

    default:
        return 1;   
    }

    return 0;
}

void nvpeVDDInit()
{
    //Initialize VPE capture hack for WDM
    vddWriteVPEPrescale(1000,   //setting ME X-prescale factor. 1000=no scale
                        1000,   //setting ME Y-prescale factor. 1000=no scale
                        0,      //set to not vpe capture mode
                        0,      //set default VP surf type = overlay  
                        0xf);   //use all values

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\AVXDSTUB.ASM ===
;
;  (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
;
;********* Operating System Interface for NVidia Resource Manager **********;
;                                                                           ;
; Module: VXDSTUB.ASM                                                       ;
;       These routines provide an operating system independent layer        ;
;       between the Resource Manager and the underlying OS APIs.            ;
;                                                                           ;
;---------------------------------------------------------------------------;
;                                                                           ;
; History:                                                                  ;
;        David Schmenk (dschmenk)     11/17/93 - wrote it                   ;
;        David Schmenk (dschmenk)     06/15/94 - rewrote for real RM        ;
;        JohnH                        10/3/97 - rewrote for MS tools--      ;
;                                     include DDB and service table here    ;
;*********************** Copyright 1993 NVidia, Inc. ***********************;

.386p

INCLUDE BASEDEF.INC
INCLUDE VMM.INC
INCLUDE VWIN32.INC
INCLUDE VPICD.INC
INCLUDE V86MMGR.INC
INCLUDE VNVRMD.INC
INCLUDE DEBUG.INC
;include         ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc


VxD_LOCKED_DATA_SEG
PUBLIC  dwSrcLinearPageNum, dwDstLinearPageNum, dwLinearRegionSizeInPages, dwPageDirectoryBaseRegLinear
dwSrcLinearPageNum              DD      0
dwDstLinearPageNum              DD      0
dwLinearRegionSizeInPages       DD      0
dwPageDirectoryBaseRegLinear    DD      0

PUBLIC  dwPageTableEntry
dwPageTableEntry                DD      0
PUBLIC	dwGotNulPTE, dwNulPTE
dwGotNulPTE			DD	0
dwNulPTE			DD	0
VxD_LOCKED_DATA_ENDS


VxD_LOCKED_CODE_SEG

;   The Device Declartation Block

;Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
;    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

Declare_Virtual_Device  NVACORE, NVRM_Major_Version, NVRM_Minor_Version, rmControlEntry, UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER, \
                        ,                    \
                        ,					\
                        ,

;---------------------------------------------------------------------------
;
;  VxD Control entrypoints.
;
;---------------------------------------------------------------------------
EXTRN   _rmAuControl : NEAR
public  rmControlEntry
BeginProc rmControlEntry
;       ebp points to the Client_Regiser_Structure
;       rmControl expects two args: msg, VMh
        push    ebx             ; VMh
        push    eax             ; msg
        call    _rmAuControl
        add     esp,2*4
        or      eax, eax
        stc
        jnz     @F
        clc
@@:     ret
EndProc rmControlEntry

VxD_LOCKED_CODE_ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nv_diag.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NV_DIAG.C                                                         *
*         Support module for NV Diagnostic Utility.                         *
*****************************************************************************
*                                                                           *
* History:  Jim Vito (jvito) 3/2/98 - Created.                              *
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"

typedef struct _def_NvDumpStruct
{
    V032 nvdump_nvAddr;
    V032 nvdump_romAddr;
    V032 nvdump_fbAddr;
    V032 nvdump_agpAddr;
    V032 nvdump_nvPhys;
    V032 nvdump_fbPhys;
    V032 nvdump_nvIRQ;  
    V032 nvdump_hDev; 
} NV_DUMP_STRUCT;

VOID NvDumpNvData(NV_DUMP_STRUCT *buffer)
{
//////  buffer->nvdump_nvAddr = (U032) nvAddr;
//////  buffer->nvdump_romAddr = (U032) romAddr;
//////  buffer->nvdump_fbAddr = (U032) fbAddr;
//////  buffer->nvdump_agpAddr = (U032) agpAddr;
//////  buffer->nvdump_nvPhys = (U032) nvPhys;
//////  buffer->nvdump_fbPhys = (U032) fbPhys;
//////  buffer->nvdump_nvIRQ = (U032) nvIRQ;  
//////  buffer->nvdump_hDev = (U032) hDev; 
}

VOID NvGetCrtcRegisters(BYTE *buffer)
{
//////  BYTE save_index;
//////  BYTE save_lock_value;
//////  BYTE i;
//////
//////
//////  // Save this register.
//////  _asm mov  dx,0x3c4  
//////  _asm in   al,dx
//////  _asm mov  save_index,al
//////
//////  // Save the lock value.
//////  _asm mov  al,6
//////  _asm out  dx,al
//////  _asm inc  dx
//////  _asm in   al,dx
//////  _asm dec  dx  
//////  _asm mov  save_lock_value,al  
//////
//////  // Unlock the extended registers.
//////  _asm mov  ax,0x5706
//////  _asm out  dx,ax
//////
//////  _asm mov  esi, buffer
//////
//////  for(i=0;i<0x40;i++)
//////  {
//////    _asm mov  al,i
//////    _asm out  dx,al
//////    _asm inc  dx
//////    _asm in   al,dx
//////    _asm dec  dx
//////    _asm mov  [esi], al
//////    _asm inc  esi
//////  }
//////
//////  // Restore the lock value.
//////  _asm mov  al,6
//////  _asm mov  ah,save_lock_value
//////  _asm out  dx,ax
//////
//////  // Restore the CRTC Index.
//////  _asm mov  al,save_index
//////  _asm out  dx,al
//////   
}

VOID NvSetCrtcRegisters(BYTE *buffer)
{
//////  BYTE save_index;
//////  BYTE save_lock_value;
//////  BYTE i;
//////
//////
//////  // Save this register.
//////  _asm mov  dx,0x3c4  
//////  _asm in   al,dx
//////  _asm mov  save_index,al
//////
//////  // Save the lock value.
//////  _asm mov  al,6
//////  _asm out  dx,al
//////  _asm inc  dx
//////  _asm in   al,dx
//////  _asm dec  dx  
//////  _asm mov  save_lock_value,al  
//////
//////  // Unlock the extended registers.
//////  _asm mov  ax,0x5706
//////  _asm out  dx,ax
//////
//////  _asm mov  esi, buffer
//////
//////  for(i=0;i<0x40;i++)
//////  {
//////    // Don't lock these registers
//////    if(i != 6){
//////      _asm mov  al,i
//////      _asm out  dx,al
//////      _asm inc  dx
//////      _asm mov  al,[esi]
//////      _asm out  dx,al
//////      _asm dec  dx
//////      _asm inc  esi
//////    }else
//////      _asm inc  esi
//////  }
//////
//////  // Restore the lock value.
//////  _asm mov  al,6
//////  _asm mov  ah,save_lock_value
//////  _asm out  dx,ax
//////
//////  // Restore the CRTC Index.
//////  _asm mov  al,save_index
//////  _asm out  dx,al
//////   
}

//////DWORD NvIoctlRead(DWORD offset)
//////{
//////
//////  BYTE  *temp1_ptr;
//////  DWORD *temp2_ptr;
//////
//////  temp1_ptr = (BYTE *) nvAddr; 
//////  temp1_ptr += offset;   
//////  temp2_ptr = (DWORD *) temp1_ptr;  
//////  return((DWORD) *temp2_ptr);
//////
//////}

VOID NvIoctlWrite(DWORD offset, DWORD data)
{
//////  BYTE  *temp1_ptr;
//////  DWORD *temp2_ptr;
//////
//////  temp1_ptr = (BYTE *) nvAddr; 
//////  temp1_ptr += offset;   
//////  temp2_ptr = (DWORD *) temp1_ptr;  
//////  *temp2_ptr = data;
}

DWORD OnW32DeviceIoControl(PDIOCPARAMETERS p)
{

//////    switch (p->dwIoControlCode)
//////    {
//////    case 0: 
//////      return 0;
//////    case NVRM_IOCTL_CRTC_GET:   
//////      NvGetCrtcRegisters((BYTE *) p->lpvInBuffer);
//////      return 0;
//////    case NVRM_IOCTL_CRTC_SET:   
//////      NvSetCrtcRegisters((BYTE *) p->lpvInBuffer);
//////      return 0;
//////    case NVRM_IOCTL_DUMPNVDATA:
//////      NvDumpNvData((NV_DUMP_STRUCT *) p->lpvInBuffer);
//////      return 0;
//////    case NVRM_IOCTL_NV_READ:
//////      {
//////        DWORD *tptr;
//////        tptr = (DWORD *) p->cbOutBuffer; 
//////        *tptr = NvIoctlRead(p->cbInBuffer);
//////      }
//////      return 0;
//////    case NVRM_IOCTL_NV_WRITE:
//////      NvIoctlWrite(p->cbInBuffer,p->cbOutBuffer);
//////      return 0;
//////      
//////    case NVRM_IOCTL_CRTC_TEST:
//////      dacEnableCursor(NvDBPtr_Table[0]);
//////    return 0;
//////
//////    default:
//////      return -1;
//////    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nvdsptch.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NVDSPTCH.C                                                        *
*         This is the VxD Dispatcher for the NvArchitecture                 *  
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito (jvito)    03/04/98 - wrote it.                            *
*                                    - and stole from JeffW :)  			*
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"		// put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"		// more vmm services
#include "vwin32.h"
//#include "tempnvos.h"

#include "nvos.h"
#include "nvarch.h"
#include "nv32.h"
#include "nvwin32.h"
#include "nvhw.h"

// Prototypes for WinNT functions added.
// extern CLASS classTable[NUM_CLASSES];

VOID NvArchRMDispatch
(
   U032  function,
   PVOID paramPtr
)
{
  switch (function){
    case NVRM_ARCH_NV01FREE:
	{
      Nv01Free((NVOS00_PARAMETERS *) paramPtr);
	}
    break;
    
    case NVRM_ARCH_NV04ALLOC:
	{
      Nv04Alloc((NVOS21_PARAMETERS *)paramPtr);
	}
    break;
    
    case NVRM_ARCH_NV01ALLOCROOT:
	{
      Nv01AllocRoot((NVOS01_PARAMETERS *)paramPtr);
	}
    break;
    
    case NVRM_ARCH_NV01ALLOCMEMORY:
	{
      Nv01AllocMemory((NVOS02_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV01ALLOCCONTEXTDMA:
	{
	  NVOS03_PARAMETERS *parameters;

	  parameters = (NVOS03_PARAMETERS *) paramPtr;
      
      Nv01AllocContextDma(parameters);
	}
    break;

	// For each dispatch to the architecture there should be a methodic process.
    // First add the objects to the architecture object structure.
    case NVRM_ARCH_NV01ALLOCCHANNELPIO:
	{
      Nv01AllocChannelPio((NVOS04_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV01ALLOCOBJECT:
	{
	  Nv01AllocObject((NVOS05_PARAMETERS *) paramPtr);
	}
    break;

    case NVRM_ARCH_NV01ALLOCDEVICE:
	{
      Nv01AllocDevice((NVOS06_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV03ALLOCCHANNELDMA:
	{
      Nv03AllocChannelDma((NVOS07_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV03DMAFLOWCONTROL:
	{
      Nv03DmaFlowControl((NVOS08_PARAMETERS *)paramPtr);
	}
    break;


    case NVRM_ARCH_NV01INTERRUPT:
	{
      Nv01Interrupt((NVOS09_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_NV01ALLOCEVENT:
	{
	  Nv01AllocEvent((NVOS10_PARAMETERS *) paramPtr);
	}
    break;

    case NVRM_ARCH_NV03HEAP:
	{
	  Nv03ArchHeap((NVOS11_PARAMETERS *) paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_VERSION:
	{
      Nv01ConfigVersion((NVOS12_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_GET:
	{
      Nv01ConfigGet((NVOS13_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_SET:
	{
      Nv01ConfigSet((NVOS14_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_UPDATE:
	{
      Nv01ConfigUpdate((NVOS15_PARAMETERS *)paramPtr);
	}
    break;

    case NVRM_ARCH_RING0CALLBACK:
	{
      NvRing0Callback((NVRM_RING0CALLBACK_PARAMS *)paramPtr);
	}
    break;

    case NVRM_ARCH_CONFIG_GET_EX:
    {
      Nv04ConfigGetEx((NVOS_CONFIG_GET_EX_PARAMS *)paramPtr);
    }
    break;

    case NVRM_ARCH_CONFIG_SET_EX:
    {
      Nv04ConfigSetEx((NVOS_CONFIG_SET_EX_PARAMS *)paramPtr);
    }
    break;

    case NVRM_ARCH_I2C_ACCESS:
    {
      Nv04I2CAccess((NVOS_I2C_ACCESS_PARAMS *)paramPtr);
    }
    break;

    default:
    break;
  }
} // end of NvArchRMDispatch
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\OSAPI.C ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OSAPI.C                                                           *
*   This is the OS interface module.  All operating system transactions     *
*   pass through these routines.  No other operating system specific code   *
*   or data should exist in the source.                                     *
*                                                                           *
\***************************************************************************/
#ifdef DEBUG
#define CAT_HELPER(x, y)    x##y
#define CAT(x, y)       CAT_HELPER(x, y)
#define MAKE_HEADER(RetType, DecType, Function, Parameters)
#endif
#include "basedef.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include "vmmreg.h"
#include "vpicd.h"
#ifdef DEBUG
#include "configmg.h"
#endif
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <devinit.h>
#include <mc.h>
#include <os.h>
#include <edid.h>
#include <dac.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmmtypes.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"
#include "nvcm.h"
#include "nvReg.h"
#include "nvmisc.h"
#include "files.h"
#ifdef DEBUG
#include <vcomm.h>
#include "osdbg.h"
#endif
  
// number of bytes of Instance Memory to save 
#define INST_COPY   (pDev->Pram.HalInfo.TotalInstSize)

//
// prototypes
//
RM_STATUS   EDIDDetect                  (PHWINFO, U032, U032);
VOID CDECL  rmService                   (VOID);
U032 CDECL  rmSetConfig                 (U032*);
RM_STATUS   RmAllocDeviceInstance       (U032*);
RM_STATUS   EDIDRead                    (PHWINFO, U032, U032);
DWORD       OnW32DeviceIoControl        (PDIOCPARAMETERS);
int         osGetNextAvailableInstance  (VOID);

#ifdef DEBUG
U032        vmmTestDebugInstalled       (VOID);
#endif

// wrapper functions in vxdstub
VOID rmUsrAPIEntry(VOID);
VOID rmControlEntry(VOID);

// Prototype of the architecture dispatch function
VOID NvArchRMDispatch(U032 /*function*/, PVOID /*paramPtr*/);

U032   NvInfoSelectors[MAX_INSTANCE] = {0,0,0,0,0,0,0,0};
U032   NvInfoSelectorsSelector;

char strDevNodeRM[128] = NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY;
char strRegistryGlobalParameters[128] = NV4_REG_GLOBAL_BASE_PATH;
char strRmCoreName[] = STR_RM_CORE_NAME;
char strRmCoreVxd[] = NV4_RM_KERNEL_BINARY;

char strMaxRefreshRate[128]               = MAXREFRESHRATE;           
char strMaxOptimalRefreshRate[128]        = MAXOPTIMALREFRESHRATE;    
char strOptimalNotFromEDID[128]           = OPTIMALREFRESHNOTFROMEDID;
char strDMTOverride[128]                  = DMTOVERRIDE;              
char strMonitorTiming[128]                = MONITORTIMING;            
char strCursorCacheOverride[128]          = CURSORCACHE;              
char strDisplayType[128]                  = DISPLAY_TYPE;             
char strDisplay2Type[128]                 = DISPLAY2_TYPE;
char strTVtype[128]                       = TV_TYPE;                  
char strStartUp[128]                      = POWERUPFLAGS;             
char strTVOutType[128]                    = TV_OUT;                   
char strNewModeSet[128]                   = NEWSTYLEMODESET;          
char strFpMode[128]                       = FLATPANELMODE;            


typedef struct MiniVDD_ParameterStruct {
  DWORD  callrm_device_handle;       
  DWORD  callrm_modechange_callback; 
  DWORD  callrm_irq_bus;             
  DWORD  callrm_fbphys;              
  DWORD  callrm_nvphys;              
  DWORD  callrm_registry_path;       
} MiniVDD_ParameterStruct;

//---------------------------------------------------------------------------
//
//  Global variables used thoughout the OS specific module.
//
//---------------------------------------------------------------------------

int global_clientID;

//---------------------------------------------------------------------------
//
//  Global variables used by the OS specific calls.
//
//---------------------------------------------------------------------------
U032        rmInit              = 0;
U032        osPhase             = 0;
U032        *inst_sv;
BOOL        InstanceMemSaved    = FALSE;
BOOL        FirstDynamicInit    = TRUE;

//
// These globals are used by the mediaport callback mechanism; used by Canopus
//
CallBackDef mpCallback, mpImageCallback;
DWORD mpInstalledCallback = FALSE;
DWORD mpImageInstalledCallback = FALSE;
DWORD rmmpInCallback = 0;

#define MVDD_COPY_PTES_FOR_LINEAR_RANGE 0x87650002
U032        p_agp_dummy_page;

U032        ResourceManagerGlobalToken=0;
extern U032        nvInfoSelector;
extern U032        clientInfoSelector;
extern U032        rmInService;
extern U032        osInService;
extern U032        rmInSafeService;
extern U032        rmInCallback;

U032 deviceInstanceSelector;
U032 the16bitProcessDSselector;
U032 the16bitProcessDS;

U032        rmSemaphore;
U032        osSemaphore;

PCALLBACK   osCallbackTable;
PCALLBACK   osCallbackList;
PCALLBACK   osCallbackFreeList;

DISPLAYINFO osDisplayInfo;

// Global semaphore for multi-monitor implementation.
U032        mmSemaphore;
// Used by the MiniVDD to monitor mode changes
U032        mode_changed_after_save = 0;
// Signal cursor re-enable after ACPI resume
U032        resume;

#ifdef DEBUG
extern char * DotN_help;
extern void DotN_cmd_asm();
#endif
extern void RegisterDisplayDriver(PCS  x);

extern WIN9XHWINFO  win9xHwInfo[MAX_INSTANCE];

#ifdef DEBUG
extern int dbgObject_inuse;
extern DBGOBJECT DbgObject[];
extern DBGPORT DbgPort;
#endif

//---------------------------------------------------------------------------
//
//  Resource Manager VxD control function.
//
//---------------------------------------------------------------------------

RM_STATUS rmControl
(
    U032 Msg,
    U032 hVM
//    U032 flags
)
{
    RM_STATUS status;
    U032      i,event;
    CLIENT_STRUCT     crs;
    PHWINFO   pDev = NULL;  // Initialize the pDev to Null.
    PWIN9XHWINFO pOsHwInfo = NULL;

    status = RM_OK;
    //
    // WARNING: Remember that there are no devices initialized during early sections of POST (DEVICE_INIT),
    // so don't attempt to access any pDev structures or fields.  They haven't been built yet.
    //
    switch (Msg)
    {
    //
    // IOCTL Control Interface.
    //
    case W32_DEVICEIOCONTROL:
        {
            PDIOCPARAMETERS ptemp;
            _asm  mov ptemp, esi
            if (ptemp->dwIoControlCode == NVRM_IOCTL_NV_ARCH)
            {
                //
                // Architectural IOCTL.
                //
                U032                  hVM = 0;
                NV_IOCTL_ARCH_STRUCT *ptr = (NV_IOCTL_ARCH_STRUCT *)ptemp->lpvInBuffer;
              
                if (ptr->nvarchFunction <= NVRM_ARCH_MAX_IOCTL)
                    NvArchRMDispatch(ptr->nvarchFunction, (PVOID)ptr->nvarchParameters);
                    //rmArchDispatchTable[ptr->nvarchFunction](hVM, (U032)vmmGetCurrentContext(), (PVOID)ptr->nvarchParameters);
            }
            else
            {
                //
                // Diag stuff.
                //
                OnW32DeviceIoControl(ptemp);
            }
            status = RM_OK;
        }
        break;
        
    case SYS_DYNAMIC_DEVICE_INIT:    
       // We get this message when the primary or the Secondary mini VDD loads nv4rm.vxd using
       // VXDLDR_LoadDevice.
       // I have noticed that we get this message only the first time. Just in case we get called 
       // more than once, we have a global to tell us not to initialize ourselves more than once.
       if (FirstDynamicInit)
       {
#ifdef DEBUG
          DbgObject[dbgObject_inuse].pConfig(NULL);          
          DbgObject[dbgObject_inuse].pInit(&DbgPort);          
          DbgObject[dbgObject_inuse].pOpen(NULL);          
#endif            
          // This is the first dynamic init we have ever got. Initialize global data structures.
          if (!status) status = initSemaphore();
          if (!status) status = initCallbackFreeList();
          if (!status) status = initClientInfo();
          
          if (!status)
          {
              rmInCallback = 0;
              rmInService  = 0;
              osInService  = 0;
              rmInit = DEVICE_INIT; // show we've init'd, thus can be uninit'd
              FirstDynamicInit = FALSE;
          }
       }
       break;
       
    //
    // We now init as a Plug and Play device, but for the time being we'll terminate on these system messages
    // We may want to move the termination code into the Plug and Play handler later.
    case INIT_COMPLETE:
#ifdef DEBUG
        dbgEnableDevice2(&DbgPort);
#endif
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Init_Complete\n\r");
        osPhase = INIT_COMPLETE;
        break;
    case SYS_VM_INIT:
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Sys_VM_Init\n\r");
        osPhase = SYS_VM_INIT;

        // VBE SetMode
        // We'll do a mode set here because the VDD wants to see one, possibly so it will have a chance to save CRTC
        // registers. If we don't do this, the VDD may set a mode 3 later, at a bad time (when a high res display is
        // running) in response to some VGA-type activity (this happens when Winbench 97 starts and tries to find out
        // what type of display is being used).
        crs.CWRS.Client_AX = 0x4F02;
        crs.CWRS.Client_BX = 0x4003;
        VBE(&crs);
    
#ifdef DEBUG
        if(vmmTestDebugInstalled())
        {
          
          // Hook the .dot commands for the winice debugger.
          _asm {
            mov   ax,0070h
            mov   bl,'T'            
            mov   esi, offset DotN_cmd_asm
            mov   edi, offset DotN_help
            int   41h
          }
          DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Soft-Ice/w Extension Installed\n\r");
        }
#endif  
     
        break;
    case POWER_EVENT:   // Win 3.1 style power event (display driver will not handle)
        _asm mov event,esi

        {
            int max_device,DeviceInstance;
            U032 Head = 0;  // TO DO: for all heads
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Control: PowerEvent=", event);

            max_device = osGetNextAvailableInstance();
            for(DeviceInstance=0;DeviceInstance<max_device;DeviceInstance++){
                // Make sure the memory window for the device is enabled.
                pDev = NvDBPtr_Table[DeviceInstance];

                // Ignore old-style event if PM supported.
                if(pDev->Power.Flags & DAC_PM_SUPPORTED)
                    break;
            
                     pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
                osEnsureDeviceEnabled(pDev);
                REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
                REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
                ////OEMEnableExtensions();
                switch (event)
                {
                    case 1:     // suspend
                        if (pDev->Power.State == MC_POWER_LEVEL_0)
                        {
                            // turn off the monitor
                                       if(pDev->Power.Flags & DAC_POWER_PENDING)
                                       {
                                             //Reset global power_pending flag
                                             pDev->Power.Flags &= ~DAC_POWER_PENDING;

                                             // Bug 29711: if you hibernate on CRT, unplug CRT, boot back up
                                             // on LCD, the LCD blooms. When we get to this function, we do
                                             // a modeset on the CRT because the pVidLutCurDacs are setup for
                                             // head A = CRT and head B = Nothing.  If we reset the chip in 
                                             // mcPowerState, we turn off the flat panel clocks.  When we call 
                                             // Wake Up in this function, the LCD turns on, but the clocks
                                             // do not. This causes blooming.  
                                             // So to fix this, if we've reset the chip, and we've boot to  
                                             // an LCD, don't power on the panel!  The Reset flag is turned
                                             // off at the end of dacSetFlatPanelMode in dacfp.c.
                                             if(pDev->Dac.DevicesEnabled & DAC_PANEL_CLK_RESET)
                                             {
                                                     if(pDev->Dac.BootDevicesBitMap & DAC_DD_MASK_IN_MAP)
                                                     {
                                                             DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Set Monitor Power called after chip reset without panel clocks setup!\n");
                                                             break;
                                                     }
                                             }

                                             for(Head = 0; Head < MAX_CRTCS; Head++)
                                             {
                                                     if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_NONE))
                                                     {
                                                             // Enable display
                                                             dacEnableDac(pDev, Head);

                                                             // also make sure the cursor image is updated
                                                             pDev->Dac.CrtcInfo[Head].UpdateFlags &= (~UPDATE_HWINFO_DAC_CURSOR_ENABLE);
                                                             pDev->Dac.CrtcInfo[Head].UpdateFlags |= (UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW |
                                                                                                                                       UPDATE_HWINFO_DAC_CURSOR_DISABLE);
                                                     }
                                             }

                                             //Toshiba specefic call (DPMS, hotkeys)
                                             //Backlight enabled inside dacEnableDac for other mobiles
                                             if (pDev->Power.MobileOperation == 2)
                                             { 
                                                     U032    EAX, EBX, ECX, EDX;
                                                     EAX = 0x4F10;
                                                     EBX = 0x0001; //wake up
                                                     EDX = 0x0000;
                                                     ECX = 0x0000;
                                                     status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
                                             }
                                       }
                            // enter power level
                            mcPowerState(pDev, MC_POWER_LEVEL_4, 0);
                        }                
                        break;
                    // suspend-resume or critical-resume
                    case 2:
                    case 3:
                        if (pDev->Power.State == MC_POWER_LEVEL_4)
                        {
                            // leave power level
                            mcPowerState(pDev, MC_POWER_LEVEL_0, 0);
                            //
                            //  Windows 98 will only trigger a modeset if you are at the
                            //  desktop .. so if you're at the login screen we're SOL
                            //  going to force a modeset.
                            //
                            if (pDev->Power.MobileOperation) 
                            {
                                pDev->Vga.Enabled = TRUE;   // We actually are already in HiRes
                                rmEnableHiRes(pDev, TRUE);                          
                            }
                            // turn monitor back on

                           // Bug 29711: if you hibernate on CRT, unplug CRT, boot back up
                                       // on LCD, the LCD blooms. When we get to this function, we do
                                       // a modeset on the CRT because the pVidLutCurDacs are setup for
                                       // head A = CRT and head B = Nothing.  If we reset the chip in 
                                       // mcPowerState, we turn off the flat panel clocks.  When we call 
                                       // Wake Up in this function, the LCD turns on, but the clocks
                                       // do not. This causes blooming.  
                                       // So to fix this, if we've reset the chip, and we've boot to  
                                       // an LCD, don't power on the panel!  The Reset flag is turned
                                       // off at the end of dacSetFlatPanelMode in dacfp.c.
                                       if(pDev->Dac.DevicesEnabled & DAC_PANEL_CLK_RESET)
                                       {
                                             if(pDev->Dac.BootDevicesBitMap & DAC_DD_MASK_IN_MAP)
                                             {
                                                     DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Set Monitor Power called after chip reset without panel clocks setup!\n");
                                                     break;
                                             }
                                       }

                                       for(Head = 0; Head < MAX_CRTCS; Head++)
                                       {
                                             if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_NONE))
                                             {
                                                   // Enable display
                                                   dacEnableDac(pDev, Head);

                                                   // also make sure the cursor image is updated
                                                   pDev->Dac.CrtcInfo[Head].UpdateFlags &= (~UPDATE_HWINFO_DAC_CURSOR_ENABLE);
                                                   pDev->Dac.CrtcInfo[Head].UpdateFlags |= (UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW |
                                                                                                                               UPDATE_HWINFO_DAC_CURSOR_DISABLE);
                                             }
                                       }

                                       //Toshiba specefic call (DPMS, hotkeys)
                                       //Backlight enabled inside dacEnableDac for other mobiles
                                       if (pDev->Power.MobileOperation == 2)
                                       { 
                                             U032    EAX, EBX, ECX, EDX;
                                             EAX = 0x4F10;
                                             EBX = 0x0001; //wake up
                                             EDX = 0x0000;
                                             ECX = 0x0000;
                                             status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
                                       }
                        }
                        break;
                }
                REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
                REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
                ////OEMDisableExtensions();
            }
        }
        // return status = RM_OK, this will ensure carry clear (must do)
        break;
     case CRIT_REBOOT_NOTIFY2:
        // Disable interrupts
        pDev = NvDBPtr_Table[0];
        pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
        REG_WR32(NV_PMC_INTR_EN_0, 0);
        //
        // There is a bug in the current mobile BIOS where it does not explicitly program
        // the FP clock routing register.  It relies on the fact that it resets to 0, which
        // means the FP should be using HeadA.  Since the OS uses HeadB, a restart of the
        // system (warm) results in a bloom screen.  Until the BIOS fixes this, force
        // it back to HeadA as we leave the OS.
        //
        // REMOVE REMOVE REMOVE 
        //
        if (pDev->Power.MobileOperation)
        {
            // Check the BIOS rev
            if ((pDev->Chip.BiosRevision & 0xFF00FFFF) < 0x03000020)
            {
                // Not a multi-head BIOS
                dacDisableDac(pDev, 1);             // clear HeadB's device in case the BIOS doesn't
                REG_WR32(NV_PRAMDAC_SEL_CLK, 0);    // force the DFP back to HeadA
            }
        }
        else
           // turn on scaling mode for Windows reboot screen--BIOS won't reprogram FP regs
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, 0); // desktop BIOS uses head A

        break;
     case KERNEL32_SHUTDOWN:
     case SYS_VM_TERMINATE:
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Sys_VM_Terminate\n\r");
        if (osPhase == SYS_VM_TERMINATE)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Sys_VM_Terminate again!\n\r");
            //DBG_BREAKPOINT();
        }
        osPhase = SYS_VM_TERMINATE;

        //
        // Terminate all active devices
        //        
        for (i=0;i<MAX_INSTANCE;i++)
        {
          // Check if this device exists.
          if (NvDBPtr_Table[i] != NULL)
          {
            pDev = NvDBPtr_Table[i];
            pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
          
            osEnsureDeviceEnabled(pDev);
            // Make sure the device is enabled for this. During a shutdown I have found Win98 disabling the memory
            // map of the device.
            // How about if Win98 decides to unmap us. Huh?
            // Just unhook the interrupt and avoid the stateNv(STATE_DESTROY) in that case.
            {
              U032 we_are_mapped;
              U032 pci_address;
              
              // Check if the device has become unmapped. If so stop servicing.
              // Read the 1st base register.
              pci_address = pDev->Mapping.nvBusDeviceFunc;
              _asm mov  eax, pci_address  
              _asm or   eax, 0x80000010 
              _asm mov  dx, 0xcf8
              _asm out  dx, eax
              _asm mov  dx, 0xcfc
              _asm in   eax,dx
              _asm mov  we_are_mapped,eax
              
              DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Disable and Unhook interrupt on device ", i);
              if(we_are_mapped)
              {
                  if (rmInit == DEVICE_INIT)  // only if we were init'd should we have anything to do
                  {
                      //
                      // Nothing to callback to.
                      //
                      pOsHwInfo->dllIpcOffset = 0;
                      pOsHwInfo->dllIpcSelector    = 0;
                      pOsHwInfo->dllNotifyOffset   = 0;
                      pOsHwInfo->dllNotifySelector = 0;
                      osCallbackList    = NULL;
                  }
                
                  stateNv(pDev, STATE_DESTROY);
                  if (pDev->Mapping.hpicIRQ)
                     VPICD_Force_Default_Behavior(pDev->Mapping.hpicIRQ);
                  pDev->Mapping.hpicIRQ = NULL;
                  pDev->DeviceDisabled = TRUE;

                  // Turn off other devices for shutdown
                  if (pDev->Power.MobileOperation)
                  {
                  U032 Broadcast;
                  U032 VGAHead;
                  U032 i;
                  U032 CR3B;
                  U008 Lock0;
                  U008 Lock1;
               
                     Lock0 = UnlockCRTC(pDev, 0x0);
                     Lock1 = UnlockCRTC(pDev, 0x1);
                     CRTC_RD(0x3C, Broadcast, 0); 
                     Broadcast &= 0x02;
//                     if (!Broadcast)
                     {
                        // Determine which head is the Primary device
                        for (i = 0, VGAHead = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                        {
                           if (pDev->Dac.CrtcInfo[i].PrimaryDevice == TRUE)
                           {
                              VGAHead = i;
                              break;
                           }
                        }
                     CRTC_RD(0x3B, CR3B, VGAHead^0x01);
                     CRTC_WR(0x3B, CR3B & 0x0F, VGAHead^0x01);
                     } 
                     RestoreLock(pDev, 0x0, Lock0);
                     RestoreLock(pDev, 0x1, Lock1);
                  }
              }
              else
              {
                  if (pDev->Mapping.hpicIRQ)
                     VPICD_Force_Default_Behavior(pDev->Mapping.hpicIRQ);
                  pDev->Mapping.hpicIRQ = NULL;
                  pDev->DeviceDisabled = TRUE;
              } 
            }
            
            //
            // Clear the device structure
            //
            NvDBPtr_Table[i] = NULL;
          } // This device exists.
        } // for all devices
               
        break;
    case SYSTEM_EXIT:
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: System_Exit\n\r");
        // nothing to do here.
        break;
    case SYS_CRITICAL_EXIT:
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Sys_Critical_Exit\n\r");
#ifdef DEBUG
        DbgObject[dbgObject_inuse].pClose(NULL);          
#endif            
        osPhase = SYS_CRITICAL_EXIT;
        rmInit = 0;
        break;
    default:
        // DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Unhandled rmControl msg: ", Msg);
        break;
    }
    return (status);
}

//---------------------------------------------------------------------------
//
//  Function to determine if Windows is terminating.
//
//---------------------------------------------------------------------------
BOOL osTerminating (VOID)
{
   return((osPhase == SYS_CRITICAL_EXIT) ||
      (osPhase == SYSTEM_EXIT) ||
      (osPhase == SYS_VM_TERMINATE));
}

//---------------------------------------------------------------------------
//
//  Resource Manager service functions.
//  These are called from the miniVDD
//
//---------------------------------------------------------------------------

//  response to PreHiResToVga. We are going to full screen DOS.
U032 CDECL rmEnableVga
(
    PHWINFO pDev,
    BOOL PrimaryDevice
)
{
    U032 page;
    U032 size;
    U032 i, VGAHead;
    U032 status;
    U032 *fb_sv;
    U008 data8;
    
    // Indicate that we are going to a DOS Box.
    pDev->Vga.DOSBox = TRUE;
    
    rmInService++;
    stateNv(pDev, STATE_UNLOAD);
    
//  clear the screen: if we're shutting down after an re-install, we don't want to leave a mess on the screen 
//  between now and when Windows puts up the "Windows is restarting" message.
    page = pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current] / 4;
    size = (pDev->Dac.HalInfo.Depth / 8) * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth / 4;
    for (i = 0; i < size; i++)
    {
        fbAddr->Reg032[page + i] = 0;
    }
    pDev->Vga.Enabled = TRUE;
    stateNv(pDev, STATE_LOAD);
    
    // In VGA mode, set flag for BIOS to program TV encoder
    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX, data8, 0);
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX, data8 & ~0x02, 0);  // clear bit 1 (OK to program TV encoder)
    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
    
    if (PrimaryDevice && pDev->Vga.Enabled)
    {
            // Copy instance memory to save area.
            // The first 64k is BIOS image (looking backwards from the top). If the BIOS does
            // not get POSTed after standby (BIOS POST can be turned off in BIOS SETUP), 
            // we need to have a copy to use to re-init the device (we use the BIOS init tables),
            // so we'll copy the BIOS image into our save buffer.
            status = osAllocMem((VOID **)&inst_sv, INST_COPY);
            fb_sv = inst_sv;
            if (!status)
            {
                for(i=0; i < INST_COPY/4; i++)
                {
                    *fb_sv++ = REG_RD32(NV_PRAMIN_DATA032(i)); // from the top
                                                               // this actually decrements from the top
                }            
                InstanceMemSaved = TRUE;    // let rmEnableHires restore it
            }
            nvHalFbControl(pDev, FB_CONTROL_INSTWR_DISABLE);
    }
    else
    {
        // For the secondary displays, disable the interrupts.
        REG_WR32(NV_PMC_INTR_EN_0, 0);
        pDev->DeviceDisabled = 1;
    }

//    pDev->Dac.DeviceProperties.InferAuxDev = TRUE;
    pDev->Dac.DeviceProperties.LastSwitchEvent = SWITCH_FROM_FS_DOS;

    DisableMobileHotkeyHandling(pDev);

    // Determine which head is the Primary device
    for (i = 0, VGAHead = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        if (pDev->Dac.CrtcInfo[i].PrimaryDevice == TRUE)
        {
            VGAHead = i;
            break;
        }
    }

    pDev->Dac.CrtcInfo[0].MonitorPowerSetMode = FALSE;
    pDev->Dac.CrtcInfo[1].MonitorPowerSetMode = FALSE;

    // Check the BIOS type: multihead or single head
    // Currently mobile is multihead and desktop is single head.
    // Sometimes Cr44 gets switched to "3" without Head2RegOwner getting update,
    // and the update of the register is skipped. We can't let this happen, so set to UNKNOWN.
    pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN; 
    if (!pDev->Power.MobileOperation)
    {
        // Not a multi-head BIOS
        if (pDev->Dac.CrtcInfo[0].pVidLutCurDac != NULL)
        {
            // if going to DOS FS, the BIOS has already set mode. Doing this will kill the TV encoder.
//            dacDisableDac(pDev, 1);    // blank display on the other head
            EnableHead(pDev, 0);       // but leave pointing to head 0
        }
    }
    else
    {
        // Is a multi-head BIOS
        if (pDev->Dac.CrtcInfo[VGAHead].pVidLutCurDac != NULL)
        {
            U008 lockA, lockB, Cr3B[2];
            
            // Read both Cr3B registers
            lockA = UnlockCRTC(pDev, 0);
            lockB = UnlockCRTC(pDev, 1);
            CRTC_RD(0x3B, Cr3B[0], 0);
            CRTC_RD(0x3B, Cr3B[1], 1);

            RestoreLock(pDev, 0, lockA);
            RestoreLock(pDev, 1, lockB);
            
            // check to see if we need to disable second head
            if (!pDev->Dac.BroadcastSupport)  // BIOS/chip revision does not support broadcast mode
            {
                U032 SecondaryHead = VGAHead^1;

                // only turn on TV flag if we intend to disable TV in dacDisableDac().
                if(((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[SecondaryHead].pVidLutCurDac)->DisplayType == DISPLAY_TYPE_TV)
                {
                    pDev->Dac.DevicesEnabled |= (DAC_TV_ENABLED); // force disabling of TV in case we already
                                                                  // disabled, but BIOS reenabled during detection.
                }
                
                dacDisableDac(pDev, VGAHead^1);    // blank display on the other head
                EnableHead(pDev, VGAHead);         // should be unnecessary, but just in case

                // Clear out the secondary head nibble
                lockA = UnlockCRTC(pDev, SecondaryHead);
                CRTC_WR(0x3B, (Cr3B[SecondaryHead]&0x0F), SecondaryHead);
                RestoreLock(pDev, SecondaryHead, lockA);
            }
            else
            {
                // We do have a Broadcast aware VBIOS/Chip.  
                // We need to make sure to set Broadcast mode here if not set.
                // Do both heads have active displays?
                if((Cr3B[0]&0xF0) && (Cr3B[1]&0xF0))
                {
                    // 
                    // Both displays are active, so enable broadcast mode
                    lockA = UnlockCRTC(pDev, 0);
                    CRTC_WR(NV_CIO_CRE_H2OWNS, 0x4, 0);
                    RestoreLock(pDev, 0, lockA);
                    pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN;
                }
  
            }
            
            
            // Save off this information here for rmEnableHires
            if(pDev->Dac.DeviceProperties.Spanning)
            {
                pDev->Dac.NonBroadcastModeStoredCr3B[0] = Cr3B[0]&0xF0;
                pDev->Dac.NonBroadcastModeStoredCr3B[1] = Cr3B[1]&0xF0;
            }
        }
    }

    rmInService--;
    return (RM_OK);
} // end of rmEnableVga


//  Called from mini-VDD PreVgaToHiRes. We are returning to Windows from full screen DOS.
//  Or called from NVRM_API_CONFIG_VGA. The display driver is asking us to go to hires.
//  Note: we should probably only call this from the mini-VDD, meaning the display driver should do the VDD call instead
//  of calling us directly.
U032 CDECL rmEnableHiRes
(
    PHWINFO pDev,
    BOOL PrimaryDevice
)
{
    PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    U032 page;
    U032 size;
    U032 i;
    U032 data;
    U032 *fb_sv;
    U032 new_config = 0;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U008 lockA, lockB, Cr3B[2];


    if (!pDev->Vga.Enabled)
    {
        //
        // We're already in graphics mode or VGA is Windows display,
        // so do nothing.
        //
        return (RM_OK);
    }

    // Clear up CR44 if Broadcast mode was set.
    // The cached state, Head2RegOwner, can be incorrect if
    // display switch to Broadcast mode happens in VBIOS/rmEnableVGA().
    if (REG_RD_DRF(_PBUS, _DEBUG_1, _DISP_MIRROR))
    {
        // Determine which head is the Primary device
        for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
        {
            if (pDev->Dac.CrtcInfo[i].PrimaryDevice == TRUE)
            {
                break;
            }
        }
        
        pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN;
        EnableHead(pDev, i);
    }

    // restore the displays for both Cr3B registers
    lockA = UnlockCRTC(pDev, 0);
    lockB = UnlockCRTC(pDev, 1);
    CRTC_RD(0x3B, Cr3B[0], 0);
    CRTC_RD(0x3B, Cr3B[1], 1);
    
    // Restore Cr3B information if we were in extended mode
    if(pDev->Dac.DeviceProperties.Spanning)
    {
        CRTC_WR(0x3B, (pDev->Dac.NonBroadcastModeStoredCr3B[0] | (Cr3B[0]&0x0F)), 0);
        CRTC_WR(0x3B, (pDev->Dac.NonBroadcastModeStoredCr3B[1] | (Cr3B[1]&0x0F)), 1);
    }

    RestoreLock(pDev, 0, lockA);
    RestoreLock(pDev, 1, lockB);

    // Update DeviceEnabled Flags if we're switching back from DOS.
    // If we're switching back from a power save state, the 
    // DevicesEnabled will be updated in mcPowerState().
    if ((pDev->Power.MobileOperation) && 
        (pDev->Dac.DeviceProperties.LastSwitchEvent == SWITCH_FROM_FS_DOS))
    {
        //Set startup display options based on BIOS CR3B settings.
        pDev->Dac.DevicesEnabled &= ~(DAC_ALL_DEVICES_ENABLED);
        if (Cr3B[0] & 0x20) 
        {
            // CRT tracking is not used yet.
            //pDev->Dac.DevicesEnabled |= DAC_CRT_ENABLED;
        }
        else if (Cr3B[0] & 0x40) 
        {
            pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
        } 
        
        if (Cr3B[1] & 0x10) 
        {
            pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
        }
    }

//    dacDetectDevices(pDev, FALSE, pDev->Dac.DeviceProperties.OverrideSBIOSDevs);
    dacDetectDevices(pDev, FALSE, TRUE);

    if (PrimaryDevice)
    {
        //
        // Reenable access to instance memory
        //
        nvHalFbControl(pDev, FB_CONTROL_INSTWR_ENABLE);

        if (InstanceMemSaved)
        {
            // Copy from save area to framebuffer instance memory
            // The first 64k is BIOS image (looking backwards from the top). If the BIOS does
            // not get POSTed after standby (BIOS POST can be turned off in BIOS SETUP), 
            // we need to have a copy to use to re-init the device (we use the BIOS init tables),
            // so we'll copy the BIOS image into our save buffer.
            fb_sv = inst_sv;
            for(i=0; i < INST_COPY/4; i++)
            {
                 data = *fb_sv++;
                 REG_WR32(NV_PRAMIN_DATA032(i), data);
            }            
            osFreeMem((VOID *)inst_sv);
            InstanceMemSaved = FALSE;
        }
    }
    else
    {
        // For secondary devices, enable interrupts.
        REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);
        pDev->DeviceDisabled = 0;
    }
    
    //
    // Save/Reload state info.
    //
    rmInService++;
    
    // mcPowerState will call stateNv during ACPI resume. Don't do it twice.
    // (rmUsrApi will also set back to Vga.Enabled, even tho mcPowerState it clears it to load Hires state; 
    // this is so Win2k can avoid making a second call to load state.)
    if (resume == 0) 
    {
        stateNv(pDev, STATE_UNLOAD);
        pDev->Vga.Enabled = FALSE;
        
        // clear display memory (in case we lost power in standby)
        page = pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current] / 4;
        size = (pDev->Dac.HalInfo.Depth / 8) * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth / 4;
        for (i = 0; i < size; i++)
        {
            fbAddr->Reg032[page + i] = 0;
        }

        stateNv(pDev, STATE_LOAD);
    }

    //Check global powerup pending flag. Win9x display driver will do the modeset
    //call right after this call so we can bypass extraneous modeset call here.
//!!! Commented this out because there was no display on LCD after monitor poweroff from clone
//!!!    if(!(pDev->Power.Flags & DAC_POWER_PENDING))
    {
        //
        // Check if the we need to do the modesets here or not. It's possible the
        // monitor power routines have already done it. Also, if we're setting the
        // panel call the dacSetModeStart/dacSetModeEnd which control the backlight.
        //
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac;
        if (pVidLutCurDac && (pDev->Dac.CrtcInfo[0].MonitorPowerSetMode == FALSE))
        {
            switch (pVidLutCurDac->DisplayType)
            {
                case DISPLAY_TYPE_MONITOR:
                    new_config |= 0x00000001; break;
                case DISPLAY_TYPE_TV:
                    new_config |= 0x00000100; break;
                case DISPLAY_TYPE_FLAT_PANEL:
                    new_config |= 0x00010000; break;
            }
        }
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[1].pVidLutCurDac;
        if (pVidLutCurDac && (pDev->Dac.CrtcInfo[1].MonitorPowerSetMode == FALSE))
        {
            switch (pVidLutCurDac->DisplayType)
            {
                case DISPLAY_TYPE_MONITOR:
                    new_config |= 0x00000001; break;
                case DISPLAY_TYPE_TV:
                    new_config |= 0x00000100; break;
                case DISPLAY_TYPE_FLAT_PANEL:
                    new_config |= 0x00010000; break;
            }
        }

        // If a flat panel is involved, start the modeset
        if (new_config & 0x00010000)
            dacSetModeStart(pDev, (new_config | NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET));

        // Do modesets on active heads (if SET_MONITOR_POWER hasn't already)
        if (pDev->Dac.CrtcInfo[0].MonitorPowerSetMode == FALSE)
        {
            pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac;
            if (pVidLutCurDac && (pVidLutCurDac->DisplayType != DISPLAY_TYPE_NONE))
            {
                dacSetModeFromObjectInfo(pDev, pVidLutCurDac);
                pDev->Dac.CrtcInfo[0].MonitorPowerSetMode = TRUE;
            }
        }
        if (pDev->Dac.CrtcInfo[1].MonitorPowerSetMode == FALSE)
        {
            pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[1].pVidLutCurDac;
            if (pVidLutCurDac && (pVidLutCurDac->DisplayType != DISPLAY_TYPE_NONE))
            {
                dacSetModeFromObjectInfo(pDev, pVidLutCurDac);
                pDev->Dac.CrtcInfo[1].MonitorPowerSetMode = TRUE;
            }
        }

        // If a flat panel was involved, end the modeset
        if (new_config & 0x00010000)
            dacSetModeEnd(pDev, (new_config | NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET));
    }

    EnableMobileHotkeyHandling(pDev);

    rmInService--;

    // If we resumed from power save, the cursor is disabled. Normally we expect Windows to re-enable.
    if (resume)
    {
        pDev->Dac.CrtcInfo[0].CursorType = DAC_CURSOR_TWO_COLOR_XOR;   // Enable cursor, because Windows won't.
        resume = 0;
    }                        

    pDev->Vga.Enabled = FALSE;
    pDev->Vga.DOSBox = FALSE;
    // Now Vga.Enable = FALSE. If we are resuming from power management, it would have been TRUE, and we might have processed
    // an IRQ, in which case the IRQ process would have returned with interrupts disabled, so we should now reenable.
    REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);

    // BIOS uses legacy readback, RM uses standard readback
    if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) 
    {
        dacTV871Readback(pDev, 0, 1);  // set non-legacy readback mode
    }

    return (RM_OK);
} // end of rmEnableHiRes

VOID RmEnableInterrupts(
    PHWINFO pDev
)
{
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Enabling NV interrupts...\n");
    REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);

} // end of RmEnableInterrupts();

//---------------------------------------------------------------------------
//  rmConfigStart
//  Response to Plug and Play handler's ConfigStart message.
//  Perform physical to linear address translation and init the resource manager
//  This function takes globals nvPhys and fbPhys and translates addresses to nvAddr and fbAddr,
//  and translates nvIRQ to pDev->Mapping.Intline.
//
//---------------------------------------------------------------------------
U032 CDECL rmConfigStart(PHWINFO pDev)
{
    PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ConfigStart\n\r");
    
    //
    // Remap address of NV (16meg) ?
    //
    if (pDev->Mapping.nvPhys != pDev->Mapping.PhysAddr)
    {
        (U032)pDev->Mapping.PhysAddr = pDev->Mapping.nvPhys;
//  the mapping will take place in nvState(state_init)
//        nvAddr = vmmMapPhysToLinear(pDev->Mapping.PhysAddr, 0x01000000, 0);
    }
        
    //
    // Remap address of NV framebuffer (16meg)
    //
    if (pDev->Mapping.fbPhys != pDev->Mapping.PhysFbAddr)
    {
        pDev->Mapping.PhysFbAddr = pDev->Mapping.fbPhys;
//  the mapping will take place in nvState(state_init)
//        fbAddr = vmmMapPhysToLinear(pDev->Mapping.PhysFbAddr, 0x01000000, 0);
    }        
    //
    // Rehook IRQ?
    //
    if (pDev->Mapping.nvIRQ != pDev->Mapping.IntLine)
    {
        pDev->Mapping.IntLine = pDev->Mapping.nvIRQ;
    }
    
    status = RM_OK;
    
    //
    // Grab state of the display first.
    // 
    osDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &osDisplayInfo, sizeof(DISPLAYINFO));
#ifdef RM_STATS
    //
    // Init all per device data structures.
    //
    pDev->Statistics.MemAlloced = 0;
    pDev->Statistics.MemLocked  = 0;
#endif    
    status = stateNv(pDev, STATE_INIT);
    //
    // For Windows, come up as VGA until display drivers
    // disables it thus enabling high-res.
    //
    pDev->Vga.Enabled = TRUE;
    if (!status) status = stateNv(pDev, STATE_LOAD);
    
    return (status);
    
}

//---------------------------------------------------------------------------
//  rmConfigStop 
//  Currently used when we get an ACPI D3 message.
//---------------------------------------------------------------------------
U032 CDECL rmConfigStop(PHWINFO pDev)
{
    PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ConfigStop\n\r");
    //
    // Nothing to callback to.
    //
    pOsHwInfo->dllIpcOffset      = 0;
    pOsHwInfo->dllIpcSelector    = 0;
    pOsHwInfo->dllNotifyOffset   = 0;
    pOsHwInfo->dllNotifySelector = 0;
    osCallbackList    = NULL;
    
    //
    // Are we still mapped? If secondary display, probably not.
    // Fifo interrupts are still enabled. This is bad, but not too bad, as long as the chip doesn't interrupt.
    //
    if (REG_RD32(NV_PMC_BOOT_0) != -1)
    {
        stateNv(pDev, STATE_UNLOAD);  
        stateNv(pDev, STATE_DESTROY);
    }
    // unhook interrupt
    if (pDev->Mapping.hpicIRQ)
      VPICD_Force_Default_Behavior(pDev->Mapping.hpicIRQ);
    pDev->Mapping.hpicIRQ = NULL;

    // Free per device RM memory if any.
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Resource Manager API for VxDs and user mode clients. (e.g. display driver)
//
//---------------------------------------------------------------------------

//
// System level API for other VxDs.
//
RM_STATUS CDECL rmSysAPI
(
    U032 hReg,
    U032 Msg,
    V032 Param1,
    V032 Param2
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: System Service to Resource Manager\n\r");
    return (RM_OK);
}

int osGetNextAvailableInstance
(
  VOID
)
{
  int i;

  for(i=0;i<MAX_INSTANCE;i++)
    if(NvDBPtr_Table[i] == NULL)
      return (i);
  // If there are no NULL entries available ... return -1
  return (-1);
}

//
// User mode client API.
//
// pcs->CRS.Client_EAX will have a pointer to the RM_STRUCT containing the function and device.
RM_STATUS __fastcall rmUsrAPI
(
    U032 hVM,
    PCS  pcs
)
{
    PWIN9XHWINFO pOsHwInfo = NULL;

    U032          i;
    DESCRIPTOR    desc;
    U032          LinAddr;
    U032          PageBase;
    U032          Page;
    U032          PageCount;
    U032          PTE;
    static U032   grCanvasID;
    static U032   grClipCount;
    static U008   NopMask;
    PDMAPUSH_ADDRESS_INFO pDmaPushInfo=NULL;
    U032          status;
    U032          data;
    U032          data32;
    U032          *fb_sv;
//#ifdef BX_FIX
    CLIENT_STRUCT crs;          // another client_reg struct for internal use
//#endif
    MiniVDD_ParameterStruct *pMiniVDD_parameters;
    PHWINFO pDev;
    PRMUSRAPI_STRUCT rm_tempp;

    U032 Head = 0;  // need to pass this as a parameter?
    static U016   BxDev, Bx50, BxA8;   // BX bus & dev #, AGP enables
#ifdef DEBUG
    extern NvU32 dbgPowerSysState;
#endif


    extern U032           DmaPushOperation(U032, PDMAPUSH_ADDRESS_INFO);
    extern U032           DmaPushLock(U032, PDMAPUSH_ADDRESS_INFO);

    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: User Service to Resource Manager: VM handle = ", hVM);

    rm_tempp = (PRMUSRAPI_STRUCT) pcs->CRS.Client_EAX;
    pDev = NvDBPtr_Table[rm_tempp->device];
    pcs->CRS.Client_EAX = rm_tempp->function;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,     "                                        Service   = ", rm_tempp->function);
    if((rm_tempp->function == NVRM_API_ARCHITECTURE_32)||(rm_tempp->function==NVRM_API_ARCHITECTURE_16)){
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,       "                                        Device not valid for NVARCH FUNCTION\n");
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                                        Device    = ", rm_tempp->device);
    }

    //This is really happens every time when RM started (NVRM_API_INIT).
    //I don't have any idea why our driver even worked before this fix.
    if( pDev != 0 )
    {
        pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

        // It appears that Windows likes to disable our memory decode at random.
        // So ... we have to re-enable in this case.
        // Check if this device exists.
        if(pcs->CRS.Client_EAX != NVRM_API_POWER_UP)
            osEnsureDeviceEnabled(pDev);
    }

    //
    // Handle requested service.
    //
    switch (pcs->CRS.Client_EAX)
    {
        //*************************************************
        // Architecture "IOCTL" calls.
        //*************************************************
        case NVRM_API_ARCHITECTURE_32:
        case NVRM_API_ARCHITECTURE_16:
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                                        ioctl    = ", pcs->CRS.Client_EDX);
              if (pcs->CRS.Client_EDX <= NVRM_ARCH_MAX_IOCTL)
                NvArchRMDispatch(pcs->CRS.Client_EDX, (PVOID)pcs->CRS.Client_EBX);
            }  
            break;
        //*************************************************
        // These first functions are called by the mini-VDD
        //*************************************************
        //
        // Map NV addresses. 
        //
        case NVRM_API_INIT:

        {
          PHWINFO pDev;
          int     dev_instance;
          U032    physAddr;          
          // This macro will produce a divide by 0 error at compile time if the sizeof HWINFO
          // struct is not a multiple of 4. However, it does not help if some sub struct of
          // HWINFO is not aligned properly.
          ASSERT_NVINFO_SIZE;

          // See if the device has already been init'd (i.e. the secondary miniVDD is loaded for the 2nd head of a single device.
          pMiniVDD_parameters = (MiniVDD_ParameterStruct *)pcs->CRS.Client_ESI;
          physAddr = pMiniVDD_parameters->callrm_nvphys;
          for (i=0; i < MAX_INSTANCE; i++) // Check all entries in the table of devices
          {
              if (NvDBPtr_Table[i] == 0)
                  break;
              else
              {
                if (physAddr == NvDBPtr_Table[i]->Mapping.PhysAddr) // Have we already init'd this device?
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: API_INIT for secondary head\n");
                    return (RM_OK);     // We don't need to do anything
                }
                else
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: API_INIT for secondary device\n");
              }
          }
          // This is a new device
          if (! (RmAllocDeviceInstance(&dev_instance)==RM_OK) )
          {
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device database\n");
          }else{

            pDev = NvDBPtr_Table[dev_instance];

            // setup the ptr to the OS Hw info
            pDev->pOsHwInfo = (VOID_PTR) &win9xHwInfo[dev_instance];
            pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

            initStack_frame(pDev);
              
            // Delete the registry override for startup, so Control Panel will know we loaded.
            osDeleteRegistryValue(pDev->Registry.DBstrDevNodeDisplay, strStartUp);
            // Same goes for TV format
            osDeleteRegistryValue(pDev->Registry.DBstrDevNodeDisplay, strTVtype); 

            pMiniVDD_parameters = (MiniVDD_ParameterStruct *)pcs->CRS.Client_ESI;

            pDev->Mapping.nvPhys = pMiniVDD_parameters->callrm_nvphys;
            pDev->Mapping.fbPhys = (pMiniVDD_parameters->callrm_fbphys & 0xFFFF0000);
            pDev->Mapping.nvIRQ = pMiniVDD_parameters->callrm_irq_bus & 0xFF;
            pDev->Mapping.fbLength =(pMiniVDD_parameters->callrm_fbphys & 0xFFFF) << 16;
            pDev->Mapping.nvBusDeviceFunc = pMiniVDD_parameters->callrm_irq_bus & 0xFFFFFF00;

            //
            // This is actually a macro into a device's pDev
            //
            pOsHwInfo->osScheduled = 0;
            
            // This is only necessary for the primary display device. The secondary minivdd will step on this otherwise.
            if(pDev == NvDBPtr_Table[0])
               pOsHwInfo->miniVDDPostModeChange = (VOID *)pMiniVDD_parameters->callrm_modechange_callback;   // save callback address
   
            {
              int  char_count,string_size;
              char stringt[128]=NV4_REG_RESOURCE_MANAGER_SUBKEY;
              char stringt1[128]=RESOURCE_MANAGER_SUBKEY_ADDITION;
              
              osStringCopy(pDev->Registry.DBstrDevNodeDisplayNumber, (char *)pMiniVDD_parameters->callrm_registry_path);
              //osStringCopy(pDev->Registry.DBstrDevNodeDisplay, (char *)pMiniVDD_parameters->callrm_registry_path);
              //osStringCopy(pDev->Registry.DBstrRegistryDeviceParameters, (char *)pMiniVDD_parameters->callrm_registry_path); 
              //string_ptr = (U008 *) pcs->CRS.Client_EBX;
              //for(char_count=0;char_count<128;char_count++){
              //  pDev->Registry.DBstrDevNodeDisplayNumber[char_count] = (U008) *(string_ptr+char_count);
              //  pDev->Registry.DBstrDevNodeDisplay[char_count] = (U008) *(string_ptr+char_count);
              //}

              string_size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
              pDev->Registry.DBstrDevNodeDisplayNumber[string_size] = '\\';
              string_size++;
              for(char_count=string_size;char_count < (128-string_size);char_count++){
                pDev->Registry.DBstrDevNodeDisplayNumber[char_count]=stringt1[char_count-string_size];
              }
              // Append the Resource Manager subkey string.("System")
              string_size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
              pDev->Registry.DBstrDevNodeDisplayNumber[string_size] = '\\';
              string_size++;
              for(char_count=string_size;char_count < (128-string_size);char_count++){
                pDev->Registry.DBstrDevNodeDisplayNumber[char_count]=stringt[char_count-string_size];
              }
              osStringCopy(pDev->Registry.DBstrDevNodeDisplay,pDev->Registry.DBstrDevNodeDisplayNumber);
            }

            // Initialize these parameters.
            pDev->Dac.MobileEDID[0] = 1;    //Indicate that the buffer initialization hasn't happened yet.
            pDev->Dac.DevicesEnabled = 0;

            pDev->Dac.CrtcInfo[0].CursorHeight=32;
            pDev->Dac.CrtcInfo[0].CursorWidth=32;
            // This is called by the mini-VDD, so we must put the return values in the client-reg-struct so they'll be popped
            // back into the registers
            pcs->CRS.Client_EAX = rmConfigStart(pDev);                 // function return value
            pcs->CRS.Client_EBX = (U032) nvAddr; // return the address of NV in ebx
            pcs->CRS.Client_ECX = dev_instance + 1; // Return a 1 based handle to this device for the miniVDD.
            pcs->CRS.Client_EDX = (U032) fbAddr;    // return fb address
            pcs->CRS.Client_ESI = (U032) pDev->Dac.DFPPortID; // return DFP port ID
            pcs->CRS.Client_EDI = (U032) pDev->Video.HalInfo.CustomizationCode; // return customer mask
            
            pDev->fb_save = 0;    // JohnH
            //pDev->DBbiosAddr = 0; // JohnH
            pDev->DBdisplayModeHook = NULL;   

            /*KYH
            dmaPushPutOffset        = 0;
            dmaPushGetOffset        = 0;
            dmaPushGetOffsetRead    = 0;
            dmaPushJumpOffset       = 0;
            dmaPushJumpOffsetSet    = 0;
            KYH*/

            pDev->Dac.flickertoggle = 0;
            pDev->DBclass63VBlankList[0] = NULL;
            pDev->DBclass63VBlankList[1] = NULL;
            pDev->Dac.I2cIniFlag = FALSE;

            {
                DESCRIPTOR  desc;
                U032        pAddress;

                // alloc a locked page to be reloaded when the GART has been cleared
                vmmPageAllocate(0x1, PG_SYS, 0, 0, 0, 0, 0, 0, &desc.Desc64);
                pAddress = (U032)desc.Desc32[0];

                if (!vmmLinPageLock(pAddress >> RM_PAGE_SHIFT, 1, 0))
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to lock detection page.\n\r");
                    //return (RM_ERR_DMA_MEM_NOT_LOCKED);
                    return (RM_OK);     // not fatal
                }
                p_agp_dummy_page = pAddress;
            }
    
            pDev->MediaPort.ImageBufferNumber = 0;    // used by canopus mediaport callback mechanism

          }//else
            // Abort Hard ....
          
        }
        break;

        // This supplies the miniVDD callback funtion with the number of heads on this device
        case NVRM_API_NUM_HEADS:
        {
            char tempString[256];
            U032 size,i;

            // Switch to the last pDev first
            for(i=0; i<MAX_INSTANCE; i++)
            {
              if(NvDBPtr_Table[i]==0)
                break;
              pDev = NvDBPtr_Table[i];
            }

            //Return DeviceInstance in EAX
            pcs->CRS.Client_EAX = i;

            //
            // Ugly but necessary.  We need to strip off the SYSTEM portion of our registry key
            // to look in the correct location for this DualView config setting.  Please revisit
            // this code and explicitly create a separate string for this registry location
            //
            osStringCopy(tempString, pDev->Registry.DBstrDevNodeDisplay);
            size = osStringLength(tempString);
            i = 2;
            while (tempString[size-i] != '\\') 
                   i++;
            tempString[size-i] = 0x00;  // truncate back to NVIDIA

            //
            // Only enable multiple CRTC's when the hardware supports more than one and the system
            // is configured to deal with it.
            //
            if (pDev->Dac.HalInfo.NumCrtcs > 1)
                pcs->CRS.Client_EBX = pDev->Dac.HalInfo.NumCrtcs;    // and get number of heads from HAL info
            else
                pcs->CRS.Client_EBX = 1;
        }
        break;

        // Remove the device specified in EBX
        case NVRM_API_EXIT:
        {
            BYTE  *x;

            pDev = NvDBPtr_Table[pcs->CRS.Client_EBX];
            rmConfigStop(pDev); 
            if (pOsHwInfo->osDeviceName != 0)
            {
                _HeapFree(pOsHwInfo->osDeviceName, 0);
                pOsHwInfo->osDeviceName = 0;
            }
            if (pDev->EDIDBuffer != 0)
            {
                osFreeMem((VOID *)pDev->EDIDBuffer);
                pDev->EDIDBuffer = 0;
            }

            x = (BYTE *) pDev;
            _HeapFree(x, 0);
            pDev = NULL;
            break;    
        }
            
        //
        //  Enable VGA
        //
        case NVRM_API_ENABLEVGA:
            // Set the context to the primary device.(This will always be the case).
            pDev = NvDBPtr_Table[0];
            rmEnableVga(pDev,TRUE /* is primary device */);
            pcs->CRS.Client_EAX = RM_OK;            // function return value
            break;

        //
        //  Disable VGA
        //
        case NVRM_API_ENABLEHIRES:
            // Set the context to the primary device.(This will always be the case).
            pDev = NvDBPtr_Table[0];
            rmEnableHiRes(pDev, TRUE /* is primary device */);
            pcs->CRS.Client_EAX = RM_OK;            // function return value
            
            break;
        
        //
        //  MiniVDD notifier that ACPI is enabled
        //
        case NVRM_API_ACPI_ENABLED:
            // Set DAC_PM_SUPPORTED bit to prevent mix with old style management.
            pDev->Power.Flags |= DAC_PM_SUPPORTED;

            break;

        //
        //  Map ACPI states into NV power states
        //
        
        //  ACPI D0 state
        case NVRM_API_POWER_UP:
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: ACPI D0 state\n");
#ifdef DEBUG
            dbgPowerSysState = 2;
#endif
            resume = 1;                                         // Signal resume has occurred, reenable cursor

            // What state are we powering up from?
            switch (pDev->Power.State)
            {
                case MC_POWER_LEVEL_1:
                    mcPowerState(pDev, MC_POWER_LEVEL_0, Head);
                    break;
                case MC_POWER_LEVEL_2:
                    mcPowerState(pDev, MC_POWER_LEVEL_0, Head);
                    break;
                case MC_POWER_LEVEL_3:
                    mcPowerState(pDev, MC_POWER_LEVEL_0, Head);
                    // Hack to fix the system BIOS (440BX only)-- restore AGP access
                    if (BxA8 != 0) // If AGP was enabled before power down, restore it
                    {
                        crs.CWRS.Client_BX  = BxDev;
                        crs.CWRS.Client_CX  = Bx50;       // Aperture Access Global Enable
                        crs.CWRS.Client_CX |= 0x20; // enable MDA
                        crs.CBRS.Client_AH  = 0xB1;       // PCI_FUNCTION_ID
                        crs.CBRS.Client_AL  = 0x0c;       // WRITE_CONFIG_WORD
                        crs.CWRS.Client_DI  = 0x50;       // NBX config reg      
                        PCI(&crs);
                        crs.CWRS.Client_CX  = BxA8;       // AGP, sideband enable; 2x
                        crs.CBRS.Client_AH  = 0xB1;       // PCI_FUNCTION_ID
                        crs.CBRS.Client_AL  = 0x0c;       // WRITE_CONFIG_WORD
                        crs.CWRS.Client_DI  = 0xA8;       // NBX config reg      
                        PCI(&crs);
                    }
                    pOsHwInfo->osScheduled = 0;         // this might have been set before we shut down
                    break;
            }

            //Return MobileOperation to VDD
            pcs->CRS.Client_EAX = pDev->Power.MobileOperation;

            pDev->Vga.Enabled = TRUE;   // set back to VGA (mcPowerState called stateNv(LOAD) for hires)
                                        // so that rmEnableHires will execute addition transition code.
            break;
        //  ACPI D3 state
        case NVRM_API_POWER_DOWN:
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: ACPI D3 state\n");
#ifdef DEBUG
            dbgPowerSysState = 1;
#endif
            if (pDev->Power.MobileOperation)
            {
                if (pDev->Power.MobileOperation == 2)// ||
                    //pDev->Power.MobileOperation == 4) // Toshiba or Compal?
                {
                    mcPowerState(pDev, MC_POWER_LEVEL_3, Head);
                }
                else
                {
                    mcPowerState(pDev, MC_POWER_LEVEL_2, Head);
                }
            }
            else
            {
                mcPowerState(pDev, MC_POWER_LEVEL_3, Head);

                // This gets called for all devices. We don't need to do it multiple times, but it shouldn't matter.
                // This only needs to happen if we have an AGP device.
                Bx50 = 0;
                BxA8 = 0;
                // Hack for 440BX system BIOS bug: save AGP enables on 440BX
                // Find the 440BX Bridge
                crs.CBRS.Client_AH  = 0xB1;           // PCI_FUNCTION_ID
                crs.CBRS.Client_AL  = 0x02;           // FIND_PCI_DEVICE
                crs.CWRS.Client_CX = 0x7190;          // Device ID
                crs.CWRS.Client_DX = 0x8086;          // Vendor ID
                crs.CWRS.Client_SI = 0;               // Index
                PCI(&crs);                              // return BH = bus, BL = dev num
                BxDev = crs.CWRS.Client_BX;
                if (crs.CBRS.Client_AH == 0x00)       // found? if not, nothing to do
                {
                    crs.CBRS.Client_AH  = 0xB1;       // PCI_FUNCTION_ID
                    crs.CBRS.Client_AL  = 0x09;       // READ_CONFIG_WORD
                    crs.CWRS.Client_DI  = 0x50;       // NBX config reg      
                    PCI(&crs);
                    Bx50 = crs.CWRS.Client_CX;
                    crs.CBRS.Client_AH  = 0xB1;       // PCI_FUNCTION_ID
                    crs.CBRS.Client_AL  = 0x09;       // READ_CONFIG_WORD
                    crs.CWRS.Client_DI  = 0xA8;       // NBX config reg      
                    PCI(&crs);
                    BxA8 = crs.CWRS.Client_CX;
            
                }
            }
            break;

        //  ACPI D1 state
        case NVRM_API_POWER_D1:
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: ACPI D1 state\n");
#ifdef DEBUG
            dbgPowerSysState = 1;
#endif
            if (pDev->Power.MobileOperation)
                mcPowerState(pDev, MC_POWER_LEVEL_1, Head);
            else
                mcPowerState(pDev, MC_POWER_LEVEL_1, Head);
            break;            
                                                
        // ACPI Hibernate
        case NVRM_API_HIBERNATE:
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: ACPI Hibernate\n");
#ifdef DEBUG
            dbgPowerSysState = 1;
#endif
            mcPowerState(pDev, MC_POWER_LEVEL_3, Head);
#ifdef DEBUG
            dbgDisableDevice2(&DbgPort);
#endif
            break;            
                                                
            
        //**************************************************************************
        // The remaining functions are called by "users", such as the display driver
        //**************************************************************************
        // Allocate page aligned DMA buffer.
        //
        case NVRM_API_ALLOC_PAGES:
            vmmGetCritSectionStatus();      // complete delayed releases of critical section
                                            // is this necessary in Win 95?
            vmmPageAllocate(pcs->CRS.Client_ECX, PG_SYS, 0, 0, 0, 0, 0, PAGELOCKED, &desc.Desc64);
            pcs->CRS.Client_EAX = desc.Desc32[0];
            pcs->CRS.Client_EDX = desc.Desc32[1];
            break;
        //
        // Free DMA buffer.
        //
        case NVRM_API_FREE_PAGES:
            vmmGetCritSectionStatus();
            vmmPageGetSizeAddr(pcs->CRS.Client_ECX, 0, &desc.Desc64);
            vmmPageUnLock(pcs->CRS.Client_ECX,
                          desc.Desc32[0],
                          0,
                          0);
            pcs->CRS.Client_EAX = vmmPageFree(pcs->CRS.Client_ECX, 0);
            break;
        //
        // Lock memory pages.
        //
        case NVRM_API_LOCK_PAGES:
            //
            // Map the buffer
            //
            vmmGetCritSectionStatus();
            LinAddr = vmmSelectorMapFlat(vmmGetSysVMHandle(), pcs->CRS.Client_EBX, 0)
                    + pcs->CRS.Client_ECX;
            PageCount = ((LinAddr & PAGEMASK) + pcs->CRS.Client_EDX + PAGESIZE - 2) >> PAGESHIFT;
            PageBase = PAGE(LinAddr);
            pcs->CRS.Client_EAX = TRUE;
            //
            // Scatter/gather lock the pages.
            //
            if (vmmPageCheckLinRange(PageBase, PageCount, 0) != PageCount)
            {
                pcs->CRS.Client_EAX = FALSE;
                break;
            }
            for (Page = 0; Page < PageCount; Page++)
            {
                //
                // Touch page to make sure it is in memory.  Win32s doesn't like
                // to play nicely with the VMMs memory manager.
                //
                NopMask |= *(volatile U008 *)LinAddr;
                LinAddr += PAGESIZE;
                if (!vmmLinPageLock(PageBase + Page, 1, 0))
                {
                    pcs->CRS.Client_EAX = FALSE;
                    break;
                }
                if (!vmmCopyPageTable(PageBase + Page, 1, (U032)&PTE, 0))
                {
                    pcs->CRS.Client_EAX = FALSE;
                    break;
                }
                if (!(PTE & P_PRES))
                {
                    pcs->CRS.Client_EAX = FALSE;
                    break;
                }
            }
            break;
        //
        // Unlock memory pages.
        //
        case NVRM_API_UNLOCK_PAGES:
            //
            // Unlock memory pages.
            //
            vmmGetCritSectionStatus();
            LinAddr   = vmmSelectorMapFlat(vmmGetSysVMHandle(), pcs->CRS.Client_EBX, 0)
                      + pcs->CRS.Client_ECX;
            PageCount = ((LinAddr & PAGEMASK) + pcs->CRS.Client_EDX + PAGESIZE - 2) >> PAGESHIFT;
            PageBase  = PAGE(LinAddr);
            //
            // Make sure the linear address range is valid.
            //
            PageCount = vmmPageCheckLinRange(PageBase, PageCount, 0);
            NopMask   = 0xFF;
            for (Page = 0; Page < PageCount; Page++)
            {
                *(volatile U008 *)LinAddr &= NopMask;
                LinAddr += PAGESIZE;
            }
            pcs->CRS.Client_EAX = vmmLinPageUnLock(PageBase, PageCount, 0) ? TRUE : FALSE;
            break;
        //
        // Map selector to linear address.
        //
        case NVRM_API_MAP_SELECTOR:
            pcs->CRS.Client_EAX = 0;
            if (pcs->CRS.Client_ECX == 0)
                break;
            //
            // Allocate a selector to map this buffer.
            //
            PageCount = ((pcs->CRS.Client_ECX + 0xFFF) & 0xFFFFF000) / 0x1000;
            vmmBuildDescriptorDWORDs(pcs->CRS.Client_EBX,
                                     PageCount,
                                     RW_DATA_TYPE,
                                     D_PAGE32,
                                     0,
                                     &desc.Desc64);
            if (pcs->CWRS.Client_DX == 0)
            {
                pcs->CRS.Client_EAX =
                    vmmAllocateGDTSelector(desc.Desc32[1],
                                           desc.Desc32[0],
                                           0);
            }
            else
            {
                pcs->CRS.Client_EAX =
                    vmmSetDescriptor(pcs->CWRS.Client_DX,
                                     hVM,
                                     desc.Desc32[1],
                                     desc.Desc32[0],
                                     0);
            }
            break;
        //
        // Register Windows Resource Manager callback routines.
        //
        case NVRM_API_IPC_CALLBACK:
            pOsHwInfo->dllIpcOffset   = pcs->CRS.Client_ECX;
            pOsHwInfo->dllIpcSelector = pcs->CWRS.Client_DX;
            break;
        case NVRM_API_NOTIFY_CALLBACK:
            pOsHwInfo->dllNotifyOffset   = pcs->CRS.Client_ECX;
            pOsHwInfo->dllNotifySelector = pcs->CWRS.Client_DX;
            break;
        //
        // Return far pointers to Resource Manager information structures.
        //
        case NVRM_API_MULTIDEVICE_MAP_RM_INFO:
          //
          // Map the DevInfo, channelInfo, & ClientInfo structures.
          //
          pcs->CRS.Client_EAX = RM_ERROR;
          {
            // Use this global to reflect whether this function has been called yet.
            // You must re-allocate sectors for the pDev's because they can be disabled and re-allocated
            // during dynamic enable/disables.
            //if (NvInfoSelectorsSelector == 0)
            {
              int device_count;
              int pDev_count=0;
              // Allocate selectors for each of the Devices.
              device_count = osGetNextAvailableInstance();
              // Set the global context to the first device.
              pDev = NvDBPtr_Table[pDev_count];
              
              // Allocate selectors for each of the device NvInfo structures.
              while(device_count != 0)
              {
                vmmBuildDescriptorDWORDs((DWORD)pDev,
                                         sizeof(HWINFO),
                                         RW_DATA_TYPE,
                                         D_DEF16,
                                         0,
                                         &desc.Desc64);
                NvInfoSelectors[pDev_count] =                         
                    vmmAllocateLDTSelector(hVM,
                                           desc.Desc32[1],
                                           desc.Desc32[0],
                                           1,
                                           0);
                device_count--;    
                pDev_count++;
                pDev = NvDBPtr_Table[pDev_count];
              }                             
            }
            // Allocate selectors for the array of NvInfo pointers.
            vmmBuildDescriptorDWORDs((DWORD)&NvInfoSelectors[0],
                                     (MAX_INSTANCE * sizeof(U032)),
                                     RW_DATA_TYPE,
                                     D_DEF16,
                                     0,
                                     &desc.Desc64);
            NvInfoSelectorsSelector =                         
                vmmAllocateLDTSelector(hVM,
                                       desc.Desc32[1],
                                       desc.Desc32[0],
                                       1,
                                       0);
            
            // Flag that this is done and send back a pointer to the array of selectors. 
            //nvInfoSelector = 0;
            pcs->CRS.Client_EAX = NvInfoSelectorsSelector;
            
            if (clientInfoSelector == 0)
            {
              //
              // Allocate a selector to map this buffer.
              //
              vmmBuildDescriptorDWORDs((DWORD)clientInfo,
                                       sizeof(CLIENTINFO) * NUM_CLIENTS,
                                       RW_DATA_TYPE,
                                       D_DEF16,
                                       0,
                                       &desc.Desc64);
              clientInfoSelector =
                  vmmAllocateLDTSelector(hVM,
                                         desc.Desc32[1],
                                         desc.Desc32[0],
                                         1,
                                         0);
            }
            pcs->CRS.Client_ECX = clientInfoSelector;
            
          }
          
          break;
        
        //
        // Configuration APIs.
        //
        case NVRM_API_GET_VERSION:
            pcs->CRS.Client_EAX = NVRM_VERSION;
            pcs->CRS.Client_EDX = NVRM_VERSION >> 16;
            break;
        case NVRM_API_UPDATE_CONFIGURATION:
        {
            rmInService++;
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_PARAMS)
            {
                //
                // Check for invalid resolution setting - use registry.
                //
                //
                //  we want to change the way resolutions are passed to RM:
                //  the display driver or control applet should call nvsys to 
                //  set display width and height and pixel depth
                //  and set flag ResolutionValid. When this function sees 
                //  Resolution Valid, it uses the values in pDev and resets
                //  ResolutionValid. Otherwise, it calls the VDD to get the 
                //  resolution (from the registry).
                //  Until the display driver is changed, always get resolution from the VDD.

                //
                // KJK If the client doesn't know his resolution, go out to the vdd and get it.
                // If he thinks he knows his resolution, just set that.
                //
                if (pDev->Framebuffer.Resolution == -1)
                {
                    //
                    // Get screen resolution and framebuffer configuration from registry.
                    //
                    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &osDisplayInfo, sizeof(DISPLAYINFO));
                    pDev->Dac.HalInfo.Depth = (osDisplayInfo.InfoFlags & REGISTRY_BPP_NOT_VALID) ? 8 : osDisplayInfo.Bpp;
                    //
                    // BUG WORKAROUND: If the user has set a specific refresh rate via the Win95 OSR2+ control
                    // panel, the resulting refresh rate will always return MONITOR_INFO_NOT_VALID.  But the
                    // refresh value is correct!  Huh???
                    //
                    // So until we can find the VDD (?) bug, if the refresh value is valid (>60,<250) for our
                    // known refresh settings, let it through.
                    //
                    // Microsoft has admitted to a bug in this area of the VDD which will be fixed
                    // in Memphis (of course).
                    //
                    if ((osDisplayInfo.InfoFlags & MONITOR_INFO_NOT_VALID) &&
                        (osDisplayInfo.InfoFlags & REFRESH_RATE_MAX_ONLY) &&
                        (osDisplayInfo.RefreshRateMax >= 60) &&
                        (osDisplayInfo.RefreshRateMax <= 250))
                            osDisplayInfo.InfoFlags &= ~MONITOR_INFO_NOT_VALID;
                    //
                    // Only go out to the registry for the refresh rate if the DDK has not preset
                    // a different rate manually sometime before this ConfigUpdate().
                    //
                    if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_REFRESH_PARAMS)                
                        pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_REFRESH_PARAMS;
                    else    
                        if ((osDisplayInfo.InfoFlags & (MONITOR_INFO_NOT_VALID | MONITOR_INFO_DISABLED_BY_USER))
                         || (osDisplayInfo.RefreshRateMax == 0xFFFFFFFF)
                         || (osDisplayInfo.RefreshRateMax == 0))
                        {
                            pDev->Framebuffer.HalInfo.RefreshRate   = 60;
                            pDev->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
                            pDev->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;
                        }
                        else
                        {
                            pDev->Framebuffer.HalInfo.RefreshRate = osDisplayInfo.RefreshRateMax;
                            pDev->Framebuffer.HSyncPolarity = osDisplayInfo.HorzSyncPolarity;
                            pDev->Framebuffer.VSyncPolarity = osDisplayInfo.VertSyncPolarity;
                        }
                        
                    pDev->Framebuffer.HalInfo.HorizDisplayWidth = osDisplayInfo.XRes;
                    pDev->Framebuffer.HalInfo.VertDisplayWidth  = osDisplayInfo.YRes;
                }
                else
                {
                    //
                    // For now, assume that all pDev data is set correctly by the client
                    //
                    //      pDev->Framebuffer.Resolution != -1
                    //      pDev->Framebuffer.HorizDisplayWidth
                    //      pDev->Framebuffer.VertDisplayWidth
                    //      pDev->Framebuffer.Depth
                    //      pDev->Framebuffer.RefreshRate
                    //
                }
                    
                //
                // BUG WORKAROUND: There is another problem with the refresh information
                // returned by the VDD.  If a low-res DDraw mode is selected (ones below 640x400)
                // and there is no refresh information in the registry (since its not a std
                // desktop resolution), the VDD seems to return the rate information that
                // it has for 640x480.  But that is wrong.  Due to line doubling, the max
                // rates for the lower modes is actually determined by the max rate of the
                // doubled mode.
                //
                // For example, the max refresh rate of 512x384 is the same as the max rate
                // for 1024x768.  But that's not the info we're given.  Figures.
                //
                // If we believe the VDD, we may end up setting a refresh rate that is too
                // high for the monitor and will end up losing sync.                    
                //
                // Monitors that appear to show the problem most often actually have invalid
                // EDID information (such as the NANAO T-20), so the blame may actually
                // fall upon the monitor manufacturer.  But ours is not to blame, ours is
                // to fix.
                //
                // Anyway, we need to limit the refresh rate of all modes below 640x400 to
                // a safe/known value.  This restriction can be removed when either
                //
                // 1) the EDID/VDD bug is fixed
                // 2) a board vendor provides explicit support for setting ddraw refresh rates
                //    and we're sure we're given a valid rate.
                //
                // I hate restricting functionality, but until then let's limit all low-res 
                // line-doubled modes to 75Hz.
                //
                if ((pDev->Framebuffer.HalInfo.VertDisplayWidth < 400) 
                    && (pDev->Framebuffer.HalInfo.RefreshRate > 75))
                        pDev->Framebuffer.HalInfo.RefreshRate = 75;    // hardcode to 75Hz
                
                pDev->Framebuffer.HorizFrontPorch = 0;
                pDev->Framebuffer.HorizSyncWidth  = 0;
                pDev->Framebuffer.HorizBackPorch  = 0;
                pDev->Framebuffer.VertFrontPorch  = 0;
                pDev->Framebuffer.VertSyncWidth   = 0;
                pDev->Framebuffer.VertBackPorch   = 0;
                pDev->Framebuffer.CSync           = BUFFER_CSYNC_DISABLED;
                pDev->Dac.HalInfo.VClk            = 0;
                
                //
                // Only enable double buffering if enough memory available.
                //
                pDev->Framebuffer.Count = 1;

                //
                // Before collecting all of the pertinent display timing data and
                // setting the mode, verify that we don't need to limit our
                // timings due to a specific display device
                //
                // This display device check will be called again later, but we
                // need a glimpse of the settings before we generate the
                // first set of timings
                //
                osPreModeSet(pDev, Head);
                //
                // If we are running on a TV, be sure to limit our refresh rate
                // to the adapter default (60Hz).  The clocks are generated by
                // the external TV encoder device, but we must be sure our CRTC
                // timings are not programmed too high for the TV encoder.
                //
                if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
                    pDev->Framebuffer.HalInfo.RefreshRate = 60;
                // Flat panels CRTC timing should always work at 60 Hz. If the FP
                // supports higher refresh rates, the DAC timings will be set higher,
                // and the CRTC running at 60 Hz should still be OK (the blank period is
                // set by the DAC, not the CRTC).
                if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
                    pDev->Framebuffer.HalInfo.RefreshRate = 60;
                                    
                
                // Setup the timing information for this mode in pDev.
                osSetupForNewStyleModeSet(pDev);

                // set the new mode.
                stateSetMode(pDev);
            }
            //
            // Update any new configuration.
            //
            i = stateNv(pDev, STATE_UPDATE);
            pcs->CRS.Client_EAX = i;
            rmInService--;
            break;
        }
        case NVRM_API_CONFIG_VGA:
        {
            // The Display Driver gets call to do a Disable and then calls us
            // to switch to VGA.  If we are in MC_POWER_LEVEL_2 this is not a 
            // good thing to do
            if (MC_POWER_LEVEL_2 == pDev->Power.State)
            {
               // there is a problem with this code
               // what happens is that there are a couple of mode switches calls
               // as we power down. Mode 3 & Mode 93 --> 13 without memory
               // change.  After these mode switch the screen is corrupted instead of
               // the correct windows bitmap.  The timing of the corruption varies, with it
               // sometimes happening after mode 3 and sometimes mode 13.
               // ok corruption is better then a hang anyday....
#if 1
               U032 bar0_address, pci_address, pci_reg, i;

               bar0_address = pDev->Chip.HalInfo.PciBars[0];
               pci_address = pDev->Mapping.nvBusDeviceFunc;

               // make sure ACPI is off
               _asm mov  dx, 0xcf8
               _asm in   eax, dx
               _asm push eax
               _asm mov  eax, pci_address  
               _asm or   eax, 0x80000064
               _asm out  dx, eax
               _asm mov  dx, 0xcfc
               _asm xor  eax, eax
               _asm out  dx, eax

               // set up pci space
               for (i = 0, pci_reg = 0x80000010; i < pDev->Chip.HalInfo.TotalPciBars; i++, pci_reg += 4)
               {
                  U032 barN_address = pDev->Chip.HalInfo.PciBars[i];

                  _asm mov  dx, 0xcf8
                  _asm mov  eax, pci_address  
                  _asm or   eax, pci_reg
                  _asm out  dx, eax
                  _asm mov  dx, 0xcfc
                  _asm mov  eax, barN_address
                  _asm out  dx, eax 
               }

               // turn us on after we are mapped in
               _asm mov  eax, pci_address  
               _asm mov  dx, 0xcf8
               _asm or   eax, 0x80000004 
               _asm out  dx, eax
               _asm mov  dx, 0xcfc
               _asm in   al,dx

               // Enable the memory decode and BusmasterEnable of the PCIO device.
               _asm or   al,6
               _asm out  dx,al
               _asm pop  eax
               _asm mov  dx, 0xcf8
               _asm out  dx, eax
#else
               break;
#endif
           }

            //
            // It appears we can get a CONFIG_VGA before you've gotten the POWER_EVENT
            // to resume and trying to rmEnableHiRes with the lower power settings hangs
            // the HW, so make sure we've restored the settings first.
            //
            if (pDev->Power.State != MC_POWER_LEVEL_0)
            {
                mcPowerState(pDev, MC_POWER_LEVEL_0, Head);
                pDev->Vga.Enabled = TRUE;
                resume = 1;
            }
            
            if (pcs->CRS.Client_EBX)
                rmEnableVga(pDev, pOsHwInfo->osDeviceHandle == 1);
            else
            {
                if (pDev->fb_save)
                {
                    // copy from save area to framebuffer instance memory
                    // the first 64k is BIOS image (looking backwards from the top)
                    // the BIOS will be POSTed, so it gets copied into instance mem without our help
                    fb_sv = pDev->fb_save;

                    for(i=0; i < INST_COPY/4; i++)
                    {
                         data = *fb_sv++;
                         REG_WR32(NV_PRAMIN_DATA032(i), data);
                    }            
                    osFreeMem((VOID *)pDev->fb_save);
                    pDev->fb_save = 0;
                }
                rmEnableHiRes(pDev, pOsHwInfo->osDeviceHandle == 1);
            }
            break;
        }
        case NVRM_API_MODE_HOOK:
            pDev->DBdisplayModeHook = (U032 (*)(U032))pcs->CRS.Client_EBX;
            break;
        //
        // Return Linear address of hardware.
        //
        case NVRM_API_GET_NV_ADDRESS:
            pcs->CRS.Client_EAX = (U032)nvAddr;
            break;
        //
        // Return Linear address of framebuffer.
        //
        case NVRM_API_GET_FB_ADDRESS:
            pcs->CRS.Client_EAX = (U032)fbAddr;
            break;
        //
        // Return Linear address of AGP aperture.
        //
        case NVRM_API_GET_AGP_ADDRESS:
            pcs->CRS.Client_EAX = (U032)pDev->DBagpAddr;
            break;
        //
        // Return Linear address of Gamma table
        //
        case NVRM_API_GET_GAMMA_ADDRESS:
            pcs->CRS.Client_EAX = (U032)pDev->Dac.Gamma;
            break;
        //
        // Return framebuffer offset of priviliged vdd memory
        //
        case NVRM_API_GET_VDD_PRIV_ADDRESS:
            pcs->CRS.Client_EAX = (U032)pDev->Pram.PrivBase;
            break;
            
        //
        // Mediaport callback mechanism still used by Canopus
        //            
        case NVRM_API_VPE_MISC:
            // decode subfunction
            pcs->CRS.Client_EAX = -1; // so far success

            switch (pcs->CRS.Client_EBX)
            {
            // 16 bit accesses only !!
            case IMAGE_INSTALL_16CALLBACK:
                    mpImageCallback.Selector = (U032) (pcs->CRS.Client_EDX & 0xFFFF);
                    mpImageCallback.Offset   = pcs->CRS.Client_ECX  & 0xFFFF;
                    mpImageInstalledCallback = TRUE; // for time being, debug reasons only
                    break;

            case IMAGE_UNINSTALL_16CALLBACK:
                    mpImageCallback.Selector = 0;
                    mpImageCallback.Offset   = 0;
                    mpImageInstalledCallback = FALSE;
                    break;

            default:
                // undefined subfunction, error alert
                pcs->CRS.Client_EAX = 0;
                break;
            }
            break;
            
        //
        // Don't call system DLL anymore.
        //
        case NVRM_API_UNLOAD_DLL:
            pOsHwInfo->dllIpcOffset      = 0;
            pOsHwInfo->dllIpcSelector    = 0;
            pOsHwInfo->dllNotifyOffset   = 0;
            pOsHwInfo->dllNotifySelector = 0;
            osCallbackList    = NULL;
            break;

        case NVRM_API_SEMAPHORE:
            {
            // Maybe this code should be executed when there are > 1 NV chips in the system,
            // as it could cause a performance hit.
              if (pcs->CRS.Client_ECX == SEMAPHORE_WAIT)
                mmWaitSemaphore();
              if (pcs->CRS.Client_ECX == SEMAPHORE_SIGNAL)
                mmSignalSemaphore();
            }
            break;
            
        case NVRM_API_DRIVER_CONNECT:
            {
              // Check all devices to find out which MiniVDD is calling.
              int temp_counter;
              char * tmpPtr;
              
              for(temp_counter=0;temp_counter<MAX_INSTANCE;temp_counter++){
                pDev = NvDBPtr_Table[temp_counter];

                if(pDev==0)
                {
                  DBG_BREAKPOINT();
                  pcs->CRS.Client_EAX = 0;
                  break;
                }

                pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
                if(pOsHwInfo->osDeviceHandle == pcs->CRS.Client_EBX){
                  pcs->CRS.Client_EAX = temp_counter + 1;            // Return a 1-based device number.
                  temp_counter = MAX_INSTANCE;                       // terminate for loop.
                } // osDeviceHandle matches
                else{
                  if(pOsHwInfo->osDeviceHandle == 0){
                    pOsHwInfo->osDeviceHandle = pcs->CRS.Client_EBX; // Set the os value to nvinfo
                    
                    if (pcs->CRS.Client_ECX != 0) {
                        // Make space for the device name string and copy it.
                        tmpPtr = _HeapAllocate(osStringLength((char *)pcs->CRS.Client_ECX), 0);
                        if (tmpPtr != 0) {
                           osStringCopy(tmpPtr, (char *)pcs->CRS.Client_ECX);
                           pOsHwInfo->osDeviceName = tmpPtr;
                        }
                    }

                    if (!pDev->DBfbInstBitmap)
                    {            
                        status = fbInitializeInstMemBitMap(pDev);
                        if (status)
                        {
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Cannot allocate InstMemBitMap!");
                            DBG_BREAKPOINT();
                        }
                    }

                    // Now that we have the osDeviceHandle for this device, 
                    // update the mode we are supposed to be in by reading the registry
                    osDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
                    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &osDisplayInfo, sizeof(DISPLAYINFO));
                    initFbEx(pDev);
                    
                    pcs->CRS.Client_EAX = temp_counter + 1;              // Return a 1-based device number.
                    temp_counter = MAX_INSTANCE;                         // terminate for loop.
                  } // osDeviceHandle == 0
                  else{
                    if(temp_counter == MAX_INSTANCE-1){
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Too many devices detected !");
                      DBG_BREAKPOINT();
                    }
                  } // osDeviceHandle is not zero
                } // osDeviceHandle is does not match
              } // loop for all devices
            }  
            break;
            
        case NVRM_API_DRIVER_DISCONNECT:
            {
                // Disconnect the device specified. Note that this is different than API_EXIT. 
                // All we do here is to undo what DRIVER_CONNECT did and throw away the instance memory
                // allocation. There should be no activity on this device. The driver calls this after
                // calling CONFIG_VGA to put the device in VGA mode. Also, this is never called for the
                // primary device.

                // don't do anything if the device is not disabled and in VGA mode.
                if (pDev->Vga.Enabled &&
                    pDev->DeviceDisabled)
                {
                    if(pOsHwInfo->osDeviceHandle != 0)
                    {
                        pOsHwInfo->osDeviceHandle = 0;
                        if (pOsHwInfo->osDeviceName != 0)
                        {
                            _HeapFree(pOsHwInfo->osDeviceName, 0);
                            pOsHwInfo->osDeviceName = NULL;
                        }
                
                        if (pDev->DBfbInstBitmap != 0)
                        {
                            osFreeMem(pDev->DBfbInstBitmap);
                            pDev->DBfbInstBitmap = 0;
                        }
                    } // osDeviceHandle is not 0
                } // device is in VGA and is disabled
            }
            break;
        case NVRM_API_DISPLAY:
            
            switch (pcs->CRS.Client_EBX)
            {
                
                case NVRM_API_DISPLAY_GET_MONITOR_TYPE:
                
                    data32 = GETDISPLAYTYPE(pDev, Head);
                    {
                        switch (data32)
                        {
                            case DISPLAY_TYPE_MONITOR:
                                SETMONITORTYPE(pDev, Head, MONITOR_TYPE_VGA);
                                break;
                            case DISPLAY_TYPE_TV:
                                switch (pDev->Dac.TVStandard)
                                {
                                    case NTSC_M:
                                    case NTSC_J:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_NTSC);
                                        break;
                                    case PAL_A:
                                    case PAL_M:
                                    case PAL_N:
                                    case PAL_NC:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_PAL);
                                        break;
                                }
                                break;
                            case DISPLAY_TYPE_FLAT_PANEL:        
                                SETMONITORTYPE(pDev, Head, MONITOR_TYPE_FLAT_PANEL);
                                break;
                            default:
                                // Set display type to the BIOS display type
                                switch (dacGetBiosDisplayType(pDev, Head))
                                {
                                    case DISPLAY_TYPE_MONITOR:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_VGA);
                                        break;
                                    case DISPLAY_TYPE_TV:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_NTSC);
                                        break;
                                    case DISPLAY_TYPE_FLAT_PANEL:
                                        SETMONITORTYPE(pDev, Head, MONITOR_TYPE_FLAT_PANEL);
                                        break;
                                }
                        }
                    }
                    pcs->CRS.Client_EAX = (U032)GETMONITORTYPE(pDev, Head);
                    // I'm tacking on this additional info for the mini-VDD. 
                    pcs->CRS.Client_EBX = (U032)pDev->Dac.DisplayChanged;
                    pDev->Dac.DisplayChanged = 0;
                    break;
                    
                case NVRM_API_DISPLAY_GET_DISPLAY_TYPE:
                    pcs->CRS.Client_EAX = GETDISPLAYTYPE(pDev, Head);
                    break;
                
                case NVRM_API_DISPLAY_SET_DISPLAY_TYPE:
                    SETDISPLAYTYPE(pDev, Head, pcs->CRS.Client_EBX);
                    break;
                
                case NVRM_API_DISPLAY_GET_FP_CONNECT_STATUS:
                    pcs->CRS.Client_EAX = dacFlatPanelConnectStatus(pDev, Head);
                    data32 = GETDISPLAYTYPE(pDev, Head);
                    if((data32==DISPLAY_TYPE_FLAT_PANEL)&&(!pcs->CRS.Client_EAX)){
                        if(dacMonitorConnectStatus(pDev, Head))
                            data32 = DISPLAY_TYPE_MONITOR;
                    }
                    SETDISPLAYTYPE(pDev, Head, data32);
                    break;
                
                case NVRM_API_DISPLAY_GET_FP_CONFIG:
                    pcs->CRS.Client_EAX = dacGetFlatPanelConfig(pDev, Head);
                    break;
                
                case NVRM_API_DISPLAY_SET_FP_CONFIG:
                    // KJK
                    // Need to revisit and add search for current dac object using this Head, then pass
                    // that object directly into this call.
                    // KJK 
                    // pcs->CRS.Client_EAX = dacSetFlatPanelMode(pDev, Head, pcs->CRS.Client_ECX, TRUE);
                    break;
                                
                //
                // Handle the incoming display change notifications from the 16bit driver
                //
                case NVRM_API_DISPLAY_CHANGE_CONFIG:
                    pcs->CRS.Client_EAX = dacSetSpanning(pDev, pcs->CRS.Client_ECX);
                    break;
                case NVRM_API_DISPLAY_CHANGE_START:
                    pcs->CRS.Client_EAX = dacSetModeStart(pDev, pcs->CRS.Client_ECX);
                    break;
                
                case NVRM_API_DISPLAY_CHANGE_END:
                    pcs->CRS.Client_EAX = dacSetModeEnd(pDev, pcs->CRS.Client_ECX);
                    break;

            }
                                    
            break;
        case NVRM_API_RM_TOKEN:
          switch(pcs->CRS.Client_EBX){
            case QUERY_TOKEN:
              pcs->CRS.Client_EAX = ResourceManagerGlobalToken;
              break;
            case RETURN_TOKEN:
              if(!ResourceManagerGlobalToken){
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: TOKEN ERROR ! TOKEN=0 on RETURN_TOKEN call\n\r");
                DBG_BREAKPOINT();
              }else
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: RELEASED THE TOKEN !\n\r");
                ResourceManagerGlobalToken = 0; 
              break;
            case AQUIRE_TOKEN:
              if(!ResourceManagerGlobalToken){
                ResourceManagerGlobalToken = 1; 
                pcs->CRS.Client_EAX = 1;
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: AQUIRED THE TOKEN !\n\r");
              }else{
                pcs->CRS.Client_EAX = 0;
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: WAITING FOR RM TOKEN ...\n\r");
              }
              break;
            default:
              DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: TOKEN ERROR ! Subfunction UNKOWN !\n\r");
              DBG_BREAKPOINT();
              break;
          }
          break;

        case NVRM_API_GET_DEVICE_TYPE:
            pcs->CRS.Client_EAX = REG_RD32(NV_PBUS_PCI_NV_0);
            break;
        case NVRM_API_REGISTER_DISPLAY_DRIVER:
            RegisterDisplayDriver(pcs);
            break;         

        case NVRM_REGISTRY_SET_STRING:
            {
              int  char_count,string_size;
              char stringt[128]=NV4_REG_RESOURCE_MANAGER_SUBKEY;

              osStringCopy(pDev->Registry.DBstrDevNodeDisplayNumber, (char *)pcs->CRS.Client_EBX);

              // Append the Resource Manager subkey string.("System")
              string_size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
              pDev->Registry.DBstrDevNodeDisplayNumber[string_size] = '\\';
              string_size++;
              for(char_count=string_size;char_count < (128-string_size);char_count++){
                pDev->Registry.DBstrDevNodeDisplayNumber[char_count]=stringt[char_count-string_size];
              }
              osStringCopy(pDev->Registry.DBstrDevNodeDisplay,pDev->Registry.DBstrDevNodeDisplayNumber);
            }
            break;

        case NVRM_API_DISPLAY_GET_BOOT_PHYS_MAP:
            pcs->CRS.Client_EAX = pDev->Dac.LogicalDeviceMap[pcs->CRS.Client_ECX];
            break;
                
        case NVRM_API_READ_EDID:
            {
                U008 lock;
                U008 failure;
                U032 dispType;
                U032 NVClktemp;

                if (pDev->Power.State != 0)
                {
                    // restore timer before attempting delay
                    REG_WR32(NV_PTIMER_NUMERATOR, pDev->Timer.Numerator);     
                    REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);     

                    // turn clocks up
                    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, pDev->Power.coeff_select);
                    if (pDev->Power.MobileOperation)
                    {
                        NVClktemp = pDev->Dac.HalInfo.NVClk;
                        pDev->Dac.HalInfo.NVClk = pDev->Power.PostNVCLK;
                    }

                    if (dacProgramNVClk(pDev) != RM_OK)
                    {
                        REG_WR32(NV_PRAMDAC_NVPLL_COEFF, pDev->Power.nvpll);         // nvclk
                    }

                    if (pDev->Power.MobileOperation)
                    {
                        pDev->Dac.HalInfo.NVClk = NVClktemp;
                    }

                    REG_WR32(NV_PRAMDAC_MPLL_COEFF, pDev->Power.mpll);           // mclk
                }

                // From parameter stack
                Head = pcs->CRS.Client_ECX;

                lock = UnlockCRTC(pDev, Head);

                 // Given a head number only, get the EDID for the attached device
                // This is called just after initDac().
                // We need to figure out the display type before we call EDIDRead().
                // We also need to call EDIDDetect to find out if there really is a display device attached,
                // since EDIDRead() will return RM_OK because it will get the BIOS default EDID.
                dispType = GETDISPLAYTYPE(pDev, Head);
                failure = 0;
                if (dispType == -1)
                {
                    dispType = DISPLAY_TYPE_FLAT_PANEL;
                    if (RM_OK != EDIDDetect(pDev, Head, dispType))
                    {
                        dispType = DISPLAY_TYPE_MONITOR;
                        if (RM_OK != EDIDDetect(pDev, Head, dispType))
                        {
                            failure = 1;
                        }
                    }
                }

                if (failure || RM_OK != EDIDRead(pDev, Head, dispType)) 
                {
                    pcs->CRS.Client_EAX = 0;
                } 
                else 
                {
                    // Copy the pointer to the edid buffer.
                    pcs->CRS.Client_EAX = (U032)pDev->Dac.CrtcInfo[Head].EDID;
                }

                RestoreLock(pDev, Head, lock);
            }
            break;
       
        case NVRM_API_GET_DDC_CAPS:
            // handle the VESA DDC Get Caps function (set bitmap of DDC addresses)
            pcs->CRS.Client_EBX = edidGetDDCCaps(pDev);
            pcs->CRS.Client_EAX = 0x004f;   // success
            break;
                
        case NVRM_API_SET_MONITOR_POWER:
            // In APM (dell data) it is common to get
            // monitor power on after we have entered power level 4
            // this will cause a bloom.  So we ignore power on/off calls
            // after the suspend
            if (pDev->Power.State == MC_POWER_LEVEL_4)
                 break;
            // Handle the ACPI monitor power state
            if (pcs->CRS.Client_ECX == 0)   // only on and off
            {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Turn On monitor power\n");

                if(pDev->Power.Flags & DAC_POWER_PENDING)
                {
                    //Reset global power_pending flag
                    pDev->Power.Flags &= ~DAC_POWER_PENDING;

                    // Bug 29711: if you hibernate on CRT, unplug CRT, boot back up
                    // on LCD, the LCD blooms. When we get to this function, we do
                    // a modeset on the CRT because the pVidLutCurDacs are setup for
                    // head A = CRT and head B = Nothing.  If we reset the chip in 
                    // mcPowerState, we turn off the flat panel clocks.  When we call 
                    // Wake Up in this function, the LCD turns on, but the clocks
                    // do not. This causes blooming.  
                    // So to fix this, if we've reset the chip, and we've boot to  
                    // an LCD, don't power on the panel!  The Reset flag is turned
                    // off at the end of dacSetFlatPanelMode in dacfp.c.
                    if(pDev->Dac.DevicesEnabled & DAC_PANEL_CLK_RESET)
                    {
                        if(pDev->Dac.BootDevicesBitMap & DAC_DD_MASK_IN_MAP)
                        {
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Set Monitor Power called after chip reset without panel clocks setup!\n");
                            break;
                        }
                    }

                    for(Head = 0; Head < MAX_CRTCS; Head++)
                    {
                        if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_NONE))
                        {
                            // Enable display
                            dacEnableDac(pDev, Head);

                            // also make sure the cursor image is updated
                            pDev->Dac.CrtcInfo[Head].UpdateFlags &= (~UPDATE_HWINFO_DAC_CURSOR_ENABLE);
                            pDev->Dac.CrtcInfo[Head].UpdateFlags |= (UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW |
                                                                  UPDATE_HWINFO_DAC_CURSOR_DISABLE);
                        }
                    }

                    //Toshiba specefic call (DPMS, hotkeys)
                    //Backlight enabled inside dacEnableDac for other mobiles
                    if (pDev->Power.MobileOperation == 2)
                    { 
                        U032    EAX, EBX, ECX, EDX;
                        EAX = 0x4F10;
                        EBX = 0x0001; //wake up
                        EDX = 0x0000;
                        ECX = 0x0000;
                        status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
                    }
                }
            }
            else
            {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Turn Off monitor power\n");

                if(!(pDev->Power.Flags & DAC_POWER_PENDING))
                {
                    // Turn off the backlight before disabling the DACs
                    if (pDev->Power.MobileOperation)
                    { 
                        if (pDev->Power.MobileOperation == 2)
                        {
                            //Toshiba specefic call (DPMS, hotkeys)
                            U032    EAX, EBX, ECX, EDX;
                            EAX = 0x4F10;
                            EBX = 0x0401; //sleep
                            EDX = 0x0000;
                            ECX = 0x0000;
                            status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
                        }
                    }

                    for(Head = 0; Head < MAX_CRTCS; Head++)
                    {
                        // if active display on Head?
                        if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_NONE)
                        {
                            dacDisableDac(pDev, Head);         // blank display
                        }
                    }

                    //Set global power_pending flag
                    //That means we would never touch neither power nor backlight
                    //on the flat panel until we would pass this case with power ON.
                    pDev->Power.Flags |= DAC_POWER_PENDING;
                }
            }

            break;
        
        case NVRM_API_BLANK_SECONDARY:
            {
                U032    PrimaryHead, i, CurrentDisplayType, CurHRes, CurVRes;
                PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
                U008 lock, Cr28, Cr33, Cr49;
                
                // Determine which head is the Primary device
                for (i = 0, PrimaryHead = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                {
                    if (pDev->Dac.CrtcInfo[i].PrimaryDevice == TRUE)
                    {
                        PrimaryHead = i;
                        break;
                    }
                }
                if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) 
                {

                    dacTV871Readback(pDev, 0, 0);  // set legacy readback mode
                    dacDisableTV(pDev, 0);
                }

                // Blank the secondary device. Also enable the BIOS's primary head and set up the display type
                if (pDev->Dac.CrtcInfo[PrimaryHead].pVidLutCurDac != NULL)
                {
                    if (pDev->Power.MobileOperation)    // mobile BIOS is multihead
                    {
                        // MOBILE
                        U008 Cr3B[2];
                        U032 SecondaryHead = PrimaryHead^1;
                        
                        // Read Head A CRTC regs
                        lock = UnlockCRTC(pDev, 0);
                        CRTC_RD(0x3B, Cr3B[0], 0);   // find out which displays are active
                        RestoreLock(pDev, 0, lock);
                        
                        // Read Head B CRTC regs
                        lock = UnlockCRTC(pDev, 1);
                        CRTC_RD(0x3B, Cr3B[1], 1);   // find out which displays are active
                        RestoreLock(pDev, 1, lock);
                        
                        // check to see if we need to disable second head
                        if (!pDev->Dac.BroadcastSupport)  // BIOS/chip revision does not support broadcast mode
                        {
                            dacDisableDac(pDev, SecondaryHead); // blank display on the other head
                    
                            // remove the displays from the secondary Cr3B registers
                            lock = UnlockCRTC(pDev, SecondaryHead);
                            CRTC_WR(0x3B, (Cr3B[SecondaryHead]&0x0F), SecondaryHead);
                            RestoreLock(pDev, SecondaryHead, lock);
                    
                            // Save off this information here for rmEnableHires
                            if(pDev->Dac.DeviceProperties.Spanning)
                            {
                                pDev->Dac.NonBroadcastModeStoredCr3B[0] = Cr3B[0]&0xF0;
                                pDev->Dac.NonBroadcastModeStoredCr3B[1] = Cr3B[1]&0xF0;
                            }
                        }
                        
                        // CRT and TV use Head A, DFP uses head B
                        EnableHead(pDev, PrimaryHead);  // leave pointing to the BIOS's primary head
                        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[PrimaryHead].pVidLutCurDac;
                        switch (pVidLutCurDac->DisplayType) 
                        {
                            case DISPLAY_TYPE_FLAT_PANEL:
                                AssocDDC(pDev, 1);  // uses PCRTC, no need to unlock ext CRTC
                                break;
                            case DISPLAY_TYPE_TV:
                            case DISPLAY_TYPE_MONITOR:
                            default:    
                                AssocDDC(pDev, 0);
                                AssocTV(pDev, 0);
                        }
                    }
                    else
                    {
                        // DESKTOP
                        EnableHead(pDev, 0);            // desktop BIOS is single head -- must use head A
                        
                        // Set Cr28 and Cr33 for the current display type
                        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[PrimaryHead].pVidLutCurDac;
                        
                        lock = UnlockCRTC(pDev, 0);
                        CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, 0);      // read pixel format
                        CRTC_RD(NV_CIO_CRE_LCD__INDEX, Cr33, 0);
                        switch (pVidLutCurDac->DisplayType) 
                        {
                            case DISPLAY_TYPE_MONITOR:
                                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 & ~0x80, 0);
                                CRTC_WR(NV_CIO_CRE_LCD__INDEX, Cr33 & ~0x13, 0);
                                break;                                
                            case DISPLAY_TYPE_TV:
                                if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) 
                                {
                                    // Set 640x480 encoder resolution. The BIOS uses discrete register programming and will be unable 
                                    // to deal with higher resolutions set by the RM using Autoconfig (there must be registers 
                                    // programmed in Autoconfig which the BIOS does not touch).
                                    CurHRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                                    CurVRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                                    pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;      // set object's res
                                    pDev->Framebuffer.HalInfo.VertDisplayWidth = 480;
                                    dacProgramBrooktreeAuto(pDev, 0);                   // do the Autoconfig modeset
                                    pDev->Framebuffer.HalInfo.HorizDisplayWidth = CurHRes;  // restore desktop res
                                    pDev->Framebuffer.HalInfo.VertDisplayWidth = CurVRes;
                                }
                                
                                // provide a clock before slaving the CRTC
                                CRTC_RD(NV_CIO_CRE_ENGINE_CTRL, Cr49, 0);      
                                CRTC_WR(NV_CIO_CRE_ENGINE_CTRL, Cr49 | 0x14, 0); // Head A owns TV + I2C      
                                        
                                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 | 0x80, 0);
                                CRTC_WR(NV_CIO_CRE_LCD__INDEX, Cr33 & ~0x13, 0);
                                break;                                
                            case DISPLAY_TYPE_FLAT_PANEL:
                                // Head A should own I2C
                                CRTC_RD(NV_CIO_CRE_ENGINE_CTRL, Cr49, 0);      
                                CRTC_WR(NV_CIO_CRE_ENGINE_CTRL, Cr49 | 0x04, 0); // Head A owns I2C      
                                // Put valid timings into PRAMDAC_FP so we have a good clock
                                CurrentDisplayType = GETDISPLAYTYPE(pDev, 0);
                                SETDISPLAYTYPE(pDev, 0, DISPLAY_TYPE_FLAT_PANEL); // make sure display type is correct
                                dacSetFlatPanelMode(pDev, 0, pVidLutCurDac, NV_CFGEX_GET_FLATPANEL_INFO_SCALED, FALSE);
                                SETDISPLAYTYPE(pDev, 0, CurrentDisplayType);      // restore type for RM
                                // slave the CRTC to FP
                                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 | 0x80, 0);
                                CRTC_WR(NV_CIO_CRE_LCD__INDEX, Cr33 | 0x13, 0);
                               
                                break;                                
                        }
                        RestoreLock(pDev, 0, lock);
                    }
                }
            }
            break;

        default:
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Unknown user API = ", (DWORD)pcs->CRS.Client_EAX);
            DBG_BREAKPOINT();
            break;
    }

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: User Service to Resource Manager complete\n\r");
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\OS.C ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.C                                                              *
*   This is the OS interface module.  All operating system transactions     *
*   pass through these routines.  No other operating system specific code   *
*   or data should exist in the source.                                     *
*                                                                           *
\***************************************************************************/
//
// Another great undocumented feature of windows.  You must including these
// defines to be able to include configmg.h
//
#define CAT_HELPER(x, y)    x##y
#define CAT(x, y)       CAT_HELPER(x, y)
#define MAKE_HEADER(RetType, DecType, Function, Parameters)

#include "basedef.h"
#include "vmm.h"
#include "vmmreg.h"
#include "vpicd.h"
#include "configmg.h"
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <mc.h>
#include <os.h>
#include <vga.h>
#include <tv.h>
#include <dac.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vdd.h"
#include "vmmtypes.h"
#include "vmm2.h"       // more vmm services
#include "nvwin32.h"
#include "nvos.h"
#include "vesadata.h"
#include "nvcm.h"
#include "edid.h"

#ifdef DEBUG
#include <vcomm.h>
#include "osdbg.h"
#include "serial.h"
#endif

#ifdef DEBUG
U032 thread_watcher;
#endif

//
// OS names.
//
char nameVideoSink[]        = "CON:";
char nameImageVideo[]       = "WND";
char nameLeft[]             = "\\LEFT";
char nameRight[]            = "\\RIGHT";
char nameSysMem[]           = "SYSMEM:";
char nameLVidMem[]          = "LOCALVIDMEM:";
char nameSVidMem[]          = "NONLOCALVIDMEM:";

//
// Define registry keys for timing parameters.
//
#ifdef OBSOLETE_FUNCTIONS
char strTimingParm0[]    = "TimingParm0";
char strTimingParm1[]    = "TimingParm1";
char strTimingChecksum[] = "TimingChecksum";
char strPBUSOverride[]   = "PBUSOverride";
char strUnderscanXOverride[]  = "UnderscanX";
char strUnderscanYOverride[]  = "UnderscanY";
#endif // OBSOLETE_FUNCTIONS
char strRefreshOverride[] = "RefreshOverride";
char strTilingOverride[] = "TilingOverride";
char strMemoryOverride[] = "MemoryOverride";
char strRTLOverride[]    = "RTLOverride";
char strFetchTriggerOverride[] = "FetchTrigger";
char strFetchSizeOverride[]    = "FetchSize";
char strFetchMaxReqsOverride[] = "FetchMaxReqs";
char strGraphicsDebug0[]        = "GRDEBUG0";
char strGraphicsDebug1[]        = "GRDEBUG1";
char strGraphicsDebug2[]        = "GRDEBUG2";
char strGraphicsDebug3[]        = "GRDEBUG3";

extern char strDevNodeRM[];
extern char strMaxRefreshRate[];
extern char strMaxOptimalRefreshRate[];
extern char strOptimalNotFromEDID[];
extern char strDMTOverride[];
extern char strMonitorTiming[];
extern char strCursorCacheOverride[];
extern char strDisplayType[];
extern char strDisplay2Type[];
extern char strTVtype[];
extern char strStartUp[];
extern char strTVOutType[];
extern char strNewModeSet[];
extern char strFpMode[];


#ifdef ON_NOW
extern U008 PowerOff;
#endif
//
// Service stack.
//
U032 *rmStack;
U032 *rmStackBase;
U032 vmmStack;
U032 tempStack;
//
// Hack
//
static U008 NopMask;


#ifdef DEBUG_TIMING

#define DEBUG_FRAMES 16

U032 dbgFrame ;
U032 dbgStart ;
U032 dbgStartInt[DEBUG_FRAMES][20];
U032 dbgEndInt[DEBUG_FRAMES][20];
U032 dbgCountInt[DEBUG_FRAMES];
#endif // DEBUG_TIMING

//
// Some quick and dirty library functions.
// This is an OS function because some operating systems supply their
// own version of this function that they require you to use instead
// of the C library function.  And some OS code developers may decide to
// use the actual C library function instead of this code.  In this case,
// just replace the code within osStringCopy with a call to the C library
// function strcpy.
//
char *osStringCopy
(
    char *dst,
    const char *src
)
{
    char *dstptr = dst;
    
    while (*dstptr++ = *src++);
    return (dst);
}

U032 osStringLength(const char * str)
{
    U032 i = 0;
    while (str[i++] != '\0');
    return i - 1;
}

S032 osStringCompare
(
    const char *s1,
    const char *s2
)
{
    while (*s1 && *s2)
    {
        if (*s1++ != *s2++)
            return (0);
    }
    return (!(*s1 || *s2));
}

/*****************************************************************************
 * fastish memcopy code - begin
 *
 *  osMemCopy 
 *   - optimal performance will have src and dst 4-byte aligned
 *   - the compiler does not even TRY to optimize this code... bad switch?
 */
void __declspec(naked) __stdcall __osMemCopy4
(
    U032 dst,
    U032 src,
    U032 len4   // u032 count
)
{
/*
    while (len4)
    {
        *(U032*)dst = *(U032*)src;
        src  += 4;
        dst  += 4;
        len4 -= 4;
    }
*/
    __asm
    {
        push esi
        push edi

        mov ecx,[esp + 20]
        mov esi,[esp + 16]
        shr ecx,2
        mov edi,[esp + 12]

        rep movsd

        pop edi
        pop esi
        ret 12
    }
}

void __declspec(naked) __stdcall  __osMemCopy1
(
    U032 dst,
    U032 src,
    U032 len    // u008 count
)
{
/*
    while (len)
    {
        *(U008*)dst = *(U008*)src;
        src ++;
        dst ++;
        len --;
    }
*/
    __asm
    {
        push esi
        push edi

        mov ecx,[esp + 20]
        mov esi,[esp + 16]
        mov edi,[esp + 12]

        rep movsb

        pop edi
        pop esi
        ret 12
    }
}

unsigned char * osMemCopy
(
          unsigned char *dst,
    const unsigned char *src,
          U032           len    // u008 count
)
{
    if (len >= 16)
    {
        __osMemCopy4 ((U032)dst,(U032)src,len & ~3);
        src += len & ~3;
        dst += len & ~3;
        __osMemCopy1 ((U032)dst,(U032)src,len &  3);
    }
    else
    {
        __osMemCopy1 ((U032)dst,(U032)src,len);
    }

    return dst;
}
/*
 * fastish memcopy code - end
 *****************************************************************************/

RM_STATUS osReleaseFifoSemaphore()
{
    return RM_OK;
}

RM_STATUS osRequestFifoSemaphore()
{
    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Operating System Memory functions.
//
//---------------------------------------------------------------------------

#ifdef OBSOLETE_FUNCTIONS
U032 osSetContext
(
    U032 ProcContext
)
{
    U032 CurrContext;

    CurrContext = (U032)vmmGetCurrentContext();
    if ((ProcContext) && (CurrContext != ProcContext))
    {
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "osSetContext: Current Context  = ",CurrContext);
        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "              Process Context  = ",ProcContext);
        return ((U032)vmmContextSwitch((DWORD) ProcContext));
    }
    //
    // No context switch required.
    //    
    return (0);
}
RM_STATUS osResetContext
(
    U032 OriginalContext
)
{
    if (OriginalContext)
        vmmContextSwitch((DWORD) OriginalContext);
    return (RM_OK);
}
#endif // OBSOLETE_FUNCTIONS

RM_STATUS  osCopyIn
(
	U008 *src, 
	U008 *target,
	U032 count
)
{
	//*target = src;

	osMemCopy(target, src, count);

	return(RM_OK);
}

RM_STATUS  osCopyOut
(
	U008 *src,
	U008 *target,
	U032 count
)
{
	osMemCopy(target, src, count);

	return(RM_OK);
}

RM_STATUS osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    RM_STATUS status = RM_OK;

#ifdef DEBUG
    U008     *pMem;
#endif // DEBUG

#ifndef DEBUG
//    *pAddress = vmmHeapAllocate(Size + 4, 0);
    *pAddress = _HeapAllocate(Size + 4, 0);
    if (*pAddress != NULL)
    {
        **(U032 **)pAddress           = Size;
        *(U032 *)pAddress            += 4;
#else
    Size += 12;
//    *pAddress = vmmHeapAllocate(Size, 0);
    *pAddress = _HeapAllocate(Size + 4, 0);
    if (*pAddress != NULL)
    {
        **(U032 **)pAddress                     = Size;
        *(U032 *)(*(U032 *)pAddress + 4)        = NV_MARKER1;
        *(U032 *)(*(U032 *)pAddress + Size - 4) = NV_MARKER2;
        *(U032 *)pAddress += 8;
        pMem = (U008 *)*pAddress;
        Size -= 12;
        while (Size--)
            *pMem++ = 0x69;
#endif // DEBUG
    }
    else
    {
        status = RM_ERR_NO_FREE_MEM;
    }
    return (status);
}
RM_STATUS osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status;
    U032      Size;
    
    if(!pAddress)
    {
#ifdef DEBUG
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error: Null pointer called to osFreeMem.\n\r");
#endif // DEBUG    
        return (RM_OK);
    }    
    
#ifndef DEBUG
    pAddress = (VOID *)((U032)pAddress - 4);
    Size     = *(U032 *)pAddress;
#else
    pAddress = (VOID *)((U032)pAddress - 8);
    Size     = *(U032 *)pAddress;
    if (*(U032 *)((U032)pAddress + 4) != NV_MARKER1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Invalid address to osFreeMem.\n\r");
        DBG_BREAKPOINT();
    }
    if (*(U032 *)((U032)pAddress + Size - 4) != NV_MARKER2)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Memory overrun in structure to osFreeMem.\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_MEM_NOT_FREED);
    }
    *(U032 *)((U032)pAddress + 4)        = 'DAED';
    *(U032 *)((U032)pAddress + Size - 4) = 'DEAD';
    Size -= 12;
#endif // DEBUG    
//    if (vmmHeapFree((BYTE *)pAddress, 0) == 0)
    if (_HeapFree((BYTE *)pAddress, 0) == 0)
      {
        status = RM_ERR_MEM_NOT_FREED;
    }
    else
    {
        status = RM_OK;
    }
    return (status);
}

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32

#define AGP_APERTURE_SIZE               0x2000000       // 32 MB

//
// osUpdateAGPLimit - determine the write-combined AGP limit
//
// This routine is now called not only at boot time, but anytime a client
// does a ConfigGet for the AGP limit, in case it's changed.
//
RM_STATUS osUpdateAGPLimit
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    U032 AGPBase, AGPLimit;
    U032 i, mtrrAddr, numRanges = 0;
    U032 BaseHi, BaseLo, MaskHi, MaskLo;
    RM_STATUS status;
        
    // If the aperture limit/size was established at boot time, just return
    if (pRmInfo->AGP.AGPLimit != 0)
        return RM_OK;

    CLI
    // Get the AGP base and limit from the chipset
    status = NvGetAGPBaseLimit(pDev, &AGPBase, &AGPLimit);
    STI

    if (status != RM_OK)
    {
        pRmInfo->AGP.AGPLimit = AGP_APERTURE_SIZE - 1;     // set to 32MB, by default
        return status;
    }

    // First, check if this processor supports the CPUID inst and MTRRs.
    __asm
    {
        ; save state
        push	eax
        push	ebx
        push	ecx
        push	edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, 254            // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        test    eax, 0x400          // check that WC as a type is supported (should be 1).
        jz      Exit

        and     eax, 0xFF           // save number of ranges
        mov     numRanges, eax
Exit:    
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }

    if (!numRanges)
    {
        pRmInfo->AGP.AGPLimit = AGPLimit;   // default to the aperture limit
        return RM_ERROR;
    }

    //
    // Now, determine if we find a Write Combined match in the MTRRs. We want
    // the AGP limit to only reflect the WC portion of the AGP aperture.
    //
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Valid MTRRs:\n");
    for (i = 0, mtrrAddr = 512; i < numRanges; i++, mtrrAddr += 2)
    {
        __asm {

            push    eax
            push    ebx
            push    ecx
            push    edx

            mov     ecx, mtrrAddr
            RDMSR

            mov     BaseHi, edx
            mov     BaseLo, eax

            mov     ecx, mtrrAddr
            add     ecx, 1
            RDMSR

            mov     MaskHi, edx
            mov     MaskLo, eax

            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }

        if (!(MaskLo & 0x800))
            continue;               // not a valid range

        MaskLo &= ~0xFFF;           // mask off the valid bit

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Range ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:      Base ", BaseLo);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    Length ", ~MaskLo + 1);

        // We only care about a Write-Combined range
        if ((BaseLo & 0xFF) != 0x1)
            continue;

        BaseLo &= ~0xFF;           // mask off the type bits

        if ((BaseLo >= AGPBase) && ((BaseLo + ~MaskLo) <= (AGPBase + AGPLimit)))
            pRmInfo->AGP.AGPLimit = ~MaskLo;  // the WC MTRR is within the aperture
    }

    return RM_OK;
}

//
// osAllocPages - Allocate a number of aligned memory pages
//  
//  **pAddress - handle to the linear address
//  PageCount  - number of pages to allocate
//  MemoryType - memory pool
//  Contiguous - contiguous pages?
//  Cache      - cacheing request
//  clientClass- is this a kernel/user allocation??
//  **pMemData - any per-allocation data (useful during a free)
//
RM_STATUS osAllocPages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    PageCount,
    U032    MemoryType,
    U032    Contiguous,
    U032    Cache,
    U032    clientClass,
    VOID    **pMemData
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    RM_STATUS       status;
    DESCRIPTOR      desc;

    status = RM_OK;
    *pMemData = NULL;   // no associated per-alloc data
    
    switch (MemoryType)
    {
    
        case NV_MEMORY_TYPE_SYSTEM:
        
            //
            // Perform VMM page allocation.  System memory arena, system VM, no alignment
            // restrictions, no min/max phys restrictions, no need for the physical address
            // (no fixed request), and no need for contiguous or fixed flags
            //
            if (Contiguous == NV_MEMORY_NONCONTIGUOUS)
            {            
                vmmGetCritSectionStatus();      // complete delayed releases of critical section
                                                // is this really necessary in Win 95?
            
                vmmPageAllocate(PageCount, PG_SYS, 0, 0, 0, 0, 0, 0, &desc.Desc64);
                *pAddress = (VOID *)desc.Desc32[0];
                
                /* MTRR work
                if (Cache == NV_MEMORY_WRITECOMBINED)
                ...
                */
            }                
            else
            {
                *pAddress = NULL;
                status = RM_ERROR;
            }                
            
            break;
            
        case NV_MEMORY_TYPE_AGP:
            
            if ((pDev->Chip.Bus == BUS_AGP) && pRmInfo->AGP.AGPLimit && pRmInfo->AGP.AGPPhysStart &&
                 (pDev->Chip.ReqAGPRate != 0))
            {
                // Need to verify availability of VM services for AGP
                if (Get_VMM_Version() < 0x40A)
                {
                    *pAddress = NULL;
                    return RM_ERROR;
                }                    
                
                //
                // Perform VGARTD (VMM) AGP page reservation.  This device, no alignment
                // restrictions, custom cacheing
                //
                if (Cache == NV_MEMORY_UNCACHED)                    
                    *pAddress = (VOID *)vmmGARTReserve(pDev->Mapping.hDev, PageCount, 0, 0, PG_UNCACHED);
                else if (Cache == NV_MEMORY_WRITECOMBINED) {
                    *pAddress = (VOID *)vmmGARTReserve(pDev->Mapping.hDev, PageCount, 0, 0, PG_WRITECOMBINED);
                } else {
                    *pAddress = NULL;       // unknown Cache type
                    status = RM_ERROR;
                }

                if (*pAddress)
                {
                    // Perform VGARTD (VMM) AGP page commit.  No page offset, no init value
                    if (!vmmGARTCommit((U032)*pAddress, 0, PageCount, 0, 0))
                    {
                        // oops, that didn't work...
                        status = RM_ERROR;
                        vmmGARTFree((U032)*pAddress);
                    } else {
                        U032 i, *bufp = (U032 *)*pAddress;

                        // let's be considerate and zero the just allocated memory
                        for (i = 0; i < ((PageCount * RM_PAGE_SIZE) / sizeof(U032)); i++)
                            *bufp++ = 0x0;

                        // update our notion of how much persistent AGP has been alloced
                        if (Cache == NV_MEMORY_WRITECOMBINED)
                            pRmInfo->AGP.AGPHeapFree += (PageCount << RM_PAGE_SHIFT);
                    }
                }
                else
                {
                    // Out of memory. For persistent AGP allocs, this can happen when not enough was
                    // taken out of DDraw's pool. Just return error status (*pAddress is already NULL).
                    status = RM_ERR_NO_FREE_MEM;
                }
            }
            else
            {
                *pAddress = NULL;
                status = RM_ERROR;
            }
            
            break;
            
    }
    
    return (status);
}

//
// osFreePages - Free a number of aligned memory pages
//  
//  **pAddress - handle to the linear address
//  MemoryType - memory pool
//
RM_STATUS osFreePages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    MemoryType,
    U032    PageCount,
    VOID    *pMemData,
    BOOL    IsWriteCombined
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    RM_STATUS   status = RM_OK;
    
    switch (MemoryType)
    {
    
        case NV_MEMORY_TYPE_SYSTEM:
        
            //
            // Perform VMM page free.
            //
            vmmGetCritSectionStatus();
            //
            // KJK: Not really necessary to unlock before free
            //
            //PageCount = vmmPageGetSizeAddr(*pAddress, 0, &desc.Desc64);
            //vmmPageUnLock(*pAddress,
            //              desc.Desc32[0],
            //              0,
            //              0);
            if (!vmmPageFree((U032)*pAddress, 0))
                status = RM_ERROR;
            
            break;
            
        case NV_MEMORY_TYPE_AGP:

            if ((pDev->Chip.Bus == BUS_AGP) && (pDev->Chip.ReqAGPRate != 0))
            {
                //
                // Not sure if the Free below covers both the underlying pages and the
                // aperture addresses, so to be sure, we'll uncommit the pages and free.
                //
                vmmGARTUnCommit((U032)*pAddress, 0, PageCount);

                //
                // Perform VGARTD (VMM) AGP page free.
                //
                vmmGARTFree((U032)*pAddress);                   // for uncached AGP, free it all

                if (IsWriteCombined)
                {
                    // update our notion of how much persistent AGP has been alloced
                    pRmInfo->AGP.AGPHeapFree -= (PageCount << RM_PAGE_SHIFT);
                }
            }
            else
            {
                status = RM_ERROR;
            }
            
            break;
    }
    
    return (status);
}

// Translate a Virtual to Physical addr (used to provide the AGP aperture offset)
RM_STATUS osVirtualToPhysicalAddr
(
    VOID* virtaddr,
    VOID** physaddr
)
{
    U032 PageBase = (U032)virtaddr >> PAGESHIFT;
    U032 BaseAddr;

    // check that we've got a page (only need to succeed for one page translate the base)
    if (vmmPageCheckLinRange(PageBase, 1, 0) != 1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Linear range not valid.\n\r");
        DBG_BREAKPOINT();
        return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
    }

    // Get the first entry.
    if (!vmmCopyPageTable(PageBase, 1, (U032)&BaseAddr, 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy page table.\n\r");
        return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
    }

    (U032)*physaddr = (BaseAddr & ~RM_PAGE_MASK) | ((U032)virtaddr & RM_PAGE_MASK);
    return RM_OK;
}

RM_STATUS osCalculatePteAdjust
(
    PHWINFO pDev,
    U032    AddressSpace,
    VOID*   Address,
    U032 *  pPteAdjust
)
{
    *pPteAdjust = (U032)Address & RM_PAGE_MASK;

    return RM_OK;
}

// Get address information from the selector:offset address combination
RM_STATUS osGetAddressInfo
(
    PHWINFO pDev,
    U032  ChID,
    U032  Selector,
    VOID** pOffset,
    U032  Length,
    VOID** pAddress,
    NV_ADDRESS_SPACE *pAddressSpace
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    DESCRIPTOR  desc;
    U032        SelectorBase, SelectorLimit;
    U032        LinAddr, PageBase, PageArray;

#ifdef DEBUG
    U032        Page;
#endif // DEBUG

    // Default set the address type to system. 
    *pAddressSpace = ADDR_SYSMEM;

    vmmGetDescriptor(Selector, vmmGetSysVMHandle(), 0, &desc.Desc64);
    if ((desc.Desc32[0] == 0) && (desc.Desc32[1] == 0))       
    {
        return (RM_ERR_BAD_ADDRESS);
    }
    SelectorBase = ((U032)desc.Desc16[1]) |
                   ((U032)desc.Desc8[4] << 16) |
                   ((U032)desc.Desc8[7] << 24);
    SelectorLimit    = ((U032)desc.Desc16[0]) |
                       ((U032)(desc.Desc8[6] & 0x0F) << 16);
    if (desc.Desc8[6] & D_GRAN_PAGE)
    {
        //
        // Page granularity.
        //
        SelectorLimit = (SelectorLimit << 12) | 0x0FFF;
    }
    //
    // Gotta check all them bits for WIN95!!!
    //
    if (desc.Desc8[5] & D_ED)
    {
        //
        // Expand Down Segment.
        //
        // Check the "B" bit to determine maximum offset.
        //
        if (desc.Desc8[6] & D_DEF32)
            SelectorLimit = 0xFFFFFFFF;
        else
            SelectorLimit = 0x0000FFFF;
    }

    // Check to see if we have an address space conflict
    if ((*pAddressSpace != ADDR_UNKNOWN) && (*pAddressSpace != ADDR_SYSMEM) && (*pAddressSpace != ADDR_AGPMEM) && (*pAddressSpace != ADDR_FBMEM)) {
       return(RM_ERR_BAD_ADDRESS);
    }
    // Check to see if the transfer is in bounds
    if (((U032)*pOffset + Length) > SelectorLimit) {
       return(RM_ERR_BAD_ADDRESS);
    }

    // The address space is always system memory
    //KJK *pAddressSpace = ADDR_SYSMEM;
    // The returned address is the selector base + selector offset
    (U032)*pAddress = SelectorBase + (U032)*pOffset;

    //
    // We need to see if the address space matches any of our known ranges, such
    // as the framebuffer.  Override the memory type as necessary.  In most cases
    // this is done by the app when it names the context instance, but sometimes
    // he might not.
    //
    // For now, only check the framebuffer.  Need to add AGP GART aperture.
    //
    if (*pAddressSpace == ADDR_AGPMEM)
    {    
       return(RM_OK);
    }       
    
    //
    // Create the linear address of the buffer.
    //
    LinAddr = vmmSelectorMapFlat(vmmGetSysVMHandle(), Selector, 0) + (U032)*pOffset;
    //
    // Create the page base
    //
    PageBase = LinAddr >> PAGESHIFT;
    //
    // Linear Address is already in the shared or system memory arena.
    // Lock memory as was done under Win31...no need to change
    // memory contexts
    //
    if (vmmPageCheckLinRange(PageBase, 1, 0) != 1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Linear page not valid.\n\r");
        //DBG_BREAKPOINT();
        return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
    }
    //
    // Grab the first page and see if it falls within our known range
    //
    if (!vmmLinPageLock(PageBase, 1, 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to lock detection page.\n\r");
        //return (RM_ERR_DMA_MEM_NOT_LOCKED);
        return (RM_OK);     // not fatal
    }
    if (!vmmCopyPageTable(PageBase, 1, (U032)&PageArray, 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy detection page table.\n\r");
        //return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        return (RM_OK);     // not fatal
    }
    if (!(PageArray & P_PRES))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Unable to lock page :LinAddr = ", (PageBase + Page) << 12);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                          :PTE     = ", PageArray);
        //DBG_BREAKPOINT();
        //return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        return (RM_OK);     // not fatal
    }
    if (!vmmLinPageUnLock(PageBase, 1, 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to unlock detection page.\n\r");
        //return (RM_ERR_DMA_MEM_NOT_LOCKED);
        return (RM_OK);     // not fatal
    }
    //
    // 4k page alignment
    //
    PageArray &= 0xFFFFF000;    
    //
    // If we're in FB space, we need to change the dma pte over to PNVM rather than PCI/AGP
    //
    if ((PageArray >= pDev->Mapping.PhysFbAddr) && (PageArray < (pDev->Mapping.PhysFbAddr + pDev->Framebuffer.HalInfo.RamSize)))
    {
        if ((PageArray+Length) >= (pDev->Mapping.PhysFbAddr + pDev->Framebuffer.HalInfo.RamSize))
        {
            //
            // We're straddling fb mem...bomb.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses fbmem boundary ", PageArray);
            DBG_BREAKPOINT();
            return (RM_ERR_MULTIPLE_MEMORY_TYPES);
        }

        //
        // Subtract off the start of the framebuffer
        //
        (U032)*pAddress = (U032)*pOffset = (PageArray - pDev->Mapping.PhysFbAddr) + 
                               (LinAddr  & RM_PAGE_MASK); // The offset within a page            
        //
        // Turn this into a PNVM dma structure
        //
        *pAddressSpace = ADDR_FBMEM;  
    }
    
    //
    // If we're in AGP space, we need to change the dma pte over to AGP rather than PCI
    //
    if ((pDev->Chip.Bus == BUS_AGP) && (pRmInfo->AGP.AGPLimit) && (pRmInfo->AGP.AGPPhysStart) &&
        (pDev->Chip.ReqAGPRate != 0))
    {
        if ((PageArray >= pRmInfo->AGP.AGPPhysStart) && (PageArray < (pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit)))
        {
            if ((PageArray+Length) > (pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit))
            {
                //
                // We're straddling agp mem...bomb.
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses agp aperture boundary ", PageArray);
                DBG_BREAKPOINT();
                return (RM_ERR_MULTIPLE_MEMORY_TYPES);
            }

            //
            // Turn this into an AGP dma structure
            //
            *pAddressSpace = ADDR_AGPMEM;
        }
    }
    
    return (RM_OK);
}

RM_STATUS osLockUserMem
(
    PHWINFO          pDev, 
    U032             ChID,
    U032             Selector,
    VOID*            Offset,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE *DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    U032            *PageArray,
    VOID**           pLinAddr,
    VOID**           LockHandle
)
{
    U032 LinAddr;
    U032 PageBase;
    U032 Page;
    U032 temp;
    
    
    //
    // If we're asking to lock video memory, let's just build up the PTE's and assume
    // that the caller has real control over video memory (such as DirectDraw or the
    // display driver).
    //
    if (*DmaAddressSpace == ADDR_FBMEM)
    {
        
        LinAddr = (U032)*pLinAddr = (U032)*LockHandle = (U032)Offset;   // 0-based selector!!

        //
        // Should probably make sure the start+limit are within the available
        // video memory!!
        //
        
        //
        // This is hardcoded assuming zero = start of fb
        //
        PageBase = LinAddr >> PAGESHIFT;
        for (Page = 0; Page < PageCount; Page++)  {
            PageArray[Page] = ((PageBase + Page)<<12) | 3;
        }
        
        return (RM_OK);
    }

    //
    // Map the buffer.
    //
    LinAddr = (U032)*pLinAddr = vmmSelectorMapFlat(vmmGetSysVMHandle(), Selector, 0) + (U032)Offset;
    //
    // Validate the parameters.
    //
    PageBase = LinAddr >> PAGESHIFT;
    //
    // Use original linear address as the lock handle.
    //
    (U032)*LockHandle = (U032)*pLinAddr;

    if (*DmaAddressSpace == ADDR_AGPMEM)
    {
        U032 AGPBaseAddr;

        //
        // For AGP, just xlate the first page and derive the remaining pages knowing
        // this memory appears linear to the processor/bus master.
        //
        // Avoiding probing invalid GART entries fixes a problem seen on Compaq Aspen
        // systems (AMD 751/Via combo chipset). This occurs when OGL allocs a 16MB AGP
        // texture context DMA that's larger than what's been allocated so far.
        //

        // Get the first entry.
        if (!vmmCopyPageTable(PageBase, 1, (U032)&AGPBaseAddr, 0))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy page table.\n\r");
            return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        }

        // Fill in the rest of the entries (though instmem only needs one entry).
        for (Page = 0; Page < PageCount; Page++)
        {
            PageArray[Page] = (AGPBaseAddr + (Page << RM_PAGE_SHIFT)) | 3;
        }

        return (RM_OK);
    }

    if (((LinAddr >= MINSHAREDLADDR) && (LinAddr <= MAXSHAREDLADDR)) ||
        ((LinAddr >= MINSYSTEMLADDR) && (LinAddr <= MAXSYSTEMLADDR)))
    {   
        //
        // Linear Address is already in the shared or system memory arena.
        // Lock memory as was done under Win31...no need to change
        // memory contexts
        //
        if (vmmPageCheckLinRange(PageBase, PageCount, 0) != PageCount)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Linear range not valid.\n\r");
            DBG_BREAKPOINT();
            return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        }
        //
        // Scatter/gather lock the pages.
        //
        for (Page = 0; Page < PageCount; Page++)
        {
            //
            // Touch page to make sure it is in memory.  Win32s doesn't like
            // to play nicely with the VMMs memory manager.
            //
            NopMask |= *(volatile U008 *)LinAddr;
            LinAddr += PAGESIZE;
            //
            // If this is a standard AGP memory context (not an NV AGP context),
            // there is no need to relock the memory.  DirectDraw has already done
            // it for us, so we can just peer at the PTEs.
            //
            if (*DmaAddressSpace != ADDR_AGPMEM)
                if (!vmmLinPageLock(PageBase + Page, 1, 0))
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to lock pages.\n\r");
                    return (RM_ERR_DMA_MEM_NOT_LOCKED);
                }
            if (!vmmCopyPageTable(PageBase + Page, 1, (U032)&PageArray[Page], 0))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy page table.\n\r");
                return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
            }
            if (!(PageArray[Page] & P_PRES))
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Unable to lock page :LinAddr = ", (PageBase + Page) << 12);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                          :PTE     = ", PageArray[Page]);
                DBG_BREAKPOINT();
                return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
            }
        }
    }
    else
    {
        //
        // Linear Address is in the private memory arena.
        // Lock memory and map linear address the the system memory arena.
        // Memory Context switch may be required.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "osLockUserMem: Original Linear Address = ",(U032)*pLinAddr);
        temp = vmmPageCheckLinRange(PageBase, PageCount, 0);
        if (temp != PageCount)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "NVRM:Linear range not valid.\n\r");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "Page Base            = ", PageBase);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "Requested Page Count = ", PageCount);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "Actual Page Count    = ", temp);
            DBG_BREAKPOINT();
            return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        }
        for (Page = 0; Page < PageCount; Page++)
        {
            //
            // Touch page to make sure it is in memory.  Win32s doesn't like
            // to play nicely with the VMMs memory manager.
            //
            NopMask |= *(volatile U008 *)LinAddr;
            LinAddr += PAGESIZE;
        }
        //
        // Lock all pages at once and map to system memory arena.
        //
        if (*DmaAddressSpace != ADDR_AGPMEM)
            LinAddr = (U032)vmmLinPageLock(PageBase, PageCount, PAGEMAPGLOBAL);
        else    
            LinAddr = (U032)*pLinAddr;    // agp doesn't need a lock, so restore the original linaddr            
        if (!LinAddr)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to lock pages.\n\r");
            return (RM_ERR_DMA_MEM_NOT_LOCKED);
        }
        if (!vmmCopyPageTable(LinAddr >> PAGESHIFT, PageCount, (U032)&PageArray[0], 0))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM:Unable to copy page table.\n\r");
            return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
        }
        LinAddr += ((U032)*pLinAddr & 0xFFF);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               New Linear Address      = ",LinAddr);
        (U032)*pLinAddr = LinAddr;
    }
    return (RM_OK);    
}
RM_STATUS osUnlockUserMem
(
    PHWINFO          pDev, 
    U032             ChID,
    VOID*            LinAddr,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    VOID*            LockHandle,
    U032             DirtyFlag
)
{
    RM_STATUS status;
    U032      PageBase;
    U032      Page;
    U032      UnlockFlags;

    //
    // If we're asking to unlock video memory, we're assuming the caller (probably
    // direct draw)  has complete control of video memory, and therefore knows what
    // is locked/unlocked.  No need to do anything.
    //
    if (DmaAddressSpace == ADDR_FBMEM)
        return (RM_OK);    

    //
    // As a convenience to the drivers, we allow an AGP Context DMA to be setup that's
    // larger than the underlying alloced pages (setup to map the whole aperture).
    // Since we avoided a call to CheckLinRange in osLockUserMem, we can't do it here
    // either. And, besides, we don't lock/unlock AGP memory anyways.
    //
    if (DmaAddressSpace == ADDR_AGPMEM)
        return (RM_OK);    

    PageBase = (U032)LinAddr >> 12;
    UnlockFlags = 0;
    if ((U032)LockHandle != (U032)LinAddr)
    {
        UnlockFlags = PAGEMAPGLOBAL;
    }
    //
    // KJK Allow a twice-deleted dma context.  Windows will return an error to CheckLinRange
    // if the context has already been unlocked by someone else, so don't go try talking
    // to the memory.
    //
//#ifdef DEBUG
    if (vmmPageCheckLinRange((U032)LinAddr >> PAGESHIFT, PageCount, 0) != PageCount)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unlocking invalid memory range!\n\r");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "     Address: ", (U032)LinAddr);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   PageCount: ", PageCount);
        DBG_BREAKPOINT();
        DirtyFlag = 0;
    }
//#endif // DEBUG
    if (DirtyFlag)
    {
        NopMask  = 0xFF;
        for (Page = 0; Page < PageCount; Page++)
        {
            *(volatile U008 *)LinAddr &= NopMask;
            (U032)LinAddr += PAGESIZE;
        }
    }
    //
    // Unlock pages and restore the memory context if neccessary.
    //
    if (DmaAddressSpace != ADDR_AGPMEM)
        status = !vmmLinPageUnLock(PageBase, PageCount, UnlockFlags) ? RM_ERR_DMA_MEM_NOT_UNLOCKED : RM_OK;
    return (status);
}

RM_STATUS osMapFifo
(
    PHWINFO pDev, 
    U032 clientClass, 
    U032 ChannelID,
    VOID **ppAddress
)
{
    *ppAddress = (VOID *) ((U032)pDev->DBnvAddr + FIFO_USER_BASE(pDev) + (ChannelID << 16));
    return RM_OK;
}

RM_STATUS osMapFrameBuffer
(
    PHWINFO pDev, 
    U032 clientClass, 
    U032 fbOffset,
    U032 length,
    VOID **ppAddress
)
{
    *ppAddress = (VOID *) ((U032)pDev->DBfbAddr + fbOffset);
    return RM_OK;

}

RM_STATUS osMapInstanceMemory
(
    PHWINFO pDev, 
    U032 clientClass, 
    U032 instanceOffset,
    U032 length,
    VOID **ppAddress
)
{
    *ppAddress = (VOID *) ((U032)INSTANCE_MEMORY_BASE + instanceOffset);
    return RM_OK;
}

// This procedure undoes the work of osMapFifo, osMapFrameBuffer and osMapInstanceMemory
RM_STATUS osUnmapMemory
(
    PHWINFO pDev,
    U032    clientClass,
    VOID   *address,
    U032    length
)
{
    // There is nothing to unmap in win9x.
    return RM_OK;
}

RM_STATUS osSetFifoDmaParams
(
    PHWINFO pDev,
    U032   *pFetchTrigger,
    U032   *pFetchSize,
    U032   *pFetchRequests
)
{
    U032 data32;

    //
    // Default win9x DMA channel fetch parameters are optimized for
    // for the D3D driver.
    //

    //
    // The registry overrides are specified in values that can be
    // plugged directly into the hardware.  We need to convert them
    // to the appropriate units so they'll continue to work.
    //

    //
    // If there's a dma fifo fetch trigger override, use it now.
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strFetchTriggerOverride, &data32) == RM_OK)
        *pFetchTrigger = (data32+1) * 8;
    else
        *pFetchTrigger = 128;           // 128 bytes

    //
    // If there's a dma fifo fetch size override, use it now.
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strFetchSizeOverride, &data32) == RM_OK)
        *pFetchSize = (data32+1) * 32;
    else
        *pFetchSize = 32;               // 32 bytes

    //
    // If there's a dma fifo fetch max reqs override, use it now.
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strFetchMaxReqsOverride, &data32) == RM_OK)
        *pFetchRequests = data32;
    else
        *pFetchRequests = 15;           // 15 outstanding read requests

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  OS specific time of day.
//
//---------------------------------------------------------------------------

RM_STATUS osGetCurrentTime
(
    U032 *year,
    U032 *month,
    U032 *day,
    U032 *hour,
    U032 *min,
    U032 *sec,
    U032 *msec
)
{
    U032 bcd;
    CLIENT_STRUCT  crs;
    U032 i;
    
    //
    // Sorry, no msec accuracy.
    //
    *msec = 0;
    //
    // Read the real time clock chip. Convert BCD to integer.
    //
    /*
    outp(0x70, 0x00); bcd = inp(0x71);
    *sec = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x02); bcd = inp(0x71);
    *min = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x04); bcd = inp(0x71);
    *hour = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x07); bcd = inp(0x71);
    *day = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x08); bcd = inp(0x71);
    *month = (bcd & 0x0F) + (bcd >> 4) * 10;
    outp(0x70, 0x09); bcd = inp(0x71);
    *year = (bcd & 0x0F) + (bcd >> 4) * 10 + 1900;
    if (*year < 1995)
        *year += 100;
    */
    
    //
    // To make sure we get a valid time, ask the BIOS to recover the data
    // instead of going directly to the hardware.
    //
    // Wait for success, but don't wait too long
    //
    crs.CWRS.Client_Flags = BIT(CF_BIT);
    i = 0;
    while ((crs.CWRS.Client_Flags & BIT(CF_BIT)) && --i)
    {
        crs.CBRS.Client_AH  = 0x02;    // READ_CMOS_TIME
        TIMER(&crs);
    }
    
    //
    // Convert from BCD.  Also make sure the time is "somewhat" valid
    //
    bcd = crs.CBRS.Client_DH;
    *sec = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*sec > 60)
        *sec = 60;
    bcd = crs.CBRS.Client_CL;
    *min = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*min > 60)
        *min = 60;
    bcd = crs.CBRS.Client_CH;
    *hour = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*hour > 24)
        *month = 24;
    
    //
    // Now get the date.
    //
    // Wait for success, but don't wait too long
    //
    crs.CWRS.Client_Flags = BIT(CF_BIT);
    i = 0;
    while ((crs.CWRS.Client_Flags & BIT(CF_BIT)) && --i)
    {
        crs.CBRS.Client_AH  = 0x04;    // READ_CMOS_DATE
        TIMER(&crs);
    }
    
    //
    // Convert from BCD.  Also make sure the time is "somewhat" valid
    //
    bcd = crs.CBRS.Client_DL;
    *day = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*day > 31)
        *day = 31;
    bcd = crs.CBRS.Client_DH;
    *month = (bcd & 0x0F) + (bcd >> 4) * 10;
    if (*month > 12)
        *month = 12;
    bcd = crs.CBRS.Client_CL;
    *year = (bcd & 0x0F) + (bcd >> 4) * 10 + 1900;
    if (*year < 1995)
        *year += 100;
    
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  OS specific IPC, notifications and error callbacks.
//
//---------------------------------------------------------------------------
extern DWORD vwin32SetWin32Event( DWORD );
extern DWORD vwin32CloseVxdHandle( DWORD );

RM_STATUS osNotifyEvent
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Notifier,    
    U032      Method,
    U032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    PEVENTNOTIFICATION NotifyEvent;
    
    //
    // Check for the correct actions
    //
    if (Action == NV_OS_WRITE_THEN_AWAKEN)
    {
        //
        // Walk this object's event list and find any matches for this
        // specific notify
        //
        NotifyEvent = Object->NotifyEvent;
        while (NotifyEvent)
        {
            //
            // Check for a notify index match
            //
            if (NotifyEvent->NotifyIndex == Notifier)
            {
                // 
                // Match!!
                //
                switch (NotifyEvent->NotifyType)                
                {
                    case NV01_EVENT_WIN32_EVENT:
#ifndef IKOS
                        //
                        // Attempt to trigger the event
                        //
                        if (vwin32SetWin32Event((U032)(NotifyEvent->Data.low)) == 0)
                        {
                            //
                            // Failed, so lose this event so we don't try again
                            //
                            vwin32CloseVxdHandle((U032)(NotifyEvent->Data.low));
                            NotifyEvent->NotifyType = 0;
                        }
#endif
                        break;
                        
                    /*
                    case NV_OS_EVENT_VM_EVENT:
                        //
                        // Schedule event servicing.  Do this in the system VM.
                        //
                        vmmCallPriorityVMEvent(HIGH_PRI_DEVICE_BOOST,
                                               vmmGetSysVMHandle(),
                                               0,
                                               0,
                                               (U032)(NotifyEvent->Data.low),
                                               0);
                    
                        break;
                    */
                        
                    case NV01_EVENT_KERNEL_CALLBACK:
                        //
                        // Perform a direct callback.  This is assumed to be a Ring0->Ring0
                        // transfer.
                        //
                        {
                        CRS       SavedCRS;
                        U032      SysVM = vmmGetSysVMHandle();
                        
                        //
                        // Just in case the callback is ill behaved
                        //
                        vmmSaveClientState(&SavedCRS);
                        
                     
                        //
                        // Schedule RM servicing.
                        //
                        vmmCallPriorityVMEvent(TIME_CRITICAL_BOOST,
                                               SysVM,
                                               0,
                                               (U032)Status,
                                               (U032)(NotifyEvent->Data.low),
                                               0);
                        
                        //
                        // Restore our state.
                        //
                        vmmRestoreClientState(&SavedCRS);
                        
                        }
                        break;
                                                
                    default:
                        break;
                }                                                
            }
            
            // 
            // On to the next one
            //
            NotifyEvent = NotifyEvent->Next;
        }
    
    }
    //
    // The rest of these actions are legacy channel-based notifies
    //
    else
    {    
        return NVOS10_STATUS_ERROR_BAD_EVENT;
    }    
}

RM_STATUS osError
(
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Error
)
{
    PHWINFO pDev;
	PWIN9XHWINFO pOsHwInfo;
    POBJECT *ppObject;
    int i;

    for(i=0;i<MAX_INSTANCE;i++){
        pDev = NvDBPtr_Table[i];
        if(pDev != NULL){
			pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

            // Search the fifo object tree for an object with the same name.
            fifoSearchObject(pDev,Object->Name,Object->ChID,ppObject);
            if(ppObject != NULL){
              if(*ppObject == Object){
                  break;
              }else{
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR in osError (Object not found)\n\r");
                  return (RM_ERROR);
              }
            }
        }
    }

    //
    // Only call back on errors, not warnings.
    //
    if (Error & 0xFFFF)
    {
        if (pOsHwInfo->dllNotifySelector + pOsHwInfo->dllNotifyOffset == 0)    
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR - Notify callback invalid!\n\r");
            return (RM_ERROR);
        }
        if (Object)
            return (osScheduleCallback(pDev,
                                       (U016)pOsHwInfo->dllNotifySelector,
                                       (U016)pOsHwInfo->dllNotifyOffset,
                                       6,
                                       Object->ChID,
                                       Object->Name, 
                                       Method,
                                       Data,
                                       Error,
                                       0));
        else       
            return (osScheduleCallback(pDev,
                                       (U016)pOsHwInfo->dllNotifySelector,
                                       (U016)pOsHwInfo->dllNotifyOffset,
                                       6,
                                       Data,
                                       0, 
                                       Method,
                                       0,
                                       Error,
                                       0));
    }
    return (RM_OK);
}

RM_STATUS osExit
(
    char *errstr
)
{
    vmmFatalErrorHandler((DWORD)errstr, 0);
    return (RM_OK);
}
//---------------------------------------------------------------------------
//
//  Misc services.
//
//---------------------------------------------------------------------------

RM_STATUS osDelay
(
    U032 MilliSeconds
)
{
    U032 Start;

    Start = vmmGetSystemTime();
    while ((vmmGetSystemTime() - Start) < MilliSeconds);
    return (RM_OK);
}

RM_STATUS osDelayUs
(
    U032 MicroSeconds
)
{
    U032 Start;

    //
    // TEMPORARY WORKAROUND
    //
    // The BIP language spec calls for a usec delay, yet win9x can only
    // handle msec delays.  So, floor us at 1ms and pre-convert all other 
    // timing requests
    //
    if (MicroSeconds < 1000)
        MicroSeconds = 1;
    else
        MicroSeconds = MicroSeconds / 1000;

    Start = vmmGetSystemTime();
    while ((vmmGetSystemTime() - Start) < MicroSeconds);
    return (RM_OK);
}
//---------------------------------------------------------------------------
//
//  PCI config space read/write routines.
//
//---------------------------------------------------------------------------
#define PCI_FUNCTION_ID         0xB1
#define READ_CONFIG_BYTE        0x08
#define READ_CONFIG_WORD        0x09
#define READ_CONFIG_DWORD       0x0A
#define WRITE_CONFIG_BYTE       0x0B
#define WRITE_CONFIG_WORD       0x0C
#define WRITE_CONFIG_DWORD      0x0D

U032
osPciReadDword(VOID *handle, U032 offset)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = READ_CONFIG_DWORD;
    pcrs->CWRS.Client_DI  = (U016) offset;
    PCI(pcrs);

    return pcrs->CRS.Client_ECX;
}

U016
osPciReadWord(VOID *handle, U032 offset)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = READ_CONFIG_WORD;
    pcrs->CWRS.Client_DI  = (U016) offset;
    PCI(pcrs);

    return pcrs->CBRS.Client_CL;
}

U008
osPciReadByte(VOID *handle, U032 offset)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = READ_CONFIG_BYTE;
    pcrs->CWRS.Client_DI  = (U016) offset;
    PCI(pcrs);

    return pcrs->CBRS.Client_CL;
}

VOID
osPciWriteDword(VOID *handle, U032 offset, U032 value)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = WRITE_CONFIG_DWORD;
    pcrs->CWRS.Client_DI  = (U016) offset;
    pcrs->CRS.Client_ECX  = value;
    PCI(pcrs);
}

VOID
osPciWriteWord(VOID *handle, U032 offset, U016 value)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = WRITE_CONFIG_WORD;
    pcrs->CWRS.Client_DI  = (U016) offset;
    pcrs->CBRS.Client_CL  = (U008) value;
    PCI(pcrs);
}

VOID
osPciWriteByte(VOID *handle, U032 offset, U008 value)
{
    CLIENT_STRUCT *pcrs = (CLIENT_STRUCT *)handle;

    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID;
    pcrs->CBRS.Client_AL  = WRITE_CONFIG_BYTE;
    pcrs->CWRS.Client_DI  = (U016) offset;
    pcrs->CBRS.Client_CL  = value;
    PCI(pcrs);
}

VOID *
osPciInitHandle(U008 bus, U008 device, U008 func, U016 *pVendorId, U016 *pDeviceId)
{
    U016 venID, devID;
    static CLIENT_STRUCT crs;

    // get vendor/device id at offset 0
    _asm {
        push    eax
        push	edx

        // build up bus/device/func config addr
        movzx   eax, bus
        shl     eax, 10h
        movzx   edx, device
        shl     edx, 0Bh
        or      dh,  func

        or      eax, edx
        or      eax, 80000000h

        mov     edx, 0cf8h
        out     dx,eax
        mov     edx, 0cfch
        in      eax, dx

        // vendor/device from config data
        mov     venID, ax
        shr     eax, 16
        mov     devID, ax

        pop     edx
        pop     eax
    }

    // return these to the caller
    if (pVendorId)
        *pVendorId = venID;
    if (pDeviceId)
        *pDeviceId = devID;

    // initialize the CLIENT_STRUCT state
    crs.CBRS.Client_AH  = PCI_FUNCTION_ID;  // PCI_FUNCTION_ID
    crs.CBRS.Client_AL  = 0x02;             // FIND_PCI_DEVICE
    crs.CWRS.Client_CX  = devID;            // Device ID
    crs.CWRS.Client_DX  = venID;            // Vendor ID
    crs.CWRS.Client_SI  = 0;                // Index
    PCI(&crs);

    return &crs;
}


#ifdef OBSOLETE_FUNCTIONS
RM_STATUS osRedrawScreen
(
    VOID
)
{
    osIPC(NVRM_WM_REDRAW_SCREEN, 0, 0);
    return (RM_OK);
}
RM_STATUS osRedrawCanvas
(
    U032 hwnd
)
{
    if (hwnd != 0)
        osIPC(NVRM_WM_REDRAW_HWND, (U016)hwnd, 0);
    return (RM_OK);
}
RM_STATUS osBeginWatchCanvas
(
    U032 hwnd
)
{
    if (hwnd != 0)
        osIPC(NVRM_WM_OPEN_HWND, (U016)hwnd, 0);
    return (RM_OK);
}
RM_STATUS osEndWatchCanvas
(
    U032 hwnd
)
{
    if (hwnd != 0)
        osIPC(NVRM_WM_CLOSE_HWND, (U016)hwnd, 0);
    return (RM_OK);
}
#endif // OBSOLETE_FUNCTIONS

// New semaphore functions for Multi-Mon support.
RM_STATUS mmWaitSemaphore
(
    VOID
)
{
//    vmmWaitSemaphore(mmSemaphore, 0);
    return (RM_OK);
}
RM_STATUS mmSignalSemaphore
(
    VOID
)
{
//    vmmSignalSemaphore(mmSemaphore);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  OS name validation.
//
//---------------------------------------------------------------------------
#ifdef OBSOLETE_FUNCTIONS
RM_STATUS osValidateVideoSink
(
    char *OsName
)
{
    U032 i;
    
    for (i = 0; i < 4; i++)
        if (OsName[i] != nameVideoSink[i])
            return (RM_ERR_INVALID_OS_NAME);
    return (RM_OK);
}
RM_STATUS osValidateImageVideo
(
    char *OsName,
    U032 *CanvasID
)
{
    U032 i;
    
    *CanvasID = 0;
    for (i = 0; i < 3; i++)
        if (*OsName++ != nameImageVideo[i])
            return (RM_ERR_INVALID_OS_NAME);
    while (*OsName >= '0' && *OsName <= '9')
        *CanvasID = *CanvasID * 10 + *OsName++ - '0';
    return (*OsName == ':' ? RM_OK : RM_ERROR);
}


// Validate the DMA address space name from the app
// A DMA object with no name is treated as System Memory space
// The DMA direction does not matter for system memory space
RM_STATUS osValidateDMAObject(
    char *OsName,
    U032 DmaObjectName,
    NV_ADDRESS_SPACE *AddressSpace
)
{
    U032 i;
    RM_STATUS status;

    if (OsName[0] == '\0') {
        *AddressSpace = ADDR_SYSMEM;
        return(RM_OK);
    }

    if (osStringCompare(OsName, nameSysMem))
    {
       *AddressSpace = ADDR_SYSMEM;
       return(RM_OK);
    }

    if (osStringCompare(OsName, nameLVidMem))
    {
       *AddressSpace = ADDR_FBMEM;
       return(RM_OK);
    }
    
    if (osStringCompare(OsName, nameSVidMem))
    {
        //
        // Only allow true AGP on AGP systems!!  
        //
        if (pDev->Chip.Bus == BUS_AGP)
            //
            // When we attempt to lock this context we need to verify it falls within
            // the AGP space.  If not, it is really a PCI memory block and needs to be
            // treated as such.
            //
            *AddressSpace = ADDR_AGPMEM;
        else    
            *AddressSpace = ADDR_SYSMEM;
        return(RM_OK);
    }
    
    *AddressSpace = ADDR_SYSMEM;
    
    return(RM_ERR_INVALID_OS_NAME);
    
}
#endif // OBSOLETE_FUNCTIONS

//---------------------------------------------------------------------------
//
//  Interrupt time stuff.
//
//---------------------------------------------------------------------------

CARRY osInterrupt
(
    U032 hIRQ,
    U032 hVM
)
{
    PHWINFO   pDev;
    U032 status;

    //
    // Need to do this within a routine with no local variables to make
    // sure we can return the carry flag correctly without the compiler
    // stomping on it.
    //
    //int  saved_DeviceInstance; 
    // Save the DeviceInstance of the current executing RM thread.
    //saved_DeviceInstance = DeviceInstance; 

    status = osInterruptProcess(&pDev,hIRQ, hVM);
    
    //_asm push eax
    //DeviceInstance = saved_DeviceInstance; 
    //_asm pop  eax
        
    //
    // Of course, the Microsoft compiler handles things differently from
    // the Watcom compiler.  We need to exit this routine with the
    // carry flag denoting if we handled this interrupt ourselves.
    // But the return value from vmmCallBackExit() is in EAX and will
    // destroy any carry flag.  So, let's set the carry flag according
    // to EAX.
    //
    // CY=1 if ok to share since we didn't process
    // CY=0 if we processed our own interrupt (w/ EOI)
    //        
    _asm {   
        clc        
        cmp eax, 0
        je notus
        stc
        notus:
    }

}

BOOL CDECL osServiceHandler
(
    VOID
)
{
    PHWINFO   pDev;
    U032      hDevice;
	PWIN9XHWINFO pOsHwInfo;

    _asm mov hDevice, edx
    pDev = (PHWINFO) hDevice;
	pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    if (pDev->DeviceDisabled)
    {
        U032 we_are_mapped;
        U032 pci_address;
    
        // Check if the device has become unmapped. If so stop servicing.
        // Read the 1st base register.
        pci_address = pDev->Mapping.nvBusDeviceFunc;
        _asm mov  dx, 0xcf8
        _asm in   eax, dx
        _asm push eax
        _asm mov  eax, pci_address  
        _asm or   eax, 0x80000010 
        _asm out  dx, eax
        _asm mov  dx, 0xcfc
        _asm in   eax,dx
        _asm mov  we_are_mapped,eax
        _asm pop  eax
        _asm mov  dx, 0xcf8
        _asm out  dx, eax
    
        if(!we_are_mapped)
        {
            // The device is disabled. Just ignore this interrupt.
            return(TRUE);
        }  
    }

    //See if we are still lineraly mapped
    if (nvAddr->Reg032[0] == 0xFFFFFFFF)
    {
		  return(1);
	 }
 
    if (pOsHwInfo->osScheduled)
    {    
        pOsHwInfo->osScheduled--;
        osEnsureDeviceEnabled(pDev);

        {
            BOOL x;
            U032 t1,t2;

            t1=(U032) pOsHwInfo->NvIsrStackFrame;
            osSwapStack(t1, t2);
            pOsHwInfo->NvSaveVmmStack = (U032 *) t2;

            x=osService(pDev);

            t1=(U032) pOsHwInfo->NvSaveVmmStack;
            osSwapStack(t1, t2);
            pOsHwInfo->NvIsrStackFrame = (U032 *) t2;

            return(x);        
        }
    }
}

U032 osInterruptProcess
(
    PHWINFO *ppDev,
    U032 hIRQ,
    U032 hVM
)
{
    PHWINFO pDev;
	PWIN9XHWINFO pOsHwInfo;

    V032 pmc;
    V032 pmce;
#ifdef RM_STATS
    U032 EnterTimeLo;
    U032 EnterTimeHi;
    U032 ExitTimeLo;
    U032 ExitTimeHi;
    U032 IntTimeLo;
    U032 IntTimeHi;
#endif
//  int  saved_DeviceInstance; 
#ifdef TIMER_OVERRIDE
    V032 ptimer;
#endif
    VOID VBlank(PHWINFO);

    CLI

//
  // Let's just walk the devices and find the one that is
  // associated with this hIRQ.  The IRQ handle was saved away
  // when each particular device hooked its interrupt routine
  // with the VPICD.
  //
  // We should get called for every handle, independent of
  // actual IRQ sharing in the system.
  //
  // For all possible devices in the system
  //
  {
    U032 i;
    
    for (i=0;i<MAX_INSTANCE;i++)
    {
        // Check if this device exists.
        if (NvDBPtr_Table[i] != NULL)
        {
            pDev = NvDBPtr_Table[i];
			pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
            //DeviceInstance = i;
            
            if (pDev->Mapping.hpicIRQ != NULL && pDev->Mapping.hpicIRQ == hIRQ)
            {
                // Make sure this device has not been disabled by Windows98.
                // If it has been disabled then re-enable it.
                osEnsureDeviceEnabled(pDev);

                // This may or may not be our interrupt, but we have established our
                // pDev (osInterrupt needs it setup, so we can chain the interrupt).
                *ppDev = pDev;

                // This code is in place for MultiMonitor support during a shutdown.
                // If the system is shutting down Win98 will zero out the pci base registers.
                // If this happens ... just return as if it was not meant for us.
                if (pDev->DeviceDisabled)
                {
                    U032 we_are_mapped;
                    U032 pci_address;
                  
                    // Check if the device has become unmapped. If so stop servicing.
                    // Read the 1st base register.
                    pci_address = pDev->Mapping.nvBusDeviceFunc;
                    _asm mov  eax, pci_address  
                    _asm or   eax, 0x80000010 
                    _asm mov  dx, 0xcf8
                    _asm out  dx, eax
                    _asm mov  dx, 0xcfc
                    _asm in   eax,dx
                    _asm mov  we_are_mapped,eax
                  
                    if(!we_are_mapped)
                        return(1);
                }

                //See if we are still linearaly mapped
                if (nvAddr->Reg032[0] == 0xFFFFFFFF)
                {
                    return(1);
                }
                
                //
                // Windows thought this IRQ was meant for us...
                //
                // Check if this device's interrupt has been asserted.
                //
                pmc  = REG_RD32(NV_PMC_INTR_0);
                pmce = REG_RD32(NV_PMC_INTR_EN_0);
                if (pmc && pmce)
                {
                    // 
                    // Hey, it was us!  Break out.
                    //
                    i = MAX_INSTANCE;
                }     
                else
                {
                    //
                    // It was our IRQ, but it wasn't our device
                    // Restore the DeviceInstance of the current executing RM thread.
                    // Let it chain
                    //
                    // JIM !!!! DON'T RESTORE THIS YET !!!!!
                    //DeviceInstance = saved_DeviceInstance; 
                    return(1);
                }                    
            }                    
        } 
        else
        {
            //
            // No more devices to check !
            // Let it chain to other ISR's
            // Restore the DeviceInstance of the current executing RM thread.
            //
            return(1);
        }
    } 
  }

    if (pmc && pmce)
    {
        //
        // Turn off interrupts here to avoid glitching the PIC on cheap
        // PCI chipsets.
        //
        REG_WR32(NV_PMC_INTR_EN_0, 0x00000000);
#ifdef RM_STATS
        //
        // Profile the interrupt execution time.
        //
        tmrGetCurrentTime(pDev, &EnterTimeHi, &EnterTimeLo);
        //
        // 12/20/95 - msk - get time right away to do accurate timings for
        // new emulation method
        //
        pDev->Chip.osStartInterrupt = EnterTimeLo;
#endif
        //
        // EOI the PIC.
        //
        VPICD_Phys_EOI(pDev->Mapping.hpicIRQ);

#ifdef DEBUG_TIMING
        if (dbgCountInt[dbgFrame] < 20)
           dbgStartInt[dbgFrame][dbgCountInt[dbgFrame]] = REG_RD32(NV_PTIMER_TIME_0) - dbgStart ;
        dbgCountInt[dbgFrame]++;
#endif // DEBUG_TIMING

        //
        // Call any high priority service routines and schedule low priority 
        // service routines if service still required.
        //
        if (pmc & (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING) |
                   DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
        {
            if (!pDev->Vga.Enabled)   // no need for vblank service in NV3
                                        // DOS prgms which poll 3DA for vblank status
                                        // may not see it because of latency
            {
            //
            // Do any VBlank servicing.
            //    
                VBlank(pDev);
            }
        }

        //
        // check if need to service any high priority Mediaport tasks
        //
        //mpService(pDev);

#ifdef NV_VGA
#ifdef TIMER_OVERRIDE // Note: TIMER_OVERRIDE should usually not be defined!
        //
        // Usually stop the timer interrupt from being serviced
        //
        if (pDev->Vga.Enabled)
        {
           if (pmc & DRF_DEF(_PMC, _INTR_0, _PTIMER, _PENDING))
           {
               REG_WR_DRF_DEF(_PTIMER, _INTR_0, _ALARM, _RESET);
               ptimer = REG_RD32(NV_PTIMER_INTR_0);
               vgaTimer();
           }
        }
#endif // TIMER_OVERRIDE
#endif // NV_VGA
#ifdef RM_STATS
        //
        // Add time spent in service routines to accumulated time.
        //
        tmrGetCurrentTime(pDev, &ExitTimeHi, &ExitTimeLo);
        IntTimeLo = ExitTimeLo - EnterTimeLo;
        IntTimeHi = ExitTimeHi - EnterTimeHi;
        if (IntTimeLo > ExitTimeLo)
            IntTimeHi--;
        pDev->Chip.ExceptionTimeLo += IntTimeLo;
        if (pDev->Chip.ExceptionTimeLo < IntTimeLo)
            IntTimeHi++;
        pDev->Chip.ExceptionTimeHi += IntTimeHi;    
#endif
        // BUG_BM_OFF();
        pmc = REG_RD32(NV_PMC_INTR_0);
        // BUG_BM_ON();
        if (pmc)
        {
        
            if (!pOsHwInfo->osScheduled)
            {   
            
                U032    VMh = vmmGetSysVMHandle();
                     
                //
                // Schedule RM servicing.
                //
                pOsHwInfo->osScheduled = 1;
                vmmCallPriorityVMEvent(TIME_CRITICAL_BOOST,
                                       VMh,
                                       0,
                                       (DWORD)pDev,
                                       (U032)osServiceHandler,
                                       0);
            }                                       
        }
        else
        {
            //
            // Reenable chip interrupts.
            // Only if the device was NOT DISABLED.
            if (!pDev->DeviceDisabled){
                REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);
            }
        }
#ifdef DEBUG_TIMING
        if (dbgCountInt[dbgFrame] - 1 < 20)
            dbgEndInt[dbgFrame][dbgCountInt[dbgFrame]-1] = REG_RD32(NV_PTIMER_TIME_0) - dbgStart ;
#endif // DEBUG_TIMING
        //vmmCallBackExit(0);
        // Restore the DeviceInstance of the current executing RM thread.
        //DeviceInstance = saved_DeviceInstance; 
        return(0);
    }
    else
    {
        //
        // This interrupt is not for us, chain to next handler.
        //
        // Restore the DeviceInstance of the current executing RM thread.
        //DeviceInstance = saved_DeviceInstance; 
        return(1);
    }
}


VOID CDECL rmService
(
    VOID
)
{
    PHWINFO pDev=NULL;
	PWIN9XHWINFO pOsHwInfo;
    V032 pmc;
    V032 pmce;
#ifdef RM_STATS
    U032 EnterTimeLo;
    U032 EnterTimeHi;
    U032 ExitTimeLo;
    U032 ExitTimeHi;
    U032 IntTimeLo;
    U032 IntTimeHi;
#endif
    CRS  SavedCRS;
    VOID VBlank(PHWINFO);

    //
    // Turn off interrupts to keep real interrupt routine from interfering.
    //
    CLI
    // BUG_BM_OFF();
    pmc  = REG_RD32(NV_PMC_INTR_0);
    pmce = REG_RD32(NV_PMC_INTR_EN_0);
    // BUG_BM_ON();
    //
    // Turn off chip interrupt here to avoid re-entrancy issues.
    //
    REG_WR32(NV_PMC_INTR_EN_0, 0x00000000);
    if (pmc && pmce)
    {
#ifdef RM_STATS
        //
        // Profile the interrupt execution time.
        //
        tmrGetCurrentTime(&EnterTimeHi, &EnterTimeLo);
#endif
        //
        // EOI the PIC.
        //
        VPICD_Phys_EOI(pDev->Mapping.hpicIRQ);
        //
        // Call all service routines requiring attention.
        //
        if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        {
            //
            // Do any VBlank servicing.
            //    
            VBlank(pDev);
        }
#ifdef RM_STATS
        //
        // Add time spent in service routines to accumulated time.
        //
        tmrGetCurrentTime(&ExitTimeHi, &ExitTimeLo);
        IntTimeLo = ExitTimeLo - EnterTimeLo;
        IntTimeHi = ExitTimeHi - EnterTimeHi;
        if (IntTimeLo > ExitTimeLo)
            IntTimeHi--;
        pDev->Chip.ExceptionTimeLo += IntTimeLo;
        if (pDev->Chip.ExceptionTimeLo < IntTimeLo)
            IntTimeHi++;
        pDev->Chip.ExceptionTimeHi += IntTimeHi;    
#endif
        // BUG_BM_OFF();
        pmc = REG_RD32(NV_PMC_INTR_0);
        // BUG_BM_ON();
    }
    if (pmc)
    {
        //
        // Service chip right now.
        //
        //
        // The only sure way to make sure that we don't deadlock if we get a second
        // flush fifo call from DirectAudio or DirectInput while we are currently
        // servicing a previous flush fifo is to protect the calls with a real
        // blocking semaphore.
        //
        vmmWaitSemaphore(osSemaphore, 0);
        if (!osService(pDev))
        {
            //
            // The RM is currently in service.  To allow the InService event
            // to complete, a dummy call to the 16 bit NVSYS.DLL will be made
            // to force the VMM to reschedule its events.  Maybe next time
            // through we will actually be able to call the RM.
            //
			pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

            vmmSaveClientState(&SavedCRS);
            vmmBeginNestExecution();
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0);
            vmmSimulatePush(0xFFFF);
            vmmSimulatePush(0xFFFF);
            vmmSimulateFarCall(pOsHwInfo->dllNotifySelector, pOsHwInfo->dllNotifyOffset);
            vmmResumeExec();
            vmmEndNestExecution();
            vmmRestoreClientState(&SavedCRS);
        }
        vmmSignalSemaphore(osSemaphore);
    }
    else
    {
        //
        // Reenable chip interrupts.
        //
        REG_WR32(NV_PMC_INTR_EN_0, pmce);
    }
    //
    // Re-enable interrupts.
    //
    STI
}
BOOL CDECL osService
(
    PHWINFO pDev
)
{
    //
    // Make sure interrupts are enabled.
    //
    STI
    //
    // Service all chip functions.
    //
    mcService(pDev);
    //
    // Try scheduling callbacks here.
    //
    if (osCallbackList && !rmInCallback)
    {
        rmInCallback++;
        vmmCallPriorityVMEvent(HIGH_PRI_DEVICE_BOOST,
                               vmmGetSysVMHandle(),
                               (PEF_WAIT_FOR_STI | PEF_ALWAYS_SCHED),
                               (DWORD)pDev,
                               (DWORD)osCallback,
                               0);
    }
    //
    // Reenable chip interrupts.
    // Only if the device was NOT DISABLED.
    if (!pDev->DeviceDisabled){
        REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);
    }

    return (TRUE);
}

VOID osNopInt
(
    U032 hIRQ,
    U032 hVM
)
{
    return;
}

RM_STATUS CDECL osScheduleCallback
(
    PHWINFO pDev,
    U016    dllSelector,
    U016    dllOffset,
    U032    Count,
    U032    Params,
    ...
)
{
    U032      i;
    U032      *ParamList;
    PCALLBACK CallbackInfo;
    PCALLBACK SearchCallback;
    
    if (dllSelector == 0 && dllOffset == 0)    
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ERROR - schedule callback invalid!\n\r");
        return (RM_ERROR);
    }
    //
    // Schedule the callback at a nice time.
    //
    CLI
    CallbackInfo = osCallbackFreeList;
    if (CallbackInfo == NULL)
    {
        STI
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to allocate callback structure!\n\r");
        return (RM_ERR_NO_FREE_MEM);
    }
    osCallbackFreeList     = osCallbackFreeList->Next;
    CallbackInfo->Next     = NULL;
    CallbackInfo->Selector = dllSelector;
    CallbackInfo->Offset   = dllOffset;
    CallbackInfo->Count    = Count;
    ParamList              = &Params;
    for (i = 0; i < Count; i++)
        CallbackInfo->Params[i] = *ParamList++;
    if (osCallbackList)
    {
        //
        // Insert into linked list of callbacks.
        //
        SearchCallback = osCallbackList;
        while (SearchCallback->Next)
            SearchCallback = SearchCallback->Next;
        SearchCallback->Next = CallbackInfo;
    }
    else
    {
        //
        // Schedule a callback.
        //
        osCallbackList = CallbackInfo;
    }
    STI
    return (RM_OK);
}

//
// Some customers are still using these legacy callback mechanisms.  Do not remove
//
extern CallBackDef mpCallback, mpImageCallback;
extern DWORD rmmpInCallback;
VOID osmpVbiCallback( U032 );
VOID osmpImageCallback( U032 );

VOID osmpCheckCallbacks(
    PHWINFO pDev,
    U032 dwCallbackSelect
)
{
    if (!(pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS))
        return;
// select VBI callback
if (dwCallbackSelect==0)
    {
    if (((mpCallback.Selector+mpCallback.Offset)!=0) && !rmmpInCallback)
    {
       rmmpInCallback++;
       vmmCallPriorityVMEvent(HIGH_PRI_DEVICE_BOOST,
                                   vmmGetSysVMHandle(),
                                   (PEF_WAIT_FOR_STI | PEF_ALWAYS_SCHED),
                                   (DWORD)pDev,
                                   (DWORD)osmpVbiCallback,
                                   0);
    }
    }                                      

// select image callback
if (dwCallbackSelect==1)
    {
    if (((mpImageCallback.Selector+mpImageCallback.Offset)!=0) && !rmmpInCallback)
    {
       rmmpInCallback++;
       vmmCallPriorityVMEvent(HIGH_PRI_DEVICE_BOOST,
                                   vmmGetSysVMHandle(),
                                   (PEF_WAIT_FOR_STI | PEF_ALWAYS_SCHED),
                                   (DWORD)pDev,
                                   (DWORD)osmpImageCallback,
                                   0);
    }


    }

}
extern DWORD mpImageInstalledCallback;
extern DWORD mpInstalledCallback;

VOID osmpVbiCallback
(
    // The parameter passing must be done via registers as seen below.
    U032 hVM
)
{
    CRS       SavedCRS;
    PHWINFO   pDev;

    // Load the device instance for this callback.
    _asm mov pDev, edx

    if (mpInstalledCallback)
        {
        vmmCallBackEntry();
        CLI
        vmmSaveClientState(&SavedCRS);
        vmmBeginNestExecution();
        STI
        // why do these have to be 16 bit pushes ?
        //vmmSimulatePush(dwVbiBufferNumber >> 16 );
        //vmmSimulatePush(dwVbiBufferNumber & 0xFFFF);
        vmmSimulatePush(0 >> 16 );
        vmmSimulatePush(0 & 0xFFFF);
        vmmSimulateFarCall(mpCallback.Selector, mpCallback.Offset & 0xFFFF);
        vmmResumeExec();
        CLI

        vmmEndNestExecution();
        vmmRestoreClientState(&SavedCRS);
        rmmpInCallback--;
        STI
        vmmCallBackExit(TRUE);
        }
}

VOID osmpImageCallback
(
    // The parameter passing must be done via registers as seen below.
    U032 hVM
)
{
    CRS       SavedCRS;
    PHWINFO   pDev;
    U032      DeviceInstance;

    // Load the device instance for this callback.
    _asm mov pDev, edx
    // Grab the device instance #
    DeviceInstance = pDev->DBdevInstance;

    if (mpImageInstalledCallback)
        {
        vmmCallBackEntry();
        CLI
        vmmSaveClientState(&SavedCRS);
        vmmBeginNestExecution();
        STI
        
        vmmSimulatePush(DeviceInstance >> 16);      // keyed for Canopus client
        vmmSimulatePush(DeviceInstance & 0xFFFF);
        
        // why do these have to be 16 bit pushes ?
        vmmSimulatePush(pDev->MediaPort.ImageBufferNumber >> 16 );
        vmmSimulatePush(pDev->MediaPort.ImageBufferNumber & 0xFFFF);

        vmmSimulateFarCall((U032) mpImageCallback.Selector, 
                            (U032) (mpImageCallback.Offset & 0xFFFF));
        vmmResumeExec();
        CLI

        vmmEndNestExecution();
        vmmRestoreClientState(&SavedCRS);
        rmmpInCallback--;
        STI
        vmmCallBackExit(TRUE);
        }
}


#define rdtsc __asm _emit 0x0f __asm _emit 0x31 
extern U032 vmmGetSystemTime();

// Return frequency value in MHz
U032 osGetCpuFrequency()
{
    U032 t1, t2;
    U032 tsc1, tsc2;

    // wait for timer to roll the first time
    t2 = vmmGetSystemTime();
    do {
        t1 = vmmGetSystemTime();
    } while (t1 == t2);

    // read the tsc
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc1], eax
        pop     edx
        pop     eax
    }

    t1 += 100;              // add 1/10 second
    while(t2 < t1) {        // wait 1/10 second
        t2 = vmmGetSystemTime();
    }

    // read the tsc again
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc2], eax
        pop     edx
        pop     eax
    }

    // multiply returned value by 10 since we timed 1/10th second
    // and divide the result to convert from Hz to MHz
    return (U032) ((tsc2-tsc1) * 10) / (1000000);
}

VOID osCallback
(
    // The parameter passing must be done via registers as seen below.
    U032 hVM
)
{
    U032      i;
    CRS       SavedCRS;
    PCALLBACK OldCallback;
    U032      hDevice;
    PHWINFO   pDev;

    // Load the device instance for this callback.
    _asm mov hDevice, edx

    pDev = NvDBPtr_Table[hDevice];
    //DeviceInstance = hDevice;

    vmmCallBackEntry();    
    CLI
//    rmInCallback = TRUE;
#if DEBUG
    if (osCallbackList == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL Callback Callback List!\n\r");
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      Add more structures.\n\r");
    }
#endif    
    vmmSaveClientState(&SavedCRS);
    vmmBeginNestExecution();
    while (osCallbackList)
    {
        U032 Selector = osCallbackList->Selector;
        U032 Offset = osCallbackList->Offset;
    
        STI
        for (i = 0; i < osCallbackList->Count; i++)
        {
            vmmSimulatePush(osCallbackList->Params[i] >> 16);
            vmmSimulatePush(osCallbackList->Params[i] & 0xFFFF);
        }
//        vmmSimulateFarCall(osCallbackList->Selector, osCallbackList->Offset);
        vmmSimulateFarCall(Selector, Offset);
        vmmResumeExec();
        CLI
        //
        // Move to next callback in the pending list.
        //
        OldCallback    = osCallbackList;
        osCallbackList = osCallbackList->Next;
        //
        // Stick the old callback structure back on the free list.
        //
        OldCallback->Next  = osCallbackFreeList;
        osCallbackFreeList = OldCallback;
    }
    vmmEndNestExecution();
    vmmRestoreClientState(&SavedCRS);
    rmInCallback--;
    STI
    vmmCallBackExit(TRUE);
}

// 
//
VOID osDisplayModeHook
(
    PHWINFO pDev,
    U032    msg
)
{
    //
    // If the Win9X display driver has asked for state change
    // notification, call him now
    //
    if (pDev->DBdisplayModeHook)
    {
        // This needed to be modified due to the incomplete 
        // _asm support in MS tools.
        //(*pDev->DBdisplayModeHook)(msg);
        VOID *x;
        x = pDev->DBdisplayModeHook;
        __asm {
            push    edi
            mov     eax, msg
            mov     edi, x
            call    edi
            pop     edi
        } 
    }
} // end of osDisplayModeHook

//
// Perform any os-specific DAC state updates that need to occur
// when the DAC/CRTC has been updated.
//
VOID osStateDacEx
(
    PHWINFO pDev,
    U032    msg
)
{
#if 0   // this should be in osPostModeSet
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    //
    // Notify the Win9X minivdd that a mode change has probably occurred.  This allows
    // it to save any new register states
    //
    if (pOsHwInfo->miniVDDPostModeChange)  // if primary display, we got callback at init
        (*pOsHwInfo->miniVDDPostModeChange)();
#endif
}

//  Set the FilterEnable value for TV flicker filtering
//  This checks the registry for an override 
//
VOID osStateFbEx
(
    PHWINFO pDev
)
{
U032    data32;
// To Do:
// we probably want to return a value (0,1, or 2) representing the amount of filtering.
// for now we just check for the string.
// we should be able to override on as well as off. This means don't check monitor.type, just check range
// on data32 and copy 0,1, or 2 to FilterEnable.
    if (osReadRegistryDword(pDev,strDevNodeRM, "FilterOverride", &data32) == RM_OK)  // TV filter?
    {
        if (GETMONITORTYPE(pDev, 0) != MONITOR_TYPE_VGA)
            pDev->Framebuffer.FilterEnable = 2;
    } 
    else 
    {
        //
        // Otherwise, make sure we get a default value in during initialization
        //
        if (GETMONITORTYPE(pDev, 0) == MONITOR_TYPE_VGA)
            pDev->Framebuffer.FilterEnable = 0;
        else
            pDev->Framebuffer.FilterEnable = 2;
    }

    // Tiling is automatically done in the RM for most modes. This key allows us
    // to disable the auto tiling feature. Once enabled or disabled, it stays that way
    // till this registry key is changed. There is also a programmatic way of 
    // enabling and disabling auto tiling (ConfigSetEx). Right now, these two methods
    // can be freely mixed. i.e, the operation performed by the programmatic interface
    // can be undone by the registry flag and vice versa.
    if (osReadRegistryDword(pDev,strDevNodeRM, "AutoTilingOverride", &data32) == RM_OK) 
    {
        if (data32 == 0)
        {
            // Disable auto tiling.
            nvHalFbControl(pDev, FB_CONTROL_TILING_DISABLE);
        }
        else
        {
            // Enable tiling.
            nvHalFbControl(pDev, FB_CONTROL_TILING_ENABLE);
        }
    } // Auto tiling override
}

// Prepare the pDev for the new style mode set.
// This should be called by the legacy mode set flow only.
//
VOID osSetupForNewStyleModeSet(PHWINFO pDev)
{
#if 0 // this is an archaic, non-architectural function
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    RM_STATUS status;
    DISPLAYINFO tmpDisplayInfo;
    BOOL    optimalRefreshSelected;
    U032    monitorTimingMode;
    U032    UseDMTFlag;
    U032    tmpDMTFlag;
    BOOL    monitorIsGTF;
    U032    data32;
    MODE_TIMING_VALUES timingValues;
    unsigned int vesaStatus;
    BOOL arbitrationValidated;
    U032 numRefreshRates;
    U032 nextLower;
    int i;

    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
    ////OEMEnableExtensions();          // Unlock the registers before DDC
    EDIDRead(pDev, 0, GETDISPLAYTYPE(pDev, 0));
    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
    ////OEMDisableExtensions();         // Lock the registers

    // Figure out what monitor timing mode we want. It is controlled by a registry flag "MonitorTiming".
    monitorTimingMode = 0; // By default, read the EDID of the monitor.
    if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strMonitorTiming, &data32) == RM_OK)
    {
        monitorTimingMode = data32;
    }
    switch (monitorTimingMode)
    {
        case 1:
            // Use DMT.
            UseDMTFlag = TRUE;
            break;
        case 2:
            // Use GTF.
            UseDMTFlag = FALSE;
            break;
        case 3:
            // Legacy mode.
            // Read the legacy DMT Override flag to see if we should use DMT. Otherwise use GTF.
            UseDMTFlag = FALSE;
            if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strDMTOverride, &data32) == RM_OK)
            {
                if (data32 == 1)
                    UseDMTFlag = TRUE;
            }
            break;
        default:
            // Automatically set it by reading the EDID.
            UseDMTFlag = TRUE; // default to DMT
            if (EDIDIsMonitorGTF(pDev, &monitorIsGTF) == RM_OK)
            {
                UseDMTFlag = (monitorIsGTF) ? FALSE : TRUE;
            }
            break;
            // 
    }

    //
    // If there's an override setting for the refresh rate, use it instead
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strRefreshOverride, &data32) == RM_OK)
        pDev->Framebuffer.HalInfo.RefreshRate = data32;

    //
    // The GTF timings for 640x400 at 70Hz and 72Hz are drastically different than
    // the original VGA timings (which officially only list 85Hz as a support rate
    // at this resolution).  Therefore, when we attempt to set the GTF rates the
    // monitors just aren't happy.
    //
    // We have two choices.  Tweak our 70Hz and 72Hz GTF numbers to mimic VGA, or
    // just use IBM VGA (70Hz) for these two rates.  Since we're doing it right, and
    // the monitors just aren't happy, I vote for the latter.
    //
    // Remember that IBM VGA 640x400 starts at 70Hz, not 60Hz.
    //
    if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 400)
        && (pDev->Framebuffer.HalInfo.RefreshRate < 75))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; // this will kick in BIOS default values (70Hz)

    //
    // NV4 limits for hires modes at 32bpp.  Windows will still send down optimal values larger
    // than the limits we placed in our INF.  Don't let them through.
    //
    if (!IsNV5orBetter(pDev))
    {    
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1280) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1024)
            && (pDev->Dac.HalInfo.Depth >= 24)
            && (pDev->Framebuffer.HalInfo.RefreshRate > 100))
                pDev->Framebuffer.HalInfo.RefreshRate = 100; 
        
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1600) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200)
            && (pDev->Dac.HalInfo.Depth >= 24)
            && (pDev->Framebuffer.HalInfo.RefreshRate > 75))
                pDev->Framebuffer.HalInfo.RefreshRate = 75; 
        
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1920) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1080)
            && (pDev->Dac.HalInfo.Depth >= 24)
            && (pDev->Framebuffer.HalInfo.RefreshRate > 72))
                pDev->Framebuffer.HalInfo.RefreshRate = 72; 
        
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1920) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200)
            && (pDev->Dac.HalInfo.Depth >= 24)
            && (pDev->Framebuffer.HalInfo.RefreshRate > 60))
                pDev->Framebuffer.HalInfo.RefreshRate = 60; 
    }                
            
    //
    // There is a hardware bug in NV4's arbitration hardware having to do with memory refresh and
    // page misses.  This shows its ugly head during 64bit operation (8meg SDRAM).  If we see
    // a pixelclock setting above ~160Hz in 32bpp, drop it down to 60Hz.
    //
    // The user may have selected a different refresh rate (since the INF allows it), but they're
    // going to get 60Hz.  Sorry.
    //            
    // The highest resolution in 8meg is 1600x1200x32bpp, so just watch for that
    //
    if ((pDev->Chip.HalInfo.MaskRevision == NV_PMC_BOOT_0_MASK_REVISION_A)
        && (pDev->Dac.HalInfo.InputWidth == 64)
        && (pDev->Framebuffer.HalInfo.RamSizeMb == 8)
        && (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1600) 
        && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200)
        && (pDev->Dac.HalInfo.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 60))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; 

    //
    // Check if "optimal" refresh rate was chosen. 
    // When "optimal" is chosen, both min and max refresh rates in DISPLAYINFO will have non-zero values. 
    // When a specific refresh rate is chosen, max will have that value and the min will have zero. 
    // When "default" is chosen, both min and max will be zero.
    //    
    tmpDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &tmpDisplayInfo, sizeof(DISPLAYINFO));
    pDev->Framebuffer.RefreshRateType = NV_CFG_REFRESH_FLAG_SPECIFIC; // assume specific 
    if ((tmpDisplayInfo.RefreshRateMax != 0) && (tmpDisplayInfo.RefreshRateMin != 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "OPTIMAL REFRESH!!\n\r");

        // Save the fact that its optimal so we can inform the control panel
        pDev->Framebuffer.RefreshRateType = NV_CFG_REFRESH_FLAG_OPTIMAL; 
        // Try to get the max frequency for this mode from the EDID. 
        // If we get a refresh rate that is less than what we have now,
        // we will use the lower value.
        if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strOptimalNotFromEDID, &data32) != RM_OK)
        {
            // No registry entry that prohibits us from looking in the EDID.
            status = EDIDGetMaxRefreshRate(pDev, pDev->Framebuffer.HalInfo.HorizDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.VertDisplayWidth,
                                           &data32);
            if (status == RM_OK     && 
                data32 != 0 &&
                data32 < pDev->Framebuffer.HalInfo.RefreshRate)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = data32;
            }
        } // Get optimal from EDID

        // Read the registry to see if there is a limit for the "optimal" refresh rate.
        if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strMaxOptimalRefreshRate, &data32) == RM_OK)
        {
            // Ignore the value read if it is less than 60Hz.
            if (data32 >= 60 &&
                data32 < pDev->Framebuffer.HalInfo.RefreshRate)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = data32;
            }
        }
        
    } // else check if "default" refresh rate chosen
    else if ((tmpDisplayInfo.RefreshRateMax == 0) && (tmpDisplayInfo.RefreshRateMin == 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "ADAPTER DEFAULT REFRESH!!\n\r");
        
        // Save the fact that its default so we can inform the control panel
        pDev->Framebuffer.RefreshRateType = NV_CFG_REFRESH_FLAG_ADAPTER_DEFAULT; 
        pDev->Framebuffer.HalInfo.RefreshRate = 60;
    }        

    //
    // Attempt to workaround a Win95 bug with OPTIMAL and some Plug-n-Play monitors.
    //
    // When the user selects OPTIMAL from the control panel, the call to the VDD returns values to
    // the driver that look similar to a specific rate request (max != 0, min == 0) rather than 
    // looking like an OPTIMAL selection (max != 0, min != 0).
    //
    // Because of this misidentification of OPTIMAL, the MaxOptimalRefresh registry flag is ignored
    // and the rate goes higher than we want.   
    //
    // First check if we're on Win95 (CONFIG_MGR version 0x400)
    //
    if (CONFIGMG_Get_Version() < 0x40A)
    {
        U032 foundRate = 0;
        U032 optimalflag = 0;
        char config_settings[] = "CONFIG\\0000\\Display\\Settings";
        char config_key[] = "RefreshRate";
        U032 i;
        
        //
        // For safety, only check for this condition if there is a MaxOptimalRefresh flag present
        //
        if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strMaxOptimalRefreshRate, &data32) == RM_OK)
        {
            //
            // This is ugly, but look for the RefreshRate key in the HKLM\Config\000X\Display\...
            //
            // Remember, since this is Win95, we don't have to worry about multimonitor
            //
            for (i = 0; (i <= 9) && !foundRate; i++)
            {
                config_settings[10] = '0' + i;
            
                if (osReadRegistryDword(pDev,config_settings, config_key, &optimalflag) == RM_OK)
                    foundRate = 1;
            }                    
            
            //
            // We found a RefreshRate key in the display config.  Check if -1 (OPTIMAL)
            //
            if ((foundRate) && (((optimalflag & 0xFF) == '-') && (((optimalflag >> 8) & 0xFF) == '1')))
            {
                pDev->Framebuffer.RefreshRateType = NV_CFG_REFRESH_FLAG_OPTIMAL; 
                // Ignore the value read if it is less than 60Hz.
                if (data32 >= 60 &&
                    data32 < pDev->Framebuffer.HalInfo.RefreshRate)
                {
                    pDev->Framebuffer.HalInfo.RefreshRate = data32;
                }
            }
            
            //
            // VX700 workaround.  The Win95 PlugNPlay monitor INF incorrectly believes this particular
            // monitor can support up to 85Hz at 16x12.  Therefore the user is given the choice of
            // all possible rates up to 85.  The problem is that the monitor only supports up to
            // 65Hz.  Attempt to manually detect this specific monitor (by name, by detailed 16x12 timing)
            // and limit 16x12 to 60Hz in all cases. 
            //
            {
                U032 offset;
                
                offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * 2); // DETAILED BLOCK3
                
                // Look for VX700 descriptor
                if ((pDev->EDIDBuffer[offset+5] == 'V') &&
                    (pDev->EDIDBuffer[offset+6] == 'X') &&
                    (pDev->EDIDBuffer[offset+7] == '7') &&
                    (pDev->EDIDBuffer[offset+8] == '0') &&
                    (pDev->EDIDBuffer[offset+9] == '0'))
                {
             
                    offset = EDID_V1_DETAILED_TIMINGS_START_INDEX; // DETAILED BLOCK1
                
                    // Look for 173.0 MHz timing at 1600x1200
                    if ((pDev->EDIDBuffer[offset+0] == 0x94) &&   // here's the MHz
                        (pDev->EDIDBuffer[offset+1] == 0x43) &&
                        (pDev->EDIDBuffer[offset+2] == 0x40) &&   // here's the active horiz
                        (pDev->EDIDBuffer[offset+4] == 0x62))
                    {
                    
                        // Look for 1600x1200 requested resolution
                        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1600) && 
                            (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200))
                            pDev->Framebuffer.HalInfo.RefreshRate = 60; 
                    
                    }
                }
            }
             
            //
            // VX900 workaround.  The Win95 PlugNPlay monitor INF incorrectly believes this particular
            // monitor can support up to 85Hz at 16x12.  Therefore the user is given the choice of
            // all possible rates up to 85.  The problem is that the monitor only supports up to
            // 75Hz.  Attempt to manually detect this specific monitor (by name, by detailed 16x12 timing)
            // and limit 16x12 to 75Hz in all cases. 
            //
            {
                U032 offset;
                
                offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * 2); // DETAILED BLOCK3
                
                // Look for VX900 descriptor
                if ((pDev->EDIDBuffer[offset+13] == 'V') &&
                    (pDev->EDIDBuffer[offset+14] == 'X') &&
                    (pDev->EDIDBuffer[offset+15] == '9') &&
                    (pDev->EDIDBuffer[offset+16] == '0') &&
                    (pDev->EDIDBuffer[offset+17] == '0'))
                {
             
                    offset = EDID_V1_DETAILED_TIMINGS_START_INDEX; // DETAILED BLOCK1
                
                    // Look for 202.50 MHz timing at 1600x1200
                    if ((pDev->EDIDBuffer[offset+0] == 0x1A) &&   // here's the MHz
                        (pDev->EDIDBuffer[offset+1] == 0x4F) &&
                        (pDev->EDIDBuffer[offset+2] == 0x40) &&   // here's the active horiz
                        (pDev->EDIDBuffer[offset+4] == 0x62))
                    {
                    
                        // Look for 1600x1200 requested resolution
                        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1600) && 
                            (pDev->Framebuffer.HalInfo.VertDisplayWidth == 1200) &&
                            (pDev->Framebuffer.HalInfo.RefreshRate > 75))
                            pDev->Framebuffer.HalInfo.RefreshRate = 75; 
                    
                    }
                }
            }
             
            //
            // EV500/EV700 workaround.  The Win95 PlugNPlay monitor INF incorrectly believes this particular
            // monitor can support up to 100Hz at 10x7.  Therefore the user is given the choice of
            // all possible rates up to 100.  The problem is that the monitor only supports up to
            // 85Hz.  Attempt to manually detect this specific monitor (by name, by detailed 10x7 timing)
            // and limit 10x7 to 85Hz in all cases. 
            //
            {
                U032 offset;
                U032 block;
                
                offset = 0;
                
                // Look for the Gateway mfg descriptor
                if ((pDev->EDIDBuffer[offset+8] == 0x1E) &&
                    (pDev->EDIDBuffer[offset+9] == 0xF9))
                {
             
                    for (block = 0; block < 4; block++)
                    {
                        offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block); // DETAILED BLOCK N
                
                        // Look for 94.50 MHz timing at 1024x768; this translates to 85Hz
                        if ((pDev->EDIDBuffer[offset+0] == 0xEA) &&   // here's the MHz
                            (pDev->EDIDBuffer[offset+1] == 0x24) &&
                            (pDev->EDIDBuffer[offset+2] == 0x00) &&   // here's the active horiz
                            (pDev->EDIDBuffer[offset+4] == 0x41))
                        {
                        
                            // Look for 1024x768 requested resolution, cap to 85Hz
                            if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 1024) && 
                                (pDev->Framebuffer.HalInfo.VertDisplayWidth == 768) &&
                                (pDev->Framebuffer.HalInfo.RefreshRate > 85))
                                pDev->Framebuffer.HalInfo.RefreshRate = 85; 
                        
                        }
                    }                        
                }
            }
            
        }
    }        
    
    //
    // Safety: make sure we aren't working off a bogus refresh rate.  Cap us to some silly limit.
    //
    if (pDev->Framebuffer.HalInfo.RefreshRate > 1000)
        pDev->Framebuffer.HalInfo.RefreshRate = 60;
    
    //
    // If there's max refresh rate, make sure we don't exceed that.
    //
    if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strMaxRefreshRate, &data32) == RM_OK)
    {
        // Ignore the value read if it is less than 60Hz.
        if (data32 >= 60 &&
            pDev->Framebuffer.HalInfo.RefreshRate > data32)
        {
            pDev->Framebuffer.HalInfo.RefreshRate = data32;
        }
    }

    //
    // Most monitors can support the vert range of 800x600x150Hz but cannot support the
    // horiz range.  We removed 150Hz from the INF, but in case Windows tries it anyway,
    // override with one lower rate.
    //
    if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 800) && (pDev->Framebuffer.HalInfo.VertDisplayWidth == 600) 
        && (pDev->Framebuffer.HalInfo.RefreshRate > 144) && (pDev->Framebuffer.HalInfo.RefreshRate < 170))
    {
        pDev->Framebuffer.HalInfo.RefreshRate = 144;
    }                


    //
    // The documented method for Windows to select refresh rates for a display/monitor
    // combination is to take the intersection of the monitor INF entries (EDID) and
    // the display device's INF values.  This will then dictate the rates that are
    // valid for both devices.
    //
    // Unfortunately, it seems Microsoft didn't follow their own documentation in all
    // cases.  If a user selects OPTIMAL from the refresh rate menu, Windows will ask
    // us to set a refresh rate that matches the monitor information.  It doesn't matter
    // if the rate is beyond the display device's INF entries.
    //
    // Due to clocking differences between all of our shipping chips, we need to
    // validate all attempted refresh rates.  If a rate is beyond our device's limits
    // based on memory and clock variables, we need to attempt one refresh rate lower.
    // Luckily, the user has selected OPTIMAL and doesn't know exactly what rate she
    // is choosing.  If we drop it by one or two values, it doesn't really matter.
    //

    if (pDev->Framebuffer.HalInfo.RefreshRate == 0) // we'll be here an awfully long time if 
        pDev->Framebuffer.HalInfo.RefreshRate = 60; // refresh is set to 0

    arbitrationValidated = FALSE;
    while (!arbitrationValidated)
    {
        tmpDMTFlag = UseDMTFlag;
        if ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) && 
            (pDev->Framebuffer.HalInfo.VertDisplayWidth == 480)  &&
            (pDev->Framebuffer.HalInfo.RefreshRate == 60))
        {
            // force 640x480 @60Hz into DMT mode.
            tmpDMTFlag = UseDMTFlag = TRUE;
        }

        if (tmpDMTFlag)
        {
            // Get DMT timings for this mode. 
            vesaStatus = vesaGetDMTTimings(pDev->Framebuffer.HalInfo.HorizDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.VertDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.RefreshRate,
                                           &timingValues);
            // If we failed to get DMT timings for this mode, force GTF
            if (vesaStatus != 0)
            {
                tmpDMTFlag = FALSE;
            }
        }

        if (!tmpDMTFlag)
        {
            // Get the GTF timings
            vesaStatus = vesaGetGTFTimings(pDev->Framebuffer.HalInfo.HorizDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.VertDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.RefreshRate,
                                           &timingValues);
        }

        if (!vesaStatus)        
        {
            //
            // We found a rate match, so check if we can set valid arbitration for a clean screen
            //
            nvHalDacValidateArbSettings(pDev, 
                                        pDev->Dac.HalInfo.Depth, 
                                        0, 0, 
                                        (U032)(timingValues.PixelClock * 10000),
                                        0, &arbitrationValidated);
        }
        
        //
        // If both DMT and GTF lookups failed, we don't have a rate that matches the request.  Drop the
        // rate by one and try again.  Don't go below some really low number (say 45).
        //
        // Same thing goes for a rate that doesn't pass arbitration.  Drop on down.
        //
        if (!arbitrationValidated || vesaStatus)
        {
            //
            // Drop it, but don't go too low
            //
            if (--pDev->Framebuffer.HalInfo.RefreshRate < 45)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = 60;     // just assume 60Hz on a total failure
                pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;
                pDev->Framebuffer.HalInfo.VertDisplayWidth = 480;
                
                vesaStatus = vesaGetDMTTimings(pDev->Framebuffer.HalInfo.HorizDisplayWidth, 
                                               pDev->Framebuffer.HalInfo.VertDisplayWidth, 
                                               pDev->Framebuffer.HalInfo.RefreshRate,
                                               &timingValues);
                                               
                arbitrationValidated = TRUE;            //  and get out of here
            }
        
        
        }

    } // while arbitration is not validated.

    // Save off the timing values in the pDev.
    pDev->Dac.HorizontalVisible       = timingValues.HorizontalVisible;
    pDev->Dac.HorizontalBlankStart    = timingValues.HorizontalBlankStart;
    pDev->Dac.HorizontalRetraceStart  = timingValues.HorizontalRetraceStart;
    pDev->Dac.HorizontalRetraceEnd    = timingValues.HorizontalRetraceEnd;
    pDev->Dac.HorizontalBlankEnd      = timingValues.HorizontalBlankEnd;
    pDev->Dac.HorizontalTotal         = timingValues.HorizontalTotal;
    pDev->Dac.VerticalVisible         = timingValues.VerticalVisible;
    pDev->Dac.VerticalBlankStart      = timingValues.VerticalBlankStart;
    pDev->Dac.VerticalRetraceStart    = timingValues.VerticalRetraceStart;
    pDev->Dac.VerticalRetraceEnd      = timingValues.VerticalRetraceEnd;
    pDev->Dac.VerticalBlankEnd        = timingValues.VerticalBlankEnd;
    pDev->Dac.VerticalTotal           = timingValues.VerticalTotal;
    pDev->Dac.PixelDepth              = pDev->Dac.HalInfo.Depth;
    pDev->Dac.HalInfo.PixelClock      = timingValues.PixelClock;
    pDev->Dac.HorizontalSyncPolarity  = timingValues.HSyncpolarity;
    pDev->Dac.VerticalSyncPolarity    = timingValues.VSyncpolarity;
    pDev->Dac.DoubleScannedMode       = (pDev->Framebuffer.HalInfo.VertDisplayWidth < 400) ? TRUE : FALSE;
#endif
} // end of osSetupForNewStyleModeSet

// Os Specifix pre mode set actions.
VOID osPreModeSet(PHWINFO pDev, U032 Head)
{
    U032 DisplayType, data32;
    U032 PrimaryHead;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // Check for registry override for display type (TV/MONITOR/FLAT_PANEL)
    // Then check that the device is actually connected. If not, find one that is.

    // Get current display type for this head.
    DisplayType = GETDISPLAYTYPE(pDev, Head);

    // Determine which Head is the PrimaryDevice
    for (PrimaryHead = 0; PrimaryHead < pDev->Dac.HalInfo.NumCrtcs; PrimaryHead++)
    {
        if (pDev->Dac.CrtcInfo[PrimaryHead].PrimaryDevice == TRUE)
        {
            break;
        }
    }

    //
    // Canopus-specific code
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
    {
        if (DisplayType==DISPLAY_TYPE_MONITOR) {
            //if(!dacMonitorConnectStatus(pDev)&&dacFlatPanelConnectStatus(pDev))
            //  DisplayType = DISPLAY_TYPE_FLAT_PANEL;
        }
        else {
            if (dacMonitorConnectStatus(pDev, Head)&&!dacFlatPanelConnectStatus(pDev, Head)) {
                DisplayType = DISPLAY_TYPE_MONITOR;
                SETDISPLAYTYPE(pDev, Head, DisplayType);
            }
        }
    }            

    //
    // Reset TV output format value from registry.
    //
    if (dacReadTVOutFromRegistry(pDev, Head, &data32) == RM_OK)
        pDev->Dac.TVoutput = data32;

    // Set the DisplayChanged flag so we can signal the miniVDD that we are no longer on the same display.
    if (Head == PrimaryHead)    // only need to signal for primary
    {                           // if the display type in the object is different from the current display type (in HalInfo)
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        if (GETDISPLAYTYPE(pDev, Head) != pVidLutCurDac->DisplayType)
            pDev->Dac.DisplayChanged = 1;
        pDev->Dac.CurrentDisplay = GETDISPLAYTYPE(pDev, Head);
    }
}

// Os Specifix post mode set actions.
VOID osPostModeSet(PHWINFO pDev, U032 Head)
{
    PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    RM_STATUS status;
    U032      data32;
    U032      PrimaryHead;

    // Determine which Head is the PrimaryDevice
    for (PrimaryHead = 0; PrimaryHead < pDev->Dac.HalInfo.NumCrtcs; PrimaryHead++)
    {
        if (pDev->Dac.CrtcInfo[PrimaryHead].PrimaryDevice == TRUE)
        {
            break;
        }
    }

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        dacSetBiosDefaultTVType(pDev, pDev->Dac.TVStandard);

    //
    // Notify the Win9X minivdd that a mode change has probably occurred. This allows
    // it to save any new register states. This is only done for the PrimaryDevice.
    //
    if (Head == PrimaryHead)
    {
        if (pOsHwInfo->miniVDDPostModeChange)  // if primary display, we got callback at init
            if (pDev->Dac.DisplayChanged)
                (*pOsHwInfo->miniVDDPostModeChange)(1);    // signal display change
            else
                (*pOsHwInfo->miniVDDPostModeChange)(0);
        pDev->Dac.DisplayChanged = 0;

        //
        // At the completetion of this modeset, check if there's been a modeset
        // on the other head, if not, call dacDisableDac on that head.
        //
        if (pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == (VOID_PTR)NULL)
            dacDisableDac(pDev, Head^1);
    }

    // See if there are any registry overrides for the desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR)
    {
        U032 cbLen;
        NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS position;

        cbLen = 4 * sizeof(U032);
        status = dacReadDesktopPositionFromRegistry(pDev, Head,
                                                    TRUE,  // isMonitor
                                                    (U008 *) &(position.HRetraceStart),
                                                    &cbLen);
        if (status == RM_OK)
        {
            // Program the new values.
            dacSetMonitorPosition(pDev, Head, 
                                  position.HRetraceStart, position.HRetraceEnd,
                                  position.VRetraceStart, position.VRetraceEnd);
        }
    }
    // See if there are any registry overrides for the monitor timing.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR)
    {
        NV_CFGEX_CRTC_TIMING_PARAMS timings;

        //
        // First check if there are timings available in the registry for this mode
        //
        timings.Head = Head;
        timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTRY;
        status = dacGetCRTCTiming(pDev, Head, &timings);

        if (status == RM_OK)
        {
            //
            // Program the new values
            //
            timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
            status = dacSetCRTCTiming(pDev, Head, &timings);
        }

    }
    // See if there are any registry overrides for the TV desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV) 
    {
        U032 cbLen;
        NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS Params;

        // Read the registry to get any updates to the default setting.
        // This should be done after dacAdjustCRTCForTV because it involves changes to CRTC.
        cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
        status = dacReadTVDesktopPositionFromRegistry(pDev, Head, (U008 *) &Params, &cbLen);

        // Make sure data is valid for the current encoder.
        if ((status == RM_OK) && (Params.Encoder_ID == pDev->Dac.EncoderType))
        {
            // Write the saved settings
            dacSetTVPosition(pDev, Head, (U032 *) &Params);
        }
        if (!pDev->Power.MobileOperation)
        {
            dacWriteTVStandardToRegistry(pDev, pDev->Dac.TVStandard);   // save TV standard in registry
        }

    }
    
    // Check/Set any PFB overrides
    if (osReadRegistryDword(pDev,strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }
    if (osReadRegistryDword(pDev,strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_RTL, data32);
    }
    else
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_RTL, 0);
    }

    //
    // If there are graphics debug overrides, use them now
    //
    if (osReadRegistryDword(pDev,strDevNodeRM, strGraphicsDebug0, &data32) == RM_OK)
    {
        nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_DEBUG0, data32);
    }
    if (osReadRegistryDword(pDev,strDevNodeRM, strGraphicsDebug1, &data32) == RM_OK)
    {
        nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_DEBUG1, data32);
    }
    if (osReadRegistryDword(pDev,strDevNodeRM, strGraphicsDebug2, &data32) == RM_OK)
    {
        nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_DEBUG2, data32);
    }
    if (osReadRegistryDword(pDev,strDevNodeRM, strGraphicsDebug3, &data32) == RM_OK)
    {
        nvHalGrLoadOverride(pDev, GR_LOAD_OVERRIDE_DEBUG3, data32);
    }
    
    //
    // Use the display cursor cache override if available
    //
    if (osReadRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplay, strCursorCacheOverride, &data32) == RM_OK)
    {
        if (data32 == 0)
            pDev->Dac.CursorCacheEnable = 0;
        else            
            pDev->Dac.CursorCacheEnable = 1;
    }
} // end of osPostModeSet

// Registry access functions.
RM_STATUS osReadRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 *cbLen
)
{
    U032 cbType;
    U032 hkSW;
    U032 ret;

    //
    // Get access to specified Device Node in the registry.
    //
    if (VMM_RegOpenKey(HKEY_LOCAL_MACHINE, regDevNode, (PVMMHKEY)&hkSW) != 0)
        return (RM_ERROR);

    if (hkSW)
    {
        cbType = REG_BINARY;

        // Is this a request to read Global Data ?
        if(regDevNode == strDevNodeRM){
            // Then just read from the global location.
            ret = VMM_RegQueryValueEx(hkSW, regParmStr, NULL, &cbType, (PBYTE)Data, cbLen);
            if (ret != 0L){
                VMM_RegCloseKey(hkSW);
                return (RM_ERROR);
            }
        }else{
            // First attempt to read the data value from the Global area.
            // Then go to the device specific location.
            ret = VMM_RegQueryValueEx(hkSW, strDevNodeRM, NULL, &cbType, (PBYTE)Data, cbLen);
            if (ret != 0L){
                ret = VMM_RegQueryValueEx(hkSW, regParmStr, NULL, &cbType, (PBYTE)Data, cbLen);
                if (ret != 0L){
                    VMM_RegCloseKey(hkSW);
                    return (RM_ERROR);
                }
            }

        }

        VMM_RegCloseKey(hkSW);
    }
    return (RM_OK);
} // end of osReadRegistryBinary

RM_STATUS osWriteRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 cbLen
)
{
    U032 cbType;
    U032 hkSW;
    U032 ret;

    //
    // Get access to specified Device Node in the registry.
    //
    if (VMM_RegCreateKey(HKEY_LOCAL_MACHINE, regDevNode, (PVMMHKEY)&hkSW) != 0)
        return (RM_ERROR);
    if (hkSW)
    {
        //
        // Write the specified parameter to the registry. (REG_DWORD = 4)
        //
        cbType = REG_BINARY;
        ret = VMM_RegSetValueEx(hkSW, regParmStr, NULL, cbType, Data, cbLen);
        VMM_RegCloseKey(hkSW);
        if (ret != 0L)
            return (RM_ERROR);
    }
    return (RM_OK);
} // end of osWriteRegistryBinary

RM_STATUS osReadRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 *Data
)
{
    U032 cbLen;

    cbLen = 4;
    return osReadRegistryBinary(pDev,regDevNode, regParmStr, (U008 *)Data, &cbLen);
} // end of osReadRegistryDword

RM_STATUS osWriteRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 Data
)
{
    U032 cbLen = 4;
    return osWriteRegistryBinary(pDev,regDevNode, regParmStr, (U008 *)&Data, cbLen);
}

RM_STATUS osDeleteRegistryValue
(
    char *regDevNode,
    char *regParmStr
)
{
    U032 hkSW;
    RM_STATUS status;

    if (VMM_RegOpenKey(HKEY_LOCAL_MACHINE, regDevNode, (PVMMHKEY)&hkSW) != 0)
        return (RM_ERROR);

    if (hkSW) {
        status = VMM_RegDeleteValue(hkSW, regParmStr);
        VMM_RegCloseKey(hkSW);
        return status;
    }
}
    
// We have found that during shutdown (and other instances) Win98 disables the memory mapping
// of the device. This procedure is a workaround for this problem. 
// It is assumed that the global DeviceInstance is set to indicate the desired device.
VOID osEnsureDeviceEnabled(PHWINFO pDev)
{
    U032 bar0_address, pci_address, pci_reg, i;

    //Check if we're in powerdown otherwise we would hang.
    if (pDev->Power.State == MC_POWER_LEVEL_2)
    {
        DBG_BREAKPOINT();
        return;
    }

    bar0_address = pDev->Chip.HalInfo.PciBars[0];
    pci_address = pDev->Mapping.nvBusDeviceFunc;

    if(pDev != NULL && nvAddr->Reg032[0]==0xffffffff)
    {   // The device is disabled.
            
        _asm mov  dx, 0xcf8
        _asm in   eax, dx
        _asm push eax
        _asm mov  eax, pci_address  
        _asm or   eax, 0x80000004 
        _asm out  dx, eax
        _asm mov  dx, 0xcfc
        _asm in   al,dx
        // Enable the memory decode and BusmasterEnable of the PCIO device.
        _asm or   al,6
        _asm out  dx,al
        _asm pop  eax
        _asm mov  dx, 0xcf8
        _asm out  dx, eax
    }

    //Make sure our PCI BAR addresses is what we expect it to be.
    //In some cases we may be moved (which we should not be)
    //or Windows may fail to restore our address. 

    if ((pDev != NULL) && (bar0_address != REG_RD32(NV_PBUS_PCI_NV_4))) 
    {
        for (i = 0, pci_reg = 0x80000010; i < pDev->Chip.HalInfo.TotalPciBars; i++, pci_reg += 4)
        {
            U032 barN_address = pDev->Chip.HalInfo.PciBars[i];

            _asm mov  dx, 0xcf8
            _asm in   eax, dx
            _asm push eax
            _asm mov  eax, pci_address  
            _asm or   eax, pci_reg
            _asm out  dx, eax
            _asm mov  dx, 0xcfc
            _asm mov  eax, barN_address
            _asm out  dx, eax 
            _asm pop  eax
            _asm mov  dx, 0xcf8
            _asm out  dx, eax
        }
    }
}

RM_STATUS osDeviceNameToDeviceClass
(
    char * deviceName,
    U032 * deviceClass
)
{
    RM_STATUS rmStatus = RM_OK;
    U032      deviceIndex;
    U032      deviceNameLen;
    
    switch (*deviceClass) 
    {
        case NV01_DEVICE_0:
        case NV01_DEVICE_1:
        case NV01_DEVICE_2:
        case NV01_DEVICE_3:
        case NV01_DEVICE_4:
        case NV01_DEVICE_5:
        case NV01_DEVICE_6:
        case NV01_DEVICE_7:
            // Nothing to do.
            return RM_OK;
            
        case NV03_DEVICE_XX:
            // Search all the nvinfo structures for a match on device name.
            // All secondary displays will have a non null string in pDev.
            deviceNameLen = osStringLength(deviceName);
            if ((deviceName[deviceNameLen - 1] == '1')  ||
                (deviceName[deviceNameLen - 1] == 'y')  ||
                (deviceName[deviceNameLen - 1] == 'Y'))
            {
                // This must be the Primary display.
                *deviceClass = NV01_DEVICE_0;
                return RM_OK;
            }
            
            for (deviceIndex = 0; deviceIndex < MAX_INSTANCE; deviceIndex++)
            {
                if (NvDBPtr_Table[deviceIndex] != 0)
                {
					PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) &NvDBPtr_Table[deviceIndex];

                    // This device is allocated. 
                    if ((pOsHwInfo->osDeviceName != 0)  &&
                        (osStringCompare(pOsHwInfo->osDeviceName, deviceName)))
                    {
                        // found a match.
                        *deviceClass = deviceIndex + NV01_DEVICE_0;
                        return RM_OK;   
                    }
                } // Device is allocated
            }
            
            // Could not find a match
            return RM_ERROR;
                
        default:
            // invalid device class.
            return RM_ERROR;
    }
}

//
// Read a data word from Priveledged IO
//
// Entry: U032 addr                // Address of controller register
//        U008 reg                 // CR/GR/SR register to read
//
// Exit:  index/data pair
//
U016 ReadIndexedpDev(PHWINFO pDev, U032 addr, U008 reg)
{      
    U016 datum;
              
    //
    // Return the data in the upper byte, index in the lower
    //
    REG_WR08(addr, reg);
    datum = (REG_RD08(addr+1) << 8) & 0xFF00;
    datum |= reg;
    
    return(datum);
}                          


//
// Function call entry to reach the video (VGA) BIOS for various needs.  In general you
// should not rely on, or attempt to call, the BIOS for any support.  Many systems do
// not even carry a copy of the video BIOS in memory.
//
// Be very very sure you need to make such calls, even if they are possible.
//
RM_STATUS osCallVideoBIOS
(
    PHWINFO pDev,
    U032    *pEAX,
    U032    *pEBX,
    U032    *pECX,
    U032    *pEDX,
    VOID    *pBuffer
)
{

    CLIENT_STRUCT     crs;

    // 
    // If no buffer data to pass, use standard Int10h interface
    //
    if (pBuffer == NULL)
    {
        // only care about the lower 16bits
        crs.CWRS.Client_AX = (U016)*pEAX;
        crs.CWRS.Client_BX = (U016)*pEBX;
        crs.CWRS.Client_CX = (U016)*pECX;
        crs.CWRS.Client_DX = (U016)*pEDX;
        VBE(&crs);
        *pEAX = (U032)crs.CWRS.Client_AX;
        *pEBX = (U032)crs.CWRS.Client_BX;
        *pECX = (U032)crs.CWRS.Client_CX;
        *pEDX = (U032)crs.CWRS.Client_DX;
    } 
    else
    {
        //
        // Otherwise construct data-passing interface
        //
        crs.CWRS.Client_AX = (U016)*pEAX;
        crs.CWRS.Client_BX = (U016)*pEBX;
        crs.CWRS.Client_CX = (U016)*pECX;
        crs.CWRS.Client_DX = (U016)*pEDX;
        crs.CRS.Client_ES = 0x0000;         // flat for now
        crs.CRS.Client_EDI = (U032)pBuffer;
        readToshibaEDID(&crs);              // special case call for EDID; really should
                                            // convert to common call!!!
        *pEAX = (U032)crs.CWRS.Client_AX;
        *pEBX = (U032)crs.CWRS.Client_BX;
        *pECX = (U032)crs.CWRS.Client_CX;
        *pEDX = (U032)crs.CWRS.Client_DX;
    }
                            

    if (crs.CWRS.Client_AX == 0x004F)
        return RM_OK;
    else
        return (RM_STATUS)(crs.CWRS.Client_AX);

}

/*

// KEEP AROUND FOR JUST A BIT LONGER

U008 convToToshibaDispMask(PHWINFO pDev, U032 disptype)
{
    if (disptype == DISPLAY_TYPE_FLAT_PANEL) return 1;
    else if (disptype == DISPLAY_TYPE_MONITOR) return 2;
    else if (disptype == DISPLAY_TYPE_TV) return 4;

    return 0;
}


// Function: osGenerateInt10h
//
// Generalized mechanism to pass parameters to VGA BIOS with an int10h call.
// Added to allow communication with the System BIOS (using VGA BIOS as a
// pass-through) in (Toshiba) mobile systems.
// 
// The creation of the display masks loaded into Dl and DH for the DEV_CTRL
// events has not yet been tested, though the other parameters for those calls
// have been.
//
// This function in currently only using the EDID read.  Note that this is
// a Win9x only mechanism -- the most likely final implementation will be
// a custom int10h that causes our BIOS to put the EDID somewhere in our
// frame buffer memory.
//
// Parameters:  pDev
//              event: an event code (defined in os.h)
//              Head: head (0 or 1) -- ignored for EDID read
//              param1: event-specific parameter
//                  (for TOSHIBA_DEV_CTRL_BEGIN, the display this head is switching to
//                   -- 0 if it is being disabled)
//              pEDID: pointer to a 128 byte buffer to copy the EDID into
//
RM_STATUS  osGenerateInt10h(PHWINFO pDev, U032 event, U032 Head, U032 param1, VOID* pEDID)
{
    CLIENT_STRUCT     crs;

    if (!pDev->Power.MobileOperation) return RM_OK;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: making int10h call for event:", event);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: making int10h call for head:", Head);

    crs.CRS.Client_ES = 0x0000;
    crs.CWRS.Client_CX = 0x0000;
    crs.CWRS.Client_DX = 0x0000;

    switch(event) {
    case TOSHIBA_READ_EDID:
        crs.CWRS.Client_AX = 0x4F15;
        crs.CWRS.Client_BX = 0x0001;
        crs.CWRS.Client_CX = 0;  //(U016)Head;  //'controller number' == head, or is primary always 0?
        crs.CWRS.Client_DX = 0x0000;    //EDID block number?
        crs.CRS.Client_EDI = (U032)pEDID;
//        VBE(&crs);
        readToshibaEDID(&crs);
        break;
    case TOSHIBA_DEV_CTRL_BEGIN:
        crs.CWRS.Client_AX = 0x4F14;
        crs.CWRS.Client_BX = 0x028F;
//        crs.CWRS.Client_DX = 0x0202;    //temp
        crs.CBRS.Client_DL = convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head))
            | convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head^1));
        crs.CBRS.Client_DH = convToToshibaDispMask(pDev, param1)
            | convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head^1));
        VBE(&crs);
        break;
    case TOSHIBA_DEV_CTRL_END:
        crs.CWRS.Client_AX = 0x4F14;
        crs.CWRS.Client_BX = 0x038F;
        crs.CBRS.Client_DL = convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head))
            | convToToshibaDispMask(pDev, GETDISPLAYTYPE(pDev, Head^1));
        crs.CBRS.Client_DH = 0;
        VBE(&crs);
        break;
    }

    if (crs.CWRS.Client_AX == 0x004F)
        return RM_OK;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: int10h call returned error:", crs.CWRS.Client_AX);

    return RM_ERROR;
}
*/


#if DEBUG
//---------------------------------------------------------------------------
//
//  Debugging support.
//
//---------------------------------------------------------------------------

// The current debug display level 
//
// Best to leave it above setup and trace messages, but below warnings and error messages
//
int cur_debuglevel = DBG_LEVEL_DEFAULTS;    // all modules set to warning level

int dbgObject_inuse = DBG_OBJECT_OS; 
   
DBGOBJECT DbgObject[] = { 
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // Standard Debug
    {dbgConfigNull, dbgInitSerial, dbgOpenNull, dbgDisplaySerial, dbgCloseNull},    // Serial
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // Parallel
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // Infrared
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // USB
    {dbgConfigNull, dbgInitNull, dbgOpenNull, vmmOutDebugString, dbgCloseNull},     // I2C
};

VOID osDbgBreakPoint
(
    void
)
{
    dbgBreakPoint();
}

VOID osDbgPrintf_va(
    int     module,
    int     debuglevel,
    const char *printf_format,
    va_list arglist)
{
    int     moduleValue = cur_debuglevel;
    char    nv_error_string[MAX_ERROR_STRING];
    char    *p = nv_error_string;
    int     chars_written;

    // get the module
    // put the module we want in the first 2 bits
    moduleValue = moduleValue >> (module * 2);

    // get the value of those two bits
    // mask off the last 30 bits
    moduleValue = moduleValue & 0x00000003;

   if (debuglevel >= moduleValue)
   {
        chars_written = nvDbgSprintf(p, printf_format, arglist);

        DbgObject[dbgObject_inuse].pDisplay(p);
   }
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nvwatch.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NV3Watch.C                                                        *
*   Winice .N Debug Interface.                                              *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito 9/23/98 - wrote it.                                        *
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <nvromdat.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <heap.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"

//
// These defines are in the chip-dependent headers.  Rather than
// create a big mess by trying to #include them here, just pull what
// we need.
//

// hash table offset
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */

#ifdef DEBUG


//
// prototypes
//
RM_STATUS btreeNodeValidate                 (PNODE);
VOID    NvWatch_MTRR_RegisterStuff          (VOID);
VOID    NvWatch_QuickDiag_fifo              (PHWINFO, PNVWATCHDIAGSTRUCT);
VOID    NvWatch_QuickDiag_master            (PHWINFO, PNVWATCHDIAGSTRUCT);
U032    NvWatch_NV04_GetHashSize            (PHWINFO);
VOID    NvWatch_NV04_Dump_Fifo              (PHWINFO);
VOID    NvWatch_NV04_Dump_Graphics          (PHWINFO);
VOID    NvWatch_NV04_Dump_Master            (PHWINFO);
VOID    NvWatch_NV04_Dump_Video             (PHWINFO);
VOID    NvWatch_NV04_Query_DeviceContext    (PHWINFO);
int     NvWatch_NV04_DmaPushAndFifo         (PHWINFO);
VOID    NvWatch_NV04_FillDiagStruct         (PHWINFO, PNVWATCHDIAGSTRUCT);
VOID    NvWatch_NV04_DumpGrTableContents    (PHWINFO, U032);
VOID    NvWatch_NV10_DumpGrTableContents    (PHWINFO, U032);
U032    NvWatch_NV10_GetHashSize            (PHWINFO);
VOID    NvWatch_NV10_Dump_Fifo              (PHWINFO);
VOID    NvWatch_NV10_Dump_Graphics          (PHWINFO);
VOID    NvWatch_NV10_Dump_Master            (PHWINFO);
VOID    NvWatch_NV10_Dump_Video             (PHWINFO);
VOID    NvWatch_NV10_Query_DeviceContext    (PHWINFO);
int     NvWatch_NV10_DmaPushAndFifo         (PHWINFO);


// Crush11 will have 512 64KB Mapping regions. 32MB Maximum.								  
// 16 4KB PTE's will define the physical memory	for each of the 64KB blocks.
#define NVWATCH_MAX_MEM_BLOCKS 512        
#define NUM_PAGES_FOR_A_64KB_BLOCK  0x10
#define NVWATCH_MAX_PAGES_PER_BLOCK NUM_PAGES_FOR_A_64KB_BLOCK

void *nvwatch_block_buffers[NVWATCH_MAX_MEM_BLOCKS]; /* up to 64K blocks*/
U032 nvwatch_PageArray[NVWATCH_MAX_MEM_BLOCKS][NVWATCH_MAX_PAGES_PER_BLOCK];
U032 nvwatch_crush11_failed_data;
U032 NvWatch_num_objects; 
//U032 NvWatch_channel;
char NvWatch_ObjectStrings[][33]={"NV01_NULL_OBJECT                ", /*    (0x00000000) */
                                  "NV01_CLASS                      ", /*    (0x00000001) */
                                  "NV01_CONTEXT_DMA_FROM_MEMORY    ", /*    (0x00000002) */
                                  "NV01_CONTEXT_DMA_TO_MEMORY      ", /*    (0x00000003) */
                                  "NV01_TIMER                      ", /*    (0x00000004) */
                                  "UNDEFINED_CLASS_Nv005           ", /*                 */
                                  "UNDEFINED_CLASS_Nv006           ", /*                 */
                                  "UNDEFINED_CLASS_Nv007           ", /*                 */
                                  "UNDEFINED_CLASS_Nv008           ", /*                 */
                                  "UNDEFINED_CLASS_Nv009           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00b           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00c           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00d           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00e           ", /*                 */
                                  "UNDEFINED_CLASS_Nv00f           ", /*                 */
                                  "UNDEFINED_CLASS_Nv010           ", /*                 */
                                  "UNDEFINED_CLASS_Nv011           ", /*                 */
                                  "NV01_BETA_SOLID                 ", /*    (0x00000012) */
                                  "UNDEFINED_CLASS_Nv013           ", /*                 */
                                  "UNDEFINED_CLASS_Nv014           ", /*                 */
                                  "UNDEFINED_CLASS_Nv015           ", /*                 */
                                  "UNDEFINED_CLASS_Nv016           ", /*                 */
                                  "NV01_IMAGE_SOLID                ", /*    (0x00000017) */
                                  "NV01_IMAGE_PATTERN              ", /*    (0x00000018) */
                                  "NV01_IMAGE_BLACK_RECTANGLE      ", /*    (0x00000019) */
                                  "UNDEFINED_CLASS_Nv01a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv01b           ", /*                 */
                                  "NV01_RENDER_SOLID_LIN           ", /*    (0x0000001C) */
                                  "NV01_RENDER_SOLID_TRIANGLE      ", /*    (0x0000001D) */
                                  "NV01_RENDER_SOLID_RECTANGLE     ", /*    (0x0000001E) */
                                  "NV01_IMAGE_BLIT                 ", /*    (0x0000001F) */
                                  "UNDEFINED_CLASS_Nv020           ", /*                 */
                                  "NV01_IMAGE_FROM_CPU             ", /*    (0x00000021) */
                                  "UNDEFINED_CLASS_Nv022           ", /*                 */
                                  "UNDEFINED_CLASS_Nv023           ", /*                 */
                                  "UNDEFINED_CLASS_Nv024           ", /*                 */
                                  "UNDEFINED_CLASS_Nv025           ", /*                 */
                                  "UNDEFINED_CLASS_Nv026           ", /*                 */
                                  "UNDEFINED_CLASS_Nv027           ", /*                 */
                                  "UNDEFINED_CLASS_Nv028           ", /*                 */
                                  "UNDEFINED_CLASS_Nv029           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02b           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02c           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02d           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02e           ", /*                 */
                                  "UNDEFINED_CLASS_Nv02f           ", /*                 */
                                  "NV01_NULL                       ", /*    (0x00000030) */
                                  "UNDEFINED_CLASS_Nv031           ", /*                 */
                                  "UNDEFINED_CLASS_Nv032           ", /*                 */
                                  "UNDEFINED_CLASS_Nv033           ", /*                 */
                                  "UNDEFINED_CLASS_Nv034           ", /*                 */
                                  "UNDEFINED_CLASS_Nv035           ", /*                 */
                                  "NV03_STRETCHED_IMAGE_FROM_CPU   ", /*    (0x00000036) */
                                  "NV03_SCALED_IMAGE_FROM_MEMORY   ", /*    (0x00000037) */
                                  "NV04_DVD_SUBPICTURE             ", /*    (0x00000038) */
                                  "NV03_MEMORY_TO_MEMORY_FORMAT    ", /*    (0x00000039) */
                                  "UNDEFINED_CLASS_Nv03a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv03b           ", /*                 */
                                  "UNDEFINED_CLASS_Nv03c           ", /*                 */
                                  "NV01_CONTEXT_DMA_IN_MEMORY      ", /*    (0x0000003D) */
                                  "NV01_CONTEXT_ERROR_TO_MEMORY    ", /*    (0x0000003E) */
                                  "NV01_MEMORY_PRIVILEGED          ", /*    (0x0000003F) */
                                  "NV01_MEMORY_USER                ", /*    (0x00000040) */
                                  "UNDEFINED_CLASS_Nv041           ", /*                 */
                                  "NV04_CONTEXT_SURFACES_2D        ", /*    (0x00000042) */
                                  "NV03_CONTEXT_ROP                ", /*    (0x00000043) */
                                  "NV04_CONTEXT_PATTERN            ", /*    (0x00000044) */
                                  "UNDEFINED_CLASS_Nv045           ", /*                 */
                                  "NV04_VIDEO_LUT_CURSOR_DAC       ", /*    (0x00000046) */
                                  "UNDEFINED_CLASS_Nv047           ", /*                 */
                                  "NV03_DX3_TEXTURED_TRIANGLE      ", /*    (0x00000048) */
                                  "UNDEFINED_CLASS_Nv049           ", /*                 */
                                  "NV04_GDI_RECTANGLE_TEXT         ", /*    (0x0000004A) */
                                  "NV03_GDI_RECTANGLE_TEXT         ", /*    (0x0000004B) */
                                  "UNDEFINED_CLASS_Nv04c           ", /*                 */
                                  "NV03_EXTERNAL_VIDEO_DECODER     ", /*    (0x0000004D) */
                                  "NV03_EXTERNAL_VIDEO_DECOMPRESSOR", /*    (0x0000004E) */
                                  "NV01_EXTERNAL_PARALLEL_BUS      ", /*    (0x0000004F) */
                                  "NV03_EXTERNAL_MONITOR_BUS       ", /*    (0x00000050) */
                                  "NV03_EXTERNAL_SERIAL_BUS        ", /*    (0x00000051) */
                                  "NV04_CONTEXT_SURFACE_SWIZZLED   ", /*    (0x00000052) */
                                  "NV04_CONTEXT_SURFACES_3D        ", /*    (0x00000053) */
                                  "NV04_DX5_TEXTURED_TRIANGLE      ", /*    (0x00000054) */
                                  "NV04_DX6_MULTI_TEXTURE_TRIANGLE ", /*    (0x00000055) */
                                  "UNDEFINED_CLASS_Nv056           ", /*                 */
                                  "NV04_CONTEXT_COLOR_KEY          ", /*    (0x00000057) */
                                  "NV03_CONTEXT_SURFACE_0          ", /*    (0x00000058) */
                                  "NV03_CONTEXT_SURFACE_1          ", /*    (0x00000059) */
                                  "NV03_CONTEXT_SURFACE_2          ", /*    (0x0000005A) */
                                  "NV03_CONTEXT_SURFACE_3          ", /*    (0x0000005B) */
                                  "NV04_RENDER_SOLID_LIN           ", /*    (0x0000005C) */
                                  "NV04_RENDER_SOLID_TRIANGLE      ", /*    (0x0000005D) */
                                  "NV04_RENDER_SOLID_RECTANGLE     ", /*    (0x0000005E) */
                                  "NV04_IMAGE_BLIT                 ", /*    (0x0000005F) */
                                  "NV04_INDEXED_IMAGE_FROM_CPU     ", /*    (0x00000060) */
                                  "NV04_IMAGE_FROM_CPU             ", /*    (0x00000061) */
                                  "NV010_CONTEXT_SURFACES_2D       ", /*                 */
                                  "NV05_SCALED_IMAGE_FROM_MEMORY   ", /*    (0x00000063) */
                                  "NV05_INDEXED_IMAGE_FROM_CPU     ", /*    (0x00000064) */
                                  "NV05_IMAGE_FROM_CPU             ", /*    (0x00000065) */
                                  "NV05_STRETCHED_IMAGE_FROM_CPU   ", /*    (0x00000066) */
                                  "NV10_VIDEO_LUT_CURSOR_DAC       ", /*                 */
                                  "UNDEFINED_CLASS_Nv068           ", /*                 */
                                  "UNDEFINED_CLASS_Nv069           ", /*                 */
                                  "NV03_CHANNEL_PIO                ", /*    (0x0000006A) */
                                  "NV03_CHANNEL_DMA                ", /*    (0x0000006B) */
                                  "NV04_CHANNEL_DMA                ", /*    (0x0000006C) */
                                  "UNDEFINED_CLASS_Nv06d           ", /*                 */
                                  "NV10_CHANNEL_DMA                ", /*                 */
                                  "UNDEFINED_CLASS_Nv06f           ", /*                 */
                                  "UNDEFINED_CLASS_Nv070           ", /*                 */
                                  "UNDEFINED_CLASS_Nv071           ", /*                 */
                                  "NV04_CONTEXT_BETA               ", /*    (0x00000072) */
                                  "UNDEFINED_CLASS_Nv073           ", /*                 */
                                  "UNDEFINED_CLASS_Nv074           ", /*                 */
                                  "UNDEFINED_CLASS_Nv075           ", /*                 */
                                  "NV04_STRETCHED_IMAGE_FROM_CPU   ", /*    (0x00000076) */
                                  "NV04_SCALED_IMAGE_FROM_MEMORY   ", /*    (0x00000077) */
                                  "UNDEFINED_CLASS_Nv078           ", /*                 */
                                  "UNDEFINED_CLASS_Nv079           ", /*                 */
                                  "NV10_VIDEO_OVERLAY              ", /*                 */
                                  "NV10_TEXTURE_FROM_CPU           ", /*                 */
                                  "UNDEFINED_CLASS_Nv07c           ", /*                 */
                                  "UNDEFINED_CLASS_Nv07d           ", /*                 */
                                  "UNDEFINED_CLASS_Nv07e           ", /*                 */
                                  "UNDEFINED_CLASS_Nv07f           ", /*                 */
                                  "NV01_DEVICE_0                   ", /*    (0x00000080) */
                                  "NV01_DEVICE_1                   ", /*    (0x00000081) */
                                  "NV01_DEVICE_2                   ", /*    (0x00000082) */
                                  "NV01_DEVICE_3                   ", /*    (0x00000083) */
                                  "NV01_DEVICE_4                   ", /*    (0x00000084) */
                                  "NV01_DEVICE_5                   ", /*    (0x00000085) */
                                  "NV01_DEVICE_6                   ", /*    (0x00000086) */
                                  "NV01_DEVICE_7                   ", /*    (0x00000087) */
                                  "NV10_DVD_SUBPICTURE             ", /*    (0x00000088) */
                                  "NV10_SCALED_IMAGE_FROM_MEMORY   ", /*    (0x00000089) */
                                  "UNDEFINED_CLASS_Nv08a           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08b           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08c           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08d           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08e           ", /*                 */
                                  "UNDEFINED_CLASS_Nv08f           ", /*                 */
                                  "UNDEFINED_CLASS_Nv090           ", /*                 */
                                  "UNDEFINED_CLASS_Nv091           ", /*                 */
                                  "UNDEFINED_CLASS_Nv092           ", /*                 */
                                  "NV10_CONTEXT_SURFACES_3D        ", /*    (0x00000093) */
                                  "NV10_DX5_TEXTURED_TRIANGLE      ", /*    (0x00000094) */
                                  "NV10_DX6_MULTI_TEXTURE_TRIANGLE ", /*    (0x00000095) */
                                  "ERROR: CLASS # TOO LARGE !!!    "}; /*    (>95) */

#define MAX_CLASS_NUMBER_SUPPORTED 0x95      
// This would be different for NV3.
#define INSTANCE_MEM_SPACE        nvAddr 

#define NVWATCH_SIMPLE 0
#define NVWATCH_COMPLEX 1
#define CurrentPatch    upatch.CurrentPatchNV10

// Internal dispatch defines.
#define NVWATCH_FUNC_GETHASHSIZE         0
#define NVWATCH_FUNC_DUMP_FIFO           1
#define NVWATCH_FUNC_DUMP_GRAPHICS       2
#define NVWATCH_FUNC_DUMP_MASTER         3
#define NVWATCH_FUNC_DUMP_VIDEO          4
#define NVWATCH_FUNC_QUERYDEVICECONTEXT  5
#define NVWATCH_FUNC_DMAPUSH_AND_FIFO    6

// JJV - Have this function echo the input.
char get_winice_input(void)
{
  char return_val;
  char echo_string[] = "x";

  _asm  mov  ax,1
  _asm  int  41h
  _asm  mov  return_val, al
  
  // Echo the keystrokes to the terminal.
  if (1){
    echo_string[0] = return_val;
    _asm  push ss
    _asm  pop  ds
    _asm  mov  ax, 2
    _asm  lea  esi, echo_string
    _asm  int  41h
  }
  
  return(return_val);
}

// Returns status.
DWORD NvWatch_ascii2hex(char *ascii_string, DWORD *ret_val)
{
  int i;
  BYTE temp_b;
  DWORD return_val=0;

  for(i=0;i<8;i++){
    temp_b = ascii_string[i];
    if( (temp_b < 0x30)||((temp_b > 0x39)&&(temp_b < 0x41))||((temp_b > 0x46)&&(temp_b < 0x61))|| \
        (temp_b > 0x66) ){
      //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Invalid register offset entered. (Must be upper case ! sorry)");
      return(0);
    }
    
    // Deal with the lower case 1st.
    if(temp_b >= 0x61)
      temp_b -= 0x20;
    
    if(temp_b > 0x39)
      temp_b -= 0x37;
    else
      temp_b -= 0x30;
      
    _asm  mov  eax, return_val
    _asm  or   al, temp_b
    _asm  ror  eax,4
    _asm  mov  return_val, eax
  }   
  
  *ret_val = return_val;
  return(1);   /* return success*/
}

DWORD NvWatch_GetInputDword(DWORD *dword_read)
{
  int i,j;
  char instring[]="00000000";
  char inchar;
  BYTE got_cr=FALSE;
  //DWORD inchar_dword;
  
  for(i=0;i<9;i++){
    // Get a character
    inchar = get_winice_input();
    
    if(inchar == '\r'){
      got_cr = TRUE;
    }else{
      // Get the character ... up to 8.
      if(i<8){
        // shift all the characters to the left.
        for(j=7;j>0;j--)
          instring[j] = instring[j-1];
        // put the character in the bottom
        instring[0] = inchar;
      }  
    }
    
    if(got_cr){
      if(i==0){
        //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Got a cr ... but no number entered");
        return(FALSE);
      }
      // Try to translate the thing.
      if(!NvWatch_ascii2hex(instring, dword_read)){
        //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Got a cr ... but can't decifer the value");
        return(FALSE);
      }else
        return(TRUE);
    }else{
      if(i==8){
        // exit with an error.
        //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Never got a  cr");
        return(FALSE);
      }  
    } 
  }  
}

void NvWatch_display_prompt(PHWINFO pDev, char *instring)
{
  U032 device_id_chip;
  U032 device;
  int i;

  for(i=0;i<MAX_INSTANCE;i++){
      if(pDev == NvDBPtr_Table[i]){
          device=i;
          break;
      }
  }

  device_id_chip = REG_RD32(NV_PBUS_PCI_NV_0);
  device_id_chip = (U032) ((device_id_chip >> DRF_SHIFT(NV_CONFIG_PCI_NV_0_DEVICE_ID)) &
      DRF_MASK(NV_CONFIG_PCI_NV_0_DEVICE_ID));

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, instring);
  
  switch(device_id_chip)
  {
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV04)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV04)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV04)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV04)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV04)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV04)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV04)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV04)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV04)>"); break;
          }
          break;
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID2:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID3:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV05)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV05)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV05)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV05)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV05)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV05)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV05)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV05)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV05)>"); break;
          }
          break;

      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID1:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID2:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID3:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV0A)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV0A)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV0A)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV0A)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV0A)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV0A)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV0A)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV0A)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV0A)>"); break;
          }
          break;

      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV10)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV10)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV10)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV10)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV10)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV10)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV10)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV10)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV10)>"); break;
          }
          break;

      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2:
      case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(NV15)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(NV15)>"); break;
            case 2:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(NV15)>"); break;
            case 3:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(NV15)>"); break;
            case 4:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(NV15)>"); break;
            case 5:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(NV15)>"); break;
            case 6:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(NV15)>"); break;
            case 7:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(NV15)>"); break;
            case 8:                                             
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(NV15)>"); break;
          }                                                     
          break;

      default:
          switch(device)
          {
            case 0:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device0(Disabled or Unknown)>"); break;
            case 1:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device1(Disabled or Unknown)>"); break;
            case 2:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device2(Disabled or Unknown)>"); break;
            case 3:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device3(Disabled or Unknown)>"); break;
            case 4:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device4(Disabled or Unknown)>"); break;
            case 5:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device5(Disabled or Unknown)>"); break;
            case 6:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device6(Disabled or Unknown)>"); break;
            case 7:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device7(Disabled or Unknown)>"); break;
            case 8:
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Device8(Disabled or Unknown)>"); break;
          }
          break;
  }
}

//****INSTANCE MEMORY INFO MENU******************************************************************************

U032 NvWatch_GetObjectFromInst(PHWINFO pDev, U032 inst, U032 *DHandle)
{
  U032 object_count, temp_d;
  U032 *hash_table_ptr;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_d = (U032) *(hash_table_ptr+1);
      temp_d &= 0xFFFF;
      if (temp_d == inst){
        *DHandle = (U032) *(hash_table_ptr);
        return(1);
      }
    }    
    hash_table_ptr+=2;
  } 
  // Error ... Not Found.
  return(0); 
}

U032 NvWatch_Process_Hash_Entry(PHWINFO pDev, U032 *hash_table_ptr, U032 verbose)
{

  U032 temp_var,t_channel;
  U032 error_found=FALSE;
  U032 *inst_ptr;
  U032 is_software=FALSE;
  OBJECT t_object,*pt_object;

  pt_object = &t_object;

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nHandle=");
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *hash_table_ptr);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Hash entry data=");
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *(hash_table_ptr+1));
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Hash entry offset=");
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) hash_table_ptr);
  
  // Print the engine.
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nEngine=");
  temp_var = (U032) *(hash_table_ptr+1);
  temp_var >>= 16;
  temp_var &= 3;
  switch(temp_var){
    case 0:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Software"); is_software=TRUE; break;
    case 1:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Graphics"); break;
    case 2:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DVD     "); break;
    default:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR!! "); error_found = TRUE; break;
  }  
  
  // Print the channel ID.
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Channel ID=");
  temp_var = (U032) *(hash_table_ptr+1);
  temp_var >>= 24;
  temp_var &= 0xf;
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Status=");
  temp_var = (U032) *(hash_table_ptr+1);
  temp_var >>= 31;
  if(temp_var)
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "VALID");
  else
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "INVALID");
    
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Instance offset=");
  temp_var = (U032) *(hash_table_ptr+1);
  temp_var &= 0xFFFF;
  temp_var <<=4;
  temp_var += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
  DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
  
  if(verbose){
    // Parse the Instance Memory also. (temp_var has the offset to the Instance)
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Instance Dump: DATA=");
    inst_ptr = (U032 *) temp_var;
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *inst_ptr);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *(inst_ptr+1));
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *(inst_ptr+2));
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) *(inst_ptr+3));
    temp_var = (U032) *inst_ptr;
    temp_var &= 0xFFF;
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nClass=");

    // Special case software objects from DMA_CONTEXT objects.
    if( (is_software)&&(temp_var != NV01_CONTEXT_DMA_TO_MEMORY)&& \
        (temp_var != NV01_CONTEXT_DMA_FROM_MEMORY)&&(temp_var != NV01_CONTEXT_DMA_IN_MEMORY) ){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Software Object Class=");
        // Search the fifo database for this guy. (Since instance memory tells us nothing)
        for(t_channel=0;t_channel<pDev->Fifo.HalInfo.Count;t_channel++){
            // Do not call fifoSearchObject on an channel that has not been initialized.
            if(((U032)pDev->DBfifoTable[t_channel].ObjectTree) == 0x69696969){
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"ERROR: NOT FOUND ??");
                break;
            }
            if(fifoSearchObject((PHWINFO) pDev,(U032) *hash_table_ptr, (U032) t_channel, (POBJECT *) &pt_object)==RM_OK){
                temp_var =(U032) pt_object->Class->Type;
                if(temp_var>MAX_CLASS_NUMBER_SUPPORTED)
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,NvWatch_ObjectStrings[MAX_CLASS_NUMBER_SUPPORTED+1]);
                else  
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,NvWatch_ObjectStrings[temp_var]);
                break;
            }
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"ERROR: NOT FOUND ??");
        }
    }
    else{   
      if(temp_var>MAX_CLASS_NUMBER_SUPPORTED)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,NvWatch_ObjectStrings[MAX_CLASS_NUMBER_SUPPORTED+1]);
      else  
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,NvWatch_ObjectStrings[temp_var]);
    }
      
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    
    switch(temp_var){
      case NV01_CONTEXT_DMA_TO_MEMORY:
      case NV01_CONTEXT_DMA_FROM_MEMORY:
      case NV01_CONTEXT_DMA_IN_MEMORY: 
        if(((U032) *inst_ptr) & 0x1000)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DMA_PAGE_TABLE_PRESENT");
        else  
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DMA_PAGE_TABLE_NOT_PRESENT");
        if(((U032) *inst_ptr) & 0x2000)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " DMA_PAGE_ENTRY_LINEAR");
        else  
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " DMA_PAGE_ENTRY_NOT_LINEAR");
        temp_var = (U032) *inst_ptr;
        temp_var >>= 16;
        temp_var &= 3;
        switch(temp_var){
          case 0: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " TARGET_NODE_NVM"); break;
          case 2: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " TARGET_NODE_PCI"); break;
          case 3: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " TARGET_NODE_AGP"); break;
          default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ERROR!"); error_found=TRUE; break;
        }
        temp_var = (U032) *inst_ptr;
        temp_var >>= 20;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nAdjust=");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
        
        temp_var = (U032) *(inst_ptr+1);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Limit=");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
        
        if(((U032) *(inst_ptr+2)) & 2)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " RW ");
        else
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " R only ");
          
        temp_var = (U032) *(inst_ptr+2);
        temp_var >>= 12;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " Frame_Addr=");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) temp_var);
        
        break;
      default:
        {
          U032 save_offset, DHandle; 
          
          if(!is_software){
            temp_var = (U032) *(inst_ptr+1);
            temp_var >>= 16;
            save_offset = temp_var;
            save_offset <<=4;
            save_offset += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
            
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NOTIFY CONTEXT Handle=");
            if(!temp_var)
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "INVALID(0x0000)");
            else{
              if(!NvWatch_GetObjectFromInst(pDev, temp_var, &DHandle))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Not found!!!");
              else{  
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) DHandle);
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  NOTIFY INSTANCE offset=");
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) save_offset);
              }  
            }  
            
            temp_var = (U032) *(inst_ptr+2);
            temp_var &= 0xFFFF;
            save_offset = temp_var;
            save_offset <<=4;
            save_offset += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
            
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDMA_CONTEXT0 Handle=");
            if(!temp_var)
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "INVALID(0x0000)");
            else{
              if(!NvWatch_GetObjectFromInst(pDev, temp_var, &DHandle))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Not found!!!");
              else{  
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) DHandle);
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  DMA_CONTEXT0 INSTANCE offset=");
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) save_offset);
              }  
            }  
          
            temp_var = (U032) *(inst_ptr+2);
            temp_var >>= 16;
            save_offset = temp_var;
            save_offset <<=4;
            save_offset += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
            
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDMA_CONTEXT1 Handle=");
            if(!temp_var)
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "INVALID(0x0000)");
            else{
              if(!NvWatch_GetObjectFromInst(pDev, temp_var, &DHandle))
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Not found!!!");
              else{  
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) DHandle);
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  DMA_CONTEXT1 INSTANCE offset=");
                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int) save_offset);
              }  
            }  
          }  
        }
        break;
    }    
  }
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
  return(!error_found);
}


void NvWatch_Dump_HT_Objects(PHWINFO pDev, U032 verbose)
{
 
  U032 object_count;
  //U032 hash_size, object_count;
  U032 object_counter=0; 
  U032 *hash_table_ptr;
  //U032 *hash_table_ptr, *inst_ptr;
  //U032 temp_var, error_found=FALSE,is_a_dmacontext;
  U032 error_found=FALSE;
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe MAX number of objects possible is = ", NvWatch_num_objects);
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    // Get the object entry. Look for a !NULL NV_RAMHT_HANDLE
    if((U032) *(hash_table_ptr+1) != 0){
      if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, verbose))
        error_found = TRUE;
      object_counter++;
    }               
    hash_table_ptr+=2;
  }  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe total number of objects found is = ", object_counter);
  if(error_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "No errors were found parsing the hash table");
  
}

U032 NvWatch_Dump_HT_Object_From_Channel(PHWINFO pDev, U032 channelv)
{

  U032 object_count;
  U032 *hash_table_ptr;
  U032 channel_found=FALSE,error_found=FALSE;
  U032 temp_var;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_var = (U032) *(hash_table_ptr+1);
      temp_var >>= 24;
      temp_var &= 0xf;
      if(temp_var == channelv){
        channel_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(channel_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object with this Channel NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(channel_found)
     return(2);
   else  
     return(1);
  }   
}

U032 NvWatch_Dump_HT_Object_From_Engine(PHWINFO pDev, U032 engine)
{

  U032 object_count;
  U032 *hash_table_ptr;
  U032 engine_found=FALSE,error_found=FALSE;
  U032 temp_var;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_var = (U032) *(hash_table_ptr+1);
      temp_var >>= 16;
      temp_var &= 3;
      if(temp_var == engine){
        engine_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(engine_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object with this engine NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(engine_found)
     return(2);
   else  
     return(1);
  }   
}

U032 NvWatch_Dump_HT_Object_From_Class(PHWINFO pDev, U032 classv)
{

  U032 object_count;
  U032 *hash_table_ptr;
  U032 class_found=FALSE,error_found=FALSE;
  U032 temp_var, *inst_ptr;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_var = (U032) *(hash_table_ptr+1);
      temp_var &= 0xFFFF;
      temp_var <<=4;
      temp_var += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
      inst_ptr = (U032 *) temp_var;
      temp_var = (U032) *inst_ptr;
      temp_var &= 0xFFF;
      if(temp_var == classv){
        class_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(class_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object with this class NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(class_found)
     return(2);
   else  
     return(1);
  }   
}

// Return 0=Error in hash, 1=Object Not found, 2=Success
U032 NvWatch_Dump_HT_Object_From_Handle(PHWINFO pDev, U032 handle)
{

  U032 object_count;
  U032 *hash_table_ptr;
  U032 handle_found=FALSE,error_found=FALSE;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      if((U032) *(hash_table_ptr) == handle){
        handle_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(handle_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object with this handle NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(handle_found)
     return(2);
   else  
     return(1);
  }   
}


U032 NvWatch_Dump_HT_Object_From_Instance(PHWINFO pDev, U032 inst)
{

  U032 object_count, temp_inst;
  U032 *hash_table_ptr;
  U032 inst_found=FALSE,error_found=FALSE;
  
  // Start from the beginning of Instance Memory
  hash_table_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset + 0x10000)/4));
  // traverse the HT searching for objects.
  for(object_count=0;object_count<NvWatch_num_objects;object_count++){
    if((U032) *(hash_table_ptr+1) != 0){
      temp_inst = (U032) *(hash_table_ptr+1);
      temp_inst &= 0xFFFF;
      if(temp_inst == inst){
        inst_found = TRUE;
        if(!NvWatch_Process_Hash_Entry(pDev, hash_table_ptr, 1)){
          error_found = TRUE;
        }  
      }
    }    
    hash_table_ptr+=2;
  }  

  if(inst_found)
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Cool ... found an object");
  else 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Object at this INSTANCE NOT found\n");
   
  if(error_found){
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR !! ERROR !! BAD Data in the hash table");
   return(0);
  }else{ 
   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " No errors were found parsing the hash table");
   if(inst_found)
     return(2);
   else  
     return(1);
  }   
}

void NvWatch_Dump_InstanceFifoContext(PHWINFO pDev)
{

    U032 temp_data,channel_counter;
    U032 *ptr_fifocontextarea;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n*********************************************");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDumping fifo contexts from instance memory\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,   "*********************************************\n");

    // Print the Hash Table size and the Instance Memory size.
    temp_data = REG_RD32(NV_PFIFO_RAMHT);
    temp_data >>= 16;
    temp_data &= 0x3;
    switch(temp_data){
      case 0:
        ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x1000) /4) );
        break;
      case 1:
        ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x2000) /4) );
        break;
      case 2:
        ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x4000) /4) );
        break;
      case 3:
        ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x8000) /4) );
        break;
    }

    for(channel_counter=0;channel_counter<NUM_FIFOS;channel_counter++){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel ", (int) channel_counter);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  DMA PUT      = ", (int) *(ptr_fifocontextarea+0+(channel_counter*8)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  DMA GET      = ", (int) *(ptr_fifocontextarea+1+(channel_counter*8)));

        if(IsNV10orBetter(pDev)){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Ref Count    = ", (int) *(ptr_fifocontextarea+2+(channel_counter*8)));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  DMA Instance = ", (int) *(ptr_fifocontextarea+3+(channel_counter*8)));
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  DMA Instance = ", (int) *(ptr_fifocontextarea+2+(channel_counter*8)));
        }
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    }
}

void NvWatch_InstanceMem_help(PHWINFO pDev)
{

  U032 temp_data;
  U032 device;
  int i;

  for(i=0;i<MAX_INSTANCE;i++){
      if(pDev == NvDBPtr_Table[i]){
          device=i;
          break;
      }
  }
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nInstance Memory options for device ", device);
  
  // Print the Hash Table size and the Instance Memory size.
  temp_data = REG_RD32(NV_PFIFO_RAMHT);
  temp_data >>= 16;
  temp_data &= 0x3;
  switch(temp_data){
    case 0:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Hash table size is 4K\n\r");
      break;
    case 1:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Hash table size is 8K\n\r");
      break;
    case 2:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Hash table size is 16K\n\r");
      break;
    case 3:
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Hash table size is 32K\n\r");
      break;
  } 
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      h   - Dump objects from the Hash table (simple ... just the hash entries)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      v   - Dump objects (Verbose ... Hash entries and Instance data)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      o   - Dump Objects by Handle\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      c   - Dump Objects by Class \n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      e   - Dump Objects by Engine\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      n   - Dump Objects by Channel\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      i   - Dump Object by Instance (eg. XXXX)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      f   - Fifo Context Area\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit this\n\r\n\r");
}

VOID NvWatch_Query_InstanceMemory(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  char pstring[]="NvWatch InstanceMem";
  
  NvWatch_InstanceMem_help(pDev);
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 'f': // Dump hash table
      case 'F': // Dump hash table
        NvWatch_Dump_InstanceFifoContext(pDev);
        break;
      case 'h': // Dump hash table
      case 'H': // Dump hash table
        NvWatch_Dump_HT_Objects(pDev,0);
        break;
      case 'v': // Dump hash table
      case 'V': // Dump hash table
        NvWatch_Dump_HT_Objects(pDev,1);
        break;
      case 'o': // Object dump by handle
      case 'O': // Object dump by handle
        {
          U032 o_handle;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the handle of the object->");
          NvWatch_GetInputDword(&o_handle);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Handle(pDev, o_handle);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      case 'c': // Object dump by class
      case 'C': // Object dump by class
        {
          U032 o_class;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the class of the object->");
          NvWatch_GetInputDword(&o_class);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Class(pDev, o_class);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      case 'e': // Object dump by engine
      case 'E': // Object dump by engine
        {
          U032 o_engine;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEngine types: Software=0 Graphics=1 DVD=2");
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the engine type of the object->");
          NvWatch_GetInputDword(&o_engine);
          if((o_engine<0)||(o_engine>2)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: Invalid Engine # entered !");
            break;
          }  
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Engine(pDev, o_engine);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      case 'n': // Object dump by channel
      case 'N': // Object dump by channel
        {
          U032 o_channel;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the channel of the objects->");
          NvWatch_GetInputDword(&o_channel);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Channel(pDev, o_channel);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      case 'i': // Object dump by instance
      case 'I': // Object dump by instance
        {
          U032 o_inst;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nEnter the instance of the objects->");
          NvWatch_GetInputDword(&o_inst);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
          NvWatch_Dump_HT_Object_From_Instance(pDev, o_inst);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        }  
        break;
      default: // Help
        NvWatch_InstanceMem_help(pDev);
        break;  
    }
  }
}

//****RM DATA MENU******************************************************************************

void NvWatch_spaceit(U032 level)
{
  U032 i;

  for (i = 0; i < level; i++)
  {
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  ");
  }
}

#define BTREE_OBJS_ONLY 0x2
#define MAX_CLASS_VALUE 0xFFF
RM_STATUS NvWatch_btreeDumpBranch
(
    PNODE Node,
    U032  Level,
    U032  dump_type // bit0=0=Simple bit0=1=Complex bit2=0=ALL bit2=1=Objects(no classes)
)
{
  if (Node)
  {
      //VALIDATE_NODE(Node);
      if (btreeNodeValidate(Node) != RM_OK){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: Btree Node Validation Failed!!");
        return (RM_ERROR);
      }  
      
      NvWatch_btreeDumpBranch(Node->RightBranch, Level + 1, 3);
      //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ");
      //for (i = 0; i < Level; i++)
      //{
      //    //DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, ".");
      //    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  ");
      //}
      
      if(dump_type & BTREE_OBJS_ONLY){
        if(Node->Value > MAX_CLASS_VALUE){ 
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Node         = ", (U032)Node);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Node         = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Value        = ", Node->Value);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Value        = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->Value);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Left count   = ", Node->LeftCount);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Left count   = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->LeftCount);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Right count  = ", Node->RightCount);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Right Count  = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->RightCount);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Left branch  = ", (U032)Node->LeftBranch);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Left Branch  = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node->LeftBranch);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
          
          //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Right branch = ", (U032)Node->RightBranch);
          NvWatch_spaceit(Level);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Right Branch = ");
          DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node->RightBranch);
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        }  
      }else{    
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Node         = ", (U032)Node);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Node         = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Value        = ", Node->Value);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Value        = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->Value);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Left count   = ", Node->LeftCount);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Left count   = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->LeftCount);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Right count  = ", Node->RightCount);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Right Count  = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, Node->RightCount);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Left branch  = ", (U032)Node->LeftBranch);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Left Branch  = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node->LeftBranch);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
        
        //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Right branch = ", (U032)Node->RightBranch);
        NvWatch_spaceit(Level);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,            "Right Branch = ");
        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032)Node->RightBranch);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
      }    
      NvWatch_btreeDumpBranch(Node->LeftBranch, Level + 1, 3);
  }       
}           
            
void NvWatch_DumpBtreeContents(PHWINFO pDev)
{
  U032 i;
    
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDumping the BTREE ! ");         

  for(i=0;i<NUM_FIFOS;i++){
  
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\n     Dumping FIFO # ", i);      
    if (pDev->DBfifoTable[i].InUse == FALSE)
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo not InUse !\n\r");
    else{  
      if (pDev->DBfifoTable[i].ObjectTree == NULL)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo InUse but =NULL\n\r");
      else
        NvWatch_btreeDumpBranch(pDev->DBfifoTable[i].ObjectTree, 0, 3);
    } 
  }
} 

void NvWatch_Dump_NvInfo(PHWINFO pDev)
{
  PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nNvInfo State Variables:\r\n");

  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\r\npDev->Mapping.nvPhys        ",pDev->Mapping.nvPhys);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.fbPhys            ",pDev->Mapping.fbPhys);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.nvIRQ             ",pDev->Mapping.nvIRQ);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.nvBusDeviceFunc   ",pDev->Mapping.nvBusDeviceFunc);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.hpicIRQ           ",pDev->Mapping.hpicIRQ);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.hDev              ",pDev->Mapping.hDev);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Mapping.osDeviceHandle  ",pOsHwInfo->osDeviceHandle);
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Framebuffer.RamSizeMb   ",pDev->Framebuffer.HalInfo.RamSizeMb);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->Framebuffer.RamSize     ",pDev->Framebuffer.HalInfo.RamSize);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "nvAddr                          ",(int) nvAddr);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "romAddr                         ",(int) romAddr);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "fbAddr                          ",(int) fbAddr);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "pDev->DBagpAddr                 ",(int) pDev->DBagpAddr);
  
}

void NvWatch_DisplayClientInfo(PHWINFO pDev, U032 client_counter, U032 verbose)
{
  U032 device_counter, fifo_counter;
  PCLI_DMA_INFO dmalist_ptr;
  
  if(clientInfo[client_counter].InUse == TRUE){
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Client found at index = ",client_counter);
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Handle        = ",clientInfo[client_counter].Handle);
     if(verbose){
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Class         = ",clientInfo[client_counter].Class);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  InUse         = ",clientInfo[client_counter].InUse);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  AppID         = ",clientInfo[client_counter].AppID);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  ProcID        = ",clientInfo[client_counter].ProcID);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  ProcContext   = ",clientInfo[client_counter].ProcContext);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  FifoCount     = ",clientInfo[client_counter].FifoCount);
     }
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  CliDmaList    = ",(int) clientInfo[client_counter].CliDmaList);
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  CliDeviceList = ",(int) clientInfo[client_counter].CliDeviceList);
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  CliMemoryList = ",(int) clientInfo[client_counter].CliMemoryList);
     DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Traversing DMA Context List ...\n");
    dmalist_ptr = clientInfo[client_counter].CliDmaList;
    while(dmalist_ptr){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  DMA Context Found\n");
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Handle       = ",dmalist_ptr->Handle);
     if(verbose){
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Client       = ",dmalist_ptr->Client);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Class        = ",dmalist_ptr->Class);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Flags        = ",dmalist_ptr->Flags);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Access       = ",dmalist_ptr->Access);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Physicality  = ",dmalist_ptr->Physicality);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Locked       = ",dmalist_ptr->Locked);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Coherency    = ",dmalist_ptr->Coherency);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Valid        = ",dmalist_ptr->Valid);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DescSelector = ",dmalist_ptr->DescSelector);  
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DescOffset   = ",(int) dmalist_ptr->DescOffset);      
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DescLimit    = ",dmalist_ptr->DescLimit);   
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DescAddr     = ",(int) dmalist_ptr->DescAddr);    
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    BufferBase   = ",(int) dmalist_ptr->BufferBase);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    BufferSize   = ",dmalist_ptr->BufferSize);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    LockHandle   = ",(int) dmalist_ptr->LockHandle);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    PteCount     = ",dmalist_ptr->PteCount);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    PteAdjust    = ",dmalist_ptr->PteAdjust);   
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    PteLimit     = ",dmalist_ptr->PteLimit);    
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    PteArray     = ",(int) dmalist_ptr->PteArray);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Next         = ",(int) dmalist_ptr->Next);
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Prev         = ",(int) dmalist_ptr->Prev);
     }
     DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    AddressSpace = ",dmalist_ptr->AddressSpace);
    dmalist_ptr = dmalist_ptr->Next;
    }
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nTraversing DeviceList ...\n");
    for(device_counter=0;device_counter<NUM_DEVICES;device_counter++){
      if(clientInfo[client_counter].CliDeviceList[device_counter].InUse == TRUE){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Device in use found = ",device_counter);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Handle        = ",clientInfo[client_counter].CliDeviceList[device_counter].Handle);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Client        = ",clientInfo[client_counter].CliDeviceList[device_counter].Client);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Class         = ",clientInfo[client_counter].CliDeviceList[device_counter].Class);
        if(verbose){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    InUse         = ",clientInfo[client_counter].CliDeviceList[device_counter].InUse);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    AppID         = ",clientInfo[client_counter].CliDeviceList[device_counter].AppID);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DevID         = ",clientInfo[client_counter].CliDeviceList[device_counter].DevID);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DevFifoList   = ",(int)clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList);  
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    DevMemoryList = ",(int)clientInfo[client_counter].CliDeviceList[device_counter].DevMemoryList);
        }
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n    Traversing Fifolist for this device ...\n");
        for(fifo_counter=0;fifo_counter<NUM_FIFOS;fifo_counter++){
          if(clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].InUse == TRUE){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "     Fifo in use found = ",fifo_counter);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Handle           = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Handle);           
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Device           = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Device);           
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Class            = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Class);            
            if(verbose){
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         ErrorDmaContext  = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].ErrorDmaContext); 
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         DataDmaContext   = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].DataDmaContext);   
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         FifoPtr          = ",(int) clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].FifoPtr);      
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         DevID            = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].DevID);            
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         InUse            = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].InUse);            
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         ChID             = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].ChID);             
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         AppID            = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].AppID);            
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Selector         = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Selector);         
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         Flat             = ",(int) clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].Flat);             
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         heventWait       = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].heventWait);       
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         hwndNotify       = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].hwndNotify);       
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         hwndError        = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].hwndError);        
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         msgNotify        = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].msgNotify);        
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         msgError         = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].msgError);         
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         lpSysCallback    = ",(int) clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].lpSysCallback);    
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         eventNotify      = ",clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].eventNotify);  
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "         pDmaObject       = ",(int) clientInfo[client_counter].CliDeviceList[device_counter].DevFifoList[fifo_counter].pDmaObject);       
            }
          }
        }  
      }  
    }
  }
}

void NvWatch_Dump_ClientInfo(PHWINFO pDev, U032 client_num, U032 verbose)
{
  int client_counter;
  

  if(client_num == 0xffffffff){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
      for(client_counter=0;client_counter<NUM_CLIENTS;client_counter++){
        NvWatch_DisplayClientInfo(pDev, client_counter, verbose);
      }
  }else{
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
      NvWatch_DisplayClientInfo(pDev, client_num, verbose);
  }

}

void NvWatch_DumpGrTableContents(PHWINFO pDev, U032 verbose_flag)
{
  
  if(IsNV10orBetter(pDev)){
      NvWatch_NV10_DumpGrTableContents(pDev, verbose_flag);
  }else{
      NvWatch_NV04_DumpGrTableContents(pDev, verbose_flag);
  }
}

void NvWatch_DumpRegistryStrings(PHWINFO pDev)
{
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r\n\rGlobal Path = ");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, strRegistryGlobalParameters);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Device Path = ");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, pDev->Registry.DBstrDevNodeDisplay);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r\n\r");
}
void NvWatch_RM_help(void)
{
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Resource Manager Internal Data Structures\n\r\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Commands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      i   - Dump NvInfo data\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      c   - Dump Client data\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      d   - Dump Client data (VERBOSE)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      b   - Dump BTREE Contents\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      r   - Dump Registry Path Info\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      g   - Dump Graphics Contexts\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      v   - Dump Graphics Contexts (VERBOSE)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      m   - CPU MTRR Registers (use n option for R/W)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      n   - CPU MSR Registers R/W\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      o   - CPU CR0 R/W\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit\n\r\n\r");
}

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32
#define WRMSR   __asm _emit 0x0F __asm _emit 0x30
VOID NvWatch_MTRR_RegisterStuff(void)
{
    U032 mtrrAddr, numRanges = 0;
    U032 BaseHi, BaseLo, MaskHi, MaskLo;
    U032 i;

    CLI
    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, 254            // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        test    eax, 0x400          // check that WC as a type is supported (should be 1).
        jz      Exit

        and     eax, 0xFF           // save number of ranges
        mov     numRanges, eax
Exit:    
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }

    // Now determine if we find a Write Combined match in the MTRRs
    for (i = 0, mtrrAddr = 512; i < numRanges; i++, mtrrAddr += 2)
    {
        __asm {

            push    eax
            push    ebx
            push    ecx
            push    edx

            mov     ecx, mtrrAddr
            RDMSR

            mov     BaseHi, edx
            mov     BaseLo, eax

            mov     ecx, mtrrAddr
            add     ecx, 1
            RDMSR

            mov     MaskHi, edx
            mov     MaskLo, eax

            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: MTRR ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Base ", BaseLo);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Mask ", MaskLo);

        /////if (!(MaskLo & 0x800))
        /////   continue;               // not a valid range
        /////MaskLo &= ~0xFFF;          // mask off the valid bit
        /////
        /////if ((BaseLo & 0xFF) != 0x1)
        /////   continue;               // not a Write Combined range
        /////BaseLo &= ~0xFF;           // mask off the type bits
        /////
        /////if ((BaseLo >= AGPBase) && ((BaseLo + ~MaskLo) < (AGPBase + AGPSize)))
        /////   pDev->Mapping.AGPLimit = ~MaskLo;  // the WC MTRR is within the aperture
    }

    STI
}

#define MAX_MSR_REGISTER 0x413

NvU64 NvWatch_MSRREAD(U032 reg_num)
{
    NvU64 return_val={0xFFFFFFFF,0xFFFFFFFF};

    if(reg_num > MAX_MSR_REGISTER){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR!: This offset exceeds the maximun MSR Register.");
        return return_val;
    }

    CLI
    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, reg_num         // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        mov     return_val.low,eax
        mov     return_val.high,edx

Exit:    
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
    STI
    return return_val;
}

NvU64 NvWatch_MSRWRITE(U032 reg_num, NvU64 data)
{
    NvU64 return_val={0xFFFFFFFF,0xFFFFFFFF};

    if(reg_num > MAX_MSR_REGISTER){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR!: This offset exceeds the maximun MSR Register.");
        return return_val;
    }

    CLI
    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, reg_num         // read the MTRRcap MSR to determine number of ranges.
        mov     eax,data.low
        mov     edx,data.high
        WBINVD
        WRMSR

Exit:    
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
    STI
    return return_val;
}

int NvWatch_MSR_Registers()
{
    char instring[]="00000000";
    DWORD ddata=0, ddata2=0, daddr=0, save_offset;
    NvU64 msr_data;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the Offset of the MSR Register to query.");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");

    if(!NvWatch_GetInputDword(&daddr)){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
      return(0);
    }  
    save_offset = daddr; 

    msr_data = NvWatch_MSRREAD(daddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe low 32 bits read are ", (int) msr_data.low);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The high 32 bits read are ", (int) msr_data.high);

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nEnter the new value for the low 32 bits ->");
    
    if(!NvWatch_GetInputDword(&ddata)){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
      return(0);
    }  
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nEnter the new value for the high 32 bits ->");
    
    if(!NvWatch_GetInputDword(&ddata2)){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
      return(0);
    }  

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe low 32 bits to write are ", (int) ddata);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The high 32 bits to write are ", (int) ddata2);
    msr_data.low = ddata;
    msr_data.high = ddata2;
    NvWatch_MSRWRITE(daddr, msr_data);
}

int NvWatch_CR0_Control()
{
    U032 ddata=0,cr0_save;
    _asm{
        mov  eax,cr0
        mov  cr0_save,eax 
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe value of CR0 is ", (int) cr0_save);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nEnter a new value for CR0 ->");

    if(!NvWatch_GetInputDword(&ddata)){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
      return(0);
    }  

    _asm{
        mov  eax,ddata
        WBINVD
        mov  cr0,eax 
    }
    _asm{
        mov  eax,cr0
        mov  cr0_save,eax 
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe new value of CR0 is ", (int) cr0_save);
}

void NvWatch_heapDump
(
    PHEAP heap
)
{
    U032      i;
    U032      free;
    PMEMBLOCK block;

    if (!heap) return;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\nHeap dump.  Size = ", heap->total);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,  "            Free = ", heap->free);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"=================================================================\r\n");
    for (i = 0; i < heap->numBanks; i++)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"Bank: ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tType flags = ", heap->Bank[i].flags);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tOffset     = ", heap->Bank[i].offset);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tSize       = ", heap->Bank[i].size);
    }
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Block List Forward:\r\n");
    block = heap->pBlockList;
    do
    {
        if (block->owner == FREE_BLOCK)
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\tOwner = FREE\r\n");
        else
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tOwner = ", block->owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tType  = ", block->u0.type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tHwres = ", block->u1.hwres);
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tBegin = ", block->begin);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tEnd   = ", block->end);
        block = block->next;
    } while (block != heap->pBlockList);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Block List Reverse:\r\n");
    block = heap->pBlockList;
    do
    {
        block = block->prev;
        if (block->owner == FREE_BLOCK)
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\tOwner = FREE\r\n");
        else
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tOwner = ", block->owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tType  = ", block->u0.type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tHwres  = ", block->u1.hwres);
        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tBegin = ", block->begin);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tEnd   = ", block->end);
    } while (block != heap->pBlockList);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"FREE Block List Forward:\r\n");
    free  = 0;
    if ((block = heap->pFreeBlockList))
        do
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\tOwner = FREE\r\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tBegin = ", block->begin);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tEnd   = ", block->end);
            free += block->end - block->begin + 1;
            block = block->u1.nextFree;
        } while (block != heap->pFreeBlockList);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tCalculated free count = ", free);
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"FREE Block List Reverse:\r\n");
    free  = 0;
    if ((block = heap->pFreeBlockList))
        do
        {
            block = block->u0.prevFree;
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\tOwner = FREE\r\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tBegin = ", block->begin);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\t\tEnd   = ", block->end);
            free += block->end - block->begin + 1;
        } while (block != heap->pFreeBlockList);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"\tCalculated free count = ", free);

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n\nKey to Types");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_IMAGE       = 0x00000001");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_DEPTH       = 0x00000002");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_TEXTURE     = 0x00000004");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_OVERLAY     = 0x00000008");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_FONT        = 0x00000010");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_CURSOR      = 0x00000020");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_DMA         = 0x00000040");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_INSTANCE    = 0x00000080");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_PRIMARY     = 0x00000100");
	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\nMEM_FLAG_IMAGE_TILED = 0x00000200");
}

int NvWatch_RMData(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  char pstring[]="NvWatch Resource Manager Data Structure Info";
 
  NvWatch_RM_help();
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 'i': // NvInfo Data
      case 'I': // NvInfo Data
        NvWatch_Dump_NvInfo(pDev);
        break;
      case 'c': // Client Data       
      case 'C': // Client Data       
        NvWatch_Dump_ClientInfo(pDev,0xFFFFFFFF,0);
        break;
      case 'd': // Client Data       
      case 'D': // Client Data       
        NvWatch_Dump_ClientInfo(pDev,0xFFFFFFFF,1);
        break;
      case 'b': // Btree Dump
      case 'B': // Btree Dump
        NvWatch_DumpBtreeContents(pDev);
        break;
      case 'r': // Btree Dump
      case 'R': // Btree Dump
        NvWatch_DumpRegistryStrings(pDev);
        break;
      case 'g': // grTable Dump
      case 'G': // grTable Dump
        NvWatch_DumpGrTableContents(pDev, NVWATCH_SIMPLE);
        break;
      case 'v': // grTable Dump
      case 'V': // grTable Dump
        NvWatch_DumpGrTableContents(pDev, NVWATCH_COMPLEX);
        break;
	  case 'h': // heap Dump
	  case 'H': // heap Dump
		NvWatch_heapDump((PHEAP)pDev->Framebuffer.HeapHandle);
		break;
      case 'm': // MTRR Stuff
      case 'M': // 
        NvWatch_MTRR_RegisterStuff();
        break;
      case 'n': // MTRR Stuff
      case 'N': // 
        NvWatch_MSR_Registers();
        break;
      case 'o': // MTRR Stuff
      case 'O': // 
        NvWatch_CR0_Control();
        break;
      default: // Help
        NvWatch_RM_help();
        break;  
    }
  }

    return (RM_OK);
}

RM_STATUS NvWatch_osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    RM_STATUS status;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. Enter *pAddress =",(int) *pAddress);

    {
        DESCRIPTOR desc;
        U032       nvwatch_nPages;
        U032       nvwatch_pType=PG_SYS;
        U032       nvwatch_VM=0;
        U032       nvwatch_AlignMask;
        U032       nvwatch_minPhys=0;
        U032       nvwatch_maxPhys=0;
        U032       nvwatch_PhysAddr=0;
        //U032       nvwatch_flags=0;
        U032       nvwatch_flags=(PAGECONTIG|PAGEFIXED);
        //U032       nvwatch_flags=(PAGECONTIG|PAGEFIXED|PAGEUSEALIGN);

        nvwatch_nPages    = Size >> 12;
        // Align on size boundary.
        nvwatch_AlignMask = 0;
        //nvwatch_AlignMask = Size;
        
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. nvwatch_nPages =",(int) nvwatch_nPages);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. nvwatch_AlignMask =",(int) nvwatch_AlignMask);
        vmmPageAllocate(
                nvwatch_nPages, 
                nvwatch_pType, 
                nvwatch_VM, 
                nvwatch_AlignMask, 
                nvwatch_minPhys, 
                nvwatch_maxPhys, 
                nvwatch_PhysAddr, 
                nvwatch_flags, 
                &desc.Desc64);
        *pAddress = (VOID *)desc.Desc32[0];
    }
//////  from osallocpages.
//////  vmmPageAllocate(PageCount, PG_SYS, 0, 0, 0, 0, 0, 0, &desc.Desc64);
//////  *pAddress = (VOID *)desc.Desc32[0];

    if (*pAddress != NULL)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. Exit *pAddress =",(int) *pAddress);
        status = RM_OK;
    }
    else
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osAllocMem. ERROR ! *pAddress =",(int) *pAddress);
        status = RM_ERR_NO_FREE_MEM;
    }
    return (status);
}

RM_STATUS NvWatch_osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status;


    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osFreeMem. pAddress =",(int) pAddress);
    if(!pAddress)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_osFreeMem. pAddress is Invalid=",(int) pAddress);
        return (RM_OK);
    }    

    {
         U032 nvwatch_hMem;
         U032 nvwatch_flags=0;

         nvwatch_hMem = (U032)pAddress;
         if (!vmmPageFree(nvwatch_hMem, 0)){
             status = RM_ERROR;
         }
         else{
             status = RM_OK;
         }
    }
    return (status);
}


U032 NvWatch_Crush11_MemFree_Block(PHWINFO pDev, U032 block_index)
{
    int i;

    if(nvwatch_block_buffers[block_index] == NULL){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_MemFree_Blocks. Block entry is NULL. block_index=",(int)block_index);
                nvwatch_crush11_failed_data = block_index;
                return(RM_ERROR);
    }
    if(NvWatch_osFreeMem((VOID *)nvwatch_block_buffers[block_index]) != RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_MemFree_Blocks. osFreeMem Failed! block_index=",(int)block_index);
                nvwatch_crush11_failed_data = block_index;
                return(RM_ERROR);
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_MemFree_Blocks. osFreeMem SUCCESS! block_index=",(int)block_index);
        nvwatch_block_buffers[block_index] == NULL;
        for(i=0;i<NVWATCH_MAX_PAGES_PER_BLOCK;i++){
                nvwatch_PageArray[block_index][i];
        }
    }

    return(RM_OK);
}

U032 NvWatch_Crush11_UnLock_Block(PHWINFO pDev, U032 bsize, U032 block_index)
{
    U032 PageBase, LinAddr, PageCount, status;
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_UnLock_Blocks. block_index=",(int)block_index);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_UnLock_Blocks. bsize=",(int)bsize);
    if(nvwatch_block_buffers[block_index] == NULL){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_UnLock_Blocks Block NOT allocated",(int)block_index);
        nvwatch_crush11_failed_data = block_index;
        return(RM_ERROR);
    }
    
    LinAddr = (U032) nvwatch_block_buffers[block_index];
    PageBase = LinAddr >> PAGESHIFT;
    PageCount = bsize >> PAGESHIFT;
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_UnLock_Block Linear Address=",(int) LinAddr);
    
    status = !vmmLinPageUnLock(PageBase, PageCount, PAGEMAPGLOBAL) ? RM_ERR_DMA_MEM_NOT_UNLOCKED : RM_OK;
    if(status != RM_OK){
        nvwatch_crush11_failed_data = block_index;
    }

    return(status);

}

U032 NvWatch_Crush11_Lock_Block(PHWINFO pDev, U032 bsize, U032 block_index)
{

    U032 PageBase, LinAddr, PageCount;
    U032 LinAddr_save;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Blocks. block_index=",(int)block_index);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Blocks. bsize=",(int)bsize);

    LinAddr = (U032) nvwatch_block_buffers[block_index];
    LinAddr_save = (U032) LinAddr;
    PageBase = LinAddr >> PAGESHIFT;
    PageCount = bsize >> PAGESHIFT;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Block Linear Address=",(int) LinAddr);
    
    LinAddr = (U032)vmmLinPageLock(PageBase, PageCount, PAGEMAPGLOBAL);
    
    if (!LinAddr)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Block Unable to lock pages. Block=",(int) block_index);
        nvwatch_crush11_failed_data = block_index;
        return (RM_ERR_DMA_MEM_NOT_LOCKED);
    }
    if (!vmmCopyPageTable(LinAddr >> PAGESHIFT, PageCount, (U032)&nvwatch_PageArray[block_index][0], 0))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Block Unable to copy page table. Block=",(int) block_index);
        nvwatch_crush11_failed_data = block_index;
        return (RM_ERR_PAGE_TABLE_NOT_AVAIL);
    }
    LinAddr += (LinAddr_save & 0xFFF);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Lock_Block New Linear Address=",(int) LinAddr);
    nvwatch_block_buffers[block_index] = (void *) LinAddr;
    return(RM_OK);
}

U032 NvWatch_Crush11_Unlock_and_Free_Block(PHWINFO pDev, U032 bsize, U032 block_index)
{
    int status=RM_OK;

    if(NvWatch_Crush11_UnLock_Block(pDev, bsize, block_index) != RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block UnLocking FAILED ! Block=",(int)block_index);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Try to free it anyway. Block=",(int)block_index);
        nvwatch_crush11_failed_data = block_index;
        status=RM_ERROR;
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block UnLocking SUCCESS ! Block=",(int)block_index);
    }

    if(NvWatch_Crush11_MemFree_Block(pDev, block_index)!=RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Freeing FAILED ! Block=",(int)block_index);
        nvwatch_crush11_failed_data = block_index;
        status=RM_ERROR;
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Freeing SUCCESS ! Block=",(int)block_index);
    }

    return(status);
}

U032 NvWatch_Crush11_Allocate_and_Lock_Block(PHWINFO pDev, U032 bsize, U032 block_index)
{

    if(osAllocMem((VOID **)&nvwatch_block_buffers[block_index], bsize) != RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Alloc FAILED ! Block=",(int)block_index);
        nvwatch_crush11_failed_data = block_index;
        return(RM_ERROR);
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Alloc SUCCESS ! Block=",(int)block_index);
        if(NvWatch_Crush11_Lock_Block(pDev, bsize, block_index) != RM_OK){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Locking FAILED ! Block=",(int)block_index);
            if(NvWatch_Crush11_MemFree_Block(pDev, block_index) != RM_OK){
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Freeing the block FAILED also ! Block=",(int)block_index);
            }
            nvwatch_crush11_failed_data = block_index;
            return(RM_ERROR);
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Lock_Block Locking SUCCESS ! Block=",(int)block_index);
            return(RM_OK);
        }
    }
    return(RM_OK);
}

U032 NvWatch_Crush11_Allocate_Blocks(PHWINFO pDev, U032 bsize, U032 num_blocks)
{
    U032 i;
    int status;

    for(i=0;i<num_blocks;i++){
        if(NvWatch_osAllocMem((VOID **)&nvwatch_block_buffers[i], bsize) != RM_OK){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_Blocks Alloc FAILED ! Block=",(int)i);
            nvwatch_crush11_failed_data = i;
            status=RM_ERROR;
            break;
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_Blocks Alloc SUCCESS ! Block=",(int)i);
            status=RM_OK;
        }
    }
//////    for(i=0;i<num_blocks;i++){
//////        if(NvWatch_Crush11_Allocate_and_Lock_Block(pDev, bsize, i)!=RM_OK){
//////            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_Blocks FAILED. num_blocks=",(int)num_blocks);
//////          nvwatch_crush11_failed_data = i;
//////            return(RM_ERROR);
//////        }
//////    }
    return(status);

}

U032 NvWatch_Crush11_Free_Blocks(PHWINFO pDev, U032 bsize, U032 num_blocks)
{
    U032 i;
    int status;

    for(i=0;i<num_blocks;i++){
        if(NvWatch_Crush11_MemFree_Block(pDev, i)!=RM_OK){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Freeing FAILED ! Block=",(int)i);
            nvwatch_crush11_failed_data = i;
            status=RM_ERROR;
            break;
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Unlock_and_Free_Block Freeing SUCCESS ! Block=",(int)i);
            status=RM_OK;
        }
    }
//////    for(i=0;i<num_blocks;i++){
//////        if(NvWatch_Crush11_Unlock_and_Free_Block(pDev, bsize, i)!=RM_OK){
//////            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Free_Blocks FAILED. num_blocks=",(int)num_blocks);
//////          nvwatch_crush11_failed_data = i;
//////            return(RM_ERROR);
//////        }
//////    }
    return(status);
}

U032 NvWatch_Crush11_Allocate_and_Free_Blocks(PHWINFO pDev, U032 bsize, U032 num_blocks)
{
    int ret_val1,ret_val2;

    if((ret_val1=NvWatch_Crush11_Allocate_Blocks(pDev, bsize, num_blocks))!=RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Free_Blocks FAILED. Failed block=",(int)ret_val1);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Free_Blocks. Freeing all allocations",(int)ret_val1);
        if((ret_val2=NvWatch_Crush11_Free_Blocks(pDev, bsize, ret_val1))!=RM_OK){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Free_Blocks. Failure Freeing after alloc failure. Free failure block=",(int)ret_val2);
        }
        return(ret_val1);
    }
    if(NvWatch_Crush11_Free_Blocks(pDev, bsize, num_blocks)!=RM_OK){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Allocate_and_Free_Blocks FAILED. num_blocks=",(int)num_blocks);
        return(RM_ERROR);
    }
    return(num_blocks);
}

void NvWatch_Crush11_Buffer_Entry_Dump(PHWINFO pDev, U032 buffer_index, U032 verbose)
{
    int i;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    for(i=0;i<20;i++){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Memory_Page_Dump=",(int) nvwatch_block_buffers[i]);
    }
}

void NvWatch_Crush11_Memory_Page_Dump(PHWINFO pDev, U032 buffer_index, U032 verbose)
{
    int i;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    for(i=0;i<20;i++){
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVWATCH:NvWatch_Crush11_Memory_Page_Dump=",(int) nvwatch_PageArray[buffer_index][i]);
    }
}

void NvWatch_Crush11_Memory_Page_Info(PHWINFO pDev, U032 buffer_index, U032 page_index, U032 verbose)
{

}

void NvWatch_Crush11_Tests_help(void)
{
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Crush11 Tests \n\r\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Commands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      a   - Allocate blocks of memory.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      f   - Free blocks of memory.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      t   - Allocate available blocks until failure.\n\r");
//  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      f   - Free all allocated blocks.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      x   - Allocate a number of blocks. (includes freeing of blocks)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      i   - Page Info on allocated blocks.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      b   - Block Info on allocated blocks.\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit\n\r\n\r");
}

void NvWatch_Crush11_Tests(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  char pstring[]="NvWatch_CrushTests";
  static U032 bsize=0x10000;
  U032 num_buffers=0;
  
  NvWatch_Crush11_Tests_help();
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;

      case 'i': // NvInfo Data
      case 'I': // NvInfo Data
          {
              NvWatch_Crush11_Memory_Page_Dump(pDev, 0, 0);
          }
          break;
      case 'b': // NvInfo Data
      case 'B': // NvInfo Data
          {
            NvWatch_Crush11_Buffer_Entry_Dump(pDev, 0, 0);
          }
          break;
      case 'a': // NvInfo Data
      case 'A': // NvInfo Data
          {
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the number of the buffers to allocate. (hex bytes)");
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");
              if(!NvWatch_GetInputDword(&num_buffers)){
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
                  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Setting number of buffers to 0");
                  num_buffers = 0;
              }else{
                  if(num_buffers > NVWATCH_MAX_MEM_BLOCKS){
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Buffer number too high");
                      DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\n\n Setting to max buffer number of ",(int) NVWATCH_MAX_MEM_BLOCKS);
                      num_buffers = NVWATCH_MAX_MEM_BLOCKS;
                  }else{
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n***Allocating ");
                      DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) num_buffers);
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
                      DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) bsize);
                      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " byte buffers*** \n\n");
                  }
                  {
                      U032 max_block;

                      if(NvWatch_Crush11_Allocate_Blocks(pDev, bsize, num_buffers)!=RM_OK){
                          max_block=nvwatch_crush11_failed_data-1;
                      }else{
                          max_block=num_buffers;
                      }

                      if(max_block==num_buffers){
                          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Successful ! Total memory locked was ", (int) (num_buffers*bsize));
                      }else{
                          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Failure ! Total memory requested was ", (int) (num_buffers*bsize));
                          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory locked was ", (int) (max_block*bsize));
                      }
                  }
              }
          }
          break;
      case 'f': // NvInfo Data
      case 'F': // NvInfo Data
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the number of the buffers to allocate. (hex bytes)");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");
                if(!NvWatch_GetInputDword(&num_buffers)){
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Setting number of buffers to 0");
                    num_buffers = 0;
                }else{
                    if(num_buffers > NVWATCH_MAX_MEM_BLOCKS){
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Buffer number too high");
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\n\n Setting to max buffer number of ",(int) NVWATCH_MAX_MEM_BLOCKS);
                        num_buffers = NVWATCH_MAX_MEM_BLOCKS;
                    }else{
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n***Freeing ");
                        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) num_buffers);
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
                        DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) bsize);
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " byte buffers*** \n\n");
                    }
                    {
                        U032 max_block;

                        if(NvWatch_Crush11_Free_Blocks(pDev, bsize, num_buffers)!=RM_OK){
                            max_block=nvwatch_crush11_failed_data-1;
                        }else{
                            max_block=num_buffers;
                        }

                        if(max_block==num_buffers){
                            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nMemory Free Successful ! Total memory freed was ", (int) (num_buffers*bsize));
                        }else{
                            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nMemory Free Failure ! Total memory requested to free was ", (int) (num_buffers*bsize));
                            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory freed was ", (int) (max_block*bsize));
                        }
                    }
                }
            }
            break;
      case 'x': // NvInfo Data
      case 'X': // NvInfo Data
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the number of the buffers to allocate. (hex bytes)");
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");
            if(!NvWatch_GetInputDword(&num_buffers)){
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Setting number of buffers to 0");
                num_buffers = 0;
            }else{
                if(num_buffers > NVWATCH_MAX_MEM_BLOCKS){
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Buffer number too high");
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\n\n Setting to max buffer number of ",(int) NVWATCH_MAX_MEM_BLOCKS);
                    num_buffers = NVWATCH_MAX_MEM_BLOCKS;
                }else{
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n***Allocating ");
                    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) num_buffers);
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " ");
                    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (U032) bsize);
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, " byte buffers*** \n\n");
                }
                {
                    U032 max_block;

                    max_block=NvWatch_Crush11_Allocate_and_Free_Blocks(pDev, bsize, num_buffers);
                    if(max_block==num_buffers){
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Successful ! Total memory locked was ", (int) (num_buffers*bsize));
                    }else{
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Failure ! Total memory requested was ", (int) (num_buffers*bsize));
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory locked was ", (int) (max_block*bsize));
                    }
                }
            }
        }
        break;
//////      case 's': // Client Data       
//////      case 'S': // Client Data       
//////        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the size of the buffers to allocate. (hex bytes)");
//////        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");
//////        if(!NvWatch_GetInputDword(&bsize)){
//////            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
//////            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Size set to default 64KB");
//////            bsize = 0x10000;
//////
//////        }else{
//////            bsize &= 0xFFFFF000;
//////            if(bsize == 0){
//////                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nError: Invalid size");
//////                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n Size set to default 64KB");
//////                bsize = 0x10000;
//////            }
//////            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe buffer size is set to ", (int) bsize);
//////        }
//////        break;
      default: // Help
        NvWatch_Crush11_Tests_help();
        break;  
    }
  }

}

/////void NvWatch_Crush11_Tests_Api(PHWINFO pDev, U032* func_params)
/////{
/////
/////    switch(func_params->function){
/////     case NVWATCH_CRUSH_API_ALLOCMEM:
/////         {
/////             U032 max_block;
/////             U032 num_buffers;
/////
/////             num_buffers=func_params->param1;
/////             bsize=func_params->param2;
/////
/////             if(NvWatch_Crush11_Allocate_Blocks(pDev, bsize, num_buffers)!=RM_OK){
/////                 max_block=nvwatch_crush11_failed_data-1;
/////             }else{
/////                 max_block=num_buffers;
/////             }
/////
/////             if(max_block==num_buffers){
/////                 DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Successful ! Total memory locked was ", (int) (num_buffers*bsize));
/////             }else{
/////                 DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nAllocation Failure ! Total memory requested was ", (int) (num_buffers*bsize));
/////                 DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory locked was ", (int) (max_block*bsize));
/////             }
/////         }
/////         break;
/////       case NVWATCH_CRUSH_API_FREEMEM:
/////           {
/////               U032 max_block;
/////               U032 num_buffers;
/////
/////               num_buffers=func_params->param1;
/////               bsize=func_params->param2;
/////
/////               if(NvWatch_Crush11_Free_Blocks(pDev, bsize, num_buffers)!=RM_OK){
/////                   max_block=nvwatch_crush11_failed_data-1;
/////               }else{
/////                   max_block=num_buffers;
/////               }
/////
/////               if(max_block==num_buffers){
/////                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nMemory Free Successful ! Total memory freed was ", (int) (num_buffers*bsize));
/////               }else{
/////                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nMemory Free Failure ! Total memory requested to free was ", (int) (num_buffers*bsize));
/////                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nTotal memory freed was ", (int) (max_block*bsize));
/////               }
/////           }
/////           break;
/////      default: // Help
/////        NvWatch_Crush11_Tests_help();
/////        break;  
/////    }
/////}
/////

void NvWatch_Testwc(void)
{
  char command_string[] = "wc;lines 25;";
  
  _asm  push ss
  _asm  pop  ds
  _asm  mov  ax, 0x7d
  _asm  mov  cx,20
  _asm  lea  esi, command_string
  _asm  int  41h
}

VOID NvWatch_QuickDiag_fifo(PHWINFO pDev, PNVWATCHDIAGSTRUCT pdiagstruct)
{
// Check the fifo first.
/* Key items:
        - Is the fifo enabled and running ?
             --check for any interrupts/errors pending.
             --check that the pusher and puller are enabled.
             --check the reassign.
             --what channel is currently running. 
             --check the mode.
             --how does the fifo context look ? 
*/

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Running Fifo diagnostic ...");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");

    if(pdiagstruct->nv_pfifo_intr_0){       
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has Interrupts pending. NV_PFIFO_INTR_0=", (int) pdiagstruct->nv_pfifo_intr_0);
        if(!pdiagstruct->nv_pfifo_intr_en_0){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has Interrupts disabled. NV_PFIFO_INTR_EN_0=", (int) pdiagstruct->nv_pfifo_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- The fifo will be stalled under these conditions.\n");
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has Interrupts enabled. NV_PFIFO_INTR_EN_0=", (int) pdiagstruct->nv_pfifo_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- The fifo appears to be waiting for the RM for service.\n");
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "                  If this condition persists ... There could be a system problem.\n");
        }
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has NO Interrupts pending. NV_PFIFO_INTR_0=", (int) pdiagstruct->nv_pfifo_intr_0);
        if(!pdiagstruct->nv_pfifo_intr_en_0){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe Fifo has Interrupts disabled. NV_PFIFO_INTR_EN_0=", (int) pdiagstruct->nv_pfifo_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -The fifo is in an idle state. (disabled)\n");
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has Interrupts enabled. NV_PFIFO_INTR_EN_0=", (int) pdiagstruct->nv_pfifo_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -All appears to be normal here.\n\n");
        }
    }

    if(pdiagstruct->nv_pfifo_caches & NV_PFIFO_CACHES_REASSIGN_ENABLED){      
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "The Fifo REASSIGN is ENABLED allowing for lightweight fifo context switching.\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  -NV_PFIFO_CACHES=", (int) pdiagstruct->nv_pfifo_caches);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo REASSIGN is DISABLED. NV_PFIFO_CACHES=", (int) pdiagstruct->nv_pfifo_caches);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!---The fifo CANNOT context switch under this condition.\n\n");
    }

    if(pdiagstruct->nv_pfifo_cache1_push0 && pdiagstruct->nv_pfifo_cache1_pull0){ 
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The fifo pusher and puller are both ENABLED. NV_PFIFO_CACHE1_PUSH0=", (int) pdiagstruct->nv_pfifo_cache1_push0);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                             NV_PFIFO_CACHE1_PULL0=", (int) pdiagstruct->nv_pfifo_cache1_pull0);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "This is the standard running condition.\n\n");
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Either the fifo pusher or puller are DISABLED. NV_PFIFO_CACHE1_PUSH0=", (int) pdiagstruct->nv_pfifo_cache1_push0);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                               NV_PFIFO_CACHE1_PULL0=", (int) pdiagstruct->nv_pfifo_cache1_pull0);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING---The fifo will be STALLED under these conditions.\n\n");
    }
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The current channel context in the fifo is channel ", (int) (pdiagstruct->nv_pfifo_cache1_push1 & 0xFF));
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "running in ");
    if(pdiagstruct->nv_pfifo_cache1_push1 & 0x100){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DMA mode.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PIO mode.\n");
    }
    
    if(IsNV4(pDev) || IsNV5(pDev) || IsNV0A(pDev)){
        if((pdiagstruct->nv_pfifo_cache1_push1 & 0xFF)==0xf){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- This channel context indicates the fifo may be in an uninitialized state\n");
        }
    }else{
        if(IsNV10orBetter(pDev)){
            if((pdiagstruct->nv_pfifo_cache1_push1 & 0xFF)==0x1f){
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- This channel context indicates the fifo may be in an uninitialized state\n");
            }
        }
    }
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    
    if(pdiagstruct->nv_pfifo_dma_put == pdiagstruct->nv_pfifo_dma_get){      
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DMA PUT and GET are equal indicating the fifo is empty. ",(int) pdiagstruct->nv_pfifo_dma_get);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -Use the d option from the main menu to view the fifo contents.\n");
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DMA PUT and GET are NOT equal indicating the fifo is NOT empty. NV_PFIFO_CACHE1_GET = ",(int) pdiagstruct->nv_pfifo_dma_get);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                                                NV_PFIFO_CACHE1_PUT = ",(int) pdiagstruct->nv_pfifo_dma_put);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "   -If this condition persists the fifo may be disabled or stalled.\n");
    }
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");
}

VOID NvWatch_QuickDiag_master(PHWINFO pDev, PNVWATCHDIAGSTRUCT pdiagstruct)
{

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Running Master Control diagnostic ...");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");

    if(pdiagstruct->nv_pmc_intr_0){       
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has Interrupts pending. NV_PMC_INTR_0=", (int) pdiagstruct->nv_pmc_intr_0);
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PMEDIA, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Media Port engine INT is PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PFIFO, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo engine INT is       PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PGRAPH, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Graphics engine INT is   PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PVIDEO, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Video engine INT is      PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PTIMER, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Timer engine INT is      PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "CRTC INT is              PENDING. (VBLANK)\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PBUS, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Bus engine INT is        PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _SOFTWARE, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Software engine INT is   PENDING.\n");
        }

        if(!pdiagstruct->nv_pmc_intr_en_0){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has Interrupts disabled. NV_PMC_INTR_EN_0=", (int) pdiagstruct->nv_pmc_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- The Chip will be stalled under these conditions.\n\n");
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has Interrupts enabled. NV_PMC_INTR_EN_0=", (int) pdiagstruct->nv_pmc_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -All appears to be normal here.\n\n");
        }
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has NO Interrupts pending. NV_PMC_INTR_0=", (int) pdiagstruct->nv_pmc_intr_0);
        if (!pDev->Vga.Enabled){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "---WARNING !!!---This would not be expected in hires mode.\n");
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "  -The CRTC should need to service VBLANK.\n");

        }
        if(!pdiagstruct->nv_pmc_intr_en_0){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe Chip has Interrupts disabled. NV_PMC_INTR_EN_0=", (int) pdiagstruct->nv_pmc_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -The Chip is in an idle state. (disabled)\n\n");
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has Interrupts enabled. NV_PMC_INTR_EN_0=", (int) pdiagstruct->nv_pmc_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -All appears to be normal here.\n\n");
        }
    }
    
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PMEDIA, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Media Port Engine is                    ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Media Port Engine is                    DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PFIFO, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo Engine is                          ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo Engine is                          DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PGRAPH, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Graphics Engine is                      ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Graphics Engine is                      DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Timer and bus mastering logic Engine is ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Timer and bus mastering logic Engine is DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PFB, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Frame Buffer Engine is                  ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Frame Buffer Engine is                  DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PCRTC, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Dac and CRTC devices are                ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Dac and CRTC devices are                DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PVIDEO, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Video Scalar device is                  ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Video Scalar device is                  DISABLED.\n");
    }

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");
}

int NvWatch_QuickDiag(PHWINFO pDev)
{
    NVWATCHDIAGSTRUCT diagstruct,*pdiagstruct;

    pdiagstruct = (PNVWATCHDIAGSTRUCT) &diagstruct;

    if(IsNV4(pDev) || IsNV5(pDev) || IsNV0A(pDev)){
        NvWatch_NV04_FillDiagStruct(pDev, pdiagstruct);
    }else{
         if(IsNV10orBetter(pDev)){
             NvWatch_NV04_FillDiagStruct(pDev, pdiagstruct);
         }else{
             DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: Aborting ... device is disabled.\n");
             return(-1);
         }
    }
  
  NvWatch_QuickDiag_master(pDev, pdiagstruct);
  NvWatch_QuickDiag_fifo(pDev, pdiagstruct);
  //NvWatch_QuickDiag_graphics(pDev, pdiagstruct);
  //NvWatch_QuickDiag_instancemem(pDev, pdiagstruct);
}

//****TOP LEVEL MENU***************************************************************************

U032 NvWatch_Edit_NvRegs(PHWINFO pDev)
{
  char instring[]="00000000";
  DWORD ddata=0, daddr=0, save_offset;
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the Offset of the Nv Register to query.");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");

  if(!NvWatch_GetInputDword(&daddr)){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
    return(0);
  }  
  save_offset = daddr; 
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe data read is ", REG_RD32(daddr));
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Enter the new value for this register ->");

  if(!NvWatch_GetInputDword(&ddata)){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
    return(0);
  }  

  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe new value written is ", ddata);
  REG_WR32(save_offset, ddata);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The data read from the register is ", REG_RD32(save_offset));
}

void NvWatch_help(void)
{
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Resource Manager System View Extension for NV4\n\r\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Commands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      sx  - Set Device Context for Queries (Default is Device0)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      f   - Dump Fifo state\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      g   - Dump Graphics state\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      m   - Dump Master Control state\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      v   - Dump Video state\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      c   - Dump CRTC registers\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      n   - Instance Memory Stuff\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      x   - Context Information\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      d   - Fifo Info\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      e   - Edit Nv Registers\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      r   - Resource Manager Data Structures\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      t   - Quick Diag\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit\n\r\n\r");
}

void NvWatch_DumpCRTCRegs(PHWINFO pDev)
{
    U008 oldCR1F;
    U008 data08;
    U032 index;

    U032 Head = 0;  // To get this to compile, I'm hardcoding to Head 0. Need to add Head # to user interface, dump multiple sets.

    // save off the contents of CR1F
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, oldCR1F, Head);

    // Unlock extended crtc registers.
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RO_VALUE, Head);

    // print the 64 CRTC registers.
    for (index = 0; index < 64; index++)
    {
        if ((index % 16) == 0)
        {
            // go to next line
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
        }

        CRTC_RD(index, data08, Head);
        vmmOutDebugStringValue("#AL", data08);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  ");
    }

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");

    // restore contents of CR1F
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, oldCR1F, Head);
}


// This routine could be removed and the functions added to the pDev.
// For now this should be fine.
U032 NvWatch_Dispatch(PHWINFO pDev, U032 function)
{
    if(IsNV10orBetter(pDev)){
        switch(function){
            case NVWATCH_FUNC_GETHASHSIZE:
                return(NvWatch_NV10_GetHashSize(pDev)); break;
            case NVWATCH_FUNC_DUMP_FIFO:
                NvWatch_NV10_Dump_Fifo(pDev);             return(0); break;
            case NVWATCH_FUNC_DUMP_GRAPHICS:
                NvWatch_NV10_Dump_Graphics(pDev);         return(0); break;
            case NVWATCH_FUNC_DUMP_MASTER:
                NvWatch_NV10_Dump_Master(pDev);           return(0); break;
            case NVWATCH_FUNC_DUMP_VIDEO:
                NvWatch_NV10_Dump_Video(pDev);            return(0); break;
            case NVWATCH_FUNC_QUERYDEVICECONTEXT:
                NvWatch_NV10_Query_DeviceContext(pDev);   return(0); break;
            case NVWATCH_FUNC_DMAPUSH_AND_FIFO:
                NvWatch_NV10_DmaPushAndFifo(pDev);(pDev); return(0); break;
        }
    }else{
        switch(function){
            case NVWATCH_FUNC_GETHASHSIZE:
                return(NvWatch_NV04_GetHashSize(pDev)); break;
            case NVWATCH_FUNC_DUMP_FIFO:
                NvWatch_NV04_Dump_Fifo(pDev);             return(0); break;
            case NVWATCH_FUNC_DUMP_GRAPHICS:              
                NvWatch_NV04_Dump_Graphics(pDev);         return(0); break;
            case NVWATCH_FUNC_DUMP_MASTER:                
                NvWatch_NV04_Dump_Master(pDev);           return(0); break;
            case NVWATCH_FUNC_DUMP_VIDEO:                 
                NvWatch_NV04_Dump_Video(pDev);            return(0); break;
            case NVWATCH_FUNC_QUERYDEVICECONTEXT:         
                NvWatch_NV04_Query_DeviceContext(pDev);   return(0); break;
            case NVWATCH_FUNC_DMAPUSH_AND_FIFO:
                NvWatch_NV04_DmaPushAndFifo(pDev);(pDev); return(0); break;
        }
    }
}

#endif

// JJV - Just leave the prototype so that this can link. Basically no ifdef DEBUG in VXDSTUB.ASM.
void DotN_cmd_c(void)
{
#ifdef DEBUG
  BOOL keep_running=TRUE;
  char in_char;
  U032 dword_char;
  U032 hash_size;
  char pstring[]="NvWatch";
  PHWINFO pDev;

  pDev = NvDBPtr_Table[0];
 
  NvWatch_help();

  hash_size = NvWatch_Dispatch(pDev, NVWATCH_FUNC_GETHASHSIZE);
  hash_size >>= 16;
  hash_size &= 0x3;
  
  switch(hash_size){
    case 0:
      NvWatch_num_objects = 0x1000/8;
      break;
    case 1:
      NvWatch_num_objects = 0x2000/8;
      break;
    case 2:
      NvWatch_num_objects = 0x4000/8;
      break;
    case 3:
      NvWatch_num_objects = 0x8000/8;
      break;
  }
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
    in_char = get_winice_input();
    dword_char = (U032) in_char;

    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE; break;
      case 'f': // Fifo Registers
      case 'F': // Fifo Registers
        NvWatch_Dispatch(pDev, NVWATCH_FUNC_DUMP_FIFO); break;
      case 'g': // Graphics Registers
      case 'G': // Graphics Registers
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_DUMP_GRAPHICS); break;
      case 'm': // Master Control Registers
      case 'M': // Master Control Registers
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_DUMP_MASTER); break;
      case 'v': // Video Registers
      case 'V': // Video Registers
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_DUMP_VIDEO); break;
      case 'e': // Edit Data
      case 'E': // Edit Data
        NvWatch_Edit_NvRegs(pDev);
        break;
      case 'n': // Instance Memory stuff
      case 'N': // Instance Memory stuff
        NvWatch_Query_InstanceMemory(pDev);
        break;
      case 'x': // Context Data
      case 'X': // Context Data
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_QUERYDEVICECONTEXT);
      case 'r': // RM Stuff
      case 'R': // RM Stuff
        NvWatch_RMData(pDev);
        break;
      case 'd': // DmaPush and Fifo
      case 'D': // DmaPush and Fifo
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_DMAPUSH_AND_FIFO); break;
      case 't': // Chip Diag
      case 'T': 
        NvWatch_QuickDiag(pDev);
        break;
      case 'p': // Crush11 Tests
      case 'P': 
        NvWatch_Crush11_Tests(pDev);
        break;
      case 's': // Switch device
      case 'S': // Switch Device
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "    Enter the Device to query. (0-8)");
        in_char = get_winice_input();
        switch (in_char)
        {
          case '0':
            pDev = NvDBPtr_Table[0]; break;
            //NvWatch_Device = 0; break;
          case '1':
            pDev = NvDBPtr_Table[1]; break;
            //NvWatch_Device = 1; break;
          case '2':
            pDev = NvDBPtr_Table[2]; break;
            //NvWatch_Device = 2; break;
          case '3':
            pDev = NvDBPtr_Table[3]; break;
            //NvWatch_Device = 3; break;
          case '4':
            pDev = NvDBPtr_Table[4]; break;
            //NvWatch_Device = 4; break;
          case '5':
            pDev = NvDBPtr_Table[5]; break;
            //NvWatch_Device = 5; break;
          case '6':
            pDev = NvDBPtr_Table[6]; break;
            //NvWatch_Device = 6; break;
          case '7':
            pDev = NvDBPtr_Table[7]; break;
            //NvWatch_Device = 7; break;
          case '8':
            pDev = NvDBPtr_Table[8]; break;
            //NvWatch_Device = 8; break;
        }

        if(pDev == NULL)
        {
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nError: Not a valid device. setting default ...\r\n");
          pDev = NvDBPtr_Table[0];
          //NvWatch_Device = 0;
        }
          
        break;
      case 'c':
      case 'C':
          // Dump crtc registers
          NvWatch_DumpCRTCRegs(pDev);
          break;

      default: // Help
        NvWatch_help();
        break;  
    }
  }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\osdbg.c ===
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>
#include <configmg.h>
#include <vcomm.h>
#include <nvtypes.h>
#include <osdbg.h>

#ifdef DEBUG

DEVNODE dbgDevNode = 0xFFFFFFFF;
NvU32 dbgPowerState = CM_POWERSTATE_D3;
NvU32 dbgPowerSysState = 0x0;
NvU32 IsConfig98 = FALSE;

char * ppdbgPortStr_COM1[] = {
   DBG_W98_COM1_KEY_STR1,
   DBG_W98_COM1_KEY_STR2,
   DBG_COM1_KEY_STR3,
   DBG_COM1_KEY_STR4,
   };

char * ppdbgPortStr_COM2[] = {
   DBG_W98_COM2_KEY_STR1,
   DBG_W98_COM2_KEY_STR2,
   DBG_COM2_KEY_STR3,
   DBG_COM2_KEY_STR4,
   };

char * ppdbgPortStr_Parallel[] = {
   DBG_W98_PARALLEL_KEY_STR1,
   DBG_PARALLEL_KEY_STR2,
   };

typedef struct cm_array {
   char ** ppStr;
   NvU32   ulSize;
   } CM_ARRAY, * PCM_ARRAY;   

CM_ARRAY CmArray[] = {
   {ppdbgPortStr_COM1, sizeof(ppdbgPortStr_COM1)/sizeof(char **),},
   {ppdbgPortStr_COM2, sizeof(ppdbgPortStr_COM2)/sizeof(char **),},
   {ppdbgPortStr_Parallel, sizeof(ppdbgPortStr_Parallel)/sizeof(char **),},
   };


// Port Names
char * ppdbgPortNameStr[] = {
   DBG_COM1_PORTNAME,
   DBG_COM2_PORTNAME,
   DBG_PARALLEL_PORTNAME,
   };

extern int dbgObject_inuse;
extern DBGOBJECT DbgObject[];
extern DBGPORT DbgPort;

//
// This routine is a callback if the another proc tries to
// our serial port
//
DWORD StealProc(DWORD dwRefData, DWORD dwType)
{
   (VOID*)dwRefData;
   (VOID*)dwType;
   return 0x0;
}

//
// Walk the string of registry serial ports looking for the
// serial port name
//

NvU32 Locate_DevNode(PDEVNODE pdnDevNode, char * pStr[], NvU32 ulSize)
{
   NvU32 i;
   NvU32 ulReturn;

   ulReturn = CR_NO_SUCH_DEVNODE;
   for (i=0; i<ulSize; i++)
      {
      ulReturn = CMxx_Locate_DevNode(pdnDevNode, pStr[i], 0x0);
      if (CR_SUCCESS == ulReturn)
         break;
      }

   return ulReturn;       
}


//
// This routine is used to call CM_Set_DevNode_PowerState
// to activate the port that we want to use.  The bios
// enables the port but then Windows ACPI Policy Manager
// deactivates the port to reduce power 
//
NvU32 dbgEnableDevice(NvU32 nPort)
{
   NvU32 nReturn;

   nReturn = FALSE;

   if (CR_SUCCESS == Locate_DevNode(&dbgDevNode, CmArray[nPort].ppStr, CmArray[nPort].ulSize))
      {
      // Is this Win '98 Version of Configuration Manager
      // VCOMM will attempt to power the port down if 
      // the registry under SW_KEY\Vxd\VCOMM\EnablePowerManagement is nonzero
      if (CONFIG98_VERSION <= CMxx_Get_Version())
         {
         IsConfig98 = TRUE;
         if (CR_SUCCESS == CMxx_Get_DevNode_PowerState(dbgDevNode, &dbgPowerState, 0x0))
            {
            // Does it hurt to do this if EnablePowerManagement is zero???
            if (CR_SUCCESS == CMxx_Set_DevNode_PowerState(dbgDevNode, CM_POWERSTATE_D0, 0x0))
               {
               nReturn = TRUE;
               }
            }
         }
      }
   
   return nReturn;
}

DWORD hPort = 0x0;
PFNCONTENT hHandler = 0x0;
DWORD hResource;
NvU32 dbgEnableDevice2(PDBGPORT pDbgPort)
{
#if 1
   DWORD hContend;
#endif
   NvU32 nReturn;
   NvU32 nPort;
   nReturn = FALSE;

   if (DBG_OBJECT_SERIAL == dbgObject_inuse)
      {
      nPort = pDbgPort->uTag.Serial.uPort;
      // Unvirtualize the port
      VCD_Set_Port_Global(nPort+1);
      // Steal the port
      if (0x0 == hPort)
         {
         hPort = VCOMM_OpenComm(ppdbgPortNameStr[nPort], 0xFFFFFFFF);
         if (IE_BADID != hPort)
            {
            if (0x0 == hHandler)
               {
               hHandler = VCOMM_Get_Contention_Handler(ppdbgPortNameStr[nPort]); 
               if (0x0 != hHandler)
                  {
                  hResource = VCOMM_Map_Name_To_Resource(ppdbgPortNameStr[nPort]);
                  if (0x0 != hResource)
                     {
                     hContend = hHandler(ACQUIRE_RESOURCE, hResource, StealProc, 0xAA5555AA, TRUE);
                     if (0x0 != hContend)
                        nReturn = TRUE;
                     }
                  }
               }
            }
         }
      // when the port was virtualized it was reinit
      // let's init the way we like
      //Reinit 1 more time
      DbgObject[dbgObject_inuse].pInit(pDbgPort);          
      }

   return nReturn;
}

NvU32 dbgDisableDevice2(PDBGPORT pDbgPort)
{
   if (DBG_OBJECT_SERIAL == dbgObject_inuse)
      {
            
      // When we did the open an implicit VCOMM_PowerOnOffComm was called
      // here we need to undue this else we cannot hibernate
      VCOMM_PowerOnOffComm(dbgDevNode, CM_POWERSTATE_D3);
      }   

   return 0;
}

//
// This routine is used to return the port to its original state.
//
NvU32 dbgDisableDevice(NvU32 nPort)
{
   
   NvU32 nReturn = FALSE;

   if (0xFFFFFFFF != dbgDevNode)
      {
      if (CR_SUCCESS == CMxx_Set_DevNode_PowerState(dbgDevNode, dbgPowerState, 0x0))
         nReturn = TRUE;
      }

   return nReturn;
}

//
// routine to do a simple hex to ascii convert
//
VOID dbgFormat(char * pStr, NvU32 value)
{
	NvS32 i;
	NvS32 hex_digit;
	NvS32 j;
	char rData[8];

	// simple hex to ascii convert
	for (i=0;value!=0;value>>=4)
		{
		hex_digit=value & 0x0F;
		if (hex_digit < 10)
			rData[i]=hex_digit+'0';
		else
			rData[i]=hex_digit-10+'A';
		i++;
		}

	// reverse string
	for (j=0;j<i;j++)
		pStr[j]=rData[i-j-1];

	// if the number is zero then we need to insert zero digit
	if (0==i)
		pStr[i++]='0';

	// null terminate
	pStr[i]='\0';
}

//
// Null Table Functions
//

//
// Null Config Function
//
void dbgConfigNull(NvV32 * pDev)
{
	return;
}

//
// Null Init Function
//
void dbgInitNull(PDBGPORT pDbgPort)
{
	return;
}

//
// Null Display Function
//
void dbgDisplayNull(char * pStr)
{
	return;
}

//
// Null Open Function
//
void dbgOpenNull(NvV32 * pDev)
{
	return;
}

//
// Null Close Function
//
void dbgCloseNull(NvV32 * pDev)
{
	return;
}


// 
// The following is a simple IO Sections
//
//
// Read a byte from a Word Port
//
// Fix Help find and Figure out how to call internal io routines
NvU8 inpb(NvU16 uPort)
{
	NvU8 bReturn;

	_asm push	edx
	_asm mov	dx, uPort
	_asm in		al, dx
	_asm mov	bReturn, al
	_asm pop	edx

	return bReturn;
}

//
// Read a word from word Port
//
NvU16 inpw(NvU16 uPort)
{
	NvU16 wReturn;

	_asm push	edx
	_asm mov	dx, uPort
	_asm in		ax, dx
	_asm mov	wReturn, ax
	_asm pop	edx

	return wReturn;
}

//
// Write a byte to a word port
//
VOID outpb(NvU16 uPort, NvU8 bValue)
{
	_asm push	edx
	_asm mov	dx, uPort
	_asm mov	al, bValue
	_asm out	dx, al
	_asm pop	edx
}

//
// Write a word to a word port
//
VOID outpw(NvU16 uPort, NvU16 wValue)
{
	_asm push	edx
	_asm mov	dx, uPort
	_asm mov	ax, wValue
	_asm out	dx, ax
	_asm pop	edx
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\OSINIT.C ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* ModuleI: INIT.C                                                           *
*   This is the OS initialization module.  One time initialization code     *
*   is present here so it can be unloaded after the OS initialization phase *
*   is complete.                                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"
#include "vnvrmd.h"
#include "vpicd.h"
#include "vdd.h"
//#include "minivdd.h"
//#include "vpaged.h"
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include <state.h>
#include <class.h>
#include <os.h>
#include "oswin.h"
#include "vmm2.h"
#include "files.h"
#include "nvmisc.h"
#include "nvReg.h"
#include <nv10_hal.h>

#ifndef PC98
// PCI function ID for PC AT
#define PCI_FUNCTION_ID 0xB1
#else
// PCI function ID for PC98
#define PCI_FUNCTION_ID 0xCC
#endif // PC98

#define READ_CONFIG_BYTE        0x08
#define READ_CONFIG_DWORD       0x0A
#define WRITE_CONFIG_BYTE       0x0B
#define WRITE_CONFIG_DWORD      0x0D

//
// Globals
//
WIN9XHWINFO	win9xHwInfo[MAX_INSTANCE];

//
// Externs.
//
extern DISPLAYINFO osDisplayInfo;
extern VOID RmInitCpuInfo(PHWINFO);
extern VOID RmInitBusInfo(PHWINFO);

// This should already exist somewhere, right??
#define RM_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global\\System"

//---------------------------------------------------------------------------
//
//  Initialization routines.
//
//---------------------------------------------------------------------------
RM_STATUS initStack_frame
(
    PHWINFO pDev
)
{
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    RM_STATUS status;
    U032      i;
    
    //
    // Allocate it.
    //
    status = osAllocMem((VOID **)&pOsHwInfo->NvIsrStackFrameBase, STACK_SIZE);
    if (status)
        return (status);
    //
    // Lock it.
    //
    vmmLinPageLock(PAGE(pOsHwInfo->NvIsrStackFrameBase), NPAGES(((U032)pOsHwInfo->NvIsrStackFrameBase & PAGEMASK) + STACK_SIZE), 0);
    //
    // Insert fence guard.
    //
    pOsHwInfo->NvIsrStackFrame = pOsHwInfo->NvIsrStackFrameBase;
    for (i = 0; i < STACK_SIZE / 4; i++)
        *(pOsHwInfo->NvIsrStackFrame)++ = 'MRVN';
    (pOsHwInfo->NvIsrStackFrame)--;
    
    return (RM_OK);
}

//
// Initialize the Resource Manager semaphores.
//
RM_STATUS initSemaphore
(
    VOID
)
{
    //
    // Create semaphores.
    //
    rmSemaphore = vmmCreateSemaphore(0);
    osSemaphore = vmmCreateSemaphore(0);
    // Multi-Mon support semaphore.
    mmSemaphore = vmmCreateSemaphore(0);
    //
    // Prime the semaphores.
    //
    vmmSignalSemaphore(rmSemaphore);
    vmmSignalSemaphore(osSemaphore);
    vmmSignalSemaphore(mmSemaphore);
    return (RM_OK);
}
//
// Initialize the callback structure free list.
//
RM_STATUS initCallbackFreeList
(
    VOID
)
{
    RM_STATUS status;
    U032      i;
    
    osCallbackList = NULL;
    status = osAllocMem((VOID **)&osCallbackTable, sizeof(CALLBACK) * NUM_CALLBACKS);
    if (status)
        return (status);
    osCallbackFreeList = osCallbackTable;    
    for (i = 0; i < NUM_CALLBACKS - 1; i++)
    {
        osCallbackFreeList[i].Next = &(osCallbackFreeList[i + 1]);
    }
    osCallbackFreeList[i].Next = NULL;
    return (RM_OK);
}

//
// Currently not used, but a useful routine to determine if the chipset driver has been
// loaded. If the DeviceID/VendorID is in the registry under the GARTMiniports key, we'll
// assume the driver has been loaded (registry entry is setup in the chipset INF).
//
static BOOL IsChipsetDriverLoaded( PHWINFO pDev, U016 vendorid, U016 deviceid)
{
    U032 data, csid = (deviceid << 16) | vendorid;
    UCHAR *strGARTMP = "System\\CurrentControlSet\\Services\\VxD\\PCI\\GARTMiniports\\DDDDVVVV";
    UCHAR *pDV = &strGARTMP[56];      // ptr to where DeviceID and VenderID are concatenated
    S032 i;

    // convert each nibble of the Device/Vendor IDs into chars and concatenate
    for (i = 7; i >= 0; i--) {
        U008 ch = (U008) ((csid >> (i * 4)) & 0xF);

        if (ch >= 0x0 && ch <= 0x9)
            *pDV++ = '0' + ch;
        else
            *pDV++ = 'A' + (ch - 0xA);
    }

    if (osReadRegistryDword(pDev, strGARTMP, "Instance", &data) != RM_OK)
        return FALSE;
    else
        return TRUE;
}

//
// Initialize the channel allocation database.
//
RM_STATUS initChannelInfo
(
    VOID
)
{
    return (RM_OK);
}    

// This is a helper proc to detect an ALI1541 chipset.
// Returns: TRUE if ALI1541 is detected,
//          FALSE otherwise.
//
static BOOL IsALI1541ChipSet(CLIENT_STRUCT *pcrs)
{
    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID; // PCI_FUNCTION_ID
    pcrs->CBRS.Client_AL  = 0x02;            // FIND_PCI_DEVICE
    pcrs->CWRS.Client_CX = 0x1541;          // Device ID
    pcrs->CWRS.Client_DX = 0x10B9;          // Vendor ID
    pcrs->CWRS.Client_SI = 0;               // Index
    PCI(pcrs);
    
    return (pcrs->CBRS.Client_AH == 0);
}

// This is a helper proc to detect an Crush11 North Bridge chipset.
// Returns: TRUE if Crush11 is detected,
//          FALSE otherwise.
//
static BOOL IsCrush11ChipSet(CLIENT_STRUCT *pcrs)
{
    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID; // PCI_FUNCTION_ID
    pcrs->CBRS.Client_AL  = 0x02;            // FIND_PCI_DEVICE
    pcrs->CWRS.Client_CX = 0x01B7;          // Device ID
    pcrs->CWRS.Client_DX = 0x10DE;          // Vendor ID
    pcrs->CWRS.Client_SI = 0;               // Index
    PCI(pcrs);
    
    return (pcrs->CBRS.Client_AH == 0);
}

#define FB_TEST_VALUE     0xA5A5A5A5

//
// Initialize the Device Information structure.
//
RM_STATUS initMapping
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    U032 data;
    CLIENT_STRUCT  crs;
    struct VPICD_IRQ_Descriptor picIRQDesc;
    U032 fb_test, status = 0;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initMapping\n\r");
    //
    // Initialize structure size.
    //
    pDev->Mapping.Size = sizeof(pDev->Mapping);
    osStringCopy(pDev->Mapping.ID, "Device Mapping");
    pDev->Mapping.IntPin  = 0x01;      // Int #A

    nvAddr = (PHWREG)vmmMapPhysToLinear(pDev->Mapping.PhysAddr, 0x01000000, 0);    
    fbAddr = (PHWREG)vmmMapPhysToLinear(pDev->Mapping.PhysFbAddr, pDev->Mapping.fbLength, 0);

    //
    // Attempt to determine the current CPU type
    //
    RmInitCpuInfo(pDev);

    //
    // Before going any further, let's do a quick verification that this memory mapping is correct.
    //
    fb_test = fbAddr->Reg032[0];
    fbAddr->Reg032[0] = FB_TEST_VALUE;                  // write fb or NV_CONFIG_PCI_NV_0 (READ ONLY)
    if((data = fbAddr->Reg032[0]) != FB_TEST_VALUE)     // if we read back, its fb
    {
        // is it possible the device manager gave us physical addresses in the "wrong" order?
        // try swapping them
        data = (U032)nvAddr;
        nvAddr = fbAddr;
        fbAddr = (PHWREG)data;

        fbAddr->Reg032[0] = FB_TEST_VALUE;
        if((data = fbAddr->Reg032[0]) != FB_TEST_VALUE)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: NV not found at physical address ", pDev->Mapping.PhysAddr);
            return(RM_ERROR);    
        }
    }       
    else    // its framebuffer, restore the data (important if we are secondary display and have a message)
        fbAddr->Reg032[0] = fb_test;

    if (!pDev->Mapping.IntLine)   // we got this IRQ from config mgr. this should never be 0.
    {
        // if BIOS assigned and IRQ,
        // read reg 3C and look for IRQ number       
        pDev->Mapping.IntLine = REG_RD32(NV_PBUS_PCI_NV_15) & 0XFF;
        if (!pDev->Mapping.IntLine)
        {
            //vmmFatalErrorHandler((DWORD)"NVVDD: Unable to connect to IRQ.", 0);
            return (RM_ERROR);
        }
    }

    // 
    // Determine the chip type and initialize the chip-specific data
    // in the pDev structure.
    //

    // The architecture bits changed after NV3, so check the device ID to rule out NV3
    if (REG_RD_DRF(_PBUS, _PCI_NV_0, _DEVICE_ID_CHIP) == 3)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: NV3 found, incorrect driver!\n\r");
        return (RM_ERROR);
    }

    //
    // Hook up data/code from the ROM.
    //
    initHal(pDev);

    // We need to know which chip this is early during boot.
    nvHalMcControl(pDev, MC_CONTROL_SETREVISION);

    //
    // I hate to do this here, but the fbstate isn't called until after we map the
    // chip (of course), but I need to figure out right now how big is our framebuffer.
    //
    // Configure validated framebuffer resolution.  Note that the BIOS will be setting these
    // bits during post, and he uses the extension bit to denote an 8meg framebuffer.  So
    // check that first...
    //
    status = nvHalFbControl(pDev, FB_CONTROL_INIT);

    if (status != RM_OK) //Was FB config set up correctly? Did we find false memory configs?
    {
        return RM_ERROR;
    }

    biosAddr = (PHWREG)((U008*)nvAddr + pDev->Pram.HalInfo.PraminOffset);

    //
    // Enable PPro write-combining using MTRR
    //
    // Framebuffer only, all fb space, fb cache type 2
    //
    // IKOS workaround for NV5/NV10 emulation.
    // If the FB is allowed to be write-combined, bad pixels may be read in during
    // these bursts, so during emulation, don't allow the FB to be write-combined.
    // 
#ifndef IKOS
    if (mtrrGetVersion() && !IsCrush11ChipSet(&crs))
        mtrrSetPhysicalCacheTypeRange(pDev->Mapping.PhysFbAddr, 0, pDev->Framebuffer.HalInfo.RamSize, 2);
#endif
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using physical address ", pDev->Mapping.PhysAddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using linear   address ", (int)nvAddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB using physical address ", pDev->Mapping.PhysFbAddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB using linear   address ", (int)fbAddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using IRQ line ", pDev->Mapping.IntLine);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using IRQ pin  ", pDev->Mapping.IntPin);
    //
    // Map the the ROM address based on whether this is a motherboard or add in.
    //
    //
    // Add in NV board map ROM through NV Space.
    //
    romAddr = (PHWREG)((DWORD)nvAddr + DEVICE_BASE(NV_PROM));

    //
    // Some PCI BIOSs leave the ROM mapped.  This causes problems if it overlays
    // system RAM.  Just disable it.
    //
    REG_WR32(NV_PBUS_PCI_NV_12, 0);

    //
    // Make sure our PCI latency timer is sufficient (max it out)
    //
    REG_WR32(NV_PBUS_PCI_NV_3, DRF_NUM(_PBUS,_PCI_NV_3,_LATENCY_TIMER, NV_PBUS_PCI_NV_3_LATENCY_TIMER_248_CLOCKS));

    if (IsALI1541ChipSet(&crs))
    {
        // This chipset has a bug which causes it to read stale data.
        // An IO needs to be done to ensure all caches are flushed before
        // the Put is updated. 
        // This happens on both PCI and AGP.
        pDev->Mapping.doIOToFlushCache = 1;
        
        //
        // This chipset has another bug, confirmed by ALI, where it cannot
        // accept fast DEVSEL# at 100MHz bus speeds.  We cannot adjust our
        // DEVSEL# speeds, but we can delay our TRDY by one clock cycle, which
        // should have the same effect.
        //
        // Note that we (NV) have seen no improvement in any of the ALI1541
        // issues with this change, but ALI is adament there is a bug in the 1541
        // having to do with this logic.  Better safe than sorry.
        //
        // This bit is present in NV4, NV5, and NV10.
        //
        FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _PCIS_WRITE, _1_CYCLE);
        
        //
        // Force the drivers to not use AGP pushing for their command streams.  There is still
        // some unexplained cache coherency issues with memory when lots of AGP traffic is
        // present.  The problems are much less when running only PCI66 (or even PCI33) traffic.
        //
        // Only enable this flag if it doesn't already exist -- that way we have a method to
        // override the default behavior if necessary.  Since you tend not to change your motherboard
        // the first install of our drivers will enable the flag.
        //
        if (osReadRegistryDword(pDev, strDevNodeRM, NV_REG_SYS_SUPER7_COMPATIBILITY, &data) != RM_OK)
        {
            // Write to both local/global keys, since the drivers check in different paths
            osWriteRegistryDword(pDev, strDevNodeRM,        NV_REG_SYS_SUPER7_COMPATIBILITY, 1);
            osWriteRegistryDword(pDev, RM_GLOBAL_BASE_PATH, NV_REG_SYS_SUPER7_COMPATIBILITY, 1);
        }
    }
    else
    {
        // Also reset a stale NV_REG_SYS_SUPER7_COMPATIBILITY registry setting
        if (osReadRegistryDword(pDev, strDevNodeRM, NV_REG_SYS_SUPER7_COMPATIBILITY, &data) == RM_OK)
        {
            // Write to both local/global keys, since the drivers check in different paths
            osWriteRegistryDword(pDev, strDevNodeRM,        NV_REG_SYS_SUPER7_COMPATIBILITY, 0);
            osWriteRegistryDword(pDev, RM_GLOBAL_BASE_PATH, NV_REG_SYS_SUPER7_COMPATIBILITY, 0);
        }
    }
        
    //
    // Attempt to determine the FSB and Memory speeds
    //
    RmInitBusInfo(pDev);

    //
    // Backdoor AGP support.  If this is an AGP card and there is an Intel 440LX/BX in the
    // system, let's detect the current GART settings.  This allows us to use AGP outside
    // of DDraw in Win9X (specifically Win95)
    //
    // Are we AGP?
    //
    pRmInfo->AGP.AGPPhysStart = 0;
    pRmInfo->AGP.AGPLimit = 0;
    pDev->Chip.ReqAGPRate = 0x2;                  // default to AGP 2x    
    
    //
    // Instead of reading the strap, walk the PCI config space.  See if there is an AGP cap
    // after the power mgmt cap.
    //
    //if ((REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_BUS_TYPE) == NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP))
    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
    {
        U032 numRanges = 0;

        // Apply any AGP chipset workarounds or overrides
        NvUpdateAGPConfig(pDev);

        // Set the AGP limit to the WC part of the Aperture
        osUpdateAGPLimit(pDev);

    }  // AGP

#ifdef PC98
    //
    // POST the chip if we're running on a system with no VGA BIOS
    //
    NvPost();
    // set a mode to get VGA running, or else we will hang on DDC
    VBESetMode(0x101, NULL);
#endif // PC98
    
    //
    // Install hardware interrupt routine through PIC device.
    //
    picIRQDesc.VID_IRQ_Number       = (U016) pDev->Mapping.IntLine;
    picIRQDesc.VID_Options          = VPICD_OPT_CAN_SHARE;
    picIRQDesc.VID_Hw_Int_Proc      = (DWORD) osInterrupt;
    picIRQDesc.VID_IRET_Time_Out    = 500;
    picIRQDesc.VID_Virt_Int_Proc    = 0;
    picIRQDesc.VID_EOI_Proc         = 0;
    picIRQDesc.VID_Mask_Change_Proc = 0;
    picIRQDesc.VID_IRET_Proc        = 0;

    //
    // Wait for PMC state change to LOAD before re-enabling the interrupt line.
    //
    CLI
    pDev->Mapping.hpicIRQ = (U032) VPICD_Virtualize_IRQ(&picIRQDesc);
    STI
    VPICD_Physically_Mask(pDev->Mapping.hpicIRQ);
    VPICD_Physically_Unmask(pDev->Mapping.hpicIRQ);
//    picPhysicallyMask(hpicIRQ);
//    picPhysicallyUnmask(hpicIRQ);

    // Check if "DoIOToFlushCache" override exists.
    if (osReadRegistryDword(pDev, strDevNodeRM, "DoIOToFlushCache", &data) == RM_OK)
    {
        pDev->Mapping.doIOToFlushCache = 1;
    } 

    // write the name of the RM VXD in the registry
    if (osWriteRegistryBinary(pDev, strDevNodeRM, strRmCoreName, strRmCoreVxd, osStringLength(strRmCoreVxd)+1) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: WriteRegistry of RmCoreName failed\n\r");
    } 

    return (RM_OK);
}

RM_STATUS initFbEx
(
    PHWINFO pDev
)
{
    S032  fbCalcMemSize(VOID);
    U032 calc_max_bw (VOID);
    U032 size;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initFramebufferEx\n\r");
    //
    // Get screen resolution and framebuffer configuration from registry.
    //
    pDev->Dac.HalInfo.Depth = (osDisplayInfo.InfoFlags & REGISTRY_BPP_NOT_VALID) ? 8 : osDisplayInfo.Bpp;

//
//7/12(DDD) commenting out the ifdef below to fix for reboot keeping at 60Hz bug
// RM guys please fix approriately and remove my comments
// I'm placing these here so somebody will look at this
//
//#ifdef NV3_HW                    
    //
    // BUG WORKAROUND: If the user has set a specific refresh rate via the Win95 OSR2+ control
    // panel, the resulting refresh rate will always return MONITOR_INFO_NOT_VALID.  But the
    // refresh value is correct!  Huh...
    //
    // So until we can find the VDD (?) bug, if the refresh value is valid (>60,<250) for our
    // known refresh settings, let it through.
    //
    if ((osDisplayInfo.InfoFlags & MONITOR_INFO_NOT_VALID) &&
        (osDisplayInfo.InfoFlags & REFRESH_RATE_MAX_ONLY) &&
        (osDisplayInfo.RefreshRateMax >= 60) &&
        (osDisplayInfo.RefreshRateMax <= 250))
            osDisplayInfo.InfoFlags &= ~MONITOR_INFO_NOT_VALID;
//#endif // NV3_HW                    
    if ((osDisplayInfo.InfoFlags & (MONITOR_INFO_NOT_VALID | MONITOR_INFO_DISABLED_BY_USER))
     || (osDisplayInfo.RefreshRateMax == 0xFFFFFFFF)
     || (osDisplayInfo.RefreshRateMax == 0))
    {
        pDev->Framebuffer.HalInfo.RefreshRate  = 60;
        pDev->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
        pDev->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    }
    else
    {
        pDev->Framebuffer.HalInfo.RefreshRate  = osDisplayInfo.RefreshRateMax;
        pDev->Framebuffer.HSyncPolarity = osDisplayInfo.HorzSyncPolarity;
        pDev->Framebuffer.VSyncPolarity = osDisplayInfo.VertSyncPolarity;
    }
    // This is because we might have shut down with > 800x600, and then rebooted on TV,
    // in which case the registry will have a resolution we cannot support. 
    // The display driver should call in NvConfigSet to set new resolution. 
    // We should never see HorizDisplayWidth == 0, but just in case, we'll check and set to registry values if it is.
    if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 0) // display driver should have called NvSetConfig to set these
    {
        pDev->Framebuffer.HalInfo.HorizDisplayWidth = osDisplayInfo.XRes;
        pDev->Framebuffer.HalInfo.VertDisplayWidth  = osDisplayInfo.YRes;
    }
    pDev->Framebuffer.HorizFrontPorch = 0;
    pDev->Framebuffer.HorizSyncWidth  = 0;
    pDev->Framebuffer.HorizBackPorch  = 0;
    pDev->Framebuffer.VertFrontPorch  = 0;
    pDev->Framebuffer.VertSyncWidth   = 0;
    pDev->Framebuffer.VertBackPorch   = 0;
    pDev->Framebuffer.CSync           = BUFFER_CSYNC_DISABLED;
    pDev->Dac.HalInfo.VClk            = 0;
    //
    // Check for valid TV mode
    //
#if 0   // taking this out -- display driver is now responsible
    if (pDev->Framebuffer.MonitorType != MONITOR_TYPE_VGA)
        if (pDev->Framebuffer.HalInfo.HorizDisplayWidth > 800)
        {
            pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;
            pDev->Framebuffer.HalInfo.VertDisplayWidth  = 480;
        } 
#endif
    //
    // Calculate the framebuffer count based on the configuration with double buffering.
    //
    size = pDev->Dac.HalInfo.Depth / 8
         * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth
         * 2;
    if (size > pDev->Framebuffer.HalInfo.RamSize)
        size = 0;
    else
        size = pDev->Framebuffer.HalInfo.RamSize - size;

    //
    // Only enable single arch buffering
    //
    pDev->Framebuffer.Count = 1;

    return (RM_OK);
}

RM_STATUS initGrEx
(
    PHWINFO pDev
)
{
    return (RM_OK);
}
RM_STATUS initDacEx
(
    PHWINFO pDev
)
{ 
    // Setup the timing information for the initial mode set.
//    osSetupForNewStyleModeSet(pDev);
    return (RM_OK);
}
RM_STATUS initFifoEx
(
    PHWINFO pDev
)
{
//    pDev->Fifo.RetryCount = vmmGetProfileDecimalInt(pDev->Fifo.RetryCount, strNv, "FifoRetryCount");
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\vmmwrap.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997. All rights reserved.
//
//	VMM Call functions
//	These are wrappers for VMM services (a few other VxD services too)
//  Some other services are defined as macros in VMM2.H

#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"
#include "vpicd.h"
#include "vdd.h"
// NVAUDIO does not want to include all
// kernel header files that nvrm.h includes
#if !defined NVAUDIO
#include <nvrm.h>
#include "nvrmwin.h"
#include "vnvrmd.h"
#include "oswin.h"
#else
#include <nvtypes.h>
#endif
#include "vmm2.h"		// more vmm services
//
// pragmas
//
#pragma warning(disable : 4035)

//	return 2 DWORDS of descriptor in address passed as argument	
VOID vmmBuildDescriptorDWORDs(U032 DESCBase, U032 DESCLimit, U032 DESCType, U032 DESCSize, U032 Flags, QUADWORD *DescQWORD)
{
			__asm {
				mov		eax, Flags
				push	eax
				mov		eax, DESCSize
				push	eax
				mov		eax, DESCType
				push	eax
				mov		eax, DESCLimit
				push	eax
				mov		eax, DESCBase
				push	eax
			}
	        CALL_VMM(BuildDescriptorDWORDs);
			// return descriptor via pointer DescQWORD
			__asm {
				push	esi
                mov		esi,DescQWORD
				mov		[esi], eax
				mov		[esi+4], edx
                pop		esi
				add		esp,5*4
			}
}

U032 vmmFreeLDTSelector(U032 vmh, U032 Selector, U032 Flags)
{
			__asm {
            	mov		eax, Flags		
				push	eax				
				mov		eax, Selector	
				push	eax				
				mov		eax, vmh		
				push	eax				
			}
	        CALL_VMM(Free_LDT_Selector)     
			_asm add	esp,3*4
}

U032 vmmAllocateGDTSelector(U032 DescDWORD1, U032 DescDWORD2, U032 Flags)
{
			__asm {
            	push	edx		
				mov		eax, Flags	
				push	eax		
			 	mov		eax, DescDWORD2	
			 	push 	eax		
			 	mov 	eax, DescDWORD1	
			 	push 	eax		
			}
	        CALL_VMM(Allocate_GDT_Selector) 
            __asm {
				add		esp,3*4
				pop		edx
            }
// return:  EAX = new selector 
//			EDX low =  GDT selector
//			EDX high = number of selectors in GDT
//			we don't use edx, so we push and pop to preserve it for the invoking code
}

U032 vmmAllocateLDTSelector(U032 vmh, U032 DescDWORD1, U032 DescDWORD2, U032 Count, U032 Flags)
{
			__asm {
            	push	edx				
				mov		eax, Flags		
				push	eax				
				mov		eax, Count		
				push	eax				
				mov		eax, DescDWORD2	
				push	eax				
				mov		eax, DescDWORD1	
				push	eax				
				mov		eax, vmh
                push	eax
			}
            CALL_VMM(Allocate_LDT_Selector) 
			__asm {
				add		esp, 5*4
				pop		edx		
			}
// return:  EAX = new selector 
//			EDX low =  GDT selector
//			EDX high = number of selectors in GDT
//			we don't use edx (or eax) so we push and pop to preserve it for the invoking code
}           


//	the only reason this needs to be a function is so it can be used as an expression
U032 vmmGetSystemTime()
{
            CALL_VMM(Get_System_Time)
}

U032 vmmCallPriorityVMEvent(U032 PriorityBoost, U032 vmh, U032 flags, U032 RefData, U032 Callback, U032 Timeout)
{
			_asm   mov eax, PriorityBoost 
			_asm   mov ebx, vmh
			_asm   mov ecx, flags		   
			_asm   mov edx, RefData
			_asm   mov esi, Callback
			_asm   mov edi, Timeout
			CALL_VMM(Call_Priority_VM_Event)	
			_asm   mov eax, esi
}


VOID vmmSimulatePush(U032 Value)
{
			_asm	mov eax, Value
            CALL_VMM(Simulate_Push)  
}

VOID vmmSimulateFarCall(U032 Segment, U032 Off)
{
			_asm	mov ecx, Segment
			_asm	mov edx, Off
			CALL_VMM(Simulate_Far_Call)
}

U032 vmmPageCheckLinRange(U032 PageBase, U032 PageCount, U032 flags) 
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, PageCount	
			_asm	push	eax			
			_asm	mov	eax, PageBase	
			_asm	push	eax			
            CALL_VMM(_PageCheckLinRange)           
			_asm 	add	esp,3*4
}

U032 vmmLinPageLock(U032 HLinPgNum, U032 nPages, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, HLinPgNum	
			_asm	push	eax			
            CALL_VMM(_LinPageLock)                  
			_asm 	add	esp,3*4
}

U032 vmmLinPageUnLock(U032 HLinPgNum, U032 nPages, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, HLinPgNum	
			_asm	push	eax			
            CALL_VMM(_LinPageUnLock)               
			_asm 	add	esp,3*4
}

U032 vmmPageReserve(U032 uPage, U032 nPages, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, uPage	
			_asm	push	eax			
            CALL_VMM(_PageReserve)               
			_asm 	add	esp,3*4
}

U032 vmmPageCommitPhys(U032 uLinPage, U032 nPages, U032 uPhysPage, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, uPhysPage		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, uLinPage	
			_asm	push	eax			
            CALL_VMM(_PageCommitPhys)               
			_asm 	add	esp,4*4
}

U032 vmmPageDecommit(U032 uLinPage, U032 nPages, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, uLinPage	
			_asm	push	eax			
            CALL_VMM(_PageDecommit)               
			_asm 	add	esp,3*4
}


VOID vmmPageAllocate(U032 nPages, 
			U032 pType, 
            U032 VM, 
            U032 AlignMask, 
			U032 minPhys, 
            U032 maxPhys, 
            U032 PhysAddr, 
            U032 flags, 
            QUADWORD *Desc)
{
			_asm {
				mov		eax,flags
                push	eax
				mov		eax,PhysAddr
                push	eax
				mov		eax,maxPhys
                push	eax
				mov		eax,minPhys
                push	eax
				mov		eax,AlignMask
                push	eax
				mov		eax,VM
                push	eax
				mov		eax,pType
                push	eax
				mov		eax,nPages
                push	eax
            }
            CALL_VMM(_PageAllocate)                 \
			_asm {
            	push	esi
                mov		esi, Desc
            	mov		[esi], eax
            	mov		[esi+4], edx
				pop		esi
			 	add		esp,8*4
			}
}

VOID vmmPageGetSizeAddr(U032 hMem, U032 flags, QUADWORD *desc64)
{
			_asm {
				mov		eax, flags		
				push	eax				
				mov		eax, hMem		
				push	eax				
			}
            CALL_VMM(_PageGetSizeAddr)
			_asm {
				push	esi
                mov		esi, desc64
            	mov		[esi], eax
                mov		[esi+4], edx
                pop		esi
				add		esp,2*4
			}
}

U032 vmmPageLock(U032 hMem, U032 nPages, U032 PageOff, U032 flags)
{
			_asm	mov		eax, flags		
			_asm	push	eax				
			_asm	mov		eax, PageOff	
			_asm	push	eax				
			_asm	mov		eax, nPages		
			_asm	push	eax				
			_asm	mov		eax, hMem		
			_asm	push	eax				
            CALL_VMM(_PageLock)                    
			_asm 	add		esp,4*4
}

U032 vmmPageUnLock(U032 hMem, U032 nPages, U032 PageOff, U032 flags) 
{
			_asm 	mov		eax, flags		
			_asm 	push	eax				
			_asm 	mov		eax, PageOff	
			_asm 	push	eax				
			_asm 	mov		eax, nPages		
			_asm 	push	eax				
			_asm 	mov		eax, hMem		
			_asm 	push	eax				
            CALL_VMM(_PageUnLock)                   
			_asm 	add 	esp,4*4
}

U032 vmmPageFree(U032 hMem, U032 flags)
{
			_asm	 mov	eax, flags		
			_asm	 push	eax				
			_asm	 mov	eax, hMem		
			_asm	 push	eax				
            CALL_VMM(_PageFree)  	
			_asm add esp,2*4
}

VOID vmmGetDescriptor(U032 Selector, U032 VM, U032 flags, QUADWORD *Desc)
{
			_asm {
            	mov		eax, flags		
			 	push	eax				
			 	mov		eax, VM			
			 	push	eax				
			 	mov		eax, Selector	
			 	push	eax				
			}
            CALL_VMM(_GetDescriptor)
			_asm {
            	push	esi
                mov		esi, Desc
			 	mov		[esi], eax	
			 	mov		[esi+4], edx
				pop		esi
			 	add		esp,3*4
			}
}

U032 vmmSetDescriptor(U032 Selector, U032 VM, U032 DescDWORD1, U032 DescDWORD2, U032 flags)
{
			_asm {
            	mov		eax, flags		
			 	push	eax				
			 	mov		eax, DescDWORD2	
			 	push	eax				
			 	mov		eax, DescDWORD1	
			 	push	eax				
			 	mov		eax, VM			
			 	push	eax				
			 	mov		eax, Selector	
			 	push	eax				
			}
            CALL_VMM(_SetDescriptor)
			_asm add	esp,5*4
}

U032 vmmSelectorMapFlat(U032 VMh, U032 Selector, U032 flags)
{
			_asm {
            	mov		eax, flags
			 	push	eax				
			 	mov		eax, Selector	
			 	push	eax				
			 	mov		eax, VMh
			 	push	eax				
			}
            CALL_VMM(_SelectorMapFlat)              
			_asm add	esp,3*4
}

U032 vmmGetSysVMHandle()
{
			CALL_VMM(Get_Sys_VM_Handle)
			_asm	mov		eax, ebx
}

U032 vmmGetCritSectionStatus(VOID)
{
			CALL_VMM(Get_Crit_Section_Status)
			_asm	mov		eax, ecx		// return # of times crit section claimed
}

U032 vmmCopyPageTable(U032 LinPgNum, U032 nPages, U032 PageBuf, U032 flags)
{
			_asm {
            	mov		eax, flags
                push	eax
                mov		eax, PageBuf
                push	eax
                mov		eax, nPages
                push	eax
                mov		eax, LinPgNum
                push	eax
              }
            CALL_VMM(_CopyPageTable)                
			_asm add	esp,4*4
}

U032 vmmMapPhysToLinear(U032 PhysAddr, U032 nBytes, U032 flags)
{
			_asm {
            	mov		eax, flags
                push	eax
                mov		eax, nBytes
                push	eax
                mov		eax, PhysAddr
                push	eax
			}
            CALL_VMM(_MapPhysToLinear)              
			_asm add	esp,3*4
}

U032 vmmGetCurrentContext(VOID)
{
            CALL_VMM(_GetCurrentContext)           
}

U032 vmmContextSwitch(U032 Context)
{
            _asm	mov		eax, Context
            _asm 	push	eax
            CALL_VMM(_ContextSwitch)
            _asm 	add	esp,4
}

U032 vmmGetProfileHexInt(U032 Default, char *Profile, char *Keyname)
{
			_asm {
                mov		eax, Default
                mov		esi, Profile
            	mov		edi, Keyname
			}
			CALL_VMM(Get_Profile_Hex_Int)
}            

U032 vmmGetProfileDecimalInt(U032 Default, char *Profile, char *Keyname)
{
			_asm {
                mov		eax, Default
                mov		esi, Profile
            	mov		edi, Keyname
			}
            CALL_VMM(Get_Profile_Decimal_Int)       
}

VOID vmmFatalErrorHandler(U032 MsgPtr, U032 ErrFlags)
{
			_asm 	mov		eax, ErrFlags		
			_asm 	mov		esi, MsgPtr	
            CALL_VMM(Fatal_Error_Handler)           
}

VOID vmmCallBackExit(U032 flag)
{
			_asm	mov		eax, flag	
            _asm 	stc                
            _asm 	or		eax, eax   
            _asm	jnz    cbExit      
            _asm	clc                
            _asm	cbExit:            
}

VOID vmmCallBackEntry(VOID)
{
}

VOID vmmSaveClientState(CRS *Buffer)		
{
			_asm	mov		edi, Buffer	
            CALL_VMM(Save_Client_State)             
}

VOID vmmRestoreClientState(CRS *Buffer)   
{
			_asm	mov		esi, Buffer	
            CALL_VMM(Restore_Client_State)          
}

U032 vmmYield(U032 timeout)
{
            _asm mov eax, timeout
            CALL_VMM(Time_Slice_Sleep);
}

U032 vmmCreateSemaphore(U032 TokenCount)	
{
			_asm	mov	ecx, TokenCount	
            CALL_VMM(Create_Semaphore)   
}

U032 vmmWaitSemaphore(U032 Semaphore, U032 Flags)	
{
			_asm	mov eax, Semaphore	
			_asm   mov ecx, Flags	
            CALL_VMM(Wait_Semaphore) 
}			

U032 vmmSignalSemaphore(U032 Semaphore)	
{
			_asm	mov	eax, Semaphore
            CALL_VMM(Signal_Semaphore)   
}			

U032 vmmCreateMutex(U032 Boost, U032 Flags)	
{
			_asm	mov	eax, Flags		
			_asm 	push	eax			
			_asm	mov	eax, Boost		
			_asm	push	eax			
            CALL_VMM(_CreateMutex)                  
			_asm 	add	esp,2*4
}

U032 vmmEnterMutex(U032 Mutex, U032 Flags)	
{
			_asm	mov	eax, Flags		
			_asm 	push	eax			
			_asm	mov	eax, Mutex		
			_asm	push	eax			
            CALL_VMM(_EnterMutex)                  
			_asm 	add	esp,2*4
}			

U032 vmmLeaveMutex(U032 Mutex)	
{
			_asm	mov	eax, Mutex		
			_asm	push	eax			
            CALL_VMM(_LeaveMutex)                  
			_asm 	add	esp,1*4
}			

U032 picGetIRQVirtualizedStatus(U032 IRQnum, U032 VMh)
{
            //
            // We need to preserve the CY flag, and if we use
            // the VPICD_Get() function the compiler will
            // readjust the stack upon return, therefore
            // destroying the CY flag.  So, let's just
            // call VPICD directly.
            //
            //VPICD_Get_IRQ_Complete_Status(IRQnum, VMh);
            __asm xor ecx,ecx
            __asm mov eax,IRQnum
            VxDCall(VPICD_Get_IRQ_Complete_Status)
			_asm	sbb		eax, eax				// set return value to carry value        
        
}

U032 vmmGARTReserve(U032 pDevObj, U032 ulNumPages, U032 ulAlignMask, U032 pulGARTDev, U032 ulFlags)
{
			_asm {
			        push	ulFlags
			        push	pulGARTDev			
			        push	ulAlignMask			
			        push	ulNumPages			
			        push	pDevObj
            }                    			
            CALL_VMM(_GARTReserve)                  
			_asm 	add	esp,5*4
}

U032 vmmGARTCommit(U032 pGARTLin, U032 ulPageOffset, U032 ulNumPages, U032 pulGARTDev, U032 ulFlags)
{
			_asm {
			        push	ulFlags
			        push	pulGARTDev			
			        push	ulNumPages			
			        push	ulPageOffset			
			        push	pGARTLin
            }                    			
            CALL_VMM(_GARTCommit)                  
			_asm 	add	esp,5*4
}

U032 vmmGARTUnCommit(U032 pGARTLin, U032 ulPageOffset, U032 ulNumPages)
{
			_asm {
			        push	ulNumPages			
			        push	ulPageOffset			
			        push	pGARTLin
            }                    			
            CALL_VMM(_GARTUncommit)                  
			_asm 	add	esp,3*4
}

U032 vmmGARTFree(U032 pGARTLin)
{
			_asm {
			        push	pGARTLin
            }                    			
            CALL_VMM(_GARTFree)                  
			_asm 	add	esp,1*4
}

U032 vmmGARTMemAttributes(U032 pGARTLin, U032 ulFlags)
{
			_asm {
			        push	ulFlags
			        push	pGARTLin
            }                    			
            CALL_VMM(_GARTMemAttributes)                  
			_asm 	add	esp,2*4
}

U032 mtrrGetVersion(VOID)
{
            CALL_VMM(_MTRR_Get_Version) 
}


// called as        mtrrSetPhysicalCacheTypeRange(nvInfo->Mapping.PhysFbAddr, 0, 0x400000, 0);
U032 mtrrSetPhysicalCacheTypeRange(U032 arg1, U032 arg2, U032 arg3, U032 arg4)
{
			_asm {
            	push	arg4
                push	arg3
                push	arg2
                push	arg1
			}
            CALL_VMM(_MTRRSetPhysicalCacheTypeRange)           
//			_asm	add	esp,16		// the callee adjusted the stack
}

U016 vddGetVersion(VOID)
{
            CALL_VDD(VDD_Get_Version)        
}

U032 vddGetDisplayInfo(U032 OsDeviceHandle, PDISPLAYINFO Info, U032 infoSize)
{
			_asm	mov		eax, Info
            _asm    mov     ebx, OsDeviceHandle
            _asm	mov		ecx, infoSize
            CALL_VDD(VDD_Get_DISPLAYINFO)    
}

//	write null terminated string to the debugging device
VOID vmmOutDebugString(char *String)	
{
		_asm	pushfd				
		_asm	pushad				
		_asm 	mov esi, String		
		CALL_VMM(Out_Debug_String)	
		_asm	popad				
		_asm	popfd
}

//	write null terminated string to the debugging device
//	the string contains a register placeholder, so the actual register value will be printed also
VOID vmmOutDebugStringValue(char *String, U032 Value)	
{
		_asm	mov eax, Value
		_asm	pushfd				
		_asm	pushad				
		_asm 	mov esi, String		
		CALL_VMM(Out_Debug_String)	
		_asm	popad				
		_asm	popfd
}

VOID	dbgBreakPoint()
{
	_asm	int	3
}

#ifdef DEBUG
// Test if the debugger is installed.
U032 vmmTestDebugInstalled(void)	
{
  U032 return_val;
          
  CALL_VMM(Test_Debug_Installed)
  _asm  mov    return_val,0  
  _asm	jz     installedExit      
  _asm  mov    return_val,1  
  _asm	installedExit:     
  return(return_val);       
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nv10\nv10wtch.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NV10wtch.C                                                        *
*   Winice .N Debug Interface. NV10 code                                    *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito 2/6/98
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"
#include "nv10_hal.h"

#ifdef DEBUG

//
// prototypes
//
U032 NvWatch_GetObjectFromInst  (PHWINFO, U032, U032 *);
U032 NvWatch_Dump_HT_Object_From_Handle(PHWINFO, U032);
VOID NvWatch_display_prompt     (PHWINFO, char *);
char get_winice_input           (VOID);

//
// defines
//
#define NVWATCH_SIMPLE      0
#define NVWATCH_COMPLEX     1
#define INSTANCE_MEM_SPACE  nvAddr 
#define CONTEXT_USE_PUT     0
#define CONTEXT_USE_GET     1

//****NV CONTEXT MENU******************************************************************************

void NvWatch_NV10_Dump_SubChannelContext(PHWINFO pDev, U032 p_channel)
{
  U032  sub_counter;
  U032  nvwatch_fifo_engine_cache1;
  U032  enginet, *inst_ptr, tempv;

  nvwatch_fifo_engine_cache1 = REG_RD32(NV_PFIFO_CACHE1_ENGINE);
  // For each subchannel (Dump the Engine, then the object).
  for(sub_counter=0;sub_counter<NUM_SUBCHANNELS;sub_counter++){
    enginet = nvwatch_fifo_engine_cache1;
    enginet &= 3;
    switch(enginet){
      case 0:
        // We need to get the channel.
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Software Object in Fifo cache0 for Subchannel ",sub_counter);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Accessing pDev->DBfifoTable ...");
        if (pDev->DBfifoTable[p_channel].InUse == FALSE)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: pDev->DBfifoTable NOT InUse !??");
        else{
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Object Name = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Name);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Object Class = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Class->Type);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "CHID = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->ChID);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Subchannel = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Subchannel);
//////    U032       Name;
//////    PCLASS     Class;
//////    U032       ChID;
//////    U032       Subchannel;
//////    NODE       Node[NUM_FIFOS];
//////    POBJECT    Next;
//////    PDMAOBJECT NotifyXlate;
//////    U032       NotifyAction;
//////    U032       NotifyTrigger;
//////    PEVENTNOTIFICATION NotifyEvent;
        }  
        break;
      case 1:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Graphics Object in Fifo cache0 for Subchannel ",sub_counter);
        
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE1 = ",REG_RD32(NV_PGRAPH_CTX_CACHE1(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE2 = ",REG_RD32(NV_PGRAPH_CTX_CACHE2(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE3 = ",REG_RD32(NV_PGRAPH_CTX_CACHE3(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE4 = ",REG_RD32(NV_PGRAPH_CTX_CACHE4(sub_counter)));
        
        tempv = (U032) REG_RD32( NV_PGRAPH_CTX_CACHE4(sub_counter) );
        tempv &= 0xFFFF;
        tempv <<= 4;
        tempv += (U032) (INSTANCE_MEM_SPACE + (pDev->Pram.HalInfo.PraminOffset/4));
        inst_ptr = (U032 *) tempv;
        
        {
          U032 DHandle;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDumping the CTX_CACHE4 Object ...");
          tempv = (U032) REG_RD32( NV_PGRAPH_CTX_CACHE4(sub_counter) );
          tempv &= 0xFFFF;
          if(!NvWatch_GetObjectFromInst(pDev, tempv, &DHandle)){
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: Object NOT FOUND !\n");
          }else{  
              NvWatch_Dump_HT_Object_From_Handle(pDev, DHandle);
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n");
          }  
        }
        break;
      case 2:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DVD Object in Fifo cache0 for Subchannel ",sub_counter);
        break;
      default:
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: INVALID Object in Fifo cache0!");
        break;
    }
    nvwatch_fifo_engine_cache1 >>= 4;
  }
}

void NvWatch_NV10_ContextInfo_help(PHWINFO pDev)
{

/////  NvWatch_channel = REG_RD32(NV_PGRAPH_CTX_USER);
/////  NvWatch_channel >>= 24;
/////  NvWatch_channel &= NUM_FIFOS-1; 
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      s   - Query SubChannel Contexts (Currently supports active channel ONLY\n\r");
//  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "            Active Channel = ",NvWatch_channel);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      ?   - ???\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      q   - quit this\n\r\n\r");
}

VOID NvWatch_NV10_Query_DeviceContext(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  U032 m_channel=0;
  char pstring[]="NvWatch Context";

  NvWatch_NV10_ContextInfo_help(pDev);
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 's':
      case 'S':
        {
          U032 save_pgraph_fifo;
          
          // Clear the NV_PGRAPH_FIFO so that it can be read.
          save_pgraph_fifo = REG_RD32(NV_PGRAPH_FIFO);
          REG_WR32(NV_PGRAPH_FIFO, 0);
          NvWatch_NV10_Dump_SubChannelContext(pDev, m_channel);
          // Restore the NV_PGRAPH_FIFO.
          REG_WR32(NV_PGRAPH_FIFO, save_pgraph_fifo);
        }  
        break;
      case 'c': // Dump hash table
      case 'C': // Dump hash table
        break;
      default: // Help
        NvWatch_NV10_ContextInfo_help(pDev);
        break;  
    }
  }
}

//****DMA PUSHER AND FIFO MENU******************************************************************************

// THE FIFO: Actually 2X the HW size. A second alias image exists.
//-----------------------------------------
//|0                                      | <-- PFIFO_PUT (word pointer)
//|---------------------------------------| <-- PFIFO_GET ( "     "    )
//|1                                      |
//|---------------------------------------| If PFIFO_PUT==PFIFO_GET then the Fifo is empty
//|2                                      |
//|---------------------------------------| If (PFIFO_PUT+128)%256==PFIFO_GET then the Fifo is full
//|...                                    |
//|---------------------------------------| 0 <= PFIFO_PUT, PFIFO_GET <= 255*4
//|---------------------------------------|
//|127                                    |
//|---------------------------------------|
//|128 == 0 alias                         |
//|---------------------------------------|
//|129 == 1 alias                         |
//|---------------------------------------|
//|...                                    |
//|---------------------------------------|
//|---------------------------------------|
//|255 == 127 alias                       |
//-----------------------------------------
void NvWatch_NV10_DumpFifoContents(PHWINFO pDev)
{

  U032 save_puller, save_pusher;
  U032 nvw_fifo_get,nvw_fifo_put;
  U032  fifo_count;
  BOOL fifo_is_empty=FALSE,fifo_is_full=FALSE;
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
  
  // In order to dump the fifo the puller and pusher must be disabled.
  save_puller = REG_RD32(NV_PFIFO_CACHE1_PULL0);
  save_pusher = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
  REG_WR32(NV_PFIFO_CACHE1_PULL0,0);
  REG_WR32(NV_PFIFO_CACHE1_PUSH0,0);

  // The Fifo is 128 entries deep.
  nvw_fifo_get = REG_RD32(NV_PFIFO_CACHE1_GET);
  nvw_fifo_put = REG_RD32(NV_PFIFO_CACHE1_PUT);

  for(fifo_count=0;fifo_count<128;fifo_count++){
    
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, fifo_count);
    
    if(( ( (nvw_fifo_get%(128*4)) /4) == fifo_count)&&(( (nvw_fifo_put%(128*4)) /4) == fifo_count)){
      if(nvw_fifo_get == nvw_fifo_put)
        fifo_is_empty = TRUE;
      else  
        fifo_is_full = TRUE;
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,    " PFIFO_GET->\n");
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,    "           PFIFO_PUT-> Method = ");
    }else{
      if(( (nvw_fifo_get%(128*4)) /4) == fifo_count)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  " PFIFO_GET-> Method = ");
      else{  
        if(( (nvw_fifo_put%(128*4)) /4) == fifo_count)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS," PFIFO_PUT-> Method = ");
        else
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"             Method = ");
      }  
    }  
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(NV_PFIFO_CACHE1_METHOD(fifo_count)) );
    
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"             Data = ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(NV_PFIFO_CACHE1_DATA(fifo_count)) );
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
  }

  if(fifo_is_empty){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nThe Fifo is EMPTY\n\r");
  }else{
    if(fifo_is_full){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nThe Fifo is FULL\n\r");
    }else{
      // This should be an error !!! Never full and Empty!
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: The Fifo is Neither FULL or EMPTY!!!\n\r");
    }
  }  
  
  // Restore the pusher and puller registers.
  REG_WR32(NV_PFIFO_CACHE1_PULL0,save_puller);
  REG_WR32(NV_PFIFO_CACHE1_PUSH0,save_pusher);
  
}

// Specify a device, channel and some format info.
void NvWatch_NV10_DumpPushBuffer(PHWINFO pDev, U032 p_channel, U032 ref_ptr, U032 bytes_before_ptr, U032 bytes_after_ptr)
{
    U032 page_ref, ref_pte, ref_offset;
    U032 dmacontext_inst, *dmacontext_inst_ptr;
    U032 *instance_fc_ptr;
    U032 *pte_ptr;

    // if this is the p_current channel.
    if(p_channel == (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & 0x1F)){
      if(ref_ptr == CONTEXT_USE_PUT)
        ref_ptr = REG_RD32(NV_PFIFO_CACHE1_PUT);
      else
        ref_ptr = REG_RD32(NV_PFIFO_CACHE1_GET);

      dmacontext_inst = REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE);
    }else{
      // Get the DMA Context for the channels pusher. (Just grab it from the FC_Context in instance memory.
      instance_fc_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset+0x10000)/4) + 0x4000);

      // Point to the correct context.
      instance_fc_ptr += p_channel*8;   // 8 dwords per context.
      // Get the 3rd DWORD from the fifo contexts.
      dmacontext_inst = *(instance_fc_ptr+2);
      
      if(ref_ptr == CONTEXT_USE_PUT)
        ref_ptr = (U032) *(instance_fc_ptr);
      else
        ref_ptr = (U032) *(instance_fc_ptr+1);
      
    }
    // Get a pointer to the ContextDma for the push buffer.
    dmacontext_inst &= 0xFFFF;
    dmacontext_inst <<=4;
    dmacontext_inst += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
    dmacontext_inst_ptr = (U032 *) dmacontext_inst;

    // Get the Offset and the 4KB aligned PTE.
    ref_offset = ref_ptr & 0xfff;
    page_ref = ref_ptr >> 12;

    // Get the PTE from the instance data. Map it and add the offset to get the linear ptr.
    ref_pte = *(dmacontext_inst_ptr + 2 + page_ref);


    pte_ptr = (U032 *) vmmMapPhysToLinear(ref_pte, 0x02000, 0);
    pte_ptr += (ref_offset/4);

    ///// // The pointers should now be set up to fetch the data. 
    ///// DBG_PRINT_STRING(DEBUGLEVEL_ERRORS," DmaPush Buffer Dump for channel ");
    ///// DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(fifo_count);
}

/////void NvWatch_NV10_DmaPushAndFifo_help(PHWINFO pDev)
/////{
/////  U032 x;
/////
/////
/////  if(REG_RD32(NV_PFIFO_CACHE1_PUSH1) & (NV_PFIFO_CACHE1_PUSH1_MODE_DMA<<8)){
/////      DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  The current channel is PUSH Channel # ",((REG_RD32(NV_PFIFO_CACHE1_PUSH1))&0x1F) );
/////  }else{
/////      DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  The current channel is PIO Channel # ", ((REG_RD32(NV_PFIFO_CACHE1_PUSH1))&0x1F) );
/////  }
/////
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      f   - Dump Fifo Contents\n\r");
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       " ALL ITEMS BELOW ARE CURRENTLY NOT SUPPORTED\n\r");
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      d   - Dump DmaPusher for Current Channel\n\r\n\r");
/////
/////  // Get the number of dmapush channels.
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      0   - Dump DmaPusher for Push Channel 0\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<1))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      1   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<2))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      2   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<3))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      3   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<4))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      4   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<5))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      5   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<6))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      6   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<7))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      7   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<8))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      8   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<9))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      9   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<10))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      a   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<11))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      b   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<12))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      c   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<13))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      d   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<14))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      e   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<15))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      f   - Dump DmaPusher for Push Channel 1\n\r");
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit this\n\r\n\r");
/////}

void NvWatch_NV10_DumpUserDmaBuffersAtGet(PHWINFO pDev)
{
    U032 channel_count;
    U032 current_channel;
    U032 channel_get;
    U032 channel_dma_inst;
    U032 channel_get_page, channel_get_offset,channel_dmabuffer_physical;
    U032 *instance_data_ptr, *instance_pte_ptr;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n*********************************************");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCalculating Physical addresses for PushBuffers\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,   "*********************************************\n");

    current_channel = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    for(channel_count=0;channel_count<NUM_FIFOS;channel_count++){
        // Is this channel running in DMA Mode ?
        if((REG_RD32(NV_PFIFO_MODE)>>channel_count)&1){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DMA Channel=",(int)channel_count);
            // Get the get pointer value.
            // From fifo context or the fifo engine ?
            if(channel_count==current_channel){
                // Go to the fifo engine.
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "This is the current channel=",(int)channel_count);
                channel_get = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
                channel_dma_inst = REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The get pointer from the fifo engine=",(int)         channel_get);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The dma instance from the fifo engine=",(int)channel_dma_inst);

            }else{
                // Go to the fifo context area in instance memory.
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "This is NOT the current channel=",(int)channel_count);
                {
                   U032 *ptr_fifocontextarea;

                   switch(REG_RD_DRF(_PFIFO, _RAMHT, _SIZE)){
                     case NV_PFIFO_RAMHT_SIZE_4K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x1000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_8K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x2000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_16K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x4000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_32K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x8000) /4) );
                       break;
                   }
                   channel_get = (U032) *(ptr_fifocontextarea+1+(channel_count*8));
                   channel_dma_inst = (U032) *(ptr_fifocontextarea+3+(channel_count*8));
                   channel_dma_inst &= 0xFFFF;
                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The get pointer from the fifo context=",(int)         channel_get);
                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The dma instance from the fifo context=",(int)channel_dma_inst);
                }
            } // equal current channel

            channel_get_page = (U032) channel_get >> 12;
            channel_get_offset = (U032) channel_get & 0xFFF;
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel get pointers page=",(int)   channel_get_page);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel get pointers offset=",(int) channel_get_offset);


            instance_data_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset+(channel_dma_inst<<4))/4));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Linear address of Push buffer context=",(int)instance_data_ptr);
            // System memory DMA contexts will have all of the PTE's listed in instance memory.(scatter/gather)
            // AGP and FB DMA Contexts will only require a base DMA context.
            // Check the type bits of the DMA context in instance memory.
            switch( ((*instance_data_ptr)>>16) & 3){
                case 2: /*system memory*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in SYSTEM MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2+channel_get_page);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Linear address of Push buffer context PTE=",(int)instance_pte_ptr);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get_offset;
                    break;
                case 3: /*AGP system memory*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in AGP SYSTEM MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get;
                    break;
                case 0: /*frame buffer NVM*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in FRAME BUFFER MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get;
                    break;
            }
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Physical address of Push buffer at the get pointer=",(int)channel_dmabuffer_physical);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Don't forget the 12bit ADJUST value for the DMA Context=",(int)((*instance_data_ptr)>>20));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "ADJUSTED Physical address of Push buffer at the get pointer=",(int)(channel_dmabuffer_physical+((*instance_data_ptr)>>20)));
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        } // DMA Mode
    }
}

void NvWatch_NV10_DmaPushAndFifo_help(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      f   - Dump Fifo Contents\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      c   - Get Physical address of DmaBuffers at Current Get ptr.(DmaPush channels only)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      d   - Dump DmaPusher Info (Not Implemented)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit this\n\r\n\r");
}

int NvWatch_NV10_DmaPushAndFifo(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  // Go with 6 dwords pre and post.
  U032 bytes_before_ptr = 48;
  U032 bytes_after_ptr = 48;
  char pstring[]="NvWatch Fifo";
 
  NvWatch_NV10_DmaPushAndFifo_help(pDev);

  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 'F': // Dump fifo 
      case 'f': // Dump fifo 
        NvWatch_NV10_DumpFifoContents(pDev);
        break;
      case 'd':
        //p_channel = REG_RD32(NV_PFIFO_CACHE1_PUSH1) & 0x1F;
        //ref_ptr = CONTEXT_USE_GET;
        //NvWatch_NV10_DumpPushBuffer(device, p_channel, ref_ptr, bytes_before_ptr, bytes_after_ptr)   
        break;
      case 'c': 
      case 'C': 
        NvWatch_NV10_DumpUserDmaBuffersAtGet(pDev);
        break;
      default: // Help
        NvWatch_NV10_DmaPushAndFifo_help(pDev);
        break;  
    }
  }

  return (RM_OK);
}

void NvWatch_NV10_Dump_Graphics(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nGraphics Engine State:\r\n");
 
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_0             = ", REG_RD32(   NV_PGRAPH_DEBUG_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_1             = ", REG_RD32(   NV_PGRAPH_DEBUG_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_2             = ", REG_RD32(   NV_PGRAPH_DEBUG_2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_3             = ", REG_RD32(   NV_PGRAPH_DEBUG_3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_INTR                = ", REG_RD32(   NV_PGRAPH_INTR                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_NSOURCE             = ", REG_RD32(   NV_PGRAPH_NSOURCE               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_INTR_EN             = ", REG_RD32(   NV_PGRAPH_INTR_EN               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH1         = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH2         = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH2           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH3         = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH3           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_CONTROL         = ", REG_RD32(   NV_PGRAPH_CTX_CONTROL           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_USER            = ", REG_RD32(   NV_PGRAPH_CTX_USER              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FIFO                = ", REG_RD32(   NV_PGRAPH_FIFO                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FFINTFC_ST2         = ", REG_RD32(   NV_PGRAPH_FFINTFC_ST2           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STATUS              = ", REG_RD32(   NV_PGRAPH_STATUS                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_TRAPPED_ADDR        = ", REG_RD32(   NV_PGRAPH_TRAPPED_ADDR          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_TRAPPED_DATA        = ", REG_RD32(   NV_PGRAPH_TRAPPED_DATA_LOW      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SURFACE             = ", REG_RD32(   NV_PGRAPH_SURFACE               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_NOTIFY              = ", REG_RD32(   NV_PGRAPH_NOTIFY                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET0            = ", REG_RD32(   NV_PGRAPH_BOFFSET0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET1            = ", REG_RD32(   NV_PGRAPH_BOFFSET1              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET2            = ", REG_RD32(   NV_PGRAPH_BOFFSET2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET3            = ", REG_RD32(   NV_PGRAPH_BOFFSET3              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET4            = ", REG_RD32(   NV_PGRAPH_BOFFSET4              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET5            = ", REG_RD32(   NV_PGRAPH_BOFFSET5              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE0              = ", REG_RD32(   NV_PGRAPH_BBASE0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE1              = ", REG_RD32(   NV_PGRAPH_BBASE1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE2              = ", REG_RD32(   NV_PGRAPH_BBASE2                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE3              = ", REG_RD32(   NV_PGRAPH_BBASE3                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE4              = ", REG_RD32(   NV_PGRAPH_BBASE4                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE5              = ", REG_RD32(   NV_PGRAPH_BBASE5                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH0             = ", REG_RD32(   NV_PGRAPH_BPITCH0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH1             = ", REG_RD32(   NV_PGRAPH_BPITCH1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH2             = ", REG_RD32(   NV_PGRAPH_BPITCH2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH3             = ", REG_RD32(   NV_PGRAPH_BPITCH3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH4             = ", REG_RD32(   NV_PGRAPH_BPITCH4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT0             = ", REG_RD32(   NV_PGRAPH_BLIMIT0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT1             = ", REG_RD32(   NV_PGRAPH_BLIMIT1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT2             = ", REG_RD32(   NV_PGRAPH_BLIMIT2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT3             = ", REG_RD32(   NV_PGRAPH_BLIMIT3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT4             = ", REG_RD32(   NV_PGRAPH_BLIMIT4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT5             = ", REG_RD32(   NV_PGRAPH_BLIMIT5               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BSWIZZLE2           = ", REG_RD32(   NV_PGRAPH_BSWIZZLE2             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BSWIZZLE5           = ", REG_RD32(   NV_PGRAPH_BSWIZZLE5             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPIXEL              = ", REG_RD32(   NV_PGRAPH_BPIXEL                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_LIMIT_VIOL_Z        = ", REG_RD32(   NV_PGRAPH_LIMIT_VIOL_Z          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STATE               = ", REG_RD32(   NV_PGRAPH_STATE                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CACHE_INDEX         = ", REG_RD32(   NV_PGRAPH_CACHE_INDEX           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CACHE_RAM           = ", REG_RD32(   NV_PGRAPH_CACHE_RAM             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_PITCH           = ", REG_RD32(   NV_PGRAPH_DMA_PITCH             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DVD_COLORFMT        = ", REG_RD32(   NV_PGRAPH_DVD_COLORFMT          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SCALED_FORMAT       = ", REG_RD32(   NV_PGRAPH_SCALED_FORMAT         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATT_COLOR0         = ", REG_RD32(   NV_PGRAPH_PATT_COLOR0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATT_COLOR1         = ", REG_RD32(   NV_PGRAPH_PATT_COLOR1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATTERN_SHAPE       = ", REG_RD32(   NV_PGRAPH_PATTERN_SHAPE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MONO_COLOR0         = ", REG_RD32(   NV_PGRAPH_MONO_COLOR0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ROP3                = ", REG_RD32(   NV_PGRAPH_ROP3                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CHROMA              = ", REG_RD32(   NV_PGRAPH_CHROMA                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BETA_AND            = ", REG_RD32(   NV_PGRAPH_BETA_AND              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BETA_PREMULT        = ", REG_RD32(   NV_PGRAPH_BETA_PREMULT          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CONTROL0            = ", REG_RD32(   NV_PGRAPH_CONTROL0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CONTROL2            = ", REG_RD32(   NV_PGRAPH_CONTROL2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLEND               = ", REG_RD32(   NV_PGRAPH_BLEND                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DPRAM_INDEX         = ", REG_RD32(   NV_PGRAPH_DPRAM_INDEX           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DPRAM_DATA          = ", REG_RD32(   NV_PGRAPH_DPRAM_DATA            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STORED_FMT          = ", REG_RD32(   NV_PGRAPH_STORED_FMT            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMATS             = ", REG_RD32(   NV_PGRAPH_FORMATS               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC0      = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC0        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC1      = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC1        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC2      = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC2        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC3      = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC3        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_X_MISC              = ", REG_RD32(   NV_PGRAPH_X_MISC                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_Y_MISC              = ", REG_RD32(   NV_PGRAPH_Y_MISC                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_XMIN      = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_XMIN        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_XMAX      = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_XMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_YMIN      = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_YMIN        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_YMAX      = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_YMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_XMIN     = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_XMIN       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_XMAX     = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_XMAX       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_YMIN     = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_YMIN       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_YMAX     = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_YMAX       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SOURCE_COLOR        = ", REG_RD32(   NV_PGRAPH_SOURCE_COLOR          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_VALID1              = ", REG_RD32(   NV_PGRAPH_VALID1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_VALID2              = ", REG_RD32(   NV_PGRAPH_VALID2                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_ICLIP_XMAX      = ", REG_RD32(   NV_PGRAPH_ABS_ICLIP_XMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_ICLIP_YMAX      = ", REG_RD32(   NV_PGRAPH_ABS_ICLIP_YMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPX_0             = ", REG_RD32(   NV_PGRAPH_CLIPX_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPX_1             = ", REG_RD32(   NV_PGRAPH_CLIPX_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPY_0             = ", REG_RD32(   NV_PGRAPH_CLIPY_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPY_1             = ", REG_RD32(   NV_PGRAPH_CLIPY_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_0            = ", REG_RD32(   NV_PGRAPH_MISC24_0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_1            = ", REG_RD32(   NV_PGRAPH_MISC24_1              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_2            = ", REG_RD32(   NV_PGRAPH_MISC24_2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_0          = ", REG_RD32(   NV_PGRAPH_PASSTHRU_0            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_1          = ", REG_RD32(   NV_PGRAPH_PASSTHRU_1            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_2          = ", REG_RD32(   NV_PGRAPH_PASSTHRU_2            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_XY              = ", REG_RD32(   NV_PGRAPH_D3D_XY                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_U0              = ", REG_RD32(   NV_PGRAPH_D3D_U0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_V0              = ", REG_RD32(   NV_PGRAPH_D3D_V0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_U1              = ", REG_RD32(   NV_PGRAPH_D3D_U1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_V1              = ", REG_RD32(   NV_PGRAPH_D3D_V1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_ZETA            = ", REG_RD32(   NV_PGRAPH_D3D_ZETA              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_RGB             = ", REG_RD32(   NV_PGRAPH_D3D_RGB               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_S               = ", REG_RD32(   NV_PGRAPH_D3D_S                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_M               = ", REG_RD32(   NV_PGRAPH_D3D_M                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMAT0             = ", REG_RD32(   NV_PGRAPH_FORMAT0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMAT1             = ", REG_RD32(   NV_PGRAPH_FORMAT1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FILTER0             = ", REG_RD32(   NV_PGRAPH_FILTER0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FILTER1             = ", REG_RD32(   NV_PGRAPH_FILTER1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE0ALPHA       = ", REG_RD32(   NV_PGRAPH_COMBINE0ALPHA         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE0COLOR       = ", REG_RD32(   NV_PGRAPH_COMBINE0COLOR         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE1ALPHA       = ", REG_RD32(   NV_PGRAPH_COMBINE1ALPHA         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE1COLOR       = ", REG_RD32(   NV_PGRAPH_COMBINE1COLOR         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_START_0         = ", REG_RD32(   NV_PGRAPH_DMA_START_0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_START_1         = ", REG_RD32(   NV_PGRAPH_DMA_START_1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_LENGTH          = ", REG_RD32(   NV_PGRAPH_DMA_LENGTH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_MISC            = ", REG_RD32(   NV_PGRAPH_DMA_MISC              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_DATA_0          = ", REG_RD32(   NV_PGRAPH_DMA_DATA_0            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_DATA_1          = ", REG_RD32(   NV_PGRAPH_DMA_DATA_1            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_RM              = ", REG_RD32(   NV_PGRAPH_DMA_RM                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_XLATE_INST    = ", REG_RD32(   NV_PGRAPH_DMA_A_XLATE_INST      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_CONTROL       = ", REG_RD32(   NV_PGRAPH_DMA_A_CONTROL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_LIMIT         = ", REG_RD32(   NV_PGRAPH_DMA_A_LIMIT           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_TLB_PTE       = ", REG_RD32(   NV_PGRAPH_DMA_A_TLB_PTE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_TLB_TAG       = ", REG_RD32(   NV_PGRAPH_DMA_A_TLB_TAG         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_ADJ_OFFSET    = ", REG_RD32(   NV_PGRAPH_DMA_A_ADJ_OFFSET      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_OFFSET        = ", REG_RD32(   NV_PGRAPH_DMA_A_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_SIZE          = ", REG_RD32(   NV_PGRAPH_DMA_A_SIZE            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_Y_SIZE        = ", REG_RD32(   NV_PGRAPH_DMA_A_Y_SIZE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_XLATE_INST    = ", REG_RD32(   NV_PGRAPH_DMA_B_XLATE_INST      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_CONTROL       = ", REG_RD32(   NV_PGRAPH_DMA_B_CONTROL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_LIMIT         = ", REG_RD32(   NV_PGRAPH_DMA_B_LIMIT           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_TLB_PTE       = ", REG_RD32(   NV_PGRAPH_DMA_B_TLB_PTE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_TLB_TAG       = ", REG_RD32(   NV_PGRAPH_DMA_B_TLB_TAG         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_ADJ_OFFSET    = ", REG_RD32(   NV_PGRAPH_DMA_B_ADJ_OFFSET      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_OFFSET        = ", REG_RD32(   NV_PGRAPH_DMA_B_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_SIZE          = ", REG_RD32(   NV_PGRAPH_DMA_B_SIZE            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_Y_SIZE        = ", REG_RD32(   NV_PGRAPH_DMA_B_Y_SIZE          ));
}  

void NvWatch_NV10_Dump_Fifo(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nFifo State:\r\n");
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DELAY_0              = ", REG_RD32(   NV_PFIFO_DELAY_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DMA_TIMESLICE        = ", REG_RD32(   NV_PFIFO_DMA_TIMESLICE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_PIO_TIMESLICE        = ", REG_RD32(   NV_PFIFO_PIO_TIMESLICE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_TIMESLICE            = ", REG_RD32(   NV_PFIFO_TIMESLICE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_NEXT_CHANNEL         = ", REG_RD32(   NV_PFIFO_NEXT_CHANNEL           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DEBUG_0              = ", REG_RD32(   NV_PFIFO_DEBUG_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_INTR_0               = ", REG_RD32(   NV_PFIFO_INTR_0                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_INTR_EN_0            = ", REG_RD32(   NV_PFIFO_INTR_EN_0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMHT                = ", REG_RD32(   NV_PFIFO_RAMHT                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMFC                = ", REG_RD32(   NV_PFIFO_RAMFC                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMRO                = ", REG_RD32(   NV_PFIFO_RAMRO                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHES               = ", REG_RD32(   NV_PFIFO_CACHES                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_MODE                 = ", REG_RD32(   NV_PFIFO_MODE                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DMA                  = ", REG_RD32(   NV_PFIFO_DMA                    ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_SIZE                 = ", REG_RD32(   NV_PFIFO_SIZE                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUSH0         = ", REG_RD32(   NV_PFIFO_CACHE0_PUSH0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUSH0         = ", REG_RD32(   NV_PFIFO_CACHE1_PUSH0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUSH1         = ", REG_RD32(   NV_PFIFO_CACHE0_PUSH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUSH1         = ", REG_RD32(   NV_PFIFO_CACHE1_PUSH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_PUSH      = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_PUSH        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_FETCH     = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_FETCH       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_PUT       = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_PUT         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_GET       = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_GET         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_STATE     = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_STATE       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_INSTANCE  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_INSTANCE    ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_CTL       = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_CTL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_LIMIT     = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_LIMIT       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_TLB_TAG   = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_TLB_TAG     ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_TLB_PTE   = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_TLB_PTE     ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PULL0         = ", REG_RD32(   NV_PFIFO_CACHE0_PULL0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PULL0         = ", REG_RD32(   NV_PFIFO_CACHE1_PULL0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PULL1         = ", REG_RD32(   NV_PFIFO_CACHE0_PULL1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PULL1         = ", REG_RD32(   NV_PFIFO_CACHE1_PULL1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_HASH          = ", REG_RD32(   NV_PFIFO_CACHE0_HASH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_HASH          = ", REG_RD32(   NV_PFIFO_CACHE1_HASH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_STATUS        = ", REG_RD32(   NV_PFIFO_CACHE0_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_STATUS        = ", REG_RD32(   NV_PFIFO_CACHE1_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_STATUS1       = ", REG_RD32(   NV_PFIFO_CACHE1_STATUS1         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUT           = ", REG_RD32(   NV_PFIFO_CACHE0_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUT           = ", REG_RD32(   NV_PFIFO_CACHE1_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_GET           = ", REG_RD32(   NV_PFIFO_CACHE0_GET             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_GET           = ", REG_RD32(   NV_PFIFO_CACHE1_GET             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_ENGINE        = ", REG_RD32(   NV_PFIFO_CACHE0_ENGINE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_ENGINE        = ", REG_RD32(   NV_PFIFO_CACHE1_ENGINE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_STATUS        = ", REG_RD32(   NV_PFIFO_RUNOUT_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_PUT           = ", REG_RD32(   NV_PFIFO_RUNOUT_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_GET           = ", REG_RD32(   NV_PFIFO_RUNOUT_GET             ));
}

void NvWatch_NV10_Dump_Master(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nMaster Control State:\r\n");
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_BOOT_0                 = ", REG_RD32(   NV_PMC_BOOT_0                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_0                 = ", REG_RD32(   NV_PMC_INTR_0                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_EN_0              = ", REG_RD32(   NV_PMC_INTR_EN_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_READ_0            = ", REG_RD32(   NV_PMC_INTR_READ_0              ));
}

void NvWatch_NV10_Dump_Video(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nVideo State:\r\n");

  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_0               = ", REG_RD32(NV_PVIDEO_DEBUG_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_1               = ", REG_RD32(NV_PVIDEO_DEBUG_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_2               = ", REG_RD32(NV_PVIDEO_DEBUG_2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_3               = ", REG_RD32(NV_PVIDEO_DEBUG_3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_4               = ", REG_RD32(NV_PVIDEO_DEBUG_4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_5               = ", REG_RD32(NV_PVIDEO_DEBUG_5               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_6               = ", REG_RD32(NV_PVIDEO_DEBUG_6               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_7               = ", REG_RD32(NV_PVIDEO_DEBUG_7               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_8               = ", REG_RD32(NV_PVIDEO_DEBUG_8               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_9               = ", REG_RD32(NV_PVIDEO_DEBUG_9               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_INTR                  = ", REG_RD32(NV_PVIDEO_INTR                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_INTR_EN               = ", REG_RD32(NV_PVIDEO_INTR_EN               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFFER                = ", REG_RD32(NV_PVIDEO_BUFFER                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_STOP                  = ", REG_RD32(NV_PVIDEO_STOP                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BASE(0)               = ", REG_RD32(NV_PVIDEO_BASE(0)               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BASE(1)               = ", REG_RD32(NV_PVIDEO_BASE(1)               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_LIMIT(0)              = ", REG_RD32(NV_PVIDEO_LIMIT(0)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_LIMIT(1)              = ", REG_RD32(NV_PVIDEO_LIMIT(1)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_LUMINANCE(0)          = ", REG_RD32(NV_PVIDEO_LUMINANCE(0)          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_LUMINANCE(1)          = ", REG_RD32(NV_PVIDEO_LUMINANCE(1)          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CHROMINANCE(0)        = ", REG_RD32(NV_PVIDEO_CHROMINANCE(0)        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CHROMINANCE(1)        = ", REG_RD32(NV_PVIDEO_CHROMINANCE(1)        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_OFFSET(0)             = ", REG_RD32(NV_PVIDEO_OFFSET(0)             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_OFFSET(1)             = ", REG_RD32(NV_PVIDEO_OFFSET(1)             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SIZE_IN(0)            = ", REG_RD32(NV_PVIDEO_SIZE_IN(0)            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SIZE_IN(1)            = ", REG_RD32(NV_PVIDEO_SIZE_IN(1)            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_POINT_IN(0)           = ", REG_RD32(NV_PVIDEO_POINT_IN(0)           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_POINT_IN(1)           = ", REG_RD32(NV_PVIDEO_POINT_IN(1)           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DS_DX(0)              = ", REG_RD32(NV_PVIDEO_DS_DX(0)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DS_DX(1)              = ", REG_RD32(NV_PVIDEO_DS_DX(1)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DT_DY(0)              = ", REG_RD32(NV_PVIDEO_DT_DY(0)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DT_DY(1)              = ", REG_RD32(NV_PVIDEO_DT_DY(1)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_POINT_OUT(0)          = ", REG_RD32(NV_PVIDEO_POINT_OUT(0)          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_POINT_OUT(1)          = ", REG_RD32(NV_PVIDEO_POINT_OUT(1)          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SIZE_OUT(0)           = ", REG_RD32(NV_PVIDEO_SIZE_OUT(0)           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SIZE_OUT(1)           = ", REG_RD32(NV_PVIDEO_SIZE_OUT(1)           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_FORMAT(0)             = ", REG_RD32(NV_PVIDEO_FORMAT(0)             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_FORMAT(1)             = ", REG_RD32(NV_PVIDEO_FORMAT(1)             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_COLOR_KEY             = ", REG_RD32(NV_PVIDEO_COLOR_KEY             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_TEST                  = ", REG_RD32(NV_PVIDEO_TEST                  ));
}

U032 NvWatch_NV10_GetHashSize(PHWINFO pDev)
{
  U032 return_val;
  
  return_val = REG_RD32(NV_PFIFO_RAMHT);

  return(return_val);
}

void NvWatch_NV10_FillDiagStruct(PHWINFO pDev, PNVWATCHDIAGSTRUCT pdiagstruct)
{
    pdiagstruct->nv_pfifo_intr_0       =  REG_RD32(NV_PFIFO_INTR_0      );
    pdiagstruct->nv_pfifo_intr_en_0    =  REG_RD32(NV_PFIFO_INTR_EN_0   );
    pdiagstruct->nv_pfifo_caches       =  REG_RD32(NV_PFIFO_CACHES      );
    pdiagstruct->nv_pfifo_mode         =  REG_RD32(NV_PFIFO_MODE        );
    pdiagstruct->nv_pfifo_cache1_push0 =  REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    pdiagstruct->nv_pfifo_cache1_push1 =  REG_RD32(NV_PFIFO_CACHE1_PUSH1);
    pdiagstruct->nv_pfifo_cache1_pull0 =  REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pdiagstruct->nv_pfifo_dma_put      =  REG_RD32(NV_PFIFO_CACHE1_PUT     );
    pdiagstruct->nv_pfifo_dma_get      =  REG_RD32(NV_PFIFO_CACHE1_GET     );
    pdiagstruct->nv_pmc_intr_0         =  REG_RD32(NV_PMC_INTR_0        );
    pdiagstruct->nv_pmc_intr_en_0      =  REG_RD32(NV_PMC_INTR_EN_0     );
    pdiagstruct->nv_pmc_intr_read_0    =  REG_RD32(NV_PMC_INTR_READ_0   );
    pdiagstruct->nv_pmc_enable         =  REG_RD32(NV_PMC_ENABLE        );
}

void NvWatch_NV10_DumpGrTableContents(PHWINFO pDev, U032 verbose_flag)
{
    PHALHWINFO pHalHwInfo = &pDev->halHwInfo;
    PGRHALINFO_NV10 pGrHalInfo;
    PFIFOHALINFO_NV10 pFifoHalInfo;
    U032 ChID;
    U032 i;

    pHalHwInfo = &pDev->halHwInfo;
    pGrHalInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalInfo;
    pFifoHalInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalInfo;

    for(ChID=0;ChID<NUM_FIFOS;ChID++){
        if (pFifoHalInfo->InUse & (1 << ChID))
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\ngrTable dump of channel ", ChID);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch1 = ", pGrHalInfo->grChannels[ChID].ContextSwitch1);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch2 = ", pGrHalInfo->grChannels[ChID].ContextSwitch2);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch3 = ", pGrHalInfo->grChannels[ChID].ContextSwitch3);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch4 = ", pGrHalInfo->grChannels[ChID].ContextSwitch4);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch5 = ", pGrHalInfo->grChannels[ChID].ContextSwitch5);
      
        for (i = 0; i < 8; i++)
        {    
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Cached Context data for subchannel ", i);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache0 = ", pGrHalInfo->grChannels[ChID].ContextCache1[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache1 = ", pGrHalInfo->grChannels[ChID].ContextCache2[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache2 = ", pGrHalInfo->grChannels[ChID].ContextCache3[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache3 = ", pGrHalInfo->grChannels[ChID].ContextCache4[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache4 = ", pGrHalInfo->grChannels[ChID].ContextCache5[i]);
        }

        if(verbose_flag == NVWATCH_COMPLEX){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].ContextUser = ",          pGrHalInfo->grChannels[ChID].ContextUser       );                 

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaStart0 = ",        pGrHalInfo->grChannels[ChID].DmaStart0             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaStart1 = ",        pGrHalInfo->grChannels[ChID].DmaStart1             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaLength = ",        pGrHalInfo->grChannels[ChID].DmaLength             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaMisc   = ",        pGrHalInfo->grChannels[ChID].DmaMisc               );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaPitch  = ",        pGrHalInfo->grChannels[ChID].DmaPitch              );             

            for (i = 0; i < 6; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferOffset[i]  = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferOffset[i]   );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferBase[i]    = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferBase[i]     );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferLimit[i]   = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferLimit[i]    );
            }
            for (i = 0; i < 5; i++)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPitch[i] = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPitch[i]      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Surface           = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.Surface               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.State             = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.State                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[0]  = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[0]      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[1]  = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[1]      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPixel       = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPixel           );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Notify            = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.Notify                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor0     = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor1     = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor1         );

            for (i = 0; i < 64; i++)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColorRam[i]  = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColorRam[i]);

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[0]         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[0]            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[1]         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[1]            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternShape       = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.PatternShape          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.MonoColor0         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.MonoColor0            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Rop3               = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Rop3                  );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Chroma             = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Chroma                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BetaAnd            = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BetaAnd               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BetaPremult        = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BetaPremult           );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control0           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control0              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control1           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control1              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control2           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control2              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control3           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control3              );
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Blend              = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Blend                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BlendColor         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BlendColor            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.SetupRaster        = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.SetupRaster           );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.FogColor           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.FogColor              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ColorKeyColor0     = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ColorKeyColor0        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ColorKeyColor1     = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ColorKeyColor1        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PointSize          = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.PointSize             );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ZOffsetFactor      = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ZOffsetFactor         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ZOffsetBias        = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ZOffsetBias           );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ZClipMin           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ZClipMin              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ZClipMax           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ZClipMax              );

            for (i = 0; i < 8; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.WinClipHorz[i]   = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.WinClipHorz[i]    );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.WinClipVert[i]   = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.WinClipVert[i]    );
            }

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XFMode[0]            = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.XFMode[0]             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XFMode[1]            = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.XFMode[1]             );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.GlobalState0         = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.GlobalState0          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.GlobalState1         = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.GlobalState1          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.StoredFmt            = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.StoredFmt             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.SourceColor          = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.SourceColor           );

            for (i = 0; i < 32; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsXRam[i]       = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.AbsXRam[i]        );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsYRam[i]       = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.AbsYRam[i]        );
            }

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMin        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMin          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMax          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMin        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMin          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMax          );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DXMin      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DXMin        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DXMax      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DXMax        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DYMin      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DYMin        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DYMax      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DYMax        );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMin       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMin         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMax       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMax         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMin       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMin         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMax       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMax         );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipXMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipXMax          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipYMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipYMax          );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc0        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc0          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc1        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc1          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc2        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc2          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc3        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc3          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY1                );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0AlphaICW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0AlphaICW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1AlphaICW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1AlphaICW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0ColorICW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0ColorICW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1ColorICW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1ColorICW      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Factor      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Factor        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Factor      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Factor        );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0AlphaOCW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0AlphaOCW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1AlphaOCW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1AlphaOCW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0ColorOCW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0ColorOCW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1ColorOCW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1ColorOCW      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.CombineSpecFogCW0   = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.CombineSpecFogCW0     );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.CombineSpecFogCW1   = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.CombineSpecFogCW1     );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TextureOffset0      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TextureOffset0        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TextureOffset1      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TextureOffset1        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexturePalette0     = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexturePalette0       );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexturePalette1     = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexturePalette1       );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexFormat0          = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexFormat0            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexFormat1          = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexFormat1            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl0_0       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl0_0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl0_1       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl0_1         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl1_0       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl1_0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl1_1       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl1_1         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl2_0       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl2_0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl2_1       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl2_1         );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ImageRect0          = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ImageRect0            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ImageRect1          = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ImageRect1            );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Filter0             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Filter0               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Filter1             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Filter1               );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru0           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru0             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru1           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru1             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru2           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru2             );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.DimxTexture         = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.DimxTexture           );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.WdimxTexture        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.WdimxTexture          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.DVDColorFormat      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.DVDColorFormat        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ScaledFormat        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ScaledFormat          );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_0            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_0              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_1            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_1              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_2            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_2              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XMisc               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XMisc                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.YMisc               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.YMisc                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Valid1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Valid1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Valid2              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Valid2                );
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\VXDSTUB.ASM ===
;
;  (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
;
;********* Operating System Interface for NVidia Resource Manager **********;
;                                                                           ;
; Module: VXDSTUB.ASM                                                       ;
;       These routines provide an operating system independent layer        ;
;       between the Resource Manager and the underlying OS APIs.            ;
;                                                                           ;
;---------------------------------------------------------------------------;
;                                                                           ;
; History:                                                                  ;
;        David Schmenk (dschmenk)     11/17/93 - wrote it                   ;
;        David Schmenk (dschmenk)     06/15/94 - rewrote for real RM        ;
;        JohnH                        10/3/97 - rewrote for MS tools--      ;
;                                     include DDB and service table here    ;
;*********************** Copyright 1993 NVidia, Inc. ***********************;

.386p

INCLUDE BASEDEF.INC
INCLUDE VMM.INC
INCLUDE VWIN32.INC
INCLUDE VPICD.INC
INCLUDE V86MMGR.INC
INCLUDE VNVRMD.INC
INCLUDE DEBUG.INC
include         ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc


VxD_LOCKED_DATA_SEG
PUBLIC  dwSrcLinearPageNum, dwDstLinearPageNum, dwLinearRegionSizeInPages, dwPageDirectoryBaseRegLinear
dwSrcLinearPageNum              DD      0
dwDstLinearPageNum              DD      0
dwLinearRegionSizeInPages       DD      0
dwPageDirectoryBaseRegLinear    DD      0

PUBLIC  dwPageTableEntry
dwPageTableEntry                DD      0
PUBLIC	dwGotNulPTE, dwNulPTE
dwGotNulPTE			DD	0
dwNulPTE			DD	0
VxD_LOCKED_DATA_ENDS


VxD_LOCKED_CODE_SEG

;   The Device Declartation Block

;Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
;    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

IFDEF NV4_HW
Declare_Virtual_Device  NVCORE, NVRM_Major_Version, NVRM_Minor_Version, rmControlEntry, UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER, \
                        ,                    \
                        rmUsrAPIEntry        \
                        ,
ENDIF

;---------------------------------------------------------------------------
;
;  These bogus routines are needed for the C compiler's optimizer function
;    Called as:
;               EAX = buffer offset
;               ECX = count
;               EDX = value
;
;---------------------------------------------------------------------------
BeginProc __STOSB
        jcxz    exitb
fillitb:
        dec     ecx
        mov     BYTE PTR [eax][ecx], dl
        jnz     fillitb
exitb:
        ret
EndProc __STOSB
BeginProc __STOSW
        jcxz    exitw
fillitw:
        dec     ecx
        mov     WORD PTR [eax][ecx*2], dx
        jnz     fillitw
exitw:
        ret
EndProc __STOSW
BeginProc __STOSD
        jcxz    exitd
fillitd:
        dec     ecx
        mov     DWORD PTR [eax][ecx*4], edx
        jnz     fillitd
exitd:
        ret
EndProc __STOSD
BeginProc _inpd
        push    edx
        mov     dx,  ax
        in      eax, dx
        pop     edx
        ret
EndProc _inpd
BeginProc _outpd
        xchg    eax, edx
        out     dx, eax
        ret
EndProc _outpd
BeginProc _inp
        push    edx
        mov     dx,  ax
        in      al, dx
        pop     edx
        ret
EndProc _inp
BeginProc _outp
        xchg    eax, edx
        out     dx, al
        ret
EndProc _outp
;---------------------------------------------------------------------------
;
;  VxD Control entrypoints.
;
;---------------------------------------------------------------------------
EXTRN   _rmControl : NEAR
public  rmControlEntry
BeginProc rmControlEntry
;       ebp points to the Client_Regiser_Structure
;       rmControl expects two args: msg, VMh
        push    ebx             ; VMh
        push    eax             ; msg
        call    _rmControl
        add     esp,2*4
        or      eax, eax
        stc
        jnz     @F
        clc
@@:     ret
EndProc rmControlEntry
;---------------------------------------------------------------------------
;
;  VxD User API entrypoints.
;
;---------------------------------------------------------------------------
EXTRN   @rmUsrAPI@8 : NEAR
public  rmUsrAPIEntry
BeginProc rmUsrAPIEntry
;       fix up arguments for the __fastcall protocol -- C function will use ecx & edx for first two args
        mov     ecx, ebx        ; VM handle
        mov     edx, ebp        ; user parameters (register structure)
        jmp     @rmUsrAPI@8     ; no arguments on stack, so no additional stack maintenance
EndProc rmUsrAPIEntry


;---------------------------------------------------------------------------
;
;  Moved from the RegisterDisplayDriover routine in the minivdd.
;
;---------------------------------------------------------------------------

; 200H bytes should be enough.
align   4
PUBLIC  LogdevSharedArea
LogdevSharedArea:
DD      200H    dup (0)

public  _RegisterDisplayDriver
BeginProc _RegisterDisplayDriver

        push    ebp
        mov     ebp,esp
        pushad
        mov     ebp,ss:[ebp + 8]

        ; The new architecture display driver needs some functions
        ; which can only be performed at the VxD level. I made a
        ; simple interface for these services out of the minivdd
        ; function RegisterDisplayDriver. The Client_EAX register
        ; is used up because it must hold the special code
        ; VDD_REGISTER_DISPLAY_DRIVER_INFO in order to get here,
        ; and Client_EBX is used up holding the system VM handle.
        ; The other registers are all free, so:
        ; CLIENT_ecx    - sub-function
        ; All other registers are sub-function specific.
        ;
        ; I placed the sub-function constants in nvrmarch at
        ; the time I wrote this code.
        mov     eax,[ebp].Client_Reg_Struc.Client_ECX
        cmp     eax,MVDD_ALLOC_LINEAR_ADDRESS_SPACE
        je      AllocLinearAddrSpace
        cmp     eax,MVDD_FREE_LINEAR_ADDRESS_SPACE
        je      FreeLinearAddrSpace
        cmp     eax,MVDD_COPY_PTES_FOR_LINEAR_RANGE
        je      CopyPtesForLinearRange
        cmp     eax,MVDD_ALLOC_MEMORY_BLOCK
        je      AllocSystemAreaMemory
        cmp     eax,MVDD_FREE_MEMORY_BLOCK
        je      FreeSystemAreaMemory
        cmp     eax,MVDD_GET_LOGDEV_SHARED_MEMORY
        je      GetLogdevSharedPtr
        jmp     MRDDExit

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_ALLOC_LINEAR_ADDRESS_SPACE -- this service allocates
        ; linear address space with no physical memory backing it.
        ;
        ; Parameters:
        ; Client_ECX = MVDD_ALLOC_LINEAR_ADDRESS_SPACE
        ; Client_EDX = amount of linear address space to alloc in bytes
        ;
        ; Returns:
        ; Client_EAX    Linear Base Address of linear space if successful
        ;               NULL if there was an error
AllocLinearAddrSpace:

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        add     eax,0FFFH
        shr     eax,0CH
        VMMCall _PageReserve,<PR_SYSTEM,eax,PR_FIXED>
        mov     [ebp].Client_Reg_Struc.Client_EAX,eax
        cmp     eax,-1
        jne     MRDDExit
        mov     [ebp].Client_Reg_Struc.Client_EAX,0
        jmp     MRDDExit
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_FREE_LINEAR_ADDRESS_SPACE -- this service frees
        ; linear address space allocated via AllocLinearAddressSpace.
        ;
        ; Parameters:
        ; Client_ECX = MVDD_FREE_LINEAR_ADDRESS_SPACE
        ; Client_EDX = base of linear address space to free
        ; Client_EBX = length in bytes of the range to free
        ;
        ; Returns:      None
FreeLinearAddrSpace:
        mov     eax, [ebp].Client_Reg_Struc.Client_EDX
        shr     eax, 0CH
        mov     [dwDstLinearPageNum], eax
        mov     eax, [ebp].Client_Reg_Struc.Client_EBX
        add     eax, 0FFFH
        shr     eax, 0CH
        mov     [dwLinearRegionSizeInPages], eax

        ; First get a linear address for CR3 (The Page Directory Base Register)
        mov     eax, cr3
        and     eax, NOT 0FFFh
        VMMCall _MapPhysToLinear,<eax,1000H,0>
        mov     [dwPageDirectoryBaseRegLinear], eax
@@:
        ; We need to remap all the pages behind this linear address
        ; space to the nul PTE so that when we PageFree, Windows
        ; does not try and decommit anything.
        mov     eax, [dwPageDirectoryBaseRegLinear]
        mov     ebx, [dwDstLinearPageNum]
        shr     ebx, 10
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

        mov     eax, [ebx]
        and     eax, 0FFFFF000H
        VMMCall _MapPhysToLinear,<eax,1000H,0>

        mov     ebx, [dwDstLinearPageNum]
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

        ; We now have a ptr in ebx to the place to put the new PTE
        mov	eax,dwNulPTE
        mov     [ebx], eax

        ; Go to the next PTEs
        inc     [dwDstLinearPageNum]

        dec     [dwLinearRegionSizeInPages]
        jne     @B

	; Now that we have mapped all PTEs to NULL, we can free the
	; linear range and Windows won't try to decommit anything.
        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        VMMcall _PageFree,<eax,0>
        jmp     MRDDExit
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_COPY_PTES_FOR_LINEAR_RANGE -- this service copies page
        ; table entries for the pages behind one linear range to the
        ; PTEs for the pages behind another linear range. This makes
        ; the two linear ranges address the same physical memory.
        ;
        ; Parameters:
        ; Client_ECX = MVDD_COPY_PTES_FOR_LINEAR_RANGE
        ; Client_EDX = base of linear address space to copy PTEs from
        ; Client_EBX = base of linear address space to copy PTEs to
        ; Client_EDI = size of linear region in bytes to copy PTEs for
        ;
        ; Returns:      None
CopyPtesForLinearRange:
        mov     eax, [ebp].Client_Reg_Struc.Client_EDX
        shr     eax, 0CH
        mov     [dwSrcLinearPageNum], eax
        mov     eax, [ebp].Client_Reg_Struc.Client_EBX
        shr     eax, 0CH
        mov     [dwDstLinearPageNum], eax
        mov     eax, [ebp].Client_Reg_Struc.Client_EDI
        add     eax, 0FFFH
        shr     eax, 0CH
        mov     [dwLinearRegionSizeInPages], eax

IF 0
        ; CopyPageTable does NOT work when you are running SoftICE
        ; if the dst page table entry you are copying over was
        ; originally part of an AllocLinearAddrSpace. SoftICE marks
        ; PTES behind an AllocLinearAddrSpace call with 000B3000
        ; (if SoftICE isn't running, non-physically-backed pages
        ; on AllocLinearAddrSpace are marked differently).
        ; CopyPageTable seems to fail if a current dst PTE is
        ; set to 000B3000 (or maybe SoftICE hooks CopyPageTable as
        ; well and blocks if the current dst PTE is 000B3000).
@@:
        ; Get the first src PTE
        mov     eax, OFFSET [dwPageTableEntry]
        VMMcall _CopyPageTable,<dwSrcLinearPageNum,1,eax,0>
        inc     [dwSrcLinearPageNum]

        ; Write the PTE for the dst region
        mov     eax, [dwPageTableEntry]
        shr     eax, 0CH
        VMMcall _PageCommitPhys,<dwDstLinearPageNum,1,eax,PC_USER + PC_WRITEABLE>
        inc     [dwDstLinearPageNum]

        ; Do the whole range
        dec     [dwLinearRegionSizeInPages]
        jne     @B
ELSE
        ; Because of SoftICE, I must bang the PTEs myself!
        ; NOTE!  This WILL NOT WORK with Physical Address Extension - i.e. P6
        ; architecture extension to 36 address bits (currently available only
        ; in Intel Xeon processors).  This can be checked with the PAE flag
        ; (bit 5 of CR4).  If we are in 36 bit (PAE) mode, CR3 becomes a
        ; 27 bit page directory pointer table base address (PDPTR).  The top
        ; two bits of the linear address will select one of four entries in the
        ; page directory pointer table.  Also, PDEs and PTEs become 64 bits to
        ; accomodate 36 bit base addresses (i.e. there are 512 per 4K page).

        ; First get a linear address for CR3 (The Page Directory Base Register)
        mov     eax, cr3
        ; Mask off PCD, PWT flags and other detritus - fixes bug 1990807-124351
        and     eax, NOT 0FFFh
        VMMCall _MapPhysToLinear,<eax,1000H,0>
        mov     [dwPageDirectoryBaseRegLinear], eax

@@:
        mov     eax, [dwPageDirectoryBaseRegLinear]
        ; add in 4 * (top 10 bits of the address) to get the PDE
        mov     ebx, [dwSrcLinearPageNum]
        shr     ebx, 10
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

        ; Now get an address with which we can reference the Page Directory
        mov     eax, [ebx]
        and     eax, 0FFFFF000H
        VMMCall _MapPhysToLinear,<eax,1000H,0>

        ; add in 4 * (bits 21:12 of the address) to get the PTE
        mov     ebx, [dwSrcLinearPageNum]
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]
        mov     eax, [ebx]
        push    eax

        ; Now go through a similar process with the dst page
        mov     eax, [dwPageDirectoryBaseRegLinear]
        mov     ebx, [dwDstLinearPageNum]
        shr     ebx, 10
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

        mov     eax, [ebx]
        and     eax, 0FFFFF000H
        VMMCall _MapPhysToLinear,<eax,1000H,0>

        mov     ebx, [dwDstLinearPageNum]
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

	; remember whatever is in the first dst PTE that we find.
	; This PTE will be what we want to restore them to when we
	; free the linear range.
	cmp	dwGotNulPTE,0
	jne	GotNulPTE
	mov	ecx,[ebx]
	mov	dwNulPTE,ecx
	inc dwGotNulPTE
GotNulPTE:
        ; We now have a ptr in ebx to the place to put the new PTE
        pop     eax
        mov     [ebx], eax

        ; Go to the next PTEs
        inc     [dwSrcLinearPageNum]
        inc     [dwDstLinearPageNum]

        dec     [dwLinearRegionSizeInPages]
        jne     @B
ENDIF
        mov     eax, cr3        ; Flush TLBs
        mov     cr3, eax
        jmp     MRDDExit
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


AllocSystemAreaMemory:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_ALLOC_MEMORY_BLOCK -- this service allocates memory in
        ; the system area (3Ggg-4Gig) and returns a flat ptr to it.
        ; Client_ECX = MVDD_ALLOC_MEMORY_BLOCK
        ; Client_EDX = amount of memory to buy in bytes
        ;
        ; Returns:      CLIENT_EAX      flat ptr to memory block
        ;                               0 if there was an error

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        add     eax,0FFFH
        shr     eax,12
        VMMcall _PageAllocate, <eax,PG_SYS,ebx,0,0,0,0,PAGEZEROINIT>
        mov     [ebp].Client_Reg_Struc.Client_EAX,eax

	; clear out the memory block
	mov	edi,eax
        mov     ecx,[ebp].Client_Reg_Struc.Client_EDX
        sub	eax,eax
        rep	stos byte ptr es:[edi]
        jmp     MRDDExit

FreeSystemAreaMemory:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_FREE_MEMORY_BLOCK -- this service frees memory in
        ; the system area (3Gig-4Gig)
        ; Client_ECX = MVDD_ALLOC_MEMORY_BLOCK
        ; Client_EDX = ptr to memory to free
        ;
        ; Returns:      None

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        VMMcall _PageFree, <eax,0>
        jmp     MRDDExit

GetLogdevSharedPtr:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;  -- this service allocates memory in
        ; the system area (3Ggg-4Gig) and returns a flat ptr to it.
        ; Client_ECX = MVDD_GET_LOGDEV_SHARED_MEMORY
        ;
        ; Returns:      None

        mov     eax,OFFSET LogdevSharedArea
        mov     [ebp].Client_Reg_Struc.Client_EAX,eax
        jmp     MRDDExit

MRDDExit:
        popad
        pop     ebp
        ret
EndProc _RegisterDisplayDriver


;---------------------------------------------------------------------------
;
;  TIMER BIOS interface
;
;---------------------------------------------------------------------------
;
; BOOL TIMER(struct Client_Regs *);
;
BeginProc _TIMER
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Load register structure for TIMER call.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]
;
; Call TIMER BIOS.
;
        push    ebp
        push    DWORD PTR 01ah
        VMMcall Exec_VxD_Int
        pop     ebp
;
; Fill register structure from TIMER call.
;
        push    esi
        mov     esi, [ebp + 8]
        mov     [esi + Client_EAX], eax
        mov     [esi + Client_EBX], ebx
        mov     [esi + Client_ECX], ecx
        mov     [esi + Client_EDX], edx
        mov     [esi + Client_EDI], edi
        pushfd
        pop     eax
        mov     [esi + Client_EFlags], eax
        pop     eax
        mov     [esi + Client_ESI], eax
;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _TIMER

;---------------------------------------------------------------------------
;
;  PCI BIOS interface
;
;---------------------------------------------------------------------------
;
; BOOL PCI(struct Client_Regs *);
;
BeginProc _PCI
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Load register structure for PCI call.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]
;
; Call PCI BIOS.
;
        push    ebp
        push    DWORD PTR 01ah
        VMMcall Exec_VxD_Int
        pop     ebp
;
; Fill register structure from PCI call.
;
        push    esi
        mov     esi, [ebp + 8]
        mov     [esi + Client_EAX], eax
        mov     [esi + Client_EBX], ebx
        mov     [esi + Client_ECX], ecx
        mov     [esi + Client_EDX], edx
        mov     [esi + Client_EDI], edi
        pushfd
        pop     eax
        mov     [esi + Client_EFlags], eax
        pop     eax
        mov     [esi + Client_ESI], eax
;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _PCI

;---------------------------------------------------------------------------
;
;  Video BIOS interface
;
;---------------------------------------------------------------------------
;
; BOOL VBE(struct Client_Regs *);
;
BeginProc _VBE
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Load register structure for PCI call.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]
;
; Call VBE BIOS.
;
        push    ebp
        push    DWORD PTR 010h
        VMMcall Exec_VxD_Int
        pop     ebp
;
; Fill register structure from PCI call.
;
        push    esi
        mov     esi, [ebp + 8]
        mov     [esi + Client_EAX], eax
        mov     [esi + Client_EBX], ebx
        mov     [esi + Client_ECX], ecx
        mov     [esi + Client_EDX], edx
        mov     [esi + Client_EDI], edi
        pop     eax
        mov     [esi + Client_ESI], eax
;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _VBE


;
; Use an int10h to our VGA BIOS to read the EDID from the Toshiba
; system BIOS (used for mobile systems).  Pass a buffer in crs.CRS.Client_EDI
; to copy the result to (128 bytes).  Based on the VBE30 function in this file.
; Called by the Win9x implementation of osGenerateInt10h.
;
; BOOL readToshibaEDID(struct Client_Regs *);
;
;
BeginProc _readToshibaEDID
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Allocate 128 bytes in the local VM translation buffer, then
; use the returned v86 segment:offset as an absolute offset within
; the VM's real-mode space.
;
        mov     esi, [ebp + 8]
        mov     esi, [esi + Client_EDI] ; get flat offset of the table into esi
        push    esi                     ; store it for the copy back later

        VMMcall Get_Cur_VM_Handle       ; get the current vm handle into ebx

        push    ebp
        mov     ebp, [ebp + 8]          ; get a ptr to the client registers
        mov     ecx, 128                ;  buffer size
        stc                             ; set carry flag to copy, clear otherwise
;        clc
        push    ss                      ; pointer must be in fs:esi
        pop     fs
;fs:esi = source, ebp = destination, ebx = handle of current VM
        VxDcall V86MMGR_Allocate_Buffer
        pop     ebp                     ; v86 address in edi 
                                        ; (16 bits of seg, 16 bits of off)
                                        
                                        ; Should probably check cx to see if all
                                        ; data was allocated.  But 60 bytes should
                                        ; always fit in the default 4k translation

        mov     eax, edi                ; Break the v86 address into ax:di
        and     edi, 0FFFFh
        shr     eax, 16

        mov     esi, [ebp + 8]          ; Load it back into our local crs
        mov     [esi + Client_ES], ax
        mov     [esi + Client_EDI], edi

;
; Load register structure for PCI call.  Move the local crs values into the
; real registers.  Don't know if this is still required with the use of the 
; Push_Client_State macros, but it won't hurt for now.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]

;
; Call VBE BIOS.
;
;        push    ebp
;        push    DWORD PTR 010h
;        VMMcall Exec_VxD_Int
;        pop     ebp

        push    ebp                     ; save away ebp so we can get back 
                                        ; to our local crs
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; 
        ; Move the register values from our local crs structure into
        ; the global vm crs that Exec_Int uses
        ;
        mov     esi, [ebp + 8]          ; esi points to local crs

                                        ; get the global vm crs from the
        VMMcall Get_Cur_VM_Handle       ; current vm handle
        mov     ebp, [ebx + CB_Client_Pointer]
                                        ; now ebp points to global crs

        push    ebx                     ; save the vm handle
        mov     ebx, [esi + Client_EBX] ; Copy over the regs
        mov     [ebp + Client_EBX], ebx
        mov     ecx, [esi + Client_ECX]
        mov     [ebp + Client_ECX], ecx
        mov     edx, [esi + Client_EDX]
        mov     [ebp + Client_EDX], edx
        mov     edi, [esi + Client_EDI]
        mov     [ebp + Client_EDI], edi
        mov     ax, [esi + Client_ES]
        mov     [ebp + Client_ES], ax
        mov     eax, [esi + Client_EAX]
        mov     [ebp + Client_EAX], eax
IF 1
        mov     esi, [esi + Client_ESI]
        mov     [ebp + Client_ESI], esi
        pop     ebx                     ; restore the handle

        push ebp    ;store global crs handle

        mov     eax, 010h
        VMMcall Exec_Int

        pop     ebp                     ;retrieve global crs handle
        mov     eax, [ebp + CLIENT_EAX] ;get success/failure code
ELSE
        mov     esi, [esi + Client_ESI]
        mov     [ebp + Client_ESI], esi
        pop     ebx                     ; restore the handle

        mov     eax, 010h
        VMMcall Exec_Int
ENDIF

        VMMcall End_Nest_Exec
        Pop_Client_State


        pop     ebp
;
; Fill register structure from PCI call.
;

        mov     esi, [ebp + 8]          ; now we need to copy data back to our
                                        ;   local crs
        mov     [esi + Client_EAX], eax ; really only eax is needed

;        push    esi
;        mov     esi, [ebp + 8]
;        mov     [esi + Client_EAX], eax
;        mov     [esi + Client_EBX], ebx
;        mov     [esi + Client_ECX], ecx
;        mov     [esi + Client_EDX], edx
;        mov     [esi + Client_EDI], edi
;        pop     eax
;        mov     [esi + Client_ESI], eax

;
; Now we must free the translation buffer we've allocated.
;

        VMMcall Get_Cur_VM_Handle       ; make sure we've got the right vm handle

        pop     esi                     ; address of extended memory buffer, stored at start of routine
        mov     ebp, [ebp + 8]          ; point to our local crs
        mov     ecx, 128                ; free buffer size
;        clc                             ; no copy back required
        push    ss                      ; pointer must be in fs:esi
        pop     fs
        stc                             ; copy back
        VxDcall V86MMGR_Free_Buffer
;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _readToshibaEDID




;
; BOOL VBE30(struct Client_Regs *);
;
;   VBE3.0 SetMode with custom refresh table
;
BeginProc _VBE30
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Copy over the mode table into V86 space.  We need to allocate 60 bytes
; in the local VM translation buffer, copy the table over, and then
; use the returned v86 segment:offset as an absolute offset within
; the VM's real-mode space.
;
        mov     esi, [ebp + 8]
        mov     esi, [esi + Client_EDI] ; get flat offset of the table into esi

        VMMcall Get_Cur_VM_Handle       ; get the current vm handle into ebx

        push    ebp
        mov     ebp, [ebp + 8]          ; get a ptr to the client registers
        mov     ecx, 60                 ; need about 60 bytes
        stc                             ; set carry flag to copy, clear otherwise
        push    ss                      ; pointer must be in fs:esi
        pop     fs
        VxDcall V86MMGR_Allocate_Buffer
        pop     ebp                     ; v86 address in edi 
                                        ; (16 bits of seg, 16 bits of off)
                                        
                                        ; Should probably check cx to see if all
                                        ; data was allocated.  But 60 bytes should
                                        ; always fit in the default 4k translation

        mov     eax, edi                ; Break the v86 address into ax:di
        and     edi, 0FFFFh
        shr     eax, 16

        mov     esi, [ebp + 8]          ; Load it back into our local crs
        mov     [esi + Client_ES], ax
        mov     [esi + Client_EDI], edi

;
; Load register structure for PCI call.  Move the local crs values into the
; real registers.  Don't know if this is still required with the use of the 
; Push_Client_State macros, but it won't hurt for now.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]

;
; Call VBE BIOS.
;
;        push    ebp
;        push    DWORD PTR 010h
;        VMMcall Exec_VxD_Int
;        pop     ebp

        push    ebp                     ; save away ebp so we can get back 
                                        ; to our local crs
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; 
        ; Move the register values from our local crs structure into
        ; the global vm crs that Exec_Int uses
        ;
        mov     esi, [ebp + 8]          ; esi points to local crs

                                        ; get the global vm crs from the
        VMMcall Get_Cur_VM_Handle       ; current vm handle
        mov     ebp, [ebx + CB_Client_Pointer]
                                        ; now ebp points to global crs

        push    ebx                     ; save the vm handle
        mov     ebx, [esi + Client_EBX] ; Copy over the regs
        mov     [ebp + Client_EBX], ebx
        mov     ecx, [esi + Client_ECX]
        mov     [ebp + Client_ECX], ecx
        mov     edx, [esi + Client_EDX]
        mov     [ebp + Client_EDX], edx
        mov     edi, [esi + Client_EDI]
        mov     [ebp + Client_EDI], edi
        mov     ax, [esi + Client_ES]
        mov     [ebp + Client_ES], ax
        mov     eax, [esi + Client_EAX]
        mov     [ebp + Client_EAX], eax
        mov     esi, [esi + Client_ESI]
        mov     [ebp + Client_ESI], esi
        pop     ebx                     ; restore the handle

        mov     eax, 010h
        VMMcall Exec_Int

        VMMcall End_Nest_Exec
        Pop_Client_State

        pop     ebp
;
; Fill register structure from PCI call.
;

        mov     esi, [ebp + 8]          ; now we need to copy data back to our
                                        ;   local crs
        mov     [esi + Client_EAX], eax ; really only eax is needed

;        push    esi
;        mov     esi, [ebp + 8]
;        mov     [esi + Client_EAX], eax
;        mov     [esi + Client_EBX], ebx
;        mov     [esi + Client_ECX], ecx
;        mov     [esi + Client_EDX], edx
;        mov     [esi + Client_EDI], edi
;        pop     eax
;        mov     [esi + Client_ESI], eax

;
; Now we must free the translation buffer we've allocated.
;

        VMMcall Get_Cur_VM_Handle       ; make sure we've got the right vm handle

        mov     ebp, [ebp + 8]          ; point to our local crs
        mov     ecx, 60                 ; free 60 bytes
        clc                             ; no copy back required
        VxDcall V86MMGR_Free_Buffer

;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _VBE30

;---------------------------------------------------------------------------
;
;  Read an IO port.
;
;---------------------------------------------------------------------------
BeginProc inp_
        push    edx
        mov     dx,  ax
        xor     eax, eax
        in      al, dx
        pop     edx
        ret
EndProc inp_
;---------------------------------------------------------------------------
;
;  Write an IO port.
;
;---------------------------------------------------------------------------
BeginProc outp_
        xchg    eax, edx
        out     dx, al
        ret
EndProc outp_

;IFDEF VPE_EXTRAS

; John Tobin : This was put here because it would not work compile
; in a 'C' environment...this was easier


public _vwin32CloseVxdHandle
public _vwin32SetWin32Event

BeginProc _vwin32SetWin32Event, CCALL, PUBLIC

ArgVar hEvent, DWORD

        EnterProc

        pushfd
        push    ecx
        push    edx
        mov     eax, [hEvent]

        VxDCall _VWIN32_SetWin32Event

        pop     edx
        pop     ecx
        popfd

        LeaveProc
        return 

EndProc _vwin32SetWin32Event

BeginProc _vwin32CloseVxdHandle, CCALL, PUBLIC

ArgVar hEvent, DWORD

        EnterProc

        push    ecx
        push    edx
        mov     eax, [hEvent]

        VxDCall _VWIN32_CloseVxDHandle

        pop     edx
        pop     ecx

        LeaveProc
        return

EndProc _vwin32CloseVxdHandle


;ENDIF

public  _DotN_help
_DotN_help db '.T - NVIDIA TnT Resource Manager Soft-Ice/W Extension handler.',0ah,0dh,00

EXTRN   _DotN_cmd_c:NEAR
public  _DotN_cmd_asm
BeginProc _DotN_cmd_asm
 
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
        
        call _DotN_cmd_c
        
        popad
        pop     ebp
        retf
        
EndProc _DotN_cmd_asm

VxD_LOCKED_CODE_ENDS

VxD_REAL_INIT_SEG
;---------------------------------------------------------------------------;
;                                                                           ;
;       NVRM_Real_Init_Proc                                                 ;
;                                                                           ;
;   DESCRIPTION:                                                            ;
;       This code is called when the system is still in real mode, and      ;
;       the VxDs are being loaded.                                          ;
;                                                                           ;
;   PARAMETERS:                                                             ;
;       AX = VMM Version                                                    ;
;       BX = Flags                                                          ;
;               Bit 0: duplicate device ID already loaded                   ;
;               Bit 1: duplicate ID was from the INT 2F device list         ;
;               Bit 2: this device is from the INT 2F device list           ;
;       EDX = Reference data from INT 2F response, or 0                     ;
;       SI = Environment segment, passed from MS-DOS                        ;
;                                                                           ;
;   RETURN VALUES:                                                          ;
;       BX = ptr to list of pages to exclude (0, if none)                   ;
;       SI = ptr to list of instance data items (0, if none)                ;
;       EDX = DWORD of reference data to be passed to protect mode init     ;
;                                                                           ;
;---------------------------------------------------------------------------;
BeginProc NVRM_Real_Init_Proc
        test    bx, Duplicate_Device_ID ; check for already loaded NVRM
        jnz     short @F                ; jump if so
        xor     bx, bx                  ; no exclusion table
        xor     si, si                  ; no instance data table
        xor     edx, edx                ; no reference data
        mov     ax, Device_Load_Ok
        ret
@@:     mov     ax, Abort_Device_Load + No_Fail_Message
        ret
EndProc NVRM_Real_Init_Proc

VxD_REAL_INIT_ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\vid_mode.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: VID_MODE.C                                                        *
*   This is the VIDEO Mode OEM module.                                      *
*   Additional video modes can be added via this module.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"
#include "vmmreg.h"
#include "vpicd.h"
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <mc.h>
#include <os.h>
#include <vga.h>
#include <tv.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vdd.h"
#include "vmm2.h"		// more vmm services
#include "modes.h"
#include "edid.h"
#include "vesadata.h"

extern char strRefreshOverride[];
//JJV-New Registry Process extern char strMaxRefreshRate[];
//JJV-New Registry Process extern char strMaxOptimalRefreshRate[];
//JJV-New Registry Process extern char strOptimalNotFromEDID[];
extern char strMemoryOverride[];
extern char strTilingOverride[];
extern char strRTLOverride[]; 
extern char strPBUSOverride[];
extern char strUnderscanXOverride[];
extern char strUnderscanYOverride[];
extern char strDevNodeRM[];
//JJV-New Registry Process extern char strDevNodeDisplay[];
//JJV-New Registry Process extern char strDMTOverride[];
//JJV-New Registry Process extern char strMonitorTiming[];
//JJV-New Registry Process extern char strCursorCacheOverride[];
extern char strFetchTriggerOverride[];
extern char strFetchSizeOverride[];
extern char strFetchMaxReqsOverride[];
extern char strGraphicsDebug0[];
extern char strGraphicsDebug1[];
extern char strGraphicsDebug2[];
extern char strGraphicsDebug3[];

//JJV-New Registry Process char strNewModeSet[] = "NewStyleModeSet";

RM_STATUS UpdateArbitrationSettings(PHWINFO);

#define NUMBER_OF_MODES 18	// this may change later
#define NUMBER_OF_DEPTHS 4
#define NUMBER_OF_RATES  13 // Double all the 60-120 Hz modes up to 240 Hz
#define DEFAULT_MODE 0x111
#define MODE_TABLE_LENGTH (NUMBER_OF_MODES * NUMBER_OF_DEPTHS * sizeof(U016))

//	this table translates resolutions into their VESA BIOS mode equivalents
U016 ModeSetTable[NUMBER_OF_MODES*NUMBER_OF_DEPTHS] =
{
	// depths: 4 (planar modes), 8, 16, 24/32
	//0:
	// 1600 x 1200
	0xff, 0x145, 0x146, 0x14E,
	//1:
	// 1280 x 1024
	0x106, 0x107, 0x11a, 0x14D,
	//2:
	// 1152 x 864
	0xff, 0x141, 0x142, 0x143,
	//3:
	// 1024 x 768
	0x104, 0x105, 0x117, 0x118,
	//4:
	// 960 x 720
	0xff, 0x14a, 0x14b, 0x14c,
	//5:
	// 800 x 600
	0x102, 0x103, 0x114, 0x115,
	//6:
	// 640 x 480
	0xff, 0x101, 0x111, 0x112,
	//7:
	// 640 x 400
	0xff, 0x100, 0x13d, 0x13e,
	//8:
	// 512 x 384
	0xff, 0x13a, 0x13b, 0x13c,
	//9:
	// 480 x 360
	0xff, 0x147, 0x148, 0x149,
	//10:
	// 400 x 300
	0xff, 0x137, 0x138, 0x139,
	//11:
	// 320 x 400
	0xff, 0x131, 0x132, 0x133,
	//12:
	// 320 x 240					   
	0xff, 0x134, 0x135, 0x136,
	//13:
	// 320 x 200
	0xff, 0x130, 0x10e, 0x10f,
	//14:
	// 1920 x 1200
	0xff, 0x154, 0x155, 0x156, 
	//15:
	// 1920 x 1080
	0xff, 0x151, 0x152, 0x153,
	//16:
	// 1800 x 1440
	0xff, 0x14f, 0x150, 0x157,
	//17:
	// 2048 x 1536
	0xff, 0x158, 0x159, 0x15A
};

//
// CRTC Timings modes for 60Hz, 70Hz, 72Hz, 75Hz, 85Hz, 100Hz, 120Hz
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use floating point).
//
// Horizontal Total, Start, End
// Vertical Total, Start, End
// DotClock, Refresh
// HSync polarity 
// VSync polarity 
//
// Max out all the modes above our pixclk (~250).
// 
U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10] =
{
	//0:
    // Settings for 1600x1200:
    2160,1704,1880,1242,1201,1204,16096,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1249,1201,1204,19025,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1251,1201,1204,19600,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1253,1201,1204,20599,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2208,1728,1904,1272,1201,1204,28064,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2224,1736,1912,1286,1201,1204,34321,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //1:
    // Settings for 1280x1024:
    1712,1360,1496,1060,1025,1028,10888,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1066,1025,1028,12894,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1067,1025,1028,13275,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1069,1025,1028,13854,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1744,1376,1512,1075,1025,1028,15936,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1760,1376,1520,1085,1025,1028,19096,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1111,1025,1028,27624,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1113,1025,1028,28464,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1117,1025,1028,29757,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1792,1392,1536,1131,1025,1028,34455,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //2:
    // Settings for 1152x864:
    1520,1216,1336,895,865,868,8162 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,900,865,868,9677 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,901,865,868,9964 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,902,865,868,10499,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,907,865,868,11965,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1568,1232,1360,915,865,868,14347,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1584,1240,1368,926,865,868,17601,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,937,865,868,20989,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,939,865,868,21635,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,943,865,868,22632,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,954,865,868,25949,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1616,1256,1384,972,865,868,31415,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,943,865,868,22632,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //3:
    // Settings for 1024x768:
    1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,800,769,772,7616 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,801,769,772,7843 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,802,769,772,8180 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1376,1088,1200,807,769,772,9439 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //1392,1096,1208,814,769,772,11331,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1392,1096,1208,814,769,772,11370,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,823,769,772,13905,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,833,769,772,16420,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,835,769,772,16930,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,838,769,772,17699,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1424,1112,1224,848,769,772,20528,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1424,1112,1224,864,769,772,24607,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1440,1120,1232,886,769,772,30620,24000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //4:
    // Settings for 960x720:
    1248,1008,1104,746,721,724,5586 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,750,721,724,6636 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,751,721,724,6835 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,752,721,724,7219 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,756,721,724,8225 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1296,1024,1128,763,721,724,9888 ,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1312,1032,1136,772,721,724,12154,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1312,1032,1136,781,721,724,14345,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1328,1040,1144,783,721,724,14973,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1328,1040,1144,786,721,724,15657,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1328,1040,1144,795,721,724,17948,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1344,1048,1152,810,721,724,21773,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1344,1048,1152,831,721,724,26805,24000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //5:
    // Settings for 800x600:
    1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,625,601,604,4550,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,626,601,604,4687,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,627,601,604,4891,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1056,840,928,630,601,604,5655,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1072,848,936,636,601,604,6818,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,643,601,604,8395,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,651,601,604,9916,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,653,601,604,10231,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,655,601,604,10690,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1104,864,952,663,601,604,12443,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1104,864,952,675,601,604,14904,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1120,872,960,692,601,604,18601,24000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //6:
    // Settings for 640x480:
    800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,500,481,484,2856,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,501,481,484,2943,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,502,481,484,3072,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,505,481,484,3571,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,509,481,484,4316,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,515,481,484,5241,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    864,680,752,521,481,484,6302,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    864,680,752,522,481,484,6495,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    864,680,752,524,481,484,6791,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    880,688,760,531,481,484,7944,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    880,688,760,540,481,484,9504,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    880,688,760,554,481,484,11700,24000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //7:
    // Settings for 640x400:
    //There is no 60Hz timings for 640x400 as defined by IBM VGA
    //784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2508,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,421,401,404,2920,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,424,401,404,3528,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //8:
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    672,536,592,795,769,772,3205,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    672,536,592,800,769,772,3763,7000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,801,769,772,3968,7200,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,802,769,772,4138,7500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,807,769,772,4719,8500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,814,769,772,5600,10000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    //9:
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    624,504,552,746,721,724,2793,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,750,721,724,3360,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,751,721,724,3461,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,752,721,724,3610,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,756,721,724,4113,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,763,721,724,5005,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //10:
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    512,416,456,622,601,604,1911,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,625,601,604,2310,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,626,601,604,2380,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,627,601,604,2483,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,630,601,604,2827,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,636,601,604,3358,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //11:
    // Settings for 320x400:
    //
    // !!! This mode should never be set !!! since DDraw doesn't support it yet
    //
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //12:
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    400,328,360,497,481,484,1193,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,500,481,484,1400,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,501,481,484,1501,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,502,481,484,1566,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,505,481,484,1786,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,509,481,484,2117,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //13:
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,


    //14:
    // Settings for 1920x1200:
    2592,2048,2256,1242,1201,1204,19316,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1249,1201,1204,22802,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1251,1201,1204,23635,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1253,1201,1204,24659,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2640,2072,2280,1260,1201,1204,28274,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2656,2072,2288,1271,1201,1204,33758,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //15:
    // Settings for 1920x1080:
    2576,2040,2248,1118,1081,1084,17280,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1124,1081,1084,20520,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1126,1081,1084,21144,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1128,1081,1084,22064,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2640,2072,2280,1144,1081,1084,30202,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2656,2072,2288,1157,1081,1084,36876,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //16:
    // Settings for 1800x1440:
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2472,1936,2136,1499,1441,1444,25939,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2472,1936,2136,1500,1441,1444,26698,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2472,1936,2136,1503,1441,1444,27866,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2488,1944,2144,1512,1441,1444,31976,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    
    //17:
    // Settings for 2048x1536:
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2816,2208,2432,1599,1537,1540,31519,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2816,2208,2432,1600,1537,1540,32440,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2832,2216,2440,1603,1537,1540,34048,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2832,2216,2440,1612,1537,1540,38804,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    
};

//
// VBE3.0A CRTC Table
//
typedef struct crtc_table_structure
{
    U016	horiz_total;
	U016	horiz_start;
	U016	horiz_end;
	U016	vertical_total;
	U016	vertical_start;
	U016	vertical_end;
	U008	horiz_polarity;
	U008	vertical_polarity;
	U008	flags;
	U016	dot_clock;
	U016	refresh;
	U008	reserved[40];
} CRTC_STRUCTURE, *PCRTC_STRUCTURE;

//
// VBE3.0P CRTC Table
//
typedef struct crtc_table_structure2
{
    U016	horiz_total;
	U016	horiz_start;
	U016	horiz_end;
	U016	vertical_total;
	U016	vertical_start;
	U016	vertical_end;
	U008	flags;
	U032	dot_clock;
	U016	refresh;
	U008	reserved[40];
} CRTC_STRUCTURE2, *PCRTC_STRUCTURE2;



//*****************************************************************************
// DMT (Discret Mode Timings) for older monitors
//*****************************************************************************

//*****************************************************************************
//
// Do VESA 1.0 rev 0.7 DMT timings for the following modes:
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7 
// Monitor Timing Specifications and D.Reed's NV3 CRTC spreadsheet.
//
//       1600 x 1200 @ 60,70,75,85
//       1280 x 1024 @ 60,75,85
//       1152 x  864 @ 75
//       1024 x  768 @ 60,70,75,85
//        800 x  600 @ 60,72,75,85
//        640 x  480 @ 60,72,75,85
//
// The refresh rates in the Mode Table are specified in the following order:
//
//       60,70,72,75,85,100,120
//
//*****************************************************************************

#define POLAR_NEG_NEG        0x0c0
#define POLAR_POS_NEG        0x040
#define POLAR_NEG_POS        0x080
#define POLAR_POS_POS        0x000


U016 DMTOverrideTable[NUMBER_OF_MODES*NUMBER_OF_RATES][13] =
{
    //0:
    // Settings for 1600x1200:
    16200, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    18900, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    20250, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    22950, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    //1:
    // Settings for 1280x1024:
    10800, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a7,   0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    13500, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a3,   0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    15750, POLAR_POS_POS, 0x0d3, 0x09f, 0x097, 0x0a9,   0x01d, 0x02e, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x02f,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    //2:
    // Settings for 1152x864:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    10800, POLAR_POS_POS, 0x0c3, 0x08f, 0x087, 0x099, 0x009, 0x082, 0x0ff, (0x061-1), (0x024-1) | 0x080, 0x05f, 0x083,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //3:
    // Settings for 1024x768:
    6500 , POLAR_NEG_NEG, 0x0a3, 0x07f, 0x087, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7500 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
// 72Hz does not appear in DMT, so this is a fudge of the GTF's    
    7843 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x085, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7875 , POLAR_POS_POS, 0x09f, 0x07f, 0x083, 0x083, 0x08f, 0x01e, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x01f,
    9450 , POLAR_POS_POS, 0x0a7, 0x07f, 0x08b, 0x087, 0x093, 0x026, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x027,
// 100Hz does not appear in DMT, so this is a fudge of the GTF's    
    11370, POLAR_POS_POS, 0x0a9, 0x07f, 0x08D, 0x086, 0x098, 0x02C, 0x0f5, (0x002-1), (0x024-1) | 0x080, 0x0ff, 0x02D,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //4:
    // Settings for 960x720:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //5:
    // Settings for 800x600:
    4000 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x06a, 0x01a, 0x072, 0x0f0, (0x059-1), (0x02d-1) | 0x080, 0x057, 0x073,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    5000 , POLAR_POS_POS, 0x07d, 0x063, 0x081, 0x06c, 0x01b, 0x098, 0x0f0, (0x07d-1), (0x023-1) | 0x080, 0x057, 0x099,
    4950 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x067, 0x011, 0x06f, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x070,
    5625 , POLAR_POS_POS, 0x07e, 0x063, 0x082, 0x069, 0x011, 0x075, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x076,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //6:
    // Settings for 640x480:
    2517 , POLAR_NEG_NEG, 0x05f, 0x04f, 0x083, 0x053, 0x09f, 0x00b, 0x03e, (0x0ea-1), (0x02c-1) | 0x080, 0x0df, 0x00c,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    3150 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x054, 0x099, 0x006, 0x03e, (0x0e9-1), (0x02c-1) | 0x080, 0x0df, 0x007,
    3150 , POLAR_NEG_NEG, 0x064, 0x04f, 0x088, 0x053, 0x09b, 0x0f2, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0f3,
    3600 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x058, 0x09f, 0x0fb, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0fc,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //7:
    // Settings for 640x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //8:
    // Settings for 512x384:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //9:
    // Settings for 480x360:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //10:
    // Settings for 400x300:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //11:
    // Settings for 320x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //12:
    // Settings for 320x240:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //13:
    // Settings for 320x200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //14:
    // Settings for 1920x1200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //15:
    // Settings for 1920x1080:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //16:
    // Settings for 1800x1440:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    
    //17:
    // Settings for 2048x1536:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    
};

//---------------------------------------------------------------------------
//
//  Set the requested video mode
//
//---------------------------------------------------------------------------

RM_STATUS osSetVideoMode
(
    PHWINFO pDev
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    U008    mode, bitdepth, doubled;
    CLIENT_STRUCT     crs;
    CRTC_STRUCTURE timings;
    CRTC_STRUCTURE2 timings2;
    U032    i, data32, temp32;
    U032    bios_revision;
    U032    UseDMTFlag;
    BOOL    monitorIsGTF;
    RM_STATUS status;
    DISPLAYINFO tmpDisplayInfo;
    BOOL    optimalRefreshSelected;
    U032    monitorTimingMode;
    GTF_TIMINGS vbe_timings;
    PDMT_OVERRIDES pDMTOverrides;
    U008 base_mode;
    U032 rate_table[] = {60,70,72,75,85,100,120,140,144,150,170,200,240};
    U032 validArb;

	mode = 0;
    doubled = 0;


    OEMEnableExtensions();          // Unlock the registers before DDC
    EDIDRead(pDev);
    OEMDisableExtensions();         // Lock the registers

	// get the index for the first dimension (resolution)
	switch (pDev->Framebuffer.VertDisplayWidth)
	{
		case 1440:
			mode = NUMBER_OF_DEPTHS*16; 
		    break;
		case 1080:
			mode = NUMBER_OF_DEPTHS*15; 
		    break;
		case 1200:
			// Just use a nested case for redundant vertical widths.
			switch (pDev->Framebuffer.HorizDisplayWidth)
			{
			  case 1920:
			    mode = NUMBER_OF_DEPTHS*14; 
			    break;
			  case 1600:
			    mode = NUMBER_OF_DEPTHS*0; 
			    break;
			  default:
			    break;
			}
	    	break;
		case 1024:
			mode = NUMBER_OF_DEPTHS*1; 
		    break;
		case 864:
			mode = NUMBER_OF_DEPTHS*2;
		    break;
		case 768:
			mode = NUMBER_OF_DEPTHS*3;
		    break;
		case 720:
			mode = NUMBER_OF_DEPTHS*4; 
		    break;
		case 600:
			mode = NUMBER_OF_DEPTHS*5; 
		    break;
		case 480:
			mode = NUMBER_OF_DEPTHS*6; 
			break;
		case 400:
			switch (pDev->Framebuffer.HorizDisplayWidth)
			{
			  case 640:
			    mode = NUMBER_OF_DEPTHS*7; 
			    break;
			  case 320:
                mode = NUMBER_OF_DEPTHS*11; 
			    break;
			  default:
			    break;
			}
			break;
		case 384:
			mode = NUMBER_OF_DEPTHS*8; 
            doubled = 1;
			break;
		case 360:
			mode = NUMBER_OF_DEPTHS*9; 
            doubled = 1;
			break;
		case 300:
			mode = NUMBER_OF_DEPTHS*10; 
            doubled = 1;
			break;
		case 240:
			mode = NUMBER_OF_DEPTHS*12; 
            doubled = 1;
			break;
		case 200:
			mode = NUMBER_OF_DEPTHS*13; 
            doubled = 1;
			break;
		default:
		    mode = NUMBER_OF_DEPTHS*6;
	}

	switch (pDev->Framebuffer.Depth)
	// the depth is 4,8,16,24, or 32. Add the second dimension.
	{
		case 4:
			break;
		case 8:
			bitdepth = mode + 1;
			break;
		case 16:
			bitdepth = mode + 2;
			break;
		case 24:
			bitdepth = mode + 3;
			break;
		case 32:
			bitdepth = mode + 3;
			break;
	    default:
			bitdepth = mode + 2;
    }
    
    // VBE SetMode
    crs.CWRS.Client_AX = 0x4F02;
	// get mode from the 2 dimensional array
	crs.CWRS.Client_BX = ModeSetTable[bitdepth];
	if ((crs.CWRS.Client_BX == 0xff) || (bitdepth > (MODE_TABLE_LENGTH)))
		crs.CWRS.Client_BX = DEFAULT_MODE;
    // linear/flat frame buffer, clear memory, use default CRTC/refresh values
    crs.CWRS.Client_BX |= 0x4000;

    //
    // Make sure we're not going into a mode that's not possible for boards with
    // less than 8meg of framebuffer
    //
    if ((pDev->Framebuffer.VertDisplayWidth >= 1024) && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.RamSizeMb < 8))
		    crs.CWRS.Client_BX = DEFAULT_MODE;

    // Figure out what monitor timing mode we want. It is controlled by a registry flag "MonitorTiming".
    monitorTimingMode = 0; // By default, read the EDID of the monitor.
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strMonitorTiming, &data32) == RM_OK)
    {
        monitorTimingMode = data32;
    }
    switch (monitorTimingMode)
    {
        case 1:
            // Use DMT.
            UseDMTFlag = TRUE;
            break;
        case 2:
            // Use GTF.
            UseDMTFlag = FALSE;
            break;
        case 3:
            // Legacy mode.
            // Read the legacy DMT Override flag to see if we should use DMT. Otherwise use GTF.
            UseDMTFlag = FALSE;
            if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strDMTOverride, &data32) == RM_OK)
            {
                if (data32 == 1)
                    UseDMTFlag = TRUE;
            }
            break;
        default:
            // Automatically set it by reading the EDID.
            UseDMTFlag = TRUE; // default to DMT
            if (EDIDIsMonitorGTF(pDev, &monitorIsGTF) == RM_OK)
            {
                UseDMTFlag = (monitorIsGTF) ? FALSE : TRUE;
            }
            break;
            // 
    }

    //
    // If there's an override setting for the refresh rate, use it instead
    //
    if (osReadRegistryDword(strDevNodeRM, strRefreshOverride, &data32) == RM_OK)
        pDev->Framebuffer.HalInfo.RefreshRate = data32;


    //
    // The GTF timings for 640x400 at 70Hz and 72Hz are drastically different than
    // the original VGA timings (which officially only list 85Hz as a support rate
    // at this resolution).  Therefore, when we attempt to set the GTF rates the
    // monitors just aren't happy.
    //
    // We have two choices.  Tweak our 70Hz and 72Hz GTF numbers to mimic VGA, or
    // just use IBM VGA (70Hz) for these two rates.  Since we're doing it right, and
    // the monitors just aren't happy, I vote for the latter.
    //
    // Remember that IBM VGA 640x400 starts at 70Hz, not 60Hz.
    //
    if ((pDev->Framebuffer.HorizDisplayWidth == 640) && (pDev->Framebuffer.VertDisplayWidth == 400)
        && (pDev->Framebuffer.HalInfo.RefreshRate < 75))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; // this will kick in BIOS default values (70Hz)

    //
    // NV4 limits for hires modes at 32bpp.  Windows will still send down optimal values larger
    // than the limits we placed in our INF.  Don't let them through.
    //
    if ((pDev->Framebuffer.HorizDisplayWidth == 1280) && (pDev->Framebuffer.VertDisplayWidth == 1024)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 100))
            pDev->Framebuffer.HalInfo.RefreshRate = 100; 
    
    if ((pDev->Framebuffer.HorizDisplayWidth == 1600) && (pDev->Framebuffer.VertDisplayWidth == 1200)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 75))
            pDev->Framebuffer.HalInfo.RefreshRate = 75; 
    
    if ((pDev->Framebuffer.HorizDisplayWidth == 1920) && (pDev->Framebuffer.VertDisplayWidth == 1080)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 72))
            pDev->Framebuffer.HalInfo.RefreshRate = 72; 
    
    if ((pDev->Framebuffer.HorizDisplayWidth == 1920) && (pDev->Framebuffer.VertDisplayWidth == 1200)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 60))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; 
            
    //
    // There is a hardware bug in NV4's arbitration hardware having to do with memory refresh and
    // page misses.  This shows its ugly head during 64bit operation (8meg SDRAM).  If we see
    // a pixelclock setting above ~160Hz in 32bpp, drop it down to 60Hz.
    //
    // The user may have selected a different refresh rate (since the INF allows it), but they're
    // going to get 60Hz.  Sorry.
    //            
    // The highest resolution in 8meg is 1600x1200x32bpp, so just watch for that
    //
    if ((pDev->Chip.MaskRevision == NV_PMC_BOOT_0_MASK_REVISION_A)
        && (pDev->Framebuffer.RamSizeMb == 8) && (pDev->Dac.InputWidth == 64)
        && (pDev->Framebuffer.HorizDisplayWidth == 1600) 
        && (pDev->Framebuffer.VertDisplayWidth == 1200)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 60))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; 

    // Check if "optimal" refresh rate was chosen. 
    // When "optimal" is chosen, both min and max refresh rates in DISPLAYINFO will have non-zero values. 
    // When a specific refresh rate is chosen, max will have that value and the min will have zero. 
    // When "default" is chosen, both min and max will be zero.
    tmpDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &tmpDisplayInfo, sizeof(DISPLAYINFO));
    if ((tmpDisplayInfo.RefreshRateMax != 0) && (tmpDisplayInfo.RefreshRateMin != 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "OPTIMAL REFRESH!!\n\r");

        // Try to get the max frequency for this mode from the EDID. 
        // If we get a refresh rate that is less than what we have now,
        // we will use the lower value.
        if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strOptimalNotFromEDID, &data32) != RM_OK)
        {
            // No registry entry that prohibits us from looking in the EDID.
            status = EDIDGetMaxRefreshRate(pDev, pDev->Framebuffer.HorizDisplayWidth, 
                                           pDev->Framebuffer.VertDisplayWidth,
                                           &data32);
            if (status == RM_OK     && 
                data32 != 0 &&
                data32 < pDev->Framebuffer.HalInfo.RefreshRate)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = data32;
            }
        } // Get optimal from EDID

        // Read the registry to see if there is a limit for the "optimal" refresh rate.
        if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strMaxOptimalRefreshRate, &data32) == RM_OK)
        {
            // Ignore the value read if it is less than 60Hz.
            if (data32 >= 60 &&
                data32 < pDev->Framebuffer.HalInfo.RefreshRate)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = data32;
            }
        }
    } // "optimal" refresh rate chosen
    
    //
    // If there's max refresh rate, make sure we don't exceed that.
    //
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strMaxRefreshRate, &data32) == RM_OK)
    {
        // Ignore the value read if it is less than 60Hz.
        if (data32 >= 60 &&
            pDev->Framebuffer.HalInfo.RefreshRate > data32)
        {
            pDev->Framebuffer.HalInfo.RefreshRate = data32;
        }
    }

    //
    // Plug in the refresh timings.  Until we have the real algorithm, just
    // use the predefined table.  Adjust all tweener rates to the real rates.
    //
    mode /= NUMBER_OF_DEPTHS;
    mode *= NUMBER_OF_RATES;
    base_mode = mode;
    crs.CWRS.Client_BX |= 0x0800;

    if (pDev->Framebuffer.HalInfo.RefreshRate >= 240)
    {        
        mode += 12;
        pDev->Framebuffer.HalInfo.RefreshRate = 240;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 200)
    {        
        mode += 11;
        pDev->Framebuffer.HalInfo.RefreshRate = 200;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 170)
    {        
        mode += 10;
        pDev->Framebuffer.HalInfo.RefreshRate = 170;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 150)
    {      
        //
        // Most monitors can support the vert range of 800x600x150Hz but cannot support the
        // horiz range.  We removed 150Hz from the INF, but in case Windows tries it anyway,
        // override with one lower rate.
        //
        if ((pDev->Framebuffer.HorizDisplayWidth == 800) && (pDev->Framebuffer.VertDisplayWidth == 600))
        {
            mode += 8;
            pDev->Framebuffer.HalInfo.RefreshRate = 144;
        }                
        else
        {        
            mode += 9;
            pDev->Framebuffer.HalInfo.RefreshRate = 150;
        }                
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 144)
    {        
        mode += 8;
        pDev->Framebuffer.HalInfo.RefreshRate = 144;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 140)
    {        
        mode += 7;
        pDev->Framebuffer.HalInfo.RefreshRate = 140;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 120)
    {        
        mode += 6;
        pDev->Framebuffer.HalInfo.RefreshRate = 120;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 100)
    {        
        mode += 5;
        pDev->Framebuffer.HalInfo.RefreshRate = 100;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 85)
    {        
        mode += 4;
        pDev->Framebuffer.HalInfo.RefreshRate = 85;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 75)
    {        
        mode += 3;
        pDev->Framebuffer.HalInfo.RefreshRate = 75;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 72)
    {        
        mode += 2;
        pDev->Framebuffer.HalInfo.RefreshRate = 72;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 70)
    {        
        mode += 1;
        pDev->Framebuffer.HalInfo.RefreshRate = 70;
    }            
    else
    {        
        mode += 0;
        pDev->Framebuffer.HalInfo.RefreshRate = 60;
    }            

    //
    // The documented method for Windows to select refresh rates for a display/monitor
    // combination is to take the intersection of the monitor INF entries (EDID) and
    // the display device's INF values.  This will then dictate the rates that are
    // valid for both devices.
    //
    // Unfortunately, it seems Microsoft didn't follow their own documentation in all
    // cases.  If a user selects OPTIMAL from the refresh rate menu, Windows will ask
    // us to set a refresh rate that matches the monitor information.  It doesn't matter
    // if the rate is beyond the display device's INF entries.
    //
    // Due to clocking differences between all of our shipping chips, we need to
    // validate all attempted refresh rates.  If a rate is beyond our device's limits
    // based on memory and clock variables, we need to attempt one refresh rate lower.
    // Luckily, the user has selected OPTIMAL and doesn't know exactly what rate she
    // is choosing.  If we drop it by one or two values, it doesn't really matter.
    //

    nvHalDacValidateArbSettings(pDev, 
                                pDev->Framebuffer.Depth, 0, 0, 
                                (U032)(ModeTimingTable[mode][6] * 10000),
                                &validArb);

    while ((mode > base_mode) && (!validArb))
    {
        // drop a refresh rate
        mode--;
        pDev->Framebuffer.HalInfo.RefreshRate = rate_table[mode];
         
        nvHalDacValidateArbSettings(pDev, 
                                    pDev->Framebuffer.Depth, 0, 0, 
                                    (U032)(ModeTimingTable[mode][6] * 10000),
                                    &validArb);
    }                                                            

    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strNewModeSet, &data32) == RM_OK)
    {
        // New style modeset.
        MODE_TIMING_VALUES timingValues;
        unsigned int vesaStatus;

        if ((pDev->Framebuffer.HorizDisplayWidth == 640) && 
            (pDev->Framebuffer.VertDisplayWidth == 480)  &&
            (pDev->Framebuffer.HalInfo.RefreshRate == 60))
        {
            // force 640x480 @60Hz into DMT mode.
            UseDMTFlag = TRUE;
        }

        if (UseDMTFlag)
        {
            // Get DMT timings for this mode. 
            vesaStatus = vesaGetDMTTimings(pDev->Framebuffer.HorizDisplayWidth, 
                                           pDev->Framebuffer.VertDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.RefreshRate,
                                           &timingValues);
            // If we failed to get DMT timings for this mode, force GTF
            if (vesaStatus != 0)
            {
                UseDMTFlag = FALSE;
            }
        }

        if (!UseDMTFlag)
        {
            // Get the GTF timings
            vesaStatus = vesaGetGTFTimings(pDev->Framebuffer.HorizDisplayWidth, 
                                           pDev->Framebuffer.VertDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.RefreshRate,
                                           &timingValues);
        }

        // copy all the relevant data to the pDev and call dacProgramCRTC.
        if (vesaStatus == 0)
        {
            pDev->Dac.HorizontalVisible       = timingValues.HorizontalVisible;
            pDev->Dac.HorizontalBlankStart    = timingValues.HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = timingValues.HorizontalRetraceStart;
            pDev->Dac.HorizontalRetraceEnd    = timingValues.HorizontalRetraceEnd;
            pDev->Dac.HorizontalBlankEnd      = timingValues.HorizontalBlankEnd;
            pDev->Dac.HorizontalTotal         = timingValues.HorizontalTotal;
            pDev->Dac.VerticalVisible         = timingValues.VerticalVisible;
            pDev->Dac.VerticalBlankStart      = timingValues.VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = timingValues.VerticalRetraceStart;
            pDev->Dac.VerticalRetraceEnd      = timingValues.VerticalRetraceEnd;
            pDev->Dac.VerticalBlankEnd        = timingValues.VerticalBlankEnd;
            pDev->Dac.VerticalTotal           = timingValues.VerticalTotal;
            pDev->Dac.PixelDepth              = pDev->Framebuffer.Depth;
            pDev->Dac.HalInfo.PixelClock      = timingValues.PixelClock;
            pDev->Dac.HorizontalSyncPolarity  = timingValues.HSyncpolarity;
            pDev->Dac.VerticalSyncPolarity    = timingValues.VSyncpolarity;
            pDev->Dac.DoubleScannedMode       = (pDev->Framebuffer.VertDisplayWidth < 400) ? TRUE : FALSE;

            dacProgramCRTC(pDev);
        } // successfully obtained timing values.
        else
        {
            // What the heck are we going to do now! There is neither a valid DMT or GTF 
            // timing description for this mode.
            DBG_BREAKPOINT();
        }
    } // do new style modeset
    else
    {
        // old style modeset.

        //
        // Load up the VBE information table
        //
        vbe_timings.horiz_total     = ModeTimingTable[mode][0];
        vbe_timings.horiz_start     = ModeTimingTable[mode][1];
        vbe_timings.horiz_end       = ModeTimingTable[mode][2];
        vbe_timings.vertical_total  = ModeTimingTable[mode][3];
        vbe_timings.vertical_start  = ModeTimingTable[mode][4];
        vbe_timings.vertical_end    = ModeTimingTable[mode][5];
        vbe_timings.dot_clock       = (U032)(ModeTimingTable[mode][6] * 10000);
        vbe_timings.refresh         = ModeTimingTable[mode][7];
        vbe_timings.flags           = (doubled) ? 0x01 : 0x00;
        vbe_timings.flags |= (ModeTimingTable[mode][8] == BUFFER_HSYNC_POSITIVE) ? 0 : 0x04;
        vbe_timings.flags |= (ModeTimingTable[mode][9] == BUFFER_VSYNC_POSITIVE) ? 0 : 0x08;

        if (UseDMTFlag)
        {        
            pDMTOverrides = (PDMT_OVERRIDES)(&(DMTOverrideTable[mode][0]));
            //
            // If there is no DMT entry for this mode/refresh, fall back to default GTF
            //
            if (pDMTOverrides->DotClock == 0)
            {
                UseDMTFlag = FALSE;
            }
        }    

        if (!UseDMTFlag &&
            pDev->Framebuffer.HalInfo.RefreshRate == 60)
        {        
            // The GTF timings for 60Hz are not right. So just fall back to the VGA defaults.
            crs.CWRS.Client_AX = VBESetMode(crs.CWRS.Client_BX, NULL, NULL, FALSE);
        }        
        else
        {
            crs.CWRS.Client_AX = VBESetMode(crs.CWRS.Client_BX, &vbe_timings, pDMTOverrides, (U016)UseDMTFlag);
        }
    }

    //
    // Determine if it's possible to support a video overlay in this resolution
    //
    nvHalDacValidateArbSettings(pDev, 
                                pDev->Framebuffer.Depth, 1, 0, 
                                (U032)(ModeTimingTable[mode][6] * 10000),
                                &(pDev->Video.OverlayAllowed));
    
    // Check/Set any PFB overrides
    if (osReadRegistryDword(strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        pDev->Framebuffer.HalInfo.Overrides.LoadMask |= FB_OVERRIDES_MEMORY;
        pDev->Framebuffer.HalInfo.Overrides.MemoryOverride = data32;
    }
    if (osReadRegistryDword(pDev, strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        pDev->Framebuffer.HalInfo.Overrides.LoadMask |= FB_OVERRIDES_RTL;
        pDev->Framebuffer.HalInfo.Overrides.RTLOverride = data32;
    }
    nvHalFbControl(pDev, FB_CONTROL_LOAD_OVERRIDES);

    //
    // If there's a dma fifo fetch trigger override, use it now
    //
    if (osReadRegistryDword(strDevNodeRM, strFetchTriggerOverride, &data32) == RM_OK)
    {
        pDev->Fifo.DmaFetchTrigger = data32;
    }
    
    //
    // If there's a dma fifo fetch size override, use it now
    //
    if (osReadRegistryDword(strDevNodeRM, strFetchSizeOverride, &data32) == RM_OK)
    {
        pDev->Fifo.DmaFetchSize = data32;
    }

    //
    // If there's a dma fifo fetch max reqs override, use it now
    //
    if (osReadRegistryDword(strDevNodeRM, strFetchMaxReqsOverride, &data32) == RM_OK)
    {
        pDev->Fifo.DmaFetchMaxReqs = data32;
    }

    //
    // If there are graphics debug overrides, use them now
    //
    if (osReadRegistryDword(strDevNodeRM, strGraphicsDebug0, &data32) == RM_OK)
    {
        pDev->Graphics.Debug0 = data32;
    }
    if (osReadRegistryDword(strDevNodeRM, strGraphicsDebug1, &data32) == RM_OK)
    {
        pDev->Graphics.Debug1 = data32;
    }
    if (osReadRegistryDword(strDevNodeRM, strGraphicsDebug2, &data32) == RM_OK)
    {
        pDev->Graphics.Debug2 = data32;
    }
    if (osReadRegistryDword(strDevNodeRM, strGraphicsDebug3, &data32) == RM_OK)
    {
        pDev->Graphics.Debug3 = data32;
    }
    
    //
    // Use the display cursor cache override if available
    //
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strCursorCacheOverride, &data32) == RM_OK)
    {
        if (data32 == 0)
            pDev->Dac.CursorCacheEnable = 0;
        else            
            pDev->Dac.CursorCacheEnable = 1;
    }
    
    //
    // If the modeset was successful, perform any more overrides required
    //
	if (crs.CWRS.Client_AX & 0xff00)
    {
        // let the miniVDD save new register states
        if (pOsHwInfo->miniVDDPostModeChange)  // if primary display, we got callback at init
            (*pOsHwInfo->miniVDDPostModeChange)();
    	return (crs.CRS.Client_EAX);
    }
    else
	{
        //
		// If 16 bit mode, turn on 565
        //
		if (pDev->Framebuffer.Depth == 16)
        {
			FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _SEL);
        }            
        
        //
        // If 16 or 32 bit mode, enable default gamma (no pixmix for these modes)
        //
		if ((pDev->Framebuffer.Depth == 16) || (pDev->Framebuffer.Depth == 32))
        {        
			FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIXMIX, _ON);
        }
            
		// Make sure we're using an 8bit palette
	    FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS);
         
        //
        // Update arb settings for each mode set
        //
        VidLutCurDac.Head = 0;
        nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac));

        // let the miniVDD save new register states
        if (pOsHwInfo->miniVDDPostModeChange)  // if primary display, we got callback at init
            (*pOsHwInfo->miniVDDPostModeChange)();

        //
        // For NV4, change the default flip functionality to end of vsync, not start
        //
        // BUG BUG BUG:  There is a hardware bug in NV4-A relating to this particular
        // register.  You must access another register in this general area before
        // accessing PCRTC_CONFIG
        //
        i = REG_RD32(NV_PCRTC_START);
        FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA);

    	return (RM_OK);
	}
}


BOOL nvIsResolutionValid(HWINFO info1)
{
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nv4\nv04wtch.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NV04wtch.C                                                        *
*   Winice .N Debug Interface. NV04 code                                    *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito 2/6/98
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"
#include "nv4_hal.h"

#ifdef DEBUG

//
// prototypes
//
U032 NvWatch_GetObjectFromInst  (PHWINFO, U032, U032 *);
U032 NvWatch_Dump_HT_Object_From_Handle(PHWINFO, U032);
VOID NvWatch_display_prompt     (PHWINFO, char *);
char get_winice_input           (VOID);

//
// defines
//
#define NVWATCH_SIMPLE      0
#define NVWATCH_COMPLEX     1
#define INSTANCE_MEM_SPACE  nvAddr 

//****NV CONTEXT MENU******************************************************************************

void NvWatch_NV04_Dump_SubChannelContext(PHWINFO pDev, U032 p_channel)
{
  U032  sub_counter;
  U032  nvwatch_fifo_engine_cache1;
  U032  enginet, *inst_ptr, tempv;

  nvwatch_fifo_engine_cache1 = REG_RD32(NV_PFIFO_CACHE1_ENGINE);
  // For each subchannel (Dump the Engine, then the object).
  for(sub_counter=0;sub_counter<NUM_SUBCHANNELS;sub_counter++){
    enginet = nvwatch_fifo_engine_cache1;
    enginet &= 3;
    switch(enginet){
      case 0:
        // We need to get the channel.
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Software Object in Fifo cache0 for Subchannel ",sub_counter);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Accessing pDev->DBfifoTable ...");
        if (pDev->DBfifoTable[p_channel].InUse == FALSE)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: pDev->DBfifoTable NOT InUse !??");
        else{
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Object Name = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Name);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Object Class = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Class->Type);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "CHID = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->ChID);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Subchannel = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Subchannel);
//////    U032       Name;
//////    PCLASS     Class;
//////    U032       ChID;
//////    U032       Subchannel;
//////    NODE       Node[NUM_FIFOS];
//////    POBJECT    Next;
//////    PDMAOBJECT NotifyXlate;
//////    U032       NotifyAction;
//////    U032       NotifyTrigger;
//////    PEVENTNOTIFICATION NotifyEvent;
        }  
        break;
      case 1:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Graphics Object in Fifo cache0 for Subchannel ",sub_counter);
        
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE1 = ",REG_RD32(NV_PGRAPH_CTX_CACHE1(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE2 = ",REG_RD32(NV_PGRAPH_CTX_CACHE2(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE3 = ",REG_RD32(NV_PGRAPH_CTX_CACHE3(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE4 = ",REG_RD32(NV_PGRAPH_CTX_CACHE4(sub_counter)));
        
        tempv = (U032) REG_RD32( NV_PGRAPH_CTX_CACHE4(sub_counter) );
        tempv &= 0xFFFF;
        tempv <<= 4;
        tempv += (U032) (INSTANCE_MEM_SPACE + (pDev->Pram.HalInfo.PraminOffset/4));
        inst_ptr = (U032 *) tempv;
        
        {
          U032 DHandle;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDumping the CTX_CACHE4 Object ...");
          tempv = (U032) REG_RD32( NV_PGRAPH_CTX_CACHE4(sub_counter) );
          tempv &= 0xFFFF;
          if(!NvWatch_GetObjectFromInst(pDev, tempv, &DHandle))
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: Object NOT FOUND !\n");
          else{  
            NvWatch_Dump_HT_Object_From_Handle(pDev, DHandle);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n");
          }  
        }
        break;
      case 2:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DVD Object in Fifo cache0 for Subchannel ",sub_counter);
        break;
      default:
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: INVALID Object in Fifo cache0!");
        break;
    }
    nvwatch_fifo_engine_cache1 >>= 4;
  }
}

void NvWatch_NV04_ContextInfo_help(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      s   - Query SubChannel Contexts (Currently supports active channel ONLY\n\r");
//  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "            Active Channel = ",NvWatch_channel);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      ?   - ???\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      q   - quit this\n\r\n\r");
}

VOID NvWatch_NV04_Query_DeviceContext(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  U032 m_channel=0;
  char pstring[]="NvWatch Context";

  NvWatch_NV04_ContextInfo_help(pDev);
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 's':
      case 'S':
        {
          U032 save_pgraph_fifo;
          
          // Clear the NV_PGRAPH_FIFO so that it can be read.
          save_pgraph_fifo = REG_RD32(NV_PGRAPH_FIFO);
          REG_WR32(NV_PGRAPH_FIFO, 0);
          NvWatch_NV04_Dump_SubChannelContext(pDev, m_channel);
          // Restore the NV_PGRAPH_FIFO.
          REG_WR32(NV_PGRAPH_FIFO, save_pgraph_fifo);
        }  
        break;
      case 'c': // Dump hash table
      case 'C': // Dump hash table
        break;
      default: // Help
        NvWatch_NV04_ContextInfo_help(pDev);
        break;  
    }
  }
}

//****DMA PUSHER AND FIFO MENU******************************************************************************

// THE FIFO: Actually 2X the HW size. A second alias image exists.
//-----------------------------------------
//|0                                      | <-- PFIFO_PUT (word pointer)
//|---------------------------------------| <-- PFIFO_GET ( "     "    )
//|1                                      |
//|---------------------------------------| If PFIFO_PUT==PFIFO_GET then the Fifo is empty
//|2                                      |
//|---------------------------------------| If (PFIFO_PUT+128)%256==PFIFO_GET then the Fifo is full
//|...                                    |
//|---------------------------------------| 0 <= PFIFO_PUT, PFIFO_GET <= 255*4
//|---------------------------------------|
//|127                                    |
//|---------------------------------------|
//|128 == 0 alias                         |
//|---------------------------------------|
//|129 == 1 alias                         |
//|---------------------------------------|
//|...                                    |
//|---------------------------------------|
//|---------------------------------------|
//|255 == 127 alias                       |
//-----------------------------------------
void NvWatch_NV04_DumpFifoContents(PHWINFO pDev)
{
  U032 save_puller, save_pusher;
  U032 nvw_fifo_get,nvw_fifo_put;
  U032 fifo_count;
  BOOL fifo_is_empty=FALSE,fifo_is_full=FALSE;
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
  
  // In order to dump the fifo the puller and pusher must be disabled.
  save_puller = REG_RD32(NV_PFIFO_CACHE1_PULL0);
  save_pusher = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
  REG_WR32(NV_PFIFO_CACHE1_PULL0,0);
  REG_WR32(NV_PFIFO_CACHE1_PUSH0,0);

  // The Fifo is 128 entries deep.
  nvw_fifo_get = REG_RD32(NV_PFIFO_CACHE1_GET);
  nvw_fifo_put = REG_RD32(NV_PFIFO_CACHE1_PUT);

  for(fifo_count=0;fifo_count<128;fifo_count++){
    
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, fifo_count);
    
    if( ( ( (nvw_fifo_get%(128*4)) /4) == fifo_count) && (( (nvw_fifo_put%(128*4)) /4) == fifo_count)){
      if(nvw_fifo_get == nvw_fifo_put)
        fifo_is_empty = TRUE;
      else  
        fifo_is_full = TRUE;
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,    " PFIFO_GET->\n");
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,    "           PFIFO_PUT-> Method = ");
    }else{
      if(( (nvw_fifo_get%(128*4)) /4) == fifo_count)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  " PFIFO_GET-> Method = ");
      else{  
        if(( (nvw_fifo_put%(128*4)) /4) == fifo_count)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS," PFIFO_PUT-> Method = ");
        else
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"             Method = ");
      }  
    }  
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(NV_PFIFO_CACHE1_METHOD(fifo_count)) );
    
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"             Data = ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(NV_PFIFO_CACHE1_DATA(fifo_count)) );
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
  }

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo Methods decode as 15:13-Subchannel 12:2-Method offset.\n");

  if(fifo_is_empty){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nThe Fifo is EMPTY\n\r");
  }else{
    if(fifo_is_full){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nThe Fifo is FULL\n\r");
    }else{
      // This should be an error !!! Never full and Empty!
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: The Fifo is Neither FULL or EMPTY!!!\n\r");
    }
  }  
  
  // Restore the pusher and puller registers.
  REG_WR32(NV_PFIFO_CACHE1_PULL0,save_puller);
  REG_WR32(NV_PFIFO_CACHE1_PUSH0,save_pusher);
}

void NvWatch_NV04_DumpUserDmaBuffersAtGet(PHWINFO pDev)
{
    U032 channel_count;
    U032 current_channel;
    U032 channel_get;
    U032 channel_dma_inst;
    U032 channel_get_page, channel_get_offset,channel_dmabuffer_physical;
    U032 *instance_data_ptr, *instance_pte_ptr;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n*********************************************");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCalculating Physical addresses for PushBuffers\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,   "*********************************************\n");

    current_channel = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    for(channel_count=0;channel_count<NUM_FIFOS;channel_count++){
        // Is this channel running in DMA Mode ?
        if((REG_RD32(NV_PFIFO_MODE)>>channel_count)&1){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DMA Channel=",(int)channel_count);
            // Get the get pointer value.
            // From fifo context or the fifo engine ?
            if(channel_count==current_channel){
                // Go to the fifo engine.
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "This is the current channel=",(int)channel_count);
                channel_get = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
                channel_dma_inst = REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The get pointer from the fifo engine=",(int)         channel_get);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The dma instance from the fifo engine=",(int)channel_dma_inst);

            }else{
                // Go to the fifo context area in instance memory.
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "This is NOT the current channel=",(int)channel_count);
                {
                   U032 *ptr_fifocontextarea;

                   switch(REG_RD_DRF(_PFIFO, _RAMHT, _SIZE)){
                     case NV_PFIFO_RAMHT_SIZE_4K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x1000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_8K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x2000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_16K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x4000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_32K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x8000) /4) );
                       break;
                   }
                   channel_get = (U032) *(ptr_fifocontextarea+1+(channel_count*8));
                   channel_dma_inst = (U032) *(ptr_fifocontextarea+3+(channel_count*8));
                   channel_dma_inst &= 0xFFFF;
                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The get pointer from the fifo context=",(int)         channel_get);
                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The dma instance from the fifo context=",(int)channel_dma_inst);
                }
            } // equal current channel

            channel_get_page = (U032) channel_get >> 12;
            channel_get_offset = (U032) channel_get & 0xFFF;
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel get pointers page=",(int)   channel_get_page);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel get pointers offset=",(int) channel_get_offset);


            instance_data_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset+(channel_dma_inst<<4))/4));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Linear address of Push buffer context=",(int)instance_data_ptr);
            // System memory DMA contexts will have all of the PTE's listed in instance memory.(scatter/gather)
            // AGP and FB DMA Contexts will only require a base DMA context.
            // Check the type bits of the DMA context in instance memory.
            switch( ((*instance_data_ptr)>>16) & 3){
                case 2: /*system memory*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in SYSTEM MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2+channel_get_page);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Linear address of Push buffer context PTE=",(int)instance_pte_ptr);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get_offset;
                    break;
                case 3: /*AGP system memory*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in AGP SYSTEM MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get;
                    break;
                case 0: /*frame buffer NVM*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in FRAME BUFFER MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get;
                    break;
            }
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Physical address of Push buffer at the get pointer=",(int)channel_dmabuffer_physical);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Don't forget the 12bit ADJUST value for the DMA Context=",(int)((*instance_data_ptr)>>20));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "ADJUSTED Physical address of Push buffer at the get pointer=",(int)(channel_dmabuffer_physical+((*instance_data_ptr)>>20)));
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        } // DMA Mode
    }
}

void NvWatch_NV04_DmaPushAndFifo_help(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      f   - Dump Fifo Contents\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      c   - Get Physical address of DmaBuffers at Current Get ptr.(DmaPush channels only)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      d   - Dump DmaPusher Info (Not Implemented)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit this\n\r\n\r");
}

void NvWatch_NV04_DmaPushAndFifo(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  char pstring[]="NvWatch Fifo";

  NvWatch_NV04_DmaPushAndFifo_help(pDev);
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 'f': // Dump fifo 
      case 'F': // Dump fifo 
        NvWatch_NV04_DumpFifoContents(pDev);
        break;
      case 'c': 
      case 'C': 
        NvWatch_NV04_DumpUserDmaBuffersAtGet(pDev);
        break;
      case 'b': 
      case 'B': 
        break;
      default: // Help
        NvWatch_NV04_DmaPushAndFifo_help(pDev);
        break;  
    }
  }
}

void NvWatch_NV04_Dump_Graphics(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nGraphics Engine State:\r\n");
 
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_0             0x00400080  RW-4R  = ", REG_RD32(   NV_PGRAPH_DEBUG_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_1             0x00400084  RW-4R  = ", REG_RD32(   NV_PGRAPH_DEBUG_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_2             0x00400088  RW-4R  = ", REG_RD32(   NV_PGRAPH_DEBUG_2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_3             0x0040008C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DEBUG_3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_INTR                0x00400100  RW-4R  = ", REG_RD32(   NV_PGRAPH_INTR                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_NSOURCE             0x00400108  R--4R  = ", REG_RD32(   NV_PGRAPH_NSOURCE               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_INTR_EN             0x00400140  RW-4R  = ", REG_RD32(   NV_PGRAPH_INTR_EN               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH1         0x00400160  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH2         0x00400164  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH2           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH3         0x00400168  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH3           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_CONTROL         0x00400170  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_CONTROL           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_USER            0x00400174  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_USER              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FIFO                0x00400720  RW-4R  = ", REG_RD32(   NV_PGRAPH_FIFO                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FFINTFC_ST2         0x00400754  RW-4R  = ", REG_RD32(   NV_PGRAPH_FFINTFC_ST2           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STATUS              0x00400700  R--4R  = ", REG_RD32(   NV_PGRAPH_STATUS                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_TRAPPED_ADDR        0x00400704  R--4R  = ", REG_RD32(   NV_PGRAPH_TRAPPED_ADDR          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_TRAPPED_DATA        0x00400708  R--4R  = ", REG_RD32(   NV_PGRAPH_TRAPPED_DATA          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SURFACE             0x0040070C  RW-4R  = ", REG_RD32(   NV_PGRAPH_SURFACE               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_NOTIFY              0x00400714  RW-4R  = ", REG_RD32(   NV_PGRAPH_NOTIFY                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET0            0x00400640  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET1            0x00400644  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET1              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET2            0x00400648  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET3            0x0040064C  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET3              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET4            0x00400650  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET4              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET5            0x00400654  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET5              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE0              0x00400658  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE1              0x0040065c  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE2              0x00400660  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE2                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE3              0x00400664  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE3                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE4              0x00400668  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE4                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE5              0x0040066C  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE5                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH0             0x00400670  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH1             0x00400674  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH2             0x00400678  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH3             0x0040067C  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH4             0x00400680  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT0             0x00400684  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT1             0x00400688  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT2             0x0040068c  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT3             0x00400690  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT4             0x00400694  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT5             0x00400698  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT5               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BSWIZZLE2           0x0040069c  RW-4R  = ", REG_RD32(   NV_PGRAPH_BSWIZZLE2             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BSWIZZLE5           0x004006a0  RW-4R  = ", REG_RD32(   NV_PGRAPH_BSWIZZLE5             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPIXEL              0x00400724  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPIXEL                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_LIMIT_VIOL_Z        0x00400614  RW-4R  = ", REG_RD32(   NV_PGRAPH_LIMIT_VIOL_Z          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STATE               0x00400710  RW-4R  = ", REG_RD32(   NV_PGRAPH_STATE                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CACHE_INDEX         0x00400728  RW-4R  = ", REG_RD32(   NV_PGRAPH_CACHE_INDEX           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CACHE_RAM           0x0040072c  RW-4R  = ", REG_RD32(   NV_PGRAPH_CACHE_RAM             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_PITCH           0x00400760  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_PITCH             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DVD_COLORFMT        0x00400764  RW-4R  = ", REG_RD32(   NV_PGRAPH_DVD_COLORFMT          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SCALED_FORMAT       0x00400768  RW-4R  = ", REG_RD32(   NV_PGRAPH_SCALED_FORMAT         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATT_COLOR0         0x00400800  RW-4R  = ", REG_RD32(   NV_PGRAPH_PATT_COLOR0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATT_COLOR1         0x00400804  RW-4R  = ", REG_RD32(   NV_PGRAPH_PATT_COLOR1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATTERN_SHAPE       0x00400810  RW-4R  = ", REG_RD32(   NV_PGRAPH_PATTERN_SHAPE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MONO_COLOR0         0x00400600  RW-4R  = ", REG_RD32(   NV_PGRAPH_MONO_COLOR0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ROP3                0x00400604  RW-4R  = ", REG_RD32(   NV_PGRAPH_ROP3                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CHROMA              0x00400814  RW-4R  = ", REG_RD32(   NV_PGRAPH_CHROMA                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BETA_AND            0x00400608  RW-4R  = ", REG_RD32(   NV_PGRAPH_BETA_AND              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BETA_PREMULT        0x0040060c  RW-4R  = ", REG_RD32(   NV_PGRAPH_BETA_PREMULT          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CONTROL0            0x00400818  RW-4R  = ", REG_RD32(   NV_PGRAPH_CONTROL0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CONTROL2            0x00400820  RW-4R  = ", REG_RD32(   NV_PGRAPH_CONTROL2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLEND               0x00400824  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLEND                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DPRAM_INDEX         0x00400828  RW-4R  = ", REG_RD32(   NV_PGRAPH_DPRAM_INDEX           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DPRAM_DATA          0x0040082c  RW-4R  = ", REG_RD32(   NV_PGRAPH_DPRAM_DATA            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STORED_FMT          0x00400830  RW-4R  = ", REG_RD32(   NV_PGRAPH_STORED_FMT            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMATS             0x00400618  RW-4R  = ", REG_RD32(   NV_PGRAPH_FORMATS               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC0      0x00400514  RW-4R  = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC0        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC1      0x00400518  RW-4R  = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC1        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC2      0x0040051C  RW-4R  = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC2        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC3      0x00400520  RW-4R  = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC3        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_X_MISC              0x00400500  RW-4R  = ", REG_RD32(   NV_PGRAPH_X_MISC                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_Y_MISC              0x00400504  RW-4R  = ", REG_RD32(   NV_PGRAPH_Y_MISC                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_XMIN      0x0040053C  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_XMIN        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_XMAX      0x00400544  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_XMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_YMIN      0x00400540  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_YMIN        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_YMAX      0x00400548  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_YMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_XMIN     0x00400560  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_XMIN       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_XMAX     0x00400568  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_XMAX       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_YMIN     0x00400564  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_YMIN       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_YMAX     0x0040056C  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_YMAX       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SOURCE_COLOR        0x0040050C  RW-4R  = ", REG_RD32(   NV_PGRAPH_SOURCE_COLOR          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_VALID1              0x00400508  RW-4R  = ", REG_RD32(   NV_PGRAPH_VALID1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_VALID2              0x00400578  RW-4R  = ", REG_RD32(   NV_PGRAPH_VALID2                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_ICLIP_XMAX      0x00400534  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_ICLIP_XMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_ICLIP_YMAX      0x00400538  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_ICLIP_YMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPX_0             0x00400524  RW-4R  = ", REG_RD32(   NV_PGRAPH_CLIPX_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPX_1             0x00400528  RW-4R  = ", REG_RD32(   NV_PGRAPH_CLIPX_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPY_0             0x0040052c  RW-4R  = ", REG_RD32(   NV_PGRAPH_CLIPY_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPY_1             0x00400530  RW-4R  = ", REG_RD32(   NV_PGRAPH_CLIPY_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_0            0x00400510  RW-4R  = ", REG_RD32(   NV_PGRAPH_MISC24_0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_1            0x00400570  RW-4R  = ", REG_RD32(   NV_PGRAPH_MISC24_1              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_2            0x00400574  RW-4R  = ", REG_RD32(   NV_PGRAPH_MISC24_2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_0          0x0040057C  RW-4R  = ", REG_RD32(   NV_PGRAPH_PASSTHRU_0            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_1          0x00400580  RW-4R  = ", REG_RD32(   NV_PGRAPH_PASSTHRU_1            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_2          0x00400584  RW-4R  = ", REG_RD32(   NV_PGRAPH_PASSTHRU_2            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_XY              0x004005c0  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_XY                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_U0              0x004005c4  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_U0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_V0              0x004005c8  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_V0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_U1              0x004005cc  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_U1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_V1              0x004005d0  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_V1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_ZETA            0x004005d4  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_ZETA              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_RGB             0x004005d8  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_RGB               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_S               0x004005dc  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_S                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_M               0x004005e0  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_M                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMAT0             0x004005A8  RW-4R  = ", REG_RD32(   NV_PGRAPH_FORMAT0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMAT1             0x004005AC  RW-4R  = ", REG_RD32(   NV_PGRAPH_FORMAT1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FILTER0             0x004005B0  RW-4R  = ", REG_RD32(   NV_PGRAPH_FILTER0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FILTER1             0x004005B4  RW-4R  = ", REG_RD32(   NV_PGRAPH_FILTER1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE0ALPHA       0x00400590  RW-4R  = ", REG_RD32(   NV_PGRAPH_COMBINE0ALPHA         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE0COLOR       0x00400594  RW-4R  = ", REG_RD32(   NV_PGRAPH_COMBINE0COLOR         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE1ALPHA       0x00400598  RW-4R  = ", REG_RD32(   NV_PGRAPH_COMBINE1ALPHA         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE1COLOR       0x0040059C  RW-4R  = ", REG_RD32(   NV_PGRAPH_COMBINE1COLOR         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_START_0         0x00401000  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_START_0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_START_1         0x00401004  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_START_1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_LENGTH          0x00401008  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_LENGTH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_MISC            0x0040100C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_MISC              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_DATA_0          0x00401020  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_DATA_0            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_DATA_1          0x00401024  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_DATA_1            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_RM              0x00401030  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_RM                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_XLATE_INST    0x00401040  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_XLATE_INST      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_CONTROL       0x00401044  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_CONTROL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_LIMIT         0x00401048  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_LIMIT           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_TLB_PTE       0x0040104C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_TLB_PTE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_TLB_TAG       0x00401050  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_TLB_TAG         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_ADJ_OFFSET    0x00401054  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_ADJ_OFFSET      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_OFFSET        0x00401058  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_SIZE          0x0040105C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_SIZE            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_Y_SIZE        0x00401060  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_Y_SIZE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_XLATE_INST    0x00401080  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_XLATE_INST      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_CONTROL       0x00401084  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_CONTROL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_LIMIT         0x00401088  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_LIMIT           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_TLB_PTE       0x0040108C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_TLB_PTE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_TLB_TAG       0x00401090  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_TLB_TAG         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_ADJ_OFFSET    0x00401094  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_ADJ_OFFSET      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_OFFSET        0x00401098  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_SIZE          0x0040109C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_SIZE            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_Y_SIZE        0x004010A0  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_Y_SIZE          ));
}  

void NvWatch_NV04_Dump_Fifo(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nFifo State:\r\n");
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DELAY_0              0x00002040  RW-4R  = ", REG_RD32(   NV_PFIFO_DELAY_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DMA_TIMESLICE        0x00002044  RW-4R  = ", REG_RD32(   NV_PFIFO_DMA_TIMESLICE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_PIO_TIMESLICE        0x00002048  RW-4R  = ", REG_RD32(   NV_PFIFO_PIO_TIMESLICE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_TIMESLICE            0x0000204C  RW-4R  = ", REG_RD32(   NV_PFIFO_TIMESLICE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_NEXT_CHANNEL         0x00002050  RW-4R  = ", REG_RD32(   NV_PFIFO_NEXT_CHANNEL           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DEBUG_0              0x00002080  R--4R  = ", REG_RD32(   NV_PFIFO_DEBUG_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_INTR_0               0x00002100  RW-4R  = ", REG_RD32(   NV_PFIFO_INTR_0                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_INTR_EN_0            0x00002140  RW-4R  = ", REG_RD32(   NV_PFIFO_INTR_EN_0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMHT                0x00002210  RW-4R  = ", REG_RD32(   NV_PFIFO_RAMHT                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMFC                0x00002214  RW-4R  = ", REG_RD32(   NV_PFIFO_RAMFC                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMRO                0x00002218  RW-4R  = ", REG_RD32(   NV_PFIFO_RAMRO                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHES               0x00002500  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHES                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_MODE                 0x00002504  RW-4R  = ", REG_RD32(   NV_PFIFO_MODE                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DMA                  0x00002508  RW-4R  = ", REG_RD32(   NV_PFIFO_DMA                    ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_SIZE                 0x0000250C  RW-4R  = ", REG_RD32(   NV_PFIFO_SIZE                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUSH0         0x00003000  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PUSH0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUSH0         0x00003200  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PUSH0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUSH1         0x00003004  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PUSH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUSH1         0x00003204  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PUSH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_PUSH      0x00003220  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_PUSH        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_FETCH     0x00003224  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_FETCH       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_PUT       0x00003240  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_PUT         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_GET       0x00003244  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_GET         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_STATE     0x00003228  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_STATE       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_INSTANCE  0x0000322C  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_INSTANCE    ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_CTL       0x00003230  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_CTL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_LIMIT     0x00003234  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_LIMIT       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_TLB_TAG   0x00003238  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_TLB_TAG     ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_TLB_PTE   0x0000323C  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_TLB_PTE     ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PULL0         0x00003050  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PULL0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PULL0         0x00003250  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PULL0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PULL1         0x00003054  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PULL1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PULL1         0x00003254  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PULL1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_HASH          0x00003058  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_HASH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_HASH          0x00003258  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_HASH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_STATUS        0x00003014  R--4R  = ", REG_RD32(   NV_PFIFO_CACHE0_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_STATUS        0x00003214  R--4R  = ", REG_RD32(   NV_PFIFO_CACHE1_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_STATUS1       0x00003218  R--4R  = ", REG_RD32(   NV_PFIFO_CACHE1_STATUS1         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUT           0x00003010  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUT           0x00003210  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_GET           0x00003070  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_GET             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_GET           0x00003270  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_GET             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_ENGINE        0x00003080  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_ENGINE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_ENGINE        0x00003280  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_ENGINE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_STATUS        0x00002400  R--4R  = ", REG_RD32(   NV_PFIFO_RUNOUT_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_PUT           0x00002410  RW-4R  = ", REG_RD32(   NV_PFIFO_RUNOUT_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_GET           0x00002420  RW-4R  = ", REG_RD32(   NV_PFIFO_RUNOUT_GET             ));
}

void NvWatch_NV04_Dump_Master(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nMaster Control State:\r\n");
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_BOOT_0                 0x00000000  R--4R  = ", REG_RD32(   NV_PMC_BOOT_0                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_0                 0x00000100  RW-4R  = ", REG_RD32(   NV_PMC_INTR_0                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_EN_0              0x00000140  RW-4R  = ", REG_RD32(   NV_PMC_INTR_EN_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_READ_0            0x00000160  R--4R  = ", REG_RD32(   NV_PMC_INTR_READ_0              ));
}

void NvWatch_NV04_Dump_Video(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nVideo State:\r\n");

  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_INTR_0              0x00680100  RWI4R  = ", REG_RD32(   NV_PVIDEO_INTR_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_INTR_EN_0           0x00680140  RWI4R  = ", REG_RD32(   NV_PVIDEO_INTR_EN_0             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_STEP_SIZE           0x00680200  RW-4R  = ", REG_RD32(   NV_PVIDEO_STEP_SIZE             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CONTROL_Y           0x00680204  RW-4R  = ", REG_RD32(   NV_PVIDEO_CONTROL_Y             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CONTROL_X           0x00680208  RW-4R  = ", REG_RD32(   NV_PVIDEO_CONTROL_X             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF0_START         0x0068020c  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF0_START           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF1_START         0x00680210  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF1_START           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF0_PITCH         0x00680214  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF0_PITCH           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF1_PITCH         0x00680218  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF1_PITCH           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF0_OFFSET        0x0068021c  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF0_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF1_OFFSET        0x00680220  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF1_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_OE_STATE            0x00680224  RW-4R  = ", REG_RD32(   NV_PVIDEO_OE_STATE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SU_STATE            0x00680228  RW-4R  = ", REG_RD32(   NV_PVIDEO_SU_STATE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_RM_STATE            0x0068022c  RW-4R  = ", REG_RD32(   NV_PVIDEO_RM_STATE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_WINDOW_START        0x00680230  RW-4R  = ", REG_RD32(   NV_PVIDEO_WINDOW_START          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_WINDOW_SIZE         0x00680234  RW-4R  = ", REG_RD32(   NV_PVIDEO_WINDOW_SIZE           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_FIFO_THRES          0x00680238  RW-4R  = ", REG_RD32(   NV_PVIDEO_FIFO_THRES            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_FIFO_BURST          0x0068023c  RW-4R  = ", REG_RD32(   NV_PVIDEO_FIFO_BURST            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_KEY                 0x00680240  RW-4R  = ", REG_RD32(   NV_PVIDEO_KEY                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_OVERLAY             0x00680244  RWI4R  = ", REG_RD32(   NV_PVIDEO_OVERLAY               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_RED_CSC             0x00680280  RW-4R  = ", REG_RD32(   NV_PVIDEO_RED_CSC               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_GREEN_CSC           0x00680284  RW-4R  = ", REG_RD32(   NV_PVIDEO_GREEN_CSC             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BLUE_CSC            0x00680288  RW-4R  = ", REG_RD32(   NV_PVIDEO_BLUE_CSC              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CSC_ADJUST          0x0068028c  RW-4R  = ", REG_RD32(   NV_PVIDEO_CSC_ADJUST            ));
}

U032 NvWatch_NV04_GetHashSize(PHWINFO pDev)
{
  U032 return_val;
  
  return_val = REG_RD32(NV_PFIFO_RAMHT);

  return(return_val);
}
  
void NvWatch_NV04_FillDiagStruct(PHWINFO pDev, PNVWATCHDIAGSTRUCT pdiagstruct)
{
    pdiagstruct->nv_pfifo_intr_0       =  REG_RD32(NV_PFIFO_INTR_0      );
    pdiagstruct->nv_pfifo_intr_en_0    =  REG_RD32(NV_PFIFO_INTR_EN_0   );
    pdiagstruct->nv_pfifo_caches       =  REG_RD32(NV_PFIFO_CACHES      );
    pdiagstruct->nv_pfifo_mode         =  REG_RD32(NV_PFIFO_MODE        );
    pdiagstruct->nv_pfifo_cache1_push0 =  REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    pdiagstruct->nv_pfifo_cache1_push1 =  REG_RD32(NV_PFIFO_CACHE1_PUSH1);
    pdiagstruct->nv_pfifo_cache1_pull0 =  REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pdiagstruct->nv_pfifo_dma_put      =  REG_RD32(NV_PFIFO_CACHE1_PUT  );
    pdiagstruct->nv_pfifo_dma_get      =  REG_RD32(NV_PFIFO_CACHE1_GET  );
    pdiagstruct->nv_pmc_intr_0         =  REG_RD32(NV_PMC_INTR_0        );
    pdiagstruct->nv_pmc_intr_en_0      =  REG_RD32(NV_PMC_INTR_EN_0     );
    pdiagstruct->nv_pmc_intr_read_0    =  REG_RD32(NV_PMC_INTR_READ_0   );
    pdiagstruct->nv_pmc_enable         =  REG_RD32(NV_PMC_ENABLE        );

}

void NvWatch_NV04_DumpGrTableContents(PHWINFO pDev, U032 verbose_flag)
{
    PHALHWINFO pHalHwInfo = &pDev->halHwInfo;
    PGRHALINFO_NV04 pGrHalInfo;
    PFIFOHALINFO_NV04 pFifoHalInfo;
    U032 ChID;
    U032 i;

    pHalHwInfo = &pDev->halHwInfo;
    pGrHalInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalInfo;
    pFifoHalInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalInfo;

    for(ChID=0;ChID<NUM_FIFOS;ChID++){
        if (pFifoHalInfo->InUse & (1 << ChID))
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\ngrTable dump of channel ", ChID);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch1 = ", pGrHalInfo->grChannels[ChID].ContextSwitch1);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch2 = ", pGrHalInfo->grChannels[ChID].ContextSwitch2);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch3 = ", pGrHalInfo->grChannels[ChID].ContextSwitch3);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch4 = ", pGrHalInfo->grChannels[ChID].ContextSwitch4);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch5 = ", pGrHalInfo->grChannels[ChID].ContextSwitch5);
      
        for (i = 0; i < 8; i++)
        {    
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Cached Context data for subchannel ", i);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache0 = ", pGrHalInfo->grChannels[ChID].ContextCache1[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache1 = ", pGrHalInfo->grChannels[ChID].ContextCache2[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache2 = ", pGrHalInfo->grChannels[ChID].ContextCache3[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache3 = ", pGrHalInfo->grChannels[ChID].ContextCache4[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache4 = ", pGrHalInfo->grChannels[ChID].ContextCache5[i]);
        }

        if(verbose_flag == NVWATCH_COMPLEX){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].ContextUser = ",          pGrHalInfo->grChannels[ChID].ContextUser       );                 

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaStart0 = ",        pGrHalInfo->grChannels[ChID].DmaStart0             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaStart1 = ",        pGrHalInfo->grChannels[ChID].DmaStart1             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaLength = ",        pGrHalInfo->grChannels[ChID].DmaLength             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaMisc   = ",        pGrHalInfo->grChannels[ChID].DmaMisc               );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaPitch  = ",        pGrHalInfo->grChannels[ChID].DmaPitch              );             

            for (i = 0; i < 6; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferOffset[i]  = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferOffset[i]   );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferBase[i]    = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferBase[i]     );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferLimit[i]   = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferLimit[i]    );
            }
            for (i = 0; i < 5; i++)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPitch[i] = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPitch[i]      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Surface           = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.Surface               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.State             = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.State                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[0]  = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[0]      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[1]  = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[1]      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPixel       = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPixel           );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Notify            = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.Notify                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor0     = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor1     = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor1         );

            for (i = 0; i < 64; i++)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColorRam[i]  = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColorRam[i]);

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[0]         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[0]            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[1]         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[1]            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternShape       = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.PatternShape          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.MonoColor0         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.MonoColor0            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Rop3               = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Rop3                  );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Chroma             = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Chroma                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BetaAnd            = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BetaAnd               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BetaPremult        = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BetaPremult           );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control0           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control0              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control1           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control1              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control2           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control2              );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Blend              = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Blend                 );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.StoredFmt            = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.StoredFmt             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.SourceColor          = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.SourceColor           );

            for (i = 0; i < 32; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsXRam[i]       = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.AbsXRam[i]        );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsYRam[i]       = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.AbsYRam[i]        );
            }

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMin        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMin          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMax          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMin        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMin          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMax          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMin       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMin         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMax       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMax         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMin       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMin         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMax       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMax         );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipXMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipXMax          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipYMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipYMax          );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc0        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc0          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc1        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc1          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc2        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc2          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc3        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc3          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY1                );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Alpha       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Alpha      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Alpha       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Alpha      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Color       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Color      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Color       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Color      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Format0             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Format0               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Format1             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Format1               );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Filter0             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Filter0               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Filter1             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Filter1               );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_XY              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_XY                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_U0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_U0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_V0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_V0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_U1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_U1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_V1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_V1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_ZETA            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_ZETA              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_RGB             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_RGB               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_S               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_S                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_M               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_M                 );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru0           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru0             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru1           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru1             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru2           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru2             );


            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.DVDColorFormat      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.DVDColorFormat        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ScaledFormat        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ScaledFormat          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_0            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_0              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_1            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_1              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_2            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_2              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XMisc               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XMisc                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.YMisc               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.YMisc                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Valid1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Valid1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Valid2              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Valid2                );
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\serial.c ===
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>
#include <configmg.h>
#include <vcomm.h>
#include <nvtypes.h>
#include <osdbg.h>
#include <serial.h>

#ifdef DEBUG

//
// Baud Rate Stuff
//
NvU32 dbgBaudRateTable[] = {
   1200, 96,
   2400, 48,
   3600, 32,
   4800, 24,
   7200, 16,
   9600, 12,
   19200, 6,
   38400, 3,
   57600, 2,
   115200, 1,
   230400, 32770,
   460800, 32769,
};

//
// PIO Offset
//
#define DBG_USE_COM_PORT_1 (0)
#define DBG_USE_COM_PORT_2 (1)
NvU16 dbgComPortTable[]={DBG_COM1_PORT, DBG_COM2_PORT};

DBGPORT DbgPort = {
   DBG_OBJECT_SERIAL, DBG_USE_COM_PORT_1, 115200,
   };

//
// Simple BaudRate Lookup Table Function
//
NvU16 dbgBaudRate(NvU32 uBaudRate)
{
   NvS32 i;
   NvU16 uReturn = 0x0c;
   
   for (i=0; i<sizeof(dbgBaudRateTable)/sizeof(NvU32); i+=2)
      {
      if (uBaudRate == dbgBaudRateTable[i])
         {
         uReturn = (NvU16)dbgBaudRateTable[i+1];
         break;
         }
      }

   return uReturn;
}


//
// Simple Init Serial Function
//
NvU32 nFirst=TRUE;
NvU16 dbgComPort = DBG_COM1_PORT;
NvU16 uBaudRate;
//
//  This is a cheap hack to fix a problem with hibernation
//  when we go into hibernation Serenum is called to reenum
//  the serial port and change it's baud rate
//  We check for this condition here
//
void ChkBaudRate(void)
{
   NvU16 ChkRate;

   //Make sure that we have the right baud rate
   // sometimes on returns from hibernation Serenum resets us to 9600 baud.. yuch
   // this is a quick check
   if (0x03 != (INB((NvU16)(dbgComPort+LCR_OFFSET))))
      {
      _asm {int 03};
		dbgInitSerial(&DbgPort);
      }
   else
      {

      // this is a long slow check but a bit more intensive
      // make sure baud rate is right
      OUTB((NvU16)(dbgComPort+LCR_OFFSET), 0x83);
      ChkRate = INB((NvU16)(dbgComPort+DHI_OFFSET));
      ChkRate = (ChkRate<<8) | INB((NvU16)(dbgComPort+DLOW_OFFSET));
      if (uBaudRate != ChkRate)
         {
         _asm {int 03};
   		dbgInitSerial(&DbgPort);
         }
      OUTB((NvU16)(dbgComPort+LCR_OFFSET), 0x03);
      }

}

VOID dbgInitSerial(PDBGPORT pDbgPort)
{
   WIN32DCB DCB;
   DWORD ulLength;
   extern DEVNODE dbgDevNode;

   uBaudRate = dbgBaudRate(pDbgPort->uTag.Serial.uBaud);

   // First Time do an enable
   if (nFirst)
      {
      dbgEnableDevice(pDbgPort->uTag.Serial.uPort);
      nFirst=FALSE;
      }

   dbgComPort = dbgComPortTable[pDbgPort->uTag.Serial.uPort];

   //
   //  Default is 8,n,1
   //
   OUTB((NvU16)(dbgComPort+ICR_OFFSET), 0x0);
   OUTB((NvU16)(dbgComPort+FIFO_OFFSET), 0x07);
   OUTB((NvU16)(dbgComPort+LCR_OFFSET), 0x83);
   OUTB((NvU16)(dbgComPort+DLOW_OFFSET), (NvU8)(uBaudRate & 0xFF));
   OUTB((NvU16)(dbgComPort+DHI_OFFSET), (NvU8)(uBaudRate>>8));
   OUTB((NvU16)(dbgComPort+LCR_OFFSET), 0x03);
   OUTB((NvU16)(dbgComPort+MCR_OFFSET), 0x0);
   OUTB((NvU16)(dbgComPort+SPARE_OFFSET), 0xAA);

   //
   // hack#9
   // we are in a fight with VCOMM for control of the serial port
   // when we input the baud, etc, they will try and change it.
   // we need to fix this here
   //
   ulLength = sizeof(DCB);
   if (CR_SUCCESS == CMxx_Read_Registry_Value(dbgDevNode, NULL, "DCB", REG_BINARY, &DCB, &ulLength, CM_REGISTRY_SOFTWARE))
      {
      // Ditto 8,n,1
      DCB.BaudRate = pDbgPort->uTag.Serial.uBaud;
      DCB.fFlags &= ~(DBG_FFLAGS_PARITY);
      DCB.ByteSize = 8;
      DCB.Parity = 0x0;
      DCB.StopBits = 0x0;
      CMxx_Write_Registry_Value(dbgDevNode, NULL, "DCB", REG_BINARY, &DCB, ulLength, CM_REGISTRY_SOFTWARE);
      } 

}


//
// Simple Poll Method to transmit string
// This is simple so the message is not lost if IRQ were used
//
VOID dbgDisplaySerial(PSTR pStr)
{
   NvU32 dbgCurrentState;
   NvU32 ulStateChange;
   extern NvU32 IsConfig98;
   extern NvU32 dbgPowerSysState;
   extern DEVNODE dbgDevNode;


   // If we are in a low power mode then turn the serial port on
   ulStateChange = FALSE;
   if (dbgPowerSysState)
      {
      if (IsConfig98)
         {
         if (CR_SUCCESS == CMxx_Get_DevNode_PowerState(dbgDevNode, &dbgCurrentState, 0x0))
            {
            if (CM_POWERSTATE_D0 != dbgCurrentState)
               {
               ulStateChange = TRUE;
               // Power On
               CMxx_Set_DevNode_PowerState(dbgDevNode, CM_POWERSTATE_D0, 0x0);
               // Initialize
               }
            dbgInitSerial(&DbgPort);
            }
         }
      }

   // Check to make sure baudrate is right
   ChkBaudRate();

	for (;*pStr!='\0'; pStr++)
      {
      while (0x20 != (INB((NvU16)(dbgComPort+LSR_OFFSET))&0x20))
         ;
      OUTB((NvU16)(dbgComPort+DATA_OFFSET), *pStr);
      if (0x0A == *pStr)
          {
          while (0x20 != (INB((NvU16)(dbgComPort+LSR_OFFSET))&0x20))
            ;
          OUTB((NvU16)(dbgComPort+DATA_OFFSET), 0x0D);
          }
      }

   // Turn if off if we are not going to D0
   if (dbgPowerSysState)
      {
      if (IsConfig98)
         {
         if (1 == dbgPowerSysState)
            {
            if (ulStateChange)
               CMxx_Set_DevNode_PowerState(dbgDevNode, dbgCurrentState, 0x0);
            }
         else
            {
            dbgPowerSysState = 0x0;
            dbgEnableDevice2(&DbgPort);
            }
         }
      }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\inc\OS.H ===
#ifndef _OS_H_
#define _OS_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.H                                                              *
*       Operating system wrapper functions used to abstract the OS.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    06/22/94 - rewrote it.                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Debug macros.
//
//---------------------------------------------------------------------------

// debug module, levels, and defines
#include <nv_dbg.h>

#ifdef DEBUG

/*
#pragma warning(disable:4311)   // allow type cast truncation
#pragma warning(disable:4242)   // allow 
#pragma warning(disable:4244)   // allow 
#pragma warning(disable:4047)   // allow 
*/

extern int cur_debuglevel;

#endif // DEBUG

// registry path for RM AGP lookups
#define RM_REGISTRY_AGP_BASE_PATH    strDevNodeRM

#ifndef toupper
#define toupper(c)  (((c)>='a'&&(c)<='z')?((c)-'a'+'A'):(c))
#endif

// data types necessary for accessing binary registry data
// this seems to be what we get back on REG_BINARY -- couldn't find it documented tho
typedef struct
{
    U032 Length;
    U032 type;
    U008 buffer[1];
    
} RM_REG_BINARY_RECORD;
typedef union
{
    RM_REG_BINARY_RECORD record;
    U008 buffer[256];
    
} RM_REG_BINARY_BUFFER;

/* polymorphic 64-bit macros */
#ifdef IA64
typedef NvU64 SIZE_PTR; 
#else
typedef NvU32 SIZE_PTR;
#endif // IA64

#define PHYSICAL_ADDRESS_VALUE(p) ((p).LowPart)

typedef struct _def_winnt_hw_info
{
	U016	filler1;
	U008	filler2;

	U008	oldIrql;
	BOOL	rmInitialized;		// per device init flag
	VOID*	pRmSpinLock;
	VOID*	AgpServices;		// win2k's AGP services func ptrs
	VOID*	dmaAdapter;			// PVP_DMA_ADAPTER for 64 bit systems

} WINNTHWINFO, *PWINNTHWINFO;

// System memory allocation tracking

typedef struct _def_sys_mem_info
{
    NvU64   physAddr;           // aligned adaper address
    VOID*   pMdl;               // MDL for user mapping
    VOID*   sysAddr;            // original, potentially unaligned address
    NvU64   logicalAddr;        // address to be used by adapter
    NvU32   length;             // actual number of bytes allocated
    NvU32   clientClass;        // NV01_ROOT_USER or NV01_ROOT
} SYS_MEM_INFO, *PSYS_MEM_INFO;

//---------------------------------------------------------------------------
//
//  Function prototypes for OS interface.
//
//---------------------------------------------------------------------------

// macro to allow different syntax between NT and Win9x
#define OS_READ_REGISTRY_DWORD(pDev, a, b, c) osReadRegistryDword(pDev, a, b, c)

RM_STATUS	osCopyIn				(U008 *src, U008 *target, U032 count);
RM_STATUS	osCopyOut				(U008 *src, U008 *target, U032 count);
RM_STATUS	osAllocMem				(VOID **, U032);
RM_STATUS	osFreeMem				(VOID *);
RM_STATUS	osAllocPages			(PHWINFO, VOID **, U032, U032, U032, U032, U032, VOID **);
RM_STATUS	osFreePages				(PHWINFO, VOID **, U032, U032, VOID *, BOOL);
RM_STATUS   osAllocSystemPages      (PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS   osFreeSystemPages       (PHWINFO, VOID **, VOID *);
RM_STATUS   osAllocAGPPages         (PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS   osFreeAGPPages          (PHWINFO, VOID **, VOID *);
RM_STATUS	osAllocDmaListElement	(PDMAUSEROBJECT*);
RM_STATUS	osFreeDmaListElement	(PDMAUSEROBJECT);
RM_STATUS   osVirtualToPhysicalAddr (VOID*, VOID**);
RM_STATUS   osCalculatePteAdjust    (PHWINFO, U032, VOID*, U032*);
RM_STATUS	osGetAddressInfo		(PHWINFO, U032, U032, VOID**, U032, VOID**, U032 *);
RM_STATUS	osLockUserMem			(PHWINFO, U032, U032, VOID*, VOID*, U032 *, U032, U032, U032 *, VOID**, VOID**);
RM_STATUS	osUnlockUserMem			(PHWINFO, U032, VOID*, VOID*, U032, U032, U032, VOID*, U032);
RM_STATUS	osGetCurrentTime		(U032 *, U032 *, U032 *, U032 *, U032 *, U032 *, U032 *);
RM_STATUS	osError					(POBJECT, U032, V032, RM_STATUS);
RM_STATUS	osDelay					(U032);
RM_STATUS   osDelayUs               (U032);
RM_STATUS	osRedrawScreen			(VOID);
RM_STATUS	osBeginWatchCanvas		(U032);
RM_STATUS	osEndWatchCanvas		(U032);
RM_STATUS	osValidateVideoSink		(char *);
RM_STATUS	osValidateImageVideo	(char *, U032 *);
RM_STATUS	osValidateDMAObject		(char *, U032, U032 *);
char*    	osStringCopy			(char *, const char *);
U032    	osStringLength			(const char *);
unsigned char * osMemCopy			(unsigned char *, const unsigned char *, U032);
RM_STATUS	osMapPciMemoryUser		(PHWINFO, U032, U032, VOID**);
RM_STATUS	osUnmapPciMemoryUser	(PHWINFO, VOID*);
RM_STATUS  	osMapFrameBuffer		(PHWINFO, U032, U032, U032, VOID **);
RM_STATUS  	osMapInstanceMemory		(PHWINFO, U032, U032, U032, VOID **);
RM_STATUS  	osMapFifo				(PHWINFO, U032, U032, VOID **);
RM_STATUS  	osUnmapMemory			(PHWINFO, U032, VOID *, U032);
RM_STATUS   osSetFifoDmaParams      (PHWINFO, U032 *, U032 *, U032 *);
S032     	osStringCompare			(const char *, const char *);
RM_STATUS	osGetCurrentProcess		(U032*);
VOID     	osWriteReg008			(volatile V008*, V008);
VOID     	osWriteReg016			(volatile V016*, V016);
VOID     	osWriteReg032			(volatile V032*, V032);
U008     	osReadReg008			(volatile V008*);
U016     	osReadReg016			(volatile V016*);
U032     	osReadReg032			(volatile V032*);
RM_STATUS	osReadRegistryDword		(PHWINFO, char *, char *, U032 *);
RM_STATUS	osWriteRegistryDword	(PHWINFO, char*, char*, U032);
RM_STATUS	osReadRegistryString	(char*, char*, char*str, U032 *);
RM_STATUS	osWriteRegistryString	(char*, char*, char* str, U032);
RM_STATUS	osReadRegistryBinary	(PHWINFO, char*, char*, U008*, U032 *);
RM_STATUS	osWriteRegistryBinary	(PHWINFO, char*, char*, U008*, U032);
RM_STATUS	osDeviceNameToDeviceClass(char*, U032*);
U032     	osGetCpuFrequency		(VOID);
U032        osPciReadDword          (VOID*, U032);
U016        osPciReadWord           (VOID*, U032);
U008        osPciReadByte           (VOID*, U032);
VOID        osPciWriteDword         (VOID*, U032, U032);
VOID        osPciWriteWord          (VOID*, U032, U016);
VOID        osPciWriteByte          (VOID*, U032, U008);
VOID*       osPciInitHandle         (U008, U008, U008, U016*, U016*);
RM_STATUS	osUpdateAGPLimit		(PHWINFO);

RM_STATUS   osIsr                   (PHWINFO);
RM_STATUS   osMemSet                (VOID *, U032, U032);
RM_STATUS   osCallVideoBIOS         (PHWINFO, U032*, U032*, U032*, U032*, VOID*);

// Win2K interrupt handling
#if (_WIN32_WINNT >= 0x0500)
VOID        RmDpcForIsr             (VOID*, VOID*);
#endif

// Win2K processor synchronization
#if (_WIN32_WINNT >= 0x0500)

RM_STATUS   osInitSpinLock          (PHWINFO);
RM_STATUS   osEnterCriticalCode     (PHWINFO);
RM_STATUS   osExitCriticalCode      (PHWINFO);
RM_STATUS   osDldLinkImg            (VOID *);
RM_STATUS   osDldUnlinkImg          (VOID *);
#else

// define away Win2K only macros
#define osInitSpinLock(p) RM_OK
#define osEnterCriticalCode(p)
#define osExitCriticalCode(p)
#define osDldLinkImg(p) RM_ERROR
#define osDldUnlinkImg(p) RM_ERROR

#endif

#if defined(_WIN64)

RM_STATUS   osInitDmaAdapter        (PHWINFO);

#else

#define osInitDmaAdapter(p)         RM_OK

#endif

#define    osDisableHardwareInterrupts(pDev)    osEnterCriticalCode(pDev)
#define    osEnableHardwareInterrupts(pDev)     osExitCriticalCode(pDev)

// Define away win9x only functions
#define  	osEnsureDeviceEnabled(pDev) 
#define		osExit(s)				osDbgPrintStr("NVRM: "); osDbgPrintStr((s)); osDbgPrintStr("\n"); return RM_ERROR	
#define  	osStateEx(pDev, msg)
#define  	osStateDacEx(pDev, msg)
#define     osDisplayModeHook(pDev, msg)
#define     osmpCheckCallbacks(pDev, dwCallbackSelect)
#define     osPreModeSet(pDev, head)
#define     osPostModeSet(pDev, head)

#define     osFlushCpuCache(p) ((VOID)0)

// define away mac-only macros
#define osReadRegistryBoolean(a,b,c)    1

extern BOOL dacMonitorConnectStatus(PHWINFO, U032);
extern BOOL dacFlatPanelConnectStatus(PHWINFO, U032);
VOID        osPostModeSetEx         (PHWINFO, U032);
VOID        osPreModeSetEx          (PHWINFO, U032);

#define     OEMEnableExtensions()
#define     OEMDisableExtensions()

VOID		osLogInstMemAlloc		(U032, U032, U032);
VOID		osUnlogInstMemAlloc		(U032, U032);

// functions needed for nvagp
/* remap IO memory to kernel space */
void *osMapKernelSpace(unsigned int start, unsigned int size_bytes, U008 mode);
void osUnmapKernelSpace(void *addr, unsigned int size_bytes);

/* remap memory to user space */
void *osMapUserSpace(void *kaddr, void **priv, unsigned int size_bytes, U008 mode);
void osUnmapUserSpace(void *uaddr, void *priv);

/* remap memory to user space */
void *osMapIOSpace(U032 start, U032 size_bytes, void **priv, U008 mode);
void osUnmapIOSpace(void *addr, U032 size_bytes, void *priv, U008 mode);

/* set physical memory range attributes (like write combining) */
RM_STATUS osSetMemRange(U032 start, U032 size_bytes, U008 mode);

// like osAllocMem, but no debugging info written into pages
RM_STATUS osAllocPool(void **addr, unsigned int size_bytes);
RM_STATUS osFreePool(void *addr);

void *osAllocContigPages(unsigned long num_pages);
void osFreeContigPages(void *addr); 
U032 osGetKernPhysAddr(void *kern_virt_addr);
RM_STATUS osGetAGPPhysAddr(PHWINFO pDev, VOID *base, U032 index, U032 *paddr);


// these are in modehw.h which is in the miniport
VOID WriteIndexed(U032 addr, U016 datum);
U016 ReadIndexed(U032 addr, U008 reg);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WritePriv08(U032 addr, U008 datum);

VOID		osStateFbEx				(PHWINFO);
RM_STATUS	osSetVideoMode			(PHWINFO);
RM_STATUS	osNotifyEvent			(PHWINFO, POBJECT, U032, U032, U032, RM_STATUS, U032);
RM_STATUS 	initMapping				(PHWINFO);
RM_STATUS 	initFbEx				(PHWINFO);
RM_STATUS 	initFifoEx				(PHWINFO);
RM_STATUS 	initGrEx				(PHWINFO);
RM_STATUS 	initDacEx				(PHWINFO);
RM_STATUS 	initCodecEx				(PHWINFO);
BOOL        RmInitAGP               (PHWINFO);
VOID        NvUpdateAGPConfig       (PHWINFO);
RM_STATUS   NvGetAGPBaseLimit       (PHWINFO, U032 *, U032 *);

#define PENDING_INTERRUPTS \
    (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)|DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))

VOID		RmEnableInterrupts		(PHWINFO);
VOID		RmDisableInterrupts		(PHWINFO);
BOOL		RmInterruptPending		(PHWINFO, BOOL*);

#if DBG
VOID osLogMemAlloc(VOID *address, U032 size);
VOID osUnlogMemAlloc(VOID *address);
#endif // DBG

//---------------------------------------------------------------------------
//
//  Required defines for OS interface.
//
//---------------------------------------------------------------------------

#define NV_MEMORY_TYPE_SYSTEM       0
#define NV_MEMORY_TYPE_AGP          1

#define NV_MEMORY_NONCONTIGUOUS     0
#define NV_MEMORY_CONTIGUOUS        1

#define NV_MEMORY_DEFAULT           0
#define NV_MEMORY_UNCACHED          1
#define NV_MEMORY_WRITECOMBINED     2
#define NV_MEMORY_WRITETHRU         3
#define NV_MEMORY_WRITEPROTECT      4
#define NV_MEMORY_WRITEBACK         5

/////////////////////////////////
#define DPC_IMPLEMENTATION 1
/////////////////////////////////


typedef struct
{
    U016  HdrSize;
    U016  InfoFlags;
    U032  DevNodeHandle;
    U008  DriverName[16];
    U016  XRes;
    U016  YRes;
    U016  DPI;
    U008  Planes;
    U008  Bpp;
    U016  RefreshRateMax;
    U016  RefreshRateMin;
    U016  LowHorz;
    U016  HighHorz;
    U016  LowVert;
    U016  HighVert;
    U032  MonitorDevNodeHandle;
    U008  HorzSyncPolarity;
    U008  VertSyncPolarity;
} DISPLAYINFO, *PDISPLAYINFO;

// DMA list element pool
#define DMALISTELEMENT_POOL_SIZE 16
typedef struct
{
	BOOL inUse;
	DMAUSEROBJECT dmaListElement;

} DMALISTELEMENT_POOL_ELEMENT, *PDMALISTELEMENT_POOL_ELEMENT;

// more globals
extern DISPLAYINFO osDisplayInfo;
extern PDMALISTELEMENT_POOL_ELEMENT dmaListElementPool;


// NT callbacks...

// notify callback action
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

// This is callback function in the miniport.
// The argument is a device extension, and must be cast as such to be useful.
typedef VOID (*MINIPORT_CALLBACK)(VOID*);


// memory allocation
#define NV_MEMORY_TAG '  VN'

// AGP macros
#define BYTES_MAPPED_PER_PAGE   ((RM_PAGE_SIZE >> 2) * RM_PAGE_SIZE)

// Arguments to osMapIOSpace and friends

#define MAP_UNCACHED       0x0
#define MAP_CACHED         0x1
#define MAP_WRITECOMBINE   0x2
#define	MAP_KERNEL         0x0
#define	MAP_USER           0x4

// Arguments to osSetMemSpace

#define MEM_WRITECOMBINE   0x0

#if (_WIN32_WINNT < 0x500) && defined(NTRM)
extern VOID SignalModeSwitchEvent();
VOID RmSignalHotKeyEvent();
#endif

#endif // _OS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\inc\NVHW.H ===
#ifndef _NVHW_H_
#define _NVHW_H_
/**************************************************************************************************************
*
*	Module:  nvhw.h
*
*	Description:
*		Hardware access macros for the resource manager.
*
*
*	Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.   
*	                                                                 
*	NOTICE TO USER:   The source code  is copyrighted under  U.S. and
*	international laws.   NVIDIA, Corp. of Sunnyvale, California owns
*	the copyright  and as design patents  pending  on the design  and
*	interface  of the NV chips.   Users and possessors of this source
*	code are hereby granted  a nonexclusive,  royalty-free  copyright
*	and  design  patent license  to use this code  in individual  and
*	commercial software.                                             
*	                                                                 
*	Any use of this source code must include,  in the user documenta-
*	tion and  internal comments to the code,  notices to the end user
*	as follows:                                                      
*	                                                                 
*	Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents
*	pending in the U.S. and foreign countries.                       
*	                                                                 
*	NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF
*	THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT
*	EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS
*	ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL
*	IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A
*	PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE
*	FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,
*	OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR
*	PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER
*	TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR
*	PERFORMANCE OF THIS SOURCE CODE.                                 
*                                                                      
*************************************************************************************************************/

/*
	The REG_WR..() and REG_RD..() macros are used to access the NV registers.
	Actual address are passed in then scaled to the correct size of access,
	so no prescaling is necessary.  Just use the register address defined
	in the reference manuals, e.g. nv.._ref.h.
*/
#define REG_WR08(a,d)   (osWriteReg008((U008*)&nvAddr->Reg008[(a)  ], (U008)(d)))
#define REG_WR16(a,d)   (osWriteReg016((U016*)&nvAddr->Reg016[(a)/2], (U016)(d)))
#define REG_WR32(a,d)   (osWriteReg032((U032*)&nvAddr->Reg032[(a)/4], (U032)(d)))
#define REG_RD08(a)     (osReadReg008 ((U008*)&nvAddr->Reg008[(a)  ])			)
#define REG_RD16(a)     (osReadReg016 ((U016*)&nvAddr->Reg016[(a)/2])			)
#define REG_RD32(a)     (osReadReg032 ((U032*)&nvAddr->Reg032[(a)/4])			)

/*
	The REG_WR..DIRECT() and REG_RD..DIRECT() macros are used to access the NV 
    registers given as system addresses.  System addresses of the registers
    are passed in.  A read is made directly from that address, without manipulation. 
*/
#define REG_WR08_DIRECT(a,d)   (osWriteReg008((a), (d)))
#define REG_WR16_DIRECT(a,d)   (osWriteReg016((a), (d)))
#define REG_WR32_DIRECT(a,d)   (osWriteReg032((a), (d)))
#define REG_RD08_DIRECT(a)     (osReadReg008 ((a)     ))
#define REG_RD16_DIRECT(a)     (osReadReg016 ((a)     ))
#define REG_RD32_DIRECT(a)     (osReadReg032 ((a)     ))

/*
	The MEM_WR..() and MEM_RD..() macros are used to access the frame buffer
	memory.  Actual addresses are passed in then scaled to the correct size of
	access, so no prescaling is necessary.  Just use the actual byte address
	of the frame buffer that needs to be accessed.  

	Note:  For NV3, these macros are used to access instance memory directly.
	So, passing in a 0 would access the first location of instance memory, 
	which is at the end of the frame buffer, i.e. at an offset of NV_PRAMIN
	from the beginning of the frame buffer.
*/

// frame buffer access macros
// for NV4 and above, fbAddr actually points to the frame buffer
#define MEM_BASE		(0)
#define MEM_WR08(a,d)   (osWriteReg008((U008*)&fbAddr->Reg008[((a)-MEM_BASE)  ], (U008)(d)))
#define MEM_WR16(a,d)   (osWriteReg016((U016*)&fbAddr->Reg016[((a)-MEM_BASE)/2], (U016)(d)))
#define MEM_WR32(a,d)   (osWriteReg032((U032*)&fbAddr->Reg032[((a)-MEM_BASE)/4], (U032)(d)))
#define MEM_RD08(a)     (osReadReg008 ((U008*)&fbAddr->Reg008[((a)-MEM_BASE)  ])		   )
#define MEM_RD16(a)     (osReadReg016 ((U016*)&fbAddr->Reg016[((a)-MEM_BASE)/2])		   )
#define MEM_RD32(a)     (osReadReg032 ((U032*)&fbAddr->Reg032[((a)-MEM_BASE)/4])		   )

#define FB_WR08(a,d)   (osWriteReg008((U008*)&fbAddr->Reg008[(a)  ], (U008)(d)))
#define FB_WR16(a,d)   (osWriteReg016((U016*)&fbAddr->Reg016[(a)/2], (U016)(d)))
#define FB_WR32(a,d)   (osWriteReg032((U032*)&fbAddr->Reg032[(a)/4], (U032)(d)))
#define FB_RD08(a)     (osReadReg008 ((U008*)&fbAddr->Reg008[(a)  ])		   )
#define FB_RD16(a)     (osReadReg016 ((U016*)&fbAddr->Reg016[(a)/2])		   )
#define FB_RD32(a)     (osReadReg032 ((U032*)&fbAddr->Reg032[(a)/4])		   )

/*
	The ROM_RD..() and BIOS_RD..() macros are used to read data from the BIOS, an image of 
	which resides in the first 64K of instance memory.
*/

// ROM access macros
#define ROM_RD08(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])    ))
#define ROM_RD16(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])	  )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+1])<<8 ))
#define ROM_RD32(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])    )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+1])<<8 )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+2])<<16)\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+3])<<24))

// BIOS access macros
#define BIOS_RD08(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])    ))
#define BIOS_RD16(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])	  )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+1])<<8 ))
#define BIOS_RD32(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])    )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+1])<<8 )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+2])<<16)\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+3])<<24))

#endif // _NVHW_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osapi.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************************************************************
*
*   File: osapi.c
*
*   Description:
*       This file contains the resource manager API for the NT miniport.  It
*   provides services to the miniport that directly access the device.
*
******************************************************************************/

#include <ntddk.h>
#include <nvrm.h>
#include <nvhw.h>
#include <os.h>

BOOL RmLoadState
(
	U032 deviceReference,
    U032 horizWidth,
    U032 vertWidth,
    U032 bitDepth,
    U032 refreshRate,
    BOOL vgaEnabled
)
{
    RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

	// allow hi res modes to happen
    // This value should be FALSE after a SetMode has occurred
    // This value should be TRUE when restoring from Hibernation (in VGA mode)
	pDev->Vga.Enabled = vgaEnabled;

	// transfer the arguments from the client into RM global state
	pDev->Dac.HalInfo.Depth 		    = bitDepth;
	pDev->Framebuffer.HalInfo.RefreshRate 	     = refreshRate;
    pDev->Framebuffer.HalInfo.HorizDisplayWidth  = horizWidth;
    pDev->Framebuffer.HalInfo.VertDisplayWidth   = vertWidth;

	// reload the state based on the new display mode
    rmStatus = stateNv(pDev, STATE_LOAD);
    
    return (rmStatus == RM_OK) ? TRUE : FALSE;
                        
} // end of RmLoadState()

BOOL RmUnloadState
(
	U032 deviceReference
)
{
    RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

	// unload the state
    rmStatus = stateNv(pDev, STATE_UNLOAD);
    
    return (rmStatus == RM_OK) ? TRUE : FALSE;
            
} // end of RmUnloadState()


BOOL RmUpdateAGPConfig
(
	U032 deviceReference
)
{
    RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    NvUpdateAGPConfig(pDev);
        
    return (rmStatus == RM_OK) ? TRUE : FALSE;
            
} // end of RmUnloadState()


BOOL RmSetMode
(
	U032 deviceReference,
	U032 HorizontalVisible,
	U032 HorizontalBlankStart,
	U032 HorizontalRetraceStart,
	U032 HorizontalRetraceEnd,
	U032 HorizontalBlankEnd,
	U032 HorizontalTotal,
	U032 VerticalVisible,
	U032 VerticalBlankStart,
	U032 VerticalRetraceStart,
	U032 VerticalRetraceEnd,
	U032 VerticalBlankEnd,
	U032 VerticalTotal,
    U032 PixelDepth,
    U032 RefreshRate,
    U032 Width,
    U032 Height,
	U032 PixelClock,
	U032 HorizontalSyncPolarity,
	U032 VerticalSyncPolarity,
	U032 DoubleScannedMode     
)
{
    VIDEO_LUT_CURSOR_DAC_OBJECT DacObj;
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // unload the state
    rmStatus = stateDac(pDev, STATE_UNLOAD);
    if (rmStatus == RM_OK)
    {
        // set the VESA parameters in the device context
        DacObj.HalObject.Dac[0].VisibleImageWidth = HorizontalVisible;
        DacObj.HalObject.Dac[0].HorizontalBlankStart = HorizontalBlankStart;
        DacObj.HalObject.Dac[0].HorizontalSyncStart = HorizontalRetraceStart;
        DacObj.HalObject.Dac[0].HorizontalSyncWidth = HorizontalRetraceEnd - HorizontalRetraceStart;
        DacObj.HalObject.Dac[0].HorizontalBlankWidth = HorizontalBlankEnd - HorizontalBlankStart;
        DacObj.HalObject.Dac[0].TotalWidth = HorizontalTotal;
        DacObj.HalObject.Dac[0].VisibleImageHeight = VerticalVisible;
        DacObj.HalObject.Dac[0].VerticalBlankStart = VerticalBlankStart;
        DacObj.HalObject.Dac[0].VerticalSyncStart = VerticalRetraceStart;
        DacObj.HalObject.Dac[0].VerticalSyncHeight = VerticalRetraceEnd - VerticalRetraceStart;
        DacObj.HalObject.Dac[0].VerticalBlankHeight = VerticalBlankEnd - VerticalBlankStart;
        DacObj.HalObject.Dac[0].TotalHeight = VerticalTotal;
        DacObj.HalObject.Dac[0].PixelDepth = PixelDepth;
        DacObj.HalObject.Dac[0].PixelClock = PixelClock;
        DacObj.HalObject.Dac[0].Format.HorizontalSyncPolarity = HorizontalSyncPolarity;
        DacObj.HalObject.Dac[0].Format.VerticalSyncPolarity = VerticalSyncPolarity;
        DacObj.HalObject.Dac[0].Format.DoubleScanMode = DoubleScannedMode;
        DacObj.HalObject.Head = 0;
        DacObj.DisplayType = GETDISPLAYTYPE(pDev, 0);

        // Set image parameters.
        DacObj.Image[0].Offset = 0;
        DacObj.Image[0].Pitch = Width * (PixelDepth >> 3);

        // reload the state -- this will reset the mode
        pDev->Vga.Enabled = FALSE;

        // transfer the arguments from the client into RM global state
        pDev->Dac.HalInfo.Depth             = PixelDepth;
        pDev->Framebuffer.HalInfo.RefreshRate        = RefreshRate;
        pDev->Framebuffer.HalInfo.HorizDisplayWidth  = Width;
        pDev->Framebuffer.HalInfo.VertDisplayWidth   = Height;

        rmStatus = stateDac(pDev, STATE_LOAD);
        if (rmStatus == RM_OK)
        {
            rmStatus = dacSetModeMulti(pDev, &DacObj);
        }
    } 

    return (rmStatus == RM_OK) ? TRUE : FALSE;  
                        
} // end of RmSetMode()

BOOL RmIsr
(
	U032 deviceReference
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

	// check for any valid NV interrupts that need to be serviced
	if (pDev)
	{
        rmStatus = osIsr(pDev);
	}

	return (rmStatus == RM_OK);

} // end of RmIsr()

BOOL RmInterruptPending
(
    PHWINFO pDev,
    BOOL   *serviced
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    V032         pmc;
    U032         hw_reg_value;

    // check interrupts only if the RM is initialized
    if (pOsHwInfo->rmInitialized)
    {
        // service interrupts only if they are enabled
        hw_reg_value = REG_RD32(NV_PMC_INTR_EN_0);
        // adi PMTE if the interrupts are enabled and if the hw registers are enabled
        if (hw_reg_value != 0 && hw_reg_value != 0xFFFFFFFF)
        {
            // service interrupts only if they are present
            pmc = REG_RD32(NV_PMC_INTR_0);
            if (pmc)
            {
                // disable interrupts
                RmDisableInterrupts(pDev);

                // only service interrupts locally for NT4
                #if (_WIN32_WINNT < 0x0500)
                // locally service high-priority interrupts immediately
                if (pmc & PENDING_INTERRUPTS)
                {
                    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Servicing VBLANK interrupt...\n");
                    VBlank(pDev);
                    *serviced = TRUE;
                }
                #endif // _WIN32_WINNT >= 0x0500

                // recheck to see if any interrupts occured during local servicing
                pmc = REG_RD32(NV_PMC_INTR_0);
                if (pmc)
                {
                    // a non-VBLANK interrupt is pending, so don't enable ints yet
                    return TRUE;
                }
                else
                {
                    // enable interrupts if all were serviced locally
                    RmEnableInterrupts(pDev);
                }
            }
        }
    }
    return FALSE;

} // end of RmInterruptPending()

VOID RmEnableInterrupts
(
	PHWINFO pDev
)
{
	//DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Enabling NV interrupts...\n");
	REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);

} // end of RmEnableInterrupts();

VOID RmDisableInterrupts
(
	PHWINFO pDev
)
{
	//DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Disabling NV interrupts...\n");
	REG_WR32(NV_PMC_INTR_EN_0, 0x00000000);

} // end of RmDisableInterrupts();

BOOL RmConfigGetKernel
(
	U032 deviceReference,
	U032 index,
	U032* pValue
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
	
    rmStatus = stateConfigGet(pDev, index, pValue);

	return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigGetKernel()

BOOL RmConfigGetExKernel
(
	U032 deviceReference,
	U032 index,
    VOID* pParms,
    U032 parmSize
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
	
    rmStatus = stateConfigGetEx(pDev, index, pParms, parmSize);

	return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigGetExKernel()


BOOL RmConfigSetKernel
(
	U032  deviceReference,
   U032  index,
   U032  newvalue,
   U032* pOldvalue
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
	
   rmStatus = stateConfigSet(pDev, index, newvalue, pOldvalue);

	return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigSetKernel()

BOOL RmConfigSetExKernel
(
	U032 deviceReference,
	U032 index,
    VOID* pParms,
    U032 parmSize
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
	
    rmStatus = stateConfigSetEx(pDev, index, pParms, parmSize);

	return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigSetExKernel()

#if (_WIN32_WINNT >= 0x0500)
VOID RmSetAgpServices
(
    U032 deviceReference,
    VOID *AgpServices
)
{
    PHWINFO pDev = NvDBPtr_Table[deviceReference];
	PRMINFO pRmInfo = (PRMINFO) NvDBPtr_Table[deviceReference]->pRmInfo;
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS status;

    pOsHwInfo->AgpServices = AgpServices;

    // setup our AGP base/limit
    if (pOsHwInfo->AgpServices) {
        PHYSICAL_ADDRESS AgpPhysBase;
        VOID *AgpLinearBase;

        // Get the AGP physical base and limit
        status = NvGetAGPBaseLimit(pDev, &pRmInfo->AGP.AGPPhysStart, &pRmInfo->AGP.AGPLimit);
        if (status != RM_OK) {
            // chipset isn't configured correctly
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NvGetAGPBaseLimit call failed\n");
            pOsHwInfo->AgpServices = NULL;        // avoid AGP allocations
            return;
        }

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,   "NVRM: AGP PhysBase:  ", pRmInfo->AGP.AGPPhysStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AGP PhysLimit: ", pRmInfo->AGP.AGPLimit);

        //
        // So we're not dependent on anyone else's mapping to exist, establish our
        // own virtual addr to the AGP physbase. We only need a single page mapped
        // and type of mapping doesn't really matter. This is used only by drivers
        // wanting to setup a context DMA for the whole AGP aperture.
        //
        AgpPhysBase.HighPart = 0x00000000;
        AgpPhysBase.LowPart = (ULONG)pRmInfo->AGP.AGPPhysStart;

        AgpLinearBase = MmMapIoSpace(AgpPhysBase, 0x1000, 0x2);
        if (AgpLinearBase == NULL) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Failed to establish AGP base mapping\n");
            return;
        }
        pRmInfo->AGP.AGPLinearStart = (VOID_PTR)AgpLinearBase;
    }
}
#endif

BOOL RmPreModeSet
(
	U032 deviceReference,
    U032 head
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
    int i;

    pDev->Vga.Enabled = FALSE;

    // call the pre-mode set OS service
    osPreModeSetEx(pDev, head);
    
    // 
    // For a tiled primary surface, we delay setting the tiled bit in the hardware
    // until after we've modeswitched out of VGA to prevent a garbled splash screen.
    // Just in case we haven't set it yet, do it now.
    //
    for (i=0; i<MAX_CRTCS; i++) {
        if (pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i].hwResId != 0) {
            nvHalFbSetAllocParameters(pDev, &pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i]);
        }
    }
    return (rmStatus == RM_OK) ? TRUE : FALSE;

}

BOOL RmPostModeSet
(
	U032 deviceReference,
    U032 head
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // call the post-mode set OS service
    osPostModeSetEx(pDev, head);

    // 
    // At the completion of this modeset, check if there's been a
    // modeset on the other head, if not, call dacDisableDac.
    //
    if (pDev->Dac.CrtcInfo[head^1].pVidLutCurDac == (VOID_PTR)NULL)
        dacDisableDac(pDev, head^1);

    return (rmStatus == RM_OK) ? TRUE : FALSE;
}

// set a display's state: TRUE = on, FALSE = off
BOOL RmSetDisplayPowerState
(
	U032 deviceReference,
    U032 head,
    BOOL state
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        if (state)
        {
            // turn DAC on
            dacEnableDac(pDev, head);
            
            // signify that the sync state has not been set
            pDev->Dac.CrtcInfo[head].SyncStateIsSaved = FALSE;
            
        }
        else
        {
            // store away the sync states only on the first call
            if (!pDev->Dac.CrtcInfo[head].SyncStateIsSaved)
            {
                pDev->Dac.CrtcInfo[head].CurrentVsyncState = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, head);
                pDev->Dac.CrtcInfo[head].CurrentHsyncState = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, head);
                pDev->Dac.CrtcInfo[head].SyncStateIsSaved = TRUE;
            }
            
            // turn DAC off
            dacDisableDac(pDev, head);
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);

} // end of RmSetDisplayPowerState()

// set I2C ownership to the given head
BOOL RmEnableHead
(
	U032 deviceReference,
    U032 head
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
	    EnableHead(pDev, head);
    }
    else
    {
        rmStatus = RM_ERROR;
    }    
    
	return (rmStatus == RM_OK);

} // end of RmEnableHead()

// TO DO:  these defines need to go to a file that is shared between the miniport.c and osapi.c
// power state definitions used by RmSet/GetPowerState() and RmGetCurrentPowerState()
#define NV_POWER_ADAPTER_STATE_0            0x00000001 // full on
#define NV_POWER_ADAPTER_STATE_1            0x00000002 // slowed clocks
#define NV_POWER_ADAPTER_STATE_2            0x00000004 // slowed clocks, mobile style *** not all devices supported ***
#define NV_POWER_ADAPTER_STATE_3            0x00000008 // very slow clocks, state saved (regs & instance memory)
#define NV_POWER_ADAPTER_STATE_4            0x00000010 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_5            0x00000020 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_6            0x00000040 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_7            0x00000080 // future lower adapter power state
#define NV_POWER_ADAPTER_FEATURE_CTXSAVED   0x00000100 // lowest power consumption state saves device context
#define NV_POWER_ADAPTER_STATE_HIBERNATE    0x00000200 // msoft hibernate mode
#define NV_POWER_ADAPTER_FEATURE_UNDEF_2    0x00000400 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_3    0x00000800 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_4    0x00001000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_5    0x00002000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_6    0x00004000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_7    0x00008000 // future feature
#define NV_POWER_MONITOR_STATE_0            0x00010000 // full on
#define NV_POWER_MONITOR_STATE_1            0x00020000 // no VSYNC nor HSYNC
#define NV_POWER_MONITOR_STATE_2            0x00040000 // future lower monitor power state 
#define NV_POWER_MONITOR_STATE_3            0x00080000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_4            0x00100000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_5            0x00200000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_6            0x00400000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_7            0x00800000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_HIBERNATE    0x01000000 // msoft hibernate mode
#define NV_POWER_UNDEF_1                    0x02000000 // future attribute
#define NV_POWER_UNDEF_2                    0x04000000 // future attribute
#define NV_POWER_UNDEF_3                    0x08000000 // future attribute
#define NV_POWER_UNDEF_4                    0x10000000 // future attribute
#define NV_POWER_UNDEF_5                    0x20000000 // future attribute
#define NV_POWER_UNDEF_6                    0x40000000 // future attribute
#define NV_POWER_UNDEF_7                    0x80000000 // future attribute


LONG RMVideoResetDevice(U032 deviceReference);
BOOL RmSetPowerState
(
	U032 deviceReference,
    U032 head,
    U032 state
)
{
    U008      reg3B;
	RM_STATUS rmStatus  = RM_OK;
	PHWINFO   pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        switch (state)
        {
            // ADAPTER POWER STATES
            
            //  Level 0 - full on
            case NV_POWER_ADAPTER_STATE_0:
                mcPowerState(pDev, MC_POWER_LEVEL_0, head);
                break;
                
            //  Level 1 - slowed clocks
            case NV_POWER_ADAPTER_STATE_1:
                mcPowerState(pDev, MC_POWER_LEVEL_1, head);
                break;
                
            //  Level 2 - slowed clocks, mobile style (not all devices support)
            case NV_POWER_ADAPTER_STATE_2:
                mcPowerState(pDev, MC_POWER_LEVEL_2, head);
                break;
                
            //  Level 3 - very slow clocks, state saved (regs & instance memory)
            case NV_POWER_ADAPTER_STATE_3:
                mcPowerState(pDev, MC_POWER_LEVEL_3, head);
                break;

            //  Level 7 - state saved (regs & instance memory)
            case NV_POWER_ADAPTER_STATE_HIBERNATE:
                RMVideoResetDevice(deviceReference);
                mcPowerState(pDev, MC_POWER_LEVEL_7, head);
                break;
                
                
            // DISPLAY POWER STATES
            
            // display on
            case NV_POWER_MONITOR_STATE_0:
                mcPowerDisplayState(pDev, MC_POWER_LEVEL_5, head);

                // set the current monitor power state for this head
                pDev->Dac.CrtcInfo[head].CurrentPowerState = NV_POWER_MONITOR_STATE_0;
                pDev->Dac.DevicesEnabled &= ~DAC_MONITOR_POWER_STATE_OFF;
                break;
            
            // display off
            case NV_POWER_MONITOR_STATE_1:
                mcPowerDisplayState(pDev, MC_POWER_LEVEL_6, head);

                // set the current monitor power state for this head
                pDev->Dac.CrtcInfo[head].CurrentPowerState = NV_POWER_MONITOR_STATE_1;
                pDev->Dac.DevicesEnabled |= DAC_MONITOR_POWER_STATE_OFF;
                break;

            // display hibernate -- msoft wants monitor left *on*
            case NV_POWER_MONITOR_STATE_HIBERNATE:
                if (!pDev->Dac.CrtcInfo[head].PrimaryDevice)
                {
                    //
                    // Disable broadcast mode on the secondary head.
                    // This only applies to mobile systems, so we are essentially
                    // disabling the external display and leaving the internal flat
                    // panel active.
                    //
                    // dacDisableBroadcast will tell us if the other head is active.
                    // If it is, the current head should be turned off instead of left on.
                    //
                    if (dacDisableBroadcast(pDev, head, &reg3B))
                    {
                        mcPowerDisplayState(pDev, MC_POWER_LEVEL_6, head);
                        //
                        // On everything except Toshiba (of course) restore the scratch
                        // register immediately so that scratch registers reflect the correct
                        // state upon returning from hibernation.  When the vga modeset occurs,
                        // the scratch bits will be tweaked again before doing the modeset so
                        // that the secondary head does not display garbage going into hibernation.
                        // Unfortunately, on Toshiba, restoring the scratch bits at any point going
                        // into hibernation, including right before exiting for the last time during
                        // adaptor hibernate, will result in garbage being displayed on the secondary
                        // head.  There is apparently yet another vga bios modeset call that is being
                        // honored somehow by the Toshiba bios after the last call to the RM, and if
                        // the scratch bits show both heads active, the secondary head will display
                        // garbage.
                        //
                        if(pDev->Power.MobileOperation != 2)
                            dacRestoreBroadcast(pDev, head, reg3B);
                    }
                    else
                        mcPowerDisplayState(pDev, MC_POWER_LEVEL_5, head);
                }
                else
                    mcPowerDisplayState(pDev, MC_POWER_LEVEL_5, head);

                // set the current monitor power state for this head
                pDev->Dac.CrtcInfo[head].CurrentPowerState = NV_POWER_MONITOR_STATE_HIBERNATE;
                pDev->Dac.DevicesEnabled &= ~DAC_MONITOR_POWER_STATE_OFF;
                break;
                
            default:
                rmStatus = RM_ERROR;
                break;
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);
    
} // end of RmSetPowerState()

BOOL RmGetCurrentPowerState
(
	U032 deviceReference,
    U032 head, 
    U032* pState
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        // load the return state with the current adapter state
        switch (pDev->Power.State)
        {
            case MC_POWER_LEVEL_0:
                *pState = NV_POWER_ADAPTER_STATE_0;
                break;
                
            case MC_POWER_LEVEL_1:
                *pState = NV_POWER_ADAPTER_STATE_1;
                break;
                
            case MC_POWER_LEVEL_2:
                *pState = NV_POWER_ADAPTER_STATE_2;
                break;
                
            case MC_POWER_LEVEL_3:
                *pState = NV_POWER_ADAPTER_STATE_3;
                break;

            case MC_POWER_LEVEL_7:
                *pState = NV_POWER_ADAPTER_STATE_HIBERNATE;
                break;
        }
        
        // OR in the current monitor state
        if (head < pDev->Dac.HalInfo.NumCrtcs)
        {
            *pState |= pDev->Dac.CrtcInfo[head].CurrentPowerState;
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);
    
} // end of RmGetCurrentPowerState()

BOOL RmGetPowerCaps
(
	U032 deviceReference,
    U032 head, 
    U032* pCaps
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        // TO DO: do we need some kind of HAL call for this?
        if (pDev->Power.MobileOperation)
        {
            *pCaps = 
                NV_POWER_ADAPTER_STATE_0            |
                NV_POWER_ADAPTER_STATE_2            |
                NV_POWER_ADAPTER_STATE_3            |
                NV_POWER_ADAPTER_FEATURE_CTXSAVED   |
                NV_POWER_ADAPTER_STATE_HIBERNATE    |
                NV_POWER_MONITOR_STATE_0            |
                NV_POWER_MONITOR_STATE_1            |
                NV_POWER_MONITOR_STATE_HIBERNATE;
        }
        else
        {
            *pCaps = 
                NV_POWER_ADAPTER_STATE_0            |
                NV_POWER_ADAPTER_STATE_1            |
                NV_POWER_ADAPTER_STATE_3            |
                NV_POWER_ADAPTER_FEATURE_CTXSAVED   |
                NV_POWER_ADAPTER_STATE_HIBERNATE    |
                NV_POWER_MONITOR_STATE_0            |
                NV_POWER_MONITOR_STATE_1            |
                NV_POWER_MONITOR_STATE_HIBERNATE;

        }    
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);
    
} // end of RmGetPowerCaps()

BOOL RmSetDriverHotkeyHandling
(
	U032 deviceReference,
    BOOL enabled
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        if (enabled)
        {
            EnableMobileHotkeyHandling(pDev);
        }
        else
        {
            //Placing this here because it will get called when going to FS-DOS.
//            pDev->Dac.DeviceProperties.InferAuxDev = TRUE;
            pDev->Dac.DeviceProperties.LastSwitchEvent = SWITCH_FROM_FS_DOS;

            DisableMobileHotkeyHandling(pDev);
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);

} // end of RmSetDriverHotkeyHandling()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\os.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1996-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.C                                                              *
*   This is the OS interface module.  All operating system transactions     *
*   pass through these routines.  No other operating system specific code   *
*   or data should exist in the source.                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    09/07/93 - wrote it.                    *
*       Jeff Westerinen (jsw)       04/97 - modified for WinNT.             *
*                                                                           *
\***************************************************************************/

#include <ntddk.h>
#include <nvrm.h>
#include <os.h>
#include <nvos.h>
#include <nvhw.h>
#include <Nvcm.h>


// OS names
char nameVideoSink[]  = "CON:";
char nameImageVideo[] = "WND";
char nameSysMem[]     = "SYSMEM:";
char nameLVidMem[]    = "LOCALVIDMEM:";
char nameSVidMem[]    = "SYSVIDMEM:";

// registry names
char strDevNodeRM[]             = "\\Registry\\Machine\\SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\System";
char strTilingOverride[]        = "TilingOverride";
char strMemoryOverride[]        = "MemoryOverride";
char strRTLOverride[]           = "RTLOverride";
char strPBUSOverride[]          = "PBUSOverride";
char strUnderscanXOverride[]    = "UnderscanX";
char strUnderscanYOverride[]    = "UnderscanY";
//char strDevNodeDisplayNumber[]  = "\\Registry\\Machine\\SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display\\DeviceX";
char strDevNodeDisplayNumber[]  = "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\nv4\\Device0";
char strNTSrvPackVersion[]      = "\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\";

// evil globals
KSEMAPHORE rmSemaphore, osSemaphore;
DISPLAYINFO osDisplayInfo;

// memory pools required so no memory is allocated during ISR
PDMALISTELEMENT_POOL_ELEMENT dmaListElementPool;

#if DBG

// memory allocation tracking data structs and globals
typedef struct _MEM_ALLOC_LOG_ENTRY
{
    U032 handle;
    VOID *address;
    U032 size;
    struct _MEM_ALLOC_LOG_ENTRY *next;
    struct _MEM_ALLOC_LOG_ENTRY *last;

} MEM_ALLOC_LOG_ENTRY;
MEM_ALLOC_LOG_ENTRY *memAllocLog = NULL;
MEM_ALLOC_LOG_ENTRY *memAllocLogTail = NULL;
U032 memAllocEntries = 0;
U032 memAllocTotal = 0;
U032 fourByteAllocs = 0;

// instance memory allocation tracking data structs and globals
typedef struct _INST_MEM_ALLOC_LOG_ENTRY
{
    U032 handle;
    U032 instance;
    U032 size;
    U032 alignment;
    struct _INST_MEM_ALLOC_LOG_ENTRY *next;
    struct _INST_MEM_ALLOC_LOG_ENTRY *last;

} INST_MEM_ALLOC_LOG_ENTRY;
INST_MEM_ALLOC_LOG_ENTRY *instMemAllocLog = NULL;
INST_MEM_ALLOC_LOG_ENTRY *instMemAllocLogTail = NULL;
U032 instMemAllocEntries = 0;
U032 instMemAllocTotal = 0;

U032 nvddHeapAllocationCount = 0;
U032 nvddHeapFreeCount = 0;

#endif // DBG    

//
// Some quick and dirty library functions.
// This is an OS function because some operating systems supply their
// own version of this function that they require you to use instead
// of the C library function.  And some OS code developers may decide to
// use the actual C library function instead of this code.  In this case,
// just replace the code within osStringCopy with a call to the C library
// function strcpy.
//
char *osStringCopy
(
    char *dst,
    const char *src
)
{
    char *dstptr = dst;

    while (*dstptr++ = *src++);
    return (dst);
}

S032 osStringCompare
(
    const char *s1,
    const char *s2
)
{
    return strcmp(s1, s2);
}

U032 osStringLength(const char * str)
{
    U032 i = 0;
    while (str[i++] != '\0');
    return i - 1;
}

unsigned char * osMemCopy(unsigned char * dst, const unsigned char * src, U032 length)
{
    U032 i;
    for (i = 0; i < length; i++)
    {
        dst[i] = src[i];
    }
    return dst;
}

//---------------------------------------------------------------------------
//
//  Operating System Memory functions.
//
//---------------------------------------------------------------------------

#ifndef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS  osCopyIn
(
	U008 *src, 
	U008 *target,
	U032 count
)
{
	osMemCopy(target, src, count);

	return(RM_OK);
}

RM_STATUS  osCopyOut
(
	U008 *src,
	U008 *target,
	U032 count
)
{
	osMemCopy(target, src, count);

	return(RM_OK);
}

RM_STATUS osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    RM_STATUS status;
    U008     *pMem;
    U032      PageCount;

    status = RM_OK;
    
#if !DBG
    *pAddress = ExAllocatePoolWithTag(NonPagedPool, Size, NV_MEMORY_TAG);
    if (*pAddress != NULL)
    {
#else
    // allocate three extra dwords to hold the size and some debug tags
    Size += 3 * sizeof(U032);

    // round to the nearest dword size to prevent alignment fault on IA64
    Size = (Size + sizeof(U032) - 1) & ~(sizeof(U032) - 1);

    *pAddress = ExAllocatePoolWithTag(NonPagedPool, Size, NV_MEMORY_TAG);
    if (*pAddress != NULL)
    {
        // memory allocation tracking
        osLogMemAlloc(*pAddress, Size);

        // load the size into the first dword, the first tag into the second dword, 
        // and the second tag into the last, then adjust the address
        **(U032**)pAddress                                = Size;
        *(*(U032**)pAddress + 1)                          = NV_MARKER1;
        *(U032*)(*(U008**)pAddress + Size - sizeof(U032)) = NV_MARKER2;
        *(U032**)pAddress += 2;
        pMem = *(U008**)pAddress;
        Size -= 3 * sizeof(U032);
        while (Size--)
            *pMem++ = 0x69;
#endif // DBG
    }
    else
    {
        status = RM_ERR_NO_FREE_MEM;
    }
    return (status);
}
RM_STATUS osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status;
    U032      Size;
    U032      PageCount;

#if DBG
    (U032*)pAddress -= 2;
    Size = *(U032*)pAddress;
    if (*((U032*)pAddress + 1) != NV_MARKER1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Invalid address to osFreeMem\n");
        DBG_BREAKPOINT();
    }
    if (*(U032*)((U008*)pAddress + Size - sizeof(U032)) != NV_MARKER2)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Memory overrun in structure to osFreeMem\n");
        DBG_BREAKPOINT();
        return (RM_ERR_MEM_NOT_FREED);
    }
    *((U032*)pAddress + 1) = 'DAED';
    *(U032*)((U008*)pAddress + Size - sizeof(U032)) = 'DEAD';
    Size -= 3 * sizeof(U032);

    // memory allocation tracking
    osUnlogMemAlloc(pAddress);

#endif // DBG    
    ExFreePool(pAddress);

    status = RM_OK;
    return (status);
}

#endif // not Win2K

#if DBG

// add a memory allocation log entry
VOID osLogMemAlloc(VOID *address, U032 size)
{
    static U032 memAllocAttempts = 0;
    static U032 memAllocId = 0;

    MEM_ALLOC_LOG_ENTRY *newElement = ExAllocatePoolWithTag(NonPagedPool, sizeof(MEM_ALLOC_LOG_ENTRY), NV_MEMORY_TAG);
    if (newElement)
    {
        // stats
        memAllocEntries++;
        memAllocTotal += size;

        // find the magic 4-byte alloc
        if (size == 0x10)
        {
            fourByteAllocs++;
        }

        // add the new element to the head of the list
        newElement->handle = memAllocId++;
        newElement->address = address;
        newElement->size = size;
        newElement->next = memAllocLog;
        newElement->last = NULL;
        memAllocLog = newElement;

        // set the tail
        if (memAllocLogTail == NULL)
        {
            memAllocLogTail = newElement;
        }

        // fixup the back link of the next element
        if (newElement->next)
        {
            newElement->next->last = newElement;
        }
    }

    // more stats
    memAllocAttempts++;
}

// remove a memory allocation log entry
VOID osUnlogMemAlloc(VOID *address)
{
    static U032 memFreeAttempts = 0;
    MEM_ALLOC_LOG_ENTRY *element;

    for (element = memAllocLog; element; element = element->next)
    {
        if (element->address == address)
        {
            // stats
            memAllocEntries--;
            memAllocTotal -= element->size;

            // unlink the element from the list
            if (element->last)
            {
                element->last->next = element->next;
            }
            else
            {
                memAllocLog = element->next;
            }
            if (element->next)
            {
                element->next->last = element->last;
            }

            // adjust the tail
            if (element == memAllocLogTail)
            {
                memAllocLogTail = element->last;
            }

            // free the element
            ExFreePool(element);
            break;
        }
    }

    // more stats
    memFreeAttempts++;
}

// add a memory allocation log entry
VOID osLogInstMemAlloc(U032 instance, U032 size, U032 alignment)
{
    static U032 instMemAllocAttempts = 0;
    static U032 instMemAllocId = 0;

    INST_MEM_ALLOC_LOG_ENTRY *newElement = ExAllocatePoolWithTag(NonPagedPool, sizeof(INST_MEM_ALLOC_LOG_ENTRY), NV_MEMORY_TAG);
    if (newElement)
    {
        // stats
        instMemAllocEntries++;
        instMemAllocTotal += size;

        // add the new element to the head of the list
        newElement->handle = instMemAllocId++;
        newElement->instance = instance;
        newElement->size = size;
        newElement->alignment = alignment;
        newElement->next = instMemAllocLog;
        newElement->last = NULL;
        instMemAllocLog = newElement;

        // set the tail
        if (instMemAllocLogTail == NULL)
        {
            instMemAllocLogTail = newElement;
        }

        // fixup the back link of the next element
        if (newElement->next)
        {
            newElement->next->last = newElement;
        }
    }

    // more stats
    instMemAllocAttempts++;
}

// remove a memory allocation log entry
VOID osUnlogInstMemAlloc(U032 instance, U032 size)
{
    static U032 instMemFreeAttempts = 0;
    INST_MEM_ALLOC_LOG_ENTRY *element;

    for (element = instMemAllocLog; element; element = element->next)
    {
        if (element->instance == instance)
        {
            // stats
            instMemAllocEntries--;
            instMemAllocTotal -= size;

            // unlink the element from the list
            if (element->last)
            {
                element->last->next = element->next;
            }
            else
            {
                instMemAllocLog = element->next;
            }
            if (element->next)
            {
                element->next->last = element->last;
            }

            // adjust the tail
            if (element == instMemAllocLogTail)
            {
                instMemAllocLogTail = element->last;
            }

            // free the element
            ExFreePool(element);
            break;
        }
    }

    // more stats
    instMemFreeAttempts++;
}

#endif // DBG    

//
// osAllocPages - Allocate a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  PageCount  - number of pages to allocate
//  MemoryType - memory pool
//  Contiguous - contiguous pages?
//  Cache      - cacheing request
//
RM_STATUS osAllocPages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    PageCount,
    U032    MemoryType,
    U032    Contiguous,
    U032    Cache,
    U032    ClientClass,
    VOID    **pMemData
)
{
    *pMemData = NULL;

    switch (MemoryType)
    {
        case NV_MEMORY_TYPE_AGP:
            return(osAllocAGPPages(pDev, pAddress, PageCount, ClientClass, pMemData));
            break;
        case NV_MEMORY_TYPE_SYSTEM:
            return(osAllocSystemPages(pDev, pAddress, PageCount, ClientClass, pMemData));
            break;
        default:
            return RM_ERROR;
    }
}

//
// osFreePages - Free a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  MemoryType - memory pool
//
RM_STATUS osFreePages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    MemoryType,
    U032    PageCount,
    VOID    *pMemData,
    BOOL    IsWriteCombined          // all NT4 AGP allocs are write combined
)
{
    switch (MemoryType)
    {
        case NV_MEMORY_TYPE_AGP:
            return(osFreeAGPPages(pDev, pAddress, pMemData));
            break;
        case NV_MEMORY_TYPE_SYSTEM:
            return(osFreeSystemPages(pDev, pAddress, pMemData));
            break;
        default:
            return RM_ERROR;
    }
}

RM_STATUS osAllocDmaListElement
(
    PDMAUSEROBJECT *ppDmaListElement
)
{
    U032 i;

    // get the next available DMA list elementt
    for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
    {
        if (!dmaListElementPool[i].inUse)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Allocating DMA list element", i);
            dmaListElementPool[i].inUse = TRUE;
            *ppDmaListElement = &dmaListElementPool[i].dmaListElement;
            return RM_OK;
        }
    }

    return RM_ERROR;

} // end of osAllocDmaListElement()

RM_STATUS osFreeDmaListElement
(
    PDMAUSEROBJECT pDmaListElement
)
{
    U032 i;

    // return the DMA list element to the pool
    for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
    {
        if (pDmaListElement == &dmaListElementPool[i].dmaListElement)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing DMA list element", i);
            dmaListElementPool[i].inUse = FALSE;
            return RM_OK;
        }
    }

    return RM_ERROR;

} // end of osFreeDmaListElement()

// video port service implementation
#ifndef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS osLockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    U032             Selector,
    VOID*            Offset,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE *DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    U032            *PageArray,
    VOID**           pLinAddr,
    VOID**           LockHandle
)
{
    NTSTATUS ntStatus;
    PMDL pMdl = 0;
    ULONG i;

    //
    // If we're asking to lock video memory, let's just build up the PTE's and assume
    // that the caller has real control over video memory (such as DirectDraw or the
    // display driver).
    //
    if (*DmaAddressSpace == ADDR_FBMEM)
    {

        *pLinAddr = Offset;   // 0-based selector!!

        //
        // For FB, the offset into the framebuffer has already been calculated by
        // osGetAddressInfo; don't assume 0, but use Offset as the first physaddr.
        //
        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (U032)((NV_UINTPTR_T)Offset + (i * RM_PAGE_SIZE)) | 3;
        }
    }
    else if (*DmaAddressSpace == ADDR_AGPMEM)
    {
        // For AGP, load in the aperture address (we'll only need 1 pte loaded),
        // but since we've allocated PageCount worth, I guess we'll load it all

        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (U032)((NV_UINTPTR_T)DmaAddress + (i * RM_PAGE_SIZE)) | 3;
        }
    }
    else
    {
        PHYSICAL_ADDRESS pagePhysicalAddr;
        U008* pageVirtualAddr;

        // lock the pages using an MDL created from the DMA buffer specs
        pMdl = IoAllocateMdl(
            DmaAddress,
            DmaLength,
            FALSE,
            FALSE,
            NULL
        );
        if (pMdl == NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Cannot allocate MDL\n");
            return RM_ERR_NO_FREE_MEM;
        }
        try
        {
            // the only way to know if locking fails is via an exception
            MmProbeAndLockPages(
                pMdl,
                KernelMode,
                IoModifyAccess
            );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ntStatus = GetExceptionCode();
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: MmProbeAndLockPages FAILED!\n");
            IoFreeMdl(pMdl);
            return RM_ERR_PAGE_TABLE_NOT_AVAIL;
        }

        // save the MDL pointer
        *LockHandle = pMdl;

        // map the buffer
#if (_WIN32_WINNT < 0x0500)
        *pLinAddr = MmGetSystemAddressForMdl(pMdl);
#else
        *pLinAddr = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
#endif // (_WIN32_WINNT < 0x0500)
        if (*pLinAddr == NULL)
        {
            MmUnlockPages(pMdl);
            IoFreeMdl(pMdl);
            return RM_ERROR;
        }


        // load the PTE array with physical addresses of the page-aligned buffer
        // note: if memory refered by DmaAddress was paged out (therefore being
        //       invalid) at the time of the lock down call, it might be still
        //       invalid. Therefore MmGetPhysicalAddress(DmaAddress) returns NULL.
        //       (seen on a SMP system / low memory condition)
        //       The recently mapped pLinAddr alias is accessible though.
        pageVirtualAddr = (U008*)((NV_UINTPTR_T)(*pLinAddr) & ~RM_PAGE_MASK);

        for (i = 0; i < PageCount; i++)
        {
            pagePhysicalAddr = MmGetPhysicalAddress(pageVirtualAddr);
            if (pagePhysicalAddr.LowPart == 0)
            {
                MmUnmapLockedPages(*pLinAddr, pMdl);
                MmUnlockPages(pMdl);
                IoFreeMdl(pMdl);
                return RM_ERR_NO_FREE_MEM;
            }
            PageArray[i] = pagePhysicalAddr.LowPart | 3;
            pageVirtualAddr += RM_PAGE_SIZE;
        }
    }

    return (RM_OK);
}
RM_STATUS osUnlockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    VOID*            LinAddr,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    VOID*            LockHandle,
    U032             DirtyFlag
)
{
    RM_STATUS status = RM_OK;
    PMDL pMdl = (PMDL)LockHandle;

    //
    // If we're asking to unlock video memory, we're assuming the caller (probably
    // direct draw)  has complete control of video memory, and therefore knows what
    // is locked/unlocked.  No need to do anything.
    //
    if ((DmaAddressSpace != ADDR_FBMEM) && (DmaAddressSpace != ADDR_AGPMEM))
    {
        // otherwise, unmap locked pages, unlock pages, and free the MDL
        MmUnmapLockedPages((VOID*)LinAddr, pMdl);
        MmUnlockPages(pMdl);
        IoFreeMdl(pMdl);
    }
    return (status);
}

//#endif // (_WIN32_WINNT < 0x0500)
#endif // VIDEO_PORT_IMPLEMENTATION

RM_STATUS osMapFifo
(
    PHWINFO pDev,
    U032 clientClass,
    U032 ChannelID,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = (VOID*)((U008*)nvAddr + FIFO_USER_BASE(pDev) + (ChannelID << 16));
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                pDev->Mapping.PhysAddr + FIFO_USER_BASE(pDev) + (ChannelID << 16),
                CHANNEL_LENGTH,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osMapInstanceMemory
(
    PHWINFO pDev,
    U032 clientClass,
    U032 instanceOffset,
    U032 length,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = INSTANCE_MEMORY_LOGICAL_BASE(pDev) + instanceOffset;
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                INSTANCE_MEMORY_PHYSICAL_BASE(pDev) + instanceOffset,
                length,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osMapFrameBuffer
(
    PHWINFO pDev,
    U032 clientClass,
    U032 fbOffset,
    U032 length,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = (U008*)fbAddr + fbOffset;
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                pDev->Mapping.PhysFbAddr + fbOffset,
                length,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

// This procedure undoes the work of osMapFifo, osMapFrameBuffer and osMapInstanceMemory
RM_STATUS osUnmapMemory
(
    PHWINFO pDev,
    U032    clientClass,
    VOID*   address,
    U032    length
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            break;

        case NV01_ROOT_USER:
            rmStatus = osUnmapPciMemoryUser(pDev, address);
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osSetFifoDmaParams
(
    PHWINFO pDev,
    U032   *pFetchTrigger,
    U032   *pFetchSize,
    U032   *pFetchRequests
)
{

    //
    // Default NT DMA channel fetch parameters
    // (optimized for NT display driver).
    //
    *pFetchTrigger = 128;           // 128 bytes
    *pFetchSize = 128;              // 128 bytes
    *pFetchRequests = 8;            // 8 outstanding read requests

    return RM_OK;
}

RM_STATUS osDeviceNameToDeviceClass(char *osName, U032 *pDevClass)
{
    // TO DO: add a validate pointer OS service
    // validate OS name parameter
    try
    {
        U008 testData = *(U008*)osName;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NTSTATUS ntStatus = GetExceptionCode();
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: invalid OS name\n");
        return RM_ERROR;
    }

    switch (*pDevClass)
    {
        // explicit device classes need no processing
        case NV01_DEVICE_0:
        case NV01_DEVICE_1:
        case NV01_DEVICE_2:
        case NV01_DEVICE_3:
        case NV01_DEVICE_4:
        case NV01_DEVICE_5:
        case NV01_DEVICE_6:
        case NV01_DEVICE_7:
            break;

        // derive the device class from the OS name, for NT, the device reference
        case NV03_DEVICE_XX:
            switch (*(U032*)osName)
            {
                case 0:
                    *pDevClass = NV01_DEVICE_0;
                    break;

                case 1:
                    *pDevClass = NV01_DEVICE_1;
                    break;

                case 2:
                    *pDevClass = NV01_DEVICE_2;
                    break;

                case 3:
                    *pDevClass = NV01_DEVICE_3;
                    break;

                case 4:
                    *pDevClass = NV01_DEVICE_4;
                    break;

                case 5:
                    *pDevClass = NV01_DEVICE_5;
                    break;

                case 6:
                    *pDevClass = NV01_DEVICE_6;
                    break;

                case 7:
                    *pDevClass = NV01_DEVICE_7;
                    break;

                // invalid escape value
                default:
                    return RM_ERROR;
            }
            break;

        // invalid class
        default:
            return RM_ERROR;

    }

    return RM_OK;

}

//---------------------------------------------------------------------------
//
//  OS specific time of day.
//
//---------------------------------------------------------------------------

/*****************************************************************************
*
*   Name: osGetCurrentTime
*
*   Description:
*       This functions returns the number of nano seconds that have ellapsed
*   since January 1 at midnight, GMT, of the given base year.  The base year
*   is passed in year, and the elapsed time is returned in nSecElapsed.  The
*   rest of the parameters are filled with the current date and time.
*
*****************************************************************************/

RM_STATUS osGetCurrentTime
(
    U032 *year,
    U032 *month,
    U032 *day,
    U032 *hour,
    U032 *min,
    U032 *sec,
    U032 *msec
)
{
    TIME_FIELDS currentTime;
    LARGE_INTEGER timeIn100ns;

    // get the current elapsed time
    KeQuerySystemTime(&timeIn100ns);

    // set the current time fields
    RtlTimeToTimeFields(&timeIn100ns, &currentTime);
    *year   = currentTime.Year;
    *month  = currentTime.Month;
    *day    = currentTime.Day;
    *hour   = currentTime.Hour;
    *min    = currentTime.Minute;
    *sec    = currentTime.Second;
    *msec   = currentTime.Milliseconds;

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Misc services.
//
//---------------------------------------------------------------------------


// Pre and Post modeset stuff, from the 9x stuff
// Os Specifix pre mode set actions.
VOID osPreModeSetEx(PHWINFO pDev, U032 Head)
{

    // Nothing to do here any more...all TV stuff is in the main
    // modeset path in dac/dacmode.c:dacSetModeMulti().

} // end of osPreModeSetEx()

// Os Specific post mode set actions.
VOID osPostModeSetEx(PHWINFO pDev, U032 Head)
{
    RM_STATUS status;
    U032      data32;

    // See if there are any registry overrides for the desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) {
        U032 cbLen;
        NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS position;

        cbLen = 4 * sizeof(U032);
        status = dacReadDesktopPositionFromRegistry(pDev, Head,
                                                    TRUE,  // isMonitor
                                                    (U008 *) &(position.HRetraceStart),
                                                    &cbLen);
        if (status == RM_OK) {
            // Program the new values.
            dacSetMonitorPosition(pDev, Head,
                                  position.HRetraceStart, position.HRetraceEnd,
                                  position.VRetraceStart, position.VRetraceEnd);
        }
    }

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        dacSetBiosDefaultTVType(pDev, pDev->Dac.TVStandard);

    // See if there are any registry overrides for the monitor timing.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR)
    {
        NV_CFGEX_CRTC_TIMING_PARAMS timings;

        //
        // First check if there are timings available in the registry for this mode
        //
        timings.Head = Head;
        timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTRY;
        status = dacGetCRTCTiming(pDev, Head, &timings);

        if (status == RM_OK)
        {
            //
            // Program the new values
            //
            timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
            status = dacSetCRTCTiming(pDev, Head, &timings);
        }

    }

    // See if there are any registry overrides for the TV desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV) {

       U032 cbLen;
       NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS Params;
 
       // Read the registry to get any updates to the default setting.
       // This should be done after dacAdjustCRTCForTV because it involves changes to CRTC.
       cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
       status = dacReadTVDesktopPositionFromRegistry(pDev, Head, (U008 *) &Params, &cbLen);
   
       // Make sure data is valid for the current encoder.
       if((status == RM_OK) && (Params.Encoder_ID == pDev->Dac.EncoderType)) {
           // Write the saved settings
           dacSetTVPosition(pDev, Head, (U032 *) &Params);
       }
       if (!pDev->Power.MobileOperation)
       {
           dacWriteTVStandardToRegistry(pDev, pDev->Dac.TVStandard);   // save TV standard in registry
       }
    }
    
    // Check/Set any PFB overrides
    if (osReadRegistryDword(pDev, strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }
    if (osReadRegistryDword(pDev, strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_RTL, data32);
    }
    
} // end of osPostModeSetEx()





//
// First pass at implementing registry string read.
// Converts the UNICODE string from registry into a POS (plain old string)
// of max length '*cbLen' and returns it in buffer pointed to by '*Data'
//
// Currently just used by RM_FAILURE mechanism in rmfailure.c
//
// Note:
//    has a lot in common w/ osReadRegistryDword
//       could be commoned once it works :-)
//    missing pDev arg of osReadRegistryDword()
//    can not be called from RmInitRm(); it is apparently too early
//        if you do, will just return STATUS_NOT_FOUND
//
RM_STATUS osReadRegistryString
(
    char *regDevNode,
    char *regParmStr,
    char *Data,
    U032 *cbLen
)
{
    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    UNICODE_STRING dest_unicode_string;
    ANSI_STRING dest_ansi_string;

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].DefaultType = REG_SZ;

    dest_unicode_string.Length = 0;
    dest_unicode_string.MaximumLength = (short) *cbLen;
    dest_unicode_string.Buffer = ExAllocatePoolWithTag(
                                        PagedPool,
                                        dest_unicode_string.MaximumLength, 
                                        NV_MEMORY_TAG
                                        );
    
    if (!dest_unicode_string.Buffer) 
    {
        return RM_ERROR;
    }

    query[0].DefaultData = dest_unicode_string.Buffer;
    query[0].DefaultLength = 0;
    query[0].EntryContext = &dest_unicode_string;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL	// environment unused
    );

    if((NT_SUCCESS(ntStatus)) && (dest_unicode_string.Length != 0))
    {
        dest_ansi_string.Length = 0;
        dest_ansi_string.MaximumLength = (unsigned short) *cbLen;
        // convert it into caller's buffer
        dest_ansi_string.Buffer = Data;
        RtlUnicodeStringToAnsiString(&dest_ansi_string,
                                 &dest_unicode_string,
                                 0 /* don't allocate dest */);
        ExFreePool(dest_unicode_string.Buffer);

        *cbLen = dest_ansi_string.Length;

        return RM_OK;
    }
    else
    {
        ExFreePool(dest_unicode_string.Buffer);
        return RM_ERROR;
    }

}


#if (_WIN32_WINNT < 0x0500)

RM_STATUS osDelayUs
(
    U032 MicroSeconds
    )
{
    // convert uSec to a relative (negative) interval of 100's of nSecs
    LARGE_INTEGER hundredsOfNanoSeconds = RtlConvertLongToLargeInteger(MicroSeconds * -10);

    // suspend for given relative time interval
    NTSTATUS ntStatus = KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &hundredsOfNanoSeconds
    );

    return (NT_SUCCESS(ntStatus)) ? RM_OK : RM_ERROR;
}


#ifdef NOT_USING_VIDEOPORT_REGISTRY_CALLS

RM_STATUS osWriteRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 cbLen
)
{

	NTSTATUS ntStatus;
	RM_STATUS rmStatus;
	STRING sRegDevNode, sRegParmStr;
	UNICODE_STRING usRegDevNode, usRegParmStr;
	WCHAR buffer1[] = L"                                                                                ";
	WCHAR buffer2[] = L"                                                                                ";


	// convert the parameters into unicode strings
	RtlInitAnsiString(&sRegDevNode, regDevNode);
	RtlInitUnicodeString(&usRegDevNode, buffer1);
	RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
	RtlInitAnsiString(&sRegParmStr, regParmStr);
	RtlInitUnicodeString(&usRegParmStr, buffer2);
	RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

	// Write the registry value 
	ntStatus = RtlWriteRegistryValue(
		RTL_REGISTRY_ABSOLUTE,
		usRegDevNode.Buffer,
		usRegParmStr.Buffer,
		REG_BINARY,
		Data,
		cbLen
	);
    if (!NT_SUCCESS(ntStatus))
    	return RM_ERROR;

	return RM_OK;

}

//
// First pass at implementing registry binary read.
// Returns binary data
// of max length '*cbLen' and returns it in buffer pointed to by '*Data'
//
// 'Data' buffer must be 8 bytes longer than your real data as it is coerced
//     into a data structure used by registry.
//
// The union of a binary registry data record, that contains the size and type
// along with the data, and a pure UCHAR buffer is used here.
//
// Note:
//    has a lot in common w/ osReadRegistryDword
//       could be commoned once it works :-)
//    missing pDev arg of osReadRegistryDword()
//    can not be called from RmInitRm(); it is apparently too early
//        if you do, will just return STATUS_NOT_FOUND
//

RM_STATUS osReadRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 *cbLen
)
{

    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    RM_REG_BINARY_BUFFER localbuf;

    // is the buffer big enough to hold the data and the length/type fields?
    // TO DO: Is there a way so send a more helpful error code?
    if (*cbLen + 8 > sizeof(RM_REG_BINARY_BUFFER))
    {
        return RM_ERROR;
    }

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial, no callback, registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].EntryContext = localbuf.buffer;
    query[0].DefaultType = REG_NONE;
    query[0].DefaultData = localbuf.buffer;
    query[0].DefaultLength = sizeof(localbuf.buffer) - 8;   // Minus the size of the header that is prepended
    
    
    // - Prep the query
    // Zero the local buffer in case the return size is less than the expected size, as someone might get back
    // less than they expected, and at this point, we return them the size that they expected
    RtlZeroMemory(localbuf.buffer, sizeof(localbuf.buffer));
    localbuf.record.Length = sizeof(localbuf.buffer) - 8;   // Minus the size of the header that is prepended
    localbuf.record.type = REG_NONE;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL
    );
    if (!NT_SUCCESS(ntStatus)) {

        return RM_ERROR;
    }

    // Make sure that NT got the value type right...
    if( localbuf.record.type != REG_BINARY) {

       return RM_ERROR;
    }

	 // shift data out to Data using a copy that works on overlapping buffers
    // For some reason, the length value handed back from Win2K is incorrect, but correct under WinNT4, so use the users size
    RtlMoveMemory(Data, localbuf.record.buffer, *cbLen);

    return RM_OK;

}

RM_STATUS osWriteRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 Data
)
{

	NTSTATUS ntStatus;
	RM_STATUS rmStatus;
	STRING sRegDevNode, sRegParmStr;
	UNICODE_STRING usRegDevNode, usRegParmStr;
	WCHAR buffer1[] = L"                                                                                ";
	WCHAR buffer2[] = L"                                                                                ";


	// convert the parameters into unicode strings
	RtlInitAnsiString(&sRegDevNode, regDevNode);
	RtlInitUnicodeString(&usRegDevNode, buffer1);
	RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
	RtlInitAnsiString(&sRegParmStr, regParmStr);
	RtlInitUnicodeString(&usRegParmStr, buffer2);
	RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

	// Write the registry value 
	ntStatus = RtlWriteRegistryValue(
		RTL_REGISTRY_ABSOLUTE,
		usRegDevNode.Buffer,
		usRegParmStr.Buffer,
		REG_DWORD,
		&Data,
		sizeof(U032)
	);
    if (!NT_SUCCESS(ntStatus))
    	return RM_ERROR;

	return RM_OK;

}

RM_STATUS osReadRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 *Data
)
{

    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    U032 errorData = 0x69696969;

    // init Data to a known-bad value
    *Data = errorData;

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].DefaultType = REG_DWORD;
    query[0].EntryContext = Data;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL
    );
    if (!NT_SUCCESS(ntStatus))
        return RM_ERROR;

    return (*Data != errorData) ? RM_OK : RM_ERROR;

}

#endif // NOT_USING_VIDEOPORT_REGISTRY_CALLS

RM_STATUS osIsr
(
    PHWINFO pDev
)
{
    BOOL serviced = FALSE;
    
    if (RmInterruptPending(pDev, &serviced))
    {
        // service any remaining interrupt and reenable ints
        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Servicing non-VBLANK interrupt...\n");
        mcService(pDev);
        RmEnableInterrupts(pDev);
        serviced = TRUE;
    }
    
    return (serviced) ? RM_OK : RM_ERROR;

} // end of osIsr()

#endif // (_WIN32_WINNT < 0x0500)


RM_STATUS
osMemSet(VOID *addr, U032 fill, U032 bytes)
{
    memset(addr, fill, bytes);
    return RM_OK;
}

// Win2K processor synchronization
#if (_WIN32_WINNT >= 0x0500)

RM_STATUS osInitSpinLock
(
    PHWINFO pDev
)
{
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS rmStatus = RM_OK;
    
    rmStatus = osAllocMem(&pOsHwInfo->pRmSpinLock, sizeof(KSPIN_LOCK));
    if (rmStatus == RM_OK)
    {
        KeInitializeSpinLock((PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock));
    }
    
    return rmStatus;
    
} // end of osInitSpinLock()
    
RM_STATUS osEnterCriticalCode
(
    PHWINFO pDev 
)
{
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    KeAcquireSpinLock
    (
        (PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock),
        (PKIRQL)&pOsHwInfo->oldIrql
    );
    return RM_OK;
    
} // end of osAcquireSpinLock()

RM_STATUS osExitCriticalCode
(
    PHWINFO pDev
)
{
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    KeReleaseSpinLock
    (
        (PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock),
        (KIRQL)pOsHwInfo->oldIrql
    );
    return RM_OK;
    
} // end of osReleaseSpinLock()

#endif // (_WIN32_WINNT >= 0x0500)

#define rdtsc __asm _emit 0x0f __asm _emit 0x31 

// Return frequency value in MHz
U032 osGetCpuFrequency()
{
    U032 t1, t2;
    U032 tsc1, tsc2;

// TO DO: what to do about inline asm for IA-64?       
#ifndef IA64
    // read the tsc
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc1], eax
        pop     edx
        pop     eax
    }

    osDelay(100);

    // read the tsc again
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc2], eax
        pop     edx
        push    eax
    }
#else     
tsc1 = 0;
tsc2 = 0;
#endif // IA-64 cannot tolerate inline asm

    // multiply returned value by 10 since we timed 1/10th second
    // and divide the result to convert from Hz to MHz
    return (U032) ((tsc2-tsc1) * 10) / (1000000);
}

#define NT_HANDLE_PCI_DEVICE_SHIFT     8
#define NT_HANDLE_PCI_FUNC_SHIFT      16

//
//  PCI config space read/write routines.
//
U032
osPciReadDword(VOID *handle, U032 offset)
{
    U032 bus;
    U032 retval;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

U016
osPciReadWord(VOID *handle, U032 offset)
{
    U032 bus;
    U016 retval;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

U008
osPciReadByte(VOID *handle, U032 offset)
{
    U032 bus;
    U008 retval;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

VOID
osPciWriteDword(VOID *handle, U032 offset, U032 value)
{
    U032 bus;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

VOID
osPciWriteWord(VOID *handle, U032 offset, U016 value)
{
    U032 bus;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

VOID
osPciWriteByte(VOID *handle, U032 offset, U008 value)
{
    U032 bus;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

VOID *
osPciInitHandle(U008 bus, U008 device, U008 func, U016 *pVendorId, U016 *pDeviceId)
{
    U032 ihandle, vendevID, status;
    PCI_SLOT_NUMBER slot;

    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = device;
    slot.u.bits.FunctionNumber = func;

    // get vendor/device id at offset 0
    status = HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                                   bus,                  // bus number
                                   slot.u.AsULONG,       // slot number
                                   &vendevID,            // buffer
                                   0x0,                  // config space offset
                                   sizeof(vendevID));
    if (status == 0 || status == 2)
        return 0;

    // return these to the caller
    if (pVendorId)
        *pVendorId = (U016)(vendevID & 0xFFFF);
    if (pDeviceId)
        *pDeviceId = (U016)(vendevID >> 16);

    // return a non-zero handle out of bus/device/func
    ihandle = 0xFF000000 |
             (func << NT_HANDLE_PCI_FUNC_SHIFT) |
             (device << NT_HANDLE_PCI_DEVICE_SHIFT) | bus;
    return (VOID *)((NV_UINTPTR_T)ihandle);
}

RM_STATUS
osUpdateAGPLimit(PHWINFO pDev)
{
    // In winnt4/win2k, the AGP limit is always known
    return RM_OK;
}

RM_STATUS osBeginWatchCanvas
(
    U032 hwnd
)
{
    return RM_OK;
}

RM_STATUS osEndWatchCanvas
(
    U032 hwnd
)
{
    return RM_OK;
}

RM_STATUS osGetCurrentProcess(
    U032 *pPid
)
{
    // TO DO:  what are the semantics of this??
    *pPid = 0;
    return RM_OK;
}

// Validate the DMA address space name from the app
// A DMA object with no name is treated as System Memory space
// The DMA direction does not matter for system memory space
RM_STATUS osValidateDMAObject(
    char *OsName,
    U032 DmaObjectName,
    NV_ADDRESS_SPACE *AddressSpace
)
{
    U032 i;
    RM_STATUS status;

    if (OsName[0] == '\0')
    {
        *AddressSpace = ADDR_SYSMEM;
        return(RM_OK);
    }

    if (strcmp(OsName, nameSysMem) == 0)
    {
       *AddressSpace = ADDR_SYSMEM;
       return(RM_OK);
    }

    if (strcmp(OsName, nameLVidMem) == 0)
    {
       *AddressSpace = ADDR_FBMEM;
       return(RM_OK);
    }

    if (strcmp(OsName, nameSVidMem) == 0)
    {
       *AddressSpace = ADDR_AGPMEM;
       return(RM_OK);
    }

    *AddressSpace = ADDR_SYSMEM;

    return(RM_ERR_INVALID_OS_NAME);

}

RM_STATUS osValidateVideoSink
(
    char *OsName
)
{
    U032 i;

    for (i = 0; i < 4; i++)
        if (OsName[i] != nameVideoSink[i])
            return (RM_ERR_INVALID_OS_NAME);
    return (RM_OK);
}

RM_STATUS osValidateImageVideo
(
    char *OsName,
    U032 *CanvasID
)
{
    U032 i;

    *CanvasID = 0;
    for (i = 0; i < 3; i++)
        if (*OsName++ != nameImageVideo[i])
            return (RM_ERR_INVALID_OS_NAME);
    while (*OsName >= '0' && *OsName <= '9')
        *CanvasID = *CanvasID * 10 + *OsName++ - '0';
    return (*OsName == ':' ? RM_OK : RM_ERROR);
}

// these must be shared by the miniport and RM

RM_STATUS osNotifyAction
(
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyAction() stub\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    return RM_OK;
}

RM_STATUS osError
(
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Error
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osError()\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Error  =", Error);

    return (RM_OK);
}

VOID osStateFbEx
(
    PHWINFO pDev
)
{
    U032    filterLevel;

    // check for an override value -- legal values are 0 (off), 1, or 2
    if (osReadRegistryDword(pDev, strDevNodeRM, "FilterOverride", &filterLevel) == RM_OK)
    {
        //if (pDev->Framebuffer.MonitorType != NV_MONITOR_VGA)
        {
            //pDev->Framebuffer.FilterEnable = 2;
            pDev->Framebuffer.FilterEnable = filterLevel;
        }
    }
    else
    {
        // only enable flicker filter for TV w/bit depth > 8BPP
        if (GETMONITORTYPE(pDev, 0) != NV_MONITOR_VGA)
        {
            if (pDev->Dac.HalInfo.Depth > 8)
            {
                pDev->Framebuffer.FilterEnable = 2;
            }
            else
            {
                pDev->Framebuffer.FilterEnable = 0;
            }
        }
        else
        {
            pDev->Framebuffer.FilterEnable = 0;
        }
    }

} // end of osStateFbEx()

RM_STATUS osSetVideoMode
(
    PHWINFO pDev
)
{
    U032 data32;

    if (osReadRegistryDword(pDev, strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }
    if (osReadRegistryDword(pDev, strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }

    return RM_OK;

} // end of osSetVideoMode()

#ifndef WIN2K_DDK_THAT_CONTAINS_APIS
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS osNotifyEvent
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Notifier,
    U032      Method,
    U032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, j;
    PEVENTNOTIFICATION NotifyEvent;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyEvent()\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    // perform the type of action
    switch (Action)
    {
        case NV_OS_WRITE_THEN_AWAKEN:

            // walk this object's event list and find any matches for this specific notify
            for (NotifyEvent = Object->NotifyEvent; NotifyEvent; NotifyEvent = NotifyEvent->Next)
            {
                if (NotifyEvent->NotifyIndex == Notifier)
                {
                    // found a match -- notify the event
                    switch (NotifyEvent->NotifyType)
                    {
                        case NV01_EVENT_WIN32_EVENT:
                        {
                            // attempt to trigger the event
                            KeSetEvent((PRKEVENT)NotifyEvent->Data, 0, FALSE);
                            break;
                        }

                        case NV01_EVENT_KERNEL_CALLBACK:
                        {
                            MINIPORT_CALLBACK callBackToMiniport = (MINIPORT_CALLBACK)NotifyEvent->Data;

                            // perform a direct callback to the miniport
                            if (callBackToMiniport)
                                callBackToMiniport(pDev->DBmpDeviceExtension);
                            break;
                        }
                    }
                }
            }
            break;

        default:

            // any other actions are legacy channel-based notifies
            rmStatus = NVOS10_STATUS_ERROR_BAD_EVENT;
            break;
    }

    return rmStatus;

} // end of osNotifyEvent()

#endif // (_WIN32_WINNT < 0x0500)


//---------------------------------------------------------------------------
//
//  AGP support
//
//---------------------------------------------------------------------------

#if (_WIN32_WINNT >= 0x0500)

// AGP memory allocation tracking
typedef struct _AGP_MEM_INFO
{
    NvU64   aperAddr;
    VOID*   virtAddr;
    VOID*   physContext;
    VOID*   virtContext;
    U032    sysPageCount;
} AGP_MEM_INFO, *PAGP_MEM_INFO;

#if defined(IA64)

//
// All of the routines below are to make osGetAddressInfo to work
// with the 82460GX chipset.  Unlike other chipsets, the physical
// memory mapped on by the CPU are not the AGP aperture addresses.
// Thus a call to MmGetPhysicalAddress cannot be used to determine
// whether an virtual address is mapped to AGP memory.  The following
// routines maintain a simple mapping table to map the system physical
// address to the AGP aperture address to program the adapter with.

#define AGP_MAPPING_INCR	1    // keep it small at first to exercise code

typedef struct _AGP_MAPPING {
    PHYSICAL_ADDRESS sysAddr;
    PHYSICAL_ADDRESS aperAddr;
} AGP_MAPPING, *PAGP_MAPPING;

static PAGP_MAPPING osAGPMappingTab;
static U032 osAGPMappingSize = 0;
static U032 osAGPMappingUsed = 0;

static RM_STATUS
osAllocAGPMapping(PHYSICAL_ADDRESS sysAddr, PHYSICAL_ADDRESS aperAddr)
{
    RM_STATUS status;
    PAGP_MAPPING pTab;
    U032 newSize;

    if (osAGPMappingSize == osAGPMappingUsed) {
        newSize = sizeof(AGP_MAPPING) * (osAGPMappingSize + AGP_MAPPING_INCR);
        status = osAllocMem((VOID **)&pTab, newSize);
        if (status != RM_OK)
            return status;
        if (osAGPMappingSize) {
            osMemCopy((unsigned char *)pTab, (unsigned char *)osAGPMappingTab, newSize);
            osFreeMem(osAGPMappingTab);
        }
        osAGPMappingTab = pTab;
        osAGPMappingSize += AGP_MAPPING_INCR;
    }
#ifdef DEBUG
    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        RM_ASSERT(pTab->sysAddr.QuadPart != sysAddr.QuadPart);
        RM_ASSERT(pTab->aperAddr.QuadPart != aperAddr.QuadPart);
    }
#endif
    pTab = &osAGPMappingTab[osAGPMappingUsed++];
    pTab->sysAddr = sysAddr;
    pTab->aperAddr = aperAddr;
    return RM_OK;
}

static VOID
osFreeAGPMapping(PHYSICAL_ADDRESS aperAddr)
{
    PAGP_MAPPING pTab;

    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        if (pTab->aperAddr.QuadPart == aperAddr.QuadPart) {
            osAGPMappingUsed--;
            osMemCopy((unsigned char *)pTab, (unsigned char *)(pTab+1),
                      (U032)((char *)&osAGPMappingTab[osAGPMappingUsed] -
                             (char *)pTab));
            return;
        }
    }
    
}

static U032
osLookupAGPMapping(PHYSICAL_ADDRESS sysAddr)
{
    PAGP_MAPPING pTab;

    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        if (pTab->sysAddr.QuadPart == sysAddr.QuadPart) {
            return (pTab->aperAddr.LowPart);
        }
    }
    return sysAddr.LowPart;
}

#else

#define WIN2K_VIRT_OFFSET_PAGES    16

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32

//
// win2k currently doesn't set up the correct page attribute table (PAT)
// index for write-combined user space mappings to AGP. The user mapping
// gets a WB index into the PAT and because of there are no non-system MTRR's,
// this defaults to uncached mapping.
//
// To work around this, we'll first READ the PAT and determine which index
// should be used for write-combining. Then, we'll read the PTE's for the
// length of the mapping and set the correct index.
//
// I don't believe (hopefully) MP will be an issue as I expect each CPU
// points to the same page table we're about to modify. At worst, this means
// we may be slow if we ran mostly on the wrong (uncached) processor.
//
static RM_STATUS
RmChangePageAttributeTable(PAGP_MEM_INFO pMemInfo)
{
    U032 modPass, PATvalue, PDTbase, WCindex;
    U032 PDEoffset, PTEoffset, physPage, lastPage;
    U032 *basepdb, *basepte, *pdbptr, *pteptr;
    U032 virtOffset, found_first_page = 0;
    PHYSICAL_ADDRESS pagePhysicalAddr;
    
    PATvalue = PDTbase = 0x0;

    __asm {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        mov     eax, 1
        CPUID

        // check for PAT support
        shr     edx, 16
        and     edx, 1  
        jz      Exit

        // get the (low 0:3 PAT) indices
        mov     ecx, 0x277
        RDMSR
        mov     PATvalue,eax

        // get the page descriptor base
        mov     ecx, cr3
        mov     PDTbase,ecx

        // flush caches making things consistent
        wbinvd
Exit:
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }

    if (!PATvalue || !PDTbase)
        return RM_ERROR;

    // look for the WC type within the PAT indices
    for (WCindex = 0; WCindex < 4; WCindex++)
    {
        if ((PATvalue & 0xF) == 0x1)
            break;
        PATvalue >>= 8;
    }
    if (WCindex == 4)
        return RM_ERROR;    // didn't find a WC index

    // Map in the PDE page (assuming 4K ptes)
    pagePhysicalAddr.HighPart = 0;
    pagePhysicalAddr.LowPart  = (PDTbase & ~0xFFF);
    basepdb = MmMapIoSpace(pagePhysicalAddr, RM_PAGE_SIZE, FALSE);
    if (basepdb == NULL)
        return RM_ERROR;

    //
    // First, we need to find if there's a virtOffset that needs to be setup.
    // In win2k, it seems user mappings, in addition to not being write-combined,
    // don't start at the address returned from AgpCommitVirtual after the DX
    // AGP heap has been setup.
    //
    // This might be caused by a non-zero fpGARTLin from the GUID_UpdateNonLocalHeap
    // callback DDraw gets, where the driver is supposed to offset everything by this
    // amount. But, each user alloc seems to not be just fpGARTLin bytes, it's almost
    // fpGARTlin * number of outstanding user allocs.
    // 
    // Rather than guess, for now, just scan WIN2K_VIRT_OFFSET_PAGES pages for the
    // first page and then verify the rest of the mapping from there. This virtOffset
    // will then be added to the user mapping passed back.
    //
    physPage = (U032)pMemInfo->aperAddr;

    virtOffset = 0;
    while (!found_first_page && (virtOffset < WIN2K_VIRT_OFFSET_PAGES))
    {
        // 10bits of PDE offset, 10bits of PTE offset
        PDEoffset = (U032)((NV_UINTPTR_T)pMemInfo->virtAddr >> (RM_PAGE_SHIFT + 10));
        PTEoffset = (U032)(((NV_UINTPTR_T)pMemInfo->virtAddr >> RM_PAGE_SHIFT) & 0x003FF);

        pdbptr = basepdb + PDEoffset;
        if (*pdbptr & 0x80)
        {
            MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
            return RM_ERROR;    // this isn't a 4K PDE
        }

        // Map in a set of PTEs (assuming 4K ptes)
        pagePhysicalAddr.HighPart = 0;
        pagePhysicalAddr.LowPart  = (*pdbptr & ~0xFFF);
        basepte = MmMapIoSpace(pagePhysicalAddr, RM_PAGE_SIZE, FALSE);
        if (basepte == NULL)
        {
            MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
            return RM_ERROR;
        }

        pteptr = basepte + PTEoffset;

        // Look for the beginning of the mapping on this PTE page
        while ((PTEoffset <= 0x3FF) && (virtOffset < WIN2K_VIRT_OFFSET_PAGES))
        {
            if ((*pteptr & ~0xFFF) == physPage)
            {
                found_first_page = 1;
                break;
            }
            PTEoffset++; pteptr++; virtOffset++;
            (U008 *)pMemInfo->virtAddr += RM_PAGE_SIZE;
        }

        MmUnmapIoSpace(basepte, RM_PAGE_SIZE);
    }

    if (!found_first_page)
    {
        MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
        return RM_ERROR;    // can't find first page of our mapping
    }

    lastPage = (U032)pMemInfo->aperAddr + (pMemInfo->sysPageCount << RM_PAGE_SHIFT);

    //
    // Before updating any PTEs, make sure they have the expected physPage.
    // The second pass is the modifying pass where we update the PAT index.
    //
    for (modPass = 0; modPass < 2; modPass++)
    {
        // sets the beginning and ending phys page
        physPage = (U032)pMemInfo->aperAddr;

        // 10bits of PDE offset, 10bits of PTE offset
        PDEoffset = (U032)((NV_UINTPTR_T)pMemInfo->virtAddr >> (RM_PAGE_SHIFT + 10));
        PTEoffset = (U032)(((NV_UINTPTR_T)pMemInfo->virtAddr >> RM_PAGE_SHIFT) & 0x003FF);

        pdbptr = basepdb + PDEoffset;

        while (physPage < lastPage)
        {
            if (*pdbptr & 0x80)
            {
                MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                return RM_ERROR;    // this isn't a 4K PDE
            }

            // Map in a set of PTEs (assuming 4K ptes)
            pagePhysicalAddr.HighPart = 0;
            pagePhysicalAddr.LowPart  = (*pdbptr & ~0xFFF);
            basepte = MmMapIoSpace(pagePhysicalAddr, RM_PAGE_SIZE, FALSE);
            if (basepte == NULL)
            {
                MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                return RM_ERROR;
            }

            pteptr = basepte + PTEoffset;

            // Check (or modify) the PTEs on this page
            while ((PTEoffset <= 0x3FF) && (physPage < lastPage))
            {
                if ((*pteptr & ~0xFFF) != physPage)
                {
                    // mismatch on physical page in PTE
                    DBG_PRINT_STRING_PTR(DEBUGLEVEL_ERRORS, "NVRM: mismatch in AGP mapping ",
                                         pMemInfo->virtAddr);
                    MmUnmapIoSpace(basepte, RM_PAGE_SIZE);
                    MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                    return RM_ERROR;
                }
                if (modPass)
                {
                    // mask off bits 4:3 and set the index
                    *pteptr = (*pteptr & ~0x18) | (WCindex << 3);
                }
                PTEoffset++; pteptr++;
                physPage += RM_PAGE_SIZE;
            }

            // Free the old page of PTEs
            MmUnmapIoSpace(basepte, RM_PAGE_SIZE);

            PTEoffset = 0x0;
            pdbptr++;
        }
    }

    MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);

    return RM_OK;
}
#endif // !IA64

#include <videoagp.h>

RM_STATUS osAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PAGP_MEM_INFO pMemInfo;
    HANDLE procHandle;
    RM_STATUS status;
    PHYSICAL_ADDRESS aperAddr;
#if defined(IA64)
    PHYSICAL_ADDRESS sysAddr;
#endif

    PVOID hwDeviceExtension = pDev->DBmpDeviceExtension;

    if (!hwDeviceExtension || !pOsHwInfo->AgpServices)
        return RM_ERR_NO_FREE_MEM;

    // we'll need to manage this allocation, a little
    status = osAllocMem((VOID **)&pMemInfo, sizeof(AGP_MEM_INFO));
    if (status != RM_OK)
        return RM_ERR_NO_FREE_MEM;

    // not all systems have PAGE_SIZE == RM_PAGE_SIZE;
    // round up to get an adequate number of system pages

    pMemInfo->sysPageCount = (pageCount + (PAGE_SIZE/RM_PAGE_SIZE) - 1) >> (PAGE_SHIFT - RM_PAGE_SHIFT);

    // reserve physical
    aperAddr = ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReservePhysical(hwDeviceExtension, pMemInfo->sysPageCount, TRUE, &pMemInfo->physContext);

    if ((aperAddr.LowPart == 0) && (aperAddr.HighPart == 0)) {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    pMemInfo->aperAddr = aperAddr.QuadPart;

    // commit physical
    if ( ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpCommitPhysical(hwDeviceExtension,
																			   pMemInfo->physContext,
																			   pMemInfo->sysPageCount,
																			   0)
																			   == FALSE )
	{

		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    // set processs handle (hopefully triggers the correct mapping)
    procHandle = (ClientClass == NV01_ROOT_USER) ? NtCurrentProcess() : 0x0;

    // reserve virtual
	pMemInfo->virtAddr = ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReserveVirtual(hwDeviceExtension,
																							   procHandle,
																							   pMemInfo->physContext,
																							   &pMemInfo->virtContext);
    if (pMemInfo->virtAddr == NULL)
	{
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    // commit virtual
    if ( ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpCommitVirtual(hwDeviceExtension,
																			  pMemInfo->virtContext,
																			  pMemInfo->sysPageCount,
																			  0)
																			  == NULL)
	{
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleaseVirtual(hwDeviceExtension, pMemInfo->virtContext);
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

#if defined(IA64)
    sysAddr = MmGetPhysicalAddress(pMemInfo->virtAddr);
    if (osAllocAGPMapping(sysAddr, aperAddr) != RM_OK) {
        osFreeAGPPages(pDev, pAddress, pMemInfo); 
        return RM_ERR_NO_FREE_MEM;
    }
#else
    // apply a win2k kernel workaround for write-combined user mappings 
    if (ClientClass == NV01_ROOT_USER)
    {
        // Dios Mio, forgive me for what I'm about to do ...
        if (RmChangePageAttributeTable(pMemInfo) != RM_OK)
        {
            osFreeAGPPages(pDev, pAddress, pMemInfo); 
            return RM_ERR_NO_FREE_MEM;
        }
    }
#endif

    // verify the buffer is writable (may not be due to a chipset driver bug).
    // This has been seen on a Via 694x when returning from hibernation.
    *(volatile U032 *)pMemInfo->virtAddr = 0xBEEFCAFE;
    if (*(volatile U032 *)pMemInfo->virtAddr != 0xBEEFCAFE)
    {
        DBG_PRINT_STRING_PTR(DEBUGLEVEL_ERRORS,
                            "NVRM: allocated unwritable AGP buffer ", pMemInfo->virtAddr);
        osFreeAGPPages(pDev, pAddress, pMemInfo); 
        return RM_ERR_NO_FREE_MEM;
    }

    // Set our AGP parameters, if they need to be.
    // We don't expect this to ever be needed, since RmSetAgpServices should've
    // handled it already.
    if (!pRmInfo->AGP.AGPLinearStart) {
        pRmInfo->AGP.AGPLinearStart = (VOID_PTR)pMemInfo->virtAddr;

        if (!pRmInfo->AGP.AGPPhysStart && !pRmInfo->AGP.AGPLimit) {
            // should've already been filled in by NvGetAGPBaseLimit()
            pRmInfo->AGP.AGPPhysStart   = aperAddr.LowPart;
            pRmInfo->AGP.AGPLimit       = 0x4000000;        // 64MB
        }

#ifdef DEBUG
        // first allocation should be at the aperture base
        if (aperAddr.LowPart != pRmInfo->AGP.AGPPhysStart) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: first AGP alloc != AGP base\n");
            DBG_BREAKPOINT();        
        }
#endif
    }

    *pAddress = pMemInfo->virtAddr;
    *pMemData = (VOID *)pMemInfo;

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: setup AGP addr    ", *pAddress);

    return RM_OK;
}

RM_STATUS osFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PVOID hwDeviceExtension = pDev->DBmpDeviceExtension;
    PAGP_MEM_INFO pMemInfo = pMemData;
#if defined(IA64)
    PHYSICAL_ADDRESS aperAddr;
#endif

	((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreeVirtual(hwDeviceExtension, pMemInfo->virtContext, pMemInfo->sysPageCount, 0);
	((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleaseVirtual(hwDeviceExtension, pMemInfo->virtContext);
	((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
    ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

#if defined(IA64)
    aperAddr.QuadPart = pMemInfo->aperAddr;
    osFreeAGPMapping(aperAddr);
#endif

    osFreeMem(pMemInfo);

    return RM_OK;
}

#else // WIN32_WINNT >= 0x0500

// NT4 versions just call into nvagp functions

#include <nvagp.h>

RM_STATUS osAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    RM_STATUS rmStatus;

    rmStatus = NvAllocAGPPages(pDev, pAddress, pageCount, ClientClass, pMemData);
    if (rmStatus == RM_OK)
        rmStatus = NvMapAGPPages(pDev, pAddress, ClientClass, *pMemData);

    return rmStatus;
}

RM_STATUS osFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    return NvFreeAGPPages(pDev, pAddress, pMemData);
}

#endif // WIN32_WINNT >= 0x0500

// Translate a Virtual to Physical addr (used to provide the AGP aperture offset)
RM_STATUS osVirtualToPhysicalAddr
(
    VOID* virtaddr,
    VOID** physaddr
)
{
    PHYSICAL_ADDRESS physAddress = MmGetPhysicalAddress(virtaddr);

    *physaddr = (VOID*)((NV_UINTPTR_T)(physAddress.LowPart));

    return RM_OK;
}

RM_STATUS osCalculatePteAdjust
(
    PHWINFO pDev,
    U032    AddressSpace,
    VOID*   Address,
    U032*   pPteAdjust
)
{
    *pPteAdjust = (U032)((SIZE_PTR)Address & RM_PAGE_MASK);

    return RM_OK;
}

// get address information from the linear address
RM_STATUS osGetAddressInfo
(
    PHWINFO pDev,
    U032    unusedParamChID,
    U032    unusedParamSelector,
    VOID**  pLinearAddress,
    U032    Limit,
    VOID**  pAddress,
    NV_ADDRESS_SPACE *pAddressSpace
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    PHYSICAL_ADDRESS pa;
    U032 physFbAddr;
    U032 physicalAddress;
    U032 ramSize;

    // Check to see if we have an address space conflict
    if ((*pAddressSpace != ADDR_UNKNOWN) && (*pAddressSpace != ADDR_SYSMEM))
    {
       return (RM_ERR_BAD_ADDRESS);
    }

    // Convert virtual address into physical address

    pa = MmGetPhysicalAddress(*pLinearAddress);

#ifdef IA64
    //
    // The virtual address of AGP memory returned to the user is mapped
    // to PCI pages on the 82460GX chipset.  Substitute the AGP aperture
    // address for this physical address in this case.

    physicalAddress = osLookupAGPMapping(pa);
#else
    physicalAddress = pa.LowPart;
#endif

    physFbAddr = pDev->Mapping.PhysFbAddr;
    ramSize = pDev->Framebuffer.HalInfo.RamSize;

    // address space type is frame buffer if the physical address lies within the FB range
    if (physicalAddress >= physFbAddr && physicalAddress < physFbAddr + ramSize)
    {
        if (physicalAddress + Limit >= physFbAddr + ramSize)
        {
            //
            // We're straddling fb mem...bomb.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses fbmem boundary ", physicalAddress);
            DBG_BREAKPOINT();
            return (RM_ERR_MULTIPLE_MEMORY_TYPES);
        }

        //
        // Subtract off the start of the framebuffer
        //
        *pLinearAddress = (VOID*)((NV_UINTPTR_T)(physicalAddress - physFbAddr));
        //
        // Turn this into a PNVM dma structure
        //
        *pAddressSpace = ADDR_FBMEM;
    }
    else if (pRmInfo->AGP.AGPLinearStart &&
             physicalAddress >= pRmInfo->AGP.AGPPhysStart &&
             physicalAddress < pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit)
    {
        if (physicalAddress + Limit > pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit)
        {
            //
            // We're straddling agp mem...bomb.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses agp aperture boundary ", physicalAddress);
            DBG_BREAKPOINT();
            return (RM_ERR_MULTIPLE_MEMORY_TYPES);
        }

        // For AGP, just return the Aperture address as the DescAddr, which'll get
        // loaded into the instance memory PTEs
        *pAddressSpace = ADDR_AGPMEM;
        *pLinearAddress = (VOID *)((NV_UINTPTR_T)physicalAddress);
    }

    // otherwise address space type is system    
    else
    {
        // The address space is always system memory
        *pAddressSpace = ADDR_SYSMEM;
    }

    // the resulting address IS the linear address
    *pAddress = *pLinearAddress;

    return (RM_OK);
}

#if !defined(_WIN64)
RM_STATUS osAllocSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    PSYS_MEM_INFO    pMemInfo;
    RM_STATUS        rmStatus;
    VOID             *pageAddr, *userAddr;

    // Since there will be some cleanup needed on the free side
    // create a struct that hooks into VOID * in CLI_MEMORY_INFO

    rmStatus = osAllocMem((VOID **)&pMemInfo, sizeof(SYS_MEM_INFO));
    if (rmStatus != RM_OK)
        return rmStatus;

    pMemInfo->sysAddr = ExAllocatePoolWithTag(NonPagedPool,
                                              (pageCount + 1) << RM_PAGE_SHIFT,
                                              NV_MEMORY_TAG);

    if (pMemInfo->sysAddr == NULL) {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }
    pageAddr = (VOID *)(((NV_UINTPTR_T)pMemInfo->sysAddr + RM_PAGE_MASK) & ~RM_PAGE_MASK);

    if ((pMemInfo->clientClass = ClientClass) == NV01_ROOT_USER) {
        userAddr = osMapUserSpace(pageAddr, &pMemInfo->pMdl,
                                  pageCount << RM_PAGE_SHIFT, MAP_WRITECOMBINE);
        if (userAddr == NULL) {
            ExFreePool(pMemInfo->sysAddr);
            osFreeMem(pMemInfo);
            return RM_ERR_NO_FREE_MEM;
        } else {
           *pAddress = userAddr;
        }
    } else {
       *pAddress = pageAddr;
    }
    *pMemData = (VOID *)pMemInfo;
    return RM_OK;
}

RM_STATUS osFreeSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID *pMemData
)
{
    PSYS_MEM_INFO    pMemInfo = (PSYS_MEM_INFO)pMemData;

    // unmap the memory from user space, if necessary
    if (pMemInfo->clientClass == NV01_ROOT_USER) {
        osUnmapUserSpace(*pAddress, pMemInfo->pMdl);
    }

    // free the memory using the original pointer
    ExFreePool(pMemInfo->sysAddr);

    // free our data struct that kept track of this mapping
    osFreeMem(pMemInfo);

    return RM_OK;
}
#endif !defined(_WIN64)


#if (_WIN32_WINNT < 0x0500)

// WINNT4 handles MmWriteCombined caching type, but it isn't in the DDK!

MEMORY_CACHING_TYPE modeTab[4] = { MmNonCached, MmCached,
                                   0x2, 0x2 };
#else
MEMORY_CACHING_TYPE modeTab[4] = { MmNonCached, MmCached,
                                   MmWriteCombined, MmWriteCombined };
#endif
/* remap IO memory to kernel space */
VOID *osMapKernelSpace(unsigned int start, unsigned int size_bytes, U008 mode)
{
    if (mode & MAP_USER)
        return NULL;
    else
        return osMapIOSpace(start, size_bytes, NULL, (U008)(mode));
}

VOID osUnmapKernelSpace(void *addr, unsigned int size)
{
   osUnmapIOSpace(addr, size, NULL, MAP_KERNEL);
}

/* remap memory to user space */
VOID *osMapUserSpace(VOID *kaddr, VOID **priv, unsigned int size_bytes, U008 mode)
{
    PMDL pMdl;
    VOID *addr;

    // create a mdl that describes the kernel mapping
    pMdl = IoAllocateMdl(kaddr, 
                         size_bytes,  // now in bytes
                         FALSE,
                         FALSE,
                         NULL);
    if (pMdl == NULL)
	{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Cannot allocate MDL\n");
        return NULL;
    }
  
  
    // fill in the physical page array of the MDL
    MmBuildMdlForNonPagedPool(pMdl);

    // create the user mapping to these pages
#if (_WIN32_WINNT < 0x0500)
    addr = MmMapLockedPages(pMdl, UserMode);
#else // Win2k doesn't want us using MmMapLockedPages, use MmMapLockedPagesSpecifyCache instead
    addr = MmMapLockedPagesSpecifyCache(pMdl, UserMode, modeTab[mode & 0x3],
                                        NULL, FALSE, HighPagePriority);
#endif
    if (addr == NULL)
    {
       IoFreeMdl(pMdl);
       pMdl = NULL;
       return NULL;
    }

	*priv = (VOID *) pMdl;
    return addr;
}

VOID osUnmapUserSpace(VOID *uaddr, VOID *priv)
{
    PMDL pMdl = (PMDL) priv;

    MmUnmapLockedPages(uaddr, pMdl);
    IoFreeMdl(pMdl);
	priv = (VOID *) NULL;
}

/* map I/O space to user or kernel space */
VOID *osMapIOSpace(U032 start, U032 size_bytes, VOID **priv, U008 mode)
{
    PHYSICAL_ADDRESS physaddr;
    PMDL pMdl;
    VOID *kaddr, *uaddr;

    physaddr.HighPart = 0;
    physaddr.LowPart  = start;

    kaddr = MmMapIoSpace(physaddr, size_bytes, modeTab[mode & 0x3]);

    if (kaddr == NULL)
        return NULL;

    if (mode & MAP_USER)
    {
        uaddr = osMapUserSpace(kaddr, priv, size_bytes, mode);

        if (uaddr == NULL)
        {
            MmUnmapIoSpace(kaddr, size_bytes);
            return NULL;
        }
        return uaddr;
    }
    else
    {
        return kaddr;
    }
}

VOID osUnmapIOSpace(VOID *addr, U032 size_bytes, void *priv, U008 mode)
{
    PMDL pMdl;
    VOID *kaddr;

    if (mode & MAP_USER)
    {
        pMdl = (PMDL) priv;
        kaddr = (char *)pMdl->StartVa + pMdl->ByteOffset;
        osUnmapUserSpace(addr, priv);
    }
    else
    {
        kaddr = addr;
    }
    MmUnmapIoSpace(kaddr, size_bytes);

}

RM_STATUS osSetMemRange(U032 start, U032 size_bytes, U008 mode)
{
    PHYSICAL_ADDRESS physaddr;
    VOID *kaddr;

    if (mode != MEM_WRITECOMBINE)
        return RM_ERROR;

    // Rely on side effect of this routine for now

    physaddr.HighPart = 0;
    physaddr.LowPart  = start;

    kaddr = MmMapIoSpace(physaddr, size_bytes, 0x2);

    if (kaddr == NULL)
        return RM_ERROR;

    MmUnmapIoSpace(kaddr, size_bytes);

    return RM_OK;
}

VOID *osAllocContigPages(U032 size)
{
    PHYSICAL_ADDRESS physaddr;
    physaddr.HighPart = 0;
    physaddr.LowPart  = -1;
    return (VOID *) MmAllocateContiguousMemory(size, physaddr);
}

VOID osFreeContigPages(VOID *addr)
{
    MmFreeContiguousMemory(addr);
}


U032 osGetKernPhysAddr(VOID *kern_virt_addr)
{
    PHYSICAL_ADDRESS physaddr;
    physaddr = MmGetPhysicalAddress(kern_virt_addr);
    return (physaddr.LowPart);
}

RM_STATUS osGetAGPPhysAddr(PHWINFO pDev, VOID *base, U032 index, U032 *paddr)
{
    VOID *vaddr = (VOID *) ((U008 *) base + (index << RM_PAGE_SHIFT));
    *paddr = osGetKernPhysAddr(vaddr);
    if (*paddr == (U032) 0x0) return RM_ERROR;
    return RM_OK;
}

RM_STATUS osAllocPool(VOID **addr, unsigned int size_bytes)
{
    *addr = ExAllocatePoolWithTag(NonPagedPool, size_bytes, NV_MEMORY_TAG);
    if (*addr == NULL) return RM_ERROR;
    return RM_OK;
}

RM_STATUS osFreePool(VOID *addr)
{
    ExFreePool(addr);
    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Debugging support.
//
//---------------------------------------------------------------------------

#if DBG

// The current debug display level 
//
// Best to leave it above setup and trace messages, but below warnings and error messages
//
int cur_debuglevel = DBG_LEVEL_DEFAULTS;    // all modules set to warning level

VOID osDbgBreakPoint
(
    void
)
{
    DbgBreakPoint();
}

VOID osDbgPrintf_va(
    int     module,
    int     debuglevel,
    const char *printf_format,
    va_list arglist)
{
    int     moduleValue = cur_debuglevel;
    char    nv_error_string[MAX_ERROR_STRING];
    char    *p = nv_error_string;
    int     chars_written;

    // get the module
    // put the module we want in the first 2 bits
    moduleValue = moduleValue >> (module * 2);

    // get the value of those two bits
    // mask off the last 30 bits
    moduleValue = moduleValue & 0x00000003;

    if (debuglevel >= moduleValue)
    {
        chars_written = nvDbgSprintf(p, printf_format, arglist);

        DbgPrint(p);
   }
}

#endif // DBG

#if (_WIN32_WINNT < 0x500) && defined(NTRM)
//
// Signals the nVidia service (NVSVC) via the "NVModeSwitchEvent" that a device switch hotkey has been pressed.
//
VOID RmSignalHotKeyEvent()
{
    SignalModeSwitchEvent();
}
#endif

// end of os.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\smp.c ===
/******************************************************************************
*
*   Module: smp.c
*
*   Description:
*       This module contains SMP-safe versions of calls to functions that
*   contain critical code.
*
*       Each SMP-safe wrapper has the same name as the function it replaces
*   prepended with "smp".  Each requires a macro, to be included in those files
*   that call the "wrapped" functions, that replaces the call to the original
*   function with a call to the wrapper.  Currently, the header file that
*   contains these macros is called "smp.h".  The wrapper function packages
*   up the args into a single, custom arg struct, then calls
*   VideoPortSynchronizeExecution(), specifying a pointer to the arg struct
*   and a callback function.  The callback has the same name as the original
*   function prepended with "smpCallback".  The callback calls the original
*   function with the correct members of the arg struct.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <miniport.h>
#include <ntddvdeo.h>
#include <video.h>
#include <nvrm.h>
#include <os.h>

// external prototypes
RM_STATUS fifoUpdateObjectInstance(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
);
RM_STATUS fifoDeleteObjectInstance(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID
);
RM_STATUS fifoResetChannelState(
    PHWINFO pDev,
    U032 ChID
);
RM_STATUS fifoDeleteSubchannelContextEntry(
    PHWINFO pDev,
    POBJECT Object
);
RM_STATUS nvHalFbSetAllocParameters(
    PHWINFO pDev,
    PFBALLOCINFO pFbAllocInfo
);
RM_STATUS nvHalFbFree(
    PHWINFO pDev,
    U032 hwResId
);
VOID VBlankDeleteCallback(
    PHWINFO pDev,
    U032 Head,
    PVBLANKCALLBACK Callback
);
RM_STATUS classDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
);
RM_STATUS nvagp_AllocAGPBitmap
(
    PHWINFO pDev,
    U032 Size,
    U032 *Offset
);
VOID nvagp_FreeAGPBitmap
(
    PHWINFO pDev,
    U032 Offset,
    U032 PageCount
);
RM_STATUS nvagp_InsertGARTEntries
(
    PHWINFO pDev,
    U032 Index,
    U032 PageCount,
    U032 Data
);
RM_STATUS nvagp_FlushGARTEntries
(
    PHWINFO pDev
);
RM_STATUS fbAllocInstMemAlign
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size,
    U032    Align		
);
RM_STATUS fbAllocInstMem
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size
);
RM_STATUS fbFreeInstMem
(
    PHWINFO pDev,
    U032    Instance,
    U032    Size
);

// local prototypes
BOOLEAN smpCallbackFifoUpdateObjectInstance(PVOID object);
BOOLEAN smpCallbackFifoDeleteObjectInstance(PVOID object);
BOOLEAN smpCallbackFifoResetChannelState(PVOID object);
BOOLEAN smpCallbackFifoDeleteSubchannelContextEntry(PVOID object);
BOOLEAN smpCallbackMcService(PVOID object);
BOOLEAN smpCallbackNvHalFbSetAllocParameters(PVOID object);
BOOLEAN smpCallbackNvHalFbFree(PVOID object);
BOOLEAN smpCallbackVBlankDeleteCallback(PVOID object);
BOOLEAN smpCallbackClassDirectSoftwareMethod(PVOID object);
BOOLEAN smpCallbackNvagpAllocAGPBitmap(PVOID object);
BOOLEAN smpCallbackNvagpFreeAGPBitmap(PVOID object);
BOOLEAN smpCallbackNvagpInsertGARTEntries(PVOID object);
BOOLEAN smpCallbackNvagpFlushGARTEntries(PVOID object);
BOOLEAN smpCallbackFbAllocInstMemAlign(PVOID object);
BOOLEAN smpCallbackFbAllocInstMem(PVOID object);
BOOLEAN smpCallbackFbFreeInstMem(PVOID object);

// arg strucs
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    ChID;
    U032    Instance;
} ARGS_FifoUpdateObjectInstance, *PARGS_FifoUpdateObjectInstance;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    ChID;
} ARGS_FifoDeleteObjectInstance, *PARGS_FifoDeleteObjectInstance;
typedef struct
{
    PHWINFO pDev;
    U032    ChID;
} ARGS_FifoResetChannelState, *PARGS_FifoResetChannelState;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
} ARGS_FifoDeleteSubchannelContextEntry, *PARGS_FifoDeleteSubchannelContextEntry;
typedef struct
{
    PHWINFO pDev;
} ARGS_McService, *PARGS_McService;
typedef struct
{
    PHWINFO pDev;
    PFBALLOCINFO pFbAllocInfo;
} ARGS_NvHalFbSetAllocParameters, *PARGS_NvHalFbSetAllocParameters;
typedef struct
{
    PHWINFO pDev;
    U032    hwResId;
} ARGS_NvHalFbFree, *PARGS_NvHalFbFree;
typedef struct
{
    PHWINFO pDev;
    U032 Head;
    PVBLANKCALLBACK Callback;
} ARGS_VBlankDeleteCallback, *PARGS_VBlankDeleteCallback;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    Offset;
    V032    Data;
} ARGS_ClassDirectSoftwareMethod, *PARGS_ClassDirectSoftwareMethod;
typedef struct
{
    PHWINFO pDev;
    U032 Size;
    U032 *Offset;
} ARGS_NvagpAllocAGPBitmap,  *PARGS_NvagpAllocAGPBitmap;
typedef struct
{
    PHWINFO pDev;
    U032 Offset;
    U032 PageCount;
} ARGS_NvagpFreeAGPBitmap,  *PARGS_NvagpFreeAGPBitmap;
typedef struct
{
    PHWINFO pDev;
    U032 Index;
    U032 PageCount;
    U032 Data;
} ARGS_NvagpInsertGARTEntries, *PARGS_NvagpInsertGARTEntries;
typedef struct
{
    PHWINFO pDev;
} ARGS_NvagpFlushGARTEntries, *PARGS_NvagpFlushGARTEntries;
typedef struct
{
    PHWINFO pDev;
    U032   *Instance;
    U032    Size;
    U032    Align;
} ARGS_FbAllocInstMemAlign, *PARGS_FbAllocInstMemAlign;
typedef struct
{
    PHWINFO pDev;
    U032   *Instance;
    U032    Size;
} ARGS_FbAllocInstMem, *PARGS_FbAllocInstMem;
typedef struct
{
    PHWINFO pDev;
    U032    Instance;
    U032    Size;
} ARGS_FbFreeInstMem, *PARGS_FbFreeInstMem;

// critical code wrappers

// critical code wrapper for fifoUpdateObjectInstance()
RM_STATUS smpFifoUpdateObjectInstance
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
)
{
    BOOLEAN bStatus;
    ARGS_FifoUpdateObjectInstance args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.ChID = ChID;
    args.Instance = Instance;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoUpdateObjectInstance...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoUpdateObjectInstance,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoUpdateObjectInstance unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoUpdateObjectInstance()

RM_STATUS smpFifoDeleteObjectInstance
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID
)
{
    BOOLEAN bStatus;
    ARGS_FifoDeleteObjectInstance args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.ChID = ChID;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoDeleteObjectInstance...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoDeleteObjectInstance,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoDeleteObjectInstance unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoDeleteObjectInstance()

// critical code wrapper for fifoResetChannelState()
RM_STATUS smpFifoResetChannelState
(
    PHWINFO pDev,
    U032    ChID
)
{
    BOOLEAN bStatus;
    ARGS_FifoResetChannelState args;

    // load the arg struct
    args.pDev = pDev;
    args.ChID = ChID;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoResetChannelState...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoResetChannelState,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoResetChannelState unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoResetChannelState()

// critical code wrapper for fifoDeleteSubchannelContextEntry()
RM_STATUS smpFifoDeleteSubchannelContextEntry
(
    PHWINFO pDev,
    POBJECT Object
)
{
    BOOLEAN bStatus;
    ARGS_FifoDeleteSubchannelContextEntry args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoDeleteSubchannelContextEntry...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoDeleteSubchannelContextEntry,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoDeleteSubchannelContextEntry unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoDeleteSubchannelContextEntry()

// critical code wrapper for nvHalFbSetAllocParameters()
RM_STATUS smpNvHalFbSetAllocParameters
(
    PHWINFO pDev,
    PFBALLOCINFO pFbAllocInfo
)
{
    RM_STATUS rmStatus;
    BOOLEAN bStatus;    
    ARGS_NvHalFbSetAllocParameters args;

    //
    // This wrapper only deploys if we have hardware resources
    // associated with the specified block of local memory.
    //
    if (pFbAllocInfo->hwResId)
    {
        // load the arg struct
        args.pDev = pDev;
        args.pFbAllocInfo = pFbAllocInfo;

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvHalFbSetAllocParameters...\n");

        bStatus = VideoPortSynchronizeExecution(
            pDev->DBmpDeviceExtension,
            VpMediumPriority,
            smpCallbackNvHalFbSetAllocParameters,
            (PVOID)&args
            );

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvHalFbSetAllocParameters unsynchronized\n");

        rmStatus = (bStatus) ? RM_OK : RM_ERROR;
    }
    else
    {
        //
        // No MP issues in this case...
        //
        rmStatus = nvHalFbSetAllocParameters(pDev, pFbAllocInfo);
    }

    return (rmStatus);

} // end of smpNvHalFbSetAllocParameters()

// critical code wrapper for nvHalFbFree()
RM_STATUS smpNvHalFbFree
(
    PHWINFO pDev,
    U032 hwResId
)
{
    RM_STATUS rmStatus;
    BOOLEAN bStatus;    
    ARGS_NvHalFbFree args;

    //
    // This wrapper only deploys if we have hardware resources
    // associated with the specified block of local memory.
    //
    if (hwResId)
    {
        // load the arg struct
        args.pDev = pDev;
        args.hwResId = hwResId;

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvHalFbFree...\n");

        bStatus = VideoPortSynchronizeExecution(
            pDev->DBmpDeviceExtension,
            VpMediumPriority,
            smpCallbackNvHalFbFree,
            (PVOID)&args
            );

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvHalFbFree unsynchronized\n");
        rmStatus = (bStatus) ? RM_OK : RM_ERROR;
    }
    else
    {
        //
        // No MP issues in this case...
        //
        rmStatus = nvHalFbFree(pDev, hwResId);
    }

    return (rmStatus);

} // end of smpNvHalFbFree()

// critical code wrapper for VBlankDeleteCallback()
RM_STATUS smpVBlankDeleteCallback
(
    PHWINFO pDev,
    U032 Head,
    PVBLANKCALLBACK Callback
)
{
    BOOLEAN bStatus;    
    ARGS_VBlankDeleteCallback args;

    // load the arg struct
    args.pDev = pDev;
    args.Head = Head;
    args.Callback = Callback;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpVBlankDeleteCallback...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackVBlankDeleteCallback,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpVBlankDeleteCallback unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpVBlankDeleteCallback()

// critical code wrapper for ClassDirectSoftwareMethod()
RM_STATUS smpClassDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032 Offset,
    U032 Data
)
{
    BOOLEAN bStatus;    
    ARGS_ClassDirectSoftwareMethod args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.Offset = Offset;
    args.Data = Data;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpClassDirectSoftwareMethod...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackClassDirectSoftwareMethod,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpClassDirectSoftwareMethod unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpClassDirectSoftwareMethod()

// critical code wrapper for nvagp_AllocAGPBitmap
RM_STATUS smpNvagpAllocAGPBitmap
(
    PHWINFO pDev,
    U032 Size,
    U032 *Offset
)
{
    BOOLEAN bStatus;    
    ARGS_NvagpAllocAGPBitmap args;

    // load the arg struct
    args.pDev = pDev;
    args.Size = Size;
    args.Offset = Offset;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvagpAllocAGPBitmap...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackNvagpAllocAGPBitmap,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvagpAllocAGPBitmap unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpNvagpAllocAGPBitmap

// critical code wrapper for nvagp_FreeAGPBitmap
RM_STATUS smpNvagpFreeAGPBitmap
(
    PHWINFO pDev,
    U032 Offset,
    U032 PageCount
)
{
    BOOLEAN bStatus;    
    ARGS_NvagpFreeAGPBitmap args;

    // load the arg struct
    args.pDev = pDev;
    args.Offset = Offset;
    args.PageCount = PageCount;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvagpFreeAGPBitmap...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackNvagpFreeAGPBitmap,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvagpFreeAGPBitmap unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpNvagpFreeAGPBitmap

// critical code wrapper for nvagp_InsertGARTEntries
RM_STATUS smpNvagpInsertGARTEntries
(
    PHWINFO pDev,
    U032 Index,
    U032 PageCount,
    U032 Data
)
{
    BOOLEAN bStatus;    
    ARGS_NvagpInsertGARTEntries args;

    // load the arg struct
    args.pDev = pDev;
    args.Index = Index;
    args.PageCount = PageCount;
    args.Data = Data;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvagpInsertGARTEntries...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackNvagpInsertGARTEntries,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvagpInsertGARTEntries unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpNvagpInsertGARTEntries

// critical code wrapper for nvagp_FlushGARTEntries
RM_STATUS smpNvagpFlushGARTEntries
(
    PHWINFO pDev
)
{
    BOOLEAN bStatus;    
    ARGS_NvagpFlushGARTEntries args;

    // load the arg struct
    args.pDev = pDev;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvagpFlushGARTEntries...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackNvagpFlushGARTEntries,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvagpFlushGARTEntries unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpNvagpFlushGARTEntries

// critical code wrapper for fbAllocInstMemAlign()
RM_STATUS smpFbAllocInstMemAlign
(
    PHWINFO pDev,
    U032 *Instance,
    U032 Size,
    U032 Align
)
{
    BOOLEAN bStatus;    
    ARGS_FbAllocInstMemAlign args;

    // load the arg struct
    args.pDev = pDev;
    args.Instance = Instance;
    args.Size = Size;
    args.Align = Align;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFbAllocInstMemAlign...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFbAllocInstMemAlign,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFbAllocInstMemAlign unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFbAllocInstMemAlign()

// critical code wrapper for fbAllocInstMem()
RM_STATUS smpFbAllocInstMem
(
    PHWINFO pDev,
    U032 *Instance,
    U032 Size
)
{
    BOOLEAN bStatus;    
    ARGS_FbAllocInstMem args;

    // load the arg struct
    args.pDev = pDev;
    args.Instance = Instance;
    args.Size = Size;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFbAllocInstMem...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFbAllocInstMem,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFbAllocInstMem unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFbAllocInstMemAlign()

// critical code wrapper for fbFreeInstMem()
RM_STATUS smpFbFreeInstMem
(
    PHWINFO pDev,
    U032 Instance,
    U032 Size
)
{
    BOOLEAN bStatus;    
    ARGS_FbFreeInstMem args;

    // load the arg struct
    args.pDev = pDev;
    args.Instance = Instance;
    args.Size = Size;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFbFreeInstMem...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFbFreeInstMem,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFbFreeInstMem unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFbFreeInstMemAlign()

// critical code callbacks

// critical code callback for fifoUpdateObjectInstance()
BOOLEAN smpCallbackFifoUpdateObjectInstance(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoUpdateObjectInstance pArgs = (PARGS_FifoUpdateObjectInstance)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoUpdateObjectInstance...\n");

    rmStatus = fifoUpdateObjectInstance(
        pArgs->pDev,
        pArgs->Object,
        pArgs->ChID,
        pArgs->Instance
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoUpdateObjectInstance\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;
    
} // end of smpCallbackFifoUpdateObjectInstance()

BOOLEAN smpCallbackFifoDeleteObjectInstance(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoDeleteObjectInstance pArgs = (PARGS_FifoDeleteObjectInstance)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoDeleteObjectInstance...\n");

    rmStatus = fifoDeleteObjectInstance(
        pArgs->pDev,
        pArgs->Object,
        pArgs->ChID
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoDeleteObjectInstance\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;
    
} // end of smpCallbackFifoDeleteObjectInstance()

BOOLEAN smpCallbackFifoResetChannelState(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoResetChannelState pArgs = (PARGS_FifoResetChannelState)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoResetChannelState...\n");

    rmStatus = fifoResetChannelState(
        pArgs->pDev,
        pArgs->ChID
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoResetChannelState\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFifoResetChannelState()

BOOLEAN smpCallbackFifoDeleteSubchannelContextEntry(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoDeleteSubchannelContextEntry pArgs = (PARGS_FifoDeleteSubchannelContextEntry)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoDeleteSubchannelContextEntry...\n");

    rmStatus = fifoDeleteSubchannelContextEntry(
        pArgs->pDev,
        pArgs->Object
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoDeleteSubchannelContextEntry\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFifoDeleteSubchannelContextEntry()

BOOLEAN smpCallbackNvHalFbSetAllocParameters(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_NvHalFbSetAllocParameters pArgs = (PARGS_NvHalFbSetAllocParameters)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvHalFbSetAllocParameters...\n");

    rmStatus = nvHalFbSetAllocParameters(pArgs->pDev, pArgs->pFbAllocInfo);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvHalFbSetAllocParameters\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackNvHalFbSetAllocParameters

BOOLEAN smpCallbackNvHalFbFree(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_NvHalFbFree pArgs = (PARGS_NvHalFbFree)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvHalFbFree...\n");

    rmStatus = nvHalFbFree(pArgs->pDev, pArgs->hwResId);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvHalFbFree\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackNvHalFbFree

BOOLEAN smpCallbackVBlankDeleteCallback(PVOID pvArgs)
{
    PARGS_VBlankDeleteCallback pArgs = (PARGS_VBlankDeleteCallback)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized VBlankDeleteCallback...\n");

    VBlankDeleteCallback(pArgs->pDev, pArgs->Head, pArgs->Callback);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized VBlankDeleteCallback\n");

    return RM_OK;

} // end of smpCallbackVBlankDeleteCallback

BOOLEAN smpCallbackClassDirectSoftwareMethod(PVOID pvArgs)
{
    PARGS_ClassDirectSoftwareMethod pArgs = (PARGS_ClassDirectSoftwareMethod)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized classDirectSoftwareMethod...\n");

    rmStatus = classDirectSoftwareMethod(pArgs->pDev, pArgs->Object, pArgs->Offset, pArgs->Data);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized classDirectSoftwareMethod\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackClassDirectSoftwareMethod

BOOLEAN smpCallbackNvagpAllocAGPBitmap(PVOID pvArgs)
{
    PARGS_NvagpAllocAGPBitmap pArgs = (PARGS_NvagpAllocAGPBitmap)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvagp_AllocAGPBitmap...\n");

    rmStatus = nvagp_AllocAGPBitmap(pArgs->pDev, pArgs->Size, pArgs->Offset);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvagp_AllocAGPBitmap\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpNvagpAllocAGPBitmap

BOOLEAN smpCallbackNvagpFreeAGPBitmap(PVOID pvArgs)
{
    PARGS_NvagpFreeAGPBitmap pArgs = (PARGS_NvagpFreeAGPBitmap)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvagp_FreeAGPBitmap...\n");

    nvagp_FreeAGPBitmap(pArgs->pDev, pArgs->Offset, pArgs->PageCount);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvagp_FreeAGPBitmap\n");

    return RM_OK;

} // end of smpNvagpFreeAGPBitmap

BOOLEAN smpCallbackNvagpInsertGARTEntries(PVOID pvArgs)
{
    PARGS_NvagpInsertGARTEntries pArgs = (PARGS_NvagpInsertGARTEntries)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvagp_InsertGARTEntries...\n");

    rmStatus = nvagp_InsertGARTEntries(pArgs->pDev, pArgs->Index, pArgs->PageCount, pArgs->Data);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvagp_InsertGARTEntries\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpNvagpInsertGARTEntries

BOOLEAN smpCallbackNvagpFlushGARTEntries(PVOID pvArgs)
{
    PARGS_NvagpFlushGARTEntries pArgs = (PARGS_NvagpFlushGARTEntries)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvagp_FlushGARTEntries...\n");

    rmStatus = nvagp_FlushGARTEntries(pArgs->pDev);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvagp_FlushGARTEntries\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpNvagpFlushGARTEntries

BOOLEAN smpCallbackFbAllocInstMemAlign(PVOID pvArgs)
{
    PARGS_FbAllocInstMemAlign pArgs = (PARGS_FbAllocInstMemAlign)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fbAllocInstMemAlign...\n");

    rmStatus = fbAllocInstMemAlign(pArgs->pDev, pArgs->Instance, pArgs->Size, pArgs->Align);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fbAllocInstMemAlign\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFbAllocInstMemAlign

BOOLEAN smpCallbackFbAllocInstMem(PVOID pvArgs)
{
    PARGS_FbAllocInstMem pArgs = (PARGS_FbAllocInstMem)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fbAllocInstMem...\n");

    rmStatus = fbAllocInstMem(pArgs->pDev, pArgs->Instance, pArgs->Size);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fbAllocInstMem\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFbAllocInstMem

BOOLEAN smpCallbackFbFreeInstMem(PVOID pvArgs)
{
    PARGS_FbFreeInstMem pArgs = (PARGS_FbFreeInstMem)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fbFreeInstMem...\n");

    rmStatus = fbFreeInstMem(pArgs->pDev, pArgs->Instance, pArgs->Size);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fbFreeInstMem\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFbFreeInstMem

// end of smp.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osvp.c ===
/******************************************************************************
*
*   Module: osvp.c
*
*   Description:
*       This module contains OS services provided to the RM kernel.  These
*       versions are implemented using the Video Port services.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <miniport.h>
#include <ntddvdeo.h>
#include <video.h>
#include <dderror.h>
#include <nvrm.h>
#include <os.h>
#include <nvos.h>

#define USE_CURRENT_CONTEXT -1

#ifdef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT >= 0x0500)

// video port service implementation

#if (_WIN32_WINNT >= 0x0500)

RM_STATUS osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    VP_STATUS vpStatus = NO_ERROR;
    U008* pMem;
    VOID* hwDeviceExtension = (VOID*)1;

#ifndef DBG

    vpStatus = VideoPortAllocateBuffer
    (
        hwDeviceExtension,
        Size + 4,
        pAddress
    );
    if (vpStatus == NO_ERROR)
    {
        //pDev.Statistics.MemAlloced += Size;
        **(U032 **)pAddress           = Size;
        *(U032 *)pAddress            += 4;
    }
        
#else

    Size += 12;
    vpStatus = VideoPortAllocateBuffer
    (
        hwDeviceExtension,
        Size,
        pAddress
    );
    if (vpStatus == NO_ERROR)
    {
        // memory allocation tracking
        osLogMemAlloc(*pAddress, Size);

        //pDev.Statistics.MemAlloced           += Size - 12;
        **(U032 **)pAddress                     = Size;
        *(U032 *)(*(U032 *)pAddress + 4)        = NV_MARKER1;
        *(U032 *)(*(U032 *)pAddress + Size - 4) = NV_MARKER2;
        *(U032 *)pAddress += 8;
        pMem = (U008 *)*pAddress;
        Size -= 12;
        while (Size--)
            *pMem++ = 0x69;
    }
            
#endif // DBG

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERR_NO_FREE_MEM;
    
}

RM_STATUS osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status = RM_OK;
    U032      Size;
    VOID* hwDeviceExtension = (VOID*)1;
    
#ifndef DBG

    pAddress = (VOID *)((U032)pAddress - 4);
    Size     = *(U032 *)pAddress;
    
#else

    pAddress = (VOID *)((U032)pAddress - 8);
    Size     = *(U032 *)pAddress;
    if (*(U032 *)((U032)pAddress + 4) != NV_MARKER1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Invalid address to osFreeMem\n");
        DBG_BREAKPOINT();
    }
    if (*(U032 *)((U032)pAddress + Size - 4) != NV_MARKER2)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Memory overrun in structure to osFreeMem\n");
        DBG_BREAKPOINT();
        return (RM_ERR_MEM_NOT_FREED);
    }
    *(U032 *)((U032)pAddress + 4)        = 'DAED';
    *(U032 *)((U032)pAddress + Size - 4) = 'DEAD';
    Size -= 12;

    // memory allocation tracking
    osUnlogMemAlloc(pAddress);

#endif // DBG  
  
    VideoPortReleaseBuffer(
        hwDeviceExtension,
        pAddress
    );

    //pDev.Statistics.MemAlloced -= Size;

    return status;
    
}

#endif // Win2K

typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_LOCK_HELD               0x0200
#define MDL_SCATTER_GATHER_VA       0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000
#define MDL_64_BIT_VA               0x8000

RM_STATUS osLockUserMem
(
    PHWINFO             pDev,
    U032                ChID,
    U032                Selector,
    U032                Offset,
    U032                DmaAddress,
    NV_ADDRESS_SPACE*   DmaAddressSpace,
    U032                DmaLength,
    U032                PageCount,
    U032*               PageArray,
    U032*               pLinAddr,
    U032*               pLockHandle
)
{
    RM_STATUS rmStatus;
    PMDL pMdl = 0;
    ULONG i;
    STATUS_BLOCK vrpStatus;
    VIDEO_REQUEST_PACKET vrp;
    PULONG mdlPageArray;

    // map the buffer
    *pLinAddr = DmaAddress;

    //
    // If we're asking to lock video memory, let's just build up the PTE's and assume
    // that the caller has real control over video memory (such as DirectDraw or the
    // display driver).
    //
    if (*DmaAddressSpace == ADDR_FBMEM)
    {
        //
        // This is hardcoded assuming zero = start of fb
        //
        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (*pLinAddr + (i * RM_PAGE_SIZE)) | 3;
        }
    }
    else
    {
        // fill a VRP with the buffer information
        vrpStatus.Status = 0;    
        vrpStatus.Information = 0;    
        vrp.IoControlCode = 0;
        vrp.StatusBlock = &vrpStatus;    
        vrp.InputBuffer = (PVOID)DmaAddress;    
        vrp.InputBufferLength = DmaLength;
        vrp.OutputBuffer = NULL;    
        vrp.OutputBufferLength = 0;

        // lock the buffer's pages
        if (
            VideoPortLockPages(
                pDev->DBmpDeviceExtension,
                &vrp,
                NULL,
                NULL,
                VideoPortDmaInitOnly
            )
        )
        {
            // save the MDL pointer
            *pLockHandle = (U032)vrp.OutputBuffer;

            // load the PTE array with physical addresses of the page-aligned buffer
            pMdl = (PMDL)VideoPortGetMdl(
                pDev->DBmpDeviceExtension, 
                (PDMA)pLockHandle
            );
            if (pMdl != NULL)
            {
                // extract the physical address from the MDL into the PTE array
                mdlPageArray = (PULONG)(pMdl + 1);
                for (i = 0; i < PageCount; i++)
                {
                    PageArray[i] = mdlPageArray[i] | 3;
                }
            }
            else 
            {
                VideoPortUnlockPages(pDev->DBmpDeviceExtension, (PDMA)pLockHandle);
                rmStatus = RM_ERROR;
            }
        }
        else 
        {
            rmStatus = RM_ERROR;
        }
    }

    return rmStatus;    
}

RM_STATUS osUnlockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    VOID*            LinAddr,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    U032             LockHandle,
    U032             DirtyFlag
)
{
    BOOLEAN status = TRUE;

    //
    // If we're asking to unlock video memory, we're assuming the caller (probably
    // direct draw)  has complete control of video memory, and therefore knows what
    // is locked/unlocked.  No need to do anything.
    //
    if (DmaAddressSpace != ADDR_FBMEM)
    {
        // otherwise, unmap locked pages, unlock pages, and free the MDL
        status = VideoPortUnlockPages(
            pDev->DBmpDeviceExtension,
            (PDMA)&LockHandle
        );
    }

    return (status) ? RM_OK : RM_ERROR;
}

//#endif // (_WIN32_WINNT >= 0x0500)
#endif // VIDEO_PORT_IMPLEMENTATION

RM_STATUS osMapPciMemoryUser( 
    PHWINFO pDev,
    U032 busAddress, 
    U032 length,
    VOID** pVirtualAddress
) 
{
    VP_STATUS vpStatus = NO_ERROR;
    U032 mapFlags;
    PHYSICAL_ADDRESS busPhysicalAddress; 

#if (_WIN32_WINNT >= 0x0500)
    mapFlags = VIDEO_MEMORY_SPACE_P6CACHE;
#else
    mapFlags = VIDEO_MEMORY_SPACE_USER_MODE;
#endif

    // construct an NT physical address from the requested bus-relative address
    busPhysicalAddress.HighPart = 0x00000000;
    busPhysicalAddress.LowPart = busAddress;

    // flag the video port to map into the current context
    *pVirtualAddress = (VOID*)USE_CURRENT_CONTEXT;

    // map the PCI memory into user mode
    vpStatus = VideoPortMapMemory(
        pDev->DBmpDeviceExtension,
        busPhysicalAddress,
        &length,
        &mapFlags,
        pVirtualAddress
    );
    
    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;

}

RM_STATUS osUnmapPciMemoryUser(
    PHWINFO pDev,
    VOID* virtualAddress
)
{
    VP_STATUS vpStatus = NO_ERROR;

    VideoPortUnmapMemory(
        pDev->DBmpDeviceExtension,
        virtualAddress,
        (VOID*)USE_CURRENT_CONTEXT
    );

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;

}

#if defined(_WIN64)

#define MAX_DMA_LENGTH   (2*1024*1024)

RM_STATUS osInitDmaAdapter
(
    PHWINFO pDev
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS rmStatus = RM_OK;
    VP_DEVICE_DESCRIPTION deviceDescription = {
        TRUE,          // ScatterGather;
        TRUE,          // Dma32BitAddresses
        FALSE,         // Dma64BitAddresses
        MAX_DMA_LENGTH // MaximumLength
    };

    pOsHwInfo->dmaAdapter = VideoPortGetDmaAdapter(pDev->DBmpDeviceExtension,
                                                   &deviceDescription);
    if(pOsHwInfo->dmaAdapter == NULL)
        return RM_ERROR;
    else
        return RM_OK;
}

RM_STATUS osAllocSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    PWINNTHWINFO     pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PSYS_MEM_INFO    pMemInfo;
    PHYSICAL_ADDRESS logicalAddr;
    RM_STATUS        rmStatus;
    VOID             *pageAddr, *userAddr;

    // Since there will be some cleanup needed on the free side
    // create a struct that hooks into VOID * in CLI_MEMORY_INFO

    rmStatus = osAllocMem((VOID **)&pMemInfo, sizeof(SYS_MEM_INFO));
    if (rmStatus != RM_OK)
        return rmStatus;

    pMemInfo->sysAddr = VideoPortAllocateCommonBuffer(pDev->DBmpDeviceExtension,
                                                      pOsHwInfo->dmaAdapter,
                                                      (pageCount + 1) << RM_PAGE_SHIFT,
                                                      &logicalAddr,
                                                      TRUE,
                                                      &pMemInfo->length);
    if (pMemInfo->sysAddr == NULL) {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }
    pMemInfo->logicalAddr = logicalAddr.QuadPart;
    pageAddr = (VOID *)(((NV_UINTPTR_T)pMemInfo->sysAddr + RM_PAGE_MASK) & ~RM_PAGE_MASK);
    pMemInfo->physAddr = (pMemInfo->logicalAddr + RM_PAGE_MASK) & ~RM_PAGE_MASK;

    if ((pMemInfo->clientClass = ClientClass) == NV01_ROOT_USER) {
        userAddr = osMapUserSpace(pageAddr, &pMemInfo->pMdl,
                                  pageCount << RM_PAGE_SHIFT, MAP_CACHED);
        if (userAddr == NULL) {
            VideoPortReleaseCommonBuffer(pDev->DBmpDeviceExtension,
                                         pOsHwInfo->dmaAdapter,
                                         pMemInfo->length,
                                         logicalAddr,
                                         pMemInfo->sysAddr,
                                         TRUE);
            osFreeMem(pMemInfo);
            return RM_ERR_NO_FREE_MEM;
        } else {
           *pAddress = userAddr;
        }
    } else {
       *pAddress = pageAddr;
    }
    *pMemData = (VOID *)pMemInfo;
    return RM_OK;
}

RM_STATUS osFreeSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID *pMemData
)
{
    PWINNTHWINFO     pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PSYS_MEM_INFO    pMemInfo = (PSYS_MEM_INFO)pMemData;
    PHYSICAL_ADDRESS logicalAddr;

    // unmap the memory from user space, if necessary
    if (pMemInfo->clientClass == NV01_ROOT_USER) {
        osUnmapUserSpace(*pAddress, pMemInfo->pMdl);
    }

    // free the memory using the original pointer and actual allocated length
    logicalAddr.QuadPart = pMemInfo->logicalAddr;
    VideoPortReleaseCommonBuffer(pDev->DBmpDeviceExtension,
                                 pOsHwInfo->dmaAdapter, pMemInfo->length,
                                 logicalAddr, pMemInfo->sysAddr,
                                 TRUE);

    // free our data struct that kept track of this mapping
    osFreeMem(pMemInfo);

    return RM_OK;
}

#endif // _WIN64

VOID osWriteReg008(volatile U008* address, U008 data)
{
    VideoPortWriteRegisterUchar((PUCHAR)address, (UCHAR)data);
}

VOID osWriteReg016(volatile U016* address, U016 data)
{
    VideoPortWriteRegisterUshort((PUSHORT)address, (USHORT)data);
}

VOID osWriteReg032(volatile U032* address, U032 data)
{
    VideoPortWriteRegisterUlong((PULONG)address, (ULONG)data);
}

U008 osReadReg008(volatile U008* address)
{
    return VideoPortReadRegisterUchar((PUCHAR)address);
}

U016 osReadReg016(volatile U016* address)
{
    return VideoPortReadRegisterUshort((PUSHORT)address);
}

U032 osReadReg032(volatile U032* address)
{
    return VideoPortReadRegisterUlong((PULONG)address);
}

VP_STATUS osReadRegistryCallback
(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
)
{
    // return the extracted reg value
    *(U032*)Context = *(U032*)ValueData;
    
    return NO_ERROR;

} // end of osReadRegistryCallback()

VP_STATUS osReadRegistryBinaryCallback
(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
)
{
    ULONG i;

    // Grab the avil length from the contexts first element and make
    // sure that the value provided will fit in the buffer
    if (ValueLength > ((U032 *)Context)[0])
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Let the VP do the value copy
    VideoPortMoveMemory(Context,ValueData,ValueLength);

    return NO_ERROR;

} // end of osReadRegistryBinaryCallback()

RM_STATUS osReadRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 *cbLen
)
{
    RM_STATUS rmStatus = RM_OK;
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;
    // long word allign the following so we can stuff
    // a buffer length in the first element.  We need
    // to do this as the callback does not provide for
    // a buffer size to be passed in
    U032 localvaluebuffer[64];
 
    // Make sure that we have enough space for the callback data copy
    if (*cbLen > sizeof(localvaluebuffer))
    {
        return RM_ERROR;
    }

     // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // Stuff the size in the first element
    localvaluebuffer[0] = *cbLen;

    // call the video port to get the parameter value -- calls back to osReadRegistryCallback()
    vpStatus = VideoPortGetRegistryParameters
    (
        pDev->DBmpDeviceExtension,
        parameterName,
        FALSE,
        osReadRegistryBinaryCallback,
        &localvaluebuffer
    );

    // If all is well, fetch the value data and copy it 
    if(vpStatus == NO_ERROR) {

      // Let the VP do the copy and set the size to
      // what the caller suggested
      VideoPortMoveMemory(Data,localvaluebuffer,*cbLen);
    }

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osWriteRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 cbLen
)
{
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;

     // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to set the parameter value
    vpStatus = VideoPortSetRegistryParameters(
                  pDev->DBmpDeviceExtension,
                  parameterName,
                  Data,
                  cbLen
                  );

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osWriteRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 Data
)
{
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;

     // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to set the parameter value
    vpStatus = VideoPortSetRegistryParameters(
                  pDev->DBmpDeviceExtension,
                  parameterName,
                  &Data,
                  sizeof(ULONG)
                  );

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osReadRegistryDword
(
    PHWINFO pDev,
    char* regDevNode,
    char* regParmStr,
    U032* pData
)
{
    RM_STATUS rmStatus = RM_OK;
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;
    
    // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to get the parameter value -- calls back to osReadRegistryCallback()
    vpStatus = VideoPortGetRegistryParameters
    (
        pDev->DBmpDeviceExtension,
        parameterName,
        FALSE,
        osReadRegistryCallback,
        pData
    );

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
} // end of osReadRegistryDword()

RM_STATUS osCallVideoBIOS
(
    PHWINFO pDev, 
    U032 *pEAX, 
    U032 *pEBX, 
    U032 *pECX, 
    U032 *pEDX, 
    VOID *pBuffer
)
{
    VP_STATUS vpStatus = NO_ERROR;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    // load the register values and call int10 thru the Video Port
    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    biosArguments.Eax = *pEAX;
    biosArguments.Ebx = *pEBX;
    biosArguments.Ecx = *pECX;
    biosArguments.Edx = *pEDX;
    vpStatus = VideoPortInt10(pDev->DBmpDeviceExtension, &biosArguments);
    *pEAX = biosArguments.Eax;
    *pEBX = biosArguments.Ebx;
    *pECX = biosArguments.Ecx;
    *pEDX = biosArguments.Edx;
    
    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
} // end of osCallVideoBIOS()

#if (_WIN32_WINNT >= 0x0500)
RM_STATUS osDelayUs
(
    U032 MicroSeconds
)
{
    VP_STATUS vpStatus = NO_ERROR;

    VideoPortStallExecution(MicroSeconds);

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
}
#endif

//
// The purpose of this routine is to reset to base VGA display mode
// in preparation for full-screen DOS box, standby, or hibernation.
// 
VP_STATUS RMVideoResetDevice(
    U032 deviceReference
)
{
    U008 cr3B;
    BOOL scratchRestore = FALSE;
    U032 headDisable;
    VP_STATUS vpStatus = NO_ERROR;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    /* 
     * Disable the secondary head (dacDisableBroadcast) if currently running in 
     * clone mode before calling the bios to do the mode set.  This will insure
     * that on chips where this feature is broken (nv11) that the secondary
     * head isn't left displaying garbage.  i.e. in a full screen dos box
     * on mobile the crt will display a red bar at the top while the internal
     * flat panel is displaying the dos screen.
     */
    if (pDev->Dac.CrtcInfo[0].PrimaryDevice)
        headDisable = 1;
    else
        headDisable = 0;

    scratchRestore = dacDisableBroadcast(pDev, headDisable, &cr3B);

    // load the register values and call int10 thru the Video Port
    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    biosArguments.Eax = 0x0003;
    
    vpStatus = VideoPortInt10(pDev->DBmpDeviceExtension, &biosArguments);


    // Need to check to see if certain devices are enabled
    if(pDev->Power.MobileOperation)
    {
      // Call the BIOS to find out which displays were enabled
      VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
      biosArguments.Eax = 0x4f14;
      biosArguments.Ebx = 0x0085;
      vpStatus = VideoPortInt10(pDev->DBmpDeviceExtension, &biosArguments);

      if(biosArguments.Ebx & 0x1)
      {
          // if the monitor was turned off by power management, make sure it is
          // turned back on.  Usually this happens via the call to do the int 10
          // modeset, but on toshiba, the bios doesn't do it.  So we'll do it here
          // just to make sure it's on.
          // Note:  This is the expected result if a modeset happens at a time when
          // just the monitor has been turned off via power management.
          if (pDev->Dac.DevicesEnabled & DAC_MONITOR_POWER_STATE_OFF)
          {
              mcPowerDisplayState(pDev, MC_POWER_LEVEL_5, 1);
              // delay needed because if it's not here, toshiba will not go completely
              // into standby.  everyone else doesn't care if the delay is here or not.
              // also, 200ms seemed to be the amount of delay needed.  200ms was close, but wasn't enough.
              tmrDelay(pDev, 1000000*300);	// 1ms*300

              pDev->Dac.DevicesEnabled &= ~DAC_MONITOR_POWER_STATE_OFF;
          }
          else
              pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
      }
      // CRT is not currently used
//      if(biosArguments.Ebx & 0x2)
//          pDev->Dac.DevicesEnabled |= DAC_CRT_ENABLED;
      if(biosArguments.Ebx & 0x4)
          pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
    }

    //
    // When just going into a dos box (i.e. display power state is on) we don't
    // want to restore the scratch bits because otherwise the secondary display will
    // get turned back on when win2k does a vga modeset behind our back.
    // However, when this reset is a result of a power management event (specifically standby)
    // and the display power state is off, then we need to restore the register before leaving
    // otherwise when we come out of standby, we won't always resume to the correct display
    // configuration.
    // Can this get any uglier??
    if ((scratchRestore)
     && (pDev->Power.DisplayState[headDisable] == MC_POWER_LEVEL_6))
        dacRestoreBroadcast(pDev, headDisable, cr3B);


    return (vpStatus);

} // end of RMVideoResetDevice()


RM_STATUS osDelay
(
    U032 MilliSeconds
)
{
    VP_STATUS vpStatus = NO_ERROR;

    VideoPortStallExecution(MilliSeconds * 1000);
    
    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
}

#if (_WIN32_WINNT >= 0x0500)
RM_STATUS osIsr
(
    PHWINFO pDev
)
{
    BOOL serviced = FALSE;
    
    if (RmInterruptPending(pDev, &serviced))
    {
        // queue up a DPC for a normal priority interrupt
        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Queueing interrupt on DPC queue...\n");
        serviced |= VideoPortQueueDpc(pDev->DBmpDeviceExtension, RmDpcForIsr, pDev);
    }
    
    return (serviced) ? RM_OK : RM_ERROR;

} // end of osIsr()

VOID RmDpcForIsr
(
    PVOID HwDeviceExtension,
    PVOID Context
)
{
    PHWINFO pDev = (PHWINFO)Context;
    
    // service queued up interrupts and reenable interrupts
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Servicing interrupt at DPC level...\n");
    mcService(pDev);
    RmEnableInterrupts(pDev);

} // end of RmDpcForIsr()

#endif // (_WIN32_WINNT >= 0x0500)

#ifdef WIN2K_DDK_THAT_CONTAINS_APIS

RM_STATUS osNotifyEvent
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Notifier,
    U032      Method,
    U032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, j;
    PEVENTNOTIFICATION NotifyEvent;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyEvent()\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    // perform the type of action
    switch (Action)
    {
        case NV_OS_WRITE_THEN_AWAKEN:

            // walk this object's event list and find any matches for this specific notify
            for (NotifyEvent = Object->NotifyEvent; NotifyEvent; NotifyEvent = NotifyEvent->Next)
            {
                if (NotifyEvent->NotifyIndex == Notifier)
                {
                    // found a match -- notify the event
                    switch (NotifyEvent->NotifyType)
                    {
                        case NV01_EVENT_WIN32_EVENT:
                        {
                            // attempt to trigger the event
                            if (!VideoPortSetEvent(pDev->DBmpDeviceExtension, (PEVENT)NotifyEvent->Data.low))
                            {
                                // failed, so invalidate this event so we don't try again
                                NotifyEvent->NotifyType = 0;
                            }
                            break;
                        }

                        case NV01_EVENT_KERNEL_CALLBACK:
                        {
                            MINIPORT_CALLBACK callBackToMiniport = (MINIPORT_CALLBACK)(NotifyEvent->Data.low);

                            // perform a direct callback to the miniport
                            if (callBackToMiniport)
                                callBackToMiniport(pDev->DBmpDeviceExtension);
                            break;
                        }
                    
                        default:
                            break;    
                    }
                }
            }
            break;

        default:

            // any other actions are legacy channel-based notifies
            rmStatus = NVOS10_STATUS_ERROR_BAD_EVENT;
            break;
    }

    return rmStatus;

} // end of osNotifyEvent()

#endif // WIN2K_DDK_THAT_CONTAINS_APIS


// end of smp.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\ccommandq.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch Qs*************************\
*                                                                           *
* Module: CCommandQ.cpp														*
*   Object to command Q reads												*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <aos.h>
#include <nv_papu.h>
#include <AudioHw.h>
};

#include "CHalBase.h"
#include "CCommandQ.h"

CCommandQ::~CCommandQ()
{
    if (m_CommandQ.pLinAddr)
        delete m_CommandQ.pLinAddr;
}

RM_STATUS
CCommandQ::Initialize(Q_TYPE eType)
{
    if (Q_TYPE_EP)
    {
        m_uPut = NV_PAPU_EPPUT;
        m_uGet = NV_PAPU_EPGET;
        m_uQ = NV_PAPU_EPCADDR;
    }
    else if (Q_TYPE_GP)
    {
        m_uPut = NV_PAPU_GPPUT;
        m_uGet = NV_PAPU_GPGET;
        m_uQ = NV_PAPU_GPCADDR;
    }
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CCommandQ::CCommandQ - bad argument!");
        aosDbgBreakPoint();
        return RM_ERROR;
    }

    // allocate memory for the command Q
    RM_STATUS rmStatus =  aosAllocateMem(m_CommandQ.Size,
						                ALIGN_16K,
						                &m_CommandQ.pLinAddr,
						                &m_CommandQ.pPhysAddr);
    if (rmStatus == RM_OK)
    {
        m_pHal->RegWrite(m_uQ, (U032)m_CommandQ.pPhysAddr);
        m_pHal->RegWrite(m_uPut, (U032)0);
        m_pHal->RegWrite(m_uGet, (U032)0);
    }

    return rmStatus;
}


BOOL
CCommandQ::Read(U032 *puData)
{
    U032 uOffset;
    U032 uPut;

    // read the offset to be read from
    m_pHal->RegRead(m_uGet, &uOffset);
    *puData = *(U032*)((U008*)m_CommandQ.pLinAddr + uOffset);

    // update the GET pointer
    COMMAND_Q_INCREMENT(uOffset);
    m_pHal->RegWrite(m_uGet, uOffset);
    m_pHal->RegRead(m_uPut, &uPut);
    return (uPut == uOffset) ? TRUE:FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\AHal.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
\***************************************************************************/

/*
* AHal.cpp
*
* Chip-independent functions exported by the RM kernel
*
*/

extern "C" 
{
#include <nvarm.h>
#include <aos.h>
#include <nv32.h>
#include <AHal.h>
#include <AudioHw.h>
}
#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalMCP1.h"

RM_STATUS InitAudioHal(U008 uRevID, HWINFO_COMMON_FIELDS *pDev)
{
	switch(uRevID)
	{
	case REV_MCP1:
		pDev->pHalContext = (VOID *) new CHalMCP1(uRevID, pDev);
		break;

	default:
		pDev->pHalContext = NULL;
		break;
	}

	return (pDev->pHalContext)?RM_OK:RM_ERROR;
}

VOID DestroyAudioHal(HWINFO_COMMON_FIELDS *pDev)
{
	delete ((CHalBase *)pDev->pHalContext);
}

RM_STATUS AllocDevice(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->Allocate();
}

RM_STATUS FreeDevice(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->Free();
}

RM_STATUS DeviceAddClient(HWINFO_COMMON_FIELDS *pDev, VOID *pParam, U008 *pClientRef)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->AddClient(pParam, pClientRef);
}

RM_STATUS DeviceRemoveClient(HWINFO_COMMON_FIELDS *pDev, U008 uClientRef)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->DeleteClient(uClientRef);
}

RM_STATUS AllocObject(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	APU_OBJECT	*pObjAllocParams = (APU_OBJECT *)pParam;
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->AllocateObject(pObjAllocParams->uObjectCode, (VOID *)pObjAllocParams->pParam);
}

RM_STATUS FreeObject(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	APU_OBJECT	*pObjFreeParams = (APU_OBJECT *)pParam;
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->FreeObject(pObjFreeParams->uObjectCode, (VOID *)pObjFreeParams->pParam);
}

RM_STATUS AllocContextDma(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->AllocateContextDma(pParam);
}

RM_STATUS FreeContextDma(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->FreeContextDma(pParam);
}

RM_STATUS InterruptService(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    if (pBase)
	    return pBase->InterruptService();

    return RM_ERROR;
}

// the following code is to make the driver compile in C++ 
void* _cdecl operator new(unsigned int n)
{
	void *p;
    aosAllocateMem((U032) n, ALIGN_DONT_CARE, &p, NULL);
    return p;
}

void _cdecl operator delete(void* p)
{
	if (p) 
		aosFreeMem(p);
}

extern "C" int _cdecl _purecall();

int _cdecl _purecall()
{
    // this better get printed!!
    aosDbgPrintString(DEBUGLEVEL_ERRORS + 5, "NVARM: _purecall - RUNTIME ERROR!  calling pure virtual function!!!\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osdload.c ===
/*****************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2001 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2001  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* Module: osdload.c                                                         *|
|*    These are the OS-specific bits of implementing dynamic loading of      *|
|* driver code.  Be that from file, ROM/BIOS, etc.                           *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* History:                                                                  *|
|*       Ken Adams (kadams)     02/2001 - wrote it based upon investigatory  *|
|*                                        code from Todd Poynter.            *|
|*                                                                           *|
\*****************************************************************************/

#include <ntddk.h>
#include <nvrm.h>
#include <os.h>
#include <nvos.h>
#include <nvhw.h>
#include <Nvcm.h>
#include <dload.h>    


// At the moment, only supported for Win2k+
#if (_WIN32_WINNT >= 0x0500)


#define BAIL(r,s,p)  {     \
   ret = (r);              \
   DBG_PRINT_STRING(p ,s); \
   DBG_BREAKPOINT();       \
   goto cleanup;           \
}

static RM_STATUS setupMemOffsets(PDLD_MODULE pImg);
static RM_STATUS setupRelocations(PDLD_MODULE pImg);

//------------------------------------------------------------------
// osDldLinkImg
//
//    As we come into this routine, pImg is pointing into the raw
// image as given to the DldLoadImg interface.  We need to copy
// everything we need out of that struct (and what it points to) 
// and replace it memory malloc'd for what we need, here.  
// Oh yeah, we also have to do any relocations, get the memory 
// offsets setup and the like.  This is the real meat of the
// linking process.  For WindowsNT anyway this is pretty easy.
// We can just simply assign memory offsets in serial fashion
// to the various sections.  Addresses have to be assigned to 
// all the symbols.  Then any relocations have to be patched in.
//
//------------------------------------------------------------------
RM_STATUS osDldLinkImg ( VOID *_pMod )
{

	PDLD_MODULE             pMod = (PDLD_MODULE) _pMod;
	PNV_ImageHeader         pHeader;
	PSectionInfoEntry	pSections;
	PRelocationInfoEntry	pRelocs;
	PSymbolTableEntry	pSymbols;
	NvU8		       *pCode;
	NvU8                   *pData;
	NvU8                   *pBss;
	int                     ret = 0;
	unsigned int            checkSize;

	pMod->footer = 0;  // we no longer care about the footer

	// pMod->header should ALWAYS be valid.  ??? The rest may or may not 
	// be needed later ???  For kicks fuse data,code,bss because we know
	// we won't ever need to remove them individually.  We can probably
	// remove the sections,relocs,symbols at some point though...

	ret |= osAllocMem(&pHeader,   sizeof(NV_ImageHeader)      * 1);
	ret |= osAllocMem(&pSections, sizeof(SectionInfoEntry)    * pMod->header->nSections);
	ret |= osAllocMem(&pRelocs,   sizeof(RelocationInfoEntry) * pMod->header->nRelocs);
	ret |= osAllocMem(&pSymbols,  sizeof(SymbolTableEntry)    * pMod->header->nSymbols);
	ret |= osAllocMem(&pData,     sizeof(char) * (  pMod->header->dataSize 
						      + pMod->header->codeSize 
						      + pMod->header->bssSize  ) );
	pCode = pData + pMod->header->dataSize;
	pBss  = pCode + pMod->header->codeSize;
			  
	if ( ret != RM_OK ) 
		BAIL(RM_ERROR,"NVRM: oom section headers",DEBUGLEVEL_ERRORS);

	osMemCopy((NvU8*)pHeader,  (NvU8*)pMod->header,     sizeof(NV_ImageHeader)      * 1);
	osMemCopy((NvU8*)pSections,(NvU8*)pMod->secTable,   sizeof(SectionInfoEntry)    * pMod->header->nSections);
	osMemCopy((NvU8*)pRelocs,  (NvU8*)pMod->relocTable, sizeof(RelocationInfoEntry) * pMod->header->nRelocs);
	osMemCopy((NvU8*)pSymbols, (NvU8*)pMod->symTable,   sizeof(SymbolTableEntry)    * pMod->header->nSymbols);
	osMemCopy((NvU8*)pData,    (NvU8*)pMod->dataBuffer, sizeof(NvU8)                * pMod->header->dataSize);
	osMemCopy((NvU8*)pCode,    (NvU8*)pMod->codeBuffer, sizeof(NvU8)                * pMod->header->codeSize);


	pMod->header     = pHeader;    	pHeader   = 0;
	pMod->secTable   = pSections;   pSections = 0;
	pMod->relocTable = pRelocs;     pRelocs   = 0;
	pMod->symTable   = pSymbols;    pSymbols  = 0;
	pMod->dataBuffer = pData;       pData     = 0;
	pMod->codeBuffer = pCode;       pCode     = 0;
	pMod->bssBuffer  = pBss;        pBss      = 0;


	if ( RM_OK != (ret = setupMemOffsets(pMod) ) ) {
		goto cleanup;
	}

	// This step performs the actual "linking".  
	ret = setupRelocations(pMod);
		

 cleanup:
	if ( ret != RM_OK ) {
		if ( pHeader )   osFreeMem(pHeader); 
		if ( pSections ) osFreeMem(pSections);
		if ( pRelocs )   osFreeMem(pRelocs);
		if ( pSymbols )  osFreeMem(pSymbols);
		if ( pData )     osFreeMem(pData);
	}

	return ret;
}


//------------------------------------------------------------------
// osDldUnlinkImg
//
// Jettison the image.
//
//------------------------------------------------------------------
RM_STATUS osDldUnlinkImg ( VOID *_pMod )
{
	PDLD_MODULE pMod = (PDLD_MODULE)_pMod;
	int ret = RM_OK;

	if ( pMod->header )     { osFreeMem(pMod->header);     pMod->header     = 0; }
	if ( pMod->secTable )   { osFreeMem(pMod->secTable);   pMod->secTable   = 0; }
	if ( pMod->relocTable ) { osFreeMem(pMod->relocTable); pMod->relocTable = 0; }
	if ( pMod->symTable )   { osFreeMem(pMod->symTable);   pMod->symTable   = 0; }
	if ( pMod->dataBuffer ) { 
		osFreeMem(pMod->dataBuffer); 
		pMod->dataBuffer = pMod->codeBuffer = pMod->bssBuffer = 0; 
	}

	return ret;
}


#ifndef _WIN64

//------------------------------------------------------------------
//  setupMemOffsets
//
//  Cruise through the sections, assigning an offset within the
//  proper buffer for each.  In otherwords, place the sections
//  in memory...
//------------------------------------------------------------------
RM_STATUS setupMemOffsets(PDLD_MODULE pMod)
{
	unsigned int i = 0;
	NvU16       nSections = pMod->header->nSections;
	NvU8        *dataPtr  = pMod->dataBuffer;
	NvU8        *codePtr  = pMod->codeBuffer;
        NvU8        *bssPtr   = pMod->bssBuffer;
	int          ret = RM_OK;
	
	for (i = 0; i < nSections; i++)
	{
		switch ( pMod->secTable[i].type ) {

			case NV_DLOAD_SECTION_TYPE_DATA:
				pMod->secTable[i].memOffset = (NvU32)(NV_UINTPTR_T)dataPtr; // XXX - ain't right 32 vs 64b
				dataPtr += pMod->secTable[i].dataSize;
				break;
			case NV_DLOAD_SECTION_TYPE_CODE:
				pMod->secTable[i].memOffset = (NvU32)(NV_UINTPTR_T)codePtr; // XXX - ain't right 32 vs 64b
				codePtr += pMod->secTable[i].dataSize;
				break;
			case NV_DLOAD_SECTION_TYPE_BSS:
				pMod->secTable[i].memOffset = (NvU32)(NV_UINTPTR_T)bssPtr;  // XXX - ain't right 32 vs 64b
				bssPtr += pMod->secTable[i].dataSize;
				break;
			default:
				BAIL(RM_ERROR,"NVRM:  setupMemOffsets(...) unknown type",DEBUGLEVEL_ERRORS);
		}
	}

 cleanup:

	return ret;
}



// Defined in winnt.h.  But we don't need that whole mess.  These aren't likely to change, ever.
#ifndef IMAGE_REL_I386_ABSOLUTE

#define IMAGE_REL_I386_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16            0x0001  // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16            0x0002  // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32            0x0006  // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB          0x0007  // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12            0x0009  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION          0x000A
#define IMAGE_REL_I386_SECREL           0x000B
#define IMAGE_REL_I386_REL32            0x0014  // PC-relative 32-bit reference to the symbols virtual address

#endif


//------------------------------------------------------------------
//  setupRelocations
//
//  This routine walks all of the registered relocations in the
//  NVImage and fixes them up as necessary.  Note that it calls
//  back into the image-format-independent code (Dld*) to get
//  symbol offsets and the like.
//------------------------------------------------------------------
RM_STATUS setupRelocations( PDLD_MODULE pMod )
{
	int         ret = RM_OK;
	unsigned int i, j, relocIndex;
	NV_UINTPTR_T relocAddr;
	NvU16        nSections  = pMod->header->nSections;
	NvU32        nRelocs    = pMod->header->nRelocs;


	for (i = 0; i < nSections; i++)	{

		if ( !pMod->secTable[i].numRelocs ) continue;

		// find the first relocation table index with the same sec number 
		// as the section we are currently working on.

		for ( relocIndex = 0; 
		      ( relocIndex < pMod->header->nRelocs )
			      && (pMod->relocTable[relocIndex].secNumber != pMod->secTable[i].secNumber ) ; 
		      relocIndex++ ) {;;;;}

		if ( relocIndex == pMod->header->nRelocs ) 
			BAIL(RM_ERROR,"NVRM: invalid relocIndex",DEBUGLEVEL_ERRORS);

		for ( j = 0; j < pMod->secTable[i].numRelocs; j++ ) {

			unsigned symIndex;

			// get the target address
			relocAddr = (unsigned) (pMod->secTable[i].memOffset + pMod->relocTable[relocIndex+j].address);
				
			symIndex = pMod->relocTable[relocIndex + j].symIndex;

			switch ( pMod->relocTable[relocIndex + j].type ) {
				// XXX Note: the (NvU32) casts after *Get*Offset aren't necessary
				// for x86.  I've added them for ia64 compilation checking, even though
				// we won't be running throught this code on that platform.
				case IMAGE_REL_I386_DIR32:
					*((NvU32*)relocAddr) = DldGetMemOffset(pMod,symIndex);
					break;

				case IMAGE_REL_I386_DIR32NB:
					*((NvU32*)relocAddr) = DldGetImageOffset(pMod,symIndex);
					break;

				case IMAGE_REL_I386_SECTION:
					*((NvU16*)relocAddr) = DldGetSymbolSection(pMod,symIndex);
					break;

				case IMAGE_REL_I386_SECREL:
					*((NvU32*)relocAddr) = 
						(NvU32) (DldGetMemOffset(pMod,symIndex) 
							 - DldGetSectionMemOffset(pMod, DldGetSymbolSection(pMod,symIndex)));
					break;

				case IMAGE_REL_I386_REL32:
					if ( pMod->secTable[i].type == NV_DLOAD_SECTION_TYPE_DATA ) 
						BAIL(RM_ERROR,"NVRM: unsupported relative data section reloc",DEBUGLEVEL_ERRORS);

					*((NvU32*)relocAddr) = (NvU32) ( DldGetMemOffset(pMod,symIndex) 
								 - (relocAddr + 4) ); // +4 since rel is from _next_ instr.
					break;

				    case IMAGE_REL_I386_ABSOLUTE:
				    case IMAGE_REL_I386_DIR16:
				    case IMAGE_REL_I386_REL16:
				    case IMAGE_REL_I386_SEG12:
				    default:
					    BAIL(RM_ERROR,"NVRM: unsupported reloc",DEBUGLEVEL_ERRORS);
			}
#ifdef NV_DBG_RELOC
			DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO," f ",(unsigned*)relocAddr);
			DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"  a",(unsigned*)*(unsigned*)relocAddr);
#endif
			
		}
	}

 cleanup:
	
	return ret;
	
}


#else
// Win64 
RM_STATUS setupMemOffsets(PDLD_MODULE pImg)
{
	return RM_ERROR;
}

RM_STATUS setupRelocations(PDLD_MODULE pImg)
{
	return RM_ERROR;
}


#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osinit.c ===
/**************************************************************************************************************
*
*   Module:  osinit.c
*
*   Description:
*       This is the NT-specific, device-independent initialization code for the resource manager.
*
*
**************************************************************************************************************/

#include <nvhw.h>
#include <nvrm.h>
#include <nvos.h>
#include <nvarch.h>
#include <devinit.h>
#include <rmfail.h>

//
// Globals
//
WINNTHWINFO	winNTHwInfo[MAX_INSTANCE];

// local prototypes
RM_STATUS   initDmaListElementPool();
VOID        initDisplayInfo(PDISPLAYINFO);


BOOL RmInitRm()
{
    // init client database
    if (initClientInfo() != RM_OK)
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize client database\n");
        return FALSE;
    }

    // init dma context-list element pool
    if (initDmaListElementPool() != RM_OK)
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize graphics patch pool\n");
        return FALSE;
    }

    // init state of display
    osDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    initDisplayInfo(&osDisplayInfo);

    return TRUE;
       
} // end of RmInitRm()


BOOL RmInitNvMapping
(
    VOID* deviceExtension,
    U032 PhysNvAddr,
    PHWREG nvRegisterBase,
    U032* pDeviceReference
)
{
    PHWINFO pDev;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: RmInitNvMapping:\n");

    // get the next available device instance
    if (!RM_SUCCESS(RmAllocDeviceInstance(pDeviceReference)))
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device database\n");
        return FALSE;
    }
    pDev = NvDBPtr_Table[*pDeviceReference];

	// setup the ptr to the OS Hw info
	pDev->pOsHwInfo = (VOID_PTR) &winNTHwInfo[*pDeviceReference];

    // set the device extension
    pDev->DBmpDeviceExtension = deviceExtension;

    // init configuration
    osStringCopy(pDev->Mapping.ID, "Device Mapping");
    pDev->Mapping.Size = sizeof(pDev->Mapping);

    // set physical and logical register base
    pDev->Mapping.PhysAddr = PhysNvAddr;
    nvAddr = nvRegisterBase;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: device instance          :", devInstance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using physical address:", pDev->Mapping.PhysAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: NV using linear address  :", nvAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: ROM using linear address :", romAddr);
    
    // default the crystal frequency to 0
    pDev->Chip.HalInfo.CrystalFreq = 0;

    return TRUE;

} // end of RmInitNvMapping()

BOOL RmInitNvHal
(
    U032 deviceReference
)
{
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // hook up the HAL
    if (initHal(pDev) != RM_OK)
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device-dependent (HAL) state\n");
        return FALSE;
    }

    // set the chip revision
    nvHalMcControl(pDev, MC_CONTROL_SETREVISION);

    // set the bios addr now, PraminOffset is set in MC_CONTROL_SETREVISION
    biosAddr = (PHWREG)((U008 *)nvAddr + pDev->Pram.HalInfo.PraminOffset);

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: BIOS using linear address:", biosAddr);

    return (TRUE);
} // end of RmInitNvHal()

// the FB address is only provided on the first POST
BOOL RmPostNvDevice
(
    U032 deviceReference,
    PHWREG externalBiosImage,
    PHWREG frameBufferBase
)
{
    RM_STATUS rmStatus = RM_OK;
    BOOL biosUsedToInit;
    
    // set the device context
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: POSTing device instance  :", devInstance);

    // set the FB logical address, if given
    if (frameBufferBase)
    {
        fbAddr = frameBufferBase;
    }
    
    // POST the device
    rmStatus = DevinitInitializeDevice(pDev, externalBiosImage, &biosUsedToInit);

    if (RM_SUCCESS(rmStatus))
    {
		DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...POST completed sucessfully\n");
        
        // shadow the VGA BIOS image in upper inst mem
        if (externalBiosImage)
        {
            DevinitShadowBios(pDev, externalBiosImage);
        }
    }
    else
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot POST the device\n");
    }
    
    return (rmStatus == RM_OK);

} // end of RmPostNvDevice()

BOOL RmInitNvDevice
(
    U032 deviceReference,
    U032 PhysFbAddr,
    PHWREG frameBufferBase
)
{
    // set the device context
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: RmInitNvDevice:\n");

    // init the RM FAILURE facility if enabled
    RM_FAILURE_ENABLE();
    
    // init processor synchronization
    if (!RM_SUCCESS(osInitSpinLock(pDev)))
    {
        return FALSE;
    }

    // init "DMA adapter" for use in memory management routines
    if (!RM_SUCCESS(osInitDmaAdapter(pDev)))
    {
        return FALSE;
    }
        
#ifdef RM_STATS
    // init all data structures
    pDev->Statistics.MemAlloced = 0;
    pDev->Statistics.MemLocked = 0;
#endif

    // set physical and logical frame buffer
    pDev->Mapping.PhysFbAddr = PhysFbAddr;
    fbAddr = frameBufferBase;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: device instance          :", devInstance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB using physical address:", pDev->Mapping.PhysFbAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: FB using linear address  :", fbAddr);

    // initialize all engines -- calls back initMapping()
    if (!RM_SUCCESS(stateNv(pDev, STATE_INIT)))
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize the device\n");
        return FALSE;
    }

    // come up as VGA until display driver disables it, thus enabling high-res
    pDev->Vga.Enabled = TRUE;
    if (!RM_SUCCESS(stateNv(pDev, STATE_LOAD)))
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot load state into the device\n");
        return FALSE;
    }

    return TRUE;

} // end of RmInitNvDevice()

// init the global pool of DMA context list elements
RM_STATUS initDmaListElementPool()
{
    RM_STATUS status = RM_OK;
    U032 i;

    // allocate the pool
    status = osAllocMem((VOID **)&dmaListElementPool, sizeof(DMALISTELEMENT_POOL_ELEMENT) * DMALISTELEMENT_POOL_SIZE);
    if (RM_SUCCESS(status))
    {
        // initialize the pool
        for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
        {
            dmaListElementPool[i].inUse = FALSE;
        }
    }

    return status;

} // end of initDmaCtxtListElemPool()

VOID initDisplayInfo(PDISPLAYINFO pDi)
{
    // these are hard coded not unreasonable values for the time being
    pDi->XRes                   = 1024;
    pDi->YRes                   = 768;
    pDi->Bpp                    = 16;
    pDi->HdrSize                = 0x32;
    pDi->InfoFlags              = 0;
    pDi->DevNodeHandle          = 0;
    pDi->DriverName[0]          = 0;
    pDi->DPI                    = 0x60;
    pDi->Planes                 = 0x1;
    pDi->RefreshRateMax         = 0x4F;
    pDi->RefreshRateMin         = 0x32;
    pDi->LowHorz                = 0x1E;
    pDi->HighHorz               = 0x40;
    pDi->LowVert                = 0x32;
    pDi->HighVert               = 0x64;
    pDi->MonitorDevNodeHandle   = 0;
    pDi->HorzSyncPolarity       = 0x2B;
    pDi->VertSyncPolarity       = 0x2B;

} // end of RmInitDisplayInfo()

// map the NV device into the RM memory space
RM_STATUS initMapping
(
    PHWINFO pDev
)
{
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS status;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initMapping:\n");

    // attempt to determine the current CPU type
    RmInitCpuInfo(pDev);

    // attempt to determine the FSB and Memory speeds
    RmInitBusInfo(pDev);

    // reload mapped device addresses for HAL use
    if (initHalMappings(pDev) != RM_OK)
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device mappings for HAL\n\r");
        return FALSE;
    }

    // satisfy MC init
    pDev->Mapping.IntPin = 0x0A;

    // Some PCI BIOSs leave the ROM mapped.  This causes problems if it overlays system RAM.  Just disable it.
    REG_WR32(NV_PBUS_PCI_NV_12, 0);
    
    // make sure our PCI latency timer is sufficient (max it out)
    REG_WR32(NV_PBUS_PCI_NV_3, DRF_NUM(_PBUS,_PCI_NV_3,_LATENCY_TIMER, NV_PBUS_PCI_NV_3_LATENCY_TIMER_248_CLOCKS));

#if (_WIN32_WINNT < 0x500)
    //
    // For NT4, we'll attempt to recognize the chipset and init AGP support
    // if this is an AGP card and there's no registry entry override set
    //
    {
        U032 data32;
        U032 stringlength=80;
        char string[80];
        extern char strDevNodeRM[];
        extern char strNTSrvPackVersion[];

        // For DELL's unattended install, they're running NT without *ANY* service packs!
        // In this case, do NOT implement AGP functionality, because NT without
        // service pack can't handle it.  We'll check and see if a service pack 
        // (greather than or equal to service pack 3) was installed.  Not sure
        // what C libraries we can include here, so to be safe, just compare the strings by hand.
    
        if (osReadRegistryString(strNTSrvPackVersion, "CSDVersion", &string[0], &stringlength) == RM_OK)
        {
            if ( ((string[0] == 'S') || (string[0] == 's'))  && 
                 ((string[1] == 'E') || (string[1] == 'e'))  &&                 
                 ((string[2] == 'R') || (string[2] == 'r'))  &&
                 ((string[3] == 'V') || (string[3] == 'v'))  && 
                 ((string[4] == 'I') || (string[4] == 'i'))  && 
                 ((string[5] == 'C') || (string[5] == 'c'))  && 
                 ((string[6] == 'E') || (string[6] == 'e'))  &&             
                 (string[13] >= '3') )             
            {

                if (osReadRegistryDword(pDev, strDevNodeRM, "NoNT4AGP", &data32) != RM_OK)
                {
                    // Allow an override to set the AGP rate
                    if (osReadRegistryDword(pDev, strDevNodeRM, "ReqAGPRate", &data32) == RM_OK)
                        pDev->Chip.ReqAGPRate = data32;

                    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
                        RmInitAGP(pDev);
                }

            }
        }
    }
#endif

    // Apply any AGP chipset workarounds or overrides
    NvUpdateAGPConfig(pDev);

    // flag RM to be initialized
    pOsHwInfo->rmInitialized = TRUE;

    // TO DO: add AGP support in NT 5.0

    return RM_OK;

} // end of initMapping()

// OS-specific initializations

RM_STATUS initFbEx
(
    PHWINFO pDev
)
{
    S032  fbCalcMemSize(VOID);
    U032 calc_max_bw (VOID);
    U032 size;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initFramebufferEx\n");
    //
    // Get screen resolution and framebuffer configuration from registry.
    //
    pDev->Dac.HalInfo.Depth = (osDisplayInfo.InfoFlags & REGISTRY_BPP_NOT_VALID) ? 8 : osDisplayInfo.Bpp;
    if ((osDisplayInfo.InfoFlags & (MONITOR_INFO_NOT_VALID | MONITOR_INFO_DISABLED_BY_USER))
     || (osDisplayInfo.RefreshRateMax == 0xFFFFFFFF)
     || (osDisplayInfo.RefreshRateMax == 0))
    {
        pDev->Framebuffer.HalInfo.RefreshRate   = 60;
        pDev->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
        pDev->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    }
    else
    {
        pDev->Framebuffer.HalInfo.RefreshRate   = osDisplayInfo.RefreshRateMax;
        pDev->Framebuffer.HSyncPolarity = osDisplayInfo.HorzSyncPolarity;
        pDev->Framebuffer.VSyncPolarity = osDisplayInfo.VertSyncPolarity;
    }

    pDev->Framebuffer.HalInfo.HorizDisplayWidth = osDisplayInfo.XRes;
    pDev->Framebuffer.HalInfo.VertDisplayWidth  = osDisplayInfo.YRes;
    pDev->Framebuffer.HorizFrontPorch = 0;
    pDev->Framebuffer.HorizSyncWidth  = 0;
    pDev->Framebuffer.HorizBackPorch  = 0;
    pDev->Framebuffer.VertFrontPorch  = 0;
    pDev->Framebuffer.VertSyncWidth   = 0;
    pDev->Framebuffer.VertBackPorch   = 0;
    pDev->Framebuffer.CSync           = BUFFER_CSYNC_DISABLED;
    pDev->Dac.HalInfo.VClk            = 0;
    //
    // Calculate the framebuffer count based on the configuration with double buffering.
    //
    size = pDev->Dac.HalInfo.Depth / 8
         * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth
         * 2;
    if (size > pDev->Framebuffer.HalInfo.RamSize)
        size = 0;
    else
        size = pDev->Framebuffer.HalInfo.RamSize - size;
    pDev->Framebuffer.Count = 1;

    return (RM_OK);
}
RM_STATUS initGrEx
(
    PHWINFO pDev
)
{
    return (RM_OK);
}
RM_STATUS initDacEx
(
    PHWINFO pDev
)
{
    return (RM_OK);
}
RM_STATUS initFifoEx
(
    PHWINFO pDev
)
{
    pDev->Fifo.HalInfo.RetryCount = 1;

    return (RM_OK);
}
RM_STATUS initRModeEx
(
    PHWINFO pDev
)
{
    return(RM_OK);
}

// end of osinit.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\ccommandq.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch Qs*************************\
*                                                                           *
* Module: CCommandQ.h														*
*   Object to command Q reads												*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CCOMMANDQH_
#define _CCOMMANDQH_

#define COMMAND_Q_SIZE      0x1000
#define COMMAND_Q_INCR      0x4
#define COMMAND_Q_INCREMENT(x)   (x) = ((x) + COMMAND_Q_INCR) & (COMMAND_Q_SIZE -1)

class CHalBase;

class CCommandQ
{
public:
    enum Q_TYPE
    {
        Q_TYPE_EP,
        Q_TYPE_GP
    };

    CCommandQ(CHalBase *pHal)
    {
        m_uPut = 0;
        m_uGet = 0;
        m_CommandQ.pLinAddr = NULL;
        m_CommandQ.Size = COMMAND_Q_SIZE;
        m_pHal = pHal;
    }
    ~CCommandQ();

    RM_STATUS Initialize(Q_TYPE);
    BOOL Read(U032 *);

    VOID *GetLinAddr() { return m_CommandQ.pLinAddr; }
    
private:
    // register offsets
    U032        m_uPut;
    U032        m_uGet;
    U032        m_uQ;

    MEM_DESC    m_CommandQ;
    CHalBase    *m_pHal;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CContextDma.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: CContextDma.cpp                                                   *
*   The MCPX HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nv32.h>
#include <nvarm.h>
#include <aos.h>
};

#include <ClinkList.h>
#include "CContextDma.h"


RM_STATUS
CContextDma::Initialize(VOID *pAddress, U032 uSize, U032 uType)
{
    RM_STATUS rmStatus = RM_ERROR;

    m_uType = uType;
    m_uSize = uSize;
    m_pLinAddr = NULL;
    m_pAddress = NULL;

    switch(m_uType)
    {
    case AUDIO_CONTEXT_DMA_GPFXPARAM:
    case AUDIO_CONTEXT_DMA_GPFXDSPCODE:
        // no check for MCP1.. just store the virtual address
        m_pLinAddr = pAddress;
        m_pAddress = NULL;
        rmStatus = RM_OK;
        break;

    case AUDIO_CONTEXT_DMA_SESGE:
    case AUDIO_CONTEXT_DMA_SESSL:
    case AUDIO_CONTEXT_DMA_GPSGE:
    case AUDIO_CONTEXT_DMA_EPSGE:
        {
            // make sure the stuff is properly aligned
            if (!PAGEOFF(pAddress))
            {
                if (!PAGEOFF(uSize))
                {
                    m_pAddress = pAddress;
                    rmStatus = RM_OK;
                }
            }
        }
        break;
    
    case AUDIO_CONTEXT_DMA_GPNOTIFIER:
    case AUDIO_CONTEXT_DMA_EPNOTIFIER:
        {
            // just make sure the address is 4K aligned and the size
            // is max 4K
            if (m_uSize <= 4096)
            {
                rmStatus = aosGetPhysicalAddress(pAddress, m_uSize, &m_pAddress);
                if (rmStatus == RM_OK)
                {
                    m_pLinAddr = pAddress;
                    if (PAGEOFF(m_pAddress))
                        rmStatus = RM_ERROR;
                }
            }
        }
        break;

    case AUDIO_CONTEXT_DMA_FENOTIFIER:
        {
            // convert the address to physical
            rmStatus = aosGetPhysicalAddress(pAddress, m_uSize, &m_pAddress);
            if (rmStatus == RM_OK)
            {
                m_pLinAddr = pAddress;

                // has to be 256 byte aligned..
                if (((U032)m_pAddress) & 0xFF)
                    rmStatus = RM_ERROR;        // alignment fails
            }
        }
        break;

    default:
        break;
    }

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CContextDma.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: CContextDma.h                                                   *
*   The MCPX HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CCONTEXTDMAH_
#define _CCONTEXTDMAH_

class CLinkList;

class CContextDma : public CLinkList
{
public:
    RM_STATUS Initialize(VOID *pAddress, U032 uSize, U032 uType);

    VOID *GetAddress() { return m_pAddress; }
    U032 GetSize()  { return m_uSize; }
    U032 GetType()  { return m_uType; }
    VOID *GetLinAddr()  { return m_pLinAddr; }

private:
    VOID *m_pAddress;
    U032 m_uSize;
    U032 m_uType;       // type of the dma - this is prob redundant
    VOID *m_pLinAddr;   // only used for GP/EP notifiers
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPDspProgram.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CEPDspProgram.h                                                   *
*	interface for accessing DSP program information  for GP                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CEPDSPPROGRAMH_
#define _CEPDSPPROGRAMH_

// reserve the last one for AC-3
#define AC3_EFFECT_INDEX        (MAX_EFFECTS - 1)

#define AC3_SUPREXECBASE        0x000
#define AC3_LOADERBASE          0x180
#define AC3_LOADERTABLEBASE     0x100 // xxxxx temp 0x2C0 until dolby modifies their code
#define AC3_DOLBYBASE           0x300

#define AC3_MAX_PROGRAMS        4

#define AC3_HEAPLENGTH          8192  // length in words

typedef struct
{
    // the entries in this table are actually all 24-bit DSP words, but when
    // we store DSP code in system memory, we extend each word to fill 32 bits,
    // so we can store them in U032S.  
    U032 tableSize;         // table size                  
    U032 maxProgs;          // number of programs

    struct
    {
        U032 ptr;
        U032 size;
    } prog[AC3_MAX_PROGRAMS];

    U032 pcm_ptr;              // pointer to input PCM buffer
    U032 pcm_size;             // size of input PCM buffer
    U032 ltrt_ptr;             // pointer to output Lt/Rt buffer  (Note: actually a FIFO index!!)
    U032 ltrt_size;            // size of output Lt/Rt buffer
    U032 ac3_ptr;              // pointer to output AC-3 buffer   (Note: actually a FIFO index!!)
    U032 ac3_size;             // size of output AC-3 buffer
    U032 config_ptr;           // pointer to config table
    U032 config_size;          // size of config table
    U032 pingpong_offset;      // current pingpong buffer offset
    U032 reserved1;
    U032 ac3_zero_fill;        // AC3 zero fill (Note: actually a FIFO index!!)
    U032 reserved2;
    U032 ac3_preamble;         // AC3 preamble (Note: actually a FIFO index!!)
    U032 reserved3;
    U032 heap_ptr;             // pointer to heap data buffer
    U032 heap_size;            // size of heap data buffer
} DOLBY_LOADER_TABLE;


#define DOLBY_LOADER_TABLE_OFFSET(x)    (U032)&(((DOLBY_LOADER_TABLE *)0)->x)

class CDspProgram;

class CEPDspProgram : public CDspProgram
{
public:
    VOID Initialize();

    // AC3 functions
    U032 AC3GetTotalScratchSize();
    VOID AC3GetSuperExec(VOID_PTR *ppData, U032 *pLength, U032 *pBase);
    VOID AC3GetLoader(VOID_PTR *ppData, U032 *pLength, U032 *pBase);
    VOID AC3GetProgram(U032 uIndex, VOID_PTR *ppData, U032 *pLength);
    
    VOID_PTR AC3GetConfigTable();
    
    U032 AC3GetLoaderTableBase() { return AC3_LOADERTABLEBASE; }
    U032 AC3GetProgramBase()     { return AC3_DOLBYBASE;       }
    U032 AC3GetMaxPrograms()     { return AC3_MAX_PROGRAMS;    }
    U032 AC3GetHeapLength()      { return AC3_HEAPLENGTH;      }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CDspProgram.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CDspProgram.h                                                     *
*	interface for accessing DSP program information                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CDSPPROGRAMH_
#define _CDSPPROGRAMH_

class CDspProgram
{
public:
    CDspProgram()
    {
        m_pLoader = NULL;
        m_uLoaderSize = 0;

        for (U032 uCnt = 0; uCnt < MAX_EFFECTS; uCnt++)
        {
            m_Effect[uCnt].pCode = NULL;
            m_Effect[uCnt].uCodeSize = 0;
            m_Effect[uCnt].uDelaySize = 0;
        }
    }
    
    virtual VOID Initialize() = 0;

    VOID_PTR    GetLoader() { return m_pLoader; }
    U032        GetLoaderSize() { return m_uLoaderSize; }
    
    VOID_PTR    GetCode(U032 uIndex) { return ((uIndex < MAX_EFFECTS)?(m_Effect[uIndex].pCode):NULL); }
    U032        GetDelayLineSize(U032 uIndex) { return ((uIndex < MAX_EFFECTS)?(m_Effect[uIndex].uDelaySize):0); }
    U032        GetCodeSize(U032 uIndex) { return ((uIndex < MAX_EFFECTS)?(m_Effect[uIndex].uCodeSize):0); }

protected:
    struct
    {
        VOID_PTR pCode;
        U032 uCodeSize;
        U032 uDelaySize;
    } m_Effect[MAX_EFFECTS];

    VOID_PTR    m_pLoader;
    U032        m_uLoaderSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPMethod.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CEPMethod.cpp                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uep.h>
#include <nv_papu.h>
#include <nv32.h>
#include <AudioHw.h>
};
#include <aos.h>
#include <ahal.h>

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalExtendedProc.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CScratchManager.h"
#include "CEPScratchManager.h"
#include "CEPMethod.h"

RM_STATUS
CEPMethod::Execute(U032 uOffset, U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;

    do
    {
        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE))
        {
            rmStatus = SetCurrentSge(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA))
        {
            rmStatus = SetContextDMA(uData);
            break;
        }
        
        if (CheckRange(uOffset, NV1BAE_PIO_SET_STATE))
        {
            rmStatus = SetState(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET))
        {
            rmStatus = SetSgeOffset(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BAE_PIO_SET_AC3_FIFO))
        {
            rmStatus = SetAC3Fifo(uData);
            break;
        }

        U032 uCnt = 0;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if ( CheckRange(uOffset, (NV1BAE_PIO_SET_OUTBUF_BA(uCnt))) )
            {
                rmStatus = SetSgeBaseAddr(uData, uCnt);
                break;
            }
        }
        
        if (uCnt != 4)
            break;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if ( CheckRange(uOffset, (NV1BAE_PIO_SET_OUTBUF_LEN(uCnt))) )
            {
                rmStatus = SetSgeLength(uData, uCnt);
                break;
            }
        }

        if (uCnt != 4)
            break;

        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CEPMethod::Execute - SW method not yet implemented!\n");

#if defined WDM
        KdPrint(("Method offset = 0x%x Method Data = 0x%x\n", uOffset, uData));
#endif

    } while (FALSE);
    
    return rmStatus;
}

RM_STATUS
CEPMethod::SetCurrentSge(U032 uData)
{
    // todo vik - check against the max PRDs allocated on EP init

    // HW indexes are 0 based
    m_uCurrSge = uData;

    return RM_OK;
}


RM_STATUS
CEPMethod::SetContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }
    
    m_uBaseAddr = (U032)pDma->GetAddress();
    m_uMaxOffset = (U032)pDma->GetSize();

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeOffset(U032 uData)
{
    if (!m_uMaxOffset)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetSgeOffset - context DMA is not valid\n");
        // context DMA not valid
        return RM_ERROR;
    }

    if (uData > m_uMaxOffset)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetSgeOffset - exceeds max offset\n");
        // bad argument
        return RM_ERROR;
    }

    
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pProc->GetSgeOutLinAddr());

    pPrd[m_uCurrSge].uAddr = m_uBaseAddr + uData;
    pPrd[m_uCurrSge].Control.uValue = 0;
    pPrd[m_uCurrSge].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeBaseAddr(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffCur;
    U032 uOffEnd;
    
    GetBaseCurEnd(uIndex, &uOffBase, &uOffCur, &uOffEnd);

    m_pHal->RegWrite(uOffBase, uData);
    m_pHal->RegWrite(uOffCur, uData);
    m_pHal->RegWrite(uOffEnd, uData+256);

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeLength(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    GetBaseAndEnd(uIndex, &uOffBase, &uOffEnd);
    
    U032 uBaseAddr;
    m_pHal->RegRead(uOffBase, &uBaseAddr);

    m_pHal->RegWrite(uOffEnd, uBaseAddr + uData);
    
    return RM_OK;
}

RM_STATUS 
CEPMethod::SetState(U032 uData)
{
    R_EP_RESET rReset;
    rReset.uValue = 0;
    R_GP_CONTROL rControl;
    rControl.uValue = 0;


    if (uData)
    {
        // take it out of reset...
        rReset.Global = NV_PAPU_EPRST_EPRST_DISABLED;
        rReset.DSP = NV_PAPU_EPRST_EPDSPRST_ENABLED;
        rReset.NMI = NV_PAPU_EPRST_EPNMI_DISABLED;
        rReset.Abort = NV_PAPU_EPRST_EPABORT_DISABLED;

        m_pHal->RegWrite(NV_PAPU_EPRST, rReset.uValue);


        // auto start and auto idle
        R_GPDMA_CONFIG rConfig;
        rConfig.uValue = 0;
        //rConfig.Start = NV_PAPU_EPDCFG_GPDASTRT_ENABLED;
        //rConfig.Ready = NV_PAPU_EPDCFG_GPDARDY_ENABLED;
        m_pHal->RegWrite(NV_PAPU_EPDCFG, rConfig.uValue);
        
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetEPState - the EP might just start...");
        // enable the EP

        rControl.Idle = NV_PAPU_EPIDRDY_EPSETIDLE_SET;
        rControl.IntrNotify = NV_PAPU_EPIDRDY_EPSETNINT_NOT_SET;
    }
    else
    {
        // stop the EP
        rReset.Global = NV_PAPU_EPRST_EPRST_DISABLED;
        rReset.DSP = NV_PAPU_EPRST_EPDSPRST_ENABLED;
        rReset.NMI = NV_PAPU_EPRST_EPNMI_DISABLED;
        rReset.Abort = NV_PAPU_EPRST_EPABORT_DISABLED;

        m_pHal->RegWrite(NV_PAPU_EPRST, rReset.uValue);
    }

    m_pHal->RegWrite(NV_PAPU_EPIDRDY, rControl.uValue);
    
    // clear the GPISTS bit
    m_pHal->RegWrite(NV_PAPU_EPISTS, (U032)0xff);

    // reset just the DSP core...
    /*
    R_GP_RESET rReset;
    rReset.uValue = 0;
    rReset.Global = NV_PAPU_EPRST_EPRST_DISABLED;
    rReset.DSP = NV_PAPU_EPRST_EPDSPRST_DISABLED;
    rReset.NMI = NV_PAPU_EPRST_EPNMI_DISABLED;
    rReset.Abort = NV_PAPU_EPRST_EPABORT_DISABLED;
    // u need to do this only when the program is in and all that
    m_pHal->RegWrite(NV_PAPU_EPRST, rReset.uValue);
    */

    m_pHal->RegWrite(NV_PAPU_EPRST, uData);


    aosDbgPrintString(DEBUGLEVEL_ERRORS, "done.  Congratulations!\n");
    return RM_OK;
}

RM_STATUS 
CEPMethod::SetAC3Fifo(U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;
    
    union
    {
        struct
        {
            U032 analog : 3;
            U032 digital : 3;
            U032 res : 26;
        } fields;

        U032 uVal;
    } Data;

    Data.uVal = uData;
    
    // some error checking
    if ( (Data.fields.analog > 3) || (Data.fields.digital > 3) )
    {
        // bad argumnet
        return RM_ERROR;
    }

    U032 uBaseAddr, uEndAddr;
    U032 uBaseVal, uEndVal;

    // get the analog fifo index
    GetBaseAndEnd(Data.fields.analog, &uBaseAddr, &uEndAddr);

    m_pHal->RegRead(uBaseAddr, &uBaseVal);
    m_pHal->RegRead(uEndAddr, &uEndVal);
    
    // update the loader table
    rmStatus = m_pProc->GetEPScratchManager()->AC3SetAnalogOutput(Data.fields.analog, (uEndVal - uBaseVal));
    //rmStatus = m_pProc->GetEPScratchManager()->AC3SetAnalogOutput(uBaseVal, (uEndVal - uBaseVal));
    if (rmStatus != RM_OK)
        return rmStatus;

    // get the digital fifo index
    GetBaseAndEnd(Data.fields.digital, &uBaseAddr, &uEndAddr);

    m_pHal->RegRead(uBaseAddr, &uBaseVal);
    m_pHal->RegRead(uEndAddr, &uEndVal);
    
    // update the loader table
    return m_pProc->GetEPScratchManager()->AC3SetDigitalOutput(Data.fields.digital, (uEndVal - uBaseVal));
    //return m_pProc->GetEPScratchManager()->AC3SetDigitalOutput(uBaseVal, (uEndVal - uBaseVal));
}


// utility functions
VOID
CEPMethod::GetBaseAndEnd(U032 uIndex, U032 *pBase, U032 *pEnd)
{
    switch(uIndex)
    {
    case 0:
        *pBase = NV_PAPU_EPOFBASE0;
        *pEnd = NV_PAPU_EPOFEND0;
        break;
    case 1:
        *pBase = NV_PAPU_EPOFBASE1;
        *pEnd = NV_PAPU_EPOFEND1;
        break;
    case 2:
        *pBase = NV_PAPU_EPOFBASE2;
        *pEnd = NV_PAPU_EPOFEND2;
        break;
    case 3:
        *pBase = NV_PAPU_EPOFBASE3;
        *pEnd = NV_PAPU_EPOFEND3;
        break;
    }
}


// utility functions
VOID
CEPMethod::GetBaseCurEnd(U032 uIndex, U032 *pBase, U032 *pCur, U032 *pEnd)
{
    switch(uIndex)
    {
    case 0:
        *pBase = NV_PAPU_EPOFBASE0;
        *pCur = NV_PAPU_EPOFCUR0;
        *pEnd = NV_PAPU_EPOFEND0;
        break;
    case 1:
        *pBase = NV_PAPU_EPOFBASE1;
        *pCur = NV_PAPU_EPOFCUR1;
        *pEnd = NV_PAPU_EPOFEND1;
        break;
    case 2:
        *pBase = NV_PAPU_EPOFBASE2;
        *pCur = NV_PAPU_EPOFCUR2;
        *pEnd = NV_PAPU_EPOFEND2;
        break;
    case 3:
        *pBase = NV_PAPU_EPOFBASE3;
        *pCur = NV_PAPU_EPOFCUR3;
        *pEnd = NV_PAPU_EPOFEND3;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPDspProgram.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CEPDspProgram.cpp                                                 *
*	interface for accessing DSP program information                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uep.h>
#include <AudioHw.h>
};

#include "CDspProgram.h"
#include "CEPDspProgram.h"

// the header files are generated at 
// build time... by the build batch file
static U032 AC3SuperExec[] = 
{
#include <AC3SuperExec.h>
};

static U032 AC3Loader[] =
{
#include <AC3Loader.h>
};

static U032 AC3Dolby1[] =
{
#include <AC3Dolby1.h>
};

static U032 AC3Dolby2[] =
{
#include <AC3Dolby2.h>
};

static U032 AC3Dolby3[] =
{
#include <AC3Dolby3.h>
};

static U032 AC3Dolby4[] =
{
#include <AC3Dolby4.h>
};

typedef struct
{
    U032 table_size;
    U032 do_surround_encode;
    U032 do_game_encode;
    U032 pcm_sample_rate_code;
    U032 input_ch_config;
    U032 lfe_present;
    U032 ac3_dialnorm;
    U032 ac3_bandwidth;
    U032 channel_lpf_enabled;
    U032 lfe_lpf_enabled;
    U032 dc_hpf_enabled;
    U032 dynrng_exists;
    U032 ac3_dynrng_code;
    U032 compr_exists;
    U032 ac3_compr_code;
    U032 surround_gain_enabled;
    U032 surround_gain;
    U032 surround_mode;
} DOLBY_CONFIG_TABLE;

static DOLBY_CONFIG_TABLE AC3ConfigTable =
  {
    18,        // table size
    1,         // perform dolby surround encode flag
    1,         // perform dolby game encode flag
    0,         // ac3 pcm sampling rate code
    7,         // ac3 dolby input channel config code (acmod)
    1,         // lfe channel present flag
    16,        // ac3 dialnorm value
    9,         // ac3 channel bandwidth code
    1,         // channel lpf enabled flag
    1,         // lfe channel lpf enabled flag
    1,         // dc hpf enabled flag
    0,         // dynrng exists flag
    0,         // ac3 dynrng code
    1,         // compr exists flag
    0xEF,      // ac3 compr code
    1,         // dolby surround gain enabled flag
    0x47FACD,  // dolby surround encoder gain value
    2          // dolby surround mode. Only used for 2/0 Mode
  };

U032
CEPDspProgram::AC3GetTotalScratchSize()
{
    // in bytes
    return (AC3_DOLBYBASE * sizeof(U032) + 
            sizeof(AC3Dolby1) + 
            sizeof(AC3Dolby2) + 
            sizeof(AC3Dolby3) + 
            sizeof(AC3Dolby4) +
            sizeof(DOLBY_CONFIG_TABLE) + 
            AC3_HEAPLENGTH * sizeof(U032));
}

VOID
CEPDspProgram::AC3GetSuperExec(VOID_PTR *ppData, U032 *pLength, U032 *pBase)
{
    *ppData  = (VOID_PTR)AC3SuperExec;
    *pLength = sizeof(AC3SuperExec)/sizeof(U032);
    *pBase   = AC3_SUPREXECBASE;
}

VOID
CEPDspProgram::AC3GetLoader(VOID_PTR *ppData, U032 *pLength, U032 *pBase)
{
    *ppData  = (VOID_PTR)AC3Loader;
    *pLength = sizeof(AC3Loader)/sizeof(U032);
    *pBase   = AC3_LOADERBASE;
}

VOID_PTR 
CEPDspProgram::AC3GetConfigTable()
{
    return (VOID_PTR)&AC3ConfigTable;
}

VOID
CEPDspProgram::AC3GetProgram(U032 uIndex, VOID_PTR *ppData, U032 *pLength)
{
    switch(uIndex)
    {
    case 0:
        *ppData  = (VOID_PTR)AC3Dolby1;
        *pLength = sizeof(AC3Dolby1)/sizeof(U032);
        break;
    case 1:
        *ppData  = (VOID_PTR)AC3Dolby2;
        *pLength = sizeof(AC3Dolby2)/sizeof(U032);
        break;
    case 2:
        *ppData  = (VOID_PTR)AC3Dolby3;
        *pLength = sizeof(AC3Dolby3)/sizeof(U032);
        break;
    case 3:
        *ppData  = (VOID_PTR)AC3Dolby4;
        *pLength = sizeof(AC3Dolby4)/sizeof(U032);
        break;

    default:
        *ppData  = NULL;
        *pLength = 0;
        break;
    }
}

VOID
CEPDspProgram::Initialize()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPMethod.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CEPMethod.h                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CEPMETHODH_
#define _CEPMETHODH_

#define METHOD_MIN_OFFSET(x)       (x)
#define METHOD_MAX_OFFSET(x)       ((x) + 0x4)

class CHalBase;
class CHalExtendedProc;

class CEPMethod
{
public:
    CEPMethod(CHalBase *pHal, CHalExtendedProc *pProc) 
    { 
        m_pHal = pHal;
        m_pProc = pProc;
        m_uCurrSge = 0;
        m_uBaseAddr = 0;
        m_uMaxOffset = 0;
    }

    ~CEPMethod() { };

public:
    RM_STATUS Execute(U032 uOffset, U032 uData);

private:
    CHalBase            *m_pHal;
    CHalExtendedProc    *m_pProc;

    // SW methods
    RM_STATUS SetCurrentSge(U032 uData);
    RM_STATUS SetSgeBaseAddr(U032, U032);
    RM_STATUS SetSgeLength(U032, U032);
    RM_STATUS SetContextDMA(U032);
    RM_STATUS SetSgeOffset(U032);
    RM_STATUS SetState(U032);
    RM_STATUS SetAC3Fifo(U032);

    // utility
    VOID GetBaseAndEnd(U032 uIndex, U032 *pBase, U032 *pEnd);
    VOID GetBaseCurEnd(U032 uIndex, U032 *pBase, U032 *pCur, U032 *pEnd);
    BOOL CheckRange(U032 uOffset, U032 uMethodOffset)   
    { 
        return ((uOffset >= METHOD_MIN_OFFSET(uMethodOffset)) && 
                (uOffset < METHOD_MAX_OFFSET(uMethodOffset))?TRUE:FALSE);
    }

    // variables equiv of some GP regs
    U032    m_uCurrSge;
    U032    m_uBaseAddr;
    U032    m_uMaxOffset;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPScratchManager.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CEPScratchManager.h                                               *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CEPSCRATCHMANAGER_
#define _CEPSCRATCHMANAGER_

class CScratchManager;
class CEPDspProgram;
class CHalGlobalProc;

class CEPScratchManager : public CScratchManager
{
public:
    CEPScratchManager(CHalBase *pHalBase);
    ~CEPScratchManager();

public:
    RM_STATUS   Initialize(VOID_PTR pLoader, U032 uLoaderSize);
	RM_STATUS	Initialize(CEPDspProgram *pDspProgram, CHalGlobalProc *pGlHal);
    
    RM_STATUS   AC3SetAnalogOutput(U032 uOffset, U032 uSize);   // actually a FIFO index
    RM_STATUS   AC3SetDigitalOutput(U032 uOffset, U032 uSize);  // actually a FIFO index

private:
    
    RM_STATUS   AC3StartGpInput(U032 uLinOffset);
    VOID        AC3StopGpInput();

    CHalBase        *m_pHal;
    // only used for AC3 stuff...
    CHalGlobalProc  *m_pGlobalProc;
    CEPDspProgram   *m_pDspProgram;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\cgpdspprogram.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CGPDspProgram.cpp                                                 *
*	interface for accessing DSP program information                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_ugp.h>
#include <AudioHw.h>
};

#include "CDspProgram.h"
#include "CGPDspProgram.h"

// all effects that can be loaded to the GP follow...

// the header files are generated at 
// build time... by the build batch file

// digital wire
static U032 WireDelaySize = 0;
static U032 Wire[] = 
{
#include <Wire.h>
};



VOID
CGPDspProgram::Initialize()
{
    m_uLoaderSize = 0;
    m_pLoader = NULL;

    // assign all the effects here

    // digital wire
    /*
    m_Effect[NV_AUDGP_SET_EFFECT_TYPE_TYPE_GENERICFX].pCode = (VOID_PTR)Wire;
    m_Effect[NV_AUDGP_SET_EFFECT_TYPE_TYPE_GENERICFX].uCodeSize = sizeof(Wire);
    m_Effect[NV_AUDGP_SET_EFFECT_TYPE_TYPE_GENERICFX].uDelaySize = WireDelaySize * sizeof(U032);
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPScratchManager.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CEPScratchManager.cpp                                              *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv32.h>
#include <aos.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalGlobalProc.h"
#include "CScratchDma.h"
#include "CScratchManager.h"
#include "CEPScratchManager.h"
#include "CDspProgram.h"
#include "CEPDspProgram.h"

#define MAX_SIZE_SCRATCH_EP     65536

#define AC3_BUFFER_COUNT        2      // so we can ping-pong
#define AC3_FRAME_SIZE          256
#define AC3_CONTAINER_SIZE      4
#define AC3_NUM_CHANNELS        6
#define AC3_NUM_INPUT_PAGES     ((AC3_BUFFER_COUNT * AC3_FRAME_SIZE * AC3_CONTAINER_SIZE * AC3_NUM_CHANNELS) + PAGE_SIZE-1)  / PAGE_SIZE

CEPScratchManager::CEPScratchManager(CHalBase *pHal)
{
    m_pHal = pHal;
    m_pGlobalProc = NULL;
    m_pDspProgram = NULL;
}

CEPScratchManager::~CEPScratchManager()
{
    
    // if this was an AC-3 party, then stop it at the GP
    if (m_pGlobalProc)
        AC3StopGpInput();

    Shutdown();

    CScratchDma *pScratchDma = GetScratchDma();
    if (pScratchDma)
    {
        VOID *pScratchTable = pScratchDma->GetScratchTableLinAddr();
        aosFreeMem(pScratchTable);
        delete pScratchDma;
    }
}


RM_STATUS   
CEPScratchManager::Initialize(VOID_PTR pLoader, U032 uLoaderSize)
{
    // allocate the scratch Dma
    CScratchDma *pScratchDma = new CScratchDma(m_pHal, NV_PAPU_EPSMAXSGE);
    if (!pScratchDma)
        return RM_ERROR;

    // 	configure the HW
    VOLU32 vTemp = (MAX_SIZE_SCRATCH_EP/PAGE_SIZE);
	m_pHal->RegWrite(NV_PAPU_EPSMAXSGE, LOW16(vTemp));
	m_pHal->RegRead(NV_PAPU_EPSMAXSGE, &vTemp);

    MEM_DESC ScratchTable;

    ScratchTable.Size = (vTemp + 1)*NV_PSGE_SIZE;

    // allocate the scratch table - PRDs for the max size
    RM_STATUS rmStatus = aosAllocateMem(ScratchTable.Size,
						                ALIGN_16K,
						                &ScratchTable.pLinAddr,
						                &ScratchTable.pPhysAddr);

    if (rmStatus != RM_OK)
        return rmStatus;

    m_pHal->RegWrite(NV_PAPU_EPSADDR, (U032) ScratchTable.pPhysAddr);
    
    rmStatus = pScratchDma->Initialize(&ScratchTable);
    if (rmStatus != RM_OK)
        return rmStatus;
    
    // if everything is good till now.. initialize the base object
    CScratchManager::SetScratchDma(pScratchDma);
    //rmStatus = CScratchManager::Initialize(pLoader, uLoaderSize);

    return rmStatus;
}

// this initialize is for AC3 configuration
RM_STATUS   
CEPScratchManager::Initialize(CEPDspProgram *pProgram, CHalGlobalProc *pGlobalProc)
{
    // allocate the scratch Dma
    CScratchDma *pScratchDma = new CScratchDma(m_pHal, NV_PAPU_EPSMAXSGE);
    if (!pScratchDma)
        return RM_ERROR;
    
    m_pGlobalProc = pGlobalProc;
    m_pDspProgram = pProgram;

    // total pages required
    U032 uPagesRequired = (m_pDspProgram->AC3GetTotalScratchSize()+PAGE_SIZE-1) / PAGE_SIZE;

    // 256 frames 4 bytes per frame 6 channels = 1.5 pages so add 2 pages
    uPagesRequired += AC3_NUM_INPUT_PAGES;

    U032 uPagesAvail;

	// find out if HW supports the max indexes (index = pages - 1)
    m_pHal->RegWrite(NV_PAPU_EPSMAXSGE, LOW16(uPagesRequired - 1));
	m_pHal->RegRead(NV_PAPU_EPSMAXSGE, &uPagesAvail);

    if (uPagesAvail != LOW16(uPagesRequired - 1))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CEPScratchManager::Initialize - PRDs not available for fixed effect\n");
        return RM_ERROR;
    }


    MEM_DESC ScratchTable;

    ScratchTable.Size = uPagesRequired * NV_PSGE_SIZE;

    // allocate the scratch table - PRDs for the max size
    RM_STATUS rmStatus = aosAllocateMem(ScratchTable.Size,
						                ALIGN_16K,
						                &ScratchTable.pLinAddr,
						                &ScratchTable.pPhysAddr);

    if (rmStatus != RM_OK)
        return rmStatus;

    m_pHal->RegWrite(NV_PAPU_EPSADDR, (U032) ScratchTable.pPhysAddr);
    
    rmStatus = pScratchDma->Initialize(&ScratchTable);
    if (rmStatus != RM_OK)
        return rmStatus;
    
    CScratchManager::SetScratchDma(pScratchDma);
    
    U032 uOffset;
    // allocate space for AC3...
    rmStatus = pScratchDma->Allocate(uPagesRequired * PAGE_SIZE, &uOffset);
    if (rmStatus != RM_OK)
        return rmStatus;
    
    // sanity check!
    if (uOffset)
        aosDbgBreakPoint();

    // now that we have the memory allocated
    VOID_PTR pCode;
    U032 uLength; // in words
    U032 uBase;   // in words
    
    // superexec
    m_pDspProgram->AC3GetSuperExec(&pCode, &uLength, &uBase);
    pScratchDma->Write(uBase*sizeof(U032), (VOID *)pCode, uLength*sizeof(U032));

    // loader
    m_pDspProgram->AC3GetLoader(&pCode, &uLength, &uBase);
    pScratchDma->Write(uBase*sizeof(U032), (VOID *)pCode, uLength*sizeof(U032));

    // loader table
    DOLBY_LOADER_TABLE LoaderTable;


    LoaderTable.tableSize = sizeof(DOLBY_LOADER_TABLE) / sizeof(U032);
    LoaderTable.maxProgs = m_pDspProgram->AC3GetMaxPrograms();

    // now copy the four Dolby encoder programs into system memory so the DSP can
    // DMA them when it needs them.  Keep track of the current offset into the
    // buffer, and update the loader table with the addresses as we go along.
    uBase = m_pDspProgram->AC3GetProgramBase();
    
    U032 uCnt;
    for (uCnt = 0; uCnt < m_pDspProgram->AC3GetMaxPrograms(); uCnt++)
    {
        // get program
        m_pDspProgram->AC3GetProgram(uCnt, &pCode, &uLength);

        // copy into scratch 
        pScratchDma->Write(uBase*sizeof(U032), (VOID *)pCode, uLength*sizeof(U032));

        // update the loader table
        LoaderTable.prog[uCnt].ptr  = uBase;
        LoaderTable.prog[uCnt].size = uLength;

        // update the current scratch index
        uBase += uLength;
    }

    // now the config table
    U032 *pConfig = (U032 *)m_pDspProgram->AC3GetConfigTable();
     // Note: the AC3 config table is actually a DOLBY_CONFIG_TABLE,
     // not a U032...  The size is contained in the first word of the
     // table, so we will treat it here as a U032 array.
    uLength = pConfig[0];
    LoaderTable.config_ptr  = uBase;
    LoaderTable.config_size = uLength;
    pScratchDma->Write(uBase*sizeof(U032), (VOID *)pConfig, uLength*sizeof(U032));
    uBase += uLength;
    
    //Init pingpong buffer offset
    LoaderTable.pingpong_offset = 0;
    LoaderTable.reserved1 = 0;
    LoaderTable.reserved2 = 0;
    LoaderTable.reserved3 = 0;
    
    // now for the heap
    uLength = m_pDspProgram->AC3GetHeapLength();
    LoaderTable.heap_ptr  = uBase;
    LoaderTable.heap_size = uLength;
    uBase += uLength;
    
    // copy the table to the offset
    pScratchDma->Write(sizeof(U032)*m_pDspProgram->AC3GetLoaderTableBase(), (VOID *)&LoaderTable, sizeof(DOLBY_LOADER_TABLE));

    return AC3StartGpInput((uPagesRequired - AC3_NUM_INPUT_PAGES) * PAGE_SIZE);
}



RM_STATUS
CEPScratchManager::AC3StartGpInput(U032 uLinOffset)
{
    if (!m_pGlobalProc)
        return RM_ERROR;

    // use the last n pages for ac-3 input from the GP
    MEM_DESC mem[AC3_NUM_INPUT_PAGES];
    
    U032 uOffset = m_pDspProgram->AC3GetLoaderTableBase() * sizeof(U032);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(pcm_ptr), uLinOffset/sizeof(U032));  
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(pcm_size), AC3_FRAME_SIZE * AC3_NUM_CHANNELS);

    // program the same pages in the GP
    for (U032 uCnt = 0; uCnt < AC3_NUM_INPUT_PAGES; uCnt++)
    {
        mem[uCnt].pLinAddr = GetScratchDma()->GetLinAddr(uLinOffset);
        mem[uCnt].pPhysAddr = GetScratchDma()->GetPhysAddr(uLinOffset);
        mem[uCnt].Size = PAGE_SIZE;
        uLinOffset += mem[uCnt].Size;
    }
    
    return m_pGlobalProc->AC3SetOutputBuffer(mem, AC3_NUM_INPUT_PAGES);
}

VOID
CEPScratchManager::AC3StopGpInput()
{
    if (!m_pGlobalProc)
        return;

    MEM_DESC mem[AC3_NUM_INPUT_PAGES];

    // update the loader table
    U032 uOffset = GetScratchDma()->Get( (m_pDspProgram->AC3GetLoaderTableBase()* sizeof(U032)) + DOLBY_LOADER_TABLE_OFFSET(pcm_ptr));

    // program the same pages in the GP
    for (U032 uCnt = 0; uCnt < AC3_NUM_INPUT_PAGES; uCnt++)
    {
        mem[uCnt].pLinAddr = GetScratchDma()->GetLinAddr(uOffset*sizeof(U032));
        mem[uCnt].pPhysAddr = GetScratchDma()->GetPhysAddr(uOffset*sizeof(U032));
        mem[uCnt].Size = PAGE_SIZE;
        uOffset += mem[uCnt].Size;
    }    
    m_pGlobalProc->AC3RemoveOutputBuffer(mem, AC3_NUM_INPUT_PAGES);
}

RM_STATUS
CEPScratchManager::AC3SetAnalogOutput(U032 uAnalogFIFO, U032 uSize)
{
    if (!m_pGlobalProc)
        return RM_ERROR;

    U032 uOffset = m_pDspProgram->AC3GetLoaderTableBase() * sizeof(U032);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ltrt_ptr), uAnalogFIFO);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ltrt_size), uSize/sizeof(U032));

    return RM_OK;
}

RM_STATUS
CEPScratchManager::AC3SetDigitalOutput(U032 uDigitalFIFO, U032 uSize)
{
    if (!m_pGlobalProc)
        return RM_ERROR;

    U032 uOffset = m_pDspProgram->AC3GetLoaderTableBase() * sizeof(U032);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_ptr), uDigitalFIFO);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_zero_fill), uDigitalFIFO);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_preamble), uDigitalFIFO);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_size), uSize/sizeof(U032));

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CGPDspProgram.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CGpDspProgram.h                                                   *
*	interface for accessing DSP program information  for GP                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CGPDSPPROGRAMH_
#define _CGPDSPPROGRAMH_

class CDspProgram;

class CGPDspProgram : public CDspProgram
{
public:
    VOID        Initialize();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\cgpmethod.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CGpMethod.cpp                                                       *
*     SW functions for the GP                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <aos.h>
#include <nv_ugp.h>
#include <nv32.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CDspProgram.h"
#include "CGPDspProgram.h"
#include "CScratchManager.h"
#include "CScratchDma.h"
#include "CGpScratchManager.h"
#include "CHalGlobalProc.h"
#include <CLinkList.h>
#include "CCommandQ.h"
#include "CContextDma.h"
#include "CMixerBuffer.h"
#include "CGpMethod.h"
#include "AudioFx.h"

CGPMethod::CGPMethod(CHalGlobalProc *pProc, CGPScratchManager *pMgr, CGPDspProgram *pDsp, CHalBase *pHal)
{
    m_pScratchManager = pMgr;
    m_uActiveEffect = 0;
    m_pDspProgram = pDsp;
    m_pHal = pHal;
    m_pGlobalProc = pProc;
    m_pCommandQ = NULL;
    m_pAudioFx = NULL;
    m_pMixerBuffer = NULL;
    
    m_ExecutionList.uCount = 0;

    for (U032 uCnt = 0; uCnt < MAX_EFFECTS; uCnt++)
    {
        m_EffectInfo[uCnt].eState = FREE;
        m_EffectInfo[uCnt].pParamDma = NULL;

        // initialize the execution list
        m_ExecutionList.uEffects[uCnt] = kAudioFxModule_EmptyID;
    }

}


CGPMethod::~CGPMethod()
{
    if (m_pAudioFx)
        delete m_pAudioFx;

    if (m_pCommandQ)
        delete m_pCommandQ;

    if (m_pMixerBuffer)
        delete m_pMixerBuffer;

    m_pAudioFx = NULL;
    m_pCommandQ = NULL;
    m_pMixerBuffer = NULL;
}

RM_STATUS
CGPMethod::Initialize()
{
    RM_STATUS rmStatus = RM_ERROR;

    m_pCommandQ = new CCommandQ(m_pHal);
    if (m_pCommandQ)
        rmStatus = m_pCommandQ->Initialize(CCommandQ::Q_TYPE_GP);

    m_pAudioFx = new AUDIOFX(MAX_EFFECTS, m_pScratchManager->GetScratchDma());
    if (!m_pAudioFx)
        rmStatus = RM_ERROR;
    else
    {
        m_pMixerBuffer = new CMixerBuffer;
        if (!m_pMixerBuffer)
            rmStatus = RM_ERROR;
    }

    return rmStatus;
}

VOID *
CGPMethod::GetCommandQAddress() 
{ 
    return m_pCommandQ->GetLinAddr();
}

VOID
CGPMethod::Execute()
{
    RM_STATUS rmStatus;
    U032 uMethod;
    U032 uData;
    BOOL bWriteNotifier = FALSE;
    BOOL bQEmpty = FALSE;
    U032 uNotifierData;
    U032 uNotifierStatus;
    U032 uFifoNumber;
    U032 uSize;

    while (!bQEmpty)
    {
        m_pCommandQ->Read(&uMethod);

        bQEmpty = m_pCommandQ->Read(&uData);

        uNotifierStatus = 0;
        uFifoNumber = ~0;

        // execute the methods
        switch(uMethod)
        {
        case NV_AUDGP_REGISTER_EFFECT:
            uNotifierData = (U032)m_pAudioFx->RegisterModuleType((AUDIOFX_PLUGIN *)uData);
            bWriteNotifier = TRUE;
            break;

        case NV_AUDGP_ADD_EFFECT:
		// FIXXXX: this will temporarily get around the check-in.  Fix !!!!
            uNotifierData = (U032)m_pAudioFx->AddModule("IIR2");
            bWriteNotifier = TRUE;
            break;

        case NV_AUDGP_SET_CURRENT_EFFECT:
            rmStatus = SetCurrentEffect(uData);
            break;

        case NV_AUDGP_ROUTE_EFFECT:
            {
                STRUCT_ROUTE_EFFECT rRouteEffect;
                rRouteEffect.uValue = uData;
            
                U032 uBufID;
                if (rRouteEffect.connection == NV_AUDGP_ROUTE_EFFECT_CONNECTION_ENABLE)
                    uBufID = rRouteEffect.bufid;
                else
                {
                    // a null id means the connection from the pin is null... but can there be a case 
                    // of one pin pointing to multiple buffers???  probably not... it'll need to go through
                    // a mixer...
                    uBufID = kAudioFX_BufferID_Null; 
                }

            
                if (rRouteEffect.orientation == NV_AUDGP_ROUTE_EFFECT_ORIENTATION_SOURCE)
                    m_pAudioFx->SetModule_OutBuffer(rRouteEffect.effectID, rRouteEffect.pin, uBufID);
                else
                    m_pAudioFx->SetModule_InBuffer(rRouteEffect.effectID, rRouteEffect.pin, uBufID);
            }
            break;

        case NV_AUDGP_ROUTE_TO_FIFO:
            {
                STRUCT_ROUTE_TO_FIFO rRoutoFifo;
                rRoutoFifo.uValue = uData;
            
                U032 uBufferID;

                // find the buffer ID
                if (rRoutoFifo.fifoType == NV_AUDGP_ROUTE_TO_FIFO_TYPE_INPUT)
                {
                    if (rRoutoFifo.fifoNum == 0)
                        uBufferID = kAudioFX_BufferID_FIFO0_Input;
                    else
                        uBufferID = kAudioFX_BufferID_FIFO1_Input;

                }
                else
                {
                    switch(rRoutoFifo.fifoNum)
                    {
                    case 0:
                        uBufferID = kAudioFX_BufferID_FIFO0_Output;
                        break;
                    case 1:
                        uBufferID = kAudioFX_BufferID_FIFO1_Output;
                        break;
                    case 2:
                        uBufferID = kAudioFX_BufferID_FIFO2_Output;
                        break;
                    case 3:
                        uBufferID = kAudioFX_BufferID_FIFO3_Output;
                        break;
                    default:
                        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CGPMethod::NV_AUDGP_ROUTE_TO_FIFO - only 4 output FIFOs!\n");
                        aosDbgBreakPoint();
                    }
                }

                uBufferID += (rRoutoFifo.fifoPin + 1);

                if (rRoutoFifo.connection == NV_AUDGP_ROUTE_TO_FIFO_CONNECTION_DISABLE)
                    uBufferID = kAudioFX_BufferID_Null;

                // so if it's an input fifo.. then does it feed an effect.. liek an input buffer?
                // it seems to be so...

                // now... i hope audiofx ignores inIndex (effect pin..), if it's a buffer, and not an effect
                if (rRoutoFifo.fifoType == NV_AUDGP_ROUTE_TO_FIFO_TYPE_INPUT)
                    m_pAudioFx->SetModule_InBuffer(rRoutoFifo.sourceID, rRoutoFifo.sourcePin, uBufferID);
                else
                    m_pAudioFx->SetModule_OutBuffer(rRoutoFifo.sourceID, rRoutoFifo.sourcePin, uBufferID);
            }
            break;

        case NV_AUDGP_QUERY_EFFECT:
            {
                STRUCT_QUERY_EFFECT rQueryEffect;
                rQueryEffect.uValue = uData;
                uNotifierData = (U032) m_pAudioFx->QueryModule(rQueryEffect.effectID, rQueryEffect.typeID);
                bWriteNotifier = TRUE;
            }
            break;

        case NV_AUDGP_DEREGISTER_EFFECT:
            m_pAudioFx->UnregisterModuleType(uData);
            break;

        case NV_AUDGP_GET_MIX_BUFFER:
            rmStatus = GetMixBuffer(uData, &uNotifierData);
            bWriteNotifier = TRUE;
            break;

        case NV_AUDGP_FREE_MIX_BUFFER:
            m_pMixerBuffer->Free((U008)uData);
            break;

        case NV_AUDGP_SET_CONTEXT_DMA_NOTIFIER:
            rmStatus = SetContextDmaNotifier(uData);
            break;
    
        case NV_AUDGP_SET_CONTEXT_DMA_PARAMETER:
            rmStatus = SetContextDmaParameter(uData);
            break;

        case NV_AUDGP_SET_CONTEXT_DMA_DSP_CODE:
            rmStatus = SetContextDmaDspCode(uData);
            break;

        case NV_AUDGP_UPDATE_EFFECT_PARAMETERS:
            {
                rmStatus = RM_ERROR;
                VOID *pParamData;
                U032 uEffectId = uData;

                // check if the context DMA for the effect params has been allocated
                if (m_EffectInfo[uEffectId].pParamDma)
                {
                    pParamData = m_EffectInfo[uEffectId].pParamDma->GetLinAddr();
                    m_pAudioFx->SetModule(uEffectId, pParamData);
                    rmStatus = RM_OK;
                }
            }
            break;

        case NV_AUDGP_ENABLE_EFFECT:
        case NV_AUDGP_DISABLE_EFFECT:
            UpdateExecutionList(uData, (uMethod==NV_AUDGP_ENABLE_EFFECT)?TRUE:FALSE);
            m_pAudioFx->SetModuleExecutionList((long *)&m_ExecutionList.uEffects[0], m_ExecutionList.uCount);
            break;
        
        case NV_AUDGP_DELETE_EFFECT:
            m_pAudioFx->DeleteModule(uData);
            break;


        case NV_AUDGP_SET_EXECUTION_LIST:
            U032 id;
            m_ExecutionList.uCount = uData;
            for(id =0;id < uData;id++)
                bQEmpty = m_pCommandQ->Read(&m_ExecutionList.uEffects[id]);
            m_pAudioFx->SetModuleExecutionList((long *)&m_ExecutionList.uEffects[0], m_ExecutionList.uCount);
            break;


        case NV_AUDGP_CONFIGURE_OUTPUT_FIFO(0):
        case NV_AUDGP_CONFIGURE_OUTPUT_FIFO(1):
        case NV_AUDGP_CONFIGURE_OUTPUT_FIFO(2):
        case NV_AUDGP_CONFIGURE_OUTPUT_FIFO(3):
        case NV_AUDGP_CONFIGURE_INPUT_FIFO(0):
        case NV_AUDGP_CONFIGURE_INPUT_FIFO(1):
            bQEmpty = m_pCommandQ->Read(&uData);
            ConfigureFifo(uMethod, uData);
            break;

        case NV_AUDGP_ALLOC_SCRATCH_MEMORY:
            m_pScratchManager->GetScratchDma()->Allocate(uData,&uNotifierData);
            bWriteNotifier = TRUE;
            break;

        case NV_AUDGP_FREE_SCRATCH_MEMORY:
            bQEmpty = m_pCommandQ->Read(&uSize);
            m_pScratchManager->GetScratchDma()->Free(uData,uSize);

        case NV_AUDGP_SET_SCRATCH_MEMORY:
            U032 uValue;
            m_pCommandQ->Read(&uSize);
            bQEmpty = m_pCommandQ->Read(&uValue);
            m_pScratchManager->GetScratchDma()->Put(uData, uSize, uValue);
            break;

        default:
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CGPMethod::Execute - unknown method\n");
            break;
        }

        // write the notifier...
        if (bWriteNotifier)
            m_pGlobalProc->WriteNotifier(uMethod, uNotifierData, (U008)rmStatus);

    }
}


// gp methods handled by this class
RM_STATUS
CGPMethod::SetCurrentEffect(U032 uData)
{
    if (uData < MAX_EFFECTS)
    {
        m_uActiveEffect = uData;
        return RM_OK;
    }
    
    return RM_ERROR;
}


RM_STATUS
CGPMethod::SetContextDmaNotifier(U032 uData)
{
    RM_STATUS rmStatus = RM_OK;
    CContextDma *pDma = (CContextDma *)uData;
    
    // in debug mode... do some checks... todo vik
    m_pHal->RegWrite( NV_PAPU_GPNADDR, (U032)(pDma->GetAddress()) );

    // set the notifier memory in the GP
    m_pGlobalProc->SetNotifierMemory(pDma->GetLinAddr(), pDma->GetSize());
    return RM_OK;
}

RM_STATUS
CGPMethod::SetContextDmaParameter(U032 uData)
{
    // i dunno if i wanna check if the effect is allocated
    m_EffectInfo[m_uActiveEffect].pParamDma = (CContextDma *)uData;
    return RM_OK;
}


RM_STATUS
CGPMethod::SetContextDmaDspCode(U032 uData)
{
    // i dunno if i wanna check if the effect is allocated
    m_EffectInfo[m_uActiveEffect].pDspCodeDma = (CContextDma *)uData;
    return RM_OK;
}


RM_STATUS
CGPMethod::GetMixBuffer(U032 uArg, U032 *pId)
{
    RM_STATUS rmStatus = RM_ERROR;

    *pId = 0;

    if ( (0x3 & uArg) != NV_AUDGP_GET_MIX_BUFFER_TYPE_SW )
        rmStatus = m_pMixerBuffer->Allocate(m_pMixerBuffer->MIXER_TYPE::HW, (U008 *)pId);

    if (rmStatus == RM_ERROR)
        rmStatus = m_pMixerBuffer->Allocate(m_pMixerBuffer->MIXER_TYPE::SW, (U008 *)pId);

    return rmStatus;
}

VOID
CGPMethod::UpdateExecutionList(U032 uEffectID, BOOL bOption)
{
    if (bOption == (BOOL)TRUE)
    {
        m_ExecutionList.uEffects[m_ExecutionList.uCount++] = uEffectID;
        return;
    }
    else
    {
        // remove it from the execution list
        for (U032 uCnt = 0; uCnt < m_ExecutionList.uCount; uCnt++)
        {
            if (m_ExecutionList.uEffects[uCnt] == uEffectID)
            {
                for (U032 uCnt1 = uCnt; uCnt1 < m_ExecutionList.uCount-1; uCnt1++)
                    m_ExecutionList.uEffects[uCnt1] = m_ExecutionList.uEffects[uCnt1+1];

                m_ExecutionList.uCount--;
                return;
            }
        }

        // some crap has happened... cant find effect!
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "CGPMethod::UpdateExecutionList - cannot find method!\n");
    }
}

VOID
CGPMethod::ConfigureFifo(U032 uMethod, U032 uData)
{
    R_GP_CTLOUT rCtlOut;
    R_GP_CTLIN rCtlIn;

    U032 uRegOffset;
    U032 uRegValue;

    STRUCT_CONFIGURE_FIFO sConfigFifo;

    m_pHal->RegRead(NV_PAPU_GPCTLOUT, &rCtlOut.uValue);
    sConfigFifo.uValue = uData;
    
    U032 uContainerSize;
    if (sConfigFifo.size == NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_8_8)
        uContainerSize = NV_PAPU_GPCTLOUT_GD0SIZ_8;
    else if (sConfigFifo.size == NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_32_32)
        uContainerSize = NV_PAPU_GPCTLOUT_GD0SIZ_32;
    else
        uContainerSize = NV_PAPU_GPCTLOUT_GD0SIZ_16;

    if (uMethod == NV_AUDGP_CONFIGURE_OUTPUT_FIFO(0))
    {
        rCtlOut.format0 = sConfigFifo.format;
        rCtlOut.type0 = sConfigFifo.type;
        rCtlOut.size0 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLOUT;
        uRegValue = rCtlOut.uValue;
        m_pAudioFx->SetOutputFIFOFormat(0, sConfigFifo.format, sConfigFifo.size);
    }
    else if (uMethod == NV_AUDGP_CONFIGURE_OUTPUT_FIFO(1))
    {
        rCtlOut.format1 = sConfigFifo.format;
        rCtlOut.type1 = sConfigFifo.type;
        rCtlOut.size1 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLOUT;
        uRegValue = rCtlOut.uValue;
        m_pAudioFx->SetOutputFIFOFormat(1, sConfigFifo.format, sConfigFifo.size);
    }
    else if (uMethod == NV_AUDGP_CONFIGURE_OUTPUT_FIFO(2))
    {
        rCtlOut.format2 = sConfigFifo.format;
        rCtlOut.type2 = sConfigFifo.type;
        rCtlOut.size2 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLOUT;
        uRegValue = rCtlOut.uValue;
        m_pAudioFx->SetOutputFIFOFormat(2, sConfigFifo.format, sConfigFifo.size);
    }
    else if (uMethod == NV_AUDGP_CONFIGURE_OUTPUT_FIFO(3))
    {
        rCtlOut.format3 = sConfigFifo.format;
        rCtlOut.type3 = sConfigFifo.type;
        rCtlOut.size3 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLOUT;
        uRegValue = rCtlOut.uValue;
        m_pAudioFx->SetOutputFIFOFormat(3, sConfigFifo.format, sConfigFifo.size);
    }
    else if (uMethod == NV_AUDGP_CONFIGURE_INPUT_FIFO(0))
    {
        rCtlIn.format0 = sConfigFifo.format;
        rCtlIn.type0 = sConfigFifo.type;
        rCtlIn.size0 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLIN;
        uRegValue = rCtlIn.uValue;
        m_pAudioFx->SetInputFIFOFormat(0, sConfigFifo.format, sConfigFifo.size);
    }
    else
    {
        rCtlIn.format1 = sConfigFifo.format;
        rCtlIn.type1 = sConfigFifo.type;
        rCtlIn.size1 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLIN;
        uRegValue = rCtlIn.uValue;
        m_pAudioFx->SetInputFIFOFormat(1, sConfigFifo.format, sConfigFifo.size);
    }
    
    m_pHal->RegWrite(uRegOffset, uRegValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\cgpscratchmanager.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CGPScratchManager.cpp                                              *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <aos.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include "CHalBase.h"
#include "CScratchDma.h"
#include "CScratchManager.h"
#include "CGPScratchManager.h"

#define MAX_SIZE_SCRATCH_GP     0x200000            //2 Meg

CGPScratchManager::CGPScratchManager(CHalBase *pHal)
{
    m_pHal = pHal;
}

CGPScratchManager::~CGPScratchManager()
{
    CScratchManager::Shutdown();
    
    CScratchDma *pScratchDma = GetScratchDma();
    
    if (pScratchDma)
    {
        VOID *pScratchTable = pScratchDma->GetScratchTableLinAddr();
        aosFreeMem(pScratchTable);
        delete pScratchDma;
    }
    
    SetScratchDma(NULL);
}


RM_STATUS   
CGPScratchManager::Initialize(VOID_PTR pLoader, U032 uLoaderSize)
{
    // allocate the scratch Dma
    CScratchDma *pScratchDma = new CScratchDma(m_pHal, NV_PAPU_GPSMAXSGE);
    if (!pScratchDma)
        return RM_ERROR;

    // 	configure the HW
    VOLU32 vTemp = (MAX_SIZE_SCRATCH_GP/PAGE_SIZE);
	m_pHal->RegWrite(NV_PAPU_GPSMAXSGE, LOW16(vTemp));
	m_pHal->RegRead(NV_PAPU_GPSMAXSGE, &vTemp);

    MEM_DESC ScratchTable;

    ScratchTable.Size = (vTemp + 1)*NV_PSGE_SIZE;

    // allocate the scratch table - PRDs for the max size
    RM_STATUS rmStatus = aosAllocateMem(ScratchTable.Size,
						                ALIGN_16K,
						                &ScratchTable.pLinAddr,
						                &ScratchTable.pPhysAddr);

    if (rmStatus != RM_OK)
        return rmStatus;

    m_pHal->RegWrite(NV_PAPU_GPSADDR, (U032) ScratchTable.pPhysAddr);
    
    rmStatus = pScratchDma->Initialize(&ScratchTable);
    if (rmStatus != RM_OK)
        return rmStatus;

    // if everything is good till now.. initialize the base object
    SetScratchDma(pScratchDma);
    //rmStatus = CScratchManager::Initialize(pLoader, uLoaderSize);

    //HACK allocate a bunch of Scratch for effects until we can allocate correctly
    if (rmStatus != RM_OK)
        return rmStatus;

    U032 Offset;
    rmStatus = pScratchDma->Allocate(0x100000,&Offset);

    return rmStatus;
}

VOID
CGPScratchManager::AC3RemoveOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages)
{
    // stop the GP from pumping data... TODO
    /*
    AC3_SET_BUFFER rSetBuffer;

    rSetBuffer.data1.uVal = 0;
    rSetBuffer.data1.fields.oper = NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_DISABLE;
    rSetBuffer.data1.fields.size = uNumOfPages * PAGE_SIZE;
    rSetBuffer.offset = m_uAC3BufferOffset;

    // write to the output Q
    CScratchQ *pQ = GetOutputQ();
    pQ->Start();
    pQ->Write(NV_OGP_SET_AC3_OUTPUT_BUFFER, rSetBuffer.data1.uVal, rSetBuffer.offset);
    pQ->Stop();
    */

    CScratchDma *pDma = GetScratchDma();
    pDma->RemovePage(pMem, uNumOfPages);
}

RM_STATUS
CGPScratchManager::AC3SetOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages)
{
    // AC3_SET_BUFFER rSetBuffer;

    CScratchDma *pDma = GetScratchDma();

    // we need to add these pages to the GP scratch
    RM_STATUS rmStatus = pDma->AddPage(pMem, uNumOfPages, &m_uAC3BufferOffset);
    if (rmStatus == RM_OK)
    {
        // write a method to the DSP telling him the offset of the AC3 output buffer - TODO!
        /*
        rSetBuffer.data1.uVal = 0;
        rSetBuffer.data1.fields.oper = NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_ENABLE;
        rSetBuffer.data1.fields.size = uNumOfPages * PAGE_SIZE;
        rSetBuffer.offset = m_uAC3BufferOffset;

        // write to the output Q
        CScratchQ *pQ = GetOutputQ();
        pQ->Start();
        if (FALSE == pQ->Write(NV_OGP_SET_AC3_OUTPUT_BUFFER, rSetBuffer.data1.uVal, rSetBuffer.offset))
            rmStatus = RM_ERROR;
        pQ->Stop();
        */
    }

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CGPScratchManager.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CGPScratchManager.h                                               *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CGPSCRATCHMANAGER_
#define _CGPSCRATCHMANAGER_

typedef struct
{
    union
    {
        struct
        {
            U032 oper : 1;
            U032 res  : 15;
            U032 size : 16;
        } fields;

        U032 uVal;
    } data1;

    U032 offset;

} AC3_SET_BUFFER;

class CScratchManager;

class CGPScratchManager : public CScratchManager
{
public:
    CGPScratchManager(CHalBase *pHalBase);
    ~CGPScratchManager();
    
    U032    AC3GetBufferOffset() { return m_uAC3BufferOffset; }

public:
    RM_STATUS   Initialize(VOID_PTR pLoader, U032 uLoaderSize);
    RM_STATUS   AC3SetOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages);
    VOID        AC3RemoveOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages);
    
private:
    CHalBase    *m_pHal;
    U032        m_uAC3BufferOffset;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CGpMethod.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CGpMethod.h                                                       *
*     SW functions for the GP                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CGPMETHODH_
#define _CGPMETHODH_

class CGPScratchManager;
class CGPDspProgram;
class CHalBase;
class CHalGlobalProc;
class CCommandQ;
class CContextDma;
class CMixerBuffer;
class AUDIOFX;


class CGPMethod
{
public:
    CGPMethod(CHalGlobalProc *pProc, CGPScratchManager *pMgr, CGPDspProgram *pDsp, CHalBase *pHal);
    ~CGPMethod();

public:
    RM_STATUS   Initialize();
    VOID        Execute();
    VOID        *GetCommandQAddress();

private:
    CGPScratchManager   *m_pScratchManager;
    CGPDspProgram       *m_pDspProgram;
    CHalBase            *m_pHal;
    CHalGlobalProc      *m_pGlobalProc;
    CCommandQ           *m_pCommandQ;
    CMixerBuffer        *m_pMixerBuffer;
    AUDIOFX             *m_pAudioFx;
    
    U032    m_uActiveEffect;
    
    enum EFFECT_STATE
    {
        FREE = 0,
        ALLOCATED,
    };

    struct
    {
        EFFECT_STATE eState;
        CContextDma *pParamDma;
        CContextDma *pDspCodeDma;
    } m_EffectInfo[MAX_EFFECTS];
    
    struct
    {
        U032 uCount;
        U032 uEffects[MAX_EFFECTS];
    } m_ExecutionList;

    RM_STATUS GetMixBuffer(U032 uArg, U032 *pId);
    VOID UpdateExecutionList(U032 uEffectID, BOOL bOption);
    VOID ConfigureFifo(U032 uMethod, U032 uData);

    // software methods
    RM_STATUS SetCurrentEffect(U032 uData);
    RM_STATUS SetContextDmaNotifier(U032 uData);
    RM_STATUS SetContextDmaParameter(U032 uData);
    RM_STATUS SetContextDmaDspCode(U032 uData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalExtendedProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************GP class for the HAL******************************\
*                                                                           *
* Module: CHalExtendedProc.cpp                                                *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <nv32.h>
#include <aos.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalExtendedProc.h"
#include "CHalGlobalProc.h"
#include "CScratchManager.h"
#include "CEPScratchManager.h"
#include "CDspProgram.h"
#include "CEPDspProgram.h"
#include "CEPMethod.h"

CHalExtendedProc::CHalExtendedProc(CHalBase *pHal, CHalGlobalProc *pGlProc) : CObjBase(pHal)
{
    // keep the internal count ahead of the external count by this much
    m_CommandQ.Size = 4096;
    m_pDspProgram = NULL;
    m_pScratchManager = NULL;
    m_pGlobalProc = pGlProc;
    m_pMethod = NULL;
}

RM_STATUS
CHalExtendedProc::Allocate(VOID *pParam)
{
	APU_EP_CREATE *pArg = (APU_EP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_ERROR;
    
    do
    {
        m_pDspProgram = new CEPDspProgram;
        m_pScratchManager = new CEPScratchManager(GetDevice());
        m_pMethod = new CEPMethod(GetDevice(), this);

        if (!m_pDspProgram || !m_pScratchManager || !m_pMethod)
            break;

        if (pArg->uUseForAC3)
        {
            rmStatus = m_pScratchManager->Initialize(m_pDspProgram, m_pGlobalProc);
            pArg->uAC3GpOutputOffset = m_pGlobalProc->AC3GetBufferOffset();
        }
        else
        {
            // tbd 
            rmStatus = RM_ERROR;
        }

        if (rmStatus != RM_OK)
            break;

        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

        InitializeHardware();

    } while (FALSE);

	return rmStatus;
}


RM_STATUS
CHalExtendedProc::Free(VOID *pParam)
{
    if (m_pMethod)
        delete m_pMethod;

    if (m_pDspProgram)
        delete m_pDspProgram;

    if (m_pScratchManager)
        delete m_pScratchManager;

    FreeMemory();

    m_pMethod = NULL;
    m_pDspProgram = NULL;
    m_pScratchManager = NULL;

    return RM_OK;
}

RM_STATUS
CHalExtendedProc::GetCaps(APU_EP_CREATE *pArg)
{
    // have no idea what regs to check against

    return RM_OK;
}

VOID
CHalExtendedProc::ExecuteMethod(U032 uMethod, U032 uParam)
{
    if (m_pMethod)
        m_pMethod->Execute(uMethod, uParam);
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalExtendedProc::ExecuteMethod - not method object!\n");
    }
}

RM_STATUS
CHalExtendedProc::AllocateMemory(APU_EP_CREATE *pArg)
{
    // vik - todo
    m_SgeOut.Size = pArg->uSGEOutCount * NV_PSGE_SIZE;

	RM_STATUS rmStatus =  aosAllocateMem(m_SgeOut.Size,
						                ALIGN_16K,
						                &m_SgeOut.pLinAddr,
						                &m_SgeOut.pPhysAddr);

    if (rmStatus == RM_OK)
    {
        // allocate memory for the command Q
        rmStatus =  aosAllocateMem(m_CommandQ.Size,
						        ALIGN_16K,
						        &m_CommandQ.pLinAddr,
						        &m_CommandQ.pPhysAddr);
    }

    return rmStatus;
}

VOID
CHalExtendedProc::FreeMemory()
{
	aosFreeMem(m_SgeOut.pLinAddr);
	aosFreeMem(m_CommandQ.pLinAddr);
}

VOID
CHalExtendedProc::InitializeHardware()
{
    // clear any pending interrupts! - todo cleanup
    RegWrite(NV_PAPU_EPISTS, (U032)0xFFFFFFFF);
    
    // output buffer PRDs
    RegWrite(NV_PAPU_EPFADDR, (U032)m_SgeOut.pPhysAddr);

    // PRDs for the FIFO
    RegWrite(NV_PAPU_EPCADDR, (U032)m_CommandQ.pPhysAddr);

    // update the max fifo PRDs req
    RegWrite(NV_PAPU_EPFMAXSGE, (U016)(m_SgeOut.Size / NV_PSGE_SIZE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalBase.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALBASEH_
#define _CHALBASEH_

class CHalBase
{
public:
    CHalBase::CHalBase(U008 uRevID, HWINFO_COMMON_FIELDS *pDev, U032 uSafeReadOffset);
    virtual CHalBase::~CHalBase();

	virtual RM_STATUS Allocate() = 0;
	virtual RM_STATUS Free() = 0;

    virtual RM_STATUS AddClient(VOID *pParam, U008 *pClientRef) = 0;
    virtual RM_STATUS DeleteClient(U008 uClientRef) = 0;

    // context dma
    virtual RM_STATUS AllocateContextDma(VOID *pParam) = 0;
    virtual RM_STATUS FreeContextDma(VOID *pParam) = 0;
    
    // object (processor) allocation
    virtual RM_STATUS AllocateObject(U032 uObjectType, VOID *pParam) = 0;
    virtual RM_STATUS FreeObject(U032 uObjectType, VOID *pParam) = 0;

	// the ISR function called at interrupt time
	virtual RM_STATUS InterruptService() = 0;


	virtual VOID RegWrite(U032 uOffset, U032 uValue)
    {
        *(U032*)(m_uBase + uOffset) = uValue;
        // read back a safe location, to make sure the APU FE FIFO is flushed
        U032 uTemp = *(U032*)(m_uBase + m_uSafeReadOffset);
    }

    virtual VOID RegRead(U032 uOffset, U032 *pValue) { *pValue = *(U032*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, U016 *pValue) { *pValue = *(U016*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, U008 *pValue) { *pValue = *(U008*)(m_uBase + uOffset); }

	virtual VOID RegRead(U032 uOffset, volatile U032 *pValue) { *pValue = *(U032*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, volatile U016 *pValue) { *pValue = *(U016*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, volatile U008 *pValue) { *pValue = *(U008*)(m_uBase + uOffset); }
    
    virtual VOID MemWrite(U032 uAddr, U008 uData)    { 	*((U008 *)uAddr) = uData;   }
    virtual VOID MemWrite(U032 uAddr, U016 uData)    { 	*((U016 *)uAddr) = uData;   }
    virtual VOID MemWrite(U032 uAddr, U032 uData)    { 	*((U032 *)uAddr) = uData;   }

	U008                    GetRevID()	{ return m_uRevID; }
	HWINFO_COMMON_FIELDS *  GetpDev()   { return m_pDev; }
    U032                    GetDevBase() { return m_uBase; }

protected:
    VOID DumpChipToFile();

private:
    U008 m_uRevID;
	U032 m_uBase;
    U032 m_uSafeReadOffset;
	HWINFO_COMMON_FIELDS *m_pDev;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalBase.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include <aos.h>
#include "CHalBase.h"

CHalBase::CHalBase(U008 uRevID, HWINFO_COMMON_FIELDS *pDev, U032 uSafeReadOffset) 
{ 
	m_uRevID = uRevID; 
	m_pDev = pDev;
	m_uBase = m_pDev->pDeviceBase;
    m_uSafeReadOffset = uSafeReadOffset;

#if defined VIKDBG
    // allocate some memory that will be the device PCI space
    if (RM_OK != aosAllocateMem(1?NV_PAPU, ALIGN_DONT_CARE, (VOID **)&m_uBase, NULL) )
    {
        // well.. too bad .. i tried
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalBase::CHalBase - no memory for the chip");
        return;
    }

    // zero the memory
    for (U032 uCnt = 0; uCnt < (1?NV_PAPU)/4; uCnt++)
        RegWrite(uCnt*4, (U032)0);
#endif
}

CHalBase::~CHalBase() 
{
    m_uRevID = 0; 

#if defined VIKDBG
    DumpChipToFile();
    aosFreeMem((VOID *)m_uBase);
#endif
}

VOID
CHalBase::DumpChipToFile()
{
    VOID *pHandle = aosCreateDiskFile();
    if (pHandle)
    {
        aosWriteDiskFile(pHandle, (VOID *)m_uBase, 1?NV_PAPU);
        aosCloseDiskFile(pHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalExtendedProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalExtendedProc.h                                                   *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALEXTENDEDPROCH_
#define _CHALEXTENDEDPROCH_

class CHalBase;
class CObjBase;
class CEPScratchManager;
class CEPDspProgram;
class CScratchManager;
class CHalGlobalProc;
class CEPMethod;

class CHalExtendedProc : public CObjBase
{
public:
    CHalExtendedProc(CHalBase *pHal, CHalGlobalProc *pGlProc);
	~CHalExtendedProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);
    
    VOID ExecuteMethod(U032 uMethod, U032 uParam);
    
    VOID *GetSgeOutLinAddr() { return m_SgeOut.pLinAddr; }
    
    CScratchManager *GetScratchManager() { return (CScratchManager *)m_pScratchManager; }
    CEPScratchManager *GetEPScratchManager() { return m_pScratchManager; }

private:
    RM_STATUS AllocateMemory(APU_EP_CREATE *);
    VOID FreeMemory();

    RM_STATUS GetCaps(APU_EP_CREATE *);
    VOID InitializeHardware();

    MEM_DESC    m_SgeOut;
    MEM_DESC    m_CommandQ;

    CEPScratchManager   *m_pScratchManager;
    CEPDspProgram       *m_pDspProgram;
    CHalGlobalProc      *m_pGlobalProc;
    CEPMethod           *m_pMethod;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalGlobalProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalGlobalProc.h                                                   *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALGLOBALPROCH_
#define _CHALGLOBALPROCH_

class CHalBase;
class CObjBase;
class CGPScratchManager;
class CGPDspProgram;
class CGPMethod;
class CScratchManager;

class CHalGlobalProc : public CObjBase
{
public:
    CHalGlobalProc(CHalBase *pHal);
	~CHalGlobalProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);

    VOID    *GetSgeOutLinAddr() { return m_SgeOut.pLinAddr; }
    VOID    WriteCommand(U032, DSP_CONTROL *, WORD4 * = NULL, WORD5 * = NULL, WORD6 * = NULL);
    
    VOID    SetNotifierMemory(VOID *pLinAddr, U032 uSize)   { m_pNotifier = (U008 *)pLinAddr; m_uNotifierSize = uSize; }
    VOID    WriteNotifier(U032 uMethod, U032 uData, U008 uStatus);
    
    VOID    ExecuteMethod();
    
    // debug only
    CScratchManager *GetScratchManager() { return (CScratchManager *)m_pScratchManager; }
    
    RM_STATUS   AC3SetOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages);
    VOID        AC3RemoveOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages);
    
    U032        AC3GetBufferOffset();

private:
    MEM_DESC    m_SgeOut;

    // notifier memory
    U008        *m_pNotifier;
    U032        m_uNotifierSize;

    // objects
    CGPScratchManager   *m_pScratchManager;
    CGPDspProgram       *m_pDspProgram;
    CGPMethod           *m_pMethod;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalGlobalProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************GP class for the HAL******************************\
*                                                                           *
* Module: CHalGlobalProc.cpp                                                *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <nv_ugp.h>
#include <aos.h>
#include <nv32.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalGlobalProc.h"
#include "CScratchManager.h"
#include "CGPScratchManager.h"
#include "CDspProgram.h"
#include "CGPDspProgram.h"
#include "CGPMethod.h"

CHalGlobalProc::CHalGlobalProc(CHalBase *pHal) : CObjBase(pHal)
{
    m_pNotifier = NULL;
    m_uNotifierSize = 0;
    m_pScratchManager = NULL;
    m_pDspProgram = NULL;
    m_pMethod = NULL;
}

RM_STATUS
CHalGlobalProc::Allocate(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_OK;
    
    do
    {
        // allocate all the objects required for GP

        m_pScratchManager = new CGPScratchManager(GetDevice());
        m_pDspProgram = new CGPDspProgram();
        m_pMethod = new CGPMethod(this, m_pScratchManager, m_pDspProgram, GetDevice());

        if (!m_pDspProgram || !m_pDspProgram || !m_pMethod)
            break;

        m_pDspProgram->Initialize();

        rmStatus = m_pScratchManager->Initialize( m_pDspProgram->GetLoader(),
                                                  m_pDspProgram->GetLoaderSize() );
        if (rmStatus != RM_OK)
            break;

        rmStatus = m_pMethod->Initialize();
        if (rmStatus != RM_OK)
            break;

        // get the device capabilities
        if (pArg->uSGEOutCount)
        {
	        VOLU32 vTemp = pArg->uSGEOutCount - 1;
	        RegWrite(NV_PAPU_FEMAXGPSGE, LOW16(vTemp));
	        RegRead(NV_PAPU_FEMAXGPSGE, &vTemp);
	        pArg->uSGEOutCount = vTemp + 1;
        }

        m_SgeOut.Size = pArg->uSGEOutCount * NV_PSGE_SIZE;

	    rmStatus =  aosAllocateMem(m_SgeOut.Size,
						                    ALIGN_16K,
						                    &m_SgeOut.pLinAddr,
						                    &m_SgeOut.pPhysAddr);
        if (rmStatus == RM_OK)
        {
            // clear any pending interrupts! - todo cleanup
            RegWrite(NV_PAPU_GPISTS, (U032)0xFFFFFFFF);
            // output buffer PRDs
            RegWrite(NV_PAPU_GPFADDR, (U032)m_SgeOut.pPhysAddr);
            // update the max fifo PRDs req
            RegWrite(NV_PAPU_GPFMAXSGE, (U016)(m_SgeOut.Size / NV_PSGE_SIZE) );

            // return the linear address of the command Q to the client
            pArg->pGPCommandQ = (VOID_PTR)m_pMethod->GetCommandQAddress();
        }

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalGlobalProc::Free(VOID *pParam)
{
    if (m_pMethod)
        delete m_pMethod;

    if (m_pDspProgram)
        delete m_pDspProgram;

    if (m_pScratchManager)
        delete m_pScratchManager;

	aosFreeMem(m_SgeOut.pLinAddr);
    m_SgeOut.pLinAddr = NULL;

    m_pMethod = NULL;
    m_pDspProgram = NULL;
    m_pScratchManager = NULL;

    return RM_OK;
}



VOID
CHalGlobalProc::WriteCommand(U032 uOffset, DSP_CONTROL *pDspWord, WORD4 *pW4, WORD5 *pW5, WORD6 *pW6)
{
    RegWrite(NV_PAPU_GPXMEM(uOffset++), pDspWord->w0.uValue);
    RegWrite(NV_PAPU_GPXMEM(uOffset++), pDspWord->w1.uValue);
    RegWrite(NV_PAPU_GPXMEM(uOffset++), pDspWord->w2.uValue);
    RegWrite(NV_PAPU_GPXMEM(uOffset++), pDspWord->w3.uValue);
    
    if (pW4)
        RegWrite(NV_PAPU_GPXMEM(uOffset++), pW4->uValue);

    if (pW5)
        RegWrite(NV_PAPU_GPXMEM(uOffset++), pW5->uValue);

    if (pW6)
        RegWrite(NV_PAPU_GPXMEM(uOffset++), pW6->uValue);
}

VOID
CHalGlobalProc::WriteNotifier(U032 uMethod, U032 uData, U008 uStatus)
{
    if (!m_pNotifier)
    {
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalGlobalProc::WriteNotifier - Memory not set\n");
        return;
    }
    
    // calculate the notifier memory address for the method
    U032 uOffset = sizeof(NVAUDGPNOTIFICATION) * uMethod;

    // check for boundary
    if (uOffset < m_uNotifierSize)
    {
        // great.. now write the notifier
        PNVAUDGPNOTIFICATION pNotify = (PNVAUDGPNOTIFICATION)(m_pNotifier + uOffset);
    
        pNotify->GSCNT = 0;     // todo vik
        pNotify->Method = uMethod;
        pNotify->Data = uData;
        pNotify->ReturnCode = uStatus;
        pNotify->Status = NV_AUDGP_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    else
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalGlobalProc::WriteNotifier - boundary check fails!\n");
}

VOID
CHalGlobalProc::ExecuteMethod() 
{ 
    if (m_pMethod)
        m_pMethod->Execute();
    else
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalGlobalProc::ExecuteMethod - no method class!\n");
}

RM_STATUS 
CHalGlobalProc::AC3SetOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages)
{
    RM_STATUS rmStatus = RM_ERROR;

    if (m_pScratchManager)
        rmStatus = m_pScratchManager->AC3SetOutputBuffer(pMem, uNumOfPages);

    return rmStatus;
}

VOID 
CHalGlobalProc::AC3RemoveOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages)
{
    if (m_pScratchManager)
       m_pScratchManager->AC3RemoveOutputBuffer(pMem, uNumOfPages);
}

U032
CHalGlobalProc::AC3GetBufferOffset()
{
    if (m_pScratchManager)
       return m_pScratchManager->AC3GetBufferOffset();

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalMCP1.cpp ===
// cHalMCPI.cpp

extern "C"
{
#include <nv32.h>
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include <aos.h>
// ahal should not need to be included...
// todo - have to work on the client info stuff
#include "AHal.h"

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalExtendedProc.h"
#include "CHalGlobalProc.h"
#include "CHalMCP1.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CEPMethod.h"
#include "CScratchDma.h"
#include "CScratchManager.h"
#include "CGpMethod.h"

// constructor
CHalMCP1::CHalMCP1(U008 uRevID, HWINFO_COMMON_FIELDS *pDev) : CHalBase(uRevID, pDev, NV_PAPU_FESCRATCH) 
{ 
    m_pVoiceProc = NULL;
    m_pCDma = NULL;
    m_pGlobalProc = NULL;
    m_pExtendedProc = NULL;
    m_MagicWrite.pLinAddr = NULL;
    m_uMagicWriteValue = 1;

    // init the client callback info
    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
        m_ClientInfo[uCnt].pFn = NULL;
}

CHalMCP1::~CHalMCP1()
{ 
    if (m_pVoiceProc)   
        delete m_pVoiceProc;
    
    if (m_pGlobalProc)
        delete m_pGlobalProc;

    if (m_pExtendedProc)
        delete m_pExtendedProc;

    if (m_pCDma)
    {
        // clean the list - todo
    }

    m_pVoiceProc = NULL;
    m_pCDma = NULL;
    m_pGlobalProc = NULL;
    m_pExtendedProc = NULL;
}

RM_STATUS 
CHalMCP1::InterruptService()
{
    RM_STATUS rmStatus = RM_OK;
    
    R_INTR rInterruptStatus;
    U032 uServiced = 1;
    
    INTR_MASK ClientMask;
    ClientMask.uValue = 0;
    
    // read from hardware what interrupt is pending
    RegRead(NV_PAPU_ISTS, &rInterruptStatus.uValue);
    
    // take action depending on what is triggered
    if (NV_PAPU_ISTS_GINTSTS_INTR == rInterruptStatus.General)
    {
        // prepare the magic write stuff
        aosZeroMemory(m_MagicWrite.pLinAddr, m_MagicWrite.Size);

        SetPrivLock(E_STATE::LOCK);

        // fixed in rev B - but for now.. read and store  NV_PAPU_FEMEMADDR
        U032 uSavedMemAddr;
        RegRead(NV_PAPU_FEMEMADDR, &uSavedMemAddr);

        RegWrite(NV_PAPU_FEMEMADDR, (U032)m_MagicWrite.pPhysAddr);
        RegWrite(NV_PAPU_FEMEMDATA, m_uMagicWriteValue);

        // find out if it's a valid interrupt
        // check for individial interrupt bits
        // can multiple bits be set?? vik
        
        if (NV_PAPU_ISTS_DWINTSTS_INTR == rInterruptStatus.DeltaWarning)
        {
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::InterruptService - Delta Warning interrupt triggered!\n");
            rInterruptStatus.DeltaWarning = NV_PAPU_ISTS_DWINTSTS_CLR;
            ClientMask.apu.DeltaWarning = 1;
        }

        if (NV_PAPU_ISTS_RTWSTS_INTR == rInterruptStatus.RetriggerEvent)
        {
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::InterruptService - Retriggerd Delta Warning interrupt (??)\n");
            // read only value.. need not be cleared
            // rInterruptStatus.RetriggerEvent = NV_PAPU_ISTS_RTWSTS_CLR; 
        }

        if (NV_PAPU_ISTS_DPINTSTS_INTR == rInterruptStatus.DeltaPanic)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::InterruptService - Delta Panic (internal and external GSCNT is same!\n");
            rInterruptStatus.DeltaPanic = NV_PAPU_ISTS_DPINTSTS_CLR;
            ClientMask.apu.DeltaPanic = 1;
        }

        if (NV_PAPU_ISTS_FETINTSTS_INTR == rInterruptStatus.FETrap)
        {
            rInterruptStatus.FETrap = NV_PAPU_ISTS_FETINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_FENINTSTS_INTR == rInterruptStatus.FENotify)
        {
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::InterruptService - Notifier was written\n");
            rInterruptStatus.FENotify = NV_PAPU_ISTS_FENINTSTS_CLR;
            ClientMask.apu.FENotify = 1;
        }

        if (NV_PAPU_ISTS_FEVINTSTS_INTR == rInterruptStatus.FEVoice)
        {
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::InterruptService - End of voice received\n");
            rInterruptStatus.FEVoice = NV_PAPU_ISTS_FEVINTSTS_CLR;
            ClientMask.apu.FEVoice = 1;
        }

        if (NV_PAPU_ISTS_FEOINTSTS_INTR == rInterruptStatus.FEMethodOverFlow)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::InterruptService - User method fifo overflow.. some methods/data will be discarded\n");
            rInterruptStatus.FEMethodOverFlow = NV_PAPU_ISTS_FEOINTSTS_CLR;
            ClientMask.apu.FEMethodOverFlow = 1;
        }

        if (NV_PAPU_ISTS_GPMINTSTS_INTR == rInterruptStatus.GPMailbox)
        {
            rInterruptStatus.GPMailbox = NV_PAPU_ISTS_GPMINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_GPNINTSTS_INTR == rInterruptStatus.GPNotify)
        {
            rInterruptStatus.GPNotify = NV_PAPU_ISTS_GPNINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_EPMINTSTS_INTR == rInterruptStatus.EPMailbox)
        {
            rInterruptStatus.EPMailbox = NV_PAPU_ISTS_EPMINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_EPNINTSTS_INTR == rInterruptStatus.EPNotify)
        {
            rInterruptStatus.EPNotify = NV_PAPU_ISTS_EPNINTSTS_CLR;
        }

        RegWrite(NV_PAPU_ISTS, rInterruptStatus.uValue);
        
        // restore the previosuly read NV_PAPU_FEMEMDATA - fixed in rev B
        RegWrite(NV_PAPU_FEMEMADDR, uSavedMemAddr);

        // unlock the FE
        SetPrivLock(E_STATE::UNLOCK);


        // complete the magic writes (??)
        U032 uCnt = 0;
        while (m_uMagicWriteValue != (*((U032 *)m_MagicWrite.pLinAddr)) )
        {
            if (uCnt++ > 1000)
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "CHalMCP1::InterruptService - magic write not completing\n");
#if defined WDM
                KdPrint(("magic write value = %d\n", m_uMagicWriteValue));
#endif
                //aosDbgBreakPoint();
                break;
            }
        }
        
        m_uMagicWriteValue ++;

        // it was our interrupt then complete the processing
        if (NV_PAPU_ISTS_GINTSTS_INTR == rInterruptStatus.General)
        {
            if (rInterruptStatus.FETrap == NV_PAPU_ISTS_FETINTSTS_CLR)
                OnIntrFETrap();
            
            if (rInterruptStatus.GPMailbox == NV_PAPU_ISTS_GPMINTSTS_CLR)
            {
                // When the client writes to the GP command Q, the GP gets an interrupt
                // on getting it, the GP should write to the mailbox register to trip this
                // interrupt - GP sw methods are handled here
                
                if (m_pGlobalProc)
                    m_pGlobalProc->ExecuteMethod();
                else
                {
                    aosDbgPrintString(DEBUGLEVEL_ERRORS, "CHalMCP1::InterruptService - m_pGlobalProc not allocated\n");
                }
            }

            // callback the clients
            CallbackClients(ClientMask.uValue);
        }

        // to make sure that the ISTS write gets thu' bfore we return from the
        // ISR - this will eliminate spurious interrupts
        RegRead(NV_PAPU_ISTS, &rInterruptStatus.uValue);
    
    }
    else
    {
        // not our interrupt
        rmStatus = RM_ERROR;
    }


    return rmStatus;
}

VOID
CHalMCP1::UpdateUserMethodQ(U032 uMethod, U032 uParam)
{
#if DEBUG
    // some error checking
    R_FE_CONTROL rFeControl;
    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);
    if (rFeControl.Mode == NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: FE free running - cannot update user method Q\n");
        aosDbgBreakPoint();
    }
#endif

    R_METHODQ_CONTROL rQControl;
    RegRead(NV_PAPU_FEUFIFOCTL, &rQControl.uValue);
    if (rQControl.count == MCP1_METHODQ_SIZE)
    {
        // this should not happen, since the driver assumes there are only 31 entries in the Q
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: FE method Q - max reached!!!\n");
        return;   
    }

    // update the head pointer - is it "0" based?
    rQControl.head = (rQControl.head == (MCP1_METHODQ_SIZE-1))?(0):(rQControl.head++);

    // stuff the method and the param
    RegWrite(NV_PAPU_FEUFIFOMETH(rQControl.head), uMethod);
    RegWrite(NV_PAPU_FEUFIFOPARAM(rQControl.head), uParam);

    rQControl.count++;
    RegWrite(NV_PAPU_FEUFIFOCTL, rQControl.uValue);
}

// returns non-zero if it's an EP SW method.. FALSE for AP
BOOL
CHalMCP1::GetUserMethodInfo(U032 *pMethod, U032 *pParam)
{
    // to do - change this when the .ref is updated
    RegRead(NV_PAPU_FEDECPARAM, pParam);
    RegRead(NV_PAPU_FEDECMETH, pMethod);

    BOOL bEPMethod = (*pMethod) & PIO_EP_OFFSET;

    // return 16 LSB after turning off bit 16
    *pMethod = ((*pMethod) & (~PIO_EP_OFFSET));
    *pMethod = LOW16(*pMethod);

    return bEPMethod;
}

VOID
CHalMCP1::OnIntrFETrap()
{
    R_FE_CONTROL rFeControl;
    
    // first find out the reason for the trap
    U032 uParam;
    U032 uMethod;
    BOOL bEpMethod = GetUserMethodInfo(&uMethod, &uParam);
    
    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);
    rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
    
    switch(rFeControl.TrapReason)
    {
    case NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN\n");
    case NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED\n");

        if (bEpMethod)
        {
            if (m_pExtendedProc)
                m_pExtendedProc->ExecuteMethod(uMethod, uParam);
            else
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - extended proc not allocated\n");
            }
        }
        else
        {
            if (m_pVoiceProc)
                m_pVoiceProc->ExecuteMethod(uMethod, uParam);
            else
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - voice proc not allocated\n");
            }
        }

        break;
        
    case NV_PAPU_FECTL_FETRAPREASON_REQUESTED:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_REQUESTED\n");
        GetDebugInfo();
        break;
        
    case NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID\n");
        GetDebugInfo();
        break;
    }
        
    // turn the FE to free running
    SetFrontEnd(E_STATE::FREE_RUN);
}

VOID
CHalMCP1::GetDebugInfo()
{
#if defined DEBUG
    // absolute max voices
    U032 uAbsMaxVoice;
    RegRead(NV_PAPU_FEAMAXV, &uAbsMaxVoice);

    // max voices used
    U032 uMaxVoice;
    RegRead(NV_PAPU_FEAMAXV, &uMaxVoice);

    // max 3D voices
    U032 uMax3DVoice;
    RegRead(NV_PAPU_FEMAXTV, &uMax3DVoice);

    // current voice
    U032 uCurrVoice;
    RegRead(NV_PAPU_FECV, &uCurrVoice);

    // current voice's data type and container size
    U032 uCurrVoiceData;
    RegRead(NV_PAPU_FECVDT, &uCurrVoiceData);

    // current method
    U032 uCurrMethod;
    RegRead(NV_PAPU_FEDECMETH, &uCurrMethod);

    // current data
    U032 uCurrData;
    RegRead(NV_PAPU_FEDECPARAM, &uCurrData);

    aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: Check local variables for debug info!\n");
    aosDbgBreakPoint();
#endif
}

VOID 
CHalMCP1::CallbackClients(U032 uIntrMask)
{
    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
    {
        if ( (m_ClientInfo[uCnt].pFn) &&
            (m_ClientInfo[uCnt].Mask.uValue & uIntrMask) )
        {
            (*(m_ClientInfo[uCnt].pFn))((U032)m_ClientInfo[uCnt].pContext, uIntrMask, 0);
        }
    }
}

RM_STATUS
CHalMCP1::AddClient(VOID *pParam, U008 *pRef)
{
    PMCP1_CLIENT_INFO pClientInfo = (PMCP1_CLIENT_INFO)pParam;

    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
    {
        if (!m_ClientInfo[uCnt].pFn)
        {
            // store it here
            m_ClientInfo[uCnt].pFn = pClientInfo->pFn;
            m_ClientInfo[uCnt].Mask.uValue = pClientInfo->Mask.uValue;
            m_ClientInfo[uCnt].pContext = pClientInfo->pContext;
            *pRef = (U008)uCnt;

            return RM_OK;
        }
    }
    
    return RM_ERROR;
}

RM_STATUS
CHalMCP1::DeleteClient(U008 uRef)
{
    m_ClientInfo[uRef].pFn = NULL;
    return RM_OK;
}


RM_STATUS
CHalMCP1::Allocate()
{
    RM_STATUS rmStatus = RM_OK;
    
    // right now allocate just a page for magic write.. but later change it 
    // to allocate only 32 bits
    m_MagicWrite.Size = PAGE_SIZE;
    rmStatus = aosAllocateMem(m_MagicWrite.Size, 
                            ALIGN_4K, 
                            &(m_MagicWrite.pLinAddr),
                            &(m_MagicWrite.pPhysAddr));

    if (rmStatus == RM_OK)
    {
        // clear all the interrupts
        RegWrite(NV_PAPU_ISTS, (U032)0x00000FFF);

        m_rInterruptMask.uValue = 0;
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
        // m_rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_ENABLED;
        // m_rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_ENABLED;
        m_rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_DISABLED;
        m_rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_DISABLED;
        m_rInterruptMask.FETrap = NV_PAPU_IEN_FETINTEN_ENABLED;
        m_rInterruptMask.FENotify = NV_PAPU_IEN_FENINTEN_DISABLED;
        m_rInterruptMask.FEVoice = NV_PAPU_IEN_FEVINTEN_DISABLED;
        m_rInterruptMask.FEMethodOverFlow = NV_PAPU_IEN_FEOINTEN_ENABLED;
        m_rInterruptMask.GPMailbox = NV_PAPU_IEN_GPMINTEN_ENABLED;
        m_rInterruptMask.GPNotify = NV_PAPU_IEN_GPNINTEN_DISABLED;
        m_rInterruptMask.EPMailbox = NV_PAPU_IEN_EPMINTEN_ENABLED;
        m_rInterruptMask.EPNotify = NV_PAPU_IEN_EPNINTEN_DISABLED;

        R_FE_CONTROL rFeControl;
        rFeControl.uValue = 0;
	    rFeControl.TrapOnNotifier = NV_PAPU_FECTL_FENINT_ENABLED;
        rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
        rFeControl.EnableLock = NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED;

        R_SE_CONTROL rSeControl;
        rSeControl.uValue = 0;
        /*
	    rSeControl.DeltaPanic = NV_PAPU_SECTL_DPINT_DISABLED;
	    rSeControl.Retriggered = NV_PAPU_SECTL_RTWARN_DISABLED;
	    rSeControl.DeltaWarn = NV_PAPU_SECTL_DWINT_DISABLED;
        */
	    rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

        RegWrite(NV_PAPU_IEN, m_rInterruptMask.uValue);
        RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
        RegWrite(NV_PAPU_SECTL, rSeControl.uValue);
    
        // i want all legal traps to come to me...
        RegWrite(NV_PAPU_FETFORCE0, (U032)0);
        RegWrite(NV_PAPU_FETFORCE1, (U032)0);
        RegWrite(NV_PAPU_FETIGNORE0, (U032)0);

		//For now disable the traps on SetSSLSegmentLength

		U032 FeIgnore1 = 1 << (0 ? NV_PAPU_FETIGNORE1_SET_SSL_SEGMENT_LENGTH);

        RegWrite(NV_PAPU_FETIGNORE1, (U032)FeIgnore1);
    
        // stop the GP - todo

        // stop the EP - todo
    }

    return rmStatus;
}

RM_STATUS
CHalMCP1::Free()
{
    RM_STATUS rmStatus = RM_OK;
    
    // disable the interrupts
    SetInterrupts(INTERRUPT_STATE::DISABLE);

    // stop the FE
    SetFrontEnd(E_STATE::HALT);

    // free the memory
    if (m_MagicWrite.pLinAddr)
        aosFreeMem(m_MagicWrite.pLinAddr);

    return rmStatus;
}

RM_STATUS 
CHalMCP1::AllocateObject(U032 uObjectType, VOID *pParam)
{
	RM_STATUS	rmStatus = RM_ERROR;

    switch (uObjectType)
    {
    case AUDIO_OBJECT_AP:

        do
        {
	        APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;

            if (m_pVoiceProc)
            {
                // not support for multiple object allocations...
                break;
            }

            // allocate the sw method class
            m_pGlobalProc = new CHalGlobalProc(this);
            m_pVoiceProc = new CHalVoiceProc(m_pGlobalProc, this);

            if (m_pVoiceProc && m_pGlobalProc)
            {
                SetInterrupts(INTERRUPT_STATE::DISABLE);
                SetPrivLock(E_STATE::LOCK);

                // now allocate the objects
                rmStatus = m_pVoiceProc->Allocate(pParam);

                if (rmStatus == RM_OK)
                    rmStatus = m_pGlobalProc->Allocate(pParam);
                
                SetISO(&pArg->flags);
                
                if (rmStatus == RM_OK)
                {
                    //Stop the Setup engine we will explicitly set it later
                    SetSetupEngine(E_STATE::OFF);

                        SetSetupEngineGlobalCounts( pArg->uExternalGSCNT,
                                                    pArg->uInternalGSCNT,
                                                    pArg->uDeltaGSCNT);

                    SetFrontEnd(E_STATE::FREE_RUN);
                }
                
                SetPrivLock(E_STATE::UNLOCK);
                SetInterrupts(INTERRUPT_STATE::ENABLE);

                pArg->pioBase = GetDevBase() + DEVICE_BASE(NV_PAPU_NV1BA0);

                // debug only!
                if (rmStatus == RM_OK)
                    pArg->pGPScratchLin = (VOID_PTR)m_pGlobalProc->GetScratchManager()->GetScratchPage(0);
            }

        } while (FALSE);

        break;

    case AUDIO_OBJECT_EP:
        do
        {
            APU_EP_CREATE *pArg = (APU_EP_CREATE *) pParam;
            
            // we need to make sure here, that the EP is not allocate more than once
            if (!m_pExtendedProc)
            {
                if (pArg->uUseForAC3)
                {
                    // chekc if GP has been allocated..
                    if (!m_pGlobalProc)
                        break; 
                }

                m_pExtendedProc = new CHalExtendedProc(this, m_pGlobalProc);

                if (m_pExtendedProc)
                    rmStatus = m_pExtendedProc->Allocate(pParam);

                if (rmStatus == RM_OK)
                {
                    // set up the sample counts
                    SetSetupEngineExtendedCounts(pArg->uInternalGSCNT,
                                                pArg->uDeltaGSCNT,
                                                pArg->uStepSize);

                    pArg->pioBase = GetDevBase() + DEVICE_BASE(NV_PAPU_NV1BA0) + PIO_EP_OFFSET;

                    pArg->pEPScratchLin = (VOID_PTR)m_pExtendedProc->GetScratchManager()->GetScratchPage(0);
                }
            }

        } while (FALSE);

        break;

    default:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::AllocateObject - Illegal object\n");
        rmStatus = RM_ERR_ILLEGAL_OBJECT;
        break;
    }
    
    if (rmStatus != RM_OK)
        FreeObject(uObjectType, NULL);

    return rmStatus;

}

RM_STATUS 
CHalMCP1::FreeObject(U032 uObjectType, VOID *pParam)
{
    RM_STATUS rmStatus = RM_OK;

    switch(uObjectType)
    {
    case AUDIO_OBJECT_AP:
        if (m_pGlobalProc)
        {
            m_pGlobalProc->Free();
            delete m_pGlobalProc;
            m_pGlobalProc = NULL;
        }

        if (m_pVoiceProc)
        {
            m_pVoiceProc->Free(pParam);
            delete m_pVoiceProc;
            m_pVoiceProc = NULL;
        }
        break;

    case AUDIO_OBJECT_EP:
        if (m_pExtendedProc)
        {
            m_pExtendedProc->Free();
            delete m_pExtendedProc;
            m_pExtendedProc = NULL;
        }
        break;

    default:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::FreeObject - Illegal object\n");
        rmStatus = RM_ERR_ILLEGAL_OBJECT;
        break;
    }

    return rmStatus;
}


VOID 
CHalMCP1::SetInterrupts(INTERRUPT_STATE eIntrState)
{
    if (eIntrState == ENABLE)		// set the interrupts on
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_ENABLED;
    else							// turn them off
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
    
    RegWrite(NV_PAPU_IEN, m_rInterruptMask.uValue);
}

VOID
CHalMCP1::SetPrivLock(E_STATE eState)
{
    /*
    make sure interrupts are disabled during
    accesses to FEPRIVLOCK, otherwise base-level
    code could set FEPRIVLOCK, then get
    an interrupt, and your ISR could set FEPRIVLOCK,
    do its thing, then clear FEPRIVLOCK -- oops.
    */

    if (eState == LOCK)
    {
        // lock
        SetInterrupts(INTERRUPT_STATE::DISABLE);
        RegWrite(NV_PAPU_FEPRIVLOCK, NV_PAPU_FEPRIVLOCK_VALUE_LOCKED);
    }
    else if (eState == UNLOCK)
    {
        RegWrite(NV_PAPU_FEPRIVLOCK, NV_PAPU_FEPRIVLOCK_VALUE_UNLOCKED);
        SetInterrupts(INTERRUPT_STATE::ENABLE);
    }
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::SetPrivLock - Illegal option\n");
        aosDbgBreakPoint();
    }
    
}

VOID
CHalMCP1::SetISO(APU_AP_FLAGS *pFlags)
{
    R_FE_CONTROL rFeControl;
    R_SE_CONTROL rSeControl;

    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);
    RegRead(NV_PAPU_SECTL, &rSeControl.uValue);
    
    rFeControl.WriteISO = (pFlags->fields.FEISOWrite)?NV_PAPU_FECTL_FEMWTYP_ISO:NV_PAPU_FECTL_FEMWTYP_NON_ISO;
    rFeControl.ReadISO = (pFlags->fields.FEISORead)?NV_PAPU_FECTL_FEMRTYP_ISO:NV_PAPU_FECTL_FEMRTYP_NON_ISO;
    rFeControl.NotifyISO = (pFlags->fields.FEISONotify)?NV_PAPU_FECTL_FENTYP_ISO:NV_PAPU_FECTL_FENTYP_NON_ISO;
    rFeControl.PIOClass = (pFlags->fields.FEISOPIO)?NV_PAPU_FECTL_FEPIOCLASS_ISO:NV_PAPU_FECTL_FEPIOCLASS_NON_ISO;
    
    rSeControl.SampleReadISO = (pFlags->fields.SEISOSampleRead)?NV_PAPU_SECTL_SESRTYP_ISO:NV_PAPU_SECTL_SESRTYP_NON_ISO;
    rSeControl.WriteISO = (pFlags->fields.SEISOWrite)?NV_PAPU_SECTL_SEPWTYP_ISO:NV_PAPU_SECTL_SEPWTYP_NON_ISO;
    rSeControl.ReadISO = (pFlags->fields.SEISORead)?NV_PAPU_SECTL_SEPRTYP_ISO:NV_PAPU_SECTL_SEPRTYP_NON_ISO;

    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
    RegWrite(NV_PAPU_SECTL, rSeControl.uValue);
}

VOID 
CHalMCP1::SetFrontEnd(E_STATE eFeState)
{
    R_FE_CONTROL rFeControl;
    
    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);

    switch(eFeState)
    {
    case HALT:
        rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
        break;
    case FREE_RUN:
        rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING;
        break;
    }

    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
}


VOID
CHalMCP1::SetSetupEngine(E_STATE eState)
{
    R_SE_CONTROL rSeControl;

    RegRead(NV_PAPU_SECTL, &rSeControl.uValue);

    switch(eState)
    {
    case OFF:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;
        break;
    case AC_SYNC:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;
        break;
    case SW:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_SW;
        break;
    case FREE_RUN:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;
        break;
        /*
    case INT_PANIC:
        rSeControl.DeltaPanic = NV_PAPU_SECTL_DPINT_ENABLED;
        break;
    case INT_RETRIGGER:
        rSeControl.Retriggered = NV_PAPU_SECTL_RTWARN_ENABLED;
        break;
    case INT_WARN:
        rSeControl.DeltaWarn = NV_PAPU_SECTL_DWINT_ENABLED;
        break;
        */
    default:
        return;
    }

    RegWrite(NV_PAPU_SECTL, rSeControl.uValue);

}

VOID
CHalMCP1::SetSetupEngineGlobalCounts(U032 uExt, U032 uInt, U032 uDelta)
{
    U032 uWarn = ((uInt - uExt) - uDelta)/3;
    U032 uRetrigger = 0;        // not using it right now
    U032 uPanic = 0;            // for now.. panic if uExt catches up with uInt

    RegWrite(NV_PAPU_XGSCNT, uExt);
    RegWrite(NV_PAPU_IGSCNT, uInt);
    RegWrite(NV_PAPU_DGSCNT, uDelta);
    RegWrite(NV_PAPU_WGSCNT, uWarn);
    RegWrite(NV_PAPU_RGSCNT, uRetrigger);
    RegWrite(NV_PAPU_PGSCNT, uPanic);
    
    // make sure the SECTL is triggering panic and warn interrupts
    // and retrigger is off
    SetSetupEngine(E_STATE::INT_PANIC);
    SetSetupEngine(E_STATE::INT_WARN);
}

VOID
CHalMCP1::SetSetupEngineExtendedCounts(U032 uInt, U032 uDelta, U032 uStep)
{
    RegWrite(NV_PAPU_EGSCNT, uInt);
    RegWrite(NV_PAPU_DEGSCNT, uDelta);
    RegWrite(NV_PAPU_ECNTSTP, uStep);
}

RM_STATUS 
CHalMCP1::AllocateContextDma(VOID *pParam)
{
    APU_AP_ALLOC_CONTEXT_DMA *pIn = (APU_AP_ALLOC_CONTEXT_DMA *)pParam;
    RM_STATUS rmStatus = RM_ERROR;

    CContextDma *pDma = new CContextDma;

    if (pDma)
    {
        rmStatus = pDma->Initialize((VOID *)pIn->uBaseAddress,
                                    pIn->uMaxOffset,
                                    pIn->uType);
        if (rmStatus == RM_OK)
            pDma->Add((CLinkList **)&m_pCDma);
        else
        {
            delete pDma;
            pDma = NULL;
        }
    }
    
    pIn->uHandle = (U032)pDma;

    return rmStatus;
}

RM_STATUS 
CHalMCP1::FreeContextDma(VOID *pParam)
{
    APU_AP_FREE_CONTEXT_DMA *pIn = (APU_AP_FREE_CONTEXT_DMA *) pParam;

#if defined DEBUG

    // search the list for the context DMA
    if (!m_pCDma || FALSE == m_pCDma->Exists((CLinkList *)pIn->uHandle))
    {
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::FreeContextDma - handle not found\n");
        return RM_ERROR;
        
    }

#endif 

    // assume it's the correct handle and free it
    CContextDma *pElement = (CContextDma *)pIn->uHandle;
    
    if (!pElement)
        return RM_ERROR;

    pElement->Remove((CLinkList **)&m_pCDma);
    
    delete pElement;

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalVoiceProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalVoiceProc.h                                                   *
*   Functions for the voice processor in MCP1.. can be used for future      *
*   revs, if the HW processor object does not change                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALVOICEPROCH_
#define _CHALVOICEPROCH_

class CHalBase;
class CObjBase;
class CVPMethod;
class CHalGlobalProc;

class CHalVoiceProc : public CObjBase
{
public:
    CHalVoiceProc(CHalGlobalProc *pGlProc, CHalBase *pHal) : CObjBase(pHal) 
    { 
        m_pMethod = NULL;
        m_pNotifier = NULL;
        m_pGlobalProc = pGlProc;
    };

	~CHalVoiceProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);
	RM_STATUS GetCaps(VOID *pParam);
    
    VOID    SetNotifierMemory(VOID *pLinAddr, U032 uSize)   
    { 
        m_pNotifier = (PNV1BA0NOTIFICATION *)pLinAddr; 
        m_uNotifierSize = uSize; 
    }

    VOID    WriteNotifier(U032 uMethod, U008 uStatus, BOOL bVoiceMethod = 0);

    // called from the interrupt handler
    VOID    ExecuteMethod(U032 uMethod, U032 uParam);

    void *  GetSgeInLinAddr()   { return m_SgeIn.pLinAddr; }
    U032    GetSgeInSize()      { return m_SgeIn.Size; }

    void *  GetSegInLinAddr()   { return m_SegIn.pLinAddr; }
    U032    GetSegInSize()      { return m_SegIn.Size; }

private:
	VOID InitializeHardware(APU_AP_CREATE *);

    RM_STATUS AllocateMemory(APU_AP_CREATE *);
    VOID FreeMemory();

    MEM_DESC    m_Voice;
    MEM_DESC    m_SgeIn;
    MEM_DESC    m_SegIn;
    MEM_DESC    m_HRTFTarg;
    MEM_DESC    m_HRTFCurr;

    CVPMethod           *m_pMethod;
    CHalGlobalProc      *m_pGlobalProc;

    PNV1BA0NOTIFICATION *m_pNotifier;
    U032                m_uNotifierSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalMCP1.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalMCP1.h                                                        *
*   All HAL functions specific to MCP1 are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALMCP1H_
#define _CHALMCP1H_

class CHalVoiceProc;
class CHalGlobalProc;
class CHalExtendedProc;
class CContextDma;

#define MAX_CLIENTS		        8

class CHalMCP1 : public CHalBase
{
public:
	CHalMCP1(U008, HWINFO_COMMON_FIELDS *);
	~CHalMCP1();

public:
	RM_STATUS Allocate();
	RM_STATUS Free();

    RM_STATUS AddClient(VOID *pParam, U008 *pClientRef);
    RM_STATUS DeleteClient(U008 uClientRef);

    RM_STATUS AllocateContextDma(VOID *pParam);
    RM_STATUS FreeContextDma(VOID *pParam);

    RM_STATUS AllocateObject(U032 uObjectType, VOID *pParam);
    RM_STATUS FreeObject(U032 uObjectType, VOID *pParam);

	RM_STATUS InterruptService();
    
    enum E_STATE
    {
        // mode states
        FREE_RUN = 0,
        // SE modes
        OFF,
        AC_SYNC,
        SW,
        // interrupts enables for SE
        INT_PANIC,
        INT_RETRIGGER,
        INT_WARN,
        // FE modes
        HALT,
        // priv locks
        LOCK,
        UNLOCK
    };

    enum INTERRUPT_STATE
    {
        ENABLE,
        DISABLE
    };

    VOID SetFrontEnd(E_STATE);
    VOID SetSetupEngine(E_STATE);
   	VOID SetInterrupts(INTERRUPT_STATE);
    VOID SetPrivLock(E_STATE);

    CHalVoiceProc   *GetVoiceProc()     { return m_pVoiceProc; }
    CHalGlobalProc  *GetGlobalProc()    { return m_pGlobalProc; }
    CHalExtendedProc *GetExtendedProc() { return m_pExtendedProc; }

protected:
	// public objects
	CHalVoiceProc	    *m_pVoiceProc;
    CHalGlobalProc      *m_pGlobalProc;
    CHalExtendedProc    *m_pExtendedProc;

private:
	VOID OnIntrFETrap();
    VOID UpdateUserMethodQ(U032 uMethod, U032 uData);
	BOOL GetUserMethodInfo(U032 *pMethod, U032 *pData);
	VOID WriteError(U032 uIsCurrentVoice, U008	uErrorCode);
    
    VOID SetISO(APU_AP_FLAGS *pFlags);

    VOID SetSetupEngineGlobalCounts(U032 uExt, U032 uInt, U032 uDelta);
    VOID SetSetupEngineExtendedCounts(U032 uInt, U032 uDelta, U032 uStep);

    VOID CallbackClients(U032 uIntrMask);
    RM_STATUS StoreClientInfo(VOID *pFn, U032 uMask, U032 uContext);
    
    VOID GetDebugInfo();

	R_INTR	m_rInterruptMask;

    CContextDma *m_pCDma;

    MCP1_CLIENT_INFO m_ClientInfo[MAX_CLIENTS];

    MEM_DESC    m_MagicWrite;
    U032        m_uMagicWriteValue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalVoiceProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalVoiceProc.cpp                                                 *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <AudioHw.h>
#include <nvarm.h>
#include <nv32.h>
#include <nv_papu.h>
#include <aos.h>
};

#include "CHalBase.h"
#include "CVPMethod.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"


RM_STATUS
CHalVoiceProc::Allocate(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_ERROR;
	
    do
    {
        // create the method class
        m_pMethod = new CVPMethod(this, m_pGlobalProc, GetDevice());
        if (!m_pMethod)
            break;
        
        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

	    // this is for debug only!
        pArg->pVoiceList = (VOID_PTR)m_Voice.pLinAddr;
       
        InitializeHardware(pArg);

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalVoiceProc::Free(VOID *pParam)
{
	RM_STATUS rmStatus = RM_OK;
	
    if (m_pMethod)
        delete m_pMethod;

    m_pMethod = NULL;

	FreeMemory();

	return rmStatus;
}

VOID
CHalVoiceProc::ExecuteMethod(U032 uMethod, U032 uParam)
{
    if (m_pMethod)
        m_pMethod->Execute(uMethod, uParam);
}

VOID
CHalVoiceProc::FreeMemory()
{
	aosFreeMem(m_Voice.pLinAddr);
	aosFreeMem(m_SgeIn.pLinAddr);
	aosFreeMem(m_SegIn.pLinAddr);
	aosFreeMem(m_HRTFTarg.pLinAddr);
	aosFreeMem(m_HRTFCurr.pLinAddr);
}

RM_STATUS
CHalVoiceProc::AllocateMemory(APU_AP_CREATE *pArg)
{
	RM_STATUS rmStatus;

    U032 uCnt;

	m_Voice.Size = pArg->uVoiceCount * NV_PAVS_SIZE;
    m_SgeIn.Size = pArg->uSGEInCount * NV_PSGE_SIZE;
    // the driver will pass the total number of PRDs to be allocated for streams
    m_SegIn.Size = pArg->uSegInCount * NV_PSGE_SIZE;
    m_HRTFTarg.Size = pArg->uHRTFCount * NV_PAHRTFT_SIZE;
    m_HRTFCurr.Size = pArg->uVoice3dCount * NV_PAHRTFC_SIZE;
	
	rmStatus = aosAllocateMem(m_Voice.Size,
							ALIGN_32K,
							&m_Voice.pLinAddr,
							&m_Voice.pPhysAddr);
	if (rmStatus == RM_OK)
	{
        rmStatus = aosAllocateMem(m_SgeIn.Size,
								ALIGN_16K,
								&m_SgeIn.pLinAddr,
								&m_SgeIn.pPhysAddr);

	}
	

	if (rmStatus == RM_OK)
	{

		rmStatus = aosAllocateMem(m_SegIn.Size,
								ALIGN_16K,
								&m_SegIn.pLinAddr,
								&m_SegIn.pPhysAddr);

	}


	if (rmStatus == RM_OK)
	{

		rmStatus = aosAllocateMem(m_HRTFTarg.Size,
								ALIGN_16K,
								&m_HRTFTarg.pLinAddr,
								&m_HRTFTarg.pPhysAddr);

	}

	if (rmStatus == RM_OK)
	{
		rmStatus = aosAllocateMem(m_HRTFCurr.Size,
								ALIGN_16K,
								&m_HRTFCurr.pLinAddr,
								&m_HRTFCurr.pPhysAddr);

	}

    // initialize the voice structures
    if (rmStatus == RM_OK)
    {
        U032 uAddr;
        U016 uNxtVoice;

        for (uCnt = 0; uCnt < pArg->uVoiceCount; uCnt++) 
        {
            uAddr = U032(m_Voice.pLinAddr) + (uCnt * NV_PAVS_SIZE);

            aosZeroMemory((VOID *)uAddr, NV_PAVS_SIZE);

            uNxtVoice = (U016)REF_NUM(NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE, uCnt);

            MemWrite(uAddr + NV_PAVS_VOICE_TAR_PITCH_LINK, uNxtVoice);
        }
        
        aosZeroMemory(m_SgeIn.pLinAddr, m_SgeIn.Size);
        aosZeroMemory(m_SegIn.pLinAddr, m_SegIn.Size);
        
    }

	return rmStatus;
}


RM_STATUS
CHalVoiceProc::GetCaps(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	VOLU32 vTemp;

    if (pArg->uVoiceCount)
    {
	    vTemp = pArg->uVoiceCount - 1;
	    RegWrite(NV_PAPU_FEMAXV, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXV, &vTemp);
	    pArg->uVoiceCount = vTemp + 1;
    }

    if (pArg->uVoice3dCount)
    {
	    vTemp = pArg->uVoice3dCount - 1;
	    RegWrite(NV_PAPU_FEMAXTV, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXTV, &vTemp);
	    pArg->uVoice3dCount = vTemp + 1;
    }

	if (pArg->uHRTFCount)
    {
        vTemp = pArg->uHRTFCount - 1;
	    RegWrite(NV_PAPU_FEMAXHT, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXHT, &vTemp);
	    pArg->uHRTFCount = vTemp + 1;
    }


	if (pArg->uSegInCount)
    {
        vTemp = pArg->uSegInCount - 1;
	    RegWrite(NV_PAPU_FEMAXSESSL, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXSESSL, &vTemp);
	    pArg->uSegInCount = vTemp + 1;
    }

	if (pArg->uSGEInCount)
    {
        vTemp = pArg->uSGEInCount - 1;
	    RegWrite(NV_PAPU_FEMAXSESGE, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXSESGE, &vTemp);
	    pArg->uSGEInCount = vTemp + 1;
    }
    
    if (pArg->uSubmixCount)
    {
	    // submixes
        vTemp = pArg->uSubmixCount - 1;
	    RegWrite(NV_PAPU_FEMAXMB, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXMB, &vTemp);
	    pArg->uSubmixCount = vTemp + 1;
    }
    
    pArg->limitFifo = NV_PAPU_FEUFIFOMETH__SIZE_1;

	return RM_OK;
}

VOID
CHalVoiceProc::InitializeHardware(APU_AP_CREATE *pArg)
{
    // program the instance memory
    RegWrite(NV_PAPU_VPVADDR, (U032)m_Voice.pPhysAddr);
	RegWrite(NV_PAPU_VPHTADDR, (U032)m_HRTFTarg.pPhysAddr);
	RegWrite(NV_PAPU_VPHCADDR, (U032)m_HRTFCurr.pPhysAddr);
	RegWrite(NV_PAPU_VPSGEADDR, (U032)m_SgeIn.pPhysAddr);
	RegWrite(NV_PAPU_VPSSLADDR, (U032)m_SegIn.pPhysAddr);
}

VOID
CHalVoiceProc::WriteNotifier(U032 uMethod, U008	uErrorCode, BOOL uIsCurrentVoice)		
{
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalVoiceProc::WriteNotifier - Writing to notification memory\n");

    if (m_pNotifier)
    {
        U032 uIndex = 0;

        // TRUE - pick up from FECV, else write to [0]
        if (uIsCurrentVoice)
        {
            // get index
            RegRead(NV_PAPU_FECV, &uIndex);
            uIndex = (2*uIndex) + 2;
        }
        
        m_pNotifier[uIndex]->GSCNT = 0xA1;             // just my signature
        m_pNotifier[uIndex]->CurrentOffset = uMethod; 
        m_pNotifier[uIndex]->Zero = 0;
        m_pNotifier[uIndex]->Res0 = 0;
        m_pNotifier[uIndex]->SamplesAvailable = 0;
        m_pNotifier[uIndex]->EnvelopeActive = 0;
        m_pNotifier[uIndex]->Status = uErrorCode;
    }
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::WriteError - Notification memory not available\n");
    }

    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::WriteError - Done\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CMixerBuffer.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: CMixerBuffer.h													*
*   Class to resource manage the mixer buffers							    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CMIXERBUFFERH_
#define _CMIXERBUFFERH_

// max 256
#define MIXER_BUFFERS_HW            32
#define MIXER_BUFFERS_SW            32


class CMixerBuffer
{
public:

    enum MIXER_TYPE
    {
        HW,
        SW
    };

    CMixerBuffer()
    {
        U008 uCnt;

        for (uCnt = 0; uCnt < MIXER_BUFFERS_HW; uCnt++)
            m_bMixHw[uCnt] = FALSE;

        for (uCnt = 0; uCnt < MIXER_BUFFERS_SW; uCnt++)
            m_bMixSw[uCnt] = FALSE;
    }

    RM_STATUS Allocate(MIXER_TYPE eType, U008 *pId)
    {
        U008 uCnt;

        if (eType == HW)
        {
            for (uCnt = 0; uCnt < MIXER_BUFFERS_HW; uCnt++)
            {
                if (m_bMixHw[uCnt] == FALSE)
                {
                    *pId = uCnt;
                    m_bMixHw[uCnt] = TRUE;
                    return RM_OK;

                }
            }
        }
        else
        {
            for (uCnt = 0; uCnt < MIXER_BUFFERS_SW; uCnt++)
            {
                if (m_bMixSw[uCnt] == FALSE)
                {
                    *pId = MIXER_BUFFERS_HW + uCnt;
                    m_bMixSw[uCnt] = TRUE;
                    return RM_OK;

                }
            }
        }

        return RM_ERROR;
    }
    
    VOID Free(U008 uId)
    {
        if (uId < MIXER_BUFFERS_HW)
            m_bMixHw[uId] = FALSE;
        else
            m_bMixSw[uId - MIXER_BUFFERS_HW] = FALSE;
    }
    
private:
    BOOL m_bMixHw[MIXER_BUFFERS_HW];
    BOOL m_bMixSw[MIXER_BUFFERS_SW];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CObjBase.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CObjBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _COBJBASEH_
#define _COBJBASEH_

class CHalBase;

class CObjBase
{
public:
	CObjBase(CHalBase *pHal)	{ m_pHal = pHal; }

public:
	// each derived object has to implement these functions
	virtual RM_STATUS Allocate(VOID *pParam) = 0;
	virtual RM_STATUS Free(VOID *pParam = NULL) = 0;
    
    // each derived object also has to make a method handler
    // for any software methods associated with the object

protected:
	
	virtual VOID RegWrite(U032 uOffset, U032 uValue) { m_pHal->RegWrite(uOffset, uValue); }
	virtual VOID RegWrite(U032 uOffset, U016 uValue) { m_pHal->RegWrite(uOffset, uValue); }
	virtual VOID RegWrite(U032 uOffset, U008 uValue) { m_pHal->RegWrite(uOffset, uValue); }

	virtual VOID RegRead(U032 uOffset, U032 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, U016 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, U008 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U032 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U016 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U008 *pValue) { m_pHal->RegRead(uOffset, pValue); }

    virtual void MemWrite(U032 uAddr, U008 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }
    virtual void MemWrite(U032 uAddr, U016 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }
    virtual void MemWrite(U032 uAddr, U032 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }

    CHalBase *GetDevice()           { return m_pHal; }

private:
	CHalBase *m_pHal;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CScratchDma.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to do DSP memory management*****************\
*                                                                           *
* Module: CScratchDma.h		                                                *
*   Object to handle pages/offsets etc for the scratch memory		        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CSCRATCHDMA_
#define _CSCRATCHDMA_

typedef struct _pageArray
{
    VOID *  pLin;
    U032    uPhys;
    U032    uBytesAvailBeg;     // bytes available on the beginning of the page
    U032    uBytesAvailEnd;     // bytes availbale at the end of the page
} PAGE_ARRAY, *PPAGE_ARRAY;

class CHalBase;

class CScratchDma
{
public:
    CScratchDma(CHalBase *pHal, U032 uRegOffset);
    ~CScratchDma();

public:
    RM_STATUS Initialize(MEM_DESC *pScratchTable);
    
    RM_STATUS Allocate(U032 uBytesReguested, U032 *pLinOffset);
    VOID Free(U032 uLinOffset, U032 uSize);

    VOID Write(U032 uLinOffset, VOID *pSource, U032 uSize);
    VOID Read(VOID *pDest, U032 uLinOffset, U032 uSize);

    VOID Put(U032 uLinOffset, U032 uVal);
    VOID Put(U032 uLinOffset, U032 uSize, U032 uVal);
    U032 Get(U032 uLinOffset);

    VOID *GetScratchTableLinAddr() { return m_ScratchTable.pLinAddr; }

    // only used to for AC-3 buffer sharing between GP & EP - use allocate
    // for all other purposes
    RM_STATUS AddPage(PMEM_DESC pMem, U032 uNumOfPages, U032 *pOffset);
    VOID RemovePage(PMEM_DESC pMem, U032 uNumOfPages);

    // debug only!
    VOID *GetPage(U032 uIndex) { return m_pPageTable[uIndex].pLin; }

    // these functions are to be used very very carefully
    // the address returned from here are not contiguous 
    // across the next page
    VOID *GetLinAddr(U032 uLinOffset);
    VOID *GetPhysAddr(U032 uLinOffset);

private:

    VOID RemovePage(U032 uIndex);
    VOID RemoveFromPageTable(U032 uIndex);

    U032 AddPage(U032 *pIndex, U032 uNum = 1);
    VOID AddToPageTable(U032 uIndex, VOID *pLinAddr, U032 uPhysAddr);

    U032 GetContiguousFreeIndex(U032 uNum);
    U032 GetPageIndex(VOID *pLin);

    U032 GetPageNumber(U032 uLinOffset) { return PAGENUM(uLinOffset); }
    U032 GetPageOffset(U032 uLinOffset) { return (uLinOffset & 0xFFF); }

    PAGE_ARRAY  *m_pPageTable;
    
    U016        m_uMaxPages;
    U016        m_uValidPages;
    MEM_DESC    m_ScratchTable;
    MEM_DESC    m_DummyPage;

    CHalBase    *m_pHal;
    U032        m_uRegOffsetValidPages;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\cscratchmanager.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CScratchManager.cpp                                              *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <aos.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include "CHalBase.h"
#include "CScratchDma.h"
#include "CScratchManager.h"


RM_STATUS   
CScratchManager::Initialize(VOID_PTR pLoader, 
                            U032 uLoaderSize)
{
    
    if (!m_pScratchDma)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchManager::Initialize - one of the objects could not be constructed\n");
        return RM_ERROR;
    }
    
    // WARNING!  WARNING!  WARNING!
    // vik todo = this line is to test out the EP dolby digital stuff without
    // GP effects actually working... remove in final version!!!!

    m_uSize = 512 * PAGE_SIZE;
    
    /*
    just need enough memory to copy the loader program and the command node the GP polls
    m_uSize = uLoaderSize + whatever the command node size is...
    */

    RM_STATUS rmStatus = m_pScratchDma->Allocate(m_uSize, &m_uOffset);

    if (rmStatus != RM_OK)
        return rmStatus;

    // sanity check!
    if (m_uOffset)
    {
        // internal error!  it's all screwed up!
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchManager::Initialize - Internal Error!!!\n");
        aosDbgBreakPoint();
    }

    // make sure the loader size is good
    if (uLoaderSize < MAX_SIZE_LOADER)
        m_pScratchDma->Write(m_uOffset, (VOID *)pLoader, uLoaderSize*sizeof(U032));
    else
        return RM_ERROR;

    return RM_OK;
}

VOID
CScratchManager::Shutdown()
{
    if (m_pScratchDma && m_uSize)
        m_pScratchDma->Free(m_uOffset, m_uSize);

    m_uSize = 0;
}

// debug onlY!
VOID *
CScratchManager::GetScratchPage(U032 uPageNumber) 
{ 
    return m_pScratchDma->GetPage(uPageNumber); 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\cscratchdma.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to do DSP memory management*****************\
*                                                                           *
* Module: CScratchMemory.cpp		                                            *
*   Object to handle pages/offsets etc for the scratch memory		        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <aos.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include "CHalBase.h"
#include "CScratchDma.h"

#define INVALID_INDEX_VALUE         (~0)

CScratchDma::CScratchDma(CHalBase *pHal, U032 uRegValidPages)
{
    m_uValidPages = 0;
    m_uMaxPages = 0;
    m_pPageTable = NULL;
    m_pHal = pHal;
    m_uRegOffsetValidPages = uRegValidPages;
}

CScratchDma::~CScratchDma()
{
    if (m_pPageTable)
    {
        // free all the memory
        for (U032 uCnt = 0; uCnt < m_uValidPages; uCnt++)
            aosFreeMem(m_pPageTable[uCnt].pLin);

        aosFreeMem(m_pPageTable);
        aosFreeMem(m_DummyPage.pLinAddr);
        m_pPageTable = NULL;
    }
}

RM_STATUS
CScratchDma::Initialize(MEM_DESC *pScratchTable)
{
	m_uMaxPages = (U016) (pScratchTable->Size / NV_PSGE_SIZE);
    aosMemCopy((VOID *)&m_ScratchTable, (VOID *)pScratchTable, sizeof(MEM_DESC));

    // allocate memory for the page table
    RM_STATUS rmStatus = aosAllocateMem(m_uMaxPages * sizeof(PAGE_ARRAY),
                                        ALIGN_DONT_CARE,
                                        (VOID **)&m_pPageTable,
                                        NULL);
    
    // allocate a dummy page, and point all unused PRDs to it
    m_DummyPage.Size = PAGE_SIZE;
    rmStatus = aosAllocateMem(m_DummyPage.Size,
                            ALIGN_4K,
                            &m_DummyPage.pLinAddr,
                            &m_DummyPage.pPhysAddr);
    
    aosZeroMemory(m_DummyPage.pLinAddr, m_DummyPage.Size);

    // make all the PRDs point to the dummy page...
    MCP1_PRD *pPrd = (MCP1_PRD *)m_ScratchTable.pLinAddr;

    for (U032 uCnt = 0; uCnt < m_uMaxPages; uCnt++)
    {
        pPrd[uCnt].uAddr = (U032)m_DummyPage.pPhysAddr;
        pPrd[uCnt].Control.uValue = 0;
        pPrd[uCnt].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;
    }

    if (rmStatus == RM_OK)
        aosZeroMemory(m_pPageTable, m_uMaxPages * sizeof(PAGE_ARRAY));
    
    m_pHal->RegWrite(m_uRegOffsetValidPages, m_uValidPages);

    return rmStatus;
}

RM_STATUS 
CScratchDma::Allocate(U032 uBytesReguested, U032 *pLinOffset)
{
    
    U032 uBytesAvail;

    // can the requirement be satisfied by the exisiting pages?
    for (U016 uCnt = 0; uCnt < m_uValidPages - 1; uCnt++)
    {
        uBytesAvail = 0;

        if (m_pPageTable[uCnt].pLin)
            uBytesAvail += m_pPageTable[uCnt].uBytesAvailEnd;
            
        if (m_pPageTable[uCnt + 1].pLin)
            uBytesAvail += m_pPageTable[uCnt].uBytesAvailBeg;

        if (uBytesReguested <= uBytesAvail)
        {
            if (m_pPageTable[uCnt].uBytesAvailEnd)
            {
                *pLinOffset = (PAGE_SIZE * uCnt) + m_pPageTable[uCnt].uBytesAvailEnd;
                if (m_pPageTable[uCnt].uBytesAvailEnd < uBytesReguested)
                {
                    m_pPageTable[uCnt + 1].uBytesAvailBeg = uBytesReguested - m_pPageTable[uCnt].uBytesAvailEnd;
                    m_pPageTable[uCnt].uBytesAvailEnd = 0;
                }
                else
                    m_pPageTable[uCnt].uBytesAvailEnd -= uBytesReguested;
            }
            else
            {
                *pLinOffset = PAGE_SIZE * (uCnt+1);
                m_pPageTable[uCnt + 1].uBytesAvailBeg -= uBytesReguested;
            }

            break;
        }
    }

    // did we satisfy the requirement
    if (uCnt < m_uValidPages - 1)
        return RM_OK;

    // elaborate the logic later to include end avail on pages other
    // than the last.. etc etc etc

    U016 uPagesNeeded = (U016)(((uBytesReguested+PAGE_SIZE-1)/PAGE_SIZE));
    U032 uPageIndex;

    RM_STATUS rmStatus = AddPage(&uPageIndex, uPagesNeeded);
    if (rmStatus != RM_OK)
        return rmStatus;
    
    m_uValidPages = uPagesNeeded;

    if (uPageIndex)
    {
        // get the 411 on the previous page and update it's offset
        *pLinOffset = (PAGE_SIZE * (uPageIndex-1) ) + m_pPageTable[uPageIndex-1].uBytesAvailEnd;
        uBytesReguested -= m_pPageTable[uPageIndex-1].uBytesAvailEnd;
        m_pPageTable[uPageIndex-1].uBytesAvailEnd = 0;
    }
    else
        *pLinOffset = PAGE_SIZE * uPageIndex;

    // spin thru' the pages updating the offsets on each page
    while (uBytesReguested)
    {
        m_pPageTable[uPageIndex].uBytesAvailBeg = 0;
        m_pPageTable[uPageIndex].uBytesAvailEnd = (PAGE_SIZE < uBytesReguested)?0:(PAGE_SIZE - uBytesReguested);
        uBytesReguested -= (PAGE_SIZE - m_pPageTable[uPageIndex].uBytesAvailEnd);
        uPageIndex++;
    }

    return rmStatus;
}

VOID
CScratchDma::Free(U032 uOffset, U032 uSize)
{
    U032 uPageIndex = GetPageNumber(uOffset);
    U032 uPageOffset = GetPageOffset(uOffset);
    
    if (uPageOffset)
    {
        m_pPageTable[uPageIndex].uBytesAvailEnd = PAGE_SIZE - uPageOffset;
        uSize -= m_pPageTable[uPageIndex].uBytesAvailEnd;
        uPageIndex++;
    }

    // how many pages are spanned?
    while(uSize)
    {
        if (PAGE_SIZE <= m_pPageTable[uPageIndex].uBytesAvailEnd + uSize)
        {   
            uSize -= (PAGE_SIZE - m_pPageTable[uPageIndex].uBytesAvailEnd);
            RemovePage(uPageIndex);
        }
        else
        {
            // this is the last page
            m_pPageTable[uPageIndex].uBytesAvailBeg = uSize;
            uSize = 0;
            if ( (m_pPageTable[uPageIndex].uBytesAvailBeg + m_pPageTable[uPageIndex].uBytesAvailBeg) == PAGE_SIZE)
                RemovePage(uPageIndex);
        }
    }
}

VOID
CScratchDma::RemovePage(U032 uIndex)
{
    aosFreeMem(m_pPageTable[uIndex].pLin);
    RemoveFromPageTable(uIndex);
}

VOID
CScratchDma::RemoveFromPageTable(U032 uIndex)
{
    m_pPageTable[uIndex].pLin = NULL;
    m_pPageTable[uIndex].uPhys = 0;

    MCP1_PRD *pPrd = (MCP1_PRD *)m_ScratchTable.pLinAddr;
    pPrd[uIndex].uAddr = (U032)m_DummyPage.pPhysAddr;
    pPrd[uIndex].Control.uValue = 0;
    pPrd[uIndex].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_NOT_HW;

    // do we need to update max valid pages?
    if (uIndex == (U032)(m_uValidPages - 1) )
    {
        // last page
        m_uValidPages--;
        m_pHal->RegWrite(m_uRegOffsetValidPages, m_uValidPages);
    }

    return;
}

U032
CScratchDma::GetContiguousFreeIndex(U032 uNum)
{
    bool bFlag;

    for (U032 uCnt = 0; uCnt < m_uMaxPages; uCnt++)
    {
        if (!m_pPageTable[uCnt].pLin)
        {
            bFlag = TRUE;

            // make sure we have contiguous indices free
            for (U032 uCnt1 = uCnt + 1; uCnt1 < (uCnt + uNum); uCnt1++)
            {
                if (m_pPageTable[uCnt].pLin)
                {
                    bFlag = FALSE;
                    break;
                }
            }

            if (bFlag == TRUE)
                return uCnt;
        }
    }

    return INVALID_INDEX_VALUE;
}

VOID
CScratchDma::AddToPageTable(U032 uIndex, VOID *pLinAddr, U032 uPhysAddr)
{
    m_pPageTable[uIndex].pLin = pLinAddr;
    m_pPageTable[uIndex].uPhys = uPhysAddr;

    // assume the pages are fully utilized
    m_pPageTable[uIndex].uBytesAvailBeg = 0;
    m_pPageTable[uIndex].uBytesAvailEnd = 0;
    
    // update the PRDs
    MCP1_PRD *pPrd = (MCP1_PRD *)m_ScratchTable.pLinAddr;
    pPrd[uIndex].uAddr = uPhysAddr;
    pPrd[uIndex].Control.uValue = 0;
    pPrd[uIndex].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;
    
    if (uIndex > (U032)m_uValidPages)
    {
        m_uValidPages = (U016)uIndex;
        m_pHal->RegWrite(m_uRegOffsetValidPages, m_uValidPages);
    }
}

RM_STATUS
CScratchDma::AddPage(U032 *pIndex, U032 uNum)
{
    RM_STATUS rmStatus = RM_ERROR;
    U032 uPagesAdded = 0;
    
    VOID *pLin;
    U032 uPhys;
    
    U032 uIndex = GetContiguousFreeIndex(uNum);

    if (uIndex == INVALID_INDEX_VALUE)
        return RM_ERROR;
    
    *pIndex = uIndex;

    while (uPagesAdded < uNum)
    {
        rmStatus =  aosAllocateMem( PAGE_SIZE,
						            ALIGN_4K,
						            &pLin,
						            (VOID **)&uPhys);

        if (rmStatus != RM_OK)
            break;

        AddToPageTable(uIndex, pLin, uPhys);

        uPagesAdded++;
        uIndex++;
    }
    
    return rmStatus;
}

RM_STATUS
CScratchDma::AddPage(PMEM_DESC pMem, U032 uNumOfPages, U032 *pOffset)
{
    RM_STATUS rmStatus = RM_OK;

    U032 uIndex = GetContiguousFreeIndex(uNumOfPages);
    if (uIndex == INVALID_INDEX_VALUE)
        return RM_ERROR;
    
    *pOffset = PAGE_SIZE * uIndex;

    // memory already allocated...
    for (U032 uCnt = 0; uCnt < uNumOfPages; uCnt++)
    {
        AddToPageTable(uIndex, pMem[uCnt].pLinAddr, (U032)pMem[uCnt].pPhysAddr);
        uIndex++;
    }

    return RM_OK;
}

U032
CScratchDma::GetPageIndex(VOID *pLin)
{
    for (U032 uCnt = 0; uCnt < m_uValidPages; uCnt++)
    {
        if (m_pPageTable[uCnt].pLin == pLin)
            return uCnt;
    }

    return INVALID_INDEX_VALUE;
}

VOID
CScratchDma::RemovePage(PMEM_DESC pMem, U032 uNumOfPages)
{
    U032 uIndex;

    for (U032 uCnt = 0; uCnt < uNumOfPages; uCnt++)
    {
        uIndex = GetPageIndex(pMem[uCnt].pLinAddr);
        if (uIndex != INVALID_INDEX_VALUE)
            RemoveFromPageTable(uIndex);
    }
}


VOID
CScratchDma::Write(U032 uLinOffset, VOID *pSource, U032 uSize)
{
    while(uSize)
    {
        U032 uDestSize = PAGE_SIZE - GetPageOffset(uLinOffset);
        U032 uCopySize = MIN(uDestSize, uSize);

#if defined DEBUG
        if (GetPageNumber(uLinOffset) > m_uValidPages)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchDma::Write - incorrect offset\n");
            aosDbgBreakPoint();
        }
#endif
        // destination ptr
        VOID *pDest = GetLinAddr(uLinOffset);
        aosMemCopy(pDest, pSource, uCopySize);

        uSize -= uCopySize;
        pSource = (VOID *)((U032)pSource + uCopySize);
        uLinOffset += uCopySize;
    }
}

VOID
CScratchDma::Read(VOID *pDest, U032 uLinOffset, U032 uSize)
{
    while (uSize)
    {
        U032 uSrcSize = PAGE_SIZE - GetPageOffset(uLinOffset);
        U032 uCopySize = MIN(uSrcSize, uSize);

#if defined DEBUG
        if (GetPageNumber(uLinOffset) > m_uValidPages)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchDma::Read - incorrect offset\n");
            aosDbgBreakPoint();
        }
#endif

        VOID *pSrc = GetLinAddr(uLinOffset);
        aosMemCopy(pDest, pSrc, uCopySize);

        uSize -= uCopySize;
        pDest = (VOID *)((U032)pDest + uCopySize);
        uLinOffset += uCopySize;
    }
}

U032
CScratchDma::Get(U032 uLinOffset)
{
#if defined DEBUG
        if (GetPageNumber(uLinOffset) > m_uValidPages)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchDma::Get - incorrect offset\n");
            aosDbgBreakPoint();
        }
#endif
    return *( (U032 *) GetLinAddr(uLinOffset) );
}

VOID
CScratchDma::Put(U032 uLinOffset, U032 uSize, U032 uVal)
{
    for (U032 uCnt = 0; uCnt < uSize; uCnt++)
        Put(uLinOffset + uCnt, uVal);
}

VOID
CScratchDma::Put(U032 uLinOffset, U032 uData)
{
#if defined DEBUG
        if (GetPageNumber(uLinOffset) > m_uValidPages)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchDma::Put - incorrect offset\n");
            aosDbgBreakPoint();
        }
#endif
    *( (U032 *) GetLinAddr(uLinOffset) ) = uData;
}

VOID *
CScratchDma::GetLinAddr(U032 uLinOffset)
{
    return (VOID *)((U032)m_pPageTable[GetPageNumber(uLinOffset)].pLin + GetPageOffset(uLinOffset));
}

VOID *
CScratchDma::GetPhysAddr(U032 uLinOffset)
{
    return (VOID *)(m_pPageTable[GetPageNumber(uLinOffset)].uPhys + GetPageOffset(uLinOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CScratchManager.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base Object to manage scratch**********************\
*                                                                           *
* Module: CScratchManager.h                                                 *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CSCRATCHMANAGER_
#define _CSCRATCHMANAGER_

#define MAX_SIZE_LOADER         (2048 * sizeof(U032))   /* in BYTES */

class CHalBase;
class CScratchDma;

class CScratchManager
{
public:
   CScratchManager()
   {
        m_pScratchDma = NULL;
        m_uSize = 0;
        m_uOffset = 0;
   }

public:

    RM_STATUS   Initialize( VOID_PTR pLoader, 
                            U032 uLoaderSize);
    VOID        Shutdown();

    CScratchDma *GetScratchDma() { return m_pScratchDma; }
    VOID        SetScratchDma(CScratchDma *pDma) { m_pScratchDma = pDma; }

    // debug only
    VOID *GetScratchPage(U032 uPageNumber);

private:
    CScratchDma     *m_pScratchDma;
    U032            m_uSize;
    U032            m_uOffset;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\AudioFx.cpp ===
// *************************************************************************
//
//	AudioFx:		DSP Execution Support routines
//
//	Written by Gints Klimanis
//
// *************************************************************************
#include "util.h"
#include <string.h>

#include "DSP_Util.h"
#include "AudioFx.h"

#include "DSP_Binaries.h"

// Built-in FX modules
#include "NullModule_Util.h"

// The First 32 buffers reference the MixBuffers
#define kAudioFX_BufferID_MixBuf00	 0	
#define kAudioFX_BufferID_MixBuf01	 1	
#define kAudioFX_BufferID_MixBuf02	 2	
#define kAudioFX_BufferID_MixBuf03	 3	
#define kAudioFX_BufferID_MixBuf04	 4	
#define kAudioFX_BufferID_MixBuf05	 5	
#define kAudioFX_BufferID_MixBuf06	 6	
#define kAudioFX_BufferID_MixBuf07	 7	
#define kAudioFX_BufferID_MixBuf08	 8	
#define kAudioFX_BufferID_MixBuf09	 9	
#define kAudioFX_BufferID_MixBuf10	10	
#define kAudioFX_BufferID_MixBuf11	11	
#define kAudioFX_BufferID_MixBuf12	12	
#define kAudioFX_BufferID_MixBuf13	13	
#define kAudioFX_BufferID_MixBuf14	14	
#define kAudioFX_BufferID_MixBuf15	15	

#define kAudioFX_BufferID_MixBuf16	16	
#define kAudioFX_BufferID_MixBuf17	17	
#define kAudioFX_BufferID_MixBuf18	18	
#define kAudioFX_BufferID_MixBuf19	19	
#define kAudioFX_BufferID_MixBuf20	20	
#define kAudioFX_BufferID_MixBuf21	21	
#define kAudioFX_BufferID_MixBuf22	22	
#define kAudioFX_BufferID_MixBuf23	23	
#define kAudioFX_BufferID_MixBuf24	24	
#define kAudioFX_BufferID_MixBuf25	25	
#define kAudioFX_BufferID_MixBuf26	26	
#define kAudioFX_BufferID_MixBuf27	27	
#define kAudioFX_BufferID_MixBuf28	28	
#define kAudioFX_BufferID_MixBuf29	29	
#define kAudioFX_BufferID_MixBuf30	30	
#define kAudioFX_BufferID_MixBuf31	31	

// GK FIXXX: check-in rush kludge.  Ideally, I would like these
// to be #define,
//char *audioFxModuleTypeName_DMA  = kAudioFxModuleTypeName_DMA;
//char *audioFxModuleTypeName_Null = kAudioFxModuleTypeName_Null;

//char *audioFxModuleTypeName_AmpMod     = kAudioFxModuleTypeName_AmpMod;
//char *audioFxModuleTypeName_Chorus     = kAudioFxModuleTypeName_Chorus;
//char *audioFxModuleTypeName_Compressor = kAudioFxModuleTypeName_Compressor;
//char *audioFxModuleTypeName_Delay      = kAudioFxModuleTypeName_Delay;
//char *audioFxModuleTypeName_Distortion = kAudioFxModuleTypeName_Distortion;
//char *audioFxModuleTypeName_Echo       = kAudioFxModuleTypeName_Echo;
//char *audioFxModuleTypeName_Equalizer  = kAudioFxModuleTypeName_Equalizer;
//char *audioFxModuleTypeName_Flange     = kAudioFxModuleTypeName_Flange;
//char *audioFxModuleTypeName_IIIR       = kAudioFxModuleTypeName_IIIR;
//char *audioFxModuleTypeName_IIR1       = kAudioFxModuleTypeName_IIR1;
//char *audioFxModuleTypeName_IIR2       = kAudioFxModuleTypeName_IIR2;
//char *audioFxModuleTypeName_Limiter    = kAudioFxModuleTypeName_Limiter;
//char *audioFxModuleTypeName_Mixer      = kAudioFxModuleTypeName_Mixer;
//char *audioFxModuleTypeName_Oscillator = kAudioFxModuleTypeName_Oscillator;
//char *audioFxModuleTypeName_Reverb     = kAudioFxModuleTypeName_Reverb;

// **********************************************************************************
// AUDIOFX:		Set up audio effects objects except the data-dependent
//						delay line stuff.  This structure will house all of
//						the ptrs to the Command Nodes, DSP Execution Lists, 
//						DSP Code Blocks, DSP Small State Blocks, DSP Large State 
//						blocks in system memory.  
//						
//		Return ptr to AUDIOFX structure
// ********************************************************************************** 
AUDIOFX::AUDIOFX(long uMaxModules, CScratchDma *pDma)
{
int i;
  
#ifndef AUDIOFX_STANDALONE  
afxScratchMemInitialize(pDma);
#endif

// Scratch Memory block pointers
dspCodeBlock   = (Int24 *) kAudioFX_SMAddress_CodeBlock;		// DSP PRAM Code block
dspModuleBlock = (Int24 *) kAudioFX_SMAddress_ModuleBlock;	// DSP XRAM Execution List
dspStateBlock  = (Int24 *) kAudioFX_SMAddress_StateBlock;		// DSP X/YRAM
//dspLargeStateBlock = NULL;  // System Memory state: delay lines, etc.

dspCodeBlockSize   = 0;		
dspModuleSize      = 0;
dspStateBlockSize  = 0;
//dspLargeStateBlockSize = 0;

topologyName = NULL;

// Setup individual modules
#ifndef AUDIOFX_STANDALONE  
if (uMaxModules > kAudioFx_MaxModules)
    {
    aosDbgPrintString(DEBUGLEVEL_ERRORS, "AUDIOFX::AUDIOFX - so many modules not supported!!\n");
    aosDbgBreakPoint();
    }
#endif
maxModules = uMaxModules;
for (i = 0; i < kAudioFxModule_MaxTypes; i++)
	{
	InitPlugIn(&plugIns[i]);

//	dspComputeRoutines    [i] = NullCompute_In1Out1;
//	dspComputeRoutineSizes[i] = NullCompute_In1Out1Length;
	}
dspModuleBlock = (Int24 *) afxSystemMemAlloc(maxModules*sizeof(DSPMODULE));

// Add Plug-In routines

// Other stuff
moduleIDCounter     = 0;
typeIDCounter       = kAudioFxModuleTypeID_Null+1;
moduleCount         = 0;
executionListLength = 0;

AUDIOFX_MODULE *p = modules;
for (i = 0; i < maxModules; i++)
	{
	p[i].moduleID = kAudioFxModule_EmptyID;
	executionList[i] = kAudioFxModuleTypeID_Null;
	}

for (i = 0; i < kAudioFX_MaxInputFIFOs; i++)
	{
	inputFIFOs[i].channelFormat = kFIFO_ChannelFormat_Stereo;
	inputFIFOs[i].classDataSize = kFIFO_ClassDataSize_16_16;
	}
for (i = 0; i < kAudioFX_MaxOutputFIFOs; i++)
	{
	outputFIFOs[i].channelFormat = kFIFO_ChannelFormat_Stereo;
	outputFIFOs[i].classDataSize = kFIFO_ClassDataSize_16_16;
	}

// FIXXX:  record to avoid this sort of string table
for (i = 0; i < kAudioFxModule_MaxTypes; i++)
	audioFxModuleTypeNames[i] = NULL;

audioFxModuleTypeNames[kAudioFxModuleTypeID_DMA       ] = kAudioFxModuleTypeName_DMA;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Mixer     ] = kAudioFxModuleTypeName_Mixer;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Null      ] = kAudioFxModuleTypeName_Null;

audioFxModuleTypeNames[kAudioFxModuleTypeID_AmpMod    ] = kAudioFxModuleTypeName_AmpMod;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Chorus    ] = kAudioFxModuleTypeName_Chorus;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Compressor] = kAudioFxModuleTypeName_Compressor;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Delay     ] = kAudioFxModuleTypeName_Delay;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Distortion] = kAudioFxModuleTypeName_Distortion;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Echo      ] = kAudioFxModuleTypeName_Echo;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Equalizer ] = kAudioFxModuleTypeName_Equalizer;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Flange    ] = kAudioFxModuleTypeName_Flange;
audioFxModuleTypeNames[kAudioFxModuleTypeID_IIIR      ] = kAudioFxModuleTypeName_IIIR;
audioFxModuleTypeNames[kAudioFxModuleTypeID_IIR1      ] = kAudioFxModuleTypeName_IIR1;
audioFxModuleTypeNames[kAudioFxModuleTypeID_IIR2      ] = kAudioFxModuleTypeName_IIR2;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Limiter   ] = kAudioFxModuleTypeName_Limiter;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Mixer     ] = kAudioFxModuleTypeName_Mixer;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Oscillator] = kAudioFxModuleTypeName_Oscillator;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Reverb    ] = kAudioFxModuleTypeName_Reverb;

}	// ---- end AUDIOFX() ---- 

// ******************************************************************
// ~AUDIOFX:		Deallocate internal Audio FX data blocks
//	
//					Return Boolean success
// ****************************************************************** 
AUDIOFX::~AUDIOFX()
{
int	i;

// Deallocate modules
for (i = 0; i < kAudioFx_MaxModules; i++)
	DeleteModule(modules[i].moduleID);
    
#ifndef AUDIOFX_STANDALONE  
    afxScratchMemShutdown();
#endif
}	// ---- end ~AUDIOFX() ---- 

#ifdef SAFE
// ****************************************************************
// ConnectAudioFX:	Connect one module output to input of another module
//
//		Note:  Modules may be connected to themselves, but there will
//				be one frame of latency in the recirculation path.
//				To Disconnect a module, connect both outputs or
//				both inputs to the NULL module.  
//
//						Return Boolean success
// **************************************************************** 
	int	
AUDIOFX::ConnectModules(long sourceID, int outIndex, long destID, int inIndex)
{
AUDIOFX_MODULE *inModule, *outModule;

inModule  = FindAudioFXModule(sourceID);
outModule = FindAudioFXModule(destID  );

if (!inModule || !outModule)
	return (False);

if (kAudioFxModule_DMA == inModule->typeID || kAudioFxModule_DMA == outModule->typeID)
	return (False);

outModule->outBufferIDs[outIndex] = inModule->inBufferIDs[ inIndex];

return (True);
}	// ---- end ConnectAudioFX() ---- 
#endif

#ifdef SAFE
// ****************************************************************
// SetModule_IOBuffers:	Specify buffer IDs for module inputs and outputs
//
//		Note:  If a module has no inputs or outputs, the bufferIDS for
//				for those connections will be ignored.
//
//						Return Boolean success
// **************************************************************** 
	int	
AUDIOFX::SetModule_IOBuffers(long moduleID, int  inIndex, int  inBufferIFD, 
								int outIndex, int outBufferID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m || kAudioFxModule_DMA == m->typeID)
	return (False);

m->inBufferIDs [ inIndex] =  inBufferID;
m->outBufferIDs[outIndex] = outBufferID;

return (True);
}	// ---- end SetModule_IOBuffers() ---- 
#endif

// ****************************************************************
// SetModule_InBuffer:	Specify buffer IDs for module inputs, only
//
//		Note:  If a module has no inputs, the bufferIDS for
//				for those connections will be ignored.
//
//						Return Boolean success
// **************************************************************** 
	int	
AUDIOFX::SetModule_InBuffer(long moduleID, int index, int bufferID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m ) //|| kAudioFxModule_DMA == m->typeID)
	return (False);

m->inBufferIDs[index] = bufferID;

return (True);
}	// ---- end SetModule_InBuffer() ---- 

// ****************************************************************
// SetModule_OutBuffer:	Specify buffer IDs for module outputs, only
//
//		Note:  If a module has no outputs, the bufferIDS for
//				for those connections will be ignored.
//
//						Return Boolean success
// **************************************************************** 
	int	
AUDIOFX::SetModule_OutBuffer(long moduleID, int index, int bufferID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m ) //|| kAudioFxModule_DMA == m->typeID)
	return (False);

m->outBufferIDs[index] = bufferID;

return (True);
}	// ---- end SetModule_OutBuffer() ---- 

// ****************************************************************
// TranslateModule_IOBufferIDs:	Convert input and output buffers IDs
//								to DSP addresses.
// **************************************************************** 
	void	
AUDIOFX::TranslateModule_IOBufferIDs(AUDIOFX_MODULE *d)
{
Int24 *ioAddresses = (Int24 *) d->data.smallState;

// Format {all inputs, all outputs}
for (int i = 0; i < d->ioCount; i++)
	{
	ioAddresses[i             ] = BufferIDToDSPAddress(d->inBufferIDs [i]);
	ioAddresses[i+d->ioCount/2] = BufferIDToDSPAddress(d->outBufferIDs[i]);
	}
}	// ---- end TranslateModule_IOBufferIDs() ----

// ****************************************************************
// BufferIDToDSPAddress:	Given buffers ID, return DSP addresses.
//		
//			In case of error, return (-1)
// **************************************************************** 
	Int24	
AUDIOFX::BufferIDToDSPAddress(Int24 id)
{
Int24 x = -1;

//  Deal with FX sources
// FIXXX: for now, using mix bins
switch (id)
	{
	case kAudioFX_BufferID_2DFxInputLeft:
		id = kGPMemory_MixBuffer00;
	break;
	case kAudioFX_BufferID_2DFxInputRight:
		id = kGPMemory_MixBuffer01;
	break;
	case kAudioFX_BufferID_2DFxOutputLeft:
		id = kGPMemory_MixBuffer00;
	break;
	case kAudioFX_BufferID_2DFxOutputRight:
		id = kGPMemory_MixBuffer01;
	break;

	case kAudioFX_BufferID_3DFxInputLeft:
		id = kGPMemory_MixBuffer02;
	break;
	case kAudioFX_BufferID_3DFxInputRight:
		id = kGPMemory_MixBuffer03;
	break;
	case kAudioFX_BufferID_3DFxOutputLeft:
	break;
	case kAudioFX_BufferID_3DFxOutputRight:
	break;

// FIXXXX: Only one global 2D->3D fx loopback 
	case kAudioFX_BufferID_2DLoopBackTo3D_Input0:
		id = kGPMemory_MixBuffer31;
	break;
	}

if (-1 != id)
	return (id);

// Next, temporary buffers
if (id >= kAudioFX_BufferID_Temp00 && id <= kAudioFX_BufferID_Temp07)
	x = kGPMemory_Base_TempBuffers + kFrameLength*(id-kAudioFX_BufferID_Temp00);

return (-1);
}	// ---- end BufferIDToDSPAddress() ---- 

// ****************************************************************
// SetModuleExecutionList:	Specify order of module execution.  If this
//						function is not called, the effects will be
//						executed in the order of their module IDs.
//
//			Return True if all modules were scheduled without error.
//
//						Return Boolean success (FIXXX: perhaps # of modules scheduled)
// **************************************************************** 
	int	
AUDIOFX::SetModuleExecutionList(long *moduleIDs, int count)
// moduleIDs		ptr to modules to be included in execution list
//					NULL value will construct an execution list of
//					all modules in increasing moduleID order.
{
if (!moduleIDs)
	{
// FIXXX: just add code.
	}

if (count > kAudioFx_MaxModules)
	return (False);

afxSystemMemCopy(executionList, moduleIDs, count*sizeof(long));
executionListLength = count;

return (True);
}	// ---- end SetModuleExecutionList() ---- 

// ****************************************************************
// AddModule:		Set up a new audio effect.  
//				Note: this function does not add this module to
//				the execution list.
//
//			Return module ID.  Return value of kAudioFxModule_EmptyID
//						indicates failure.
// **************************************************************** 
	int 
AUDIOFX::AddModule(char *typeName)
{
int		i;
AUDIOFX_MODULE *m      = NULL;
AUDIOFX_PLUGIN *plugIn = FindAudioFXPlugInByName(typeName);

// Search for plug-in as specified by typeID
if (!plugIn)
	{
	printf("AddModule: unable to find plug-in specified by '%s'.\n", typeName);
	return (-1);
	}

// Find an empty slot for the module.
for (i = 0; i < maxModules; i++)
	{
	m = &modules[i];
	if (kAudioFxModule_EmptyID == m->moduleID)
		break;
	}

// Uh oh . Unable to find a slot for the module.
if (i == maxModules)
	{
	printf("AddModule: out of module slots.\n");
	return (kAudioFxModule_EmptyID);
	}
InitModule(m);
m->parent = plugIn;

m->moduleID = moduleIDCounter++;
//printf("AddModule: added id=%d of type '%s'\n", m->moduleID, typeName);

return (m->moduleID);
}	// ---- end AddModule() ---- 

// ****************************************************************
// AddModule:		Set up a new audio effect.  
//				Note: this function does not add this module to
//				the execution list.
//
//			Return module ID.  Return value of kAudioFxModule_EmptyID
//						indicates failure.
// **************************************************************** 
	int 
AUDIOFX::AddModule(long typeID)
{
if (kAudioFxModuleTypeID_DMA <= typeID && typeID <= kAudioFxModuleTypeID_Reverb)
	return (AddModule(audioFxModuleTypeNames[typeID]));
else
	return (kAudioFxModuleTypeID_Invalid);
}	// ---- end AddModule() ---- 

#ifdef SAFE
// ****************************************************************
// Command:		Send command to one/all modules.
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::Command(long moduleID, int commandID, void *data)
{
switch (commandID)
	{
	case kDSPCommand_IgnoreMe:
	break;
	case kDSPCommand_StopDSPList:
	break;
	case kDSPCommand_StartDSPList:
	break;
	case kDSPCommand_LoadDSPModuleBlock:
	break;
	case kDSPCommand_LoadDSPCodeBlock:
	break;

	case kDSPCommand_ResetAllDSPModuleStates:
	break;
	case kDSPCommand_UpdateAllDSPModuleParameters:
	break;
	case kDSPCommand_PrepareAllDSPModules:
	break;

	case kDSPCommand_ResetOneDSPModuleState:
	break;
	case kDSPCommand_UpdateOneDSPModuleParameters:
	break;
	case kDSPCommand_PrepareOneDSPModule:
	break;
	default:
	return (False);
	}

return (True);
}	// ---- end Command() ---- 
#endif

// ****************************************************************
// QueryModule:		Inquire about module state
//
//						Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::QueryModule(long moduleID, int queryID)
{
return (True);
}	// ---- end QueryModule() ---- 

// ****************************************************************
// SetInputFIFOFormat:	Use this call to register actual
//						FIFO settings set by driver.  This
//						call will not reconfigure the FIFO hardware
//
//						Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::SetInputFIFOFormat(int index, int channelFormat, int classDataSize)
{
if (index >= kAudioFX_MaxInputFIFOs)
	return (False);

inputFIFOs[index].classDataSize = classDataSize;
inputFIFOs[index].channelFormat = channelFormat;

return (True);
}	// ---- end SetInputFIFOFormat() ---- 

// ****************************************************************
// SetOutputFIFOFormat:	Use this call to register actual
//						FIFO settings set by driver.  This
//						call will not reconfigure the FIFO hardware
//
//						Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::SetOutputFIFOFormat(int index, int channelFormat, int classDataSize)
{
if (index >= kAudioFX_MaxOutputFIFOs)
	return (False);

outputFIFOs[index].classDataSize = classDataSize;
outputFIFOs[index].channelFormat = channelFormat;

return (True);
}	// ---- end SetOutputFIFOFormat() ---- 

// ****************************************************************
// SetTopologyName:	used to set file names for generated binary outputs
//
// **************************************************************** 
	void 
AUDIOFX::SetTopologyName(char *s)
{
topologyName = s;
}	// ---- end SetTopologyName() ---- 

// ****************************************************************
// RegisterModuleType:		Install audio fx plug-in from system.
//
//		Note:  An FX type may not be reregistered.  This
//				function does not instantiate a module.
//
//			Return type ID
// **************************************************************** 
	int 
AUDIOFX::RegisterModuleType(AUDIOFX_PLUGIN *d)
{
long i;

// Don't register if it already exists
if (FindAudioFXPlugInByName(d->name))
	{
	printf("RegisterModuleType: unable to find space for plugin '%s'\n", d->name);
	return (True);
	}

// Find an empty slot
for (i = 0; i < kAudioFxModule_MaxTypes; i++)
	{
	if (kAudioFxModuleTypeID_Null == plugIns[i].typeID)
		break;
	}
if (kAudioFxModule_MaxTypes == i)
	{
	printf("RegisterModuleType: unable to find space for plugin %d\n", d->typeID);
	return (False);
	}

// Copy plugin data
memcpy(&plugIns[i], d, sizeof(AUDIOFX_PLUGIN));
plugIns[i].typeID = typeIDCounter++;
//printf("RegisterModuleType: %d plugIn name='%s' typeID=%d\n", i, plugIns[i].name, plugIns[i].typeID);

return (plugIns[i].typeID);
}	// ---- end RegisterModuleType() ---- 

// ****************************************************************
// UnregisterModuleType:	Remove audio fx plug-in from system.
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::UnregisterModuleType(long typeID)
{
int	i;

// Don't unregister if it doesn't exist
AUDIOFX_PLUGIN *thisPlugin = FindAudioFXPlugInByID(typeID);
if (!thisPlugin)
	return (False);

// Remove all instances of this type from the module list
for (i = 0; i < maxModules; i++)
	{
	if (modules[i].parent == thisPlugin)
		InitModule(&modules[i]);
	}

// Clear plug-in entry
InitPlugIn(thisPlugin);

return (True);
}	// ---- end UnregisterModuleType() ---- 

// ****************************************************************
// DeleteModule:	Delete specified module instance
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::DeleteModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m)
	return (False);

m->moduleID = kAudioFxModule_EmptyID;

// Remove module from execution list before state memory is
// deallocated 


// Deallocate state block

// FIXXX: add signal to update DSP state and code blocks.

return (True);
}	// ---- end DeleteModule() ---- 

// ****************************************************************
// DefaultModule:		Set default parameters to specified effect
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::DefaultModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m)
	return (False);
(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Default].function)(&m->data);

return (True);
}	// ---- end DefaultModule() ---- 

// ****************************************************************
// ResetModule:	Reset large and small parameter smallState
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::ResetModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m)
	return (False);
(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Reset].function)(&m->data);

return (True);
}	// ---- end ResetModule() ---- 

// ****************************************************************
// UpdateModule:		Update parameter values
//					Note:  Update() does not reset the module
//								unless the parameters require 
//								a Reset.
//
//			Returns Boolean indication that a Reset() is needed.
// **************************************************************** 
	int 
AUDIOFX::UpdateModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
int resetNeeded = False;
if (!m)
	return (False);

// Convert buffer IDs to DSP memory IDs
TranslateModule_IOBufferIDs(m);

(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Update].function)(&m->data);

return (resetNeeded);
}	// ---- end UpdateModule() ---- 

// ****************************************************************
// PrepareModule:		Update + Reset
//
//					Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::PrepareModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m)
	return (False);

if (m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Prepare].function)
	(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Prepare].function)(&m->data);
else
	{
	(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Update].function)(&m->data);
	(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Reset ].function)(&m->data);
	}

return (True);
}	// ---- end PrepareModule() ---- 

// ****************************************************************
// SetModule:		Set high level  (usually DirectX parameters), 
//					but do not process	parameters with Update() call.
//
//					Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::SetModule(long moduleID, void *data)
// data		ptr to DX8 parameter structure
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
if (!m)
	return (False);

// Copy parameter data
Int24 *localData = (Int24 *) m->data.moduleData;
afxSystemMemCopy(localData, data, m->parent->moduleStructSize);

return (True);
}	// ---- end SetModule() ---- 

// ****************************************************************
// GetModule:		Retrieve high level parameters
//
//					Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::GetModule(long moduleID, void *data)
// parameterData		ptr to DX8 parameter structure
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
if (!m)
	return (False);

// Copy parameter data
Int24 *localData = (Int24 *) m->data.moduleData;
afxSystemMemCopy(data, localData, m->parent->moduleStructSize);

return (True);
}	// ---- end GetModule() ---- 

// ****************************************************************
// GetModuleAFXParametersPtr:	Return ptr to AFX (high+low level) parameters
//
//					Return Boolean success
// **************************************************************** 
	AFX_PARAMETERS * 
AUDIOFX::GetModuleAFXParametersPtr(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
if (!m)
	return (False);

return (&m->data);
}	// ---- end GetModuleAFXParametersPtr() ---- 

// ****************************************************************
// GetModuleParameterPtr:		Return ptr high level parameters
//
// **************************************************************** 
	void * 
AUDIOFX::GetModuleParameterPtr(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
if (!m)
	return (False);
return (m->data.moduleData);
}	// ---- end GetModuleParameterPtr() ---- 

// ****************************************************************
// InitModule:		
// **************************************************************** 
	void
AUDIOFX::InitModule(AUDIOFX_MODULE *d)
{
int i;

for (i = 0; i < kAudioFX_MaxInputs; i++)
	d->inBufferIDs [i] = kAudioFX_BufferID_MixBuf00;
for (i = 0; i < kAudioFX_MaxOutputs; i++)
	d->outBufferIDs[i] = kAudioFX_BufferID_MixBuf00;

d->ioCount = 1;
d->parent  = NULL;

//d->data.parameters     = d->parameters;
//d->data.smallState     = d->smallState;
d->data.largeState     = 0;
d->data.largeStateSize = 0;
}	// ---- end InitModule() ---- 

// ****************************************************************
// InitPlugIn:		
// **************************************************************** 
	void
AUDIOFX::InitPlugIn(AUDIOFX_PLUGIN *d)
{
int i;

d->maxInputs  = 1;
d->maxOutputs = 1;
d->name       = NULL;
d->typeID     = kAudioFxModuleTypeID_Null;

d->moduleStructSize = 0;
d->smallStateSize   = 0;

for (i = 0; i < kAudioFX_PlugIn_Function_BaseCount; i++)
	{
	d->functionIDList[i].id       = kAudioFX_PlugIn_FunctionID_Null;
	d->functionIDList[i].function = 0;
	}
}	// ---- end InitPlugIn() ---- 

// ****************************************************************
// Update:	Assemble and download DSP code and state blocks
//
//					Return Boolean success
// **************************************************************** 
	int
AUDIOFX::Update()
{
char s[500];
if (!topologyName)
	topologyName = "out";

DefaultCommandNode(&dspCommandNode);

//sprintf(s, "%s.code", topologyName);
//if (!AssembleDSPCodeBlock(s))
//	{
//	printf("Update:  AssembleDSPCodeBlock() failed\n");
//	return (False);
//	}
dspCommandNode.dspModuleCodeBlock     = (Int24) dspCodeBlock;
dspCommandNode.dspModuleCodeBlockSize = dspCodeBlockSize;
// dspCommandNode.commandID |= kDSPCommandID_LoadDSPBlock_Code;

if (topologyName)
	{
	// All of this to get past lack of sprintf() in Resman.
	strcpy(s, "ms_");
	strcat(s, topologyName);
	strcat(s, ".dat");
//	sprintf(s, "ms_%s.dat", topologyName);
	}
else
	strcpy(s, "ms.dat");
if (!AssembleDSPStateBlock(s))
	{
	printf("Update:  AssembleDSPStateBlock() failed\n");
	return (False);
	}
dspCommandNode.moduleCount         = executionListLength;
dspCommandNode.dspModuleBlock      = (Int24) dspModuleBlock;
dspCommandNode.dspModuleBlockSize  = executionListLength*kDSPMODULE_Words;
dspCommandNode.commandID          |= kDSPCommandID_LoadDSPBlock_ModuleList;

dspCommandNode.dspModuleStateBlock     = (Int24) dspStateBlock;
dspCommandNode.dspModuleStateBlockSize = dspStateBlockSize;
dspCommandNode.commandID              |= kDSPCommandID_LoadDSPBlock_State;

// FIXXXX: add code to transfer blocks to System Memory
{
}

// Create DSP command node
{
dspCommandNode.dspModuleBlock     = 2;
dspCommandNode.dspModuleBlockSize = 2;


#ifdef AUDIOFX_STANDALONE
WriteWordsToFile("CommandNode.dat", (Int24 *) &dspCommandNode, sizeof(DSPCOMMANDNODE)/sizeof(Int24));
#else
#endif
}

return (True);
}	// ---- end Update() ---- 

// ****************************************************************
// AssembleDSPCodeBlock:	Concatenate DSP code blocks for
//							all modules included in the execution list.
//							Beginning of block is the list of common
//							routines.  Be sure to link any DSP code
//							functions.
//
//							This function will also fill in the
//							'state' and 'typeID' fields in the
//							DSPModuleBlock.
//
//					Return Boolean success
// **************************************************************** 
	int
AUDIOFX::AssembleDSPCodeBlock(char *filePath)
{
int i, j;
DSPMODULE *modulePtr  = (DSPMODULE *) dspModuleBlock;
Int24      blockIndex = 0;
long	   blockSize  = 0;
long	   computeRoutineAddress[kAudioFxModule_MaxTypes];	
AUDIOFX_MODULE *moduleList[kAudioFx_MaxModules];
AUDIOFX_MODULE *m;

// Setup 
#define kAudioFx_InvalidComputeRoutineAddress	(-1)
for (i = 0; i < kAudioFxModule_MaxTypes; i++)
	computeRoutineAddress[i] = kAudioFx_InvalidComputeRoutineAddress;

// First, calculate size of block.
blockSize = dspCommonRoutinesSize;
for (i = 0; i < executionListLength; i++)
	{
	m = FindAudioFXModule(executionList[i]);
// Failure !  The execution list specifies an invalid module.
	if (!m)
		return (False);
	moduleList[i] = m;
	blockSize += m->parent->dspComputeRoutineSize;
	}

// Allocate new block
if (dspCodeBlock)
        afxSystemMemFree(dspCodeBlock);
dspCodeBlock     = (Int24 *) afxSystemMemAlloc(sizeof(Int24)*blockSize);
dspCodeBlockSize = blockSize;

// Copy module info to new block
#ifdef AUDIOFX_STANDALONE
afxSystemMemCopy(dspCodeBlock, (void *) dspCommonRoutines, sizeof(Int24)*dspCommonRoutinesSize);
#else
afxScratchMemWrite((U032)dspCodeBlock, (void *) dspCommonRoutines, sizeof(Int24)*dspCommonRoutinesSize);
#endif

blockIndex += dspCommonRoutinesSize;
for (i = 0; i < executionListLength; i++)
	{
	m = moduleList[i];

// Add code to block if it doesn't yet exist
	if (kAudioFx_InvalidComputeRoutineAddress == computeRoutineAddress[0])
		{
#ifdef AUDIOFX_STANDALONE
		afxScratchMemCopy(dspCodeBlock+blockIndex, (void *) m->parent->dspComputeRoutine, sizeof(Int24)*m->parent->dspComputeRoutineSize);
#else
		afxScratchMemWrite((U032)(dspCodeBlock+blockIndex), (void *) m->parent->dspComputeRoutine, sizeof(Int24)*m->parent->dspComputeRoutineSize);
#endif
//		computeRoutineAddress[m->typeID] = blockIndex;

//		blockIndex += dspComputeRoutineSizes[m->typeID];
		}

// Assign FX pins (bufferIDs) to DSP addresses.  Process IO pairs
//			because that is the format expected by the DSP.
// Output address in format {all inputs, all outputs}
	for (j = 0; j < m->ioCount/2; j++)
		m->data.smallState[j] = BufferIDToDSPAddress(m->inBufferIDs[j]);

	for (     ; j < m->ioCount; j++)
		m->data.smallState[j] = BufferIDToDSPAddress(m->outBufferIDs[j]);

// Fill in 'compute' and 'typeID' fields in DSPModuleBlock.  Don't touch 'state' field.
//	modulePtr->compute = m->parent->dspComputeRoutine;
	modulePtr->typeID  = m->parent->typeID;
	modulePtr         += sizeof(DSPMODULE);
	}

WriteWordsToFile("DspCode.bin", dspStateBlock, blockIndex+1);

return (True);
}	// ---- end AssembleDSPCodeBlock() ---- 

// ****************************************************************
// AssembleDSPStateBlock:	Concatenate small state blocks for
//							all modules included in the execution list.
//							This function will allocate the correct 
//							block size.
//
//							This function will also fill in the
//							'state' and 'typeID' fields in the
//							DSPModuleBlock.
//
//		The DSP state block will reside in DSP X/YRAM
//
//					Return # words in state block, 0 on failure
// **************************************************************** 
	int
AUDIOFX::AssembleDSPStateBlock(char *filePath)
{
int i, j;
DSPMODULE *modulePtr  = (DSPMODULE *) dspModuleBlock;
Int24      blockIndex = 0;
long	   blockSize  = 0;
AUDIOFX_MODULE *moduleList[kAudioFx_MaxModules];
AUDIOFX_MODULE *m;
int byteSwap = True;

//printf("AssembleDSPStateBlock to '%s'\n", filePath);

// First, calculate size of block.
for (i = 0; i < executionListLength; i++)
	{
	m = FindAudioFXModule(executionList[i]);
// Failure !  The execution list specifies an invalid module.
	if (!m)
		{
		printf("AssembleDSPStateBlock: module %d not found\n", executionList[i]);
		return (0);
		}
	AUDIOFX_PLUGIN *plugIn = m->parent;

	moduleList[i] = m;
	blockSize += plugIn->smallStateSize;
	}

// Allocate new block
if (dspStateBlock)
      afxSystemMemFree(dspStateBlock);
dspStateBlock = (Int24 *) afxSystemMemAlloc(blockSize*sizeof(Int24));
if (!dspStateBlock)
	{
	printf("AssembleDSPStateBlock: unable to allocate new state block\n");
	return (0);
	}
dspStateBlockSize = blockSize;

//printf("AssembleDSPStateBlock: dspStateBlock=%d size=%d\n", dspStateBlock, dspStateBlockSize);

// Copy module info to new block
for (i = 0; i < executionListLength; i++)
	{
	m = moduleList[i];
	AUDIOFX_PLUGIN *plugIn = m->parent;
	if (plugIn)
		{
		Int24 *bPtr = dspStateBlock+blockIndex;
#ifdef AUDIOFX_STANDALONE
	    afxScratchMemCopy(dspStateBlock+blockIndex, (void *) m->data.smallState, sizeof(Int24)*plugIn->smallStateSize);
#else
		afxScratchMemWrite((U032)(dspStateBlock+blockIndex), (void *) m->data.smallState, sizeof(Int24)*plugIn->smallStateSize);
#endif

	// Fill connection information  (All inputs, followed by outputs)
		for (j = 0; j < plugIn->maxInputs; j++)
			*bPtr++ = BufferIDToDSPAddress(m->inBufferIDs[j]);	
		for (j = 0; j < plugIn->maxOutputs; j++)
			*bPtr++ = BufferIDToDSPAddress(m->outBufferIDs[j]);	
		*bPtr++ = kFrameLength;

	// Update DSP Module in execution list
	   blockIndex += plugIn->smallStateSize;
//printf("AssembleDSPStateBlock %2d: moduleID=%2d, typeID=%2d (%s), stateSize=%2d\n",
//	   i, m->moduleID, plugIn->typeID, plugIn->name, plugIn->smallStateSize);
	// Fill in 'state' and 'typeID' fields in DSPModuleBlock. 
		modulePtr->state  = blockIndex;
		modulePtr->typeID = plugIn->typeID;
		modulePtr        += sizeof(DSPMODULE);
		}
	}

// Blast to file
#ifdef AUDIOFX_STANDALONE
{
FILE *h = fopen(filePath, "w+b");
if (NULL == h)
	{
    printf("AssembleDSPStateBlock: unable to open file '%s'\n", filePath);
    return (0);
	}

// Shuffle bytes to write packed 24 bit words
unsigned char *a = (unsigned char *) dspStateBlock;
unsigned char *b = (unsigned char *) dspStateBlock;
if (byteSwap)
	{
	ByteSwapBuf32((long *)dspStateBlock, dspStateBlockSize);
	for (int i = 0; i < dspStateBlockSize; i++, a += 3, b += 4)
		{
		a[0] = b[1];
		a[1] = b[2];
		a[2] = b[3];
		}
	}
else
	{
	for (int i = 0; i < dspStateBlockSize; i++, a += 3, b += 4)
		{
		a[0] = b[0];
		a[1] = b[1];
		a[2] = b[2];
		}
	}

long bytesToWrite = (3*sizeof(Int24)*dspStateBlockSize)/4;
long bytesWritten = fwrite(dspStateBlock, sizeof(char), bytesToWrite, h);
//printf("AssembleDSPStateBlock: wrote %d words (%d bytes) to '%s'\n", 
//	   dspStateBlockSize, bytesWritten, filePath);
fclose(h);
}
#endif

return (dspStateBlockSize);
}	// ---- end AssembleDSPStateBlock() ---- 

// ****************************************************************
// FindAudioFXModule:	 Return ptr to module with specified ID	
// **************************************************************** 
	AUDIOFX_MODULE *
AUDIOFX::FindAudioFXModule(long moduleID)
{
// Scan array for particular module
for (int i = 0; i < maxModules; i++)
	{
	if (moduleID == modules[i].moduleID)
		return (&modules[i]);
	}

return (NULL);
}	// ---- end FindAudioFXModule() ---- 

// ****************************************************************
// FindAudioFXPlugInByID:	 Return ptr to plug-in with specified ID	
// **************************************************************** 
	AUDIOFX_PLUGIN *
AUDIOFX::FindAudioFXPlugInByID(long typeID)
{
// Scan array for particular module
for (int i = 0; i < kAudioFxModule_MaxTypes; i++)
	{
	if (typeID == plugIns[i].typeID)
		return (&plugIns[i]);
	}

return (NULL);
}	// ---- end FindAudioFXPlugInByID() ---- 

// ****************************************************************
// FindAudioFXPlugInByName:	 Return ptr to plug-in with specified name	
// **************************************************************** 
	AUDIOFX_PLUGIN *
AUDIOFX::FindAudioFXPlugInByName(char *name)
{
// Scan array for particular module
for (long i = 0; i < kAudioFxModule_MaxTypes; i++)
	{
	if (plugIns[i].name)
		{
		if(!strcmp(name, plugIns[i].name))
			return (&plugIns[i]);
		}
	}

return (NULL);
}	// ---- end FindAudioFXPlugInByName() ---- 

// **************************************************************** 
// WriteWordsToFile:	 Write array of Int24's to specified file
//
//					Return words written	
// **************************************************************** 
	long
AUDIOFX::WriteWordsToFile(char *filePath, Int24 *data, long count)
{
#ifdef AUDIOFX_STANDALONE
FILE *h = fopen(filePath, "w+b");
if (!h)
	{
	printf("WriteWordsToFile: failed to create '%s'\n", filePath);
	return (False);
	}

// Blast data (swap bytes!) to specified file
long wordsWritten = fwrite( data, sizeof(Int24), count, h );
if (wordsWritten != count)
	{
	printf("WriteWordsToFile: short write of %d/%d to '%s'\n",
				wordsWritten, count, filePath);
	fclose(h);
	return (False);
	}

//printf("WriteWordsToFile: wrote %d words to '%s'\n", wordsWritten, filePath);

fclose(h);
return (wordsWritten);
#else
return (0);
#endif
}	// ---- end WriteWordsToFile() ---- 

// **************************************************************** 
// FxTypeIDToName:	 Return ptr to effect name string
//
// **************************************************************** 
	char *
AUDIOFX::FxTypeIDToName(long typeID)
{
AUDIOFX_PLUGIN *plugIn = FindAudioFXPlugInByID(typeID);
if (!plugIn)
	{
	printf("FxTypeIDToName: unable to find plugIn type=%d\n", typeID);
	return (0);
	}

return (plugIn->name);
}	// ---- end FxTypeIDToName() ---- 

// **************************************************************** 
// FxParameterSize:	 Return size of high-level (often DirectX8) structure
//
// **************************************************************** 
	long
AUDIOFX::FxParameterSize(long typeID)
{
AUDIOFX_PLUGIN *plugIn = FindAudioFXPlugInByID(typeID);
if (!plugIn)
	{
	printf("FxParameterSize: unable to find plugIn type=%d\n", typeID);
	return (0);
	}

return (plugIn->moduleStructSize);

return (0);
}	// ---- end FxParameterSize() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\AudioFx.h ===
// *************************************************************************
//
//	AudioFx.h		Support functions for DSP System memory operations
//
//	Written by Gints Klimanis, 2000
//
// *************************************************************************
//
#ifndef __AUDIOFX_H__
#define	__AUDIOFX_H__

#include "DSP_Util.h"
#include "AudioFxDef.h"

#ifndef AUDIOFX_STANDALONE
#include "AudioHw.h"
#endif

// ==============================================================
// Global Processor DSP Address Map 
// ==============================================================
// Relative to GPBase (24 bit words (3 bytes) in 32-bit containers (4 bytes))
//     0x0000 - 0x1FFC   GP DSP X-Memory 4K Words (24 lsbits of Dword)     
//     0x4000 - 0x5FFC   GP DSP Y-Memory 2K Words (24 lsbits of Dword) 
//     0x8000 - 0x8FFC   GP DSP P-Memory 4K Words (24 lsbits of Dword) 
//     0xFE00 - 0xFFF0   GP DSP Peripheral Registers
//     0xFFFC            GP DSP Reset
//
// Peripheral registers (Control,Status) mapped to upper 128 words
// of X-memory (0xFFFF80 to 0xFFFFFF) so they can be accessed with movep 
//
// GP DSP memory addresses 24-bit words
// System memory address    8-bit words 

#define kGPMemory_Base		 0x000000
#define kGPMemory_Base_XRAM	(kGPMemory_Base+0x000000)
#define kGPMemory_Base_YRAM	(kGPMemory_Base+0x001800)
#define kGPMemory_Base_PRAM	(kGPMemory_Base+0x002000)

#define kGPMemory_Size_XRAM	3*1024
#define kGPMemory_Size_YRAM	2*1024
#define kGPMemory_Size_PRAM	4*1024

// MixBuffers 0x1400 through 0x17ff  Two banks of 32 Mixbuffers of 32 words each
//	2 banks x 32 Buffers/bank x 32 words/buffer = 2048 ($1000) words
#define kMixBufferSize		kFrameLength
#define kMixBufferLength	kFrameLength

#define kGPMemory_Base_MixBuffers	0x001400	
#define kGPMemory_Base_TempBuffers	0x0	

// Buffer IDs used to connect effects modules
#define kAudioFX_BufferID_2DFxInputLeft		100		// left  channel from two channel FX input
#define kAudioFX_BufferID_2DFxInputRight	101		// right channel from two channel FX input
#define kAudioFX_BufferID_2DFxOutputLeft	102		// to left  front channel output
#define kAudioFX_BufferID_2DFxOutputRight	103		// to right front channel output

#define kAudioFX_BufferID_3DFxInputLeft		110		// left  channel from two channel I3DL2 input
#define kAudioFX_BufferID_3DFxInputRight	111		// right channel from two channel I3DL2 input
#define kAudioFX_BufferID_3DFxOutputLeft	112		// two front channels to front X-talk box
#define kAudioFX_BufferID_3DFxOutputRight	113		// two rear channels  to rear  X-talk box

#define kAudioFX_BufferID_Null		150				// Used to indicate an idle connection

#define kAudioFX_BufferID_Temp00	200		
#define kAudioFX_BufferID_Temp01	201	
#define kAudioFX_BufferID_Temp02	202	
#define kAudioFX_BufferID_Temp03	203	
#define kAudioFX_BufferID_Temp04	204	
#define kAudioFX_BufferID_Temp05	205	
#define kAudioFX_BufferID_Temp06	206	
#define kAudioFX_BufferID_Temp07	207	

#define kAudioFX_BufferID_FinalMix_Input	300		// Future use:   connect to all pins
#define kAudioFX_BufferID_FinalMix_Pin0		301
#define kAudioFX_BufferID_FinalMix_Pin1		302
#define kAudioFX_BufferID_FinalMix_Pin2		303
#define kAudioFX_BufferID_FinalMix_Pin3		304
#define kAudioFX_BufferID_FinalMix_Pin4		305
#define kAudioFX_BufferID_FinalMix_Pin5		306

// DO NOT change the values!!  it'll break NV_AUDGP_ROUTE_TO_FIFO - (CGpMethod.cpp)
#define kAudioFX_BufferID_FIFO0_Input		300		// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO0_Input_Pin0	301
#define kAudioFX_BufferID_FIFO0_Input_Pin1	302
#define kAudioFX_BufferID_FIFO0_Input_Pin2	303
#define kAudioFX_BufferID_FIFO0_Input_Pin3	304
#define kAudioFX_BufferID_FIFO0_Input_Pin4	305
#define kAudioFX_BufferID_FIFO0_Input_Pin5	306

#define kAudioFX_BufferID_FIFO1_Input		310	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO1_Input_Pin0	311
#define kAudioFX_BufferID_FIFO1_Input_Pin1	312
#define kAudioFX_BufferID_FIFO1_Input_Pin2	313
#define kAudioFX_BufferID_FIFO1_Input_Pin3	314
#define kAudioFX_BufferID_FIFO1_Input_Pin4	315
#define kAudioFX_BufferID_FIFO1_Input_Pin5	316

#define kAudioFX_BufferID_FIFO0_Output		320	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO0_Output_Pin0	321
#define kAudioFX_BufferID_FIFO0_Output_Pin1	322
#define kAudioFX_BufferID_FIFO0_Output_Pin2	323
#define kAudioFX_BufferID_FIFO0_Output_Pin3	324
#define kAudioFX_BufferID_FIFO0_Output_Pin4	325
#define kAudioFX_BufferID_FIFO0_Output_Pin5	326

#define kAudioFX_BufferID_FIFO1_Output		330	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO1_Output_Pin0	331
#define kAudioFX_BufferID_FIFO1_Output_Pin1	332
#define kAudioFX_BufferID_FIFO1_Output_Pin2	333
#define kAudioFX_BufferID_FIFO1_Output_Pin3	334
#define kAudioFX_BufferID_FIFO1_Output_Pin4	335
#define kAudioFX_BufferID_FIFO1_Output_Pin5	336

#define kAudioFX_BufferID_FIFO2_Output		340	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO2_Output_Pin0	341
#define kAudioFX_BufferID_FIFO2_Output_Pin1	342
#define kAudioFX_BufferID_FIFO2_Output_Pin2	343
#define kAudioFX_BufferID_FIFO2_Output_Pin3	344
#define kAudioFX_BufferID_FIFO2_Output_Pin4	345
#define kAudioFX_BufferID_FIFO2_Output_Pin5	346

#define kAudioFX_BufferID_FIFO3_Output		350	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO3_Output_Pin0	351
#define kAudioFX_BufferID_FIFO3_Output_Pin1	352
#define kAudioFX_BufferID_FIFO3_Output_Pin2	353
#define kAudioFX_BufferID_FIFO3_Output_Pin3	354
#define kAudioFX_BufferID_FIFO3_Output_Pin4	355
#define kAudioFX_BufferID_FIFO3_Output_Pin5	356

#define kAudioFX_BufferID_2DLoopBackTo3D_Input0		120		// FIXXX: not done:Will probably be dynamic.
//#define kAudioFX_BufferID_2DLoopBackTo3D_Output0	121		

#define kAudioFX_Pin0	0
#define kAudioFX_Pin1	1
#define kAudioFX_Pin2	2
#define kAudioFX_Pin3	3
#define kAudioFX_Pin4	4
#define kAudioFX_Pin5	5

#define kAudioFX_PinLeft	kAudioFX_Pin0
#define kAudioFX_PinRight	kAudioFX_Pin1

// ****************************************************************
//  AudioFX:  the master system that manages audio fx modules and
//				assembles the memory blocks downloaded to the DSP
// ****************************************************************
// The first three memory block sizes are known before CreateAudioFX()
// The large state block size is calculated from parameter sets
#define kAudioFX_Memory_DspCodeBlock		0
#define kAudioFX_Memory_DspModuleBlock		1
#define kAudioFX_Memory_DspStateBlock		2
#define kAudioFX_Memory_DspLargeStateBlock	3		

#define kAudioFX_AllModules	(-1)

class CScratchDma;

class AUDIOFX {
public:
	AUDIOFX(long maxModules, CScratchDma *pDma);		
	~AUDIOFX(); 

// NV_AUDGP_ENABLE_EFFECT
//	To to disable an effect without deleting it:
//	1) Exclude from execution list
//	2) Disconnect inputs and outputs
	int	SetModuleExecutionList(long *moduleIDs, int count);

// ---- Module Functions
// When moduleID=kAudioFX_AllModules, apply to all modules
    // NV_AUDGP_ADD_EFFECT
    // RegisterModuleType() will return a unique typeID
	int AddModule	  (long  typeID);
	int AddModule	  (char *typeName);

    // NV_AUDGP_DELETE_EFFECT
	int DeleteModule (long moduleID);
	
// NV_AUDGP_SET_EFFECT_PARAMETERS
// The module will know the size of parameterData
// Will delay memory be allocated here?
	int SetModule    (long moduleID, void *parameterData);
	int GetModule    (long moduleID, void *parameterData);
	void *GetModuleParameterPtr(long moduleID);
	AFX_PARAMETERS *GetModuleAFXParametersPtr(long moduleID);
    /*
    NV_AUDGP_ROUTE_EFFECT
    shouldn't there be a pin # - like an outindex from the effect?
		Developers will know an effect's input and output count beforehand.
    buffer ID?  we need to make the RM do the resource management.. also is there a diff
    between the SW buffers, and HW buffers?
GK>> What kind of difference?  Right now, there isn't a difference.  
    */
//	int	SetModule_IOBuffers(long moduleID, int  inIndex, int  inBufferID, int outIndex, int outBufferID);
	int	SetModule_InBuffer (long moduleID, int  inIndex, int  inBufferID);
	int	SetModule_OutBuffer(long moduleID, int outIndex, int outBufferID);

	int SetInputFIFOFormat (int index, int channelFormat, int classDataSize);
	int SetOutputFIFOFormat(int index, int channelFormat, int classDataSize);

    // NV_AUDGP_REGISTER_EFFECT
    //the AUDIOFX_PLUGIN structure has to be shared between the driver and the RM
	int RegisterModuleType  (AUDIOFX_PLUGIN *data);

    // NV_AUDGP_DEREGISTER_EFFECT  
	int UnregisterModuleType(long typeID);

    /* NV_AUDGP_QUERY_EFFECT define query ID for the driver.*/
	int Command		 (long moduleID, int commandID, void *data);
	int QueryModule  (long moduleID, int queryID);

// Debug for now
	int  Update();
	void SetTopologyName(char *s);

	int DefaultModule(long moduleID);
	int ResetModule  (long moduleID);
	int UpdateModule (long moduleID);
	int PrepareModule(long moduleID);

private:

	char *audioFxModuleTypeNames[kAudioFxModule_MaxTypes];
	DSPCOMMANDNODE dspCommandNode;

// System Memory block pointers (address offsets from GPSADDR)
//	Int24 *dspCommandNode;
	Int24 *dspCodeBlock;		// DSP PRAM Code block
	Int24 *dspModuleBlock;		// DSP XRAM Execution List
	Int24 *dspStateBlock;		// DSP X/YRAM, includes command node
//	Int24 dspLargeStateBlock;   // System Memory state: delay lines, etc.

// Scratch memory address offsets
	Int24 smDspCommandNode;
	Int24 smDspCodeBlock;		
	Int24 smDspModuleBlock;		
	Int24 smDspStateBlock;		

// Allocated size, in Int24 words
//	long dspCommandNodeSize;
	long dspCodeBlockSize;		
	long dspModuleSize;
	long dspStateBlockSize;
//	long dspLargeStateBlockSize;

#define kAudioFX_MaxInputFIFOs	2
#define kAudioFX_MaxOutputFIFOs	4
	FIFO_INFO	inputFIFOs [kAudioFX_MaxInputFIFOs ];
	FIFO_INFO	outputFIFOs[kAudioFX_MaxOutputFIFOs];

// FX registry 
	AUDIOFX_PLUGIN plugIns[kAudioFxModule_MaxTypes];	// [0.. kAudioFxModule_MaxTypes]
	long	plugInCount;
	long	typeIDCounter;	// Incremented every time a new module is added

// Module lists
	AUDIOFX_MODULE	modules[kAudioFx_MaxModules];
	long	moduleCount;
	long	maxModules;

	long	moduleIDCounter;	// Incremented every time a new module is added
	long	executionList[kAudioFx_MaxModules];	// Array of module IDs
	long	executionListLength;
	char	*topologyName;

// DSP code & state data info
	Int24 *dspComputeRoutines    [kAudioFxModule_MaxTypes];	
	long   dspComputeRoutineSizes[kAudioFxModule_MaxTypes];	// in Int24 words
	Int24 *dspCommonRoutines;
	long   dspCommonRoutinesSize;

	void InitModule(AUDIOFX_MODULE *d);
	void InitPlugIn(AUDIOFX_PLUGIN *d);

	int  AssembleDSPCodeBlock  (char *filePath);
	int  AssembleDSPStateBlock (char *filePath);
	void TranslateModule_IOBufferIDs(AUDIOFX_MODULE *d);
	Int24 BufferIDToDSPAddress(Int24 id);

	AUDIOFX_MODULE *FindAudioFXModule(long moduleID);
	AUDIOFX_PLUGIN *FindAudioFXPlugInByID  (long typeID);
	AUDIOFX_PLUGIN *FindAudioFXPlugInByName(char *name );

	long WriteWordsToFile(char *filePath, Int24 *data, long count);
	char *FxTypeIDToName (long id);
	long  FxParameterSize(long typeID);
} ;



#endif  //	__AUDIOFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CVPMethod.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CVPMethod.h                                                       *
*     SW functions for Voice Processor class (PIO based)                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CVPETHODH_
#define _CVPETHODH_

#define METHOD_MIN_OFFSET(x)       (x)
#define METHOD_MAX_OFFSET(x)       ((x) + 0x4)

class CHalBase;
class CHalVoiceProc;
class CHalGlobalProc;

class CVPMethod
{
public:
    CVPMethod(CHalVoiceProc *pProc, CHalGlobalProc *pGlProc, CHalBase *pHal) 
    { 
        m_pHal = pHal;
        m_pVoiceProc = pProc;
        m_pGlobalProc = pGlProc;
    };

    ~CVPMethod() { };

public:
    VOID Execute(U032 uOffset, U032 uData);

private:
    CHalBase        *m_pHal;
    CHalVoiceProc   *m_pVoiceProc;
    CHalGlobalProc  *m_pGlobalProc;

    // utility
    BOOL CheckRange(U032 uOffset, U032 uMethodOffset)   
    { 
        return ((uOffset >= METHOD_MIN_OFFSET(uMethodOffset)) && 
                (uOffset < METHOD_MAX_OFFSET(uMethodOffset))?TRUE:FALSE);
    }

    // software methods
    RM_STATUS SetContextDMANotify(U032);
    RM_STATUS SetCurrentSSLContextDMA(U032);
    RM_STATUS SetCurrentInBufSGEContextDMA(U032);
    RM_STATUS SetCurrentOutBufSGEContextDMA(U032);

    // damn hacks!
    RM_STATUS SetGPState(U032);
    RM_STATUS SetXCNTMode(U032 uData);
    RM_STATUS SetCurrentOutBufSGEOffset(U032);
    RM_STATUS SetCurrentInBufSGEOffset(U032);
    RM_STATUS SetSSLSegmentOffset(U032);
    RM_STATUS SetSSLSegmentOffsetLength(U032, U032);
    RM_STATUS SetOutBufBA(U032, U032);
    RM_STATUS SetOutBufLen(U032, U032);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\DSP_Util.h ===
// *************************************************************************
//
//	DSP_Util.h		Support functions for DSP System memory operations
//
//	Written by Gints Klimanis
//
// *************************************************************************
//
#ifndef __DSP_UTIL_H__
#define	__DSP_UTIL_H__

#include "util.h"

#define kAudioFX_SMAddress_CommandNode		 9000
#define kAudioFX_SMAddress_ModuleBlock		 9500
#define kAudioFX_SMAddress_StateBlock		10000
#define kAudioFX_SMAddress_CodeBlock		12000

// ****************************************************************
// Command/Status for driver <-> DSP messaging.   This is done
//							every few frames by DMAing the system 
//							memory command block
// ****************************************************************
typedef struct dspcommandnode {
	Int24	stateID;		// Values: kDSPState ID's
	Int24	commandID;		// Values: kDSPCommand ID's
	Int24	moduleIndex;	// {0..N-1}, used only for commands that operate on 
							// a single module

	Int24	moduleCount;	// {0 .. kMaxDSPModules-1}

	Int24	dspModuleBlock;
	Int24	dspModuleStateBlock;
	Int24	dspModuleCodeBlock;

	Int24	dspModuleBlockSize;
	Int24	dspModuleStateBlockSize;
	Int24	dspModuleCodeBlockSize;

	Int24	misc1;
	Int24	misc2;
	Int24	misc3;

} DSPCOMMANDNODE;

void DefaultCommandNode(DSPCOMMANDNODE *d);

// Bit 0
#define kDSPCommandID_IgnoreMe						0x00
#define kDSPCommandID_CheckForCommand				0x01
// Bit 1
#define kDSPCommandID_StopDSPList					0x00
#define kDSPCommandID_RunDSPList					0x02
// Bit 4:2
#define kDSPCommandID_LoadDSPBlock_ModuleList		0x04
#define kDSPCommandID_LoadDSPBlock_Code				0x08
#define kDSPCommandID_LoadDSPBlock_State			0x10


// The following commands access parts of the State block
// Reset and Prepare will be the same if the DSP relies on the
// driver to do all of the high->low level parameter conversions
#define kDSPCommandID_ResetAllDSPModuleStates		5
#define kDSPCommandID_UpdateAllDSPModuleParameters	6
#define kDSPCommandID_PrepareAllDSPModules			7	// Prepare = Update + Reset

// For "Single" commands, include module index in command node
#define kDSPCommandID_ResetOneDSPModuleState		8	
#define kDSPCommandID_UpdateOneDSPModuleParameters	9	
#define kDSPCommandID_PrepareOneDSPModule			10	

// Debug Stuff
// misc1= RAM Word Address (0-based, not mapped address)
// misc2= # words
// misc2= SM Byte Address
#define kDSPCommandID_DumpXRAM		10		
#define kDSPCommandID_DumpYRAM		11	
#define kDSPCommandID_DumpPRAM		12	

// dspStateWord Bit 0 is waiting processing bit
#define kDSPStateID_WaitingBitCommandMask		0x1	// 1=waiting, 0=processing
#define kDSPStateID_ProcessingCommand			0x0	// 1=waiting, 0=processing
#define kDSPStateID_WaitingForCommand			0x1	// 1=waiting, 0=processing

// dspStateWord Bit 1 is running bit
#define kDSPStateID_ModuleListRunningBitMask	0x2	// 1=running, 0=stopped
#define kDSPStateID_ModuleListRunning			0x2	// 1=running, 0=stopped
#define kDSPStateID_ModuleListStopped			0x0	// 1=running, 0=stopped


// ****************************************************************
//  DSP Module block:  concatenation of DSPModule structures
// ****************************************************************

// Size of low-level data structure used by DSP Code
#define kDSPState_DMATransfer_Size	3	// DATA_SIZE_DMATRANSFER
#define kDSPState_Mixer_Size		3	// DATA_SIZE_MIXER
#define kDSPState_NullModule_Size	3	// DATA_SIZE_
#define kDSPState_Limiter_Size		3	// DATA_SIZE_LIMITER

#define kDSPState_AmpMod_Size		3	// DATA_SIZE_AMPMOD
#define kDSPState_Chorus_Size		3	// DATA_SIZE_CHORUS
#define kDSPState_Compressor_Size	3	// DATA_SIZE_COMPRESSOR
#define kDSPState_Delay_Size		3	// DATA_SIZE_DELAY
#define kDSPState_Distortion_Size	3	// DATA_SIZE_DISTORTION
#define kDSPState_Echo_Size			3	// DATA_SIZE_ECHO
#define kDSPState_Equalizer_Size	3	// DATA_SIZE_EQUALIZER
#define kDSPState_Flange_Size		3	// DATA_SIZE_FLANGE
#define kDSPState_IIR1_Size			3	// DATA_SIZE_IIR1
#define kDSPState_IIR2_Size			3	// DATA_SIZE_IIR2
#define kDSPState_IIIR_Size			3	// DATA_SIZE_IIIR
#define kDSPState_Oscillator_Size	3	// DATA_SIZE_OSCILLATOR
#define kDSPState_Reverb_Size		3	// DATA_SIZE_REVERB

// Low level data accessed by DSP
typedef struct { Int24	d[kDSPState_DMATransfer_Size]; } DSP_DMATRANSFER_STATE;
typedef struct { Int24	d[kDSPState_Mixer_Size      ]; } DSP_MIXER_STATE;
typedef struct { Int24	d[kDSPState_NullModule_Size ]; } DSP_NULLMODULE_STATE;
typedef struct { Int24	d[kDSPState_Limiter_Size    ]; } DSP_LIMITER_STATE;

typedef struct { Int24	d[kDSPState_AmpMod_Size     ]; } DSP_AMPMOD_STATE;
typedef struct { Int24	d[kDSPState_Chorus_Size     ]; } DSP_CHORUS_STATE;
typedef struct { Int24	d[kDSPState_Compressor_Size ]; } DSP_COMPRESSOR_STATE;
typedef struct { Int24	d[kDSPState_Delay_Size      ]; } DSP_DELAY_STATE;
typedef struct { Int24	d[kDSPState_Distortion_Size ]; } DSP_DISTORTION_STATE;
typedef struct { Int24	d[kDSPState_Echo_Size       ]; } DSP_ECHO_STATE;
typedef struct { Int24	d[kDSPState_Equalizer_Size  ]; } DSP_EQUALIZER_STATE;
typedef struct { Int24	d[kDSPState_Flange_Size     ]; } DSP_FLANGE_STATE;
typedef struct { Int24	d[kDSPState_IIR1_Size       ]; } DSP_IIR1_STATE;
typedef struct { Int24	d[kDSPState_IIR2_Size       ]; } DSP_IIR2_STATE;
typedef struct { Int24	d[kDSPState_IIIR_Size       ]; } DSP_IIIR_STATE;
typedef struct { Int24	d[kDSPState_Oscillator_Size ]; } DSP_OSCILLATOR_STATE;
typedef struct { Int24	d[kDSPState_Reverb_Size     ]; } DSP_REVERB_STATE;


// The DSP execution list is contructed of these modules
typedef struct dspmodule {
// Note:  Don't reorder these fields because DSP execution kernel
// expects the values in specific places.
	Int24	state;		// Low-level data, I/O ptrs are stored in state, In1Out1, In2/Out2, etc.
	Int24	compute;	// Ptr to compute routine in PRAM
	Int24   typeID;		// Algorithm/I/O type
}  DSPMODULE;

#define kDSPMODULE_Words	(sizeof(DSPMODULE)/sizeof(Int24))
void DefaultDSPModule  (DSPMODULE      *d);

// ****************************************************************
//  DSP Module state block:  concatenation of state structures,
//							excluding delay lines.  Reset command will
//							DMA this stuff into DSP XRAM and zero out
//							delay line memory.
//
//			(initial state given latest parameter set)
// ****************************************************************
#define kState_MaxSize	20		// in Int24 words

// ****************************************************************
// DSP Module code block:		Linked DSP Module Compute subroutines
//							and library routines
//
//		160 MHz/48000 = 3333 cycles
// ****************************************************************
#define kSysMem_DSPModuleCodeBlockMaxLength		3000

// MixBuffers 0x1400 through 0x17ff  Two banks of 32 Mixbuffers of 32 words each
//	2 banks x 32 Buffers/bank x 32 words/buffer = 2048 ($1000) words
#define kMixBufferSize			kFrameLength
#define kMixBufferLength		kFrameLength

#define kGPMemory_MixBuffers		0x001400	
#define kGPMemory_MixBuffer00		(kGPMemory_MixBuffers)	
#define kGPMemory_MixBuffer01		(kGPMemory_MixBuffer00+kMixBufferLength)	
#define kGPMemory_MixBuffer02		(kGPMemory_MixBuffer01+kMixBufferLength)	
#define kGPMemory_MixBuffer03		(kGPMemory_MixBuffer02+kMixBufferLength)	
#define kGPMemory_MixBuffer04		(kGPMemory_MixBuffer03+kMixBufferLength)	
#define kGPMemory_MixBuffer05		(kGPMemory_MixBuffer04+kMixBufferLength)	
#define kGPMemory_MixBuffer06		(kGPMemory_MixBuffer05+kMixBufferLength)	
#define kGPMemory_MixBuffer07		(kGPMemory_MixBuffer06+kMixBufferLength)	
#define kGPMemory_MixBuffer08		(kGPMemory_MixBuffer07+kMixBufferLength)	
#define kGPMemory_MixBuffer09		(kGPMemory_MixBuffer08+kMixBufferLength)	
#define kGPMemory_MixBuffer10		(kGPMemory_MixBuffer09+kMixBufferLength)	
#define kGPMemory_MixBuffer11		(kGPMemory_MixBuffer10+kMixBufferLength)	
#define kGPMemory_MixBuffer12		(kGPMemory_MixBuffer11+kMixBufferLength)	
#define kGPMemory_MixBuffer13		(kGPMemory_MixBuffer12+kMixBufferLength)	
#define kGPMemory_MixBuffer14		(kGPMemory_MixBuffer13+kMixBufferLength)	
#define kGPMemory_MixBuffer15		(kGPMemory_MixBuffer14+kMixBufferLength)
	
#define kGPMemory_MixBuffer16		(kGPMemory_MixBuffer15+kMixBufferLength)	
#define kGPMemory_MixBuffer17		(kGPMemory_MixBuffer16+kMixBufferLength)	
#define kGPMemory_MixBuffer18		(kGPMemory_MixBuffer17+kMixBufferLength)	
#define kGPMemory_MixBuffer19		(kGPMemory_MixBuffer18+kMixBufferLength)	
#define kGPMemory_MixBuffer20		(kGPMemory_MixBuffer19+kMixBufferLength)	
#define kGPMemory_MixBuffer21		(kGPMemory_MixBuffer20+kMixBufferLength)	
#define kGPMemory_MixBuffer22		(kGPMemory_MixBuffer21+kMixBufferLength)	
#define kGPMemory_MixBuffer23		(kGPMemory_MixBuffer22+kMixBufferLength)	
#define kGPMemory_MixBuffer24		(kGPMemory_MixBuffer23+kMixBufferLength)	
#define kGPMemory_MixBuffer25		(kGPMemory_MixBuffer24+kMixBufferLength)	
#define kGPMemory_MixBuffer26		(kGPMemory_MixBuffer25+kMixBufferLength)	
#define kGPMemory_MixBuffer27		(kGPMemory_MixBuffer26+kMixBufferLength)	
#define kGPMemory_MixBuffer28		(kGPMemory_MixBuffer27+kMixBufferLength)	
#define kGPMemory_MixBuffer29		(kGPMemory_MixBuffer28+kMixBufferLength)	
#define kGPMemory_MixBuffer30		(kGPMemory_MixBuffer29+kMixBufferLength)	
#define kGPMemory_MixBuffer31		(kGPMemory_MixBuffer30+kMixBufferLength)	

#define kGPMemory_TmpBuffers		0x0	
#define kGPMemory_TmpBuffer00		(kGPMemory_TmpBuffers)	
#define kGPMemory_TmpBuffer01		(kGPMemory_TmpBuffer00+kMixBufferLength)	
#define kGPMemory_TmpBuffer02		(kGPMemory_TmpBuffer01+kMixBufferLength)	
#define kGPMemory_TmpBuffer03		(kGPMemory_TmpBuffer02+kMixBufferLength)	

#define kGPMemory_TmpBuffer0		kGPMemory_TmpBuffer00
#define kGPMemory_TmpBuffer1		kGPMemory_TmpBuffer01
#define kGPMemory_TmpBuffer2		kGPMemory_TmpBuffer02
#define kGPMemory_TmpBuffer3		kGPMemory_TmpBuffer03

#endif  //	__DSP_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\CVPMethod.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CMCP1Method.cpp                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uap.h>
#include <nv_papu.h>
#include <AudioHw.h>
#include <nv32.h>
};
#include <aos.h>
#include <ahal.h>

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalGlobalProc.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CVPMethod.h"

VOID
CVPMethod::Execute(U032 uOffset, U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;  // not implemented

    do
    {
        if (CheckRange(uOffset, NV1BA0_PIO_SET_CONTEXT_DMA_NOTIFY))
        {
            rmStatus = SetContextDMANotify(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_SSL_CONTEXT_DMA))
        {
            rmStatus = SetCurrentSSLContextDMA(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_INBUF_SGE_CONTEXT_DMA))
        {
            rmStatus = SetCurrentInBufSGEContextDMA(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA))
        {
            rmStatus = SetCurrentOutBufSGEContextDMA(uData);
            break;
        }
        
        if (CheckRange(uOffset, 0x4000))        // to be moved to the .ref file.. todo vik
        {
            rmStatus = SetGPState(uData);
            break;
        }

        if (CheckRange(uOffset, 0x4004))        // debug...
        {
            rmStatus = SetCurrentOutBufSGEOffset(uData);
            break;
        }
        
        if (CheckRange(uOffset, 0x4008))        // debug...
        {
            rmStatus = SetCurrentInBufSGEOffset(uData);
            break;
        }

        if (CheckRange(uOffset, 0x422C))        // debug...
        {
            rmStatus = SetXCNTMode(uData);
            break;
        }
        
        U032 uCnt = 0;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if (CheckRange(uOffset, (0x420C + (uCnt*8))) )
            {
                rmStatus = SetOutBufBA(uData, uCnt);
                break;
            }
        }
        
        if (uCnt != 4)
            break;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if (CheckRange(uOffset, (0x4210 + (uCnt*8))) )
            {
                rmStatus = SetOutBufLen(uData, uCnt);
                break;
            }
        }

        if (uCnt != 4)
            break;

        // find out if NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET got triggered
        for (uCnt = 0; uCnt < 64; uCnt++)
        {
            if (CheckRange(uOffset, (0x400C + (uCnt*8))) )
            {
                rmStatus = SetSSLSegmentOffset(uData);
                break;
            }
        }
        
        if (uCnt != 64)
            break;

        for (uCnt = 0; uCnt < 64; uCnt++)
        {
            if (CheckRange(uOffset, (0x4010 + (uCnt*8))) )
            {
                rmStatus = SetSSLSegmentOffsetLength(uData, uCnt);
                break;
            }
        }

        if (uCnt != 64)
            break;
        
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CMCP1Method::Execute - SW method not yet implemented!\n");

#if defined WDM
        KdPrint(("Method offset = 0x%x Method Data = 0x%x\n", uOffset, uData));
#endif

    } while (FALSE);

    if (rmStatus != RM_OK)
    {
        // function failed.. write a notifier
        if (m_pVoiceProc)
            m_pVoiceProc->WriteNotifier(uOffset, (U008)rmStatus);
    }
 
}

// software methods
RM_STATUS
CVPMethod::SetContextDMANotify(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if ((U032)(pDma->GetAddress()) & 0xFF)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetContextDMANotify - Address not aligned on 256bytes boundary\n");
        return RM_ERROR;
    }
    
    if (m_pVoiceProc)
        m_pVoiceProc->SetNotifierMemory(pDma->GetLinAddr(), pDma->GetSize());

    m_pHal->RegWrite(NV_PAPU_FENADDR, (U032)pDma->GetAddress());
    return RM_OK;
}

RM_STATUS
CVPMethod::SetCurrentSSLContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentSSLContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FESESSLCTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FESESSLMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CVPMethod::SetCurrentInBufSGEContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentInBufSGEContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FESESGECTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FESESGEMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CVPMethod::SetCurrentOutBufSGEContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentOutBufSGEContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FEGPSGECTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FEGPSGEMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}






RM_STATUS
CVPMethod::SetGPState(U032 uData)
{
    R_GP_CONTROL rControl;
    rControl.uValue = 0;

    switch (uData)
    {
        case 0:
        {
            // stop the GP
            // take it out of reset...
            R_GP_RESET rReset;
            rReset.uValue = 0;
            rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
            rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
            rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
            rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;

            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);
            break;
        }
        case 1:
        {

            SetXCNTMode(GSCNT_OFF);
            //Take the GP Peripherals out of reset but leave DSP core reset
            R_GP_RESET rReset;
            rReset.uValue = 0;

            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);

            // take it out of reset...

            rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
            rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
            rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
            rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;
    
            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);

            // clear the GPISTS bit
            m_pHal->RegWrite(NV_PAPU_GPISTS, (U032)0xff);

            // auto start and auto idle
            R_GPDMA_CONFIG rConfig;
            rConfig.uValue = 0;
            //rConfig.Start = NV_PAPU_GPDCFG_GPDASTRT_ENABLED;
            //rConfig.Ready = NV_PAPU_GPDCFG_GPDARDY_ENABLED;
            m_pHal->RegWrite(NV_PAPU_GPDCFG, rConfig.uValue);




            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CMCP1Method::SetGPState - the GP might just start...");
            // enable the GP
            rControl.Idle = NV_PAPU_GPIDRDY_GPSETIDLE_SET;
            rControl.IntrNotify = NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET;

            m_pHal->RegWrite(NV_PAPU_GPIDRDY, rControl.uValue);
            break;
        }
        case 3:
        {
            SetXCNTMode(GSCNT_ACSYNC);
            //Take the GP Peripherals and DSP core out of reset
            R_GP_RESET rReset;
            rReset.uValue = 0;
            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);

            // take it out of reset...

            rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
            rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
            rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
            rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;
    
            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);


            // auto start and auto idle
            R_GPDMA_CONFIG rConfig;
            rConfig.uValue = 0;
            m_pHal->RegWrite(NV_PAPU_GPDCFG, rConfig.uValue);

            // clear the GPISTS bit
            m_pHal->RegWrite(NV_PAPU_GPISTS, (U032)0xff);


            U032 uXgscnt;
            U032 uDgscnt;

            m_pHal->RegRead(NV_PAPU_XGSCNT, &uXgscnt);
            m_pHal->RegRead(NV_PAPU_DGSCNT, &uDgscnt);
            m_pHal->RegWrite(NV_PAPU_IGSCNT, uXgscnt+uDgscnt);

            rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
            rReset.DSP = NV_PAPU_GPRST_GPDSPRST_DISABLED;
            rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
            rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;
    
            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);


            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CMCP1Method::SetGPState - the GP might just start...");

            break;
        }
    }

    aosDbgPrintString(DEBUGLEVEL_ERRORS, "done.  Congratulations!\n");
    return RM_OK;
}


//Set the NV_PAPU_SECTL_XCNTMODE register

RM_STATUS
CVPMethod::SetXCNTMode(U032 uData)
{

    U032  dwXcntMode;  
    switch(uData)
   {
       case GSCNT_OFF:
           dwXcntMode = NV_PAPU_SECTL_XCNTMODE_OFF;
            break;
       case GSCNT_ACSYNC:
            dwXcntMode = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;
            break;
       case GSCNT_SW:
           dwXcntMode = NV_PAPU_SECTL_XCNTMODE_SW;
            break;
       case GSCNT_FREE_RUNNING:
           dwXcntMode = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;
            break;
   }

    R_SE_CONTROL rSeControl;

    m_pHal->RegRead(NV_PAPU_SECTL, &rSeControl.uValue);

    rSeControl.GSCUpdate = uData;

    m_pHal->RegWrite(NV_PAPU_SECTL, rSeControl.uValue);

    return RM_OK;
}


// NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET
RM_STATUS
CVPMethod::SetCurrentOutBufSGEOffset(U032 uData)
{
    MCP1_PRD *pLin = (MCP1_PRD *)(m_pGlobalProc->GetSgeOutLinAddr());

    pLin->uAddr = uData;
    pLin->Control.uValue = 0;
    pLin->Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;      // owned by HW

    return RM_OK;
}

// NV1BA0_PIO_SET_CURRENT_INBUF_SGE_OFFSET
RM_STATUS
CVPMethod::SetCurrentInBufSGEOffset(U032 uData)
{
    VOLU32 uTemp;

    // find out the max offset
    m_pHal->RegRead(NV_PAPU_FESESGEMAXOFF, &uTemp);
    if (uTemp < uData)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - max offset exceeded!\n");
        return RM_ERROR;
    }

    R_FE_CONTROL rFeCtl;

    m_pHal->RegRead(NV_PAPU_FECTL, &rFeCtl.uValue);
    if (rFeCtl.ValidSESGE == NV_PAPU_FECTL_FESESGECTXPA_VALID_NO)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - SGE context dma valid bit not set\n");
        return RM_ERROR;
    }

    // find the right PRD to write to
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pVoiceProc->GetSgeInLinAddr());
    U032 uNumOfPrds = (m_pVoiceProc->GetSgeInSize())/NV_PSGE_SIZE;

    // read the current index to write to...
    m_pHal->RegRead(NV_PAPU_FECSESGE, &uTemp);

    // a little error checking of my own..
    if (uNumOfPrds < uTemp)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - current index greater than total PRDs allocated\n");
        return RM_ERROR;
    }

    VOLU32 uBase;
    m_pHal->RegRead(NV_PAPU_FESESGECTXPA, &uBase);

    // make the PRD (not 0 based.. i think)
    pPrd[uTemp-1].uAddr = uBase + uData;
    pPrd[uTemp-1].Control.uValue = 0;
    pPrd[uTemp-1].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

    return RM_OK;
}

// NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET
RM_STATUS
CVPMethod::SetSSLSegmentOffset(U032 uData)
{
    // error checking .. to hell with it! (for now)
    // logic has changed in HW
    /*
    if (uData & 0xFFF)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetSSLSegmentOffset - alignment check fails!\n");
        return RM_ERROR;
    }
    
    // save it as pending
    uData = uData | NV_PAPU_FESESSLPENDOFF_VALID_YES;

    m_pHal->RegWrite(NV_PAPU_FESESSLPENDOFF, uData);
    */

    return RM_ERROR;
}

// NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH
RM_STATUS
CVPMethod::SetSSLSegmentOffsetLength(U032 uData, U032 uIndex)
{
    /*
    Check that the offset has already been saved by the previous method.
    Check that container_size != 2. 
    Check that (offset & container_size) == 0.
    Check that samples_per_block > stereo.
    
    Then, check the offset and length as follows:
    
           offset+(length*container_size*samples_per_block) <= maxoff
    */
    
    /*
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pHal->GetVoiceProc()->GetSegInLinAddr());
    
    // calculate the index of the SSL
    VOLU16 uCurrSSL = 0;
    m_pHal->RegRead(NV_PAPU_FECSESSL, &uCurrSSL);
    
    uIndex += (uCurrSSL * 64);
    
    // read the offset previosuly set
    VOLU32 uPendOffset = 0;
    m_pHal->RegRead(NV_PAPU_FESESSLPENDOFF, &uPendOffset);
    
    // just for fun confirm that it's valid
    if ((uPendOffset & 0x1) != NV_PAPU_FESESSLPENDOFF_VALID_YES)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetSSLSegmentOffsetLength - u can only set length after setting the offset!\n");
        return RM_ERROR;
    }
    
    VOLU32 uBase;
    m_pHal->RegRead(NV_PAPU_FESESSLCTXPA, &uBase);
    
    // these don't look like being '0' based
    pPrd[uIndex-1].uAddr = uBase + (uPendOffset & 0xFFFFF000);
    pPrd[uIndex-1].Control.uValue = uData;
    */

    return RM_ERROR;
}

// NV1BA0_PIO_SET_OUTBUF_BA(i)
RM_STATUS
CVPMethod::SetOutBufBA(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    switch(uIndex)
    {
    case 0:
        uOffBase = NV_PAPU_GPOFBASE0;
        uOffEnd = NV_PAPU_GPOFEND0;
        break;
    case 1:
        uOffBase = NV_PAPU_GPOFBASE1;
        uOffEnd = NV_PAPU_GPOFEND1;
        break;
    case 2:
        uOffBase = NV_PAPU_GPOFBASE2;
        uOffEnd = NV_PAPU_GPOFEND2;
        break;
    case 3:
        uOffBase = NV_PAPU_GPOFBASE3;
        uOffEnd = NV_PAPU_GPOFEND3;
        break;
    }

    m_pHal->RegWrite(uOffBase, uData);
    m_pHal->RegWrite(uOffEnd, uData);

    return RM_OK;
}

// NV1BA0_PIO_SET_OUTBUF_LEN(i)
RM_STATUS
CVPMethod::SetOutBufLen(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    switch(uIndex)
    {
    case 0:
        uOffBase = NV_PAPU_GPOFBASE0;
        uOffEnd = NV_PAPU_GPOFEND0;
        break;
    case 1:
        uOffBase = NV_PAPU_GPOFBASE1;
        uOffEnd = NV_PAPU_GPOFEND1;
        break;
    case 2:
        uOffBase = NV_PAPU_GPOFBASE2;
        uOffEnd = NV_PAPU_GPOFEND2;
        break;
    case 3:
        uOffBase = NV_PAPU_GPOFBASE3;
        uOffEnd = NV_PAPU_GPOFEND3;
        break;
    }
    
    U032 uBaseAddr;
    m_pHal->RegRead(uOffBase, &uBaseAddr);

    m_pHal->RegWrite(uOffEnd, uBaseAddr + uData);
    
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\DSP_Util.cpp ===
// ****************************************************************
//
//	DSP_Util:		DSP Execution Support routines
//
//	Written by Gints Klimanis
//
// ****************************************************************
#include "DSP_Util.h"

// ****************************************************************
// DefaultCommandNode:		
// **************************************************************** 
	void
DefaultCommandNode(DSPCOMMANDNODE *d)
{
d->commandID     =  kDSPCommandID_IgnoreMe;		
d->stateID       = (kDSPStateID_ModuleListStopped | kDSPStateID_WaitingForCommand);			
d->moduleIndex = 0;	

d->moduleCount = 0;	

d->dspModuleBlock      = 0;
d->dspModuleStateBlock = 0;
d->dspModuleCodeBlock  = 0;

d->dspModuleBlockSize      = 0;
d->dspModuleStateBlockSize = 0;
d->dspModuleCodeBlockSize  = 0;
}	// ---- end DefaultCommandNode() ---- 

// ****************************************************************
// DefaultDSPModule:		
// **************************************************************** 
	void
DefaultDSPModule(DSPMODULE *d)
{
d->state   = 0;
d->compute = 0;
d->typeID  = 2; //kAudioFxModule_Null;

}	// ---- end DefaultDSPModule() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\Util.cpp ===
// ****************************************************************
//
//	Util.cpp			Conversion functions, memory stuff, etc.
//
//	Written by Gints Klimanis
//
// ****************************************************************
#include "util.h"

#ifndef AUDIOFX_STANDALONE
#include <AudioHw.h>

#ifndef BUILD_DRIVER
#include <CScratchDma.h>

// This is a dummy variable referenced by the Visual C++ compiler when
// compiling floating point code.  Since we can't use the Visual C++ run-time
// library, we create an instance of it here.
extern "C" int _fltused = 0x9875;
#endif // BUILD_DRIVER

#endif	// AUDIOFX_STANDALONE

#ifdef AUDIOFX_STANDALONE
// ***************************************************************
// afxScratchMemZero:	Clear some scratch memory.
//					NOTE: this function will disappear !
// *************************************************************** 
	void  
afxScratchMemZero(Int24 memBlock, long size)
{
memset((void *) memBlock, 0, size );
}	// ---- end afxScratchMemZero() ---- 

// ***************************************************************
// afxScratchMemSet:	Set some scratch memory.
//					NOTE: this function will disappear !
// *************************************************************** 
	void  
afxScratchMemSet(Int24 memBlock, long size, long value)
// value	Well, it's just the 8 bits, I think !
{
memset((void *) memBlock, value, size );
}	// ---- end afxScratchMemSet() ---- 

// ***************************************************************
// afxScratchMemRealloc:	Reallocate scratch memory.
// *************************************************************** 
	void  
afxScratchMemRealloc(Int24 *memBlock, long size, int clear)
{
afxScratchMemFree((void *) *memBlock);
*memBlock = (long) afxScratchMemAlloc(size);
if (*memBlock && clear)
	afxScratchMemZero(*memBlock, size);
}	// ---- end afxScratchMemRealloc() ---- 

// ***************************************************************
// afxSystemMemZero:	Clear some system memory.
//					NOTE: this function will disappear !
// *************************************************************** 
	void  
afxSystemMemZero(void *memBlock, long size)
{
memset(memBlock, 0, size );
}	// ---- end afxSystemMemZero() ---- 

// **********************************************************************************
// ByteSwap32:		Swap bytes in one 32-bit word
// ********************************************************************************** 
	void
ByteSwap32(long *p)
{
unsigned char x, y, *d = (unsigned char *) p;

x    = d[0];
d[0] = d[3];
d[3] = x;
y    = d[1];
d[1] = d[2];
d[2] = y;
}	// ---- end ByteSwap32() ---- 

// **********************************************************************************
// ByteSwapBuf32:		Do Endian byte swap on each 32-bit word in buffer
// ********************************************************************************** 
	void
ByteSwapBuf32(long *p, long count)
{
for (long i = 0; i < count; i++)
	{
	unsigned char x, y;
	unsigned char *b = (unsigned char *) p++;
	x    = b[0];
	b[0] = b[3];
	b[3] = x;
	y    = b[1];
	b[1] = b[2];
	b[2] = y;
	}
}	// ---- end ByteSwapBuf32() ---- 

// **********************************************************************************
// ByteSwap24:		Swap bytes in one 24-bit word
// ********************************************************************************** 
	void
ByteSwap24(Int24 *p)
{
unsigned char *b = (unsigned char *) p;
unsigned char x;

x    = b[0];
b[0] = b[2];
b[2] = x;
}	// ---- end ByteSwap24() ---- 

// **********************************************************************************
// ByteSwapBuf24:		Do byte swap on each 24-bit word in buffer
// ********************************************************************************** 
	void
ByteSwapBuf24(Int24 *p, long count)
{
unsigned char *b = (unsigned char *) p;
unsigned char x;
for (long i = 0; i < count; i++, b += 3)
	{
	x    = b[0];
	b[0] = b[2];
	b[2] = x;
	}
}	// ---- end ByteSwapBuf24() ---- 

#else		// AUDIOFX_STANDALONE

// system memory functions
void *afxSystemMemAlloc(U032 uSize)
{
    void *pLinAddr = NULL;
    aosAllocateMem(uSize, ALIGN_DONT_CARE, &pLinAddr, NULL);
    return pLinAddr;
}

void afxSystemMemFree(void *pLinAddr)
{
    aosFreeMem(pLinAddr);
}

void afxSystemMemCopy(void *pDest, void *pSrc, U032 uSize)
{
    aosMemCopy(pDest, pSrc, uSize);
}

void afxScratchMemZero(void *ptr, U032 uSize)
{
    aosZeroMemory(ptr, uSize);
}

// scratch memory functions
#define MAX_ALLOCATIONS     256
#define INVALID_OFFSET      ~0

CScratchDma *gpDma = NULL;

struct
{
    U032 uLinOffset;
    U032 uSize;
} gAllocMap[MAX_ALLOCATIONS];

BOOL AllocMapStoreEntry(U032 uLinOffset, U032 uSize)
{
    for (U032 uCnt = 0; uCnt < MAX_ALLOCATIONS; uCnt++)
    {
        if (gAllocMap[uCnt].uLinOffset == INVALID_OFFSET)
        {
            gAllocMap[uCnt].uLinOffset = uLinOffset;
            gAllocMap[uCnt].uSize = uSize;
            return TRUE;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: AllocMapStoreEntry - ERROR! increase MAX_ALLOCATIONS\n");
    return FALSE;
}

BOOL AllocMapGetSize(U032 uLinOffset, U032 *pSize)
{
    for (U032 uCnt = 0; uCnt < MAX_ALLOCATIONS; uCnt++)
    {
        if (gAllocMap[uCnt].uLinOffset == uLinOffset)
        {
            *pSize = gAllocMap[uCnt].uSize;
            return TRUE;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: AllocMapGetSize - bad linear offset!\n");
    return FALSE;
}

BOOL AllocMapFreeEntry(U032 uLinOffset)
{
    for (U032 uCnt = 0; uCnt < MAX_ALLOCATIONS; uCnt++)
    {
        if (gAllocMap[uCnt].uLinOffset == uLinOffset)
        {
            gAllocMap[uCnt].uLinOffset = INVALID_OFFSET;
            gAllocMap[uCnt].uSize = 0;
            return TRUE;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: AllocMapFreeEntry - bad linear offset!\n");
    return FALSE;
}

// called from audiofx object
void afxScratchMemInitialize(CScratchDma *pDma)
{
    gpDma = pDma;
    
    for (U032 uCnt = 0; uCnt < MAX_ALLOCATIONS; uCnt++)
    {
        gAllocMap[uCnt].uLinOffset = INVALID_OFFSET;
        gAllocMap[uCnt].uSize = 0;
    }
}

void afxScratchMemShutdown()
{
    // check for memory leaks here
    gpDma = NULL;
}


BOOL afxScratchMemAlloc(U032 uSize, U032 *pOffset)
{
    BOOL bStatus = FALSE;
    
    if ( (gpDma) && (RM_OK == gpDma->Allocate(uSize, pOffset)) )
        bStatus = TRUE;
    
    if (bStatus == (BOOL)TRUE)
        bStatus = AllocMapStoreEntry(*pOffset, uSize);
    
    return bStatus;
}

void afxScratchMemFree(U032 uOffset)
{
    U032 uSize;
    
    if ( AllocMapGetSize(uOffset, &uSize) == (BOOL)TRUE )
    {
        if (gpDma)
            gpDma->Free(uOffset, uSize);
        
        AllocMapFreeEntry(uOffset);
        
    }
}

void afxScratchMemWrite(U032 uOffset, void *pSource, U032 uSize)
{
    if (gpDma)
        gpDma->Write(uOffset, pSource, uSize);
    else
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: afxScratchMemCopy - scratch DMA not initialized!\n");
}

void afxScratchMemRead(void *pDest, U032 uOffset, U032 uSize)
{
    if (gpDma)
        gpDma->Read(pDest, uOffset, uSize);
    else
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: afxScratchMemCopy - scratch DMA not initialized!\n");
    
}

BOOL  afxScratchMemRealloc(U032 *pOffset, U032 uNewSize, BOOL bClear)
{
    U032 uOldSize;
    BOOL bStatus = FALSE;
    
    if ( AllocMapGetSize(*pOffset, &uOldSize) == (BOOL)TRUE )
    {
        if (uOldSize > uNewSize)
        {
            U032 uExtraOffset = *pOffset + uNewSize;
            if (gpDma)
            {
                gpDma->Free(uExtraOffset, uOldSize - uNewSize);
                // update the alloc map
                AllocMapFreeEntry(*pOffset);
                AllocMapStoreEntry(*pOffset, uNewSize);
                bStatus = TRUE;
            }
        }
        else
        {
            // free and allocate again
            afxScratchMemFree(*pOffset);
            bStatus = afxScratchMemAlloc(uNewSize, pOffset);
        }
    }
    
    if ( (bStatus == (BOOL)TRUE) && (bClear == (BOOL)TRUE) )
        afxScratchMemZero(*pOffset, uNewSize);
    
    return bStatus;
}
void afxScratchMemZero(U032 uOffset, U032 uSize)
{
    afxScratchMemSet(uOffset, uSize, 0);
}

void afxScratchMemSet(U032 uOffset, U032 uSize, U032 uValue)
{
    if (gpDma)
        gpDma->Put(uOffset, uSize, uValue);
}

#endif


// ***************************************************************
// FloatToInt24:	Convert float to 24-bit fractional int
// *************************************************************** 
	Int24 
FloatToInt24(float x)
{
#ifdef AUDIOFX_STANDALONE
return ((Int24)(k24Norm*x));
#else
long lTemp = DTOL(k24Norm*x);
return (Int24)lTemp;
#endif
}	// ---- end FloatToInt24() ---- 

// ***************************************************************
// DoubleToInt24:	Convert double to 24-bit fractional int
// *************************************************************** 
	Int24 
DoubleToInt24(double x)
{
#ifdef AUDIOFX_STANDALONE
return ((Int24)(k24Norm*x));
#else
long lTemp = DTOL(k24Norm*x);
return (Int24)lTemp;
#endif
}	// ---- end DoubleToInt24() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\audio\dspprogs\Wire.h ===
/* Section  7 Including Memory P $000000 (1st word= $300000 ) length=    44 */
    0x300000, 
    0x310C00, 
    0x62F400, 
    0x001420, 
    0x0BF080, 
    0x000062, 
    0x300600, 
    0x61F400, 
    0x001000, 
    0x62F000, 
    0x003024, 
    0x0BF080, 
    0x000082, 
    0x300C00, 
    0x0BF080, 
    0x0000C2, 
    0x300000, 
    0x0BF080, 
    0x0000C8, 
    0x56F400, 
    0x000006, 
    0x0BF080, 
    0x00002C, 
    0x46F400, 
    0x000012, 
    0x08C608, 
    0x000000, 
    0x08F484, 
    0x000001, 
    0x0BF080, 
    0x0000AC, 
    0x56F400, 
    0x000000, 
    0x0BF080, 
    0x0000A2, 
    0x300C00, 
    0x310000, 
    0x0BF080, 
    0x0000CE, 
    0x56F400, 
    0x000006, 
    0x0BF080, 
    0x0000A2, 
    0x0C001A, 

    /* Section  8 Including Memory P $00002C (1st word= $0BF080 ) length=   268 */
    0x0BF080, 
    0x000046, 
    0x08CE15, 
    0x0140C2, 
    0x004000, 
    0x08CE14, 
    0x08F497, 
    0x000000, 
    0x08F485, 
    0x000000, 
    0x00000C, 
    0x08F496, 
    0x000001, 
    0x0A9684, 
    0x000039, 
    0x00000C, 
    0x08F496, 
    0x000002, 
    0x0A96A4, 
    0x00003E, 
    0x00000C, 
    0x08F496, 
    0x000003, 
    0x0A96A3, 
    0x000043, 
    0x00000C, 
    0x08F496, 
    0x000002, 
    0x0A96A4, 
    0x000048, 
    0x08F496, 
    0x000003, 
    0x0A96A3, 
    0x00004C, 
    0x00000C, 
    0x08F496, 
    0x000004, 
    0x0A9683, 
    0x000051, 
    0x00000C, 
    0x08F496, 
    0x000004, 
    0x0A9683, 
    0x000056, 
    0x08F496, 
    0x000001, 
    0x0A9684, 
    0x00005A, 
    0x00000C, 
    0x0A9687, 
    0x00005D, 
    0x08F485, 
    0x000080, 
    0x00000C, 
    0x220E00, 
    0x0140C6, 
    0xFF8000, 
    0x0140C2, 
    0x004000, 
    0x02008E, 
    0x56F400, 
    0x0059E0, 
    0x0200CE, 
    0x56F400, 
    0x000020, 
    0x02088E, 
    0x0A7091, 
    0x000003, 
    0x0A7092, 
    0x000004, 
    0x00000C, 
    0x220E00, 
    0x0140C6, 
    0xFF8000, 
    0x02008E, 
    0x56F400, 
    0x0059E0, 
    0x0200CE, 
    0x56F400, 
    0x000020, 
    0x02088E, 
    0x0A7091, 
    0x000003, 
    0x0A7092, 
    0x000004, 
    0x00000C, 
    0x220E00, 
    0x0140C6, 
    0xFF8000, 
    0x0140C2, 
    0x004000, 
    0x02008E, 
    0x56F400, 
    0x0059E2, 
    0x0200CE, 
    0x56F400, 
    0x000020, 
    0x02088E, 
    0x0A7091, 
    0x000003, 
    0x0A7092, 
    0x000004, 
    0x00000C, 
    0x220E00, 
    0x0140C6, 
    0xFF8000, 
    0x02008E, 
    0x56F400, 
    0x0059E2, 
    0x0200CE, 
    0x56F400, 
    0x000020, 
    0x02088E, 
    0x0A7091, 
    0x000003, 
    0x0A7092, 
    0x000004, 
    0x00000C, 
    0x0D0046, 
    0x08CE15, 
    0x0D0054, 
    0x0D005D, 
    0x00000C, 
    0x0D0046, 
    0x09CE15, 
    0x0D0054, 
    0x0D005D, 
    0x00000C, 
    0x000000, 
    0x0A8581, 
    0x0000AD, 
    0x08F485, 
    0x000002, 
    0x00000C, 
    0x60F400, 
    0x000000, 
    0x44F400, 
    0x000800, 
    0x200013, 
    0x06C420, 
    0x565800, 
    0x00000C, 
    0x60F400, 
    0x001000, 
    0x44F400, 
    0x000800, 
    0x200013, 
    0x06C420, 
    0x565800, 
    0x00000C, 
    0x44F400, 
    0x000020, 
    0x200013, 
    0x06C420, 
    0x565800, 
    0x00000C, 
    0x44F400, 
    0x000020, 
    0x200013, 
    0x06C420, 
    0x5E5800, 
    0x00000C, 
    0x062080, 
    0x0000D1, 
    0x44D800, 
    0x4C5900, 
    0x00000C, 
    0x062080, 
    0x0000D6, 
    0x4CD800, 
    0x445900, 
    0x00000C, 
    0x062080, 
    0x0000DB, 
    0x44D800, 
    0x445900, 
    0x00000C, 
    0x062080, 
    0x0000E0, 
    0x44D800, 
    0x445900, 
    0x00000C, 
    0x062080, 
    0x0000E7, 
    0x44D800, 
    0x56D900, 
    0x200040, 
    0x565A00, 
    0x00000C, 
    0x062080, 
    0x0000EE, 
    0x4CD800, 
    0x5ED900, 
    0x200040, 
    0x5E5A00, 
    0x00000C, 
    0x062080, 
    0x0000F5, 
    0x44D800, 
    0x56E100, 
    0x200040, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x0000FC, 
    0x4CD800, 
    0x5EE100, 
    0x200040, 
    0x5E5900, 
    0x00000C, 
    0x062080, 
    0x000103, 
    0x4CD800, 
    0x56E100, 
    0x200040, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x000109, 
    0x46D800, 
    0x2000D0, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x00010F, 
    0x4ED800, 
    0x2000D0, 
    0x5E5900, 
    0x00000C, 
    0x062080, 
    0x000116, 
    0x46D800, 
    0x56E100, 
    0x2000D2, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x00011D, 
    0x46D800, 
    0x56E100, 
    0x2000D2, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x000124, 
    0x44D800, 
    0x56D900, 
    0x200044, 
    0x565A00, 
    0x00000C, 
    0x200013, 
    0x062080, 
    0x000129, 
    0x565800, 
    0x00000C, 
    0x200013, 
    0x062080, 
    0x00012E, 
    0x5E5800, 
    0x00000C, 
    0x062080, 
    0x000132, 
    0x445800, 
    0x00000C, 
    0x062080, 
    0x000136, 
    0x4C5800, 
    0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\class\nv\class.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASS.C                                                           *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <mc.h>
#include <gr.h>
#include <dac.h>
#include <tmr.h>
#include <os.h>
#include <modular.h>
#include <nv32.h>


//---------------------------------------------------------------------------
//
//  Class methods.
//
//---------------------------------------------------------------------------

METHOD NvPatchcordMethods[] =
{
    {mthdSetNotifyCtxDma,           0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107}
    //{mthdValidate,                  0x0300, 0x0303}
};
METHOD NvClassMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdCreateLegacy,              0x0300, 0x0303},
    {mthdDestroy,                   0x0304, 0x0307},
};
METHOD NvDmaFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvDmaToMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvDmaInMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvVideoSinkMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetVideoInput,             0x0200, 0x02ff}
};
METHOD NvVideoColormapMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetColormapCtxDma,         0x0184, 0x0187},
    {mthdSetVideoOutput,            0x0200, 0x0203},
    {mthdSetVideoInput,             0x0204, 0x0207},
    {mthdSetColormapStart,          0x0308, 0x030b},
    {mthdSetColormapLength,         0x030c, 0x030f},
    {mthdColormapDirtyStart,        0x0310, 0x0313},
    {mthdColormapDirtyLength,       0x0314, 0x0317}
};
METHOD Nv04VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class046SetNotify,             0x0104, 0x0107},
    {class046StopImage,             0x0108, 0x010f},
    {class046StopLUT,               0x0110, 0x0117},
    {class046StopCursorImage,       0x0118, 0x011f},
    {class046StopDAC,               0x0120, 0x0128},
    {class046SetNotifyCtxDma,       0x0180, 0x0183},
    {class046SetImageCtxDma,        0x0184, 0x018b},
    {class046SetLUTCtxDma,          0x018c, 0x0193},
    {class046SetCursorCtxDma,       0x0194, 0x019b},
    {class046SetPanOffset,          0x0220, 0x0223},
    {class046GetOffset,             0x02fc, 0x02ff},
    {class046SetImageValues,        0x0300, 0x030f},
    {class046SetLUTValues,          0x0310, 0x031f},
    {class046SetCursorImageValues,  0x0320, 0x032f},
    {class046SetCursorPoint,        0x0330, 0x0333},
    {class046SetDACValues,          0x0340, 0x037c}
};

METHOD Nv04VideoOverlayMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class047SetNotify,             0x0104, 0x0107},
    {class047StopOverlay,           0x0120, 0x0127},
    {class047SetNotifyCtxDma,       0x0180, 0x0183},
    {class047SetOverlayCtxDma,      0x019c, 0x01a3},
    {class047GetOffset,             0x02fc, 0x02ff},
    {class047SetOverlayValues,      0x0400, 0x04ff},
    {class047SetOverlayPointOutNow, 0x0500, 0x0503}
};

METHOD Nv05VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class049SetNotify,             0x0104, 0x0107},
    {class049StopImage,             0x0108, 0x010f},
    {class049StopLUT,               0x0110, 0x0117},
    {class049StopCursorImage,       0x0118, 0x011f},
    {class049StopDAC,               0x0120, 0x0128},
    {class049SetNotifyCtxDma,       0x0180, 0x0183},
    {class049SetImageCtxDma,        0x0184, 0x018b},
    {class049SetLUTCtxDma,          0x018c, 0x0193},
    {class049SetCursorCtxDma,       0x0194, 0x019b},
    {class049SetPanOffset,          0x0220, 0x0223},
    {class049GetOffset,             0x02fc, 0x02ff},
    {class049SetImageValues,        0x0300, 0x030f},
    {class049SetLUTValues,          0x0310, 0x031f},
    {class049SetCursorImageValues,  0x0320, 0x032f},
    {class049SetCursorPoint,        0x0330, 0x0333},
    {class049SetDACValues,          0x0340, 0x037c}
};

METHOD NvVideoFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class63SetNotify,              0x0104, 0x0107},
    {class63StopTransfer,           0x0108, 0x010b},
    {class63SetNotifyCtxDma,        0x0180, 0x0183},
    {class63SetImageCtxDma,         0x0184, 0x018b},
    {class63SetVideoOutput,         0x0200, 0x0203},
    {class63ImageScan,              0x0300, 0x0327},
    {class63GetOffsetNotify,        0x0328, 0x032f}
};
METHOD NvVideoScalerMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class64SetNotify,              0x0104, 0x0107},
    {class64SetNotifyCtxDma,        0x0180, 0x0183},
    {class64SetVideoOutput,         0x0200, 0x0203},
    {class64SetVideoInput,          0x0204, 0x0207},
    {class64SetDeltaDuDx,           0x0300, 0x0303},
    {class64SetDeltaDvDy,           0x0304, 0x0307},
    {class64SetPoint,               0x0308, 0x030b}
};
METHOD NvVideoColorKeyMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class65SetNotify,              0x0104, 0x0107},
    {class65SetNotifyCtxDma,        0x0180, 0x0183},
    {class65SetVideoOutput,         0x0200, 0x0203},
    {class65SetVideoInput,          0x0204, 0x020f},
    {class65SetColorFormat,         0x0300, 0x0303},
    {class65SetColorKey,            0x0304, 0x0307},
    {class65SetPoint,               0x0308, 0x030b},
    {class65SetSize,                0x030c, 0x030f}
};

/*
METHOD NvVideoCaptureToMemoryMethods[] =
{
    {class66SetNotifyCtxDma,        0x0100, 0x0103},
    {class66SetNotify,              0x0104, 0x0107},
    {class66StopTransfer,           0x0108, 0x010b},
    {class66SetVideoInput,          0x0200, 0x0203},
    {class66SetImageCtxDma,         0x0300, 0x0307},
    {class66SetImageNotifyCtxDma,   0x0308, 0x030f},
    {class66ImageCapture,           0x0310, 0x0337},
    {class66SetVbiCtxDma,           0x0400, 0x0407},
    {class66SetVbiNotifyCtxDma,     0x0408, 0x040f},
    {class66VbiCapture,             0x0410, 0x0437}
};
*/

METHOD Nv10VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class067SetNotify,             0x0104, 0x0107},
    {class067StopImage,             0x0108, 0x010f},
    {class067StopLUT,               0x0110, 0x0117},
    {class067StopCursorImage,       0x0118, 0x011f},
    {class067StopDAC,               0x0120, 0x0128},
    {class067SetNotifyCtxDma,       0x0180, 0x0183},
    {class067SetImageCtxDma,        0x0184, 0x018b},
    {class067SetLUTCtxDma,          0x018c, 0x0193},
    {class067SetCursorCtxDma,       0x0194, 0x019b},
    {class067SetPanOffset,          0x0220, 0x0223},
    {class067GetOffset,             0x02fc, 0x02ff},
    {class067SetImageValues,        0x0300, 0x030f},
    {class067SetLUTValues,          0x0310, 0x031f},
    {class067SetCursorImageValues,  0x0320, 0x032f},
    {class067SetCursorPoint,        0x0330, 0x0333},
    {class067SetDACValues,          0x0340, 0x037c}
};

METHOD Nv10VideoOverlayMethods[] =
{
    {mthdNoOperation,                  0x0100, 0x0103},
    {class07ASetNotify,                0x0104, 0x0107},
    {class07AStopOverlay,              0x0120, 0x0127},
    {class07ASetNotifyCtxDma,          0x0180, 0x0183},
    {class07ASetOverlayCtxDma,         0x019c, 0x01a3},
    {class07AGetOffset,                0x02fc, 0x02ff},
    {class07ASetOverlayValues,         0x0400, 0x04ff},
    {class07ASetOverlayPointOutNow,    0x0500, 0x0503},
    {class07ASetOverlayLuminanceNow,   0x0504, 0x0507},
    {class07ASetOverlayChrominanceNow, 0x0508, 0x050b}
};

METHOD Nv15VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07CSetNotify,             0x0104, 0x0107},
    {class07CStopImage,             0x0108, 0x010f},
    {class07CStopLUT,               0x0110, 0x0117},
    {class07CStopCursorImage,       0x0118, 0x011f},
    {class07CStopDAC,               0x0120, 0x0128},
    {class07CSetNotifyCtxDma,       0x0180, 0x0183},
    {class07CSetImageCtxDma,        0x0184, 0x018b},
    {class07CSetLUTCtxDma,          0x018c, 0x0193},
    {class07CSetCursorCtxDma,       0x0194, 0x019b},
    {class07CSetSemaphoreCtxDma,    0x019c, 0x019f},
    {class07CSetHotPlug,            0x01a0, 0x01a3},
    {class07CSetPanOffset,          0x0220, 0x0223},
    {class07CSetSemaphoreOffset,    0x02f0, 0x02f3},
    {class07CSetSemaphoreRelease,   0x02f4, 0x02f7},
    {class07CSetOffsetRange,        0x02f8, 0x02fb},
    {class07CGetOffset,             0x02fc, 0x02ff},
    {class07CSetImageValues,        0x0300, 0x030f},
    {class07CSetLUTValues,          0x0310, 0x031f},
    {class07CSetCursorImageValues,  0x0320, 0x032f},
    {class07CSetCursorPoint,        0x0330, 0x0333},
    {class07CSetDACValues,          0x0340, 0x037c},
};

METHOD Nv20VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07CSetNotify,             0x0104, 0x0107},
    {class07CStopImage,             0x0108, 0x010f},
    {class07CStopLUT,               0x0110, 0x0117},
    {class07CStopCursorImage,       0x0118, 0x011f},
    {class07CStopDAC,               0x0120, 0x0128},
    {class07CSetNotifyCtxDma,       0x0180, 0x0183},
    {class07CSetImageCtxDma,        0x0184, 0x018b},
    {class07CSetLUTCtxDma,          0x018c, 0x0193},
    {class07CSetCursorCtxDma,       0x0194, 0x019b},
    {class07CSetSemaphoreCtxDma,    0x019c, 0x019f},
    {class07CSetHotPlug,            0x01a0, 0x01a3},
    {class07CSetPanOffset,          0x0220, 0x0223},
    {class07CSetSemaphoreOffset,    0x02f0, 0x02f3},
    {class07CSetSemaphoreRelease,   0x02f4, 0x02f7},
    {class07CSetOffsetRange,        0x02f8, 0x02fb},
    {class07CGetOffset,             0x02fc, 0x02ff},
    {class07CSetImageValues,        0x0300, 0x030f},
    {class07CSetLUTValues,          0x0310, 0x031f},
    {class07CSetCursorImageValues,  0x0320, 0x032f},
    {class07CSetCursorPoint,        0x0330, 0x0333},
    {class07CSetDACValues,          0x0340, 0x037c},
};

/*
METHOD NvVideoSourceMethods[] =
{
    {class74SetNotifyCtxDma,        0x0100, 0x0103},
    {class74SetNotify,              0x0104, 0x0107},
    {class74SetVideoOutput,         0x0200, 0x0203},
};
*/

METHOD Nv1TimerMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {tmrStopTransfer,               0x0108, 0x010b},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetAlarmTime,              0x0300, 0x0307},
    {mthdSetAlarmTimeRelative,      0x0308, 0x030f},
    {mthdSetAlarmNotify,            0x0320, 0x0323}
};
METHOD Nv1BetaSolidMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class012Notify,                0x0104, 0x0107},
    {class012SetContextDmaNotifies, 0x0180, 0x0183},
    {class012SetBeta,               0x0300, 0x0303}
};
METHOD Nv1ImageSolidMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class017Notify,                0x0104, 0x0107},
    {class017SetContextDmaNotifies, 0x0180, 0x0183},
    {class017SetColorFormat,        0x0300, 0x0303},
    {class017SetColor,              0x0304, 0x0307}
};
METHOD Nv1ImagePatternMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class018Notify,                0x0104, 0x0107},
    {class018SetContextDmaNotifies, 0x0180, 0x0183},
    {class018SetColorFormat,        0x0300, 0x0303},
    {class018SetMonochromeFormat,   0x0304, 0x0307},
    {class018SetPatternShape,       0x0308, 0x030b},
    {class018SetColor0,             0x0310, 0x0313},
    {class018SetColor1,             0x0314, 0x0317},
    {class018SetPattern,            0x0318, 0x031f}
};
METHOD Nv1ImageRectangleBlackMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class019Notify,                0x0104, 0x0107},
    {class019SetContextDmaNotifies, 0x0180, 0x0183},
    {class019SetRectangle,          0x0300, 0x0307}
};
METHOD Nv1RenderSolidLinMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01CNotify,                0x0104, 0x0107},
    {class01CSetContextDmaNotifies, 0x0180, 0x0183},
    {class01CSetContextClip,        0x0184, 0x0187},
    {class01CSetContextPattern,     0x0188, 0x018b},
    {class01CSetContextRop,         0x018c, 0x018f},
    {class01CSetContextBeta1,       0x0190, 0x0193},
    {class01CSetContextSurface,     0x0194, 0x0197},
    {class01CSetOperation,          0x02fc, 0x02ff},
    {class01CSetColorFormat,        0x0300, 0x0303},
    {class01CColor,                 0x0304, 0x0307},
    {class01CLin,                   0x0400, 0x047f},
    {class01CLin32,                 0x0480, 0x04ff},
    {class01CPolyLin,               0x0500, 0x057f},
    {class01CPolyLin32,             0x0580, 0x05ff},
    {class01CColorPolyLin,          0x0600, 0x067f}
};
METHOD Nv1RenderSolidTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01DNotify,                0x0104, 0x0107},
    {class01DSetContextDmaNotifies, 0x0180, 0x0183},
    {class01DSetContextClip,        0x0184, 0x0187},
    {class01DSetContextPattern,     0x0188, 0x018b},
    {class01DSetContextRop,         0x018c, 0x018f},
    {class01DSetContextBeta1,       0x0190, 0x0193},
    {class01DSetContextSurface,     0x0194, 0x0197},
    {class01DSetOperation,          0x02fc, 0x02ff},
    {class01DSetColorFormat,        0x0300, 0x0303},
    {class01DColor,                 0x0304, 0x0307},
    {class01DTriangle,              0x0310, 0x031b},
    {class01DTriangle32,            0x0320, 0x0337},
    {class01DTrimesh,               0x0400, 0x047f},
    {class01DTrimesh32,             0x0480, 0x04ff},
    {class01DColorTriangle,         0x0500, 0x057f},
    {class01DColorTrimesh,          0x0580, 0x05ff}
};
METHOD Nv1RenderSolidRectangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01ENotify,                0x0104, 0x0107},
    {class01ESetContextDmaNotifies, 0x0180, 0x0183},
    {class01ESetContextClip,        0x0184, 0x0187},
    {class01ESetContextPattern,     0x0188, 0x018b},
    {class01ESetContextRop,         0x018c, 0x018f},
    {class01ESetContextBeta1,       0x0190, 0x0193},
    {class01ESetContextSurface,     0x0194, 0x0197},
    {class01ESetOperation,          0x02fc, 0x02ff},
    {class01ESetColorFormat,        0x0300, 0x0303},
    {class01EColor,                 0x0304, 0x0307},
    {class01ERectangle,             0x0400, 0x047f}
};
METHOD Nv1ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01FNotify,                0x0104, 0x0107},
    {class01FSetContextDmaNotifies, 0x0180, 0x0183},
    {class01FSetContextColorKey,    0x0184, 0x0187},
    {class01FSetContextClip,        0x0188, 0x018b},
    {class01FSetContextPattern,     0x018c, 0x018f},
    {class01FSetContextRop,         0x0190, 0x0193},
    {class01FSetContextBeta1,       0x0194, 0x0197},
    {class01FSetContextSurfaceSource, 0x0198, 0x019b},
    {class01FSetContextSurface,     0x019c, 0x019f},
    {class01FSetOperation,          0x02fc, 0x02ff},
    {class01FPointIn,               0x0300, 0x0303},
    {class01FPointOut,              0x0304, 0x0307},
    {class01FSize,                  0x0308, 0x030b}
};
METHOD Nv1ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class021Notify,                0x0104, 0x0107},
    {class021SetContextDmaNotifies, 0x0180, 0x0183},
    {class021SetContextColorKey,    0x0184, 0x0187},
    {class021SetContextClip,        0x0188, 0x018b},
    {class021SetContextPattern,     0x018c, 0x018f},
    {class021SetContextRop,         0x0190, 0x0193},
    {class021SetContextBeta1,       0x0194, 0x0197},
    {class021SetContextSurface,     0x0198, 0x019b},
    {class021SetOperation,          0x02fc, 0x02ff},
    {class021SetColorFormat,        0x0300, 0x0303},
    {class021Point,                 0x0304, 0x0307},
    {class021Size,                  0x0308, 0x030b},
    {class021SizeIn,                0x030c, 0x030f},
    {class021Color,                 0x0400, 0x047f}
};
METHOD Nv3StretchedImageFromCPUMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class036Notify,                0x0104, 0x0107},
    {class036SetContextDmaNotifies, 0x0180, 0x0183},
    {class036SetContextColorKey,    0x0184, 0x0187},
    {class036SetContextPattern,     0x0188, 0x018b},
    {class036SetContextRop,         0x018c, 0x018f},
    {class036SetContextBeta1,       0x0190, 0x0193},
    {class036SetContextSurface,     0x0194, 0x0197},
    {class036SetOperation,          0x02fc, 0x02ff},
    {class036SetColorFormat,        0x0300, 0x0303},
    {class036SizeIn,                0x0304, 0x0307},
    {class036DeltaDxDu,             0x0308, 0x030b},
    {class036DeltaDyDv,             0x030c, 0x030f},
    {class036Clip,                  0x0310, 0x0317},
    {class036Point12d4,             0x0318, 0x031b},
    {class036Color,                 0x0400, 0x1fff}
};
METHOD Nv3ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class037Notify,                0x0104, 0x0107},
    {class037SetContextDmaNotifies, 0x0180, 0x0183},
    {class037SetContextDmaImage,    0x0184, 0x0187},
    {class037SetContextPattern,     0x0188, 0x018b},
    {class037SetContextRop,         0x018c, 0x018f},
    {class037SetContextBeta1,       0x0190, 0x0193},
    {class037SetContextSurface,     0x0194, 0x0197},
    {class037SetColorFormat,        0x0300, 0x0303},
    {class037SetOperation,          0x0304, 0x0307},
    {class037Clip,                  0x0308, 0x030f},
    {class037RectangleOut,          0x0310, 0x0317},
    {class037DeltaDuDx,             0x0318, 0x031b},
    {class037DeltaDvDy,             0x031c, 0x031f},
    {class037ImageIn,               0x0400, 0x040f}
};
METHOD Nv3MemoryToMemoryFormatMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class039Notify,                0x0104, 0x0107},
    {class039SetContextDmaNotifies, 0x0180, 0x0183},
    {class039SetContextDmaBufferIn, 0x0184, 0x0187},
    {class039SetContextDmaBufferOut, 0x0188, 0x018b},
    {class039BufferTransfer,        0x030c, 0x032b}
};
METHOD Nv3DX3TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class048Notify,                0x0104, 0x0107},
    {class048SetContextDmaNotifies, 0x0180, 0x0183},
    {class048SetTextureCtxDma,      0x0184, 0x0187},
    {class048SetContextClip,        0x0188, 0x018b},
    {class048SetContextSurfaceColor, 0x018c, 0x018f},
    {class048SetContextSurfaceZeta, 0x0190, 0x0193},
    {class048TextureOffset,         0x0304, 0x0307},
    {class048TextureFormat,         0x0308, 0x030b},
    {class048Filter,                0x030c, 0x030f},
    {class048FogColor,              0x0310, 0x0313},
    {class048ControlOut0,           0x0314, 0x0317},
    {class048ControlOut1,           0x0318, 0x031b},
    {class048ControlPoint,          0x1000, 0x1fff}
};
METHOD Nv3GDIRectangleTextMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04BNotify,                0x0104, 0x0107},
    {class04BSetContextDmaNotifies, 0x0180, 0x0183},
    {class04BSetContextPattern,     0x0184, 0x0187},
    {class04BSetContextRop,         0x0188, 0x018b},
    {class04BSetContextBeta1,       0x018c, 0x018f},
    {class04BSetContextSurface,     0x0190, 0x0193},
    {class04BSetOperation,          0x02fc, 0x02ff},
    {class04BSetColorFormat,        0x0300, 0x0303},
    {class04BSetMonochromeFormat,   0x0304, 0x0307},
    {class04BColor1A,               0x03fc, 0x03ff},
    {class04BUnclippedRectangle,    0x0400, 0x05ff},
    {class04BClipB,                 0x07f4, 0x07fb},
    {class04BColor1B,               0x07fc, 0x07ff},
    {class04BClippedRectangle,      0x0800, 0x09ff},
    {class04BClipC,                 0x0bec, 0x0bf3},
    {class04BColor1C,               0x0bf4, 0x0bf7},
    {class04BSizeC,                 0x0bf8, 0x0bfb},
    {class04BPointC,                0x0bfc, 0x0bff},
    {class04BMonochromeColor1C,     0x0c00, 0x0dff},
    {class04BClipD,                 0x0fe8, 0x0fef},
    {class04BColor1D,               0x0ff0, 0x0ff3},
    {class04BSizeInD,               0x0ff4, 0x0ff7},
    {class04BSizeOutD,              0x0ff8, 0x0ffb},
    {class04BPointD,                0x0ffc, 0x0fff},
    {class04BMonochromeColor1D,     0x1000, 0x11ff},
    {class04BClipE,                 0x13e4, 0x13eb},
    {class04BColor0E,               0x13ec, 0x13ef},
    {class04BColor1E,               0x13f0, 0x13f3},
    {class04BSizeInE,               0x13f4, 0x13f7},
    {class04BSizeOutE,              0x13f8, 0x13fb},
    {class04BPointE,                0x13fc, 0x13ff},
    {class04BMonochromeColor01E,    0x1400, 0x15ff}
};
METHOD Nv3ExternalVideoDecoderMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04DNotify,                0x0104, 0x0107},
    {class04DStopTransferVbi,       0x0108, 0x010b},
    {class04DStopTransferImage,     0x010c, 0x010f},
    {class04DSetContextDmaNotifies, 0x0180, 0x0183},
    {class04DSetContextDmaVbi,      0x0184, 0x018b},
    {class04DSetContextDmaImage,    0x018c, 0x0193},
    {class04DSetImageConfig,        0x02f8, 0x02fb},
    {class04DSetImageStartLine,     0x02fc, 0x02ff},
    {class04DSetVbi,                0x0300, 0x0317},
    {class04DGetVbiOffsetNotify,    0x0318, 0x031f},
    {class04DSetImage,              0x0320, 0x033f},
    {class04DGetImageOffsetNotify,  0x0340, 0x0347}
};
METHOD Nv3ExternalVideoDecompressorMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04ENotify,                0x0104, 0x0107},
    {class04EStopTransfer,          0x0108, 0x010b},
    {class04ESetContextDmaNotifies, 0x0180, 0x0183},
    {class04ESetContextDmaData,     0x0184, 0x018b},
    {class04ESetContextDmaImage,    0x018c, 0x0193},
    {class04EReadData,              0x0300, 0x0317},
    {class04EWriteImage,            0x0318, 0x033f}
};
METHOD Nv1ExternalParallelBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04FNotify,                0x0104, 0x0107},
    {class04FStopTransfer,          0x0108, 0x010b},
    {class04FSetContextDmaNotifies, 0x0180, 0x0183},
    {class04FWrite,                 0x0300, 0x030b},
    {class04FRead,                  0x030c, 0x0317},
    {class04FSetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv3ExternalMonitorBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class050Notify,                0x0104, 0x0107},
    {class050StopTransfer,          0x0108, 0x010b},
    {class050SetContextDmaNotifies, 0x0180, 0x0183},
    {class050Write,                 0x0300, 0x030b},
    {class050Read,                  0x030c, 0x0317},
    {class050SetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv4ExternalSerialBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class051Notify,                0x0104, 0x0107},
    {class051StopTransfer,          0x0108, 0x010b},
    {class051SetContextDmaNotifies, 0x0180, 0x0183},
    {class051Write,                 0x0300, 0x030b},
    {class051Read,                  0x030c, 0x0317},
    {class051SetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv3ContextSurface0Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class058Notify,                0x0104, 0x0107},
    {class058SetContextDmaNotifies, 0x0180, 0x0183},
    {class058SetContextDmaImage,    0x0184, 0x0187},
    {class058SetColorFormat,        0x0300, 0x0303},
    {class058SetImagePitch,         0x0308, 0x030b},
    {class058SetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface1Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class059Notify,                0x0104, 0x0107},
    {class059SetContextDmaNotifies, 0x0180, 0x0183},
    {class059SetContextDmaImage,    0x0184, 0x0187},
    {class059SetColorFormat,        0x0300, 0x0303},
    {class059SetImagePitch,         0x0308, 0x030b},
    {class059SetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface2Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05ANotify,                0x0104, 0x0107},
    {class05ASetContextDmaNotifies, 0x0180, 0x0183},
    {class05ASetContextDmaImage,    0x0184, 0x0187},
    {class05ASetColorFormat,        0x0300, 0x0303},
    {class05ASetImagePitch,         0x0308, 0x030b},
    {class05ASetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface3Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05BNotify,                0x0104, 0x0107},
    {class05BSetContextDmaNotifies, 0x0180, 0x0183},
    {class05BSetContextDmaImage,    0x0184, 0x0187},
    {class05BSetColorFormat,        0x0300, 0x0303},
    {class05BSetImagePitch,         0x0308, 0x030b},
    {class05BSetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextRopMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class043Notify,                0x0104, 0x0107},
    {class043SetContextDmaNotifies, 0x0180, 0x0183},
    {class043SetRop5,               0x0300, 0x0303}
};
METHOD Nv4DvdSubpictureMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class038Notify,                0x0104, 0x0107},
    {class038SetContextDmaNotifies, 0x0180, 0x0183},
    {class038SetContextDmaOverlay,  0x0184, 0x0187},
    {class038SetContextDmaImageIn,  0x0188, 0x018b},
    {class038SetContextDmaImageOut, 0x018c, 0x018f},
    {class038ImageOutPoint,         0x0300, 0x0303},
    {class038ImageOutSize,          0x0304, 0x0307},
    {class038ImageOutFormat,        0x0308, 0x030b},
    {class038ImageOutOffset,        0x030c, 0x030f},
    {class038ImageInDeltaDuDx,      0x0310, 0x0313},
    {class038ImageInDeltaDvDy,      0x0314, 0x0317},
    {class038ImageInSize,           0x0318, 0x031b},
    {class038ImageInFormat,         0x031c, 0x031f},
    {class038ImageInOffset,         0x0320, 0x0323},
    {class038ImageInPoint,          0x0324, 0x0317},
    {class038OverlayDeltaDuDx,      0x0328, 0x032b},
    {class038OverlayDeltaDvDy,      0x032c, 0x032f},
    {class038OverlaySize,           0x0330, 0x0333},
    {class038OverlayFormat,         0x0334, 0x0337},
    {class038OverlayOffset,         0x0338, 0x033b},
    {class038OverlayPoint,          0x033c, 0x033f}
};
METHOD Nv4ContextSurfaces2DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class042Notify,                0x0104, 0x0107},
    {class042SetContextDmaNotifies, 0x0180, 0x0183},
    {class042SetContextDmaSource,   0x0184, 0x0187},
    {class042SetContextDmaDestin,   0x0188, 0x018b},
    {class042SetColorFormat,        0x0300, 0x0303},
    {class042SetPitch,              0x0304, 0x0307},
    {class042SetOffsetSource,       0x0308, 0x030b},
    {class042SetOffsetDestin,       0x030c, 0x030f}
};
METHOD Nv4ContextPatternMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class044Notify,                0x0104, 0x0107},
    {class044SetContextDmaNotifies, 0x0180, 0x0183},
    {class044SetColorFormat,        0x0300, 0x0303},
    {class044SetMonochromeFormat,   0x0304, 0x0307},
    {class044SetMonochromeShape,    0x0308, 0x030b},
    {class044SetPatternSelect,      0x030c, 0x030f},
    {class044SetMonochromeColor,    0x0310, 0x0317},
    {class044SetMonochromePattern,  0x0318, 0x031f},
    {class044SetPatternY8,          0x0400, 0x043f},
    {class044SetPatternR5G6B5,      0x0500, 0x057f},
    {class044SetPatternX8R8G8B8,    0x0700, 0x07ff}
};
METHOD Nv4GDIRectangleTextMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04ANotify,                0x0104, 0x0107},
    {class04ASetContextDmaNotifies, 0x0180, 0x0183},
    {class04ASetContextFonts,       0x0184, 0x0187},
    {class04ASetContextPattern,     0x0188, 0x018b},
    {class04ASetContextRop,         0x018c, 0x018f},
    {class04ASetContextBeta1,       0x0190, 0x0193},
    {class04ASetContextBeta4,       0x0194, 0x0197},
    {class04ASetContextSurface,     0x0198, 0x019b},
    {class04ASetOperation,          0x02fc, 0x02ff},
    {class04ASetColorFormat,        0x0300, 0x0303},
    {class04ASetMonochromeFormat,   0x0304, 0x0307},
    {class04AColor1A,               0x03fc, 0x03ff},
    {class04AUnclippedRectangle,    0x0400, 0x04ff},
    {class04AClipB,                 0x05f4, 0x05fb},
    {class04AColor1B,               0x05fc, 0x05ff},
    {class04AClippedRectangle,      0x0600, 0x06ff},
    {class04AClipC,                 0x07ec, 0x07f3},
    {class04AColor1C,               0x07f4, 0x07f7},
    {class04ASizeC,                 0x07f8, 0x07fb},
    {class04APointC,                0x07fc, 0x07ff},
    {class04AMonochromeColor1C,     0x0800, 0x09ff},
    {class04AClipE,                 0x0be4, 0x0beb},
    {class04AColor0E,               0x0bec, 0x0bef},
    {class04AColor1E,               0x0bf0, 0x0bf3},
    {class04ASizeInE,               0x0bf4, 0x0bf7},
    {class04ASizeOutE,              0x0bf8, 0x0bfb},
    {class04APointE,                0x0bfc, 0x0bff},
    {class04AMonochromeColor01E,    0x0c00, 0x0dff},
    {class04AFontF,                 0x0ff0, 0x0ff3},
    {class04AClipF,                 0x0ff4, 0x0ffb},
    {class04AColor1F,               0x0ffc, 0x0fff},
    {class04ACharacterColor1F,      0x1000, 0x13ff},
    {class04AFontG,                 0x17f0, 0x17f3},
    {class04AClipG,                 0x17f4, 0x17fb},
    {class04AColor1G,               0x17fc, 0x17ff},
    {class04ACharacterColor1G,      0x1800, 0x1fff}
};
METHOD Nv4ContextSurfaceSwizzledMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class052Notify,                0x0104, 0x0107},
    {class052SetContextDmaNotifies, 0x0180, 0x0183},
    {class052SetContextDmaImage,    0x0184, 0x0187},
    {class052SetFormat,             0x0300, 0x0303},
    {class052SetOffset,             0x0304, 0x0307}
};
METHOD Nv4ContextSurfacesArgbZsMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class053Notify,                0x0104, 0x0107},
    {class053SetContextDmaNotifies, 0x0180, 0x0183},
    {class053SetContextDmaColor,    0x0184, 0x0187},
    {class053SetContextDmaZeta,     0x0188, 0x018b},
    {class053SetClipHorizontal,     0x02f8, 0x02fb},
    {class053SetClipVertical,       0x02fc, 0x02ff},
    {class053SetFormat,             0x0300, 0x0303},
    {class053SetClipSize,           0x0304, 0x0307},
    {class053SetPitch,              0x0308, 0x030b},
    {class053SetOffsetColor,        0x030c, 0x030f},
    {class053SetOffsetZeta,         0x0310, 0x0313}
};
METHOD Nv4DX5TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class054Notify,                0x0104, 0x0107},
    {class054SetContextDmaNotifies, 0x0180, 0x0183},
    {class054SetContextDmaA,        0x0184, 0x0187},
    {class054SetContextDmaB,        0x0188, 0x018b},
    {class054SetContextSurface,     0x018c, 0x018f},
    {class054ColorKey,              0x0300, 0x0303},
    {class054Offset,                0x0304, 0x0307},
    {class054Format,                0x0308, 0x030b},
    {class054Filter,                0x030c, 0x030f},
    {class054Blend,                 0x0310, 0x0313},
    {class054Control,               0x0314, 0x0317},
    {class054FogColor,              0x0318, 0x031b},
    {class054Tlvertex,              0x0400, 0x05ff},
    {class054DrawPrimitive,         0x0600, 0x06ff}
};
METHOD Nv4DX6MultiTextureTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class055Notify,                0x0104, 0x0107},
    {class055SetContextDmaNotifies, 0x0180, 0x0183},
    {class055SetContextDmaA,        0x0184, 0x0187},
    {class055SetContextDmaB,        0x0188, 0x018b},
    {class055SetContextSurface,     0x018c, 0x018f},
    {class055Offset,                0x0308, 0x030f},
    {class055Format,                0x0310, 0x0317},
    {class055Filter,                0x0318, 0x031f},
    {class055Combine0Alpha,         0x0320, 0x0323},
    {class055Combine0Color,         0x0324, 0x0327},
    {class055Combine1Alpha,         0x032c, 0x032f},
    {class055Combine1Color,         0x0330, 0x0333},
    {class055CombineFactor,         0x0334, 0x0337},
    {class055Blend,                 0x0338, 0x033b},
    {class055Control,               0x033c, 0x0347},
    {class055FogColor,              0x0348, 0x034b},
    {class055Tlmtvertex,            0x0400, 0x053f},
    {class055DrawPrimitive,         0x0540, 0x05ff}
};
METHOD Nv10CelsiusPrimitiveMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class056Notify,                0x0104, 0x0107},
    {class056SetWarningEnable,      0x0108, 0x010b},
    //{class056GetState,              0x010c, 0x010f},
    {class056WaitForIdle,           0x0110, 0x0113},
    {class056PMTrigger,             0x0140, 0x0143},
    {class056SetContextDmaNotifies, 0x0180, 0x0183},
    {class056SetContextDmaA,        0x0184, 0x0187},
    {class056SetContextDmaB,        0x0188, 0x018b},
    {class056SetContextDmaVertex,   0x018c, 0x018f},
    {class056SetContextDmaState,    0x0190, 0x0193},
    {class056SetContextDmaColor,    0x0194, 0x0197},
    {class056SetContextDmaZeta,     0x0198, 0x019b},
    {class056MethodCatcher,         0x019c, 0x17ff},    // catch any in between methods
    //{class056SetMaterialEmission,   0x1628, 0x1633},    // HW workaround for NV10
    //{class056MethodCatcher,         0x1634, 0x17ff},    // catch any in between methods
    {class056InlineArray,           0x1800, 0x1fff},
};
METHOD Nv4ContextColorKeyMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class057Notify,                0x0104, 0x0107},
    {class057SetContextDmaNotifies, 0x0180, 0x0183},
    {class057SetColorFormat,        0x0300, 0x0303},
    {class057SetColor,              0x0304, 0x0307}
};
METHOD Nv4RenderSolidLinMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05CNotify,                0x0104, 0x0107},
    {class05CSetContextDmaNotifies, 0x0180, 0x0183},
    {class05CSetContextClip,        0x0184, 0x0187},
    {class05CSetContextPattern,     0x0188, 0x018b},
    {class05CSetContextRop,         0x018c, 0x018f},
    {class05CSetContextBeta1,       0x0190, 0x0193},
    {class05CSetContextBeta4,       0x0194, 0x0197},
    {class05CSetContextSurface,     0x0198, 0x019b},
    {class05CSetOperation,          0x02fc, 0x02ff},
    {class05CSetColorFormat,        0x0300, 0x0303},
    {class05CColor,                 0x0304, 0x0307},
    {class05CLin,                   0x0400, 0x047f},
    {class05CLin32,                 0x0480, 0x04ff},
    {class05CPolyLin,               0x0500, 0x057f},
    {class05CPolyLin32,             0x0580, 0x05ff},
    {class05CColorPolyLin,          0x0600, 0x067f}
};
METHOD Nv4RenderSolidTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05DNotify,                0x0104, 0x0107},
    {class05DSetContextDmaNotifies, 0x0180, 0x0183},
    {class05DSetContextClip,        0x0184, 0x0187},
    {class05DSetContextPattern,     0x0188, 0x018b},
    {class05DSetContextRop,         0x018c, 0x018f},
    {class05DSetContextBeta1,       0x0190, 0x0193},
    {class05DSetContextBeta4,       0x0194, 0x0197},
    {class05DSetContextSurface,     0x0198, 0x019b},
    {class05DSetOperation,          0x02fc, 0x02ff},
    {class05DSetColorFormat,        0x0300, 0x0303},
    {class05DColor,                 0x0304, 0x0307},
    {class05DTriangle,              0x0310, 0x031b},
    {class05DTriangle32,            0x0320, 0x0337},
    {class05DTrimesh,               0x0400, 0x047f},
    {class05DTrimesh32,             0x0480, 0x04ff},
    {class05DColorTriangle,         0x0500, 0x057f},
    {class05DColorTrimesh,          0x0580, 0x05ff}
};
METHOD Nv4RenderSolidRectangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05ENotify,                0x0104, 0x0107},
    {class05ESetContextDmaNotifies, 0x0180, 0x0183},
    {class05ESetContextClip,        0x0184, 0x0187},
    {class05ESetContextPattern,     0x0188, 0x018b},
    {class05ESetContextRop,         0x018c, 0x018f},
    {class05ESetContextBeta1,       0x0190, 0x0193},
    {class05ESetContextBeta4,       0x0194, 0x0197},
    {class05ESetContextSurface,     0x0198, 0x019b},
    {class05ESetOperation,          0x02fc, 0x02ff},
    {class05ESetColorFormat,        0x0300, 0x0303},
    {class05EColor,                 0x0304, 0x0307},
    {class05ERectangle,             0x0400, 0x047f}
};
METHOD Nv4ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05FNotify,                0x0104, 0x0107},
    {class05FSetContextDmaNotifies, 0x0180, 0x0183},
    {class05FSetContextColorKey,    0x0184, 0x0187},
    {class05FSetContextClip,        0x0188, 0x018b},
    {class05FSetContextPattern,     0x018c, 0x018f},
    {class05FSetContextRop,         0x0190, 0x0193},
    {class05FSetContextBeta1,       0x0194, 0x0197},
    {class05FSetContextBeta4,       0x0198, 0x019b},
    {class05FSetContextSurfaces2d,  0x019c, 0x019f},
    {class05FSetOperation,          0x02fc, 0x02ff},
    {class05FControlPointIn,        0x0300, 0x0303},
    {class05FControlPointOut,       0x0304, 0x0307},
    {class05FSize,                  0x0308, 0x030b}
};
METHOD Nv4IndexedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class060Notify,                0x0104, 0x0107},
    {class060SetContextDmaNotifies, 0x0180, 0x0183},
    {class060SetContextDmaLut,      0x0184, 0x0187},
    {class060SetContextColorKey,    0x0188, 0x018b},
    {class060SetContextClip,        0x018c, 0x018f},
    {class060SetContextPattern,     0x0190, 0x0193},
    {class060SetContextRop,         0x0194, 0x0197},
    {class060SetContextBeta1,       0x0198, 0x019b},
    {class060SetContextBeta4,       0x019c, 0x019f},
    {class060SetContextSurface,     0x01a0, 0x01a3},
    {class060SetColorConversion,    0x03e0, 0x03e3},
    {class060SetOperation,          0x03e4, 0x03e7},
    {class060SetColorFormat,        0x03e8, 0x03eb},
    {class060IndexFormat,           0x03ec, 0x03ef},
    {class060LutOffset,             0x03f0, 0x03f3},
    {class060Point,                 0x03f4, 0x03f7},
    {class060SizeOut,               0x03f8, 0x03fb},
    {class060SizeIn,                0x03fc, 0x03ff},
    {class060Indices,               0x0400, 0x1fff}
};
METHOD Nv4ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class061Notify,                0x0104, 0x0107},
    {class061SetContextDmaNotifies, 0x0180, 0x0183},
    {class061SetContextColorKey,    0x0184, 0x0187},
    {class061SetContextClip,        0x0188, 0x018b},
    {class061SetContextPattern,     0x018c, 0x018f},
    {class061SetContextRop,         0x0190, 0x0193},
    {class061SetContextBeta1,       0x0194, 0x0197},
    {class061SetContextBeta4,       0x0198, 0x019b},
    {class061SetContextSurface,     0x019c, 0x019f},
    {class061SetOperation,          0x02fc, 0x02ff},
    {class061SetColorFormat,        0x0300, 0x0303},
    {class061Point,                 0x0304, 0x0307},
    {class061SizeOut,               0x0308, 0x030b},
    {class061SizeIn,                0x030c, 0x030f},
    {class061Color,                 0x0400, 0x1fff}
};

METHOD Nv5ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class063Notify,                0x0104, 0x0107},
    {class063SetContextDmaNotifies, 0x0180, 0x0183},
    {class063SetContextDmaImage,    0x0184, 0x0187},
    {class063SetContextPattern,     0x0188, 0x018b},
    {class063SetContextRop,         0x018c, 0x018f},
    {class063SetContextBeta1,       0x0190, 0x0193},
    {class063SetContextBeta4,       0x0194, 0x0197},
    {class063SetContextSurface,     0x0198, 0x019b},
    {class063SetColorConversion,    0x02fc, 0x02ff},
    {class063SetColorFormat,        0x0300, 0x0303},
    {class063SetOperation,          0x0304, 0x0307},
    {class063Clip,                  0x0308, 0x030f},
    {class063RectangleOut,          0x0310, 0x0317},
    {class063DeltaDuDx,             0x0318, 0x031b},
    {class063DeltaDvDy,             0x031c, 0x031f},
    {class063ImageIn,               0x0400, 0x040f}
};

METHOD Nv5IndexedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class064Notify,                0x0104, 0x0107},
    {class064SetContextDmaNotifies, 0x0180, 0x0183},
    {class064SetContextDmaLut,      0x0184, 0x0187},
    {class064SetContextColorKey,    0x0188, 0x018b},
    {class064SetContextClip,        0x018c, 0x018f},
    {class064SetContextPattern,     0x0190, 0x0193},
    {class064SetContextRop,         0x0194, 0x0197},
    {class064SetContextBeta1,       0x0198, 0x019b},
    {class064SetContextBeta4,       0x019c, 0x019f},
    {class064SetContextSurface,     0x01a0, 0x01a3},
    {class064SetColorConversion,    0x03e0, 0x03e3},
    {class064SetOperation,          0x03e4, 0x03e7},
    {class064SetColorFormat,        0x03e8, 0x03eb},
    {class064IndexFormat,           0x03ec, 0x03ef},
    {class064LutOffset,             0x03f0, 0x03f3},
    {class064Point,                 0x03f4, 0x03f7},
    {class064SizeOut,               0x03f8, 0x03fb},
    {class064SizeIn,                0x03fc, 0x03ff},
    {class064Indices,               0x0400, 0x1fff}
};

METHOD Nv5ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class065Notify,                0x0104, 0x0107},
    {class065SetContextDmaNotifies, 0x0180, 0x0183},
    {class065SetContextColorKey,    0x0184, 0x0187},
    {class065SetContextClip,        0x0188, 0x018b},
    {class065SetContextPattern,     0x018c, 0x018f},
    {class065SetContextRop,         0x0190, 0x0193},
    {class065SetContextBeta1,       0x0194, 0x0197},
    {class065SetContextBeta4,       0x0198, 0x019b},
    {class065SetContextSurface,     0x019c, 0x019f},
    {class065SetColorConversion,    0x02f8, 0x02fb},
    {class065SetOperation,          0x02fc, 0x02ff},
    {class065SetColorFormat,        0x0300, 0x0303},
    {class065Point,                 0x0304, 0x0307},
    {class065SizeOut,               0x0308, 0x030b},
    {class065SizeIn,                0x030c, 0x030f},
    {class065Color,                 0x0400, 0x1fff}
};
METHOD Nv5StretchedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class066Notify,                0x0104, 0x0107},
    {class066SetContextDmaNotifies, 0x0180, 0x0183},
    {class066SetContextColorKey,    0x0184, 0x0187},
    {class066SetContextPattern,     0x0188, 0x018b},
    {class066SetContextRop,         0x018c, 0x018f},
    {class066SetContextBeta1,       0x0190, 0x0193},
    {class066SetContextBeta4,       0x0194, 0x0197},
    {class066SetContextSurface,     0x0198, 0x019b},
    {class066SetColorConversion,    0x02f8, 0x02fb},
    {class066SetOperation,          0x02fc, 0x02ff},
    {class066SetColorFormat,        0x0300, 0x0303},
    {class066SizeIn,                0x0304, 0x0307},
    {class066DeltaDxDu,             0x0308, 0x030b},
    {class066DeltaDyDv,             0x030c, 0x030f},
    {class066Clip,                  0x0310, 0x0317},
    {class066Point12d4,             0x0318, 0x031b},
    {class066Color,                 0x0400, 0x1fff}
};
METHOD Nv4ContextBetaMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class072Notify,                0x0104, 0x0107},
    {class072SetContextDmaNotifies, 0x0180, 0x0183},
    {class072SetBetaFactor,         0x0300, 0x0303}
};
METHOD Nv4StretchedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class076Notify,                0x0104, 0x0107},
    {class076SetContextDmaNotifies, 0x0180, 0x0183},
    {class076SetContextColorKey,    0x0184, 0x0187},
    {class076SetContextPattern,     0x0188, 0x018b},
    {class076SetContextRop,         0x018c, 0x018f},
    {class076SetContextBeta1,       0x0190, 0x0193},
    {class076SetContextBeta4,       0x0194, 0x0197},
    {class076SetContextSurface,     0x0198, 0x019b},
    {class076SetOperation,          0x02fc, 0x02ff},
    {class076SetColorFormat,        0x0300, 0x0303},
    {class076SizeIn,                0x0304, 0x0307},
    {class076DeltaDxDu,             0x0308, 0x030b},
    {class076DeltaDyDv,             0x030c, 0x030f},
    {class076Clip,                  0x0310, 0x0317},
    {class076Point12d4,             0x0318, 0x031b},
    {class076Color,                 0x0400, 0x1fff}
};
METHOD Nv4ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class077Notify,                0x0104, 0x0107},
    {class077SetContextDmaNotifies, 0x0180, 0x0183},
    {class077SetContextDmaImage,    0x0184, 0x0187},
    {class077SetContextPattern,     0x0188, 0x018b},
    {class077SetContextRop,         0x018c, 0x018f},
    {class077SetContextBeta1,       0x0190, 0x0193},
    {class077SetContextBeta4,       0x0194, 0x0197},
    {class077SetContextSurface,     0x0198, 0x019b},
    {class077SetColorFormat,        0x0300, 0x0303},
    {class077SetOperation,          0x0304, 0x0307},
    {class077Clip,                  0x0308, 0x030f},
    {class077RectangleOut,          0x0310, 0x0317},
    {class077DeltaDuDx,             0x0318, 0x031b},
    {class077DeltaDvDy,             0x031c, 0x031f},
    {class077ImageIn,               0x0400, 0x040f}
};
METHOD Nv10ContextSurfaces2DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class062Notify,                0x0104, 0x0107},
    {class062SetContextDmaNotifies, 0x0180, 0x0183},
    {class062SetContextDmaSource,   0x0184, 0x0187},
    {class062SetContextDmaDestin,   0x0188, 0x018b},
    {class062SetColorFormat,        0x0300, 0x0303},
    {class062SetPitch,              0x0304, 0x0307},
    {class062SetOffsetSource,       0x0308, 0x030b},
    {class062SetOffsetDestin,       0x030c, 0x030f}
};
METHOD Nv10TextureFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07BNotify,                0x0104, 0x0107},
    {class07BSetContextDmaNotifies, 0x0180, 0x0183},
    {class07BSetContextSurface,     0x0184, 0x0187},
    {class07BSetColorFormat,        0x0300, 0x0303},
    {class07BPoint,                 0x0304, 0x0307},
    {class07BSize,                  0x0308, 0x030b},
    {class07BClipHorizontal,        0x030c, 0x030f},
    {class07BClipVertical,          0x0310, 0x0313},
    {class07BColor,                 0x0400, 0x1fff}
};
METHOD Nv10DvdSubpictureMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class088Notify,                0x0104, 0x0107},
    {class088SetContextDmaNotifies, 0x0180, 0x0183},
    {class088SetContextDmaOverlay,  0x0184, 0x0187},
    {class088SetContextDmaImageIn,  0x0188, 0x018b},
    {class088SetContextDmaImageOut, 0x018c, 0x018f},
    {class088ImageOutPoint,         0x0300, 0x0303},
    {class088ImageOutSize,          0x0304, 0x0307},
    {class088ImageOutFormat,        0x0308, 0x030b},
    {class088ImageOutOffset,        0x030c, 0x030f},
    {class088ImageInDeltaDuDx,      0x0310, 0x0313},
    {class088ImageInDeltaDvDy,      0x0314, 0x0317},
    {class088ImageInSize,           0x0318, 0x031b},
    {class088ImageInFormat,         0x031c, 0x031f},
    {class088ImageInOffset,         0x0320, 0x0323},
    {class088ImageInPoint,          0x0324, 0x0317},
    {class088OverlayDeltaDuDx,      0x0328, 0x032b},
    {class088OverlayDeltaDvDy,      0x032c, 0x032f},
    {class088OverlaySize,           0x0330, 0x0333},
    {class088OverlayFormat,         0x0334, 0x0337},
    {class088OverlayOffset,         0x0338, 0x033b},
    {class088OverlayPoint,          0x033c, 0x033f}
};
METHOD Nv10ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class089Notify,                0x0104, 0x0107},
    {class089SetContextDmaNotifies, 0x0180, 0x0183},
    {class089SetContextDmaImage,    0x0184, 0x0187},
    {class089SetContextPattern,     0x0188, 0x018b},
    {class089SetContextRop,         0x018c, 0x018f},
    {class089SetContextBeta1,       0x0190, 0x0193},
    {class089SetContextBeta4,       0x0194, 0x0197},
    {class089SetContextSurface,     0x0198, 0x019b},
    {class089SetColorConversion,    0x02fc, 0x02ff},
    {class089SetColorFormat,        0x0300, 0x0303},
    {class089SetOperation,          0x0304, 0x0307},
    {class089Clip,                  0x0308, 0x030f},
    {class089RectangleOut,          0x0310, 0x0317},
    {class089DeltaDuDx,             0x0318, 0x031b},
    {class089DeltaDvDy,             0x031c, 0x031f},
    {class089ImageIn,               0x0400, 0x040f}
};
METHOD Nv10ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class08ANotify,                0x0104, 0x0107},
    {class08ASetContextDmaNotifies, 0x0180, 0x0183},
    {class08ASetContextColorKey,    0x0184, 0x0187},
    {class08ASetContextClip,        0x0188, 0x018b},
    {class08ASetContextPattern,     0x018c, 0x018f},
    {class08ASetContextRop,         0x0190, 0x0193},
    {class08ASetContextBeta1,       0x0194, 0x0197},
    {class08ASetContextBeta4,       0x0198, 0x019b},
    {class08ASetContextSurface,     0x019c, 0x019f},
    {class08ASetColorConversion,    0x02f8, 0x02fb},
    {class08ASetOperation,          0x02fc, 0x02ff},
    {class08ASetColorFormat,        0x0300, 0x0303},
    {class08APoint,                 0x0304, 0x0307},
    {class08ASizeOut,               0x0308, 0x030b},
    {class08ASizeIn,                0x030c, 0x030f},
    {class08AColor,                 0x0400, 0x1fff}
};
METHOD Nv10ContextSurfaces3DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class093Notify,                0x0104, 0x0107},
    {class093SetContextDmaNotifies, 0x0180, 0x0183},
    {class093SetContextDmaColor,    0x0184, 0x0187},
    {class093SetContextDmaZeta,     0x0188, 0x018b},
    {class093SetClipHorizontal,     0x02f8, 0x02fb},
    {class093SetClipVertical,       0x02fc, 0x02ff},
    {class093SetFormat,             0x0300, 0x0303},
    {class093SetClipSize,           0x0304, 0x0307},
    {class093SetPitch,              0x0308, 0x030b},
    {class093SetOffsetColor,        0x030c, 0x030f},
    {class093SetOffsetZeta,         0x0310, 0x0313}
};
METHOD Nv10DX5TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class094Notify,                0x0104, 0x0107},
    {class094SetContextDmaNotifies, 0x0180, 0x0183},
    {class094SetContextDmaA,        0x0184, 0x0187},
    {class094SetContextDmaB,        0x0188, 0x018b},
    {class094SetContextSurface,     0x018c, 0x018f},
    {class094ColorKey,              0x0300, 0x0303},
    {class094Offset,                0x0304, 0x0307},
    {class094Format,                0x0308, 0x030b},
    {class094Filter,                0x030c, 0x030f},
    {class094Blend,                 0x0310, 0x0313},
    {class094Control,               0x0314, 0x0317},
    {class094FogColor,              0x0318, 0x031b},
    {class094Tlvertex,              0x0400, 0x05ff},
    {class094DrawPrimitive,         0x0600, 0x06ff}
};
METHOD Nv10DX6MultiTextureTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class095Notify,                0x0104, 0x0107},
    {class095SetContextDmaNotifies, 0x0180, 0x0183},
    {class095SetContextDmaA,        0x0184, 0x0187},
    {class095SetContextDmaB,        0x0188, 0x018b},
    {class095SetContextSurface,     0x018c, 0x018f},
    {class095Offset,                0x0308, 0x030f},
    {class095Format,                0x0310, 0x0317},
    {class095Filter,                0x0318, 0x031f},
    {class095Combine0Alpha,         0x0320, 0x0323},
    {class095Combine0Color,         0x0324, 0x0327},
    {class095Combine1Alpha,         0x032c, 0x032f},
    {class095Combine1Color,         0x0330, 0x0333},
    {class095CombineFactor,         0x0334, 0x0337},
    {class095Blend,                 0x0338, 0x033b},
    {class095Control,               0x033c, 0x0347},
    {class095FogColor,              0x0348, 0x034b},
    {class095Tlmtvertex,            0x0400, 0x053f},
    {class095DrawPrimitive,         0x0540, 0x05ff}
};
METHOD Nv15CelsiusPrimitiveMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class096Notify,                0x0104, 0x0107},
    {class096SetWarningEnable,      0x0108, 0x010b},
    //{class096GetState,              0x010c, 0x010f},
    {class096WaitForIdle,           0x0110, 0x0113},
    {class096SyncSetRead,           0x0120, 0x0123},
    {class096SyncSetWrite,          0x0124, 0x0127},
    {class096SyncSetModulo,         0x0128, 0x012b},
    {class096SyncIncrementWrite,    0x012c, 0x012f},
    {class096SyncStall,             0x0130, 0x0133},
    {class096PMTrigger,             0x0140, 0x0143},
    {class096SetContextDmaNotifies, 0x0180, 0x0183},
    {class096SetContextDmaA,        0x0184, 0x0187},
    {class096SetContextDmaB,        0x0188, 0x018b},
    {class096SetContextDmaVertex,   0x018c, 0x018f},
    {class096SetContextDmaState,    0x0190, 0x0193},
    {class096SetContextDmaColor,    0x0194, 0x0197},
    {class096SetContextDmaZeta,     0x0198, 0x019b},
    //...
    // for now, catch anything in between
    {class096MethodCatcher,         0x0200, 0x17ff},
    //...
    {class096InlineArray,           0x1800, 0x1fff},
    {class096DebugInit,             0x2000, 0x2027}
};
METHOD Nv15ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class09FNotify,                0x0104, 0x0107},
    {class09FSyncSetRead,           0x0120, 0x0123},
    {class09FSyncSetWrite,          0x0124, 0x0127},
    {class09FSyncSetModulo,         0x0128, 0x012b},
    {class09FSyncIncrementWrite,    0x012c, 0x012f},
    {class09FSyncStall,             0x0130, 0x0133},
    {class09FSyncIncrementReadRange,0x0134, 0x0137},
    {class09FSetContextDmaNotifies, 0x0180, 0x0183},
    {class09FSetContextColorKey,    0x0184, 0x0187},
    {class09FSetContextClip,        0x0188, 0x018b},
    {class09FSetContextPattern,     0x018c, 0x018f},
    {class09FSetContextRop,         0x0190, 0x0193},
    {class09FSetContextBeta1,       0x0194, 0x0197},
    {class09FSetContextBeta4,       0x0198, 0x019b},
    {class09FSetContextSurfaces2d,  0x019c, 0x019f},
    {class09FSetOperation,          0x02fc, 0x02ff},
    {class09FControlPointIn,        0x0300, 0x0303},
    {class09FControlPointOut,       0x0304, 0x0307},
    {class09FSize,                  0x0308, 0x030b}
};

//
// These classes are supported across all chips.
//
CLASSDESCRIPTOR Common_ClassDescriptors[] =
{
    MKCLASSDECL(TMR_ENGINE_TAG, 0, NV01_TIMER),

    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_COLOR_KEY),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_SCALER),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_FROM_MEMORY),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_COLORMAP),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_SINK),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_PATCHCORD_VIDEO),

    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_FROM_MEMORY),
    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_TO_MEMORY),
    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_IN_MEMORY),

    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_SYSTEM),
    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_LOCAL_PRIVILEGED),
    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_LOCAL_USER),

    // MAKE THIS LAST !!!!
    MKCLASSDECL(CLASS_PSEUDO_ENGINE_TAG, 0, NV_CLASS),
};

#define NUM_COMMONCLASSDESCRIPTORS          (sizeof (Common_ClassDescriptors) / sizeof (CLASSDESCRIPTOR))

CLASSMETHODS classMethodsTable[] =
{
    {NV1_CLASS,                             NULL, 0},

    {NV1_CONTEXT_DMA_FROM_MEMORY,           NULL, 0},

    {NV1_CONTEXT_DMA_TO_MEMORY,             NULL, 0},

    {NV1_TIMER,                             Nv1TimerMethods,
                                            sizeof(Nv1TimerMethods)/sizeof(METHOD)},

    {NV1_BETA_SOLID,                        Nv1BetaSolidMethods,
                                            sizeof(Nv1BetaSolidMethods)/sizeof(METHOD)},

    {NV1_IMAGE_SOLID,                       Nv1ImageSolidMethods,
                                            sizeof(Nv1ImageSolidMethods)/sizeof(METHOD)},

    {NV1_IMAGE_PATTERN,                     Nv1ImagePatternMethods,
                                            sizeof(Nv1ImagePatternMethods)/sizeof(METHOD)},

    {NV1_IMAGE_BLACK_RECTANGLE,             Nv1ImageRectangleBlackMethods,
                                            sizeof(Nv1ImageRectangleBlackMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_LIN,                  Nv1RenderSolidLinMethods,
                                            sizeof(Nv1RenderSolidLinMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_TRIANGLE,             Nv1RenderSolidTriangleMethods,
                                            sizeof(Nv1RenderSolidTriangleMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_RECTANGLE,            Nv1RenderSolidRectangleMethods,
                                            sizeof(Nv1RenderSolidRectangleMethods)/sizeof(METHOD)},

    {NV1_IMAGE_BLIT,                        Nv1ImageBlitMethods,
                                            sizeof(Nv1ImageBlitMethods)/sizeof(METHOD)},

    {NV1_IMAGE_FROM_CPU,                    Nv1ImageFromCpuMethods,
                                            sizeof(Nv1ImageFromCpuMethods)/sizeof(METHOD)},

    {NV1_NULL,                              NULL, 0},

    {NV3_STRETCHED_IMAGE_FROM_CPU,          Nv3StretchedImageFromCPUMethods,
                                            sizeof(Nv3StretchedImageFromCPUMethods)/sizeof(METHOD)},


    {NV3_SCALED_IMAGE_FROM_MEMORY,          Nv3ScaledImageFromMemoryMethods,
                                            sizeof(Nv3ScaledImageFromMemoryMethods)/sizeof(METHOD)},

                                            
    {NV3_MEMORY_TO_MEMORY_FORMAT,           Nv3MemoryToMemoryFormatMethods,
                                            sizeof(Nv3MemoryToMemoryFormatMethods)/sizeof(METHOD)},
                                            
    {NV1_CONTEXT_DMA_IN_MEMORY,             NULL, 0},

    {NV_CONTEXT_ERROR_TO_MEMORY,            NULL, 0},

    {NV1_CONTEXT_ERROR_TO_MEMORY,           NULL, 0},

    {NV1_MEMORY_PRIVILEGED,                 NULL, 0},

    {NV1_MEMORY_USER,                       NULL, 0},

    {NV3_CONTEXT_ROP,                       Nv3ContextRopMethods,
                                            sizeof(Nv3ContextRopMethods)/sizeof(METHOD)},

    {NV04_VIDEO_LUT_CURSOR_DAC,             Nv04VideoLUTCursorDACMethods,
                                            sizeof(Nv04VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV04_VIDEO_OVERLAY,                    Nv04VideoOverlayMethods,
                                            sizeof(Nv04VideoOverlayMethods)/sizeof(METHOD)},

    {NV3_DX3_TEXTURED_TRIANGLE,             Nv3DX3TexturedTriangleMethods,
                                            sizeof(Nv3DX3TexturedTriangleMethods)/sizeof(METHOD)},

    {NV05_VIDEO_LUT_CURSOR_DAC,             Nv05VideoLUTCursorDACMethods,        
                                            sizeof(Nv05VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV3_GDI_RECTANGLE_TEXT,                Nv3GDIRectangleTextMethods,   
                                            sizeof(Nv3GDIRectangleTextMethods)/sizeof(METHOD)},

    {NV03_EXTERNAL_VIDEO_DECODER,           Nv3ExternalVideoDecoderMethods,
                                            sizeof(Nv3ExternalVideoDecoderMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_VIDEO_DECOMPRESSOR,       Nv3ExternalVideoDecompressorMethods,   
                                            sizeof(Nv3ExternalVideoDecompressorMethods)/sizeof(METHOD)},

    {NV1_EXTERNAL_PARALLEL_BUS,             Nv1ExternalParallelBusMethods,
                                            sizeof(Nv1ExternalParallelBusMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_MONITOR_BUS,              Nv3ExternalMonitorBusMethods,
                                            sizeof(Nv3ExternalMonitorBusMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_SERIAL_BUS,               Nv4ExternalSerialBusMethods,
                                            sizeof(Nv4ExternalSerialBusMethods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_0,                 Nv3ContextSurface0Methods,
                                            sizeof(Nv3ContextSurface0Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_1,                 Nv3ContextSurface1Methods,   
                                            sizeof(Nv3ContextSurface1Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_2,                 Nv3ContextSurface2Methods,   
                                            sizeof(Nv3ContextSurface2Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_3,                 Nv3ContextSurface3Methods,   
                                            sizeof(Nv3ContextSurface3Methods)/sizeof(METHOD)},

    {NV4_DVD_SUBPICTURE,                    Nv4DvdSubpictureMethods,
                                            sizeof(Nv4DvdSubpictureMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACES_2D,               Nv4ContextSurfaces2DMethods,
                                            sizeof(Nv4ContextSurfaces2DMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_PATTERN,                   Nv4ContextPatternMethods,
                                            sizeof(Nv4ContextPatternMethods)/sizeof(METHOD)},

    {NV4_GDI_RECTANGLE_TEXT,                Nv4GDIRectangleTextMethods,
                                            sizeof(Nv4GDIRectangleTextMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACE_SWIZZLED,          Nv4ContextSurfaceSwizzledMethods,
                                            sizeof(Nv4ContextSurfaceSwizzledMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACES_ARGB_ZS,          Nv4ContextSurfacesArgbZsMethods,
                                            sizeof(Nv4ContextSurfacesArgbZsMethods)/sizeof(METHOD)},

    {NV4_DX5_TEXTURED_TRIANGLE,             Nv4DX5TexturedTriangleMethods,
                                            sizeof(Nv4DX5TexturedTriangleMethods)/sizeof(METHOD)},

    {NV4_DX6_MULTI_TEXTURE_TRIANGLE,        Nv4DX6MultiTextureTriangleMethods,
                                            sizeof(Nv4DX6MultiTextureTriangleMethods)/sizeof(METHOD)},

    {NV10_CELSIUS_PRIMITIVE,                Nv10CelsiusPrimitiveMethods,
                                            sizeof(Nv10CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_COLOR_KEY,                 Nv4ContextColorKeyMethods,
                                            sizeof(Nv4ContextColorKeyMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_LIN,                  Nv4RenderSolidLinMethods,
                                            sizeof(Nv4RenderSolidLinMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_TRIANGLE,             Nv4RenderSolidTriangleMethods,
                                            sizeof(Nv4RenderSolidTriangleMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_RECTANGLE,            Nv4RenderSolidRectangleMethods,
                                            sizeof(Nv4RenderSolidRectangleMethods)/sizeof(METHOD)},

    {NV4_IMAGE_BLIT,                        Nv4ImageBlitMethods,
                                            sizeof(Nv4ImageBlitMethods)/sizeof(METHOD)},

    {NV4_INDEXED_IMAGE_FROM_CPU,            Nv4IndexedImageFromCpuMethods,   
                                            sizeof(Nv4IndexedImageFromCpuMethods)/sizeof(METHOD)},

    {NV4_IMAGE_FROM_CPU,                    Nv4ImageFromCpuMethods,   
                                            sizeof(Nv4ImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_SCALED_IMAGE_FROM_MEMORY,         Nv5ScaledImageFromMemoryMethods,   
                                            sizeof(Nv5ScaledImageFromMemoryMethods)/sizeof(METHOD)},

    {NV05_INDEXED_IMAGE_FROM_CPU,           Nv5IndexedImageFromCpuMethods,
                                            sizeof(Nv5IndexedImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_IMAGE_FROM_CPU,                   Nv5ImageFromCpuMethods,
                                            sizeof(Nv5ImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_STRETCHED_IMAGE_FROM_CPU,         Nv5StretchedImageFromCpuMethods,
                                            sizeof(Nv5StretchedImageFromCpuMethods)/sizeof(METHOD)},

    {NV10_VIDEO_LUT_CURSOR_DAC,             Nv10VideoLUTCursorDACMethods,
                                            sizeof(Nv10VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_BETA,                      Nv4ContextBetaMethods,
                                            sizeof(Nv4ContextBetaMethods)/sizeof(METHOD)},

    {NV4_STRETCHED_IMAGE_FROM_CPU,          Nv4StretchedImageFromCpuMethods,
                                            sizeof(Nv4StretchedImageFromCpuMethods)/sizeof(METHOD)},

    {NV4_SCALED_IMAGE_FROM_MEMORY,          Nv4ScaledImageFromMemoryMethods,
                                            sizeof(Nv4ScaledImageFromMemoryMethods)/sizeof(METHOD)},

    {NV_VIDEO_COLOR_KEY,                    NvVideoColorKeyMethods,
                                            sizeof(NvVideoColorKeyMethods)/sizeof(METHOD)},

    {NV_VIDEO_SCALER,                       NvVideoScalerMethods,
                                            sizeof(NvVideoScalerMethods)/sizeof(METHOD)},

    {NV_VIDEO_FROM_MEMORY,                  NvVideoFromMemoryMethods,
                                            sizeof(NvVideoFromMemoryMethods)/sizeof(METHOD)},

    {NV_VIDEO_COLORMAP,                     NvVideoColormapMethods,   
                                            sizeof(NvVideoColormapMethods)/sizeof(METHOD)},

    {NV_VIDEO_SINK,                         NvVideoSinkMethods,   
                                            sizeof(NvVideoSinkMethods)/sizeof(METHOD)},

    {NV_PATCHCORD_VIDEO,                    NvPatchcordMethods,
                                            sizeof(NvPatchcordMethods)/sizeof(METHOD)},

    {NV_CONTEXT_DMA_IN_MEMORY,              NvDmaInMemoryMethods,
                                            sizeof(NvDmaInMemoryMethods)/sizeof(METHOD)},
                                            
    {NV_CONTEXT_DMA_TO_MEMORY,              NvDmaToMemoryMethods,
                                            sizeof(NvDmaToMemoryMethods)/sizeof(METHOD)},
                                            
    {NV_CONTEXT_DMA_FROM_MEMORY,            NvDmaFromMemoryMethods,
                                            sizeof(NvDmaFromMemoryMethods)/sizeof(METHOD)},
                                            
    {NV10_CONTEXT_SURFACES_2D,              Nv10ContextSurfaces2DMethods,
                                            sizeof(Nv10ContextSurfaces2DMethods)/sizeof(METHOD)},

    {NV10_VIDEO_OVERLAY,                    Nv10VideoOverlayMethods,
                                            sizeof(Nv10VideoOverlayMethods)/sizeof(METHOD)},

    {NV10_TEXTURE_FROM_CPU,                 Nv10TextureFromCpuMethods,
                                            sizeof(Nv10TextureFromCpuMethods)/sizeof(METHOD)},

    {NV15_VIDEO_LUT_CURSOR_DAC,             Nv15VideoLUTCursorDACMethods,
                                            sizeof(Nv15VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV10_DVD_SUBPICTURE,                   Nv10DvdSubpictureMethods,
                                            sizeof(Nv10DvdSubpictureMethods)/sizeof(METHOD)},
                                            
    {NV10_SCALED_IMAGE_FROM_MEMORY,         Nv10ScaledImageFromMemoryMethods,
                                            sizeof(Nv10ScaledImageFromMemoryMethods)/sizeof(METHOD)},
                                            
    {NV10_IMAGE_FROM_CPU,                   Nv10ImageFromCpuMethods,
                                            sizeof(Nv10ImageFromCpuMethods)/sizeof(METHOD)},

    {NV10_CONTEXT_SURFACES_3D,              Nv10ContextSurfaces3DMethods,   
                                            sizeof(Nv10ContextSurfaces3DMethods)/sizeof(METHOD)},

    {NV10_DX5_TEXTURED_TRIANGLE,            Nv10DX5TexturedTriangleMethods,
                                            sizeof(Nv10DX5TexturedTriangleMethods)/sizeof(METHOD)},

    {NV10_DX6_MULTI_TEXTURE_TRIANGLE,       Nv10DX6MultiTextureTriangleMethods,
                                            sizeof(Nv10DX6MultiTextureTriangleMethods)/sizeof(METHOD)},

    {NV15_CELSIUS_PRIMITIVE,                Nv15CelsiusPrimitiveMethods,
                                            sizeof(Nv15CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV15_IMAGE_BLIT,                       Nv15ImageBlitMethods,
                                            sizeof(Nv15ImageBlitMethods)/sizeof(METHOD)},

    // NV11 and NV15 Celsius share the same method struct.
    {NV11_CELSIUS_PRIMITIVE,                Nv15CelsiusPrimitiveMethods,
                                            sizeof(Nv15CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV20_VIDEO_LUT_CURSOR_DAC,             Nv20VideoLUTCursorDACMethods,
                                            sizeof(Nv20VideoLUTCursorDACMethods)/sizeof(METHOD)},

    //
    // MAKE THIS LAST!!!
    //                                     
    {NV_CLASS,                              NvClassMethods,
                                            sizeof(NvClassMethods)/sizeof(METHOD)},
};

#define CLASSMETHODSTABLE_SIZE              (sizeof(classMethodsTable) / sizeof(CLASSMETHODS))

//---------------------------------------------------------------------------
//
//  Class table access.
//
//---------------------------------------------------------------------------

RM_STATUS classGetClass
(
    PCLASSDB pClassDB,
	U032 classNum, 
	PCLASS *ppClass
)
{
    U032 i;

	for (i = 0; i < pClassDB->numClasses; i++)
    {
		if (pClassDB->pClasses[i].Type == classNum)
        {
			*ppClass = &pClassDB->pClasses[i];
			return RM_OK;
        }
    }

	return RM_ERROR;
}

//
// classGetInfo
//
// This routine sets up method handling for the specified class
// It also binds the class to a a particular engine.
//
RM_STATUS classGetInfo
(
    PENGINEDB pEngineDB, 
    PCLASSDB pClassDB,
    PCLASS pClass
)
{
    U032 classNum;
    PENGINEINFO pEngineInfo;
    PENGINEDESCRIPTOR pEngineDecl;
    U032 engine;
	U032 i;

    //
    // Get class number and engine tag.
    //
    classNum = CLASSDECL_FIELD(*pClass->ClassDecl, _CLASS);
    engine = CLASSDECL_FIELD(*pClass->ClassDecl, _TAG);

    //
    // Wire up engine data first.
    //
    if (engineGetInfo(pEngineDB, engine, &pEngineInfo, &pEngineDecl) != RM_OK)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: classGetInfo: bad engine tag ", engine);
        return RM_ERROR;
    }

    pClass->EngineDecl = pEngineDecl;
    pClass->EngineInfo = pEngineInfo;

    //
    // Now wire up method routines.
    //
    for (i = 0; i < CLASSMETHODSTABLE_SIZE; i++)
    {
        if (classMethodsTable[i].Type == classNum)
        {
            pClass->Method = classMethodsTable[i].Method;
            pClass->MethodMax = classMethodsTable[i].MethodMax;
            break;
        }
    }

    //
    // If we don't have an entry in the resman method table for the
    // given class, then use the engine-specific default table
    // (usually just filled with a hardware method stub).
    //
    if (i == CLASSMETHODSTABLE_SIZE)
    {
        pClass->Method = pEngineInfo->Methods;
        pClass->MethodMax = pEngineInfo->MethodMax;
    }
    
	return RM_OK;
}

//
// classBuildDB
//
// This routine generates the class database for the
// specified device.
//
RM_STATUS classBuildDB
(
    PENGINEDB pEngineDB,
    PCLASSDB pClassDB
)
{
    PCLASS pClass;
    PCLASSDESCRIPTOR pClassDesc;
    U032 numClasses;
    U032 i, j;
    RM_STATUS status;

    //
    // Calculate number of classes supported by this device.
    //
    // For now, just add the size of the common class descriptor
    // table to the number of class descriptors in the pClassDB table (we
    // should probably allow for overlaps between the two).
    //
    j = 0;
    for (i = 0; i < pClassDB->numClassDescriptors; i++)
    {
        if (CLASSDECL_FIELD(pClassDB->pClassDescriptors[i], _OPCODE) == CLASSDECL_INSTR)
            j++;
            
    }

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvInfo class descriptors ",  j);

    numClasses = NUM_COMMONCLASSDESCRIPTORS + j;

    //
    // Allocate space for correct number of entries.
    //
    status = osAllocMem((VOID **)&pClass, sizeof (CLASS) * numClasses);
    if (status)
        return status;

    //
    // Load up the fixed (common) classes.
    //
    pClassDesc = &Common_ClassDescriptors[0];
    for (i = 0; i < NUM_COMMONCLASSDESCRIPTORS; i++)
    {
        pClass[i].Type = CLASSDECL_FIELD(pClassDesc[i], _CLASS);
        pClass[i].ClassDecl = &pClassDesc[i];
        status = classGetInfo(pEngineDB, pClassDB, &pClass[i]);
        if (status != RM_OK)
        {
            //
            // This shouldn't happen; treat as a fatal error.
            //
            osFreeMem((VOID *)pClass);
            return (RM_ERROR);
        }
    }

    //
    // Load up chip-dependent classes.
    //
    pClassDesc = &pClassDB->pClassDescriptors[0];
    for (i = NUM_COMMONCLASSDESCRIPTORS, j = 0; i < numClasses; i++)
    {
        //
        // Advance to next class descriptor header
        // (i.e. skip over any class extension descriptors).
        //
        while (CLASSDECL_FIELD(pClassDesc[j], _OPCODE) != CLASSDECL_INSTR)
            j++;
        pClass[i].Type = CLASSDECL_FIELD(pClassDesc[j], _CLASS);
        pClass[i].ClassDecl = &pClassDesc[j];
        if (CLASSDECL_FIELD(pClassDesc[++j], _OPCODE) == CLASSINSTMALLOC_INSTR)
            pClass[i].ClassInstMalloc = &pClassDesc[j];
        else
            pClass[i].ClassInstMalloc = NULL;
        
        status = classGetInfo(pEngineDB, pClassDB, &pClass[i]);
        if (status != RM_OK)
        {
            //
            // This shouldn't happen; treat as a fatal error.
            //
            osFreeMem((VOID *)pClass);
            return (RM_ERROR);
        }
    }

    pClassDB->pClasses = pClass;
    pClassDB->numClasses = numClasses;

    return (RM_OK);
}

RM_STATUS classDestroyDB
(
    PCLASSDB  pClassDB
)
{
    osFreeMem((VOID *)pClassDB->pClasses);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class object initial creation.
//
//---------------------------------------------------------------------------

RM_STATUS classCreateWellKnownObjects
(
    PHWINFO pDev,
    U032    ChID
)
{
    RM_STATUS    status;
    U032         i;
    U032         j;
    PCLASSDB pClassDB;
    PCLASSOBJECT ClassObject;
    PCLASSOBJECT *ClassObjects;
    PRENDERCOMMONOBJECT nullObject;
    PCLASS classTable;
#ifdef LEGACY_ARCH
    PDMAOBJECT   ErrNotifier;
#endif

    pClassDB = &pDev->classDB;

    //
    // Create and initialize all CLASS objects.  These are the master
    // class instances for this particular channel.  All user objects
    // created in this channel will be children of these master class
    // objects.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: numClasses ", pClassDB->numClasses);

    //
    // Allocate ClassObjects[] table.
    //
    status = osAllocMem((VOID **)&ClassObjects, sizeof (PCLASSOBJECT) * pClassDB->numClasses);
    if (status)
        return (status);

    classTable = pClassDB->pClasses;
    for (i = 0; i < pClassDB->numClasses; i++)
    {
        status = osAllocMem((VOID **)&ClassObject, sizeof (CLASSOBJECT));
        if (status)
        {
            while (i)
                osFreeMem(ClassObjects[--i]);
            osFreeMem(ClassObjects);
            return status;
        }

        //
        // Init global state.
        //
        ClassObjects[i]                 = ClassObject;
        ClassObject->Base.Name          = classTable[i].Type;
        //ClassObject->Base.Class         = &(classTable[i]);
        ClassObject->Base.Class         = &(classTable[NUM_COMMONCLASSDESCRIPTORS-1]);
        ClassObject->Base.ThisClass     = &(classTable[i]);
        ClassObject->Base.ChID          = ChID;
        ClassObject->Base.NotifyXlate   = NULL;
        ClassObject->Base.NotifyAction  = 0;
        ClassObject->Base.NotifyTrigger = 0;
        ClassObject->Base.NotifyEvent   = NULL;

        //
        // Add object into FIFO object tree.
        //
        status = fifoAddObject(pDev, (POBJECT)ClassObject);
        if (status != RM_OK)
        {
            while (i)
                osFreeMem(ClassObjects[--i]);
            osFreeMem(ClassObjects);
            return (status);
        }
    }

    //
    // Create and initialize NV_ERROR_NOTIFIER.
    //
    // jsw: this is no longer necessary with the new architecture
    //      error notifiers are explicitly created.
#ifdef LEGACY_ARCH
    // Find the DMA_TO_MEM master class object first.
    //
    j = 0;
    while ((j < pClassDB->numClasses) && (ClassObjects[j]->Base.Name != NV_CONTEXT_DMA_TO_MEMORY))
        j++;
    if (j == pClassDB->numClasses)
    {
        // Kinda silly error, but just in case we can't find the class
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        return (status);
    }
    //
    // Now create our instance
    //
    status = dmaCreate(pDev, ClassObjects[j], NV_CONTEXT_ERROR_TO_MEMORY, (POBJECT *)&ErrNotifier, NULL);
    if (status)
    {
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        dmaDelete((VOID*)pDev, (POBJECT)ErrNotifier);
        return (status);
    }
    ErrNotifier->Base.Name          = NV_CONTEXT_ERROR_TO_MEMORY;
    ErrNotifier->Base.Class         = &(classTable[j]);
    ErrNotifier->Base.ThisClass     = &(classTable[j]);
    ErrNotifier->Base.ChID          = ChID;
    ErrNotifier->Base.NotifyXlate   = NULL;
    ErrNotifier->Base.NotifyAction  = 0;
    ErrNotifier->Base.NotifyTrigger = 0;
    ErrNotifier->Base.NotifyEvent   = NULL;
    if ((status = fifoAddObject(pDev, (POBJECT)ErrNotifier)) != RM_OK)
    {
        dmaDelete((VOID*)pDev, (POBJECT)ErrNotifier);
        //return (status);
    }
#endif

    //
    // Create and initialize NV1_NULL_OBJECT.
    //
    // Find the NV1_NULL master class object first.
    //
    j = 0;
    while ((j < pClassDB->numClasses) && (ClassObjects[j]->Base.Name != NV1_NULL))
        j++;

    if (j == pClassDB->numClasses)
    {
        // Kinda silly error, but just in case we can't find the class
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        return (status);
    }       

    //
    // Now create our instance
    // 
    status = grCreateObj(pDev, ClassObjects[j], 0, (POBJECT *)&nullObject, NULL);
    if (status)
    {
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        grDestroyObj(pDev, (POBJECT)nullObject);
        return (status);
    }

    if ((status = fifoAddObject(pDev, (POBJECT)nullObject)) != RM_OK)
    {
        grDestroyObj(pDev, (POBJECT)nullObject);
        //return (status);
    }

    osFreeMem(ClassObjects);

    return (RM_OK);
}

RM_STATUS classDeleteWellKnownObjects
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    return (osFreeMem(Object));
}

RM_STATUS classInitCommonObject
(
    POBJECT pObject,
    PCLASSOBJECT pClassObject,
    U032 Name
)
{
    PCOMMONOBJECT pCommonObject;

    //
    // Initialize base object data.
    //
    pCommonObject = (PCOMMONOBJECT)pObject;

    pCommonObject->Base.Name = Name;
    pCommonObject->Base.ChID = pClassObject->Base.ChID;
    pCommonObject->Base.Class = pClassObject->Base.ThisClass;
    pCommonObject->Base.ThisClass = pClassObject->Base.ThisClass;
    pCommonObject->Base.NotifyXlate   = NULL;
    pCommonObject->Base.NotifyAction  = 0;
    pCommonObject->Base.NotifyTrigger = 0;
    pCommonObject->Base.NotifyEvent   = NULL;

    //
    // Initialize common object data.
    //
    pCommonObject->Valid            = FALSE;
    pCommonObject->NotifyPending    = FALSE;
    pCommonObject->Instance         = 0;
    pCommonObject->NotifyObject     = NULL;
    pCommonObject->Dma0Object       = NULL;
    pCommonObject->Dma1Object       = NULL;

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  NOP methods.
//
//---------------------------------------------------------------------------

RM_STATUS nopCreate
(
    VOID*        pDevHandle,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *UserObject,
    VOID*        pCreateParms
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Class not implemented yet: ", ClassObject->Base.Class->Type);
    return (RM_ERR_CREATE_BAD_CLASS);
}
RM_STATUS nopDelete
(
    PHWINFO pDev,
    POBJECT Object
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Class not implemented yet: ", Object->Class->Type);
    return (RM_ERR_DELETE_BAD_CLASS);
}
RM_STATUS mthdNoOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Method NoOperation", Object->Class->Type);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Create object.
//
//---------------------------------------------------------------------------

RM_STATUS classCreate
(
    VOID*        pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *UserObject,
    VOID*        pCreateParms
)
{
    //
    // Class specific create procedure.
    //

    DBG_VAL_PTR(ClassObject);
    return ((*(ClassObject->Base.ThisClass->EngineInfo->CreateObject))(pDev, ClassObject, UserName, UserObject, pCreateParms)); //KJK YUCK!!
}

//---------------------------------------------------------------------------
//
//  Destroy object.
//
//---------------------------------------------------------------------------

RM_STATUS classDestroy
(
    VOID*   pDev,
    POBJECT Object
)
{
    //
    // Class specific delete procedure.
    //
    DBG_VAL_PTR(Object);
    return ((*(Object->Class->EngineInfo->DestroyObject))(pDev, Object));    //KJK YUCK!!
}

//---------------------------------------------------------------------------
//
//  Software methods.
//  Emulate the device access in software.
//
//---------------------------------------------------------------------------

RM_STATUS classSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS  status;
    U032       i;

    NVRM_TRACE3('SWMT',
                (Object->ChID << 24) | (Object->Subchannel << 16) | (*Object->Class->ClassDecl & 0xffff),
                Object->Name);
    NVRM_TRACE2(Offset, Data);

#if DEBUG
    //
    // Reject unaligned accesses.
    //
    if (Offset & 0x0003)
        return (RM_ERR_FIFO_BAD_ACCESS);
#endif // DEBUG
    if (Object != NULL)
    {
        //
        // Search for object method.
        //
        DBG_VAL_PTR(Object);
        for (i = 0; i < Object->Class->MethodMax; i++)
        {
            if ((Offset >= Object->Class->Method[i].Low)
            &&  (Offset <  Object->Class->Method[i].High))
            {

                status = Object->Class->Method[i].Proc(pDev,
                                                       Object,
                                                       &(Object->Class->Method[i]),
                                                       Offset,
                                                       Data);
                //
                // Send completion notification.
                //
                notifyMethodComplete(pDev, Object, Offset, Data, status);
                NVRM_TRACE2('swmt', status);
                return (status);
            }
        }
        //
        // Method not found, so report the error if notify pending.
        //
        NVRM_TRACE_ERROR('swmt', RM_ERR_FIFO_BAD_ACCESS);
        notifyMethodComplete(pDev, Object, Offset, Data, RM_ERR_FIFO_BAD_ACCESS);
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: invalid access ", RM_ERROR);
    if (Object)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              object ", Object->Class->Type);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "              object NULL");
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              offset ", Offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "                data ", Data);
    return (RM_ERR_FIFO_BAD_ACCESS);
}

//
// SMP wrapper for classSoftwareMethod
//
RM_STATUS classDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS status;

    osEnterCriticalCode(pDev);
    status = classSoftwareMethod(pDev, Object, Offset, Data);
    osExitCriticalCode(pDev);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\class\nv\classobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASSOBJ.C                                                        *
*     NV_CLASS objects are defined and managed in this module.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <fifo.h>
#include <os.h>
#include <modular.h>


//
// Class object table.
//
extern CLASS classTable[];


//---------------------------------------------------------------------------
//
//  Class object method functions.
//
//---------------------------------------------------------------------------

RM_STATUS mthdCreateLegacy
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    NewName
)
{
    RM_STATUS status;
    POBJECT   NewObject;

    if (NewName < RESERVED_NAMES)
        return (RM_ERR_CREATE_BAD_CLASS);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Creating Object ", NewName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               ChID   ", ClassObject->ChID);
    
    //
    // Class specific creation routine.
    //
    status = classCreate((VOID*)pDev, (PCLASSOBJECT)ClassObject, NewName, &NewObject, NULL);
    if (status == RM_OK)
    {
        //
        // Init global state.
        //
        DBG_VAL_PTR(NewObject);

        //
        // Stick new object into FIFO database.
        //
        if ((status = fifoAddObject(pDev, NewObject)) != RM_OK)
            classDestroy((VOID*)pDev, NewObject);
    }
    return (status);
}
RM_STATUS mthdCreate
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    NewName,
    VOID*   pCreateParms
)
{
    RM_STATUS status;
    POBJECT   NewObject;

    if (NewName < RESERVED_NAMES)
        return (RM_ERR_CREATE_BAD_CLASS);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Creating Object ", NewName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               ChID   ", ClassObject->ChID);
    
    //
    // Class specific creation routine.
    //
    status = classCreate((VOID*)pDev, (PCLASSOBJECT)ClassObject, NewName, &NewObject, pCreateParms);
    if (status == RM_OK)
    {
        //
        // Init global state.
        //
        DBG_VAL_PTR(NewObject);

        //
        // Stick new object into FIFO database.
        //
        if ((status = fifoAddObject(pDev, NewObject)) != RM_OK)
            classDestroy((VOID*)pDev, NewObject);
    }
    return (status);
}
RM_STATUS mthdDestroy
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    DelName
)
{
    RM_STATUS status;
    POBJECT   DelObject;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Destroying Object ", DelName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 ChID   ", ClassObject->ChID);
    //
    // Retrieve and delete object from FIFO database.
    //    
    status = fifoSearchObject(pDev, DelName, ClassObject->ChID, &DelObject);
    if (status == RM_OK)
    {
        //
        // Make sure to free up any events in this object
        //
        if (DelObject->NotifyEvent)
        {
            PEVENTNOTIFICATION thisEvent = DelObject->NotifyEvent;
            PEVENTNOTIFICATION nextEvent = DelObject->NotifyEvent->Next;
            
            //
            // Walk the event chain and delete
            //
            osFreeMem((VOID *)thisEvent);
            while (nextEvent)
            {
                thisEvent = nextEvent;
                nextEvent = thisEvent->Next;
                osFreeMem((VOID *)thisEvent);
            }
        }
        
        //
        // Class specific delete procedure.
        //
        status  = fifoDelObject(pDev, DelObject);
        status |= classDestroy((VOID*)pDev, DelObject);
    }
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\class\nv\classdel.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASSDEL.C                                                        *
*     Deleted user objects are destroyed here if not in use or placed       *
* into a 'zombie' state waiting to go idle before all state is removed.     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>

//
// No zombie management yet
//
RM_STATUS classAddZombie
(
    POBJECT DeadObject
)
{
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\class\nv\control.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CONTROL.C                                                         *
*     Control methods are implemented in this module.                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include <nv32.h>
#include "control.h"
#include "nvhw.h"

//
// FIFO database.
//

//---------------------------------------------------------------------------
//
//  Control methods.
//
//---------------------------------------------------------------------------


CTRLMETHOD NvControlMethods[] =
{
    {mthdSetObject,                 0x0000, 0x0003}
#ifdef OBSOLETE_FUNCTIONS
    {mthdSetStallNotifier,          0x0050, 0x0053},
    {mthdStallChannel,              0x0054, 0x0057}
#endif // OBSOLETE_FUNCTIONS
};

// Class representing information for channel control operations
CTRLCLASS NvControlClass =
{
    NvControlMethods,
    sizeof(NvControlMethods) / sizeof(CTRLMETHOD)
};


// Implementation of the control "Set Object" method
RM_STATUS mthdSetObject
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    U032    Context;
    POBJECT Object;
#ifdef KJK
    U032    CacheChID;
#endif

    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object.
        //
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = NULL;
    }
    else if (fifoSearchObject(pDev, Data, ChID, &Object) == RM_OK)
    {
    
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: SetObject on subchannel: ", SubChannel);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      Object#: ", Object->Name);
    
        //
        // Set this as the current object for this ChID/SubChannel.
        //
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = Object;

        //
        // Set the current subchannel for this object, per this SetObject
        //
        Object->Subchannel = SubChannel;
        
        //
        // Update the fifo context for this subchannel back to a software object
        //
        Context = REG_RD32(NV_PFIFO_CACHE1_ENGINE);
        Context &= ~(0x03 << (SubChannel*4));
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, Context);
    }
    else
    {
        //
        // Object not found.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetObject on invalid object: ", Data);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = NULL;
    }
    
#ifdef KJK    
    //
    // Do the hash function.  Update the appropriate channel context.
    //
    fifoHashEntry(pDev->DBfifoTable[ChID].ObjectStack[SubChannel][0], ChID, &Context);
    CacheChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    if (CacheChID == ChID)
    {
        REG_WR32(NV_PFIFO_CACHE1_CTX(SubChannel), Context);
        REG_WR32(NV_PFIFO_CACHE1_PULL1, DRF_DEF(_PFIFO, _CACHE1_PULL1, _CTX,       _DIRTY));
    }
    else
    {
        U032  *CtxtPtr = (U032 *)pDev->Pram.FifoContextAddr;
        MEM_WR32((U032)(CtxtPtr + (ChID * 8) + SubChannel), Context);
    }
#endif // KJK
    
    return(RM_OK);
}

#ifdef OBSOLETE_FUNCTIONS
// Implementation of the control "Set Stall Notifier" method
RM_STATUS mthdSetStallNotifier
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    RM_STATUS status;

    if (!(REG_RD32(NV_PFIFO_MODE) & (1 << ChID))) 
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetStallNotifier not valid for PIO channel: ", ChID);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_ILLEGAL_ACTION;
    }

    status = dmaValidateObjectName(pDev, Data,
                                   ChID,
                                   &(pDev->DBfifoTable[ChID].StallNotifier));
    if (status) {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid notifier for SetStallNotifier: ", Data);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_BAD_OBJECT;
    }

    return RM_OK;
}


// Implementation of the control "Stall Channel" method
RM_STATUS mthdStallChannel
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    RM_STATUS status;
    U032      GetPtr;

    if (!(REG_RD32(NV_PFIFO_MODE) & (1 << ChID))) 
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: StallChannel not valid for PIO channel: ", ChID);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_ILLEGAL_ACTION;
    }

    // Remember the current position of the PutPtr.
    pDev->DBfifoTable[ChID].Put = REG_RD32(NV_PFIFO_CACHE1_PUT);

    // Make the Put the same as Get. The getptr will be incremented to skip 
    // over the stall channel method. Account for that when setting the putptr.
    GetPtr     = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    GetPtr++;
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, GetPtr);

    // Mark this channel as stalled.
    pDev->DBfifoTable[ChID].IsStalledPendingVblank = TRUE;

    // Write the stall notifier.
    if (pDev->DBfifoTable[ChID].StallNotifier) 
    {
        status = notifyFillNotifierArray(pDev, pDev->DBfifoTable[ChID].StallNotifier, 
                                         0 /* info16 */, 0 /* info32 */, 
                                         Data,
                                         0 /* index */);
    }

    return RM_OK;
}

RM_STATUS mthdEnableStalledChannels
(
    PHWINFO   pDev,
    RM_STATUS status
)
{
    U032 i, currentCh, pushPending;
    BOOL isDma;
    // Check all DMA channels other than the current channel that are in use 
    // (The stalled channel cannot be the current one.)
    currentCh = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 
    for (i = 0; i < NUM_FIFOS; i++)
    {
        isDma = REG_RD32(NV_PFIFO_MODE) & (1 << i);
        if (pDev->DBfifoTable[i].InUse && isDma && i != currentCh && 
            pDev->DBfifoTable[i].IsStalledPendingVblank)
        {
            // This channel was stalled pending a vblank.
            // Update the put in instance memory and mark this channel as push pending.
            REG_WR32((0x714000 + i * 32), pDev->DBfifoTable[i].Put);
            pushPending = REG_RD32(NV_PFIFO_DMA);
            pushPending |= (1 << i);
            REG_WR32(NV_PFIFO_DMA, pushPending);
            // Write the stall notifier.
            if (pDev->DBfifoTable[i].StallNotifier) 
            {
                notifyFillNotifierArray(pDev, pDev->DBfifoTable[i].StallNotifier, 
                                        0 /* info16 */, 0 /* info32 */, 
                                        status,
                                        0 /* index */);
            }

            pDev->DBfifoTable[i].IsStalledPendingVblank = FALSE;
        }
    }

    return RM_OK;
}
#endif // OBSOLETE_FUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\btree\nv\btree.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Balanced Tree *******************************\
*                                                                           *
* Module: BTREE.C                                                           *
*   A generic library to balanced tree management is provided.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <class.h>
#include <btree.h>
#include <os.h>
//
// Debugging support.
//
#ifdef DEBUG
//
// Validate node.
//
#define VALIDATE_NODE(pn)                   \
{                                           \
    if (btreeNodeValidate(pn) != RM_OK)     \
        return (RM_ERROR);                  \
}
#define VALIDATE_TREE(pt)                   \
{                                           \
    if (btreeTreeValidate(pt) != RM_OK)     \
        return (RM_ERROR);                  \
}
//
// Prototype validation routines.
//
RM_STATUS btreeNodeValidate(PNODE);
RM_STATUS btreeTreeValidate(PNODE);
RM_STATUS btreeDumpBranch(PNODE, U032);
RM_STATUS btreeDumpTree(PNODE);
//
// Validate a nodes branch and count values.
//
RM_STATUS btreeNodeValidate
(
    PNODE Node
)
{
    RM_STATUS status;
    
    status = RM_OK;
    if (Node == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR validating NULL NODE.\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }
    if (((Node->LeftCount != 0) && (Node->LeftBranch == NULL))
    ||  ((Node->LeftCount == 0) && (Node->LeftBranch != NULL)))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left branch, Value = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                       Left count = ", Node->LeftCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                      Left branch = ", Node->LeftBranch);
        DBG_BREAKPOINT();
        status = RM_ERROR;
    }
    if (((Node->RightCount != 0) && (Node->RightBranch == NULL))
    ||  ((Node->RightCount == 0) && (Node->RightBranch != NULL)))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right branch, Value = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                       Right count = ", Node->RightCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                      Right branch = ", Node->RightBranch);
        DBG_BREAKPOINT();
        status = RM_ERROR;
    }
    return (status);
}
//
// Validate entire BTREE.
//
RM_STATUS btreeBranchValidate
(
    PNODE Node,
    U032 *NodeCount
)
{
    RM_STATUS status;
    U032 LeftCount;
    U032 RightCount;
    
    status = RM_OK;
    if (Node)
    {
        btreeNodeValidate(Node);
        if (Node->LeftBranch)
            status = btreeBranchValidate(Node->LeftBranch, &LeftCount);
        else
            LeftCount = 0;
        if (Node->RightBranch)
            status = btreeBranchValidate(Node->RightBranch, &RightCount);
        else
            RightCount = 0;
        if (Node->LeftCount != LeftCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left count, Value = ", Node->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Left count = ", Node->LeftCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Left branch = ", Node->LeftBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        if (Node->RightCount != RightCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right count, Value = ", Node->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Right count = ", Node->RightCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Right branch = ", Node->RightBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        *NodeCount = LeftCount + RightCount + 1;
    }
    return (status);
}
RM_STATUS btreeTreeValidate
(
    PNODE Trunk
)
{
    RM_STATUS status;
    U032      LeftCount;
    U032      RightCount;
    
    status = RM_OK;
    if (Trunk)
    {
        status = btreeNodeValidate(Trunk);
        if (Trunk->LeftBranch)
            status |= btreeBranchValidate(Trunk->LeftBranch, &LeftCount);
        else
            LeftCount = 0;
        if (Trunk->RightBranch)
            status |= btreeBranchValidate(Trunk->RightBranch, &RightCount);
        else
            RightCount = 0;
        if (Trunk->LeftCount != LeftCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left count, Value = ", Trunk->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Left count = ", Trunk->LeftCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Left branch = ", Trunk->LeftBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        if (Trunk->RightCount != RightCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right count, Value = ", Trunk->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Right count = ", Trunk->RightCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Right branch = ", Trunk->RightBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
    }
    if (status)
        btreeDumpTree(Trunk);
    return (status);
}
//
// Dump current tree to debug port.
//
RM_STATUS btreeDumpBranch
(
    PNODE Node,
    U032  Level
)
{
    U032 i;

    if (Node)
    {
        VALIDATE_NODE(Node);
        btreeDumpBranch(Node->RightBranch, Level + 1);
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: ");
        for (i = 0; i < Level; i++)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, ".");
        }
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Node         = ", Node);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Value        = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Left count   = ", Node->LeftCount);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Right count  = ", Node->RightCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Left branch  = ", Node->LeftBranch);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Right branch = ", Node->RightBranch);
        btreeDumpBranch(Node->LeftBranch, Level + 1);
    }
    return (RM_OK);
}
RM_STATUS btreeDumpTree
(
    PNODE Trunk
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: ======================== Tree Dump ==========================\n\r");
    if (Trunk == NULL)
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: NULL\n\r");
    else
        btreeDumpBranch(Trunk, 0);
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: =============================================================\n\r");
    return (RM_OK);
}
#else
//
// Validate nothing.
//
#define VALIDATE_NODE(pn)
#define VALIDATE_TREE(pt)
#endif // DEBUG
//
// Insert new node into tree.
//
RM_STATUS btreeInsertBranch
(
    PNODE Node, 
    PNODE BranchNode
)
{
    RM_STATUS status;
    
    //
    // Check for duplicate names.
    //
    VALIDATE_NODE(BranchNode);
    if (Node->Value == BranchNode->Value)
        return (RM_ERR_INSERT_DUPLICATE_NAME);
    status = RM_OK;    
    if (Node->Value < BranchNode->Value)
    {
        //
        // Insert into right branch.
        //
        if (BranchNode->RightBranch)
        {
            status = btreeInsertBranch(Node, BranchNode->RightBranch);
        }
        else
        {
            BranchNode->RightBranch = Node;
            Node->RightCount        = 0;
            Node->LeftCount         = 0;
            Node->RightBranch       = NULL;
            Node->LeftBranch        = NULL;
        }
        if (status == RM_OK)    
            BranchNode->RightCount++;
    }
    else
    {
        //
        // Insert into left branch.
        //
        if (BranchNode->LeftBranch)
        {
            status = btreeInsertBranch(Node, BranchNode->LeftBranch);
        }
        else
        {
            BranchNode->LeftBranch = Node;
            Node->RightCount       = 0;
            Node->LeftCount        = 0;
            Node->RightBranch      = NULL;
            Node->LeftBranch       = NULL;
        }
        if (status == RM_OK)    
            BranchNode->LeftCount++;
    }
    return (status);
}
RM_STATUS btreeInsert
(
    PNODE  Node,
    PNODE *Trunk
)
{
    RM_STATUS status;

#ifdef DEBUG
    if (Node == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: Inserting NULL into BTREE!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG    
    status = RM_OK;
    if (*Trunk == NULL)
    {
        *Trunk            = Node;
        Node->RightCount  = 0;
        Node->LeftCount   = 0;
        Node->RightBranch = NULL;
        Node->LeftBranch  = NULL;
    }
    else
    {
        status = btreeInsertBranch(Node, *Trunk);
    }
    VALIDATE_TREE(*Trunk);
    return (status);
}
//
// Remove node from tree.
//
RM_STATUS btreeDelete
(
    U032   Value,
    PNODE *Trunk
)
{
    PNODE Node;
    PNODE ParentNode;
    PNODE PrevNode;
    PNODE SearchNode;

    if (*Trunk == NULL)
        return (RM_ERROR);
    Node       = *Trunk;
    SearchNode = NULL;
    ParentNode = NULL;
    VALIDATE_TREE(*Trunk);
    //
    // Search tree for node being deleted.
    //
    while (Value != Node->Value)
    {
        ParentNode = Node;
        if (Value > Node->Value)
            Node = Node->LeftBranch;
        else
            Node = Node->RightBranch;
        if (Node == NULL)
            //
            // Not found.
            //
            return (RM_ERROR);
    }
    //
    // Check for branches of node to be deleted.
    //
    if (Node->RightCount + Node->LeftCount > 0)
    {
        PrevNode = NULL;
        //
        // Find best candidate to fill in place of deleted node.
        //
        if (Node->RightCount > Node->LeftCount)
        {
            //
            // Get next higher node.
            //
            SearchNode = Node->RightBranch;
            Node->RightCount--;
            while (SearchNode->LeftBranch)
            {
                SearchNode->LeftCount--;
                PrevNode   = SearchNode;
                SearchNode = SearchNode->LeftBranch;
            }
            if (PrevNode)
                PrevNode->LeftBranch = SearchNode->RightBranch;
            else
                Node->RightBranch = SearchNode->RightBranch;
        }
        else
        {
            //
            // Get next lower node.
            //
            SearchNode = Node->LeftBranch;
            Node->LeftCount--;
            while (SearchNode->RightBranch)
            {
                SearchNode->RightCount--;
                PrevNode   = SearchNode;
                SearchNode = SearchNode->RightBranch;
            }
            if (PrevNode)
                PrevNode->RightBranch  = SearchNode->LeftBranch;
            else
                Node->LeftBranch = SearchNode->LeftBranch;
        }
        //
        // Replace deleted node with best candidate.
        //
        SearchNode->LeftBranch  = Node->LeftBranch;
        SearchNode->LeftCount   = Node->LeftCount;
        SearchNode->RightBranch = Node->RightBranch;
        SearchNode->RightCount  = Node->RightCount;
    }
    //
    // Update parent branch pointers.
    //
    if (ParentNode)
    {
        if (ParentNode->LeftBranch == Node)
            ParentNode->LeftBranch  = SearchNode;
        else
            ParentNode->RightBranch = SearchNode;
    }
    else
    {
       *Trunk = SearchNode;
    }
    //
    // Update branch counts up to the deleted node.
    //    
    PrevNode = *Trunk;
    while (PrevNode && (PrevNode != SearchNode))
    {
        if (Value > PrevNode->Value)
        {
            PrevNode->LeftCount--;
            PrevNode = PrevNode->LeftBranch;
        }
        else
        {
            PrevNode->RightCount--;
            PrevNode = PrevNode->RightBranch;
        }
    }
    Node->RightCount  = 0;
    Node->LeftCount   = 0;
    Node->RightBranch = NULL;
    Node->LeftBranch  = NULL;
    VALIDATE_TREE(*Trunk);
    return (RM_OK);
}
//
// Search for node in tree.
//
RM_STATUS btreeSearch
(
    U032   Value,
    PNODE *Node,
    PNODE  Trunk
)
{
    VALIDATE_TREE(Trunk);
    *Node = Trunk;
    //
    // Search for Node Value.
    //
    while (*Node)
    {
        if (Value == (*Node)->Value)
            return (RM_OK);
        if (Value > (*Node)->Value)
            *Node = (*Node)->LeftBranch;
        else
            *Node = (*Node)->RightBranch;
    }
    return (RM_ERR_OBJECT_NOT_FOUND);
}
//
// Enumerate tree.
//
RM_STATUS btreeEnumStart
(
    U032   Value,
    PNODE *Node,
    PNODE  Trunk
)
{
    PNODE EnumNode;
    
    *Node    = Trunk;
    EnumNode = NULL;
    //
    // Search for Node Value.
    //
    while (*Node)
    {
        VALIDATE_NODE(*Node);
        if (Value == (*Node)->Value)
            return (RM_OK);
        if (Value > (*Node)->Value)
            *Node = (*Node)->LeftBranch;
        else
        {
            //
            // Save next nearest node.
            //
            EnumNode = *Node;
            *Node    = (*Node)->RightBranch;
        }
    }
    *Node = EnumNode;
    return (RM_OK);
}
RM_STATUS btreeEnumNext
(
    PNODE *Node,
    PNODE  Trunk
)
{
    PNODE EnumNode;
    U032  Value;
    
    VALIDATE_NODE(*Node);
    if ((*Node)->LeftBranch)
    {
        //
        // Start where we left off.
        //
        Value     = (*Node)->Value + 1;
        *Node    = (*Node)->LeftBranch;
        EnumNode = *Node;
        while (*Node)
        {
            VALIDATE_NODE(*Node);
            if (Value == (*Node)->Value)
                return (RM_OK);
            if (Value > (*Node)->Value)
                *Node = (*Node)->LeftBranch;
            else
            {
                //
                // Save next nearest node.
                //
                EnumNode = *Node;
                *Node    = (*Node)->RightBranch;
            }
        }
        *Node = EnumNode;
        return (RM_OK);
    }
    else
        return (btreeEnumStart((*Node)->Value + 1, Node, Trunk));
}
//
// Balance branch.
//
RM_STATUS btreeBalanceBranch
(
    PNODE *Node
)
{
    PNODE SearchNode;
    PNODE ParentNode;

    VALIDATE_NODE(*Node);
    while ((((*Node)->RightCount > (*Node)->LeftCount)
          ? ((*Node)->RightCount - (*Node)->LeftCount)
          : ((*Node)->LeftCount  - (*Node)->RightCount)) > 1)
    {
        ParentNode = NULL;
        if ((*Node)->RightCount > (*Node)->LeftCount)
        {
            SearchNode = (*Node)->RightBranch;
            while (SearchNode->LeftBranch)
            {
                ParentNode = SearchNode;
                SearchNode->LeftCount--;
                SearchNode = SearchNode->LeftBranch;
            }
            if (ParentNode)
            {
                ParentNode->LeftBranch  = SearchNode->RightBranch;
                SearchNode->RightBranch = (*Node)->RightBranch;
                SearchNode->RightCount  = (*Node)->RightCount - 1;
            }
            else
            {
                (*Node)->RightBranch = NULL;
                (*Node)->RightCount  = 0;
            }
            SearchNode->LeftBranch     = *Node;
            SearchNode->LeftCount      = (*Node)->LeftCount + 1;
            (*Node)->RightBranch = NULL;
            (*Node)->RightCount  = 0;
        }
        else
        {
            SearchNode = (*Node)->LeftBranch;
            while (SearchNode->RightBranch)
            {
                ParentNode = SearchNode;
                SearchNode->RightCount--;
                SearchNode = SearchNode->RightBranch;
            }
            if (ParentNode)
            {
                ParentNode->RightBranch = SearchNode->LeftBranch;
                SearchNode->LeftBranch  = (*Node)->LeftBranch;
                SearchNode->LeftCount   = (*Node)->LeftCount - 1;
            }
            else
            {
                (*Node)->LeftBranch = NULL;
                (*Node)->LeftCount  = 0;
            }
            SearchNode->RightBranch   = *Node;
            SearchNode->RightCount    = (*Node)->RightCount + 1;
            (*Node)->LeftBranch = NULL;
            (*Node)->LeftCount  = 0;
        }
        *Node = SearchNode;
    }
    if ((*Node)->RightBranch)
        btreeBalanceBranch(&((*Node)->RightBranch));
    if ((*Node)->LeftBranch)
        btreeBalanceBranch(&((*Node)->LeftBranch));
    return (RM_OK);
}
//
// Balance tree.
//
RM_STATUS btreeBalance
(
    PNODE *Trunk
)
{
    RM_STATUS status;
    
    status = RM_OK;
    if (*Trunk)
    {
        VALIDATE_TREE(*Trunk);
        status = btreeBalanceBranch(Trunk);
        VALIDATE_TREE(*Trunk);
    }
    return (status);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\class\nv\nvde.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** NVDE ****************************************\
*                                                                           *
* Module: NVDE.C                                                            *
*     NVDE methods                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <modular.h>
#include <event.h>

RM_STATUS NvdeAlloc
(
    U032            Name,
    VOID*           pCreateParms
)
{
    PRMINFO pRmInfo = &NvRmInfo;
    RM_STATUS status;
    POBJECT pObject;
    PNVDEOBJECT pNvdeObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvdeAlloc\r\n");

    //
    // Make sure an NVDE object isn't already in use
    //
    if (pRmInfo->Debugger.object)
        return (NVDE_STATUS_ERROR_STATE_IN_USE);

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)&pObject, sizeof(NVDEOBJECT));
    if (status)
        return (status);

    //
    // Set some default state.
    //
    pObject->Name = Name;
    pObject->ChID = 0;
    pObject->Class = NULL;
    pObject->ThisClass = NULL;
    pObject->Subchannel = NULL;
    pObject->Next = NULL;
    pObject->NotifyXlate = NULL;
    pObject->NotifyAction = 0;
    pObject->NotifyTrigger = 0;
    pObject->NotifyEvent = 0;

    //
    // Save off the event parameters.
    //
    pNvdeObject = (PNVDEOBJECT)pObject;
    pNvdeObject->EventHandle = ((NVDE_ALLOCATION_PARAMETERS*)pCreateParms)->EventHandle;
    pNvdeObject->EventClass = ((NVDE_ALLOCATION_PARAMETERS*)pCreateParms)->EventClass;
    pNvdeObject->EventBufferCount = 0;

    //
    // Queue up event...
    //
    status = eventSetObjectEventNotify(pObject, 0, 0, pNvdeObject->EventClass,  pNvdeObject->EventHandle);

    //
    // Set the pointer so we know a NVDE object is in use
    //
    if (status == RM_OK)
        pRmInfo->Debugger.object = (POBJECT) pObject;

    return status;
}


RM_STATUS NvdeFree
(
    U032 Client,
    U032 Object
)
{
    PRMINFO pRmInfo = &NvRmInfo;
    PNVDEOBJECT pNvdeObject = (PNVDEOBJECT)pRmInfo->Debugger.object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvdeFree\r\n");

    if (pNvdeObject == NULL)
        return RM_OK;

    //
    // Assert that the handles match.
    //
    if (pNvdeObject->Common.Base.Name != Object)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad debugger object handle ", Object);
        return RM_ERROR;
    }

    //
    // Unplug event.  Handle is 0 for now since we only support
    // a single debugger event.
    //
    eventRemoveObjectEventNotify((POBJECT)pNvdeObject, 0);

    //
    // Clear out the NVDE object pointer so we know it's not in use
    //
    pRmInfo->Debugger.object = (POBJECT)NULL;

    return (osFreeMem(pNvdeObject));
}

V032 NvdeAppendEventForDebugger
(
    PNVDEOBJECT pDebugger,
    U032        code,
    U032        flags,
    U032        param1,
    U032        param2,
    U032        param3,
    U032        param4,
    U032        param5,
    U032        param6
)
{
    PNVDEEVENT event;

    if (pDebugger->EventBufferCount >= NVDE_MAX_EVENTS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Too many NVDE events to buffer.\n\r");
        return 0;
    }
    
    event           = pDebugger->EventBuffer + pDebugger->EventBufferCount;
    event->code     = code;
    event->flags    = flags;
    event->param[0] = param1;
    event->param[1] = param2;
    event->param[2] = param3;
    event->param[3] = param4;
    event->param[4] = param5;
    event->param[5] = param6;

    pDebugger->EventBufferCount++;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dac.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DAC.C                                                             *
*   The DAC control management is updated here.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include <i2c.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include <edid.h>
#include <tv.h>
#include <devinit.h>
#include <smp.h>
#include <stddef.h>    // for size_t

/* This file simulates the NV arbitor */
#include <arb_fifo.h>


// Const strings for accessing the registry

extern U008    CH_Init[];
// The "leaf" subkeys are OS-independent

#ifdef NTRM    
char strDisplayType[] = "Display Type";
char strDisplay2Type[] = "Display2 Type";
char strTVtype[] = "TV Type";
char strTVOutType[] = "TV Out";
char    strFpMode[] = "FlatPanelMode";
#else
extern char strDisplayType[];
extern char strDisplay2Type[];
extern char strTVtype[];
extern char strTVOutType[];
extern char strFpMode[];
#endif // NTRM

extern char strDevNodeRM[];

#define RED_OUT_300MV	0x800001A0
#define MAXCRTRETRIES   5

// remove this after all drivers switch to the new devices based API.
static BOOL using_new_api = FALSE;

//
// Set Display Power Managememnt Level.
//
RM_STATUS dacSetDpmLevel
(
    PHWINFO      pDev
)
{
    switch (pDev->Dac.DpmLevel)
    {
        default:
            break;
    }
    return (RM_OK);
}

RM_STATUS dacLoadWidthDepth
(
   PHWINFO pDev,
   U032    Head
)
{
    U032 data;

    switch (pDev->Dac.HalInfo.Depth)
    {
        case 8:
            data = NV_CIO_CRE_PIXEL_FORMAT_8BPP;
            break;
        case 15:
        case 16:
            data = NV_CIO_CRE_PIXEL_FORMAT_16BPP;
            break;
        case 24:
        case 30:
        case 32:
        default:
            data = NV_CIO_CRE_PIXEL_FORMAT_32BPP;
            break;
    }
    //
    // Write the CRTC register
    //
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

    return (RM_OK);
}

//
// Find closest DAC PLL parameters for a given frequency.
//
RM_STATUS dacCalcPLL
(
    PHWINFO pDev 
)
{
    U032 DeltaNew;
    U032 DeltaOld;
    U032 VClk;
    U032 Freq;
    U032 M;
    U032 N;
    U032 P;

    //
    // Calc VPLL.
    //
    DeltaOld = 0xFFFFFFFF;
    VClk     = pDev->Dac.HalInfo.VClk / 1000;
    //
    // Calculate frequencies using KHz to keep the math precision inside 32 bits.
    //
    for (P = 1; P <= 8; P <<= 1)
    {
        Freq = VClk * P;
        //
        // Bound the parameters to the internal frequencies of the DAC.
        //
        if ((Freq >= 64000) && (Freq <= 170000))
        {
            for (M = 7; M <= 12; M++)
            {
                N    = VClk * P * M / 12096;
                Freq = N * 12096 / P / M;
                if (Freq > VClk)
                    DeltaNew = Freq - VClk;
                else
                    DeltaNew = VClk - Freq;
                if (DeltaNew < DeltaOld)
                {
                    //
                    // Closer match.
                    //
                    pDev->Dac.HalInfo.VPllM = M;
                    pDev->Dac.HalInfo.VPllN = N;
                    pDev->Dac.HalInfo.VPllO = 1;
                    if (P==8)
                        pDev->Dac.HalInfo.VPllP = 3;
                    else if (P==4)
                        pDev->Dac.HalInfo.VPllP = 2;
                    else if (P==2)
                        pDev->Dac.HalInfo.VPllP = 1;
                    else 
                        pDev->Dac.HalInfo.VPllP = 0;
                    DeltaOld = DeltaNew;
                }
            }
        }
    }
    return (RM_OK);
}


//
//       dacCalcMNP - Return the PLL values for a specified frequency
//
//          Clock frequency in MHz * 100
//
// The algorithm is constrained to keep within 0.5% error
// to remain inside the VBE spec.
// However, if you have a choice of what frequencies you
// request, try to avoid the following requested frequencies
// when you get above 300MHz, as they require M values > 3.
//
//  14.31818 MHz
// 29739 - 29918
// 30219 - 30393
// 31178 - 31343
// 31658 - 31818
// 32617 - 32767
// 33097 - 33243
// 34056 - 34193
// 34536 - 34668
//
//  13.5000 MHz
// 29397 - 29552
// 29849 - 30000
// 30754 - 30896
// 31206 - 31344
// 32110 - 32239
// 32563 - 32767
// 33467 - 33582
// 33919 - 34030
// 34824 - 34926
//
U032 dacCalcMNP(
    PHWINFO  pDev,
    U032     Head,
    U032     Clock,
    U032    *M,    
    U032    *N,    
    U032    *P    
)
{
    U016  crystalFreq;
    U032  vclk;
    U016  vclkClosest = 0;
    U016  deltaOld;
    U016  bestM = 0;
    U016  bestP = 0;
    U016  bestN = 0;
    U016  lowM;
    U016  highM;
    U016  lowP, highP;
    U032  hiVclk1, hiVclk2, hiVclk3;
    U032  FminVco, FmaxVco;
    
    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032  lwv, lwv2;
    
    U016  lwvs, vclks;
    U016  t;
    
    vclk = (U032)(Clock * 10);     // Make KHz
    
    deltaOld = 0xFFFF;

    //
    // NV11 needs four highM buckets due to
    // induced jitter into the PLL's
    //
    if (IsNV11(pDev))
    {
        hiVclk1 = 150000;
        hiVclk2 = 200000;
        hiVclk3 = 340000;
    }
    else
    {
        hiVclk1 = 250000;
        hiVclk2 = 340000;

    }

    lowP  = 0;
    highP = 4;

    // if initDac() has run then FminVco and FmaxVco will be set.
    // But we might be called during devinit processing prior to
    //    initDac(), so we need a fallback...
    // NOTE: these defaults duplicated in initDac()
    if ((pDev->Dac.FminVco == 0) || (pDev->Dac.FmaxVco == 0))
    {
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;
            
            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }
    
    FminVco = pDev->Dac.FminVco;
    FmaxVco = pDev->Dac.FmaxVco;

    //
    // NV11 requires a modified Vco range, and since the BIOS's are already 
    // out in the field, shortcircuit this nice feature to fix the noise issue.
    //
    // When we're sure all older BIOS's have been flushed out of the world
    // (need 3.11.01.25.00+), this code can be removed.  If we detect a newer
    // BIOS revision is in use, use those values.
    //
    // Mobile NV11 has always used these ranges, so this should not be a change
    // for them.
    //
    if (IsNV11(pDev) && (pDev->Chip.BiosRevision <= 0x03110125))
    {
        FminVco = 200000;
        FmaxVco = 400000;
    }

    // Apply any adjusts needed to FminVco/FmaxVco.
    //
    // 1). Make sure vclk is not so low that we'll miss the whole VCO range.
    //     Adjust FminVco to hit with the highest P (post divide).
    //
    if ((vclk << highP) < FminVco)
        FminVco = vclk << highP;

    //
    // 2). Also, check if two consecutive P values would cause us to miss
    //     the whole VCO range, where the first P is beneath FminVco and
    //     the next P is above FmaxVco.
    //
    for (powerP = lowP; powerP < highP; powerP++)
    {
        lwv = vclk << powerP;
        if ((lwv < FminVco) && ((lwv << 1) > FmaxVco))
        {
            // adjust FminVco or FmaxVco, whichever is closer
            if ((FminVco - lwv) < ((lwv << 1) - FmaxVco))
                FminVco = lwv;
            else
                FmaxVco = (lwv << 1);
        }
    }

    //
    // 3). Let a high vclk set the upper bound.
    //
    if (vclk > FmaxVco)
        FmaxVco = vclk;

    //
    // For NV15, we've got a bit in CR33 that indicates we're setting the
    // PLL in the "upper" VCO range.
    //
    if (IsNV15(pDev))
    {
        U008 lock, cr33;

        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        // put NV15 into NV15 VPLL VCO programming mode
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, cr33, Head);
        cr33 |= (1 << DRF_SHIFT(NV_CIO_CRE_LCD_VPLL_VCO));
        CRTC_WR(NV_CIO_CRE_LCD__INDEX, cr33, Head);

        RestoreLock(pDev, Head, lock);
    }

    //
    // Determine the current crystal frequency
    //   
    if (pDev->Chip.HalInfo.CrystalFreq == 14318180)
    {
        // 14.3Khz
        crystalFreq = 14318;

        lowM = 1;
             
        if (IsNV11(pDev))
        {
            //
            // NV11 needs four highM buckets due to
            // induced jitter into the PLL's
            //
            if (vclk > hiVclk3)
                highM = 2;
            else if (vclk > hiVclk2)
                highM = 4;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 14;

        }
        else
        {
            //
            // All chips except for NV11 only need three
            // highM buckets
            //
            if (vclk > hiVclk2)
                highM = 2;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 14;
        }
    }
    else
    {
        // 13.5Khz
        crystalFreq = 13500;

        lowM = 1;

        //
        // NV11 needs four highM buckets due to
        // induced jitter into the PLL's
        //
        if (IsNV11(pDev))
        {
            if (vclk > hiVclk3)
                highM = 2;
            else if (vclk > hiVclk2)
                highM = 4;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 13;
        }
        else
        {
            //
            // All chips except for NV11 only need three
            // highM buckets
            //
            if (vclk > hiVclk2)
                highM = 2;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 13;
        }
    }                      
    
    //
    // P Loop
    //
    for (powerP = lowP; powerP <= highP; powerP++) // Init Power of P
    {                             
        // M Loop
        for (m = lowM; m <= highM; m++)
        {                          
            lwv = vclk << powerP;   // vclk * P
            
            // Compare with internal range of DAC
            if ((lwv >= FminVco) && (lwv <= FmaxVco))
            {
                lwv *= (U032)m;    // vclk * P * M
                
                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);
                
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                
                if (n > 0xFF)
                    break;
                    
                lwv *= crystalFreq; // N * crystal
                   
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                
                i = m;
                j = m;
                
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                                       
                lwv2 = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                
                if (lwvs < vclks)
                {               
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }            
                    
                lwvs -= vclks;      // ABS(Freq-Vclk);
                
                //
                // If this is an NV5 or better, allow the higher PCLK settings to use a lower M
                // if the error is small enough.  Just looking for the lowest overall error
                // may result in an M that is too high, possibly introducing PLL jitter.
                //
                if (IsNV5orBetter(pDev))
                {                
                    //
                    // If VCLK > 250MHz and error is less than 0.2%, drop out
                    //
                    if (vclk > hiVclk1)
                    {
                        if (lwvs == 0) // zero error; rare, but would cause exception
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                        else if ((vclk/lwvs) > 200) // ok, now safe to div by lwvs (it's not zero)
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                    }
                    
                    if (lwvs < deltaOld) // go to closest match with M < highM
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                                            
                }
                else // !NV5
                {
                    if (lwvs < deltaOld)
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                }
            }
        }
    }                             
    
    // Verify we've established M, N, P values to use
    if (!bestM && !bestN && !bestP)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: dacCalcMNP didn't set any M, N, P values!!!\n");
        DBG_BREAKPOINT();
    }

    //
    // Return the results
    //
    *M = bestM;
    *N = bestN;
    *P = bestP;
    
    return (vclkClosest);
} 


//
//       dacCalcMNP_MaxM - Return the PLL values for a specified frequency while
//                          abiding by the given maximum M value
//
//          Clock frequency in MHz * 100
//
// The algorithm is constrained to keep within 0.5% error
// to remain inside the VBE spec.
// However, if you have a choice of what frequencies you
// request, try to avoid the following requested frequencies
// when you get above 300MHz, as they require M values > 3.
//
//  14.31818 MHz
// 29739 - 29918
// 30219 - 30393
// 31178 - 31343
// 31658 - 31818
// 32617 - 32767
// 33097 - 33243
// 34056 - 34193
// 34536 - 34668
//
//  13.5000 MHz
// 29397 - 29552
// 29849 - 30000
// 30754 - 30896
// 31206 - 31344
// 32110 - 32239
// 32563 - 32767
// 33467 - 33582
// 33919 - 34030
// 34824 - 34926
//
U032 dacCalcMNP_MaxM(
    PHWINFO  pDev,
    U032     Head,
    U032     Clock,
    U032    *M,    
    U032    *N,    
    U032    *P,
    U032    maxM
)
{
    U016  crystalFreq;
    U032  vclk;
    U016  vclkClosest = 0;
    U016  deltaOld;
    U016  bestM = 0;
    U016  bestP = 0;
    U016  bestN = 0;
    U016  lowM;
    U016  highM;
    U016  lowP, highP;
    U032  hiVclk1, hiVclk2, hiVclk3;
    U032  FminVco, FmaxVco;

    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032  lwv, lwv2;
    
    U016  lwvs, vclks;
    U016  t;
    
    vclk = (U032)(Clock * 10);     // Make KHz
    
    deltaOld = 0xFFFF;
    
    //
    // NV11 needs four highM buckets due to
    // induced jitter into the PLL's
    //
    if (IsNV11(pDev))
    {
        hiVclk1 = 150000;
        hiVclk2 = 200000;
        hiVclk3 = 340000;
    }
    else
    {
        hiVclk1 = 250000;
        hiVclk2 = 340000;

    }
    
    lowP  = 0;
    highP = 4;

    // if initDac() has run then FminVco and FmaxVco will be set.
    // But we might be called during devinit processing prior to
    //    initDac(), so we need a fallback...
    // NOTE: these defaults duplicated in initDac()
    if ((pDev->Dac.FminVco == 0) || (pDev->Dac.FmaxVco == 0))
    {
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;
            
            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }
    
    FminVco = pDev->Dac.FminVco;
    FmaxVco = pDev->Dac.FmaxVco;

    //
    // NV11 requires a modified Vco range, and since the BIOS's are already 
    // out in the field, shortcircuit this nice feature to fix the noise issue.
    //
    // When we're sure all older BIOS's have been flushed out of the world
    // (need 3.11.01.25.00+), this code can be removed.  If we detect a newer
    // BIOS version is in use, go ahead and use those values
    //
    // Mobile NV11 has always used these ranges, so this should not be a change
    // for them.
    //
    if (IsNV11(pDev) && (pDev->Chip.BiosRevision <= 0x03110125))
    {
        FminVco = 200000;
        FmaxVco = 400000;
    }

    // Apply any adjusts needed to FminVco/FmaxVco.
    //
    // 1). Make sure vclk is not so low that we'll miss the whole VCO range.
    //     Adjust FminVco to hit with the highest P (post divide).
    //
    if ((vclk << highP) < FminVco)
        FminVco = vclk << highP;

    //
    // 2). Also, check if two consecutive P values would cause us to miss
    //     the whole VCO range, where the first P is beneath FminVco and
    //     the next P is above FmaxVco.
    //
    for (powerP = lowP; powerP < highP; powerP++)
    {
        lwv = vclk << powerP;
        if ((lwv < FminVco) && ((lwv << 1) > FmaxVco))
        {
            // adjust FminVco or FmaxVco, whichever is closer
            if ((FminVco - lwv) < ((lwv << 1) - FmaxVco))
                FminVco = lwv;
            else
                FmaxVco = (lwv << 1);
        }
    }

    //
    // 3). Let a high vclk set the upper bound.
    //
    if (vclk > FmaxVco)
        FmaxVco = vclk;

    //
    // For NV15, we've got a bit in CR33 that indicates we're setting the
    // PLL in the "upper" VCO range.
    //
    if (IsNV15(pDev))
    {
        U008 lock, cr33;

        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        // put NV15 into NV15 VPLL VCO programming mode
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, cr33, Head);
        cr33 |= (1 << DRF_SHIFT(NV_CIO_CRE_LCD_VPLL_VCO));
        CRTC_WR(NV_CIO_CRE_LCD__INDEX, cr33, Head);

        RestoreLock(pDev, Head, lock);
    }

    //
    // Determine the current crystal frequency
    //   
    if (pDev->Chip.HalInfo.CrystalFreq == 14318180)
    {
        // 14.3Khz
        crystalFreq = 14318;

        lowM = 1;
             
        if (IsNV11(pDev))
        {
            //
            // NV11 needs four highM buckets due to
            // induced jitter into the PLL's
            //
            if (vclk > hiVclk3)
                highM = 2;
            else if (vclk > hiVclk2)
                highM = 4;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 14;

        }
        else
        {
            //
            // All chips except for NV11 only need three
            // highM buckets
            //
            if (vclk > hiVclk2)
                highM = 2;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 14;
          
        }
        
    }
    else
    {
        // 13.5Khz
        crystalFreq = 13500;

        lowM = 1;

        //
        // NV11 needs four highM buckets due to
        // induced jitter into the PLL's
        //
        if (IsNV11(pDev))
        {
            if (vclk > hiVclk3)
                highM = 2;
            else if (vclk > hiVclk2)
                highM = 4;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 13;
        }
        else
        {
            //
            // All chips except for NV11 only need three
            // highM buckets
            //
            if (vclk > hiVclk2)
                highM = 2;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 13;
        }

    }                      
    

    // Make sure we haven't gone past the maximum M
    if (highM > (U016)maxM) {
      highM = (U016)maxM;
    }


    //
    // P Loop
    //
    for (powerP = lowP; powerP <= highP; powerP++) // Init Power of P
    {                             
        // M Loop
        for (m = lowM; m <= highM; m++)
        {                          
            lwv = vclk << powerP;   // vclk * P
            
            // Compare with internal range of DAC
            if ((lwv >= FminVco) && (lwv <= FmaxVco))
            {
                lwv *= (U032)m;    // vclk * P * M
                
                //
                // In case of normal incoming clock, 
                // want to select a clock that is close
                // but can be greater or less than the target
                // In case of SpreadSpectrum want to be 
                // EQUAL or LOWER than the target frequency
                //
                // !! always skip this when searching with a limited M value
                //
                // Add crystal Frequency /2 - will round better
                //  lwv += (crystalFreq >> 1);
                
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                
                if (n > 0xFF)
                    break;
                    
                lwv *= crystalFreq; // N * crystal
                   
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                
                i = m;
                j = m;
                
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                                       
                lwv2 = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                
                if (lwvs < vclks)
                {               
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }            
                    
                lwvs -= vclks;      // ABS(Freq-Vclk);
                
                //
                // If this is an NV5 or better, allow the higher PCLK settings to use a lower M
                // if the error is small enough.  Just looking for the lowest overall error
                // may result in an M that is too high, possibly introducing PLL jitter.
                //
                if (IsNV5orBetter(pDev))
                {                
                    //
                    // If VCLK > 250MHz and error is less than 0.2%, drop out
                    //
                    if (vclk > hiVclk1)
                    {
                        if (lwvs == 0) // zero error; rare, but would cause exception
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                        else if ((vclk/lwvs) > 200) // ok, now safe to div by lwvs (it's not zero)
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                    }
                    
                    if (lwvs < deltaOld) // go to closest match with M < highM
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                                            
                }
                else // !NV5
                {
                    if (lwvs < deltaOld)
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                }
            }
        }
    }                             
    
    // Verify we've established M, N, P values to use
    if (!bestM && !bestN && !bestP)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: dacCalcMNP didn't set any M, N, P values!!!\n");
        DBG_BREAKPOINT();
    }

    //
    // Return the results
    //
    *M = bestM;
    *N = bestN;
    *P = bestP;
    
    return (vclkClosest);
} 


static U032 CalculateClockFrequency
(
   PHWINFO pDev,
   U032 M,
   U032 N,
   U032 P
)
{
    U032 Fout;
    // Fout = Fin * (N/M) / 2**P.
    U032 Fin = pDev->Chip.HalInfo.CrystalFreq;

    if ((M * (1 << P)) == 0)
       return 0;

    Fout = (Fin * N) / (M * (1 << P));

    return Fout;
}

//
// Clock programming methods
//

//
// dacProgramMClk - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
// If Ponly is TRUE, then we will only raise and lower P get as close to the desired
// clock speed as possible without going above or below it.
//
RM_STATUS dacProgramMClk
(
    PHWINFO pDev,
    U032    DisableDLLs
)
{
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 Head = 0;  // MPLL is on head 0
    RM_STATUS status;

    // Compute M, N, O, and P values
    dacCalcMNP( pDev, Head, pDev->Dac.HalInfo.MClk / 10000, &mNew, &nNew, &pNew );

    // Update Dac structure
    pDev->Dac.HalInfo.MPllM = mNew;
    pDev->Dac.HalInfo.MPllN = nNew;
    pDev->Dac.HalInfo.MPllO = 1;
    pDev->Dac.HalInfo.MPllP = pNew;

    status = nvHalDacProgramMClk(pDev, DisableDLLs);

    return status;
}

//
// dacProgramNVClk - Program NVCLK based on the value in
// pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramNVClk
(
    PHWINFO pDev 
)
{
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 Head = 0; // NVPLL is on head 0

    // Compute M, N, O, and P values
    dacCalcMNP(pDev, Head, pDev->Dac.HalInfo.NVClk / 10000, &mNew, &nNew, &pNew);

    // Update Dac structure
    pDev->Dac.HalInfo.NVPllM = mNew;
    pDev->Dac.HalInfo.NVPllN = nNew;
    pDev->Dac.HalInfo.NVPllO = 1;
    pDev->Dac.HalInfo.NVPllP = pNew;

    return(nvHalDacProgramNVClk(pDev));
}

RM_STATUS dacGetDisplayInfo
(
    PHWINFO pDev,
    U032 DisplayMap,
    U032 *Head,
    U032 *DisplayType,
    U032 *I2CWritePort,
    U032 *I2CReadPort
)
{
    U032 flag = 0;
    PDACDCBDEVDESC pDevDesc;
    pDACDCBI2CRECORD pDCBI2c;

    pDevDesc = pDev->Dac.DCBDesc;
    pDCBI2c  = pDev->Dac.DCBI2c;

    while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL)
    {
        if (pDevDesc->DevTypeUnit == DisplayMap)
        {
            flag = 1;
            break;
        }
        pDevDesc++;
        pDCBI2c++;
    }

    if (!flag) return RM_ERROR;

    if (Head)         *Head = pDevDesc->DCBRecHead;
    if (DisplayType)  *DisplayType = pDevDesc->DCBRecType;
    if (I2CWritePort) *I2CWritePort = pDCBI2c->WritePort;
    if (I2CReadPort)  *I2CReadPort = pDCBI2c->ReadPort;

    return RM_OK;
}

//
// dacProgramPClk - Program PCLK based on the value in pDev->Dac.PClk
//
// This routine uses the value in pDev->Dac.PClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramPClk
(
    PHWINFO pDev, 
    U032    Head,
    U032    PixelClock
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
    U032 mNew;
    U032 nNew;
    U032 pNew;

    // Compute M, N, O, and P values
    dacCalcMNP( pDev, Head, PixelClock, &mNew, &nNew, &pNew );

    // Update Dac structure
    pDev->halHwInfo.pDacHalInfo->VPllM = mNew;
    pDev->halHwInfo.pDacHalInfo->VPllN = nNew;
    pDev->halHwInfo.pDacHalInfo->VPllO = 1;
    pDev->halHwInfo.pDacHalInfo->VPllP = pNew;

    vidLutCurDacHalObj.Head = Head;

    return(nvHalDacProgramPClk(pDev, PixelClock, (VOID*) &vidLutCurDacHalObj));
}

// This function just enables the cursor by setting bit 0 of config register 0x31 to 1.
// The cursor image is not changed in any way.
VOID dacEnableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    cr31;
    U008    lock;
    
    lock = UnlockCRTC(pDev, Head);
    
    CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, Head);           
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (cr31 | (1 << DRF_SHIFT(NV_CIO_CRE_HCUR_ADDR1_ENABLE))), Head);

    RestoreLock(pDev, Head, lock);
}

// This function just disables the cursor by setting bit 0 of config register 0x31 to 0.
// The cursor image is not changed in any way.
VOID dacDisableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    cr31;
    U008    lock;
    
    lock = UnlockCRTC(pDev, Head);
    
    CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, Head);           
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (cr31 & ~(1 << DRF_SHIFT(NV_CIO_CRE_HCUR_ADDR1_ENABLE))), Head);

    RestoreLock(pDev, Head, lock);
}

/*  This function is mis-named. It also loads the cursor image offset in addition to enabling the
    cursor. This is used by the old style of cursor manipulation. 
*/
VOID enableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    lock;
    
    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
#ifdef NTRM    
    // Tell the DAC where to load the image from
    // The address is in pages, so shift 4 bits.
    if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x00000001)    // color or mono?
    {
        CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f, Head);
        CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 4) & 0xf8), Head);
    }
    else
    {
        // call crtc_wrm: need to add this routine
        CRTC_WRM(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f);
        CRTC_WRM(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 4) & 0xf8) | 1);
    }
#else
    // Tell the DAC where to load the image from. The address is in pages, so shift 4 bits.
#ifdef WIN31
    // On NV4 and later HCUR_ADDR0 is 23:17, HCUR_ADDR1 is 16:11 (on NV3 its 22:16)
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 13) & 0x7f);
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 5) & 0xfc) | 1);
//JohnH The Win9x code below is incorrect for NV4 and up, but the correct address
//JohnH gets set in dacProgramCursorImage.
//JohnH CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f);
//JohnH CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (pDev->Dac.CursorImageInstance >> 4) & 0xf8);
#endif // WIN31
#endif // NTRM
    
    // JJV - I am removing this call. Vblank will call this later if needed.
    //       This will fix a multimonitor cursor problem.  
    // Enable the cursor.
    //dacEnableCursor(pDev);

    RestoreLock(pDev, Head, lock);
}

/*  Turn off the enable bit in CRTC reg
    This function unlocks the CRTC extended registers and calls dacDisableCursor.
    This is used by the old style cursor manipulation functions. */
VOID disableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 lock;

#ifndef NTRM
    pDev->Dac.CrtcInfo[Head].CursorType = DAC_CURSOR_DISABLED;    // disable updates in vblank
#endif

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    dacDisableCursor(pDev, Head);

    RestoreLock(pDev, Head, lock);
}

RM_STATUS dacProgramCursorPosition
(
    PHWINFO pDev, 
    U032    Head,
    U032    cursorX, 
    U032    cursorY 
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // on modes below 400 lines, scanline doubling is used. we need to adjust cursor y postion
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac && pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode)
        cursorY *= 2;

//    if (CRTCHALINFO(pDev, Head, DisplayType) == TV)
        cursorX += pDev->Framebuffer.CursorAdjust;  // HW bug in NV4, position is off a little on TV

    DAC_REG_WR32(NV_PRAMDAC_CU_START_POS, cursorX | (cursorY << 16), Head);

    return RM_OK;
}

VOID dacDisableImage
(
    PHWINFO pDev,
    U032 Head
)
{
    U016 data;
    U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);

    EnableHead(pDev, Head);        // sequencer updates require setting CR44 

    // turn on blank
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    data |= 0x2000;
    WriteIndexed(NV_PRMVIO_SRX, data);

    EnableHead(pDev, prevHead);    // restore previous CR44 value
}

VOID dacEnableImage
(
    PHWINFO pDev,
    U032 Head
)
{
    U016 data;
    U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);

    EnableHead(pDev, Head);        // sequencer updates require setting CR44 

    // turn off blank
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    data &= ~0x2000;
    WriteIndexed(NV_PRMVIO_SRX, data);

    EnableHead(pDev, prevHead);    // restore previous CR44 value
}


VOID dacEnableDac
(
    PHWINFO pDev,
    U032 Head
)
{
    U008 lock, data08;    
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    if (!IsNV11(pDev) && (Head == 1)) // if not dual-head
    {
        return;
    }
    
    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    // enable vblank interrupt
    DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 1, Head);
    pDev->Dac.CrtcInfo[Head].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
    
    // device-specific disabling...
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac)
    {
        switch (pVidLutCurDac->DisplayType)
        {
            case DISPLAY_TYPE_MONITOR:
        
                // TO DO: this decision must be made by the HAL
                // if normal VGA (internal DAC)
                if (Head == 0) 
                {
                    dacEnableImage(pDev, Head);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);  // CRT on
                    //
                    // We need to be careful about powering down the TMDS
                    // transmitter on NV11 because we can lose a flat
                    // panel connected to the second crtc (head 1).
                    //
                    if (IsNV11(pDev))
                        dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);     // FPCLK off only;leave TMDS going for secondary crtc
                    else
                        dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);      // FPCLK/TMDS both off
                    CRTC_RD(0x33, data08, Head);
                    CRTC_WR(0x33, (data08 & ~0x02), Head);  // clear CR33[1] (BIOS flag)
                    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & 0x3F, Head);
                    dacSetCursorBlink(pDev, Head, 0); // set cursor blink rate for DOS
                }
        
                // PRAMDAC_FP is driving analog
                else
                {
                    // restore sync states
                    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, pDev->Dac.CrtcInfo[Head].CurrentVsyncState, Head);
                    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, pDev->Dac.CrtcInfo[Head].CurrentHsyncState, Head);
                    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);
                }
            
                break;   
                                       
            case DISPLAY_TYPE_FLAT_PANEL:
        
                // restore sync states
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, pDev->Dac.CrtcInfo[Head].CurrentVsyncState, Head);
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, pDev->Dac.CrtcInfo[Head].CurrentHsyncState, Head);
                dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);

                // Turn Hsync off and Vsync on, or leave both on, depending on what we found in registry
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                data08 &= ~0xC0;
                if (pDev->Dac.HsyncOff) 
                {
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 |= 0x80, Head); // disable horiz sync to put CRT in suspend
                }
                else
                {
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);    // leave both syncs on
                }

                if (pDev->Power.MobileOperation)
                    dacPowerOnMobilePanel(pDev,Head);

                //
                // Slave the CRTC again off the FP (this complements what was done
                // in dacDisableDac for the FP).
                //
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
                data08 |= 0x80;        // set bit 7
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data08, Head);    
                break;                              
            
            case DISPLAY_TYPE_TV:
                // Turn Hsync off and Vsync on, or leave both on, depending on what we found in registry
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                data08 &= ~0xC0;
                if (pDev->Dac.HsyncOff) 
                {
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 |= 0x80, Head); // disable horiz sync to put CRT in suspend
                }
                else
                {
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);    // leave both syncs on
                }
                dacEnableTV(pDev, Head);
                break;
            
            default:
                break;
        }
    }

    RestoreLock(pDev, Head, lock);

} // end of dacEnableDac()

VOID dacDisableDac
(
    PHWINFO pDev,
    U032 Head
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    if (!IsNV11(pDev) && (Head == 1)) // if not dual-head
    {
        return;
    }

    if (MC_POWER_LEVEL_0 != pDev->Power.State) {
        return;
        }

    // disable vblank interrupt, if there are no callbacks pending
    if (pDev->Dac.CrtcInfo[Head].VBlankCallbackList == NULL)
    {
        DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, Head);
        DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, Head);
        pDev->Dac.CrtcInfo[Head].StateFlags &= ~DAC_CRTCINFO_VBLANK_ENABLED;
    }

    // device-specific disabling...
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac)
    {
        pDev->Dac.CrtcInfo[Head].MonitorPowerSetMode = FALSE;
        switch (pVidLutCurDac->DisplayType)
        {
            case DISPLAY_TYPE_MONITOR:
        
                // TO DO: this decision must be made by the HAL
                // head 0 -- treat as CRT
                if (Head == 0)
                {
                    // disable hsync
                    if (pDev->Dac.HsyncOff) 
                        dacSetSyncState(pDev, Head, 0, 1); // H off, V on
                    else
                        dacSetSyncState(pDev, Head, 0, 0); // H off, V off
                    dacDisableImage(pDev, Head);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);
                }

                // head 1 -- treat as DFP
                else
                {    
                    // disable hsync
                    if (pDev->Dac.HsyncOff) 
                        dacSetSyncState(pDev, Head, 0, 1); // H off, V on
                    else
                        dacSetSyncState(pDev, Head, 0, 0); // H off, V off
                    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);
                }
                break;
            
            case DISPLAY_TYPE_FLAT_PANEL:
            {
                U008 lock, data;

                //Don't mess with the clocks on a Toshiba system unless we know that the
                //SBIOS has been informed of the switch.  They will turn off the panel
                //power for us, an event that should occur within a not-too-large time
                //window of turning off the clocks to spare the display.
                if ((pDev->Power.MobileOperation == 2) && !pDev->Dac.DisplayChangeInProgress)
                    break;

                // if we're mobile, turn the power off as well
                if (pDev->Power.MobileOperation)
                    dacPowerOffMobilePanel(pDev, Head);

                //
                // Unslave the CRTC from the FP (the BIOS uses the state of CR28
                // and CR33 to determine if a FP is active on this head). 
                //
                lock = UnlockCRTC(pDev, Head);

                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
                data &= ~0x80;        // clear bit 7
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);    
           
                RestoreLock(pDev, Head, lock);
                
                // NOTE: do not turn off FPCLK before unslaving CRTC
                dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);
                break;
            }            

            case DISPLAY_TYPE_TV:
            {
                dacSetSyncState(pDev, Head, 0, 0); // H off, V off (TV is disabled, CRT is powered down)
                // this has to be encoder dependent
                dacDisableTV(pDev, Head);
                break;
            }
            
            default:
                break;
        }
    }
    else
    {
        U008 lock, data;

        // Since pVidLutCurDac is NULL, pDev->Dac.DevicesEnabled will tell us if the flat panel is on.
        // If we're in a mobile environment on Head 1 and the flat panel is on,
        // go ahead and turn it off. This fixes the stand-by problem with 32095.
        if((Head == 1) && (pDev->Power.MobileOperation) && (pDev->Dac.DevicesEnabled & DAC_PANEL_POWER_ENABLED))
            dacPowerOffMobilePanel(pDev, Head);

        //
        // Disable in a display device independent way (i.e. drop the monitor
        // syncs, powerdown the DAC and turnoff sequencer memory fetches).
        //
        dacSetSyncState(pDev, Head, 0, 0); // H off, V off (no device is being driven off this head)
        dacDisableImage(pDev, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);
        //
        // Unslave the CRTC from the FP (the BIOS uses the state of CR28
        // and CR33 to determine if a FP is active on this head). 
        // This catches cases where we declined to disable the hardware
        // when we originally deallocated the object.  Solves problems
        // with Toshiba mobile.
        lock = UnlockCRTC(pDev, Head);

        CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
        data &= ~0x80;        // clear bit 7
        CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);    

        RestoreLock(pDev, Head, lock);
    }

} // end of dacDisableDac()

RM_STATUS dacProgramVideoStart
(
    PHWINFO pDev, 
    U032    Head,
    U032    StartAddr, 
    U032    Pitch 
)
{
    if (pDev->pStereoParams && (pDev->pStereoParams->Flags & (STEREOCFG_STEREOACTIVATED|STEREOCFG_INTERLACED)) 
        == (STEREOCFG_STEREOACTIVATED|STEREOCFG_INTERLACED))
    {
        // Asus stereo uses interlaced video modes.
        Pitch >>= 1;
    }
    if (!pDev->Vga.Enabled)
    {
        VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;

        vidLutCurDacHalObj.Head = Head;

        //
        // If the pitch of the RGB surface does not match the current display width, we
        // need to tweak the CRTC to a different pitch adjust.
        //
        // Compare Pitch against pDev->Framebuffer.DisplayPitch rather than trying to
        // calculate it, since DisplayPitch has been aligned for the HW already (e.g. NV10).
        //
        // Checking against DisplayPitch actually doesn't save us in the case where the 2
        // surfaces have different pitch values. This really needs to be checking against
        // the last loaded pitch ... but then we'd be programming more than just the start
        // addr 1/2 the time.
        //
        // For now, print out a message, so the driver can be changed to flip between
        // surfaces of the same pitch making our job easier and giving us the best perf.
        //        
//#if 0 // This was used for video class63, but later classes take care of this case
//        if (Pitch != pDev->Framebuffer.DisplayPitch)
        {

            U008      i, lock, crtc_index;
            U032      val32;

//            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Flipping between different pitched surfaces!!!\n\r");

            //
            // Save the current CRTC index
            //
            if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
                crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
            else
                crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

            // unlock the extended regs
            lock = UnlockCRTC(pDev, Head);

            // Write the alternative pitch to the CRTC Offset Register
            // The value written to CR13/CR19 is the number of 8-byte chunks
            CRTC_WR(NV_CIO_CR_OFFSET_INDEX, (Pitch >> 3) & 0xFF, Head);

            // Modify the bits in the extended register as well
            CRTC_RD(NV_CIO_CRE_RPC0_INDEX, i, Head);
            i &= 0x1F;
            val32 = ((Pitch >> 3) & 0x700) >> 3;
            i |= (U008)val32; 
            CRTC_WR(NV_CIO_CRE_RPC0_INDEX, i, Head);

            RestoreLock(pDev, Head, lock);

            // Restore index
            if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
                REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
            else
                REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);	// restore crtc index
        }
//#endif

        // Program the new start address; this will latch at the end of blank
        if (pDev->pStereoParams)
        {
            pDev->pStereoParams->FlipOffsets[3][0] = StartAddr;
            if ((pDev->pStereoParams->Flags & (STEREOCFG_STEREOACTIVATED|STEREOCFG_INTERLACED)) == STEREOCFG_STEREOACTIVATED)
            {
                return RM_OK;
            }
        }
        nvHalDacSetStartAddr(pDev, StartAddr, &vidLutCurDacHalObj);
    }
    return RM_OK;
}

RM_STATUS dacProgramLUT
(
    PHWINFO pDev, 
    U032    Head,
    U032*   Palette, 
    U032    numEntries 
)
{
    U032    i, rgb;

    // start at palette 0 and autoincrement
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0, Head);
    for (i = 0; i < numEntries; i++)
    {
        rgb = Palette[i];
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)(rgb >> 16), Head);    // b
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)(rgb >> 8), Head);     // g
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)rgb, Head);            // r
    }
    return RM_OK;
}

RM_STATUS dacProgramScanRegion
(
    PHWINFO pDev,
    U032    Head,
    U032    startLine,
    U032    stopLine,
    U032    polarity
)
{
    if (IsNV15(pDev) || IsNV11(pDev) || IsNV1A(pDev) || IsNV20(pDev))
    {
        DAC_REG_WR32(NV_PCRTC_RASTER_START, startLine | DRF_NUM(_PCRTC, _RASTER_START, _POL, polarity), Head);
        DAC_REG_WR32(NV_PCRTC_RASTER_STOP,  stopLine, Head);
        return (RM_OK);    
    }
    else
        return (RM_ERROR);
}

/************************************************************
* Here is how the H & V blank and retrace values map to the config registers:
    Hbs<0:7> = CR02<0:7>
    Hbe<0:4> = CR03<0:4>
    Hbe<5>   = CR05<7>
    Hbe<6>   = CR25<4>
    Vbs<0:7> = CR15<0:7>
    Vbs<8>   = CR07<3>
    Vbs<9>   = CR09<5>
    Vbs<10>  = CR25<3>
    Vbe<0:7> = CR16<0:7>
    
    Hrs<0:7> = CR04<0:7>
    Hre<0:4> = CR05<0:4>
    Vrs<0:7> = CR10<0:7>
    Vrs<8>   = CR07<2>
    Vrs<9>   = CR07<7>
    Vrs<10>  = CR25<2>
    Vre<0:3> = CR11<0:3>
***********************************************************/

// Position the screen on the display device (CRT or TV).
// DeviceMap: bit 0..7 = CRT0-7, bit 8..15 = TV 8-15
// Position:  bit 0..3 = position, bit 4 = default, bit 5 = last committed positon, bit 6 = commit
RM_STATUS dacSetDesktopPosition
(
    PHWINFO pDev, 
    U032    DeviceMap, 
    U032    Position
)
{

    // Add CRT positioning here

    // Position TV
    return dacPositionTV(pDev, 0, Position);
}
    
//  Position TV display in a device-independent way (via CRTC).
RM_STATUS dacPositionTV
(
    PHWINFO pDev, 
    U032    Head, 
    U032    Position
)
{
    RM_STATUS status = RM_OK;
    U008 lock;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 VTotal, Vbs, Vt, Vrs = 0;
    U008 Skew, Cr01, Cr04, Cr05, Cr07, Cr21, Cr28;
    
#if 0
    // If no positioning info is given, then return whether this is the default position
    if (Position == 0) 
    {
        if (Vt == pDev->Dac.CrtcInfo[Head].MonitorPosition.Vt) // need to add Vt to MonitorPosition
            if (Hrs == pDev->Dac.CrtcInfo[Head].MonitorPosition.Hrs) 
                return TV_DEFAULT_POSITION;
        return TV_CUSTOM_POSITION;
    }
    if (Position & POS_DEFAULT) 
    {
        // Set default position
    }
    if (Position & POS_COMMIT) 
    {
        // Commit the current position to the registry
    }
    if (Position & POS_CANCEL) 
    {
        // Set the last committed position (saved in registry)
    }
#endif    
    
    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    // save the shadow lock
    CRTC_RD(0x21, Cr21, Head);
    CRTC_WR(0x21, Cr21 | 0x10, Head); // enable loading VT

    // The only adjustment we can do is the position, and that is done thru CRTC adjustment,
    // so this is actually generic TV positioning code. Should work on any encoder.

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    VTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight;    
    Vbs = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
        
    // Horizontal position is controlled at pixel granularity by Cr28, 
    // and at character granularity by Cr4 (HRS)
    // Vertical position is controlled by Vertical Total.
    // Increasing the H retrace start value shortens the time between the sync and the start of display,
    // moving the screen to the left; decreasing retrace starts moves right.
    // Increasing vertical total increases time between sync and start of the display, moving the screen
    // down; decreasing VT moves the screen up.
    if (Position & POS_RIGHT) // right
    {
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
            CRTC_RD(NV_CIO_CR_HRS_INDEX, Cr04, Head);
            CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr01, Head);
            Skew = Cr28 & 0x38;
            if (Skew == 0x38) // at max?
            {
                if ((Cr04) > Cr01) // HRS must be > display end
                {
                    Cr04--;            // move right one char
                    Cr28 &= ~0x38;     // and set skew back to 0
                }
                else
                    status = RM_ERROR;
            }
            else
            {
                Skew >>= 3;
                Skew++;   // increment one pixel
                Skew <<=3;
            }
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, Cr04, Head);
        
     }
     if (Position & POS_LEFT) // left
     {
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
            CRTC_RD(NV_CIO_CR_HRS_INDEX, Cr04, Head);
            CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
            Skew = Cr28 & 0x38;
            if (Skew == 0x00) 
            {
                if (((Cr04 + 1) & BITS0_4) < Cr05) // start must be < end
                {
                    Cr04++;            // move left one char
                    Cr28 |= 0x38;     // and set skew to max
                }
                else
                    status = RM_ERROR;
            }
            else
            {
                Skew >>= 3;
                Skew--;   // decrement one pixel
                Skew <<= 3;
            }
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, Cr04, Head);
    }
    if (Position & POS_DOWN) // down
    {
            // get current VT
            CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
            CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
            if (Cr07 & BIT0)
                Vt |= BIT8;
            if (Cr07 & BIT5)
                Vt |= BIT9;
            if (Vt < VTotal + 10) // put some limit on how far we increment
            {
                Vt++;
                Cr07 &= ~(BIT5 | BIT0);
                if (Vt & BIT8) Cr07 |= BIT0;
                if (Vt & BIT9) Cr07 |= BIT5;
                CRTC_WR(NV_CIO_CR_VDT_INDEX, Vt & 0xff, Head);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
            }
            else
                status = RM_ERROR;
    }
    if (Position & POS_UP)  // up
    {
            // get current VT
            CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
            CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
            if (Cr07 & BIT0)
                Vt |= BIT8;
            if (Cr07 & BIT5)
                Vt |= BIT9;
            // get VRS too
            CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
            if (Cr07 & BIT2) 
                Vrs |= BIT8;
            if (Cr07 & BIT7)
                Vrs |= BIT9;
            if (Vt > Vrs) // total must be > sync start
            {
                Vt--;
                Cr07 &= ~(BIT5 | BIT0);
                if (Vt & BIT8) Cr07 |= BIT0;
                if (Vt & BIT9) Cr07 |= BIT5;
                CRTC_WR(NV_CIO_CR_VDT_INDEX, Vt & 0xff, Head);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
            }
            else
                status = RM_ERROR;
    }
    CRTC_WR(0x21, Cr21, Head); // restore shadow locks
    RestoreLock(pDev, Head, lock);
    
    return status;
}

//  After every mode set, we save the H & V retrace in nvinfo, so we can restore the default screen position
VOID dacSaveMonitorDefaultPosition
(
    PHWINFO pDev,
    U032    Head
)
{
    PDACMONITORPOSITION pDacMonPos;
    U016    Hrs, Hre, Vrs, Vre;
    U016    Hbs, Hbe, Vbs, Vbe;
    U008    Cr03, Cr05, Cr07, Cr09, Cr25;
    short   temp;

// debug 
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);

    // read all the necessary config registers.
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);

    // Construct Hbs
    CRTC_RD(NV_CIO_CR_HBS_INDEX, Hbs, Head);
    // Construct Hbe
    Hbe = Cr03 & BITS0_4;
    if (Cr05 & BIT7)
        Hbe |= BIT5;
    if (Cr25 & BIT4)
        Hbe |= BIT6;
    // Construct Vbs
    CRTC_RD(NV_CIO_CR_VBS_INDEX, Vbs, Head);
    if (Cr07 & BIT3)
        Vbs |= BIT8;
    if (Cr09 & BIT5)
        Vbs |= BIT9;
    if (Cr25 & BIT3)
        Vbs |= BIT10;
    // Construct Vbe
    CRTC_RD(NV_CIO_CR_VBE_INDEX, Vbe, Head);

    // Construct Hrs
    CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);
    // Construct Hre
    Hre = Cr05 & BITS0_4;
    // Construct Vrs
    CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
    if (Cr25 & BIT2)
        Vrs |= BIT10;
    if (Cr07 & BIT7)
        Vrs |= BIT9;
    if (Cr07 & BIT2)
        Vrs |= BIT8;
    // Construct Vre
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Vre, Head);
    Vre &= BITS0_3;

    // The horizontal/vertical, blank/retrace end values are really the width of the respective signal.
    // Calculate the absolute end values. It is a bit cumbursome because the number of bits of information
    // is not uniform.
    // The formula is: <Absolute end value> = <start-value> + ((<width> - <start-value>) & (# of bits))
    temp = (short)Hbe - (short)Hbs; 
    temp &= 0x7f; // just take the low 7 bits
    Hbe = Hbs + temp;
    
    temp = (short)Hre - (short)Hrs; 
    temp &= 0x1f; // just take the lower 5 bits
    Hre = Hrs + temp;

    temp = (short)Vbe - (short)Vbs; 
    temp &= 0x7f; // just take the low 7 bits
    Vbe = Vbs + temp;
    
    temp = (short)Vre - (short)Vrs; 
    temp &= 0xf; // just take the lower 4 bits
    Vre = Vrs + temp;

    // save it off in nvinfo
    pDacMonPos = &pDev->Dac.CrtcInfo[Head].MonitorPosition;
    pDacMonPos->Hbs = Hbs;
    pDacMonPos->Hbe = Hbe;
    pDacMonPos->Vbs = Vbs;
    pDacMonPos->Vbe = Vbe;
    pDacMonPos->Hrs = Hrs;
    pDacMonPos->Hre = Hre;
    pDacMonPos->Vrs = Vrs;
    pDacMonPos->Vre = Vre;
}

//****************************************************************************************
/*  Adjust monitor horizontal position
    This is accomplished by increasing/decreasing the retrace start/end values
    The adjustment is character granularity
*/
static VOID SetRetraceH
(   PHWINFO pDev, 
    U032    Head,
    U032    Hrs, 
    U032    Hre
)
{
    U008    Cr05;

    // Get HRE
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    Cr05 &= ~BITS0_4;        // Clear bits 0:4
    Cr05 |= (Hre & BITS0_4); // Combine new HRE bits 0:4 with other bits

    // Write out adjustment
    CRTC_WR(NV_CIO_CR_HRS_INDEX, Hrs, Head);
    CRTC_WR(NV_CIO_CR_HRE_INDEX, Cr05, Head);
}

//****************************************************************************************
/*  Adjust monitor vertical position
    This is accomplished by increasing/decreasing the retrace start/end values
    The adjustment is scanline granularity
*/
static VOID SetRetraceV
(   PHWINFO pDev, 
    U032    Head,
    U032    Vrs, 
    U032    Vre
)
{
    U008    Cr10, Cr11, Cr07, Cr25;

    // Get CR25, CR7, CR11, mask VR bits
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    Cr07 &= ~(BIT7 | BIT2);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    Cr25 &= ~BIT2;
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    Cr11 &= ~BITS0_3;
        
    Cr10 = (U008)(Vrs & BITS0_7);
    // Combine new VRS value with other bits in CR07, CR25.
    if (Vrs & BIT10)
        Cr25 |= BIT2;
    if (Vrs & BIT9)
        Cr07 |= BIT7;
    if (Vrs & BIT8)
        Cr07 |= BIT2;

    // Combine VRE with other bits in CR11
    Cr11 |= (Vre & BITS0_3);
    
    // Write out adjustment
    CRTC_WR(NV_CIO_CR_VRS_INDEX, Cr10, Head);  
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Cr11, Head);
}

//****************************************************************************************
/*  Adjust monitor postion
    A CRT is positioned by moving the sync pulses relative to the display data.
*/
RM_STATUS dacSetMonitorPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    Hrs,
    U032    Hre,
    U032    Vrs,
    U032    Vre
)
{
    U032      Vde, Vt;
    U008      Cr01, Cr07, Cr11, Cr21, Cr25, val;
    U008      lock;
    U008      UpdatedCr11;
    RM_STATUS rmStatus = RM_OK;

    // A CRT driven by a DAC is positioned by CRTC timing;
    // a CRT driven by FP timing is positioned by FP timing
    if (Head == 0) // TODO: don't assume Head B = FP; use DCB
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
        val = Cr11 & 0x7f;                          // clear write protection bit
        CRTC_WR(NV_CIO_CR_VRE_INDEX, val, Head);

        CRTC_RD(0x21, Cr21, Head);
        CRTC_WR(0x21, 0xf8, Head);       // disable shadowing for TV

        CRTC_RD(NV_CIO_CR_HDE_INDEX, Cr01, Head);     // read H display end

        // Check that the sync width doesn't go to 0 and that the sync pulse is beyond display end
        if ((Hre <= (Hrs & 0x1f)) || (Hrs <= Cr01))
        {
            rmStatus = RM_ERROR;
            goto done;
        }

        // Get overflow bits
        CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);    

        // Check that the sync width doesn't go to 0 and that the sync pulse is beyond display end
        CRTC_RD(NV_CIO_CR_VDE_INDEX, Vde, Head);    // read V display end (CR12)
        if (Cr07 & BIT(1)) Vde |= 0x100;
        if (Cr07 & BIT(6)) Vde |= 0x200;
        if (Cr25 & BIT(1)) Vde |= 0x400;

        // Check also that the sync pulse doesn't enter the display start (vertical total)
        CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
        if (Cr07 & BIT(0)) Vt |= 0x100;
        if (Cr07 & BIT(5)) Vt |= 0x200;    
        if (Cr25 & BIT(0)) Vt |= 0x400; 

        // Check for error conditions
        if ((Vre <= Vrs) || (Vrs < Vde) || (Vre > Vt))
        {
            rmStatus = RM_ERROR;
            goto done;
        }

        /*
        // Make sure we don't change these values during the vblank interval.
        while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_ACTIVE)
            ;
        while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_INACTIVE)
            ;
        */

        SetRetraceH(pDev, Head, Hrs, Hre);
        SetRetraceV(pDev, Head, Vrs, Vre);

        CRTC_WR(0x21, Cr21, Head);

        // the lower 4 bits in CR11 were updated by SetRetraceV(), don't mess it up
        CRTC_RD(NV_CIO_CR_VRE_INDEX, UpdatedCr11, Head);
        Cr11 = (Cr11 & ~BITS0_3) | (UpdatedCr11 & BITS0_3);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, Cr11, Head);

     done:
        RestoreLock(pDev, Head, lock);
    }
    else // FP timing
    {
        PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
        // The default timing is in the dac object. Only the sync timings change.
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        
        // Check that the sync pulse is between display end and total
        if ((Hrs <= pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth) || (Hre >= pVidLutCurDac->HalObject.Dac[0].TotalWidth))
        {
            rmStatus = RM_ERROR;
        }
        // 
        if ((Vrs <= pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight) || (Vre >= pVidLutCurDac->HalObject.Dac[0].TotalHeight))
        {
            rmStatus = RM_ERROR;
        }
        if (rmStatus == RM_OK) 
        {
            // The timings are reasonable, write them to HW        
            DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, Hrs, Head);
            DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, Hre, Head);
            DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, Vrs, Head);
            DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, Vre, Head);
        }
    }

    return rmStatus;
}
 
//  Get the H & V Blank and retrace values from nvinfo.
VOID dacGetMonitorDefaultPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    *pHbs,
    U032    *pHbe,
    U032    *pVbs,
    U032    *pVbe,
    U032    *pHrs,
    U032    *pHre,
    U032    *pVrs,
    U032    *pVre
)
{
    PDACMONITORPOSITION pDacMonPos;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;


    if (Head == 0) // TODO: don't assume Head B = FP; use DCB
    {
        // We saved the timings when did the modeset (NOTE: they are also in the DAC object, 
        // so it is no longer necessary to have this structure)
        pDacMonPos = &pDev->Dac.CrtcInfo[Head].MonitorPosition;

        *pHbs = pDacMonPos->Hbs;
        *pHbe = pDacMonPos->Hbe;
        *pVbs = pDacMonPos->Vbs;
        *pVbe = pDacMonPos->Vbe;
        *pHrs = pDacMonPos->Hrs;
        *pHre = pDacMonPos->Hre;
        *pVrs = pDacMonPos->Vrs;
        *pVre = pDacMonPos->Vre;
    }
    else
    {
        // The timings are in the DAC object
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        
        *pHbs = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
        *pHbe = *pHbs + pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth;
        *pVbs = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
        *pVbe = *pVbs + pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight;
        *pHrs = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
        *pHre = *pHrs + pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth;
        *pVrs = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
        *pVre = *pVrs + pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight;

    }
}

//  Get a string pointing to a key in the Display section
//  The string is of the type hresxyres, e.g. "1024x768"
//  Return 0 if its not a desktop mode
void dacFindRegistryKeyDisplayPosition
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    char    *strDisplayMode
)
{
    U032    hres, vres;
    U032    strIndex;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hres = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vres = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    //
    // For non-TV modes, convert the resolution into a string
    //
    // Oh, to have a sscanf() handy...
    //
    strIndex = 0;   // start at the beginning

    //
    // Prepend the TV format if necessary
    //
    if (!isMonitor)
    {
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                strDisplayMode = osStringCopy(strDisplayMode, "NTSC");
                strIndex = 4;
                break;
            case PAL_M: // unique case; does not use normal PAL timing
                strDisplayMode = osStringCopy(strDisplayMode, "PALM");
                strIndex = 4;
                break;
            default:    // rest are PAL modes
                strDisplayMode = osStringCopy(strDisplayMode, "PAL");
                strIndex = 3;
                break;     
        }
    }

    //
    // Assume the resolution is always below 9999x9999 and above 99x99
    // (this makes it a bit easier, especially with floating 0's)
    //
    // Start with the horizontal resolution first
    //
    if (hres / 1000)
    {
        strDisplayMode[strIndex++] = (U008)(hres/1000)+'0';
        hres -= (hres/1000)*1000;
    }

    if (hres / 100)
    {
        strDisplayMode[strIndex++] = (U008)(hres/100)+'0';
        hres -= (hres/100)*100;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    if (hres / 10)
    {
        strDisplayMode[strIndex++] = (U008)(hres/10)+'0';
        hres -= (hres/10)*10;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    strDisplayMode[strIndex++] = (U008)hres + '0';

    //
    // Append a lower case 'x'
    //
    strDisplayMode[strIndex++] = 'x';

    // 
    // Now generate the vertical value
    //
    if (vres / 1000)
    {
        strDisplayMode[strIndex++] = (U008)(vres/1000)+'0';
        vres -= (vres/1000)*1000;
    }
    
    if (vres / 100)
    {
        strDisplayMode[strIndex++] = (U008)(vres/100)+'0';
        vres -= (vres/100)*100;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    if (vres / 10)
    {
        strDisplayMode[strIndex++] = (U008)(vres/10)+'0';
        vres -= (vres/10)*10;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    strDisplayMode[strIndex++] = (U008)vres + '0';

    //
    // Zero append to the end
    //
    strDisplayMode[strIndex] = 0;

    return;

}

//  Save the screen position for the current mode in the registry
//  Find the registry key for this device and this mode
RM_STATUS dacWriteDesktopPositionToRegistry
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    U008 *  position, 
    U032    numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";
    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, isMonitor, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = 0;

    return osWriteRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, position, numBytes);
}

//  Read the screen position for the current mode from the registry
RM_STATUS dacReadDesktopPositionFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    U008 *  position, 
    U032 *  numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";

    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, isMonitor, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = 0;

    return osReadRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, position, numBytes);
}

//  Return the registry values for TV position, brightness, contrast and flicker filter.
RM_STATUS dacReadTVDesktopPositionFromRegistry
(
    PHWINFO pDev,
    U032 Head,
    U008 *Params,
    U032 *numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";

    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, 0, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = 0;

    return osReadRegistryBinary(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, Params, numBytes);
}

//  Read the TV type (NTSC_, PAL_) from the registry
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacReadTVStandardFromRegistry
(
    PHWINFO pDev,
	U032 *	type
)
{

    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVtype, type);
}

//  Write the TV type (NTSC_, PAL_) from the registry
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacWriteTVStandardToRegistry
(
    PHWINFO pDev,
	U032 	type
)
{

    return osWriteRegistryDword(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVtype, type);
}

//  Read the TV Out format (Composite on S-video, S-Video, Auto select)
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacReadTVOutFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032   *type
)
{
    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVOutType, type);
}

//  Check Registry for Philips 7108B special setting
RM_STATUS dacReadTVPhilipsBFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032   *type
)
{
char strTVPhilipsB[] = "Philips7108B";

    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVPhilipsB, type);
}

//  Write the TV Out format (Composite on S-video, S-Video, Auto select)
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacWriteTVOutToRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032    type
)
{
    pDev->Dac.TVoutput = type;  // save in pDev, because NT cannot read registry at modeset time.
    return osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strTVOutType, type);
}

//  Look for registry entry telling us how to treat monitor syncs when monitor is not in use.
//  If we find "PowerSaverHsyncOn", we'll turn on Hsync & leave Vsync on when we want to blank the CRT
//  but driver DFP or TV on the same head. Otherwise, we'll turn off HSync, which is the legacy
//  method for communicating power mgmt requests to displays.
RM_STATUS dacReadMonitorSyncsFromRegistry
(
    PHWINFO pDev,
    U032   *type
)
{
    char strMonitorSyncs[] = "PowerSaverHsyncOn";

    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strMonitorSyncs, type);
}


RM_STATUS dacGetMonitorInfo
(
    PHWINFO pDev,
    U032    Head,
    U032    *MonitorConnected
)
{
    *MonitorConnected = 0;

    if (dacMonitorConnectStatus(pDev, Head))
        *MonitorConnected = 1;
    return RM_OK;
}
// Write a CRTC timing parameter into the CRTC registers
VOID dacSetCRTC
(
    PHWINFO pDev, 
    U032 Head, 
    U032 Param, 
    U032 Val
)
{
    U008 Crtc;
    U032 Val2;

    switch (Param) 
    {
    case H_TOTAL:
        Val2 = (Val >> 3) - 5;
        Crtc = (U008)(Val2 & 0xff);
        CRTC_WR(0, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x100)               
            Crtc |= BIT(0);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_DISPLAY_END:
        Crtc = (U008) ((Val >> 3) - 1);
        CRTC_WR(1, Crtc, Head);
        break;
    case H_BLANK_START:
        Val2 = (Val >> 3) - 1;
        Crtc = (U008)(Val2 & 0xff);
        CRTC_WR(2, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(2);
        if (Val2 & 0x100)               
            Crtc |= BIT(2);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_BLANK_END:
        Val2 = (Val >> 3) - 1;
        CRTC_RD(3, Crtc, Head);     // HBE bits 4:0
        Crtc &= 0xe0;
        Crtc |= (U008)(Val2 & 0x1f);
        CRTC_WR(3, Crtc, Head);
        CRTC_RD(5, Crtc, Head);
        Crtc &= ~BIT(7);
        if (Val2 & 0x20)               // HBE bit 5
            Crtc |= BIT(7);
        CRTC_WR(5, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(4);
        if (Val2 & 0x40)
            Crtc |= BIT(4);             // HBE bit 6
        CRTC_WR(0x25, Crtc, Head);
        break;
    case H_RETRACE_START:
        Val2 = (Val >> 3) + 1;
        Crtc = (U008) (Val2 & 0xFF);
        CRTC_WR(4, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x100)
            Crtc |= BIT(3);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_RETRACE_END:
        Val2 = (Val >> 3) + 1;
        CRTC_RD(5, Crtc, Head);     // HRE bits 4:0
        Crtc &= 0xe0;
        Crtc |= (U008)(Val2 & 0x1f);
        CRTC_WR(5, Crtc, Head);
        break;
    case V_TOTAL:
        Val2 = Val - 2;
        Crtc = (U008) Val2;
        CRTC_WR(6, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(0x21);
        if (Val2 & 0x100) Crtc |= BIT(0);
        if (Val2 & 0x200) Crtc |= BIT(5);
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x400) Crtc |= BIT(0);
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x800) Crtc |= BIT(0);
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_DISPLAY_END:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x12, Crtc, Head);    // VDE 7:0
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(0x42);
        if (Val2 & 0x100) Crtc |= BIT(1);  // VDE 8
        if (Val2 & 0x200) Crtc |= BIT(6);  // VDE 9
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(1);
        if (Val2 & 0x400) Crtc |= BIT(1);  // VDE 10
        CRTC_WR(0x25, Crtc, Head);
        break;
    case V_RETRACE_START:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x10, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(BIT(2) | BIT(7));
        if (Val2 & 0x100) Crtc |= BIT(2);  // VRS 8
        if (Val2 & 0x200) Crtc |= BIT(7);  // VRS 9
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(2);
        if (Val2 & 0x400) Crtc |= BIT(2);  // VRS 10
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(4);
        if (Val2 & 0x800) Crtc |= BIT(4);  // VRS 11
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_RETRACE_END:
        Val2 = Val - 1;
        CRTC_RD(0x11, Crtc, Head);
        Crtc &= 0xF0;
        Crtc |= (U008) (Val2 & 0x0F);
        CRTC_WR(0x11, Crtc, Head);
        break;
    case V_BLANK_START:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x15, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x100) Crtc |= BIT(3);  // VBS 8
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(9, Crtc, Head);
        Crtc &= ~BIT(5);
        if (Val2 & 0x200) Crtc |= BIT(5);  // VBS 9
        CRTC_WR(9, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x400) Crtc |= BIT(3);  // VBS 10
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(6);
        if (Val2 & 0x800) Crtc |= BIT(6);  // VBS 11
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_BLANK_END:
        Crtc = (U008) Val - 1;
        CRTC_WR(0x16, Crtc, Head);
        break;
    }
}

// Write a CRTC timing parameter into the CRTC registers
U032 dacGetCRTC
(
    PHWINFO pDev, 
    U032 Head, 
    U032 Param
)
{
    U008 Crtc;
    U032 Val=0, Val2;

    switch (Param) 
    {
    case H_TOTAL:
        CRTC_RD(0, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x100;
        Val = (Val + 5) * 8;
        break;
    case H_DISPLAY_END:
        CRTC_RD(1, Crtc, Head);
        Val = (U032)(Crtc + 1) * 8;
        break;
    case H_BLANK_START:
        CRTC_RD(2, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x100;
        Val = (Val + 1) * 8;
        break;
    case H_BLANK_END:
        CRTC_RD(3, Crtc, Head);     // HBE bits 4:0
        Val = (U032)(Crtc & 0x1f);
        CRTC_RD(5, Crtc, Head);
        if (Crtc & 0x80) Val |= 0x20;
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(4)) Val |= 0x40;
        Val++;
        Val2 = dacGetCRTC(pDev, Head, H_BLANK_START);
        Val2 >>= 3;                     // convert HRS back to real chars
        Val2++;
        if (Val >= (Val2 & 0x7f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0x180);
        }
        else
        {
            Val |= ((Val2 + 0x80) & 0x180);    // add Start + carry
        }
        Val *= 8;
        break;
    case H_RETRACE_START:
        CRTC_RD(4, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x100;
        Val--;
        Val *= 8;
        break;
    case H_RETRACE_END:
        CRTC_RD(5, Crtc, Head);     // HRE bits 4:0
        Val = (U032)(Crtc & 0x1f);
        Val--;
        Val2 = dacGetCRTC(pDev, Head, H_RETRACE_START);
        Val2 >>= 3;                     // convert HRS back to real chars
        Val2--;
        if (Val >= (Val2 & 0x1f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0x1E0);
        }
        else
        {
            Val |= ((Val2 + 0x20) & 0x1E0);    // add Start + carry
        }
        Val *= 8;
        break;
    case V_TOTAL:
        CRTC_RD(6, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x100;
        if (Crtc & BIT(5)) Val |= 0x200;
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x400;
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x800;
        Val += 2;
        break;
    case V_DISPLAY_END:
        CRTC_RD(0x12, Crtc, Head);    // VDE 7:0
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(1)) Val |= 0x100;  // VDE 8
        if (Crtc & BIT(6)) Val |= 0x200;  // VDE 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(1)) Val |= 0x400;  // VDE 10
        Val++;
        break;
    case V_RETRACE_START:
        CRTC_RD(0x10, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x100;  // VRS 8
        if (Crtc & BIT(7)) Val |= 0x200;  // VRS 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x400;  // VRS 10
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(4)) Val |= 0x800;  // VRS 11
        Val++;
        break;
    case V_RETRACE_END:
        CRTC_RD(0x11, Crtc, Head);
        Val = (U032)(Crtc & 0x0f);
        Val2 = dacGetCRTC(pDev, Head, V_RETRACE_START);
        if (Val >= (Val2 & 0x0f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0xFF0);
        }
        else
        {
            Val |= ((Val2 + 0x10) & 0xFF0);    // add Start + carry
        }
        Val++;
        break;
    case V_BLANK_START:
        CRTC_RD(0x15, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x100;  // VBS 8
        CRTC_RD(9, Crtc, Head);
        if (Crtc & BIT(5)) Val |= 0x200;  // VBS 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x400;  // VBS 10
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(6)) Val |= 0x800;  // VBS 11
        Val++;
        break;
    case V_BLANK_END:
        CRTC_RD(0x16, Crtc, Head);
        Val = (U032)Crtc + 1;
        Val2 = dacGetCRTC(pDev, Head, V_RETRACE_START); // End = Start + width of sync
        if (Val >= (Val2 & 0xff))    // if low byte of end > low byte of start 
        {
            Val |= (Val2 & 0xf00);  // combine with upper bits of V_BLANK_START
        }
        else
        {
            Val |= ((Val2 + 0x100) & 0xf00);    // combine with upper bits of V_BLANK_START plus carry
        }
        break;
    }
    return Val;
}
//  Get CRTC timing values from either CRTC registers or Windows registry
RM_STATUS dacGetCRTCTiming
(
    PHWINFO pDev,
    U032    Head,
    NV_CFGEX_CRTC_TIMING_PARAMS    *Params
)
{
    U008    lock;

    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTER) // Get currect CRTC values
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);
        
        Params->HTotal = dacGetCRTC(pDev, Head, H_TOTAL);    
        Params->HDisplayEnd = dacGetCRTC(pDev, Head, H_DISPLAY_END);    
        Params->HBlankStart = dacGetCRTC(pDev, Head, H_BLANK_START);    
        Params->HBlankEnd = dacGetCRTC(pDev, Head, H_BLANK_END);    
        Params->HRetraceStart = dacGetCRTC(pDev, Head, H_RETRACE_START);    
        Params->HRetraceEnd = dacGetCRTC(pDev, Head, H_RETRACE_END);    
        Params->VTotal = dacGetCRTC(pDev, Head, V_TOTAL);    
        Params->VDisplayEnd = dacGetCRTC(pDev, Head, V_DISPLAY_END);    
        Params->VRetraceStart = dacGetCRTC(pDev, Head, V_RETRACE_START);    
        Params->VRetraceEnd = dacGetCRTC(pDev, Head, V_RETRACE_END);    
        Params->VBlankStart = dacGetCRTC(pDev, Head, V_BLANK_START);    
        Params->VBlankEnd = dacGetCRTC(pDev, Head, V_BLANK_END);    
        
        RestoreLock(pDev, Head, lock);
        return RM_OK;
    }
    else if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTRY)   // Get values from registry
    {

        char    *strptr;
        U032    numBytes;
        char    strDisplayMode[] = "12345678901234567890";

        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(strDevNodeDisplayNumber);
        //JJV-New registry Process strDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        // now get the specific entry we need
        dacFindRegistryKeyDisplayPosition(pDev, Head, TRUE, strDisplayMode);
        // Copy the string and append the head number
        
        for (strptr = strDisplayMode; *strptr != 0; strptr++) 
            ;
        *strptr++ = '_';
        *strptr++ = (char)(Head | 0x30);
        *strptr++ = 'T';                    // make sure to use different key than desktop position
        *strptr   = 0;
        return osReadRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, (U008 *)&Params->HTotal, &numBytes);
    }
    else // return default values for current mode
    {

        PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

        //
        // Grab the current dac settings (last modeset to come through on this head)
        //
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;


        Params->HTotal = pVidLutCurDac->HalObject.Dac[0].TotalWidth;    
        Params->HDisplayEnd = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        Params->HBlankStart = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
        Params->HBlankEnd = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                            pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
        Params->HRetraceStart = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
        Params->HRetraceEnd = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                            pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
        Params->VTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
        Params->VDisplayEnd = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        Params->VRetraceStart = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
        Params->VRetraceEnd = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
        Params->VBlankStart = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
        Params->VBlankEnd = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                            pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);

        //
        // There is a bug in NV hardware where the hardware cursor will not clip correctly
        // if a border is defined in the display timings (blank start != visible end).
        //
        // Borders are only defined in two specific DMT modes, so generally this is
        // not a problem.
        //
        // To fix this, set the blank starts to match the visible totals and remove the 
        // implicit borders.
        //
        // Remove this code when the hardware gets fixed.  Since this bug has been in the 
        // hardware since 1994, don't expect a fix soon.
        //
        //HorizontalBlankStart = HorizontalVisible;
        //HorizontalBlankEnd   = HorizontalTotal;
        //VerticalBlankStart   = VerticalVisible;
        //VerticalBlankEnd     = VerticalTotal;
        //
        // We want to return "default" values that match what the hardware really wants
        // us to program, not the true borders that exist in the DMT.  Otherwise a
        // client that uses this call to get hardware defaults, and then turns around
        // and programs the hardware with them, will get incorrect timings.
        //
        Params->HBlankStart = Params->HDisplayEnd;
        Params->HBlankEnd = Params->HTotal;
        Params->VBlankStart = Params->VDisplayEnd;
        Params->VBlankEnd = Params->VTotal;

        return RM_OK;
    }
}

//  Write caller's CRTC timing values into CRTC register and/or Windows Registry
RM_STATUS dacSetCRTCTiming
(
    PHWINFO pDev,
    U032    Head,
    NV_CFGEX_CRTC_TIMING_PARAMS    *Params
)
{

    U008    lock, data08;

    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTER) // Set CRTC values
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7


        // Write the CRTC's        
        dacSetCRTC(pDev, Head, H_TOTAL, Params->HTotal);
        dacSetCRTC(pDev, Head, H_DISPLAY_END, Params->HDisplayEnd);
        dacSetCRTC(pDev, Head, H_BLANK_START, Params->HBlankStart);
        dacSetCRTC(pDev, Head, H_BLANK_END, Params->HBlankEnd);       
        dacSetCRTC(pDev, Head, H_RETRACE_START, Params->HRetraceStart);
        dacSetCRTC(pDev, Head, H_RETRACE_END, Params->HRetraceEnd);     
        dacSetCRTC(pDev, Head, V_TOTAL, Params->VTotal);
        dacSetCRTC(pDev, Head, V_DISPLAY_END, Params->VDisplayEnd);
        dacSetCRTC(pDev, Head, V_BLANK_START, Params->VBlankStart);
        dacSetCRTC(pDev, Head, V_BLANK_END, Params->VBlankEnd);
        dacSetCRTC(pDev, Head, V_RETRACE_START, Params->VRetraceStart);
        dacSetCRTC(pDev, Head, V_RETRACE_END, Params->VRetraceEnd);

        //
        // Lock everything back up again
        //
        CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 | 0x80, Head);    // lock CR0-7
        RestoreLock(pDev, Head, lock);
    }
    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTRY) // Set Register values
    {
        char    *strptr;
        U032    numBytes = (NV_CFGEX_CRTC_PARAMS * 4) - 8;  // HTotal is 8 bytes in
        char    strDisplayMode[] = "12345678901234567890";

        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(strDevNodeDisplayNumber);
        //JJV-New registry Process strDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        // now get the specific entry we need
        dacFindRegistryKeyDisplayPosition(pDev, Head, TRUE, strDisplayMode);
        // append the head number
        for (strptr = strDisplayMode; *strptr != 0; strptr++) 
            ;
        *strptr++ = '_';
        *strptr++ = (char)(Head | 0x30);
        *strptr++ = 'T';                    // make sure to use different key than desktop position
        *strptr   = 0;
        return osWriteRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, (U008 *)&Params->HTotal, numBytes);
    }
    return RM_OK;
}

//	See what is currently being used as a display
U032 dacGetBiosDisplayType
(
    PHWINFO pDev,
    U032    Head
)
{
    U008  	rc;
    U032 	displayType;
    U008	lock;               

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, rc, Head);
    if (rc & 0x80)    // is VGA slaved to something?
    {
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, rc, Head);
        if (rc & 0x01)
            displayType = DISPLAY_TYPE_FLAT_PANEL;   
        else
            displayType = DISPLAY_TYPE_TV;      
    }
    else
    {
        displayType = DISPLAY_TYPE_MONITOR;
    }

    RestoreLock(pDev, Head, lock);

    return displayType;
}

//
// Determine which is the boot head by checking which head has an active
// display set (this mechanism breaks with simul-mode). This should only
// be called from initDac.
//
U032 dacGetBiosDisplayHead
(
    PHWINFO pDev
)
{
    U008 lock, cr4b_A, cr3b_A, cr3b_B;

    // headA for non-NV11
    if (IsNV11(pDev) == FALSE)
        return 0;

    lock = UnlockCRTC(pDev, 0);
    CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, cr4b_A, 0);
    RestoreLock(pDev, 0, lock);

    // headA if this is not a Mobile BIOS
    if ((cr4b_A & NV_IS_MOBILE_BIOS) == 0) 
        return 0;

    // read out the current display (7:4 of CR3B) for both heads
    lock = UnlockCRTC(pDev, 0);
    CRTC_RD(NV_CIO_CRE_SCRATCH3__INDEX, cr3b_A, 0);
    RestoreLock(pDev, 0, lock);

    lock = UnlockCRTC(pDev, 1);
    CRTC_RD(NV_CIO_CRE_SCRATCH3__INDEX, cr3b_B, 1);
    RestoreLock(pDev, 1, lock);

    // error check if both heads have non-zero current displays
    if ((cr3b_A & 0xF0) && (cr3b_B & 0xF0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "dacGetBiosDisplayHead - both heads have current displays\n");
        return 0;
    }

    if (cr3b_B & 0xF0)
        return 1;
    else
        return 0;
}

//
// This routine is ugly!
// It is used to clear the bits in the bios scratch register CR3B on the non-primary
// head when more than one head is active.
// One instance where this is needed is on portables when going into hibernation
// under win2k.  Normally, the monitors are supposed to be left on and a hibernation
// progress screen is displayed in vga mode.  But since broadcast mode is broken,
// if we don't clear the bits in the scratch register on the non-primary head, then
// one screen will display the hibernation progress screen and the other will display
// garbage.
// This routine will return TRUE if the other head is active.
//
BOOL dacDisableBroadcast
(
    PHWINFO pDev,
    U032    headSecondary,
    U008   *reg3B
)
{
    BOOL otherHeadActive;
    U008 lock[2];
    U008 cr3B[2];
    U032 headPrimary;

    //
    // Only need to execute on NV11's that don't support broadcast.
    //
    otherHeadActive = FALSE;
    if (IsNV11(pDev))
    {
        headPrimary = 1 - headSecondary;
        if (pDev->Power.MobileOperation)
        {
            //
            // MOBILE
            //
            // Unlock the registers.
            //
            lock[0] = UnlockCRTC(pDev, 0);
            lock[1] = UnlockCRTC(pDev, 1);
            //
            // Get current register values.
            //
            CRTC_RD(0x3B, cr3B[0], 0);
            CRTC_RD(0x3B, cr3B[1], 1);
            //
            // Return the original value of reg cr3B for the head being disabled.
            //
            if (reg3B)
                *reg3B = cr3B[headSecondary];
            //
            // Check if the other head is active.
            //
            if (cr3B[headPrimary] & 0xF0)
            {
                //
                // Mark the specified head as disabled.
                //
                cr3B[headSecondary] &= 0x0F;
                CRTC_WR(0x3B, cr3B[headSecondary], headSecondary);
                otherHeadActive = TRUE;
                //
                // Enable the primary head so any subsequent vga modesets will be be done on the
                // correct head by the bios.
                //
                EnableHead(pDev, headPrimary);
            }
            //
            // Restore the register locks.
            //
            RestoreLock(pDev, 0, lock[0]);
            RestoreLock(pDev, 1, lock[1]);
        }
        else
        {
            //
            // DESKTOP
            //
            // If the display on head 1 is on, turn it off to avoid
            // seeing garbage on it while in vga mode.
            if (pDev->Power.DisplayState[1] != MC_POWER_LEVEL_6)
            {
                //
                // Use the power management routines to turn the display on head 1 off.
                //
                mcPowerDisplayState(pDev, MC_POWER_LEVEL_6, 1);
                //
                // not really in MC_POWER_LEVEL_6 power management state, so leave
                // the power level state set to MC_POWER_LEVEL_5.
                //
                pDev->Power.DisplayState[1] = MC_POWER_LEVEL_5;
            }
            //
            // Whatever is the the active display on head a is the display that we
            // want to enable.  That's what the bios expects to be programming when
            // doing a modeset.
            // One negative side effect of this is that in clone mode with the DFP as the
            // primary display, opening a full screen dos box will not display on the DFP.
            // it will display on whatever display is on head a.
            //
            EnableHead(pDev, 0);
        }
    }
    return (otherHeadActive);
}
BOOL dacRestoreBroadcast
(
    PHWINFO pDev,
    U032    head,
    U008    reg3B
)
{
    BOOL regRestored = FALSE;
    U008 lock;

    if (IsNV11(pDev) && pDev->Power.MobileOperation)
    {
        lock = UnlockCRTC(pDev, head);
        CRTC_WR(0x3B, reg3B, head);
        RestoreLock(pDev, head, lock);
        regRestored = TRUE;
    }
    return (regRestored);
}

//  Read analog out comparator 
//  If the output is loaded, it will be below threshold
//  If no CRT is attached, it will trip
U032 dacDetectTrigger(
    PHWINFO pDev
)
{
    U008 blank, data8;
    U032 retry;
    U032 LastFunc;

//define maxretries in 100us increments
#define MAXRETRIES 334
    
    // wait for active
    retry = 0;
    LastFunc=0;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++; 
        tmrDelay(pDev,100000); //delay 100us
    } while((retry<MAXRETRIES)&&(blank));
    if (retry >= MAXRETRIES)
        goto timedout;

    
    // wait for blank
    retry = 0;
    LastFunc=1;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
        tmrDelay(pDev,100000); //delay 100us
    } while ((retry < MAXRETRIES) && !blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // wait for active
    retry = 0;
    LastFunc=2;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
        tmrDelay(pDev,100000); //delay 100us
    } while ((retry < MAXRETRIES) && blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // get 2 samples which are the same to debounce
    retry = 0;
    LastFunc=3;
    do {
        data8 = (REG_RD08(NV_PRMCIO_INP0) & 0x10);
        retry++;
        tmrDelay(pDev,100000); //delay 100us
    } while ((retry < MAXRETRIES) && ((REG_RD08(NV_PRMCIO_INP0) & 0x10) != data8));
    if (retry >= MAXRETRIES)
    {
 timedout:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: trigger detect timed out: ",LastFunc);
        return 2;
    }

    // sense bit in NV_PRMCIO_INP0 is inverted (0x1 = no trigger).
    if (data8)
    {
        // DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: DacDetectTrigger: False\n");
        return 0;    // no trigger
    }
    else
    {
        // DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: DacDetectTrigger: True\n");
        return 1;     // trigger
    }
}



// Check whether monitor is currently connected
BOOL dacMonitorConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    RM_STATUS status = RM_OK;
    U008      lock;
    U032      Current;
    U032      data;
    U032      force_flag = 0;

    if (using_new_api == FALSE) {
        //
        // Make sure monitor is supported on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR)) == 0)
            return FALSE;

        //
        // For NV11 TwinView, make sure head isn't in use by another display device
        //
        if (!pDev->Power.MobileOperation)
            if (IsNV11(pDev))
            {
                if (GETDISPLAYTYPE(pDev, Head ^ 1) != 0xFFFFFFFF) // if both heads in use
                {
                    Current = GETDISPLAYTYPE(pDev, Head);
                    if (Current == DISPLAY_TYPE_FLAT_PANEL) // then only the current type is allowed (except TV)
                        return FALSE;
                }
            }

        // Mobile devices should never have CRT on Head 1
        if (pDev->Power.MobileOperation && (Head == 1)) 
            return FALSE;
    }

//#ifdef USE_EDID_TO_TEST_CRT_CONNECT
    if ((IsNV11(pDev)) && (Head == 1))
    {
        U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);
        PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
        U032 M,N,P;
        U032 CoeffSelect = 0;
        U032 Vpll2 = 0;
        U008 Cr28  = 0;
        U008 Cr33  = 0;
        // Attempt to read EDID and check for analog display. On head 1 there is no way to do the analog out test below.

        if (IsNV11(pDev))
           EnableHead(pDev, Head);

        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        
        // There are monitors which do not perform DDC unless they see valid sync timing. If we are on the DVI connector
        // (and on Head 1 we are), we must toggle syncs long enough to wake the monitor up so we can do DDC.
        if (pVidLutCurDac == NULL) // Currently in use?
        {
            if (pDev->Dac.HalInfo.InitialBootHead != 1) // And if not the boot device (this may be called before VidLutCurDac is created)
            {
                VIDEO_LUT_CURSOR_DAC_OBJECT VidLutCurDac;

                // Write 800x600 timing in the FP registers.
                DAC_REG_WR32(NV_PRAMDAC_FP_HCRTC, 800, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HDISPLAY_END, 799, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, 800, Head);    // START = END + 1 so no data goes out
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, 799, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, 799+16, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, 839, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HTOTAL, 1120, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VCRTC, 600, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VDISPLAY_END, 599, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, 600, Head);    // START = END + 1 so no data goes out
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, 599, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, 601, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, 625, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VTOTAL, 638, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _POS, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _POS, Head);
                // Give it a 40 MHz clock
                dacCalcMNP(pDev, Head, 4000, &M, &N, &P);   // 40 MHz
                FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG); 
                REG_WR32(NV_PRAMDAC_VPLL2_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                                DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                                DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FPCLK ON

                // dacProgramCRTC need a couple of values set in addition to the arguments passed.
                pDev->Framebuffer.HalInfo.Start[Head] = 0;
                // need one field in a lut object, not other fields used
                VidLutCurDac.Image[0].Pitch = 0;
                // Set 800x600 60 timing to make sure CRT is alive
                dacProgramCRTC(pDev, Head, &VidLutCurDac, 800, 800, 840, 840+128, 800+256, 1056,
                                     600, 600, 601, 605, 628, 628, 8, 4000, 1, 1, 0);

                // Slave the CRTC to timing generator
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
                Cr28 |= BIT(7);
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head); 
                CRTC_RD(0x33, Cr33, Head);   // NV_CIO_CRE_LCD__INDEX
                CRTC_WR(0x33, Cr33 | 0x11, Head); // bits 0 & 4 are HW
                tmrDelay(pDev, 200000000); // delay 200 ms for monitor to see syncs
                
                // read EDID 
                status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);		// Try to read EDID
                
                // restore 
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 & 0x7f, Head); // unslave CRTC
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);     // FPCLK OFF
                CRTC_WR(0x33, Cr33, Head);
            }
        }
        else
        {

            // In use, if used by TV, we must preserve timings.
            // On NV11, it can only be TV.
            if (pVidLutCurDac->DisplayType == DISPLAY_TYPE_TV)
            {
                // Write 800x600 timing in the FP registers.
                // CRTC timing may not match FP timing. This is OK; we only need valid sync timing.
                DAC_REG_WR32(NV_PRAMDAC_FP_HCRTC, 800, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HDISPLAY_END, 799, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, 800, Head);    // START = END + 1 so no data goes out
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, 799, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, 799+16, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, 839, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HTOTAL, 1120, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VCRTC, 600, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VDISPLAY_END, 599, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, 600, Head);    // START = END + 1 so no data goes out
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, 599, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, 601, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, 625, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VTOTAL, 638, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _POS, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _POS, Head);
                // Give it a 40 MHz clock
                Vpll2 = REG_RD32(NV_PRAMDAC_VPLL2_COEFF);
                dacCalcMNP(pDev, Head, 4000, &M, &N, &P);   // 40 MHz
                FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG); 
                REG_WR32(NV_PRAMDAC_VPLL2_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                                DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                                DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FPCLK ON
                
                CoeffSelect = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
                FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);   // clock source is not TV
                
                // Slave the CRTC to timing generator
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
                Cr28 |= BIT(7);
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head); 
                CRTC_RD(0x33, Cr33, Head);   // NV_CIO_CRE_LCD__INDEX
                CRTC_WR(0x33, Cr33 | 0x11, Head); // bits 0 & 4 are HW
                tmrDelay(pDev, 200000000); // delay 200 ms for monitor to see syncs
                
                // read EDID 
                status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);		// Try to read EDID
                
                // restore
                REG_WR32(NV_PRAMDAC_VPLL2_COEFF, Vpll2); 
                REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, CoeffSelect);
                CRTC_WR(0x33, Cr33, Head);
            }
        }
        
        RestoreLock(pDev, Head, lock);
        if (IsNV11(pDev))
           EnableHead(pDev, prevHead);


        if (OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, "ForceCRTDetect", &data) == RM_OK)
        {
            if (data == 1)
            {
                force_flag = 1;
            }
        }

        if (status == RM_OK)		
    	{
            if (edidIsAnalogDisplay(pDev, Head))
                return TRUE;
            else    
            {
                if (force_flag == 1)
                {
                    return TRUE;
                }
                return FALSE;
            }
    	}
        else
        {
            if (force_flag == 1)
            {
                return TRUE;
            }
            return FALSE;   // the analog test (below) will not work on head 1--it always returns TRUE.
        }
    }
//#endif

    // NOTE: for cards with 1 head (NV15/20/...) that can have a CRT plugged into the DVI-I port
    // EDIDDetect will always fail, relying on the call to dacVGAConnectStatus below to properly
    // detect the CRT.  This works because on NV15/20 and other cards with 1 head, the RGB/sync lines
    // are physically connected, so a dacVGAConnectStatus(pDev,0) on head 0 will detect a CRT regardless
    // of which I2C it is actually on.
    status = EDIDDetect(pDev, Head, DISPLAY_TYPE_MONITOR);      // Try to read EDID
    if (status) 
    {
        if (Head != 1) // Head 1 does not have an internal DAC, so we cannot do the analog check.
        {
            // EDID did not confirm that a CRT is connected, but it may be an older non-DDC CRT,
            // so procede with analog out test.
            return (dacVGAConnectStatus(pDev, Head));
        }
        return FALSE;       // EDID read failed on head1, so not CRT
    }

    return TRUE;
}

BOOL dacVGAConnectStatus
(
    PHWINFO pDev, 
    U032    Head
)
{
    U032    dacPowerDown;
    U016    Sr1;
    U032    retries;
    U032    result = 0;
    U032    prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);
    U032    rgb, trigger, testColor, dacControl;
    U032    PramdacCoeffSelect, CurrentVClk;
    U008    Cr28, Cr1A, PixMask, lock;
    U032    done = 0;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: VGA connection detection on head ", Head);

    // This test drives a selected amount of current out the DAC output.
    // This currect causes a voltage drop over the terminating
    // resistor (no CRT connected) or the terminating resistor in parallel
    // with the CRT load.  There is a voltage comparator which is sampled at
    // port 3C2. (Actually 3, one for each color.)  This indicates whether the
    // voltage at the output resistor has crossed a reference level.  If a CRT
    // is connected, the amount of current required to reach this level will
    // be twice (this can vary depending on the board) that required if there
    // is not a CRT.  (e.g. 75 ohms on the board, in parallel with 75 ohms at
    // the monitor = 37.5 ohms).  At the selected current level, we check to
    // see whether the comparator has flipped.  If so, there must be no CRT
    // connected (75 ohm load). If not, there is additional loading, i.e.  a
    // CRT is connected.
    // NOTE: we could possibly improve this in terms of speed by using the palette mask register and only changing
    // one byte of framebuffer and one palette location. But then again, since there's RC delay to ramp up voltage, there may 
    // be no advantage.
    lock = UnlockCRTC(pDev, Head);

    // Sequencer updates require pointing at the appropriate head
    EnableHead(pDev, Head);

    Sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    if (Sr1 & 0x2000)
        WriteIndexed(NV_PRMVIO_SRX, (U016)(Sr1 & ~0x2000));	// turn off blank

    // make sure the DAC is driving RGB out
    dacPowerDown = DAC_REG_RD32(NV_PRAMDAC_TEST_CONTROL, Head);
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);

    tmrDelay(pDev, 10000000);	// delay 10 ms to allow DAC to power up

    CurrentVClk = REG_RD32(NV_PRAMDAC_VPLL_COEFF);
    
    // We need to make sure that a mode is set up.  If there's no object and this is not the head the BIOS is using,
    // we should just go ahead and set up a dummy mode for the test.
    if((pDev->Dac.CrtcInfo[Head].pVidLutCurDac == NULL) && (Head != pDev->Dac.HalInfo.InitialBootHead))

    {
        VIDEO_LUT_CURSOR_DAC_OBJECT VidLutCurDac;
        U032 M,N,P;
        
        // Give it a 40 MHz clock
        dacCalcMNP(pDev, Head, 4000, &M, &N, &P);   // 40 MHz
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG); 
        REG_WR32(NV_PRAMDAC_VPLL_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FPCLK ON

        // dacProgramCRTC need a couple of values set in addition to the arguments passed.
        pDev->Framebuffer.HalInfo.Start[Head] = 0;
        // need one field in a lut object, not other fields used
        VidLutCurDac.Image[0].Pitch = 0;
        // Set 800x600 60 timing to make sure CRT is alive
        dacProgramCRTC(pDev, Head, &VidLutCurDac, 800, 800, 840, 840+128, 800+256, 1056,
                             600, 600, 601, 605, 628, 628, 8, 4000, 1, 1, 0);

    }
    else
    {
        // If FP is output, it may be scaling, and so pixel clock is wrong for this mode. Get native clock.
        // NOTE for debugging: it's good to verify the output is changing color as we go thru the loop, but the
        // monitor may not be synced when the flat panel is the output device, because of the CRTC adjustments (esp. CR4).
        // NOTE 2: It is possible that pVidLutCurDac is NULL at this point.  This happens on Win2k when drivers are being
        // installed on the system for the very first time. In this case, the system will be running in vga mode.
        //
        if ((pDev->Dac.CrtcInfo[Head].pVidLutCurDac)
         && (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL))
        {
            VIDEO_LUT_CURSOR_DAC_OBJECT * pVidLutCurDac;
            U032 M,N,P;

            pVidLutCurDac = (VIDEO_LUT_CURSOR_DAC_OBJECT *)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
            dacCalcMNP(pDev, Head, pVidLutCurDac->HalObject.Dac[0].PixelClock, &M, &N, &P);   // get native VCLK
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG); 
            REG_WR32(NV_PRAMDAC_VPLL_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                            DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                            DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
        }
        // If TV, should be OK as is, if CRT, definitely OK
    }
    // Here's the "ramping up the palette" method for detecting if a CRT is
    // present, reimplemented from what the BIOS had. The USE_TESTPOINT_DATA
    // version seemed not very reliable and frequently gave false CRT
    // detections. 
    // 
    // The palette version in testing gave no false detections for many test
    // loops and did correctly detect the monitor when it was present. The
    // trigger value used was tested on NV5/NV10/NV15 and NV11.
    //
    
    // Make sure we have a PCLK before accessing the palette
    PramdacCoeffSelect = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
    // Make PLL the source
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _NONE);
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);
    }
    // Not slaved, 8 bpp
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 & ~0x83, Head);    

    // Enable syncs
    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, Cr1A, Head);
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, Cr1A & ~0xC0, Head);    

    // save the current palette (we only need one entry)
    DAC_REG_WR08(NV_USER_DAC_READ_MODE_ADDRESS, 0, Head);
    rgb = DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);     // b
    rgb <<= 8;
    rgb |= DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);    // g
    rgb <<= 8;
    rgb |= DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);    // r
    
    // use the mask register to limit DAC lookup to the first entry
    PixMask = DAC_REG_RD08(NV_USER_DAC_PIXEL_MASK, Head);
    DAC_REG_WR08(NV_USER_DAC_PIXEL_MASK, 0, Head);
    
    // these values rely on being interpreted as 6 bits per color
    dacControl = DAC_REG_RD32(NV_PRAMDAC_GENERAL_CONTROL, Head);
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _6BITS, Head);
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIXMIX, _ON, Head); // set PIXMIX so that LUT is used

    // Ramp up the color until the comparator flips or we hit the top of our range
    for (trigger = 0x8; (trigger < 0x18) && ! done; trigger++)
    {
        testColor = trigger; // one color should do it. The BIOS uses all three. 
        // testColor |= trigger << 8;
        // testcolor |= trigger << 16;

        // write RGB of the first entry in the palette
        DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0, Head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, testColor >> 16, Head); // R
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, testColor >> 8, Head);  // G
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, testColor, Head);       // B
        
        retries = 0;
        
        do
        {
            result = dacDetectTrigger(pDev);
            if (result==2)
            {
                done = 1;    // exit the test now
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: vga connect timeout\n");
            }
        } while((result != dacDetectTrigger(pDev)) && (retries++ < 5));
        
        if (result == 1)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Trigger Detected\n");
            done = 1;
        }
    }
    // restore the mask register 
    DAC_REG_WR08(NV_USER_DAC_PIXEL_MASK, PixMask, Head);
    
    // restore the previous dac control
    DAC_REG_WR32(NV_PRAMDAC_GENERAL_CONTROL, dacControl, Head);

    // restore the previous palette value
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0, Head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, rgb >> 16, Head); // b
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, rgb >> 8, Head);  // g
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, rgb, Head);       // r

    // restore VCLK
    REG_WR32(NV_PRAMDAC_VPLL_COEFF, CurrentVClk);

    // restore the previous dac powerdown
    DAC_REG_WR32(NV_PRAMDAC_TEST_CONTROL, dacPowerDown, Head);

    // restore the previous SR1 value
    // sequencer updates require pointing at the appropriate head
    EnableHead(pDev, Head);
    WriteIndexed(NV_PRMVIO_SRX, (U016)Sr1);

    // restore previous CR44 value
    EnableHead(pDev, prevHead);
    // restore Cr28
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);    
    // restore syncs
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, Cr1A, Head);    
    // restore clock source
    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, PramdacCoeffSelect);

    RestoreLock(pDev, Head, lock);

    if (trigger < 0x18) // If trigger, there is less DC load, therefore no monitor
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: Monitor detect: FALSE\n");
        
        return FALSE;
    }
    else
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: Monitor detect: TRUE -- red trigger is: ", trigger);
        
        return TRUE;
    }
}


// Check whether flat panel is currently connected
BOOL dacFlatPanelConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    RM_STATUS status;
    U008 lock;

    if (using_new_api == FALSE) {
        //
        // Make sure flatpanel allowed on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL)) == 0)
            return FALSE;

        //
        // If the other head is TV, we can't do it (P38 with external TMDS, P41 with internal is OK)
        // TODO: Need to change this to a dynamic check based on feedback from the BIOS topology table
        // If we're using the 12bit wide FP interface, then FP/TV can share and are allowed.
        //
        if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_TV) && !pDev->Power.MobileOperation &&
            (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT))
            return FALSE;
    }

    lock = UnlockCRTC(pDev, Head);

    // read EDID 
    status = EDIDRead(pDev, Head, DISPLAY_TYPE_FLAT_PANEL);	// Try to read EDID

    RestoreLock(pDev, Head, lock);

    if (status != RM_OK)
        return FALSE;

    if (edidIsDigitalDisplay(pDev, Head)) 		// Check the display technology byte
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;
        return TRUE;
    }
    return FALSE;
}

U032 dacGetFlatPanelConfig
(
    PHWINFO pDev,
    U032    Head
)
{
    U032 mode;
    
    mode = DAC_REG_RD32(NV_PRAMDAC_FP_TG_CONTROL, Head); 
    return(DRF_VAL(_PRAMDAC, _FP_TG_CONTROL, _MODE, mode)); 
}
    
RM_STATUS dacGetFlatPanelInfo
(
    PHWINFO pDev,
    U032    Head,
    U032    *FpMode,
    U032    *FpMaxX,
    U032    *FpMaxY,
    BOOL    *FpConnected,
    BOOL    *FlatPanelNativeSupported,
    BOOL    fromRegistry
)
{
    U032      mode;
    RM_STATUS status;
    U008    i, chksum2 = 0xff, chksum = 0xff;
    BOOL    EdidOk = FALSE;

    // Not getting an EDID for the flat panel is catasrophic, so we'll do some retries if we fail.
    for (i=0; i<3; i++) 
    {
        // Get info from EDID
        if (!dacFlatPanelConnectStatus(pDev, Head))	// FP connected? (we got a header)
        {
            *FpConnected = NV_CFGEX_GET_FLATPANEL_INFO_NOT_CONNECTED;
            return RM_OK;						// then no more to do
        }
        // If we got an EDID, make sure it's a good one
        if (fpParseEDID(pDev, Head) == RM_OK) // parse EDID to get timing info (fail if bad header, or (?) bad timing)
        {
            // Checksum to verify this is a valid EDID
            if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 128, &chksum)) // expect checksum = 0
            {
                EdidOk = TRUE;
                break; // stop iteration if checksum is good
            }
            else
            {
                // some "good" panels have bad checksums, so if we get the same checksum twice, accept it
                if (chksum == chksum2) 
                {
                    EdidOk = TRUE;
                    break; // stop iteration if we get same checksum twice
                }
                chksum2 = chksum;
            }
            // If we fail, print checksum
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Flat Panel EDID checksum =  ", chksum);
        }
    } // if we still fail, we have no choice but to go with it

    *FpConnected = NV_CFGEX_GET_FLATPANEL_INFO_CONNECTED;
    *FpMaxX = pDev->Dac.HalInfo.fpHMax;
    *FpMaxY = pDev->Dac.HalInfo.fpVMax;
    *FlatPanelNativeSupported = FALSE;
    if (pDev->Dac.fpNative)
        *FlatPanelNativeSupported = TRUE;

    if (fromRegistry)
    {
        //JJV-New registry Process   char * strDisplayMode;
        //JJV-New registry Process   U032   size;
        // read it from the registry
        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
        //JJV-New registry Process pDev->Registry.DBstrDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        status = OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, &mode);
    	if (status == RM_OK)
	        *FpMode = mode;
    	else
	    	*FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
    }
    else
    {
        mode = dacGetFlatPanelConfig(pDev, Head); // This just reads the HW to find the current scaling mode
        *FpMode = mode;
        status = RM_OK;
    }
    if (!EdidOk) 
        return RM_ERROR; // failed to get a good EDID
    else
        return status;   // error if requested registry, but none found
}

// Check whether TV is currently connected
// This only works for the Brooktree encoder
BOOL dacTVConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    read, ack, lock, encoderPower, reg0e, reg10, reg3d, i;
    BOOL    connect;
    U032    retry;

    if (using_new_api == FALSE) {
        //
        // Make sure TV allowed on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_TV)) == 0)
            return FALSE;
    }

    //
    // For NV11, make sure TV isn't in use by other head.
    // For P38 boards (external TMDS), we cannot run both TV and flat panel. This will change if we use internal TMDS,
    // but we'll have to get that info from the BIOS. Until then, TV + DFP is not allowed.
    //
    if (IsNV11(pDev))
    {
        if (using_new_api == FALSE) {
            // If the other head already has the TV, we can't use it.
            if (GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_TV)  
                return FALSE;

            //
            // If the other head is flat panel, we can't do it (only if this board is using external TMDS)
            // or if we're using the 12bit wide FP interface, then FP/TV can share and are allowed.
            //
            if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_FLAT_PANEL) && !pDev->Power.MobileOperation &&
                (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT))
                return FALSE;

            // If the other head is CRT on head 1, we can't do it (only if this board is using external TMDS)
            if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_MONITOR) && (Head == 0))
                return FALSE;
        }
        
        //
        // Make sure that i2c/tv ownership is setup properly.
        //
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // Set power to "normal"
            // Chrontel 7007 wants bit 7 set on register address
            
            // Read Power Management Register to preserve contents
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E); // 0x0e = PM register
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg0e,1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // Powered up? No, then do so
            if ((reg0e & 3) != 3) {
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E); // 0e = power register
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x0b); // ON + RESET HIGH
                }
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);


            // Some initialization is necessary on the 7007 to make the detection work.
            // Exactly what needs to be set, I don't know, but the following 2 register initializations do it.

            // Set data format
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // 04 = input data format reg
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x05);      // set to NTSC for now
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // Set clocking
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // 06 = clock mode
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x40);      // 
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // In the 7008, reg 3D bits 2:0 must be cleared for detection to work
            // Don't know what effect it has on others, so we'll special case it.
            if (pDev->Dac.EncoderType == NV_ENCODER_CHRONTEL_7008) {

                // Read Reg 3D to preserve contents
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_3D); // 3D = ?
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg3d,1);
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

                if (ack == 0) {
                    // clear mystery bits 2:0 so TV connect detection will work
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    }
                    if (ack == 0) {
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_3D); // 
                        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(reg3d & 0xf8)); 
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
            } // 7008

            // Read Connection Detect Register to preserve contents
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg10,1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            if (ack == 0) {
                // Set Sense bit to tell encoder to check for TV connected
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    reg10 &= 0x0f;  // clear bits 7:4
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(reg10 | 1)); // sense bit <= 1
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }

            if (ack == 0) {
                // Reset Sense bit 
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); // sense bit <= 0
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }

            if (ack == 0) {
                // Read Connect reg - restart read
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
            {
              // Say that the device is enabled just to disable it
              pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
              dacDisableTV(pDev, Head);
            }

            if  ((ack == 0 ) &&     // If we failed some how, we fail this
                 ((read & 0x0e) ^ 0x0e))     // 0 indicates connection
                                    // bit 3: Y (luma), bit 2: C (chroma), bit 1: composite
                connect = TRUE;
            else
                connect =  FALSE;
            break;
   

        case TV_ENCODER_BROOKTREE:

            // Turn DAC on before checking status
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);   // subaddress
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            // Give it some time for the outputs to stabilize
            tmrDelay(pDev, 20000000);         // 20 ms delay    

            // Set Check Status bit to tell encoder to check for TV connected.
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                if (ack)
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after first address byte while detecting TV connection\n\r");
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL); // subaddress
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT); // set check stat
            } else {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after first address byte while detecting TV connection\n\r");
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            if (ack != 0) {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during first transaction while detecting TV connection\n\r");
            }

            //870/871 supports direct register reads.  The older chips require a more involved procedure.
            if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) {
                
                // enable non-legacy readback mode for 870/871 by doing a reset - harmless for older parts
                // (this enables read of any register on 87x -- 868/869 has only one read subaddress)
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);     // subaddress
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);     // TIMING_RST low, set readback mode, EACTIVE
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
                tmrDelay(pDev, 10000000);
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);      // TIMING_RST high
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         

                if (ack == 0) {
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x06);
                }

                if (ack == 0) {
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID | 1));   // Add read bit
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after third address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
            } else {
                if (ack == 0) {
                    // Set Estat to select status register 1
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after second address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);   // subaddress
                        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x41);   // set estat (estat 01 + en_out)
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after second address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                    if (ack != 0) {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during second transaction while detecting TV connection\n\r");
                    }
                }

                if (ack == 0) {
                    // Read Monitor Status bits
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID | 1));   // Add read bit
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after third address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                } 
            }

            if (ack == 0) {
                // Reset Check Status -- not documented, but very important (can't program encoder if not done).
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    if (ack)
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after last address byte while detecting TV connection\n\r");
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL); // subaddress
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF); // set check stat
                } else {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after last address byte while detecting TV connection\n\r");
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                if (ack != 0) {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during last transaction while detecting TV connection\n\r");
                }
            }

            if (ack) // if any error occurred, go to monitor
                return (FALSE);

            if (read & BT_MONSTAT)  // any connection deteced?
                connect = TRUE;
            else
                connect =  FALSE;

            // If not TV, disable DAC
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_TV)
            {
                // If no head is using TV, blank image.
                for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                    if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                        break;
                if (i == pDev->Dac.HalInfo.NumCrtcs)
                {
                  // Say that the device is enabled just to disable it
                  pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
                  dacDisableTV(pDev, Head);
                }
            }
            break;
        
       case TV_ENCODER_PHILIPS:
           // Turn Power On -- Read/Modify/Write
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
           }
           if (ack == 0) {
              ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x61); // 
              i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
              ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
              i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           encoderPower = read;
           read &= 0x3f;   // power on
           // Write Power bits
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x61);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) read);   // 
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           
           // Set Monitor Sense Threshold
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Set Monitor Sense Threshold
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Set Monitor Sense Mode
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x80);   // MSM
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Read sense bits
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
           }
           if (ack == 0) {
              ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x1b); // 
              i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
              ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
              i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           if ((read & 0x07) == 0x07)    // check C and Y inputs
               connect = FALSE;
           else
               connect = TRUE;                                    
           // Reset Monitor Sense Mode
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x00);   // MSM
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           // Restore power state
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x61);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) encoderPower);   // power
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           break;
        default:
                connect =  FALSE;
    }
    RestoreLock(pDev, Head, lock);

    // restore TV connection if TV is connected on the other head
    if (GETDISPLAYTYPE(pDev, Head ^ 0x1) == DISPLAY_TYPE_TV) {
        AssocDDC(pDev, Head ^ 0x1);
        AssocTV(pDev, Head ^ 0x1);
    }

    // restore macrovision mode if appropriate
    if (pDev->Dac.TVLastMacrovision.mode & 0x3)
        SetMacrovisionMode(pDev, Head, (RM_MACROVISION_CONTROL *)&(pDev->Dac.TVLastMacrovision));

    return connect;
}

//  Set the text cursor blink rate depending on the display type
//  The BIOS won't do this, so we have to.
VOID dacSetCursorBlink
(
    PHWINFO pDev,
    U032    Head,
    U008    Rate
)
{
U008    data;

    if (IsNV5(pDev)) // This is a problem in NV5 only
    {
        // another undocumented register
        CRTC_RD(NV_CIO_CRE_TREG__INDEX, data, Head);
        data &= ~0x80;
        if (Rate)   // CRT set bit 7 to 0, FP & TV set to 1
            data |= 0x80;
        CRTC_WR(NV_CIO_CRE_TREG__INDEX, data, Head);
    }
}

// Unlock extended CRTC and return former state of lock
U008 UnlockCRTC
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 lock;
    
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    return lock;
}
VOID RestoreLock
(
    PHWINFO pDev, 
    U032    Head, 
    U008    lock
)
{
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}
//  Read extended CRTC lock register and return corresponding write value
U008 ReadCRTCLock
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 data;

    CRTC_RD(NV_CIO_SR_LOCK_INDEX, data, Head);
    switch (data)
    {
        case 0x03:
            data = 0x57;
            break;
        case 0x01:
            data = 0x75;
            break;
        case 0x00:
        default:
            data = 0x99;
            break;
    }
    return data;
}

VOID dacSetFan
(
    PHWINFO pDev,
    U008    state
)
{
    U008 data, lock;
    U032 Head = 0;

    if (IsNV10orBetter(pDev))
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);
        
        CRTC_RD(0x35, data, Head);
        data &= ~0x02;		// bit 1 = output enable (active low) 
        if (state == 0)
        {
            // OFF
            CRTC_WR(0x35, data & ~0x01, Head);	// bit 0 = fan control (active high)
        }
        else
        {
            // ON
            CRTC_WR(0x35, data | 0x01, Head);		// bit 0 = fan control (active high)
        }

        RestoreLock(pDev, Head, lock);
    }
}

RM_STATUS dacGetColorSaturationBoost
(
    PHWINFO pDev,
    U032    Head,
    U008    *boostValue
)
{
    U008 lock;

    if (IsNV11orBetter(pDev) == FALSE)
        return CONFIG_GETEX_BAD_READ;    // not supported pre-NV11

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    // get the color boost value
    CRTC_RD(NV_CIO_CRE_CSB, *boostValue, Head);

    RestoreLock(pDev, Head, lock);

    return RM_OK;
}

RM_STATUS dacSetColorSaturationBoost
(
    PHWINFO pDev,
    U032    Head,
    U008    boostValue
)
{
    U008 lock;

    if (IsNV11orBetter(pDev) == FALSE)
        return CONFIG_GETEX_BAD_READ;    // not support pre-NV11

    if (boostValue > NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_750)
        return CONFIG_SETEX_BAD_PARAM;    // 75% is the largest value

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    // set the color saturation boost value
    CRTC_WR(NV_CIO_CRE_CSB, boostValue, Head);

    RestoreLock(pDev, Head, lock);
    return RM_OK;
}

#ifdef MACOS
/*
 * The fcode on the mac implements Apple's monitor selection policy
 *  (what device to boot on, etc).  The fcode then publishes this information
 *  in the registry.
 *
 * Here we read that information.
 *
 * "displayA"      --  HHIILLTT
 * "displayB"      --  HHIILLTT
 * "display-type"  -- "CRT" or "LCD"  preferred boot device
 *
 * Decoder ring:
 *             HH -- head
 *             II -- i2c status port base
 *             LL -- TMDS link info
 *             TT -- display type (0 = crt, 3 = digital flat panel)
 *
 * If a display is not present, then the value will be 0x??FFFFFF.
 *
 * On the iMac / P11, displayA would be 00FFFF00 (Head A, no I2C port, no TMDS
 * link, CRT) and displayB would be 013E0103 (Head B, I2C 3E/3F, Link 2, DFP).
 *
 */

RM_STATUS dacMacReadBIOSDisplaySettings(
    PHWINFO pDev
)
{
    U032 displayA, displayB;
    U032 head, i2cportA=0, i2cportB=0, tmdslink;
    U032 displaytype = 0;
    char primary_displaytype_string[16];
    U032 reglen;

    displayA = ~0;
    displayB = ~0;
    osReadRegistryDword(pDev, (char *) 0, "displayA", &displayA);
    osReadRegistryDword(pDev, (char *) 0, "displayB", &displayB);
    if ((displayA == ~0) && (displayB == ~0))
        return RM_ERROR;

    // what is the display type that the fcode depended on?
    // We don't really use this right now...

    reglen = sizeof(primary_displaytype_string);
    osMemSet(primary_displaytype_string, 0, reglen);
    osReadRegistryBinary(pDev,
                         (char *) 0,
                         "display-type",
                         (U008 *) primary_displaytype_string,
                         &reglen);


    // parse out displayA settings

    if ((displayA & 0x00FFFFFF) != 0x00FFFFFF)
    {
        head =        (displayA >> 24) & 0xFF;
        i2cportA =    (displayA >> 16) & 0xFF;
        tmdslink =    (displayA >> 8)  & 0xFF;
        displaytype = (displayA >> 0)  & 0xFF;
    }
    
    if ((displayB & 0x00FFFFFF) != 0x00FFFFFF)
    {
        head =        (displayB >> 24) & 0xFF;
        i2cportB =    (displayB >> 16) & 0xFF;
        tmdslink =    (displayB >> 8)  & 0xFF;
        displaytype = (displayB >> 0)  & 0xFF;
    }
    
    //
    // NOTE: DFP2 means the DFP on head B!!
    //       DFP  means the DFP on head A.
    //
    // first mark them all unknown
    //
    pDev->Dac.DFPPortID  = NV_I2C_PORT_TERTIARY;
    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;
    pDev->Dac.CRTPortID  = NV_I2C_PORT_TERTIARY;
    pDev->Dac.CRT2PortID = NV_I2C_PORT_TERTIARY;

    // If we have anything on headB, then that will be our primary.
    // If not, then A will be primary
    if ((displayB & 0x00FFFFFF) != 0x00FFFFFF)
    {
        pDev->Dac.I2CPrimaryStatusIndex = i2cportB;
        pDev->Dac.I2CPrimaryWriteIndex = i2cportB + 1;
        
        if (displaytype == 3)
            pDev->Dac.DFP2PortID = NV_I2C_PORT_PRIMARY;
        else
            pDev->Dac.CRT2PortID = NV_I2C_PORT_PRIMARY;

        if ((displayA & 0x00FFFFFF) != 0x00FFFFFF)
        {
            pDev->Dac.I2CSecondaryStatusIndex = i2cportA;
            pDev->Dac.I2CSecondaryWriteIndex = i2cportA + 1;
            
            if (displaytype == 3)
                pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
            else
                pDev->Dac.CRTPortID = NV_I2C_PORT_SECONDARY;
        }
    }
    else
    {
        pDev->Dac.I2CPrimaryStatusIndex = i2cportA;
        pDev->Dac.I2CPrimaryWriteIndex = i2cportA + 1;
        
        if (displaytype == 3)
            pDev->Dac.DFPPortID = NV_I2C_PORT_PRIMARY;
        else
            pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
    }
    
    return  RM_OK;
}

#endif // MACOS



//
// Extract the relevant I2C values from any arbitrary version of BMP structure
// Update the nvInfo structure with the location of the TV and FP ports.
RM_STATUS dacReadBIOSI2CSettings(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

#ifdef IKOS
    pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
    pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
    pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
    pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
    pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
    pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
    pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
#else

    if ( !IsNV5orBetter(pDev) || IsNV0A(pDev) )
    {
        // This is a one DDC port device
        pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.TVOutPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.DFPPortID = NV_I2C_PORT_PRIMARY;
    }
    else
    {
        U032 offset;
        BMP_Control_Block bmpCtrlBlk;
        U032 RegistryData;

        // This device has two DDC ports, set defaults

        pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
        pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
        if (pDev->Power.MobileOperation)
        {
            // 
            // For mobile, CIO_CRE_DDC2 (CR50/CR51) is used to control the spread
            // spectrum chip (avoid using this pair for any DDC communication).
            //
            pDev->Dac.I2CTertiaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
            pDev->Dac.I2CTertiaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
        }
        else
        {
            pDev->Dac.I2CTertiaryWriteIndex = NV_CIO_CRE_DDC2_WR__INDEX;
            pDev->Dac.I2CTertiaryStatusIndex = NV_CIO_CRE_DDC2_STATUS__INDEX;
        }
        pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
        pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
        
        // NV11, NV20 have three DDC ports
        if (IsNV11(pDev))
        {
#if 0 // We can no longer assume that VGA is the boot device. We assume that we can talk to VGA over I2C 0 and DFP over I2C 1
      // unless we find a registry override.
            // determine if this is VGA + ? or DVI/DVI board
            if (dacVGAConnectStatus(pDev, 0))  // Is there VGA on I2C 0? (Uses analog comparator)
            {
                // VGA is mapped to I2C 0, so the secondary could be VGA or DFP on I2C 1
                pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
                pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;     // No primary DFP--set to unused port
                pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;   // second DFP uses I2C 1
            }
            else // no CRT, assume dual DFP
            {
                if (dacFlatPanelConnectStatus(pDev, 0)) // this will try to find EDID on I2C 1
                {
                    // DVI on I2C 1 and 2                
                    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // secondary DFP uses I2c 2
                }
                else // No DFP after all, assume CRT with no EDID
                {
                    pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
                    pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;    // set to unused port
                    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // set to unused port
                }
            }
#else
            U032 val = 0;
            char strDualDVI[] = "Dual DVI";

            // VGA is mapped to I2C 0, so the secondary could be VGA or DFP on I2C 1
            pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
            pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;     // No primary DFP--set to unused port
            pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;   // second DFP uses I2C 1
            
            // registry override for dual DVI board -- Flat Panels connected to I2C 1 and 2
            OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strDualDVI, &val);
            if (val) 
            {
                pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
                pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // secondary DFP uses I2c 2
            }
#endif        
        }

#ifdef MACOS
        // the Mac is *special*
        // The fcode sets registry properties to indicate i2c mappings
        //    If we find these registry settings, we'll use them,
        //    otherwise we'll look for the BMP bios table.
        if (RM_OK == dacMacReadBIOSDisplaySettings(pDev))
            return RM_OK;
#endif

        // Attempt to find the I2C info in the BIOS' BMP tables
        rmStatus = DevinitGetBMPControlBlock(pDev,
                                             &bmpCtrlBlk,
                                             &offset);
        if (rmStatus == RM_OK)
        {
            switch ( bmpCtrlBlk.CTL_Version )
            {
                // version 0 is for Nv3, no others exist
                case BMP_INIT_TABLE_VER_0:
                case BMP_INIT_TABLE_VER_1:
                {
                    // There is no I2C info in these BIOS's.
                    break;
                }
                    
                // BMP init table version 2 & 3
                case BMP_INIT_TABLE_VER_2:
                case BMP_INIT_TABLE_VER_3:
                {
                    //PBMP_Struc_Rev3 BMP_InitTableInfo = (PBMP_Struc_Rev3)pBmpCtrlBlk;
                    BIOSI2CTable biosI2CTable;
                    
                    rmStatus = BiosReadStructure(pDev,
                                                 (U008 *) &biosI2CTable,
                                                 0x40,
                                                 (U032 *) 0,
                                                 BMP_I2C_FMT);
                    if (rmStatus == RM_OK)
                    {
                        pDev->Dac.I2CPrimaryWriteIndex = biosI2CTable.I2CPort0IO & 0xFF;
                        pDev->Dac.I2CPrimaryStatusIndex = ( biosI2CTable.I2CPort0IO >> 8 ) & 0xFF;
                        pDev->Dac.I2CSecondaryWriteIndex = biosI2CTable.I2CPort1IO & 0xFF;;
                        pDev->Dac.I2CSecondaryStatusIndex = ( biosI2CTable.I2CPort1IO >> 8 ) & 0xFF;
                        pDev->Dac.CRTPortID = biosI2CTable.CRTI2CPort;
                        pDev->Dac.TVOutPortID = biosI2CTable.TVI2CPort;
                        pDev->Dac.DFPPortID = biosI2CTable.DFPI2CPort;
                    }
                    break;
                }
        
                // BMP init table version >= BMP_INIT_TABLE_VER_4 ( 4 )
                default:
                {
                    BMP_Struc_Rev4 bmp_InitTableInfo ;
                    
                    rmStatus = BiosReadStructure(pDev,
                                                 (U008 *) &bmp_InitTableInfo,
                                                 offset,
                                                 (U032 *) 0,
                                                 BMP_INIT4_FMT);

                    if (rmStatus == RM_OK)
                    {
                        pDev->Dac.I2CPrimaryWriteIndex = bmp_InitTableInfo.BMP_I2CPort0IO & 0xFF;
                        pDev->Dac.I2CPrimaryStatusIndex = ( bmp_InitTableInfo.BMP_I2CPort0IO >> 8 ) & 0xFF;
                        pDev->Dac.I2CSecondaryWriteIndex = bmp_InitTableInfo.BMP_I2CPort1IO & 0xFF;;
                        pDev->Dac.I2CSecondaryStatusIndex = ( bmp_InitTableInfo.BMP_I2CPort1IO >> 8 ) & 0xFF;
                        pDev->Dac.CRTPortID = bmp_InitTableInfo.BMP_CRTI2CPort;
                        pDev->Dac.TVOutPortID = bmp_InitTableInfo.BMP_TVI2CPort;
                        pDev->Dac.DFPPortID = bmp_InitTableInfo.BMP_DFPI2CPort;
                    }
                    break;
                }
            }
        }

        // Verify that there are no non-zero values in these reg indexes as these should never be 0       
        // This fixes a bug in which Diamond stuffs 0s into the bitmap
        if( (pDev->Dac.I2CPrimaryWriteIndex == 0x00)   ||
            (pDev->Dac.I2CPrimaryStatusIndex == 0x00)  ||
            (pDev->Dac.I2CSecondaryWriteIndex == 0x00) ||
            (pDev->Dac.I2CSecondaryStatusIndex == 0x00) ) {

            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid I2C info in bios image\n");

            // Someone gave us bogus values, so set all of these to the defaults
            pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
            pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
            pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
            pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
            pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
            pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
            pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
        }

        if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "Nv11DVIConnectorOnly", &RegistryData) == RM_OK) {
            pDev->Dac.CRTPortID = NV_I2C_PORT_SECONDARY;
            pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;

            pDev->Dac.TVOutPortID = NV_I2C_PORT_TERTIARY;
            pDev->Dac.CRT2PortID = NV_I2C_PORT_TERTIARY;
            pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;
        }

        if (IsNV15(pDev))
            pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;
    }
#endif

    return rmStatus;
}

//
// Return head number specified in alloc request.
//
U032 dacGetHead
(
    PCLASS pClass,
    VOID *pCreateParms
)
{
    RM_STATUS   status = RM_OK;
    U032 Head = 0;

    if (pCreateParms == NULL)
        return Head;

    switch (pClass->Type)
    {
        case NV15_VIDEO_LUT_CURSOR_DAC:
        {
            NV07C_ALLOCATION_PARAMETERS Class07cParams;
            status = osCopyIn(pCreateParms, (U008*) &Class07cParams, sizeof (NV07C_ALLOCATION_PARAMETERS));
            if (status != RM_OK)
                return 0;
            Head = Class07cParams.logicalHeadId;
        }
        default:
            // for everything else, it's head 0
            break;
    }

    return Head;
}

RM_STATUS
dacCreateObj(VOID* pDevHandle, PCLASSOBJECT ClassObject, U032 Name, POBJECT *Object, VOID *pCreateParms)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS                    status = RM_OK;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    PCLASS                       pClass = ClassObject->Base.ThisClass;
    U008                         *bytePtr;
    U032                          i, head;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacCreateObj\r\n");
    
    //
    // Check allocation restrictions.
    //

    //
    // Check head assignment.
    //
    head = dacGetHead(pClass, pCreateParms);
    if (head >= pDev->Dac.HalInfo.NumCrtcs)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: dacCreateObj: invalid logical head number ", head);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    //
    // For synchronized multi-head flips, init the sync counter
    //
    pDev->Dac.MultiSyncCounter = pDev->Dac.HalInfo.NumCrtcs;

    //
    // Alloc memory for class dependent object state.
    // All DAC engine objects currently use the same structure.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEO_LUT_CURSOR_DAC_OBJECT));
    if (status)
        return (status);

    //
    // Nice casts to make the code more readable.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pVidLutCurDac;
    for (i = 0; i < sizeof (VIDEO_LUT_CURSOR_DAC_OBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidLutCurDac->CBase, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    pVidLutCurDac->HalObject.Head = head;
    status = nvHalDacAlloc(pDev, pVidLutCurDac->CBase.ChID, pVidLutCurDac->CInstance, pClass->Type, (VOID *)&pVidLutCurDac->HalObject);

    if (status == RM_OK)
    {
        //
        // Build a FIFO/Hash context for this object
        //
        status = fifoUpdateObjectInstance(pDev,
                                          &pVidLutCurDac->CBase, 
                                          pVidLutCurDac->CBase.ChID, 
                                          pVidLutCurDac->CInstance);
    }

    if (status)
    {
        osFreeMem(*Object);
        return (status); 
    }

    //
    // Bump up reference count on this.
    //
    pDev->Dac.CrtcInfo[head].RefCount++;

    return (RM_OK);
}

RM_STATUS
dacDestroyObj(VOID* pDevHandle, POBJECT Object)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS               status = RM_OK;
    PCLASS                  pClass;
    U032                    buffNum;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

#if !defined(NTRM) && !defined(__DJGPP__)
    U008    data08, lock;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // Nice cast to make the code more readable.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    pClass = Object->ThisClass;
    nvHalDacFree(pDev, pVidLutCurDac->CBase.ChID, pVidLutCurDac->CInstance, pClass->Type, (VOID *)&pVidLutCurDac->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidLutCurDac->CBase, pVidLutCurDac->CBase.ChID); 
    if (status)
        return (status);

    //
    // Cleanup any pending VBlank callbacks
    //
    VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->CursorPointCallback));

    for (buffNum = 0; buffNum < 2; buffNum++) {
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->Image[buffNum].ImageCallback));
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->LUT[buffNum].LUTCallback));
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
    }

    //
    // Decrement reference count.
    //
    // Turn off DAC if this is last object instance associated
    // with this (non-primary) head
    //
    if (--pDev->Dac.CrtcInfo[pVidLutCurDac->HalObject.Head].RefCount == 0)
    {
#ifndef __DJGPP__
        // Assumes last pVidLutCurDac is the modesetting object (which holds this flag)
        if (   pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PrimaryDevice == FALSE
       //comment out following line to see multimon nv11-pci modeswitch problem
            && pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac != NULL 
           )
        {
            dacDisableDac(pDev, pVidLutCurDac->HalObject.Head);
        }
#endif
    }

    //Remove the pointer to this object -- whether this ptr is NULL is used
    // to determine whether this head is disabled.
    if (pVidLutCurDac == (PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac)) 
    {
#if !defined(NTRM) && !defined(__DJGPP__)
        //Runtime clone mode switch support -- turn off display when associated object it is destroyed.
        if (!pDev->Vga.Enabled) {
            dacDisableDac(pDev, pVidLutCurDac->HalObject.Head); 

            if (MC_POWER_LEVEL_0 == pDev->Power.State) {
              lock = UnlockCRTC(pDev, pVidLutCurDac->HalObject.Head);
                if (pDev->Power.MobileOperation &&  pDev->HotKeys.enabled) {
                    CRTC_RD(0x3B, data08, pVidLutCurDac->HalObject.Head);
                    CRTC_WR(0x3B, (data08 & 0x0F), pVidLutCurDac->HalObject.Head);
                }

                RestoreLock(pDev, pVidLutCurDac->HalObject.Head, lock);
            }
        }
#endif                                                          
        SETDISPLAYTYPE(pDev, DACGETHEAD(pVidLutCurDac), DISPLAY_TYPE_NONE);
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = NULL;
        pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = NULL;
    }

    //
    // And finally delete the object itself    
    //    
    return (osFreeMem(Object));
}

//
// EnableHead
//
// Set DAC address space mode in CR44 (H2OWNS)
// register so that CIO/VIO/PRMVIO addressing 
// goes to the specified head.
//
VOID EnableHead
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 data08;
    U008 crtc_index, lock;

    if (!IsNV11(pDev))
        return;

    if (pDev->Dac.HalInfo.Head2RegOwner == HEAD2_OWNER_UNKNOWN) {
        // Set the initial values, if this is the first call.
        if (Head == 1)
            data08 = 3;
        else
            data08 = 0;
    } else {
        // CR44 has a bug; memory mapped reads don't work, so we use a shadow copy.
        data08 = (U008)pDev->Dac.HalInfo.Head2RegOwner;
        if (Head == 1) 
        {
            // Did CR44 already point to head 1
            if ((data08 & 0x3) == 3)
                return;

            data08 |= 3;
        }
        else
        {
            // Did CR44 already point to head 0
            if ((data08 & 0x3) == 0)
                return;

            data08 &= ~3;
        }
    }

    // save/unlock head0 (new head is always programmed from head 0).
    crtc_index = DAC_REG_RD08(NV_PRMCIO_CRX__COLOR, 0);
    lock = UnlockCRTC(pDev, 0);

    CRTC_WR(NV_CIO_CRE_H2OWNS, data08, 0);

    RestoreLock(pDev, 0, lock);    // not pointing at CR44 anymore
    DAC_REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index, 0);

    pDev->Dac.HalInfo.Head2RegOwner = (U032)data08;
}


//returns the current owner of DDC (ENGINE_CTRL_I2C)
U032 CurrentHeadDDC(PHWINFO pDev)
{
    if (DAC_REG_RD_DRF(_PCRTC, _ENGINE_CTRL, _I2C, 0))
        return 0;   //head A wins a tie

    if (DAC_REG_RD_DRF(_PCRTC, _ENGINE_CTRL, _I2C, 1))
        return 1;

    return 0;   //head A wins by default
}


// Multi-head DDC switching (ENGINE_CTRL update routine).
VOID AssocDDC(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _DEFAULT, 0);
    }
}

// Multi-head TV switching (ENGINE_CTRL update routine).
VOID AssocTV(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _DEFAULT, 0);
    }
}

// Multi-head VideoScalar switching (ENGINE_CTRL update routine).
VOID AssocVideoScalar(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _DEFAULT, 0);
    }
}


//Set a flag to let the BIOS know not to handle hotkey events itself.
//Set while in Windows, cleared in full-screen DOS.  Mobile only.
VOID EnableMobileHotkeyHandling(PHWINFO pDev)
{
    U008 lock, data;

    if (pDev->Power.MobileOperation) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling enabled\n\r");

        // unlock the extended regs
        lock = UnlockCRTC(pDev, 0);

        //Clear any pending events
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);
        data &= ~(NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);

        //Notify BIOS we're enabling driver hotkey handling.
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 0);
        //Temporary: Toshiba's system BIOS clears that bit accidentally.
        //So also use another bit.  Our VGA BIOS checks both.
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 0);

        RestoreLock(pDev, 0, lock);

        //Workaround: head 1's bit, too.
        lock = UnlockCRTC(pDev, 1);

        //Clear any pending events
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);
        data &= ~(NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);

        //Notify BIOS we're enabling driver hotkey handling.
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 1);
        //Temporary: Toshiba's system BIOS clears that bit accidentally.
        //So also use another bit.  Our VGA BIOS checks both.
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 1);

        RestoreLock(pDev, 1, lock);

        pDev->HotKeys.enabled = TRUE;
    }
}


//Clear flag so BIOS knows to handle hotkey events itself.
//Set while in Windows, cleared in full-screen DOS.  Mobile only.
VOID DisableMobileHotkeyHandling(PHWINFO pDev)
{
    U008 lock, data;

    if (pDev->Power.MobileOperation) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling disabled\n\r");

        // unlock the extended regs
        lock = UnlockCRTC(pDev, 0);

        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 0);
        //Temporary: Toshiba's system BIOS clears that bit accidentally.
        //So also use another bit.  Our VGA BIOS checks both.
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 0);

        RestoreLock(pDev, 0, lock);

        //Workaround: head 1's bit, too.
        // unlock the extended regs
        lock = UnlockCRTC(pDev, 1);

        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling disabled\n\r");
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 1);
        //Temporary: Toshiba's system BIOS clears that bit accidentally.
        //So also use another bit.  Our VGA BIOS checks both.
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 1);

        RestoreLock(pDev, 1, lock);

        pDev->HotKeys.enabled = FALSE;
    }
}

//---------------------------------------------------------------------------
//
//  VBlank service handler.
//
//---------------------------------------------------------------------------
V032 dacService
(
    PHWINFO pDev
)
{
    U032 head, pmc, pending;
    RM_STATUS status;

    pending = 0;

    pmc = REG_RD32(NV_PMC_INTR_0);
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        pending |= 0x1;
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))
        pending |= 0x2;

    //
    // Check for any VBlank actions. Service count was already updated in VBlank
    //
    status = RM_OK;
    if (pDev->Framebuffer.FinishFlags)
        status |= grVBlank(pDev);
#if DEBUG
    if (status)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Problems in dacService.\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG

    VBlank(pDev);

    // Clear 'em all...
    for (head = 0; head < MAX_CRTCS; head++)
    {
        if (pending & BIT(head))
            DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, head);
    }
    return (0x00000000);
}

// read/parse the Display Config Block (DCB) from the BIOS.  only revisions 1.4 and up support
// this feature
RM_STATUS dacParseDCBFromBIOS
(
    PHWINFO pDev
)
{
    U016        offset;             // offset from NV BIOS base
    U016        DCBBase;            // offset of DCB from BIOS base
    U032        CRTs = 0;           // # of CRT connectors
    U032        DDs = 0;            // # of DD connectors
    U032        TVs = 0;            // # of TV connectors
    U032        DevDescs = 0;       // # of valid DCB device descriptors
    U032        CRTCs = 0;          // # of CRTCs
    U032        I2cPorts;           // # of I2C ports
    U032        i;
    U032        j;
    U032        *pI2cPort;
    U032        RegistryData;
    U032        BMPOffset;
    BOOL        BMPVersionOK;
    RM_STATUS   status;
    BMP_Control_Block BMPCtrlBlk;
    
    // The BMP version must be greater than or equal to 0x05.0x12 for us to
    // use the DCB table
    
    status = DevinitGetBMPControlBlock(pDev, &BMPCtrlBlk, &BMPOffset);
   
    BMPVersionOK = ((status == RM_OK) &&
		    (( BMPCtrlBlk.CTL_Version >  BMP_INIT_TABLE_VER_5) ||
                     ((BMPCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5) &&
                      (BMPCtrlBlk.CTL_Flags   >= BMP_INIT_TABLE_SUBVER_0x12))));

    DCBBase = BIOS_RD16(DCB_PTR_OFFSET);
    
    if ((BMPVersionOK) &&
        (DCBBase != 0) &&
        (BIOS_RD08(DCBBase + DCB_REVISION_OFFSET) >= DCB_FIRST_REVISION))
    {   
        // This is Rev 1.4 or greater, so there exits a DCB; however, many Rev 1.4 BIOS' have  
        // one DEV_REC (device descriptor) in the DCB, making them not very useful. 
        // If Rev 1.4 and there is only one DEV_REC, then fall back to the RM default DCB above.

        // read DCB device descriptors. endianess ?
        offset = DCBBase + DCB_DEV_DESC_OFFSET;
        for (i = 0; i < DCB_MAX_NUM_DEVDESCS; i++) 
        {
            pDev->Dac.DCBDesc[i].DCBDevRec.DevRec_U032 = BIOS_RD32(offset);
            if (pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_EOL)
                break;
            offset += sizeof(U032);
            pDev->Dac.DCBDesc[i].DataPtr = BIOS_RD16(offset);
            offset += sizeof(U016);

            pDev->Dac.DCBDesc[i].DCBDevData.DataDword = BIOS_RD32(offset);
            offset += sizeof(U032);

            // keep track of the highest head number
            if (pDev->Dac.DCBDesc[i].DCBRecHead > CRTCs)
                CRTCs = pDev->Dac.DCBDesc[i].DCBRecHead;
        }
        DevDescs = i;   // # of device descriptors, excluding EOL
        CRTCs++;        // head number is zero based

        // We parsed the DCB, but if it's Rev 1.4 with a single entry,
        if ((DevDescs == 1) && (BIOS_RD08(DCBBase + DCB_REVISION_OFFSET) == DCB_FIRST_REVISION))
        {
            goto RM_DCB;
        }
        else
        {
            // read the I2C Configuration Block (ICB). endianess ?
            offset = BIOS_RD16(DCBBase + DCB_ICB_OFFSET);
            pI2cPort = (U032 *)pDev->Dac.DCBI2c;
            for (i = 0; i < DCB_MAX_NUM_I2C_RECORDS; i++) 
            {
                *pI2cPort++ = BIOS_RD32(offset);

                if (pDev->Dac.DCBI2c[i].I2cAccess == I2C_PORT_ACCESS_UNUSED)
                    break;

                offset += sizeof(U032);
            }
            I2cPorts = i;
        }
    }
    else
    {
RM_DCB:        
        // fake DCB records for older board
#define SETUP_DCB_DESC(i,a,b,c,d,e,f,g)                                     \
        pDev->Dac.DCBDesc[i].DCBRecType = DCB_DEV_REC_TYPE_##a;             \
        pDev->Dac.DCBDesc[i].DCBRecSubtype = DCB_DEV_REC_SUBTYPE_##b;       \
        pDev->Dac.DCBDesc[i].DCBRecFmt = DCB_DEV_REC_FMT_##c;               \
        pDev->Dac.DCBDesc[i].DCBRecIdxToICB = DCB_DEV_REC_LOGICAL_PORT_##d; \
        pDev->Dac.DCBDesc[i].DCBRecHead = DCB_DEV_REC_HEAD_##e;             \
        pDev->Dac.DCBDesc[i].DCBRecLocation = DCB_DEV_REC_LOCATION_##f;     \
        pDev->Dac.DCBDesc[i].DCBRecBus = DCB_DEV_REC_BUS_##g;

        if (IsNV11(pDev)) 
        {
            pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
            pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;

            pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
            pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;

            pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[2].WritePort = I2C_PHYSICAL_PORT_C_DATA;
            pDev->Dac.DCBI2c[2].ReadPort = I2C_PHYSICAL_PORT_C_STATUS;

            pDev->Dac.DCBI2c[3].I2cAccess = I2C_PORT_ACCESS_UNUSED;
            I2cPorts = 3;

            if (pDev->Power.MobileOperation) 
            {
                //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                SETUP_DCB_DESC(0, DD_SLINK, UNUSED, UNUSED, UNUSED, B,      UNUSED, 0); 
                SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, UNUSED, A,      UNUSED, 0); 
                SETUP_DCB_DESC(2, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 1); 
                SETUP_DCB_DESC(3, CRT,      UNUSED, UNUSED, 0,      B,      UNUSED, 1); 
                if ((1 == pDev->Power.MobileOperation) || (pDev->Power.MobileOperation == 2)) 
                {     // no CRT/TV combo on toshiba
                    SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                    SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                }
                else 
                {
                    SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 2); 
                    SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 2); 
                }
                SETUP_DCB_DESC(6, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
                DevDescs = 6;
                CRTCs = 2;
            }
            else 
            {
                if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "Nv11DVIConnectorOnly", &RegistryData) == RM_OK) 
                {
                    //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                    SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
                    SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
                    SETUP_DCB_DESC(2, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 

                    DevDescs = 2;
                    CRTCs = 1;
                }
                else 
                {
                    //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                    SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0); 
                    SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                    SETUP_DCB_DESC(2, DD_SLINK, UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                    SETUP_DCB_DESC(3, CRT,      UNUSED, UNUSED, 1,      B,      UNUSED, 2); 
                    // Originally this was set up as A, B for 24 bit, B, A for 12 bit.
                    // The problem with that is that we don't want to use B as the primary on a desktop system.
                    // The desktop BIOS is not head aware; it will always assume head A, so DOS boxes won't work on B.
                    if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT) 
                    {
                        SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                        SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                    }
                    else 
                    {
                        SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 3); 
                        SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 3); 
                    }
                    SETUP_DCB_DESC(6, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 

                    DevDescs = 6;
                    CRTCs = 2;
                }
            }
        }
        else 
        {  // non NV11 boards
            pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
            pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;
            pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
            pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;
            pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_UNUSED;
            I2cPorts = 2;

            //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
            SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(2, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(3, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
            DevDescs = 3;
            CRTCs = 1;
        }
    }


#ifdef MACOS
    //special failure case for NV11/NV20 on Mac - seeds are broken or not present
    //DDLLPP - remove when new seed properly describes hardware
    pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
    pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
    pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;

    pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
    pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
    pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;

    pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
    pDev->Dac.DCBI2c[2].WritePort = I2C_PHYSICAL_PORT_C_DATA;
    pDev->Dac.DCBI2c[2].ReadPort = I2C_PHYSICAL_PORT_C_STATUS;

    pDev->Dac.DCBI2c[3].I2cAccess = I2C_PORT_ACCESS_UNUSED;
    I2cPorts = 3;
    
    if(IsNV20(pDev))
    {
        SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0);
        SETUP_DCB_DESC(1, CRT,      UNUSED, UNUSED, 1,      A,      UNUSED, 0);
        SETUP_DCB_DESC(2, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 0);
        SETUP_DCB_DESC(3, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, 0);   
        
        DevDescs = 3;
        CRTCs = 1;
    }    
    if(IsNV11(pDev))
    {   
        if (osReadRegistryBoolean(pDev, NULL, "backlight-control"))
        {

            //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
            SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, UNUSED, A,      UNUSED, 0     ); 
            SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      B,      UNUSED, 0     );
            SETUP_DCB_DESC(2, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED);
            
            DevDescs = 2;
            CRTCs = 2;
        }
        else
        {
            SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0);
            SETUP_DCB_DESC(1, CRT,      UNUSED, UNUSED, 1,      A,      UNUSED, 0);
            SETUP_DCB_DESC(2, DD_SLINK, UNUSED, UNUSED, 1,      B,      UNUSED, 0);
            SETUP_DCB_DESC(3, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, 0);   
            
            DevDescs = 3;
            CRTCs = 2;
        }
    }
#endif    
    
    // override nvHalmcControl_nv10 setting
    DACHALINFO(pDev, NumCrtcs) = CRTCs;
    if (IsNV11(pDev) && OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "TwinViewDisabled", &RegistryData) == RM_OK)
        DACHALINFO(pDev, NumCrtcs) = 1;

    // find all devices with no I2C port.  these are the built in devices.
    // currently, only the flat panel on laptop doesn't have an I2C port
    // associate with it.  assume at most one device of each type.
    for (i = 0; i < DevDescs; i++) 
    {
        if (pDev->Dac.DCBDesc[i].DCBRecIdxToICB == DCB_DEV_REC_LOGICAL_PORT_UNUSED) 
        {
            switch (pDev->Dac.DCBDesc[i].DCBRecType) {
            case DCB_DEV_REC_TYPE_CRT:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_CRT_OFFSET_IN_MAP;
                CRTs = 1;
                break;

            case DCB_DEV_REC_TYPE_TV:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_TV_OFFSET_IN_MAP;
                TVs = 1;
                break;

            case DCB_DEV_REC_TYPE_DD_SLINK:
            case DCB_DEV_REC_TYPE_DD_DLINK:
            case DCB_DEV_REC_TYPE_DD:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_DD_OFFSET_IN_MAP;
                DDs = 1;
                break;
            }
        }
    }

    // assign device unit number according to the I2C port number.  devices
    // of the same type connected to the same I2C port have the same unit
    // number since they use the same connnector.
    for (i = 0; i < I2cPorts; i++) 
    {
        int     CRTFound;
        int     TVFound;
        int     DDFound;

        CRTFound = TVFound = DDFound = 0;
        for (j = 0; j < DevDescs; j++) 
        {
            if (pDev->Dac.DCBDesc[j].DCBRecIdxToICB != i)
                continue;

            switch (pDev->Dac.DCBDesc[j].DCBRecType) 
            {
            case DCB_DEV_REC_TYPE_CRT:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_CRT_OFFSET_IN_MAP + CRTs);
                CRTFound = 1;
                break;

            case DCB_DEV_REC_TYPE_TV:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_TV_OFFSET_IN_MAP + TVs);
                TVFound = 1;
                break;

            case DCB_DEV_REC_TYPE_DD_SLINK:
            case DCB_DEV_REC_TYPE_DD_DLINK:
            case DCB_DEV_REC_TYPE_DD:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_DD_OFFSET_IN_MAP + DDs);
                DDFound = 1;
                break;

            }
        }

        CRTs += CRTFound;
        TVs += TVFound;
        DDs += DDFound;
    }

    // create devices bitmap
    pDev->Dac.DevicesBitMap = (((0x1 << CRTs) - 1) << DAC_CRT_OFFSET_IN_MAP) |
        (((0x1 << TVs) - 1) << DAC_TV_OFFSET_IN_MAP) |
        (((0x1 << DDs) - 1) << DAC_DD_OFFSET_IN_MAP);

    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "DevicesConnected", &RegistryData) == RM_OK)
        pDev->Dac.DevicesNoCheck = RegistryData;
    else
        pDev->Dac.DevicesNoCheck = 0;

    return RM_OK;
}

// Find the connect status of the specified devices.
// *pDevBitMap - on input, a map of devices to check the connect status of
//  at ouput, a map of the queried devices that are actually present
// DevForcePresentMap - a similarly formatted map that indicates devices
//  that should always be considered present, whether they are attached or not
VOID dacDevicesConnectStatus
(
    PHWINFO pDev,
    U032    *pDevBitMap,
    U032    DevForcePresentMap
)
{
    U032            dev = *pDevBitMap;
    PDACDCBDEVDESC  pDevDesc;
    U032            CurrDevTypeUnit = 0x1;
    BOOL            status;

    using_new_api = TRUE;
    while (dev) {
        if (dev & 0x1) {
            if (CurrDevTypeUnit & DevForcePresentMap)
                goto NextDev;

            // go through all entries in the DCB to find matching devices.
            pDevDesc = pDev->Dac.DCBDesc;
            while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
                status = FALSE;
                if  (pDevDesc->DevTypeUnit == CurrDevTypeUnit) {
                    if (pDevDesc->DCBRecIdxToICB == DCB_DEV_REC_LOGICAL_PORT_UNUSED)
                        goto NextDev;

                    switch (pDevDesc->DCBRecType)  {
                    case DCB_DEV_REC_TYPE_CRT:
                        status = dacMonitorConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;

                    case DCB_DEV_REC_TYPE_TV:
                        status = dacTVConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;

                    case DCB_DEV_REC_TYPE_DD_SLINK:
                    case DCB_DEV_REC_TYPE_DD_DLINK:
                    case DCB_DEV_REC_TYPE_DD:
                        status = dacFlatPanelConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;
                    }

                    if (status == FALSE)
                        // clear the corresponding bit if no devices found.
                        *pDevBitMap &= ~CurrDevTypeUnit;

                    goto NextDev;
                }
                pDevDesc++;
            }
        }

NextDev:
        dev >>= 1;
        CurrDevTypeUnit <<= 1;
    }
    using_new_api = FALSE;
}

// this routine will try to find a configuration for the specified
// devices. return FALSE if a suitable configuration cannot be found.
// the configuration is returned in pAllocationMap with the first nibble
// corresponds to the first/rightmost device, second nibble corresponds
// to the second device, ... up to 8 devices can be specified. the nibble
// value is the head that should be connected to the device.
static BOOL dacMapDeviceToHead
(
    PHWINFO     pDev,
    U032        DevBitMap,          // devices in configuration
    U032        HeadsUsed,          // assigned heads
    U032        BusesUsed,          // assigned buses
    U032        CurrDev,            // current device
    U032        NibbleToUse,        // nibble to use for the next allocation
    U032        *pAllocationMap     // allocation map, result that will be passed
                                    // back to the calling routine
)
{
    PDACDCBDEVDESC  pDevDesc;

    // done, no more device
    if (!DevBitMap)
        return TRUE;

    // look for the rightmost set bit
    while (!(DevBitMap & 0x1)) {
        DevBitMap >>= 1;
        CurrDev++;
    }

    // use recursion to map device to head, one at a time.
    pDevDesc = pDev->Dac.DCBDesc;
    while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
        if (pDevDesc->DevTypeUnit != ((U032)0x1 << CurrDev))
            goto NextDevDesc;

        // make sure we are not using resources assigned already.
        if (((0x1 << pDevDesc->DCBRecHead) & HeadsUsed) ||
            ((0x1 << pDevDesc->DCBRecBus) & BusesUsed))
            goto NextDevDesc;

        if (dacMapDeviceToHead(pDev,
                               DevBitMap >> 1,
                               HeadsUsed | (0x1 << pDevDesc->DCBRecHead),
                               BusesUsed | (0x1 << pDevDesc->DCBRecBus),
                               CurrDev + 1,
                               NibbleToUse + 1,
                               pAllocationMap) == TRUE) {
            *pAllocationMap |= pDevDesc->DCBRecHead << (NibbleToUse * 4);
            return TRUE;
        }

NextDevDesc:
        pDevDesc++;
    }

    return FALSE;
}

// find a suitable configuration for the specified devices.
RM_STATUS dacFindDevicesConfiguration
(
    PHWINFO pDev,
    U032    NewDevBitMap,
    U032    *pNewAllocationMap,
    U032    OldDevBitMap,
    U032    OldAllocationMap
)
{
    U032        DevBitMap;
    U032        CurrDev;
    U032        NibbleToUse;
    U032        HeadsUsed = 0x0;     // heads used
    U032        BusesUsed = 0x0;     // buses used
    U032        head;
    PDACDCBDEVDESC pDevDesc;
    U032        AdjustedOldAllocationMap = 0x0;
    U032        AdjustedNibbleToUse;
    U032        NewConfig;

    // find common devices between the old and new configurations. keep them
    // attaching to the same CRTCs if possible.
    DevBitMap = OldDevBitMap;
    CurrDev = NibbleToUse = AdjustedNibbleToUse = 0;
    while (DevBitMap) {
        if (!(DevBitMap & 0x1))
            goto NextDev_0;

        // device in the old but not in the new configuration ?
        if (!(OldDevBitMap & NewDevBitMap & (0x1 << CurrDev))) {
            NibbleToUse++;
            goto NextDev_0;
        }

        // device is in both the old and new configurations.
        // find CRTCs attached to the device and mark it as used.
        // adjust old allocation map such that we can merge it with the new
        // allocation map later.
        head = (OldAllocationMap >> (NibbleToUse++ * 4)) & 0xf;
        HeadsUsed |= 0x1 << head;
        AdjustedOldAllocationMap |= head << (AdjustedNibbleToUse++ * 4);

        // determine other non-shared resources used by this device.
        pDevDesc = pDev->Dac.DCBDesc;
        while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
            if ((pDevDesc->DevTypeUnit != ((U032)0x1 << CurrDev)) ||
                (pDevDesc->DCBRecHead != head))
                pDevDesc++;
            else {
                BusesUsed |= 0x1 << pDevDesc->DCBRecBus;
                break;
            }
        }

NextDev_0:
        DevBitMap >>= 1;
        CurrDev++;
    }

    // find new allocation with common devices at fixed CRTCs.
    NewConfig = 0x0;
    if (dacMapDeviceToHead(pDev,
                           (NewDevBitMap ^ OldDevBitMap) & NewDevBitMap,
                           HeadsUsed,
                           BusesUsed,
                           0,
                           0,
                           &NewConfig) == TRUE) {

        // no merging necessary if there are no common devices.
        if (!(OldDevBitMap & NewDevBitMap)) {
            *pNewAllocationMap = NewConfig;
            return RM_OK;
        }

        // merge configuration.
        DevBitMap = NewDevBitMap;
        *pNewAllocationMap = 0x0;
        CurrDev = NibbleToUse = 0;
        while (DevBitMap) {
            if (!(DevBitMap & 0x1))
                goto NextDev_1;

            if ((0x1 << CurrDev) & OldDevBitMap) {
                *pNewAllocationMap |= (AdjustedOldAllocationMap & 0xf) << (NibbleToUse++ * 4);
                AdjustedOldAllocationMap >>= 4;
            }
            else {
                *pNewAllocationMap |= (NewConfig & 0xf) << (NibbleToUse++ * 4);
                NewConfig >>= 4;
            }

NextDev_1:
            DevBitMap >>= 1;
            CurrDev++;
        }

        return RM_OK;
    }

    // couldn't find allocation with common devices at fixed CRTCs.
    // try to get allocation with no CRTCs fixed.
    if (OldDevBitMap & NewDevBitMap) {
        *pNewAllocationMap = 0x0;
        if (dacMapDeviceToHead(pDev,
                               NewDevBitMap,
                               0x0,
                               0x0,
                               0,
                               0,
                               pNewAllocationMap) == TRUE)
            return RM_OK;
    }

    return RM_ERROR;
}

//
// This is a more complete way of implementating a modeset within the RM from
// VIDEO_LUT_CURSOR_DAC values. It's more than just calling dacSetModeMulti
// since other VIDEO_LUT_CURSOR_DAC methods also occur during a complete modeset.
//
RM_STATUS dacSetModeFromObjectInfo
(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    // Do the initial basic modeset (uses a default startAddr and palette)
    dacSetModeMulti(pDev, pVidLutCurDac);

    // Program the correct CRTC startAddr/pitch (with panning offset).
    if (pVidLutCurDac->Image[0].ImageCtxDma)
    {
        U032 startAddr;
        startAddr = (U032)
                    ((size_t)(pVidLutCurDac->Image[0].ImageCtxDma->DescAddr) +
                     pVidLutCurDac->Image[0].Offset);
        startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

        dacProgramVideoStart(pDev,
                             DACGETHEAD(pVidLutCurDac),
                             startAddr,
                             pVidLutCurDac->Image[0].Pitch);
    }

    // Program the user-defined LUT
    if (pVidLutCurDac->LUT[0].LUTCtxDma)
    {
        RM_STATUS status;
        U032 numEntries = 256;
        U032 *pPaletteAddr;
        
        status = dmaGetMappedAddress(pDev,
                                     pVidLutCurDac->LUT[0].LUTCtxDma,
                                     pVidLutCurDac->LUT[0].Offset,
                                     numEntries * 4,
                                     (void **)(&pPaletteAddr));
        if (status == RM_OK)
            dacProgramLUT(pDev, DACGETHEAD(pVidLutCurDac), pPaletteAddr, numEntries);
    }

    return RM_OK;
}

static RM_STATUS GetCrcValuesCallback
(
    PHWINFO   pDev,
    POBJECT   pObject,
    U032      Head,
    U032      Channel,
    RM_STATUS Status
)
{
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
            DAC_REG_WR32
            (
                NV_PRAMDAC_TEST_CONTROL,
                  DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_RESET,   _DEASSERTED)
                | DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                | DRF_NUM(_PRAMDAC, _TEST_CONTROL, _CRC_CHANNEL, Channel)
                | DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_CAPTURE, _ONE),
                Head
            );
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            DAC_REG_WR32
            (
                NV_PRAMDAC_FP_TEST_CONTROL,
                  DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_RESET,   _DEASSERTED)
                | DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                | DRF_NUM(_PRAMDAC, _FP_TEST_CONTROL, _CRC_CHANNEL, Channel)
                | DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_CAPTURE, _ONE),
                Head
            );
            break;

        case DISPLAY_TYPE_TV:
            DAC_REG_WR32
            (
                NV_PRAMDAC_TV_TEST_CONTROL,
                  DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_RESET,   _DEASSERTED)
                | DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                | DRF_NUM(_PRAMDAC, _TV_TEST_CONTROL, _CRC_CHANNEL, Channel)
                | DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_CAPTURE, _ONE),
                Head
            );
            break;

        default:
            RM_ASSERT(0);
            return RM_ERROR;
    }

    return RM_OK;
}

RM_STATUS  dacGetCrcValues
(
    PHWINFO pDev,
    U032    Head,
    U032 *  pRedCrc,
    U032 *  pGreenCrc,
    U032 *  pBlueCrc
)
{
    VBLANKCALLBACK VBlankCallback;
    U032 Channel;
    U032 Crcs[3];
    U032 i;
    U032 Try;
    U032 DisplayType  = GETDISPLAYTYPE(pDev, Head);
    U032 MaxPollLoops = 100;
    U032 Retries      =  10;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacGetCrcValues:\n");

    VBlankCallback.Proc        = GetCrcValuesCallback;
    VBlankCallback.Object      = 0;
    VBlankCallback.Param1      = Head;
    VBlankCallback.Param2      = 0;     // Used to pass Channel to callback.
    VBlankCallback.VBlankCount = 0;
    VBlankCallback.Flags       = 0;
    VBlankCallback.Status      = RM_OK;
    VBlankCallback.Next        = 0;

    *pRedCrc   = 0;
    *pGreenCrc = 0;
    *pBlueCrc  = 0;

    for (Channel = 0; Channel < 3; ++Channel)
    {
        switch (DisplayType)
        {
            case DISPLAY_TYPE_MONITOR:
                for (Try = 0; Try < Retries; ++Try)
                {
                    // Reset CRC.
                    DAC_REG_WR32(NV_PRAMDAC_TEST_CONTROL,
                          DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_RESET,   _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_CAPTURE, _ONE),
                        Head);

                    // Capture the CRC.
                    VBlankCallback.Param2 = Channel;
                    VBlankAddCallback(pDev, Head, &VBlankCallback);
                    for (i = 0; (DAC_REG_RD_DRF(_PRAMDAC, _CHECKSUM, _STATUS, Head)
                                    != NV_PRAMDAC_CHECKSUM_STATUS_CAPTURED)
                                &&  (i < MaxPollLoops); ++i)
                    {
                        osDelay(1);
                    }
                    if (i < MaxPollLoops)
                    {
                        Crcs[Channel] = DAC_REG_RD_DRF(_PRAMDAC, _CHECKSUM, _VALUE, Head); 
                        break;
                    }
                }
                if (Try == Retries)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: failed to capture DAC CRC\n");
                    return FALSE;
                }

                break;
    
            case DISPLAY_TYPE_FLAT_PANEL:
                for (Try = 0; Try < Retries; ++Try)
                {
                    // Reset CRC.
                    DAC_REG_WR32(NV_PRAMDAC_FP_TEST_CONTROL,
                          DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_RESET,   _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_CAPTURE, _ONE),
                        Head);

                    // Capture the CRC.
                    VBlankCallback.Param2 = Channel;
                    VBlankAddCallback(pDev, Head, &VBlankCallback);
                    for (i = 0; (DAC_REG_RD_DRF(_PRAMDAC, _FP_CHECKSUM, _STATUS, Head)
                                    != NV_PRAMDAC_FP_CHECKSUM_STATUS_CAPTURED)
                                &&  (i < MaxPollLoops); ++i)
                    {
                        osDelay(1);
                    }
                    if (i < MaxPollLoops)
                    {
                        Crcs[Channel] = DAC_REG_RD_DRF(_PRAMDAC, _FP_CHECKSUM, _VAL, Head); 
                        break;
                    }
                }
                if (Try == Retries)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: failed to capture FP CRC\n");
                    return FALSE;
                }

                break;
    
            case DISPLAY_TYPE_TV:
                for (Try = 0; Try < Retries; ++Try)
                {
                    // Reset CRC.
                    DAC_REG_WR32(NV_PRAMDAC_TV_TEST_CONTROL,
                          DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_RESET,   _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_CAPTURE, _ONE),
                        Head);

                    // Capture the CRC.
                    VBlankCallback.Param2 = Channel;
                    VBlankAddCallback(pDev, Head, &VBlankCallback);
                    for (i = 0; (DAC_REG_RD_DRF(_PRAMDAC, _TV_CHECKSUM, _STATUS, Head)
                                    != NV_PRAMDAC_TV_CHECKSUM_STATUS_CAPTURED)
                                &&  (i < MaxPollLoops); ++i)
                    {
                        osDelay(1);
                    }
                    if (i < MaxPollLoops)
                    {
                        Crcs[Channel] = DAC_REG_RD_DRF(_PRAMDAC, _TV_CHECKSUM, _VAL, Head); 
                        break;
                    }
                }
                if (Try == Retries)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: failed to capture TV CRC\n");
                    return FALSE;
                }

                break;
    
            default:
                RM_ASSERT(0);
                return RM_ERROR;
        }

    } // for each channel

    *pRedCrc   = Crcs[2];
    *pGreenCrc = Crcs[1];
    *pBlueCrc  = Crcs[0];

    return RM_OK;
}

RM_STATUS dacSetHotPlugInterrupts(PHWINFO pDev, U032 Head, U032 HotPlugEnable, U032 HotUnplugEnable)
{
    U032 HotPlugEnableProxy,HotUnplugEnableProxy;
    
    //do the transfer safely since technically we should be passing pointers to writeable memory
    HotPlugEnableProxy = HotPlugEnable;
    HotUnplugEnableProxy = HotUnplugEnable;

    //do the set    
    return nvHalDacHotPlugInterrupts(
        pDev,
        (VOID *)&(((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[Head].pVidLutCurDac))->HalObject),
        &HotPlugEnableProxy,
        &HotUnplugEnableProxy,
        TRUE /* write mode */,
        TRUE /* reset */
    );
}

RM_STATUS dacGetHotPlugInterrupts(PHWINFO pDev, U032 Head, U032 * pHotPlugStatus, U032 * pHotUnplugStatus, BOOL Reset)
{
    return nvHalDacHotPlugInterrupts(
        pDev,
        (VOID *)&(((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[Head].pVidLutCurDac))->HalObject),
        pHotPlugStatus,
        pHotUnplugStatus,
        FALSE /* read mode */,
        Reset
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DACINIT.C                                                         *
*   The DAC is initialized in this module.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <dac.h>
#include <os.h>
#include <i2c.h>
#include <edid.h>
#include "nvhw.h"
#include "nvcm.h"
#include <devinit.h>

//
// DAC names.
//
char dac16Name[] = "SGS 16-bit DAC                ";
char dac32Name[] = "SGS 32-bit DAC (Van Gogh)     ";
char dac64Name[] = "SGS 64-bit DAC (Van Dyke)     ";
char dac128Name[] = "NV 128-bit DAC (Picasso)    ";

//
// Externals.
//

extern char strDevNodeRM[];
char strEnable256Burst[] = "Enable256Burst";
char strTVOutOnPrimary[] = "TVOutOnPrimary";
char strLastExtDevice[] = "LastExtDevice";
char strCurWinDevices[] = "strCurWinDevices";

BOOL dacTVConnected(PHWINFO);

BOOL dacMonitorConnectStatus(PHWINFO,U032);
BOOL dacFlatPanelConnectStatus(PHWINFO pDev, U032);

static U032 dacGetDisplayType(PHWINFO, U032);

static RM_STATUS dacInitCurrentDevices(PHWINFO);
static RM_STATUS dacInitGetMobileEDIDFromBios(PHWINFO);
static VOID dacInitFPTableToEDID(PHWINFO, PBIOSFPTable, U008 *);

char digits[16] = {'0', '1', '2', '3', '4', '5', '6', '7',
                   '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
#define DIGIT(i,n) digits[((n >> (i * 4)) & 0xF)]
#define COMPRESSEDASCIIVAL(i) ((i - 'A') + 1)
//
// Initialize the DAC.
//
RM_STATUS initDac
(
    PHWINFO pDev
)
{
    U032 i;
    U032 j;
    U032 k;
    U032 data, data32, type;
#ifndef IKOS
    U008 data08, lockA;
#endif
    U032 freq = 0;

    //
    // Initialize flags.
    //
    pDev->Dac.UpdateFlags = 0;
    pDev->Dac.DisplayChangeInProgress = 0;

    //
    // Disable I/O broadcast mode for now until we can figure
    // out why we can't reach HeadB through privSpace with
    // this enabled
    //
    FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _DISP_MIRROR, _DISABLE);

    nvHalDacControl(pDev, DAC_CONTROL_INIT);

    //
    // Initialize CR44 shadow contents to UNKNOWN and determine/set the
    // current boot head (call EnableHead to make things consistent).
    // 
    pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN;
    EnableHead(pDev, dacGetBiosDisplayHead(pDev));

    if ( BiosGetMaxExternalPCLKFreq( pDev, 1, &freq ) == RM_OK )
    {
        if ( freq != 0 )
        {
            // Convert freq from freq(Mhz)*100 to plain Hz
            freq = freq * 10000;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit8bpp  = freq;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp = freq;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit32bpp = freq;
        }
    }
    //
    // Determine how to handle syncs on CRT.  This key, if it exists, tells us
    // to leave HSync ON during power mgmt of the display (CRT)
    //
    if (dacReadMonitorSyncsFromRegistry(pDev, &data32) == RM_OK)
        pDev->Dac.HsyncOff = 0;
    else
        pDev->Dac.HsyncOff = 1;     // default is to leave it off like normal

    // Determine I2C setup from BIOS
    dacReadBIOSI2CSettings(pDev);

    // Read/Parse BIOS Display Config Block
    dacParseDCBFromBIOS(pDev);

    //
    // Find out where to send TV Out commands (overrides dacReadBIOSI2CSettings)
    //
    // NV_I2C_PORT_SECONDARY is the default (unless the BIOS overrode it), but
    // we can override everything here with the registry
    if ( OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strTVOutOnPrimary, &data32) == RM_OK)
    {
        pDev->Dac.TVOutPortID = NV_I2C_PORT_PRIMARY;
    }

    //
    // Initialize cursor.
    //
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        pDev->Dac.CrtcInfo[i].CursorType      = DAC_CURSOR_TWO_COLOR_XOR;
        pDev->Dac.CrtcInfo[i].UpdateFlags = 0;
    }

    //
    // Start the cursor cache at 0
    //
    pDev->Dac.CursorCacheCount = 0;
    pDev->Dac.CursorCacheEntry = 0;
    pDev->Dac.CursorCacheEnable = 1;
    
    //
    // Clear the initial cursor cache data
    //
    for (k = 0; k < MAX_CACHED_CURSORS; k++)
    {
        pDev->Dac.CursorMaskCRC[k] = 0;    
        for (i = 0; i < 32; i++)    
            for (j = 0; j < 32; j++)
                pDev->Dac.CursorImageCache[i][j][k] = 0;
    }                
            
    //
    // Initialize palette to grey scale ramp.
    //
    for (i = 0; i < 256; i++)
        pDev->Dac.Palette[i] = (i << 16) | (i << 8) | i;
    //
    // Initialize gamma to unity translation.
    //
    for (i = 0; i < 256; i++)
        pDev->Dac.Gamma[i] = (i << 16) | (i << 8) | i;
    //
    // Initialize power management state.
    //
    pDev->Dac.DpmLevel = 0;

    //Initialize device properties bits, used to interpret scratch register settings.
    if (osReadRegistryDword(pDev, strDevNodeRM, "RMMaintainDevs", &data32) == RM_OK)
        pDev->Dac.DeviceProperties.RMMaintainDevs = data32;
    else
        pDev->Dac.DeviceProperties.RMMaintainDevs = 0;

    pDev->Dac.DeviceProperties.OverrideSBIOSDevs = ((pDev->Power.MobileOperation == 2) || (pDev->Power.MobileOperation == 4))?TRUE:FALSE;
    // For Toshiba, we'd like to set the infer property only in the case of spanning mode.
    // Unfortunately, at this stage the display driver hasn't told us if we're in spanning
    // mode or not.  I've seen that, at least in Win9x, the display driver enables the
    // second display itself once it is started.  But I'd rather not have the logic in
    // two locations like this.
//    pDev->Dac.DeviceProperties.InferAuxDev = FALSE;
    pDev->Dac.DeviceProperties.Spanning = FALSE;
    pDev->Dac.DeviceProperties.LastSwitchEvent = SWITCH_FROM_COLD_START;

    //
    // Check for a registry override to temporarily enable the 256Burst setting
    // within the DAC.
    //    
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strEnable256Burst, &data) == RM_OK)
        pDev->Dac.HalInfo.Enable256Burst = data;

    //
    // Set the min/max VCO values from the BIOS. This call may fail if we're
    // running an older BIOS, so in this case we'll use the RM defaults.
    //
    if (DevinitGetMinMaxVCOValues(pDev,
                                  &pDev->Dac.FminVco,
                                  &pDev->Dac.FmaxVco) != RM_OK)
    {
        // Use the RM default values for these chips
        // NOTE: These defaults are duplicated in dacCalcMNP() which may
        //       be called before initDac()
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;

            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }

    //
    // Look for a registry override for min/max VCO (in MHz).
    //
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FminVCO", &data32) == RM_OK)
        pDev->Dac.FminVco = data32 * 1000;

    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FmaxVCO", &data32) == RM_OK)
        pDev->Dac.FmaxVco = data32 * 1000;

    //
    // Look for a registry override to set the maximum M value for the PLL equation
    // when driving the external DAC on NV11.  Value must be greater than or equal
    // to 1.  A value of 0 is not allowed, and therefore means the limit feature
    // is disabled.
    //
    // This value is used in dacfp.c
    //
    pDev->Dac.ExtDacMaxM = 0;   // default to off
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "EXTERNALDACMAXM", &data32) == RM_OK)
        if ((data32 > 0) && (data32 <= 0xFF))
            pDev->Dac.ExtDacMaxM = data32;

    //
    // Attempt to detect the presense of an external TV chip.  Attempt to also
    // identify the part so we know how to program it up when a modeset comes
    // through a bit later.
    //    

    //Skip TV encoder detection for IKOS.
#ifndef IKOS
    //
    // If Canopus, skip the detection
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
        pDev->Dac.EncoderType = NV_ENCODER_NONE;
    else
    {        
        // Use head 0 for decoder detection.
        dacDetectEncoder(pDev, 0);
    } // !Canopus

    // Get TV output format from the registry.
    if (dacReadTVOutFromRegistry(pDev, 0, &data32) == RM_OK)
        pDev->Dac.TVoutput = data32;
    else
        pDev->Dac.TVoutput = 0xffffffff;

    //
    // Get TV standard format from what the BIOS chose
    //
    lockA = ReadCRTCLock(pDev, 0);           //Back up lock state
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs
    CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data08, 0);  //scratch value on HeadA only!!
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lockA, 0); // Restore lock state

    pDev->Dac.TVStandard = data08 & 0x7;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DacInit - read TV standard:", pDev->Dac.TVStandard);
    
    if (!pDev->Power.MobileOperation)
    {
        // Check for User override of TV standard
        if (dacReadTVStandardFromRegistry(pDev, &type) == RM_OK)
        {
            pDev->Dac.TVStandard = type;
        }
    }
    //
    // By default on Chrontel encoders, we need to invert the encoder clock
    // out in order to lengthen our time to sample HSYNC.  Some systems require
    // this feature to be disabled, so look for a registry key to override
    // this functionality
    //
    // Default is enabled, override means disabled
    //
    if (osReadRegistryDword(pDev, strDevNodeRM, "DisableTVClockInversion", &data32) == RM_OK)
        pDev->Dac.TVClockInversionDisabled = 1;
    else
        pDev->Dac.TVClockInversionDisabled = 0;

    if (osReadRegistryDword(pDev, strDevNodeRM, "DisableTVOverscan", &data32) == RM_OK)
        pDev->Dac.TVOverscanDisabled = data32;
    else
        pDev->Dac.TVOverscanDisabled = 0;

    if (RM_OK != osReadRegistryDword(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, "TVMasterMode", &pDev->Dac.TVMasterMode))
        pDev->Dac.TVMasterMode = 0;

    //
    // Default Macrovision mode (OFF)
    //
    pDev->Dac.TVLastMacrovision.devAddr         = 0;
    pDev->Dac.TVLastMacrovision.mode            = 0;
    pDev->Dac.TVLastMacrovision.port            = 0;
    pDev->Dac.TVLastMacrovision.encoderType     = 0;
    pDev->Dac.TVLastMacrovision.tvStandard      = 0;
    pDev->Dac.TVLastMacrovision.resx            = 0;
    pDev->Dac.TVLastMacrovision.resy            = 0;

    //
    // We're about to setup head 0's default display type.
    // Before we do that, invalidate any other heads.
    //
    for (i = 1; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        SETDISPLAYTYPE(pDev, i, 0xffffffff);
        SETMONITORTYPE(pDev, i, 0xffffffff);
    }


    
    //Mobile hotkey support initialization.

    pDev->HotKeys.queueHead = 0;
    pDev->HotKeys.queueTail = 0;
    pDev->HotKeys.enabled = FALSE;

    if (pDev->Power.MobileOperation)
        EnableMobileHotkeyHandling(pDev);

    //
    //Set boot display types.
    //
    dacDetectDevices(pDev, TRUE, FALSE);

    // Assume BIOS panel programming initally for all Mobile platforms
    if(pDev->Power.MobileOperation)
      pDev->Dac.BIOSPanelProgramming = 1;

    dacInitCurrentDevices(pDev);


    // We need to setup the DevicesEnabled SW flag.
    // First turn off all devices
    pDev->Dac.DevicesEnabled &= ~(DAC_ALL_DEVICES_ENABLED);
    // loop on all CRTCs
    for (i = 0; i < MAX_CRTCS; i++) 
    {
        // make sure to switch on the CurrentDisplayType
        switch(pDev->Dac.HalInfo.CrtcInfo[i].CurrentDisplayType)
        {
            case DISPLAY_TYPE_MONITOR:
                // pDev->Dac.DevicesEnabled |= DAC_CRT_ENABLED;  // CRT not currently used
                break;
            case DISPLAY_TYPE_FLAT_PANEL:
                pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
                break;
            case DISPLAY_TYPE_TV:
                pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
                break;
            default:
                break;
        }
    }

    //Use what we know about the boot devices to set up a mapping of logical->physical devices
    // for the display driver's benefit.  This is a recommendation of which head should drive
    // the primary device. Logical device 0 is the primary, logical device 1 is the secondary.
    // By default, we set head 0 to the primary.
    // This initialization should only be of interest to mobile systems that don't do explicit
    // reenumerations when the display driver changes devices (read 'Toshiba'), on desktops it's
    // all run via registry keys.  Later changes to the logical device mapping are made via
    // rmUsrAPI calls to NVRM_API_DISPLAY_SET_PHYS_MAPPING.
    pDev->Dac.LogicalDeviceMap[0] = 0;
    pDev->Dac.LogicalDeviceMap[1] = 1;
    if (pDev->Power.MobileOperation) {
        //We use a simple rule set:
        // 1) if there is only one device, leave it alone.  Except for Toshiba, which wants both
        //   devices regardless.
        // 2) if there are two, one is the internal LCD.  That's the primary.
        if ((pDev->Power.MobileOperation == 2)
            || ((pDev->Dac.BootDevicesBitMap - 1) & pDev->Dac.BootDevicesBitMap)) {
            pDev->Dac.LogicalDeviceMap[0] = 1;
            pDev->Dac.LogicalDeviceMap[1] = 0;
        }
    }

    //
    // Set the MonitorType for head 0 *only*
    //
    switch (GETDISPLAYTYPE(pDev, 0))
    {
        case DISPLAY_TYPE_MONITOR:
            SETMONITORTYPE(pDev, 0, MONITOR_TYPE_VGA);
            break;
        case DISPLAY_TYPE_TV:
            switch (pDev->Dac.TVStandard)
            {
                case NTSC_M:
                case NTSC_J:
                    SETMONITORTYPE(pDev, 0, MONITOR_TYPE_NTSC);
                    break;
                case PAL_A:
                case PAL_M:
                case PAL_N:
                case PAL_NC:
                    SETMONITORTYPE(pDev, 0, MONITOR_TYPE_PAL);
                    break;
            }
            break;
        case DISPLAY_TYPE_FLAT_PANEL:        
            SETMONITORTYPE(pDev, 0, MONITOR_TYPE_FLAT_PANEL);
            break;
        default:
            SETDISPLAYTYPE(pDev, 0, DISPLAY_TYPE_MONITOR);
    }

#endif // not IKOS

    //
    // initialize per-crtc state
    //
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        pDev->Dac.CrtcInfo[i].RefCount = 0;
        pDev->Dac.CrtcInfo[i].StateFlags = 0;
        pDev->Dac.CrtcInfo[i].VBlankCounter = 0;
        pDev->Dac.CrtcInfo[i].VBlankToggle = 0;
        pDev->Dac.CrtcInfo[i].VBlankCallbackList = NULL;
        pDev->Dac.CrtcInfo[i].CurrentPanOffset = 0;
        pDev->Dac.CrtcInfo[i].CurrentImageOffset = 0;
    }

    //
    // Perform any os initialization
    //
    initDacEx(pDev);
    
    //
    // initialize I2C lock flags
    //
    pDev->I2CAcquired = 0;

    //
    // Initialize mclk divide.  Default is 1 which is no
    // divide
    //
    pDev->Dac.HalInfo.MClkDivide = 1;

    //
    // Determine which head was used to boot the system
    //
    // NEED TO DO: Get this from the BIOS, but for now if we're
    // a mobile system booting the DFP let's get the drivers to swing
    // over to the secondary head.
    // LPL : preliminary version that reads from BIOS in place above.
    //
    pDev->Dac.HalInfo.InitialBootHead = 0;
    if (pDev->Power.MobileOperation && (GETDISPLAYTYPE(pDev, 0) == DISPLAY_TYPE_FLAT_PANEL))
        pDev->Dac.HalInfo.InitialBootHead = 1;

    //
    // WORKAROUND - REMOVE QUICKLY BEFORE SCOTT LONG CATCHES ME
    //
    // The current PCLK limits programmed by the HAL are head driven.
    // They really need to be device driven, as the head can drive any
    // one of many devices.  The current HeadB limits were dictated by
    // an external CRT (150MHz max) and were fine while the possible
    // DFP's and TV's stayed below that ceiling.  Now mobile is appearing
    // with huge DFP's, and therefore the 150 limit is insufficient.
    //
    // Since mobile will never use an external DAC, override in this one
    // case to 170MHz in order to handle 16x12 panels.
    //
    // The real limits will actually come from the BIOS via the BIP/3
    // parser.
    //
    if (pDev->Power.MobileOperation)
    {
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit8bpp = 170000000;
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit16bpp = 170000000;
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit32bpp = 170000000;
    }

    //
    // WORKAROUND FOR INCORRECT BOARD STRAPPING ON TOSHIBA SYSTEMS
    //
    // Toshiba mobile is incorrectly strapped for 24bit DFP operation,
    // which precludes the use of the TV encoder.  Force back to the
    // correct 12bit until the boards are reworked.
    //
    if (pDev->Power.MobileOperation == 2)
    {
        FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
        FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE, _12BIT);
    }

    // Make sure we initialize the panel strap and Mobile EDID
    dacPreInitEDID(pDev);
    
    // determine broadcast support
    // Read Head A CRTC regs
    {
      U008 Cr3C, lock;

      lock = UnlockCRTC(pDev, 0);
      CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, Cr3C, 0);     // find out if BIOS supports broadcast mode
      RestoreLock(pDev, 0, lock);
      if((pDev->Power.MobileOperation) && // only for mobiles right now.
         (Cr3C & 0x02)  && // Bit 1 shows BIOS support for broadcast mode. 0-no support 1-supported
         (0)) //(pDev->Chip.BiosRevision > 0x3110134))  Don't support broadcast mode until I get this fixed.
        pDev->Dac.BroadcastSupport = 1;
      else
        pDev->Dac.BroadcastSupport = 0;
    }

    return (RM_OK);
}

// WinNT / Win2k Notes:
//
//        Before RmInitDevice() is called in the NT miniport, we need
//        to make sure that any non-primary monitor is 'alive',  so that
//        dacMonitorConnectStatus() works correctly.  We do this by using
//        the 'WakeUpCard' function in the miniport.
//  
//        dacMonitorConnectStatus() sometimes returns FALSE POSITIVE 
//        when on a FLAT PANEL panel or TV.  So to make NT initialization
//        as safe as possible, we need to use combinations of these functions.
//
//        1) Check for CRT first
//        2) Check for Flat Panel
//        3) Check for TV
//        4) Fall back to CRT
//

#ifdef MACOS        /* macos9 or macosX */

// Mac algorithm for monitor selection is different from windows:
//
//   if flat panel avail
//      use it
//   else if CRT attached
//      use it
//   else
//      no device, error.
//

static U032 dacGetDisplayType(
    PHWINFO pDev,
    U032 Head
)
{
    U032   BootDisplayDevice;
    U008   lock;
    RM_STATUS status;

    //
    // Use our current setting as the desired display type.
    //
    BootDisplayDevice = GETDISPLAYTYPE(pDev, Head);

    if (dacFlatPanelConnectStatus(pDev, Head))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel\n");

        BootDisplayDevice = DISPLAY_TYPE_FLAT_PANEL;
        
        dacGetPWMController(pDev);          
    }
    else if (dacMonitorConnectStatus(pDev, Head))
    {
        lock = UnlockCRTC(pDev, Head);
        status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);
        RestoreLock(pDev, Head, lock);
        
        if ((status == RM_OK) && (edidIsAnalogDisplay(pDev, Head)))
            BootDisplayDevice = DISPLAY_TYPE_MONITOR;
    }

    return BootDisplayDevice;
}

#else

static U032 dacGetDisplayType(
    PHWINFO pDev,
    U032 Head
)
{
    U032 BootDisplayDevice;
    BOOL MonitorAvail, FlatPanelAvail, TVAvail, RequestedDisplayDeviceAvail;
    U032 RequestedDisplayDevice;

    //
    // Use our current setting as the desired display type.
    //
    RequestedDisplayDevice = GETDISPLAYTYPE(pDev, Head);

    // @ Detect avail display devices
    // - Check the MONITOR status
    if(dacMonitorConnectStatus(pDev, Head)) {
        MonitorAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Monitor connected\n\r");
    }
    else {
        MonitorAvail = FALSE;
    }

    // - Check the FLATPANEL status
    if(IsNV5orBetter(pDev) && dacFlatPanelConnectStatus(pDev, Head)) {
        FlatPanelAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel connected\n\r");
    }
    else {
        FlatPanelAvail = FALSE;
    }

    // - Check the TV status
    if(dacTVConnectStatus(pDev, Head)) {
        TVAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - TV connected\n\r");
    }
    else {
        TVAvail = FALSE;
    }

    // - Assume the requested display device is not available
    RequestedDisplayDeviceAvail = FALSE;

    switch(RequestedDisplayDevice) {
        case DISPLAY_TYPE_MONITOR:
            if(MonitorAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            if(FlatPanelAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        case DISPLAY_TYPE_TV:
            if(TVAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        default:
            break;
    }

    // - If the requested device is unavail, determine the next best thing
    if(!RequestedDisplayDeviceAvail)
    {
        if(MonitorAvail)
        {
            BootDisplayDevice = DISPLAY_TYPE_MONITOR;
        }
        else
        {
            if(FlatPanelAvail)
            {
                BootDisplayDevice = DISPLAY_TYPE_FLAT_PANEL;
            }
            else
            {
                if(TVAvail)
                    BootDisplayDevice = DISPLAY_TYPE_TV;
                else
                    BootDisplayDevice = dacGetBiosDisplayType(pDev, 0);
            }
        }
    }

    // - If the requested device is present, use it
    if(RequestedDisplayDeviceAvail)
        BootDisplayDevice = RequestedDisplayDevice;

    // Display the resulting display device
    switch(BootDisplayDevice) {

        case DISPLAY_TYPE_MONITOR:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Monitor selected as display device\n\r");
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel selected as display device\n\r");
            break;

        case DISPLAY_TYPE_TV:
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - TV selected as display device\n\r");
               break;

        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Display device is unknown\n\r");
            break;
    }

    return BootDisplayDevice;
}
#endif   /* ! MACOS */


//Note this function is only intended for mobile system lookup (assumes internal LCD on head 1)
U032 dispTypeToHotkeyLookup(U032 Head, U032 dispType)
{
    if (dispType == DISPLAY_TYPE_MONITOR)
        return NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT;
    if (dispType == DISPLAY_TYPE_TV)
        return NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV;
    if (dispType == DISPLAY_TYPE_FLAT_PANEL) {
        if (Head)
            return NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD;
        else
            return NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP;
    }

    return 0;
}

RM_STATUS dacDetectDevices
(
    PHWINFO pDev,
    BOOL    bStartup,
    BOOL    spoofKey
)
{
    U008 lockA, lockB, cr3BhA, cr3BhB;
    U032 i, j, curDispType[MAX_CRTCS], origDispType[MAX_CRTCS], devmask;
    U032 noCheckDevices = 0;

    // Disable I/O broadcast mode for now to work around a
    // a hardware bug that prevents us from reaching
    // HeadB through privSpace with this enabled
    FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _DISP_MIRROR, _DISABLE);

    for (i = 0; i < MAX_CRTCS; i++) {
        curDispType[i] = GETDISPLAYTYPE(pDev, i);
        //I'm seeing the display type set to a valid value when the display isn't in use.  So...
        if (!pDev->Dac.CrtcInfo[i].pVidLutCurDac) curDispType[i] = DISPLAY_TYPE_NONE;
        origDispType[i] = curDispType[i];
    }

    if (pDev->Power.MobileOperation) {
        if (pDev->Dac.DeviceProperties.RMMaintainDevs) { //Ignore SBIOS/VBIOS and apply our own selection scheme
            //Could make it so we only need to read the reg key at startup and cache the changes
            // the rest of the time.  This would avoid the problem of being unable to access
            // the registry under NT while at raised IRQL.  But I think we're safe whenever this
            // fn is called.
            if(osReadRegistryDword(pDev, strDevNodeRM, strCurWinDevices, &i) == RM_OK) {
                //Seems unfortunate to break down the bitmask into devices, only to reconstruct
                // a bitmask later, but since part of that later process is detection, and it
                // alreasy works, we'll stick with this format for now.
                curDispType[0] = DISPLAY_TYPE_NONE;
                curDispType[1] = DISPLAY_TYPE_NONE;
                if (i & DAC_DD_MASK_IN_MAP) curDispType[1] = DISPLAY_TYPE_FLAT_PANEL;
                if (i & DAC_TV_MASK_IN_MAP) curDispType[0] = DISPLAY_TYPE_TV;
                if (i & DAC_CRT_MASK_IN_MAP) curDispType[0] = DISPLAY_TYPE_MONITOR;
            } else {    //No reg key? Fallback rules apply.
                curDispType[0] = DISPLAY_TYPE_MONITOR;
                curDispType[1] = DISPLAY_TYPE_FLAT_PANEL;
            }
        } else {    //Check and use current VBIOS settings
            // Unlock both heads
            lockA = UnlockCRTC(pDev, 0);
            lockB = UnlockCRTC(pDev, 1);

            //Read CR3B regs -- used below to set default display types.
            // Write back the registers with the 'enable' bits cleared.
            // They will be set as needed via display driver calls to dacSetModeMulti.
            CRTC_RD(0x3B, cr3BhA, 0);
            CRTC_RD(0x3B, cr3BhB, 1);

            //Removed because calls to detect devices after boot but before any modesets
            //will detect no devices enabled.  If there is a modeset to each head at startup
            //this is safe.  If there were only one, and the other head had been enabled
            //in DOS but not in Windows, I think invalid CR3B settings may slip through.
        //    if (bStartup) { //May not be needed anymore -- explicit clear of what's enabled
        //                    // at startup.  Modesets will then enable whatever is needed.
        //        CRTC_WR(0x3B, cr3BhA & 0x0F, 0);
        //        CRTC_WR(0x3B, cr3BhB & 0x0F, 1);
        //    }

            RestoreLock(pDev, 0, lockA);
            RestoreLock(pDev, 1, lockB);

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/0 register:", cr3BhA);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/1 register:", cr3BhB);

            //Set startup display options based on BIOS CR3B settings.
            if (cr3BhA & 0x20) {
                curDispType[0] = DISPLAY_TYPE_MONITOR;
            } else if (cr3BhA & 0x40) {
                curDispType[0] = DISPLAY_TYPE_TV;
            } else if (cr3BhA & 0x80) {
                curDispType[0] = DISPLAY_TYPE_FLAT_PANEL; //external DFP
            } else {
                curDispType[0] = DISPLAY_TYPE_NONE;
            }
            if (cr3BhB & 0x10) {
                curDispType[1] = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
            } else {
                curDispType[1] = DISPLAY_TYPE_NONE;
            }

            // Since the VGA modes do not support twinview modes, we may need a
            // way to infer that in Windows a second display should be enabled
            // (Since it won't be reflected in the CR3B scratch register settings).
            // We currently only apply this for Toshiba.  Dell's system BIOS
            // largely sets the values correctly, and they have agreed they'd
            // rather keep control of it themselves than have us add in logic
            // here.  God bless 'em.
            if (pDev->Dac.DeviceProperties.OverrideSBIOSDevs) {
                noCheckDevices = pDev->Dac.DevicesNoCheck;

                if(osReadRegistryDword(pDev, strDevNodeRM, strLastExtDevice, &i) == RM_OK) {
    //                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: read ext dev:", i);
                } else {
                    i = DISPLAY_TYPE_NONE;
                }
                switch (pDev->Dac.DeviceProperties.LastSwitchEvent) {
                case SWITCH_FROM_FS_DOS:
                    //If we were in spanning mode in Windows, restore to same devices.
                    // Otherwise switch to one device, with preference for LCD.
                    if (pDev->Dac.DeviceProperties.Spanning) {
                        curDispType[0] = i;
                        curDispType[1] = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
                    } else {
                        //This should already be set properly by SBIOS coming from
                        // hibernation or cold boot, but for Win2K may not be set
                        // correctly returning from FS-DOS.
                        if (curDispType[1] != DISPLAY_TYPE_NONE)
                            curDispType[0] = DISPLAY_TYPE_NONE;
                    }
                    break;
                case SWITCH_FROM_COLD_START:
    #if 1
                    if (i != DISPLAY_TYPE_NONE) {
                        curDispType[0] = i;
                        curDispType[1] = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
                    
                        // If we hibernate in LCD+CRT Clone mode, Toshiba wants to return 
                        // to LCD+CRT whether or not the CRT is actually present.  
                        // To fix this, we use pDev->Dac.DevicesNoCheck so that when 
                        // we call dacDevicesConnectStatus() later in this function,
                        // it will return TRUE always for that particular device.
                        // This fixes bug 32780.
      //                  noCheckDevices = pDev->Dac.DevicesNoCheck;
                    }
    #else
                    if (pDev->Dac.DeviceProperties.Spanning) {
                        curDispType[0] = DISPLAY_TYPE_MONITOR;
                        curDispType[1] = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
                    } else {
                        //This should already be set properly by SBIOS coming from
                        // hibernation or cold boot, but for Win2K may not be set
                        // correctly returning from FS-DOS.
                        if (curDispType[1] != DISPLAY_TYPE_NONE)
                            curDispType[0] = DISPLAY_TYPE_NONE;
                    }
    #endif
                    break;
                case SWITCH_FROM_WINDOWS:
                default:
                    break;
                }
            }

            //
            // BUG WORKAROUND
            //
            // We used to do a device scan on every boot, but now with the new DEVICES_CONNECTED
            // API in place, this is only done on demand.
            //
            // Now with the Chrontel encoders Windows sometimes boots up all wavy.
            //
            // There appears to be a bug in programming the initial mode on the Chrontel 7007
            // TV encoder where some values are incorrect.  For whatever reason, we didn't
            // see this before because of the detection sequence that occurred before the
            // modeset.
            // 
            // In any event, asking the encoder to detect the presence of the TV clears 
            // everything up.
            //
            // Until we can find the underlying cause, force a detect even though we
            // don't need it.  This will act as a workaround until I can get someone
            // to debug the TV programming.
            //
            // PLEASE remove this as soon as possible.
            //
            // Only do this at boot time.
            if(bStartup)
                i = dacGetDisplayType(pDev, 0);  // don't really care what we get, just scan
        }

    } else {    //Desktop, not mobile
    //
    // Set default boot display type...first, use what the
    // CR28/CR33 registers tell us via the BIOS settings.
    //
        if (bStartup) {
            SETDISPLAYTYPE(pDev, 0, dacGetBiosDisplayType(pDev, 0));
            SETDISPLAYTYPE(pDev, 0, dacGetDisplayType(pDev, 0));
            curDispType[0] = GETDISPLAYTYPE(pDev, 0);
        }
    }


    //Determine which displays the VGA BIOS enabled at boot time, so that on mobile systems
    //we can have the same ones enabled in Windows.  The result is reported to the display
    //driver as a device bit mask rather than the old head-based system.
    // (We now do this re-detect at several other times, including resume from hibernation
    // and whenever the boot mask is requested).
    devmask = 0;   //clear boot device bitmask
    //Loop over all heads
    for (j = 0; j < MAX_CRTCS; j++) {   //Head
        //Loop over all list entries
        for (i = 0; (i < DCB_MAX_NUM_DEVDESCS) && (pDev->Dac.DCBDesc[i].DCBRecType != DCB_DEV_REC_TYPE_EOL); i++)
        {
//            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  *** Checking for: ", pDev->Dac.DCBDesc[i].DevTypeUnit);
            //If list entry is for this head...
            if (pDev->Dac.DCBDesc[i].DCBRecHead == (U032)(j?DCB_DEV_REC_HEAD_B:DCB_DEV_REC_HEAD_A))
            {
                //...and display type matches the BIOS's...
                U032 typematch = 0;
                switch (pDev->Dac.DCBDesc[i].DCBRecType) {
                case DCB_DEV_REC_TYPE_CRT:
                    if (curDispType[j] == DISPLAY_TYPE_MONITOR) typematch = 1;
                    break;
                case DCB_DEV_REC_TYPE_TV:
                    if (curDispType[j] == DISPLAY_TYPE_TV) typematch = 1;
                    break;
                case DCB_DEV_REC_TYPE_DD_SLINK:
                case DCB_DEV_REC_TYPE_DD_DLINK:
                case DCB_DEV_REC_TYPE_DD:
                    if (curDispType[j] == DISPLAY_TYPE_FLAT_PANEL) typematch = 1;
                    break;
                default:
                    break;
                }

                if (typematch) {
                    //...OR this entry's mask into the boot device mask
                    U032 temp = pDev->Dac.DCBDesc[i].DevTypeUnit;
//                    if (pDev->Power.MobileOperation != 2) //Toshiba doesn't want non-existence to prevent enabling a device
                        dacDevicesConnectStatus(pDev, &temp, noCheckDevices);   //Test for presence of this device
                    if (!temp) {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Discarding as boot dev:", pDev->Dac.DCBDesc[i].DevTypeUnit);
                        curDispType[j] = DISPLAY_TYPE_NONE;
                    }
                    devmask |= temp;   //Device bitmask for device on this head.
                }
            }
        }

        if (bStartup && pDev->Power.MobileOperation)
            SETDISPLAYTYPE(pDev, j, curDispType[j]);
    }

    //What if nothing turned up?
    if (!devmask) {
        if (pDev->Power.MobileOperation) { 
            devmask = 0x1 << DAC_DD_OFFSET_IN_MAP;  // Fall back to the internal LCD
            curDispType[1] = DISPLAY_TYPE_FLAT_PANEL;
        } else {
            devmask = 0x1 << DAC_CRT_OFFSET_IN_MAP; // Fall back to a CRT
            curDispType[0] = DISPLAY_TYPE_MONITOR;
        }
        
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No boot device determined.  Using default.\r\n");
    }
    
    // Only assign the devmask to BootDevicesBitMap if we are mobile or doing
    // startup; desktop systems calling dacDetectDevices during non-startup
    // may build an incorrect devmask (and since the BootDevicesBitMap is
    // static on desktops, we don't want to reassign it anyway)
    
    if (pDev->Power.MobileOperation || bStartup)
        pDev->Dac.BootDevicesBitMap = devmask;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Boot device(s):", pDev->Dac.BootDevicesBitMap);

#ifndef NTRM
    // There may have been a change in which devices are connected during power-down.
    // When we resume, on mobile systems we emulate the state the system BIOS powered
    // up in.  Under Win2K, this is handled with ACPI events.  Under Win9x, we may generate
    // a fake hotkey event here which will switch the displays if needed.  Currently
    // only used with Toshiba.
    if (spoofKey && pDev->Power.MobileOperation) {
        if ((curDispType[0] != origDispType[0]) || (curDispType[1] != origDispType[1])) {
            U032 induceSwitch;
            induceSwitch = dispTypeToHotkeyLookup(0, curDispType[0]) | dispTypeToHotkeyLookup(1, curDispType[1]);
            hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_ENABLE, induceSwitch);
        }
    }
#endif

    return RM_OK;
}

static RM_STATUS dacInitCurrentDevices
(
    PHWINFO pDev
)
{
    U008 lockA, lockB, cr3BhA, cr3BhB;

    if (pDev->Power.MobileOperation) {

        // Unlock both heads
        lockA = UnlockCRTC(pDev, 0);
        lockB = UnlockCRTC(pDev, 1);
    
        //Read CR3B regs -- used below to set default display types.
        CRTC_RD(0x3B, cr3BhA, 0);
        CRTC_RD(0x3B, cr3BhB, 1);
        RestoreLock(pDev, 0, lockA);
        RestoreLock(pDev, 1, lockB);

        //Set startup display options based on BIOS CR3B settings.
        if (cr3BhA & 0x20) {
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_MONITOR;
        } else if (cr3BhA & 0x40) {
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_TV;
        } else if (cr3BhA & 0x80) {
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_FLAT_PANEL; //external DFP
        } else {
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_NONE;
        }
        
        if (cr3BhB & 0x10) {
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
        } else {
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = DISPLAY_TYPE_NONE;
        }
    } else { // Non-mobile case already detected in dacDetectDevices.
        pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = pDev->Dac.HalInfo.CrtcInfo[0].DisplayType;
    }
    return RM_OK;
}

static RM_STATUS dacInitGetMobileEDIDFromBios(PHWINFO pDev)
{
    U032 rmStatus = RM_ERROR;
    U032 offset;
    BMP_Control_Block bmpCtrlBlk;
    BIOSFPTable biosFPTable;
    U008 fpTableIndex;
    U008 fpXlateTable[SIZE_FP_XLATE_TABLE];
    U032 useDynEDIDs;

    //The sequence of events here is
    //A.) Find the control block
    //B.) If correct ver/subver grab the BMP Table
    //C.) Get strappings from vbios call
    //D.) Read a translate table from the bios
    //E.) Use the straps to index into the translate table
    //F.) Take the entry at that index in the xlate talbe
    //    and that is the index of the FP_TABLE you want to
    //    use.
    //G.) Mult the xlate table entry by # bytes in an FP_TABLE
    //    then add this to the FP_TABLE ptr in the control blk.
    //    This gets you to the FP_TABLE you need.
    //H.) Read in the FP_TABLE and extract EDID DTD.

    //Check to see if this feature is desired, based on registry key setting:
    pDev->Dac.MobileEDID[0] = 1;    //Assure the EDID is invalid unless we get all the way through.
                                    // (checked in edidConstructMobileInfo())
    rmStatus = osReadRegistryDword(pDev, strDevNodeRM, "SoftEDIDs", &useDynEDIDs);
    if ((rmStatus != RM_OK) || !useDynEDIDs) {
        rmStatus = RM_ERROR;
    } else {
        rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    }

    if (rmStatus == RM_OK)
    {
        //According to the bios guys only Rev5 Subver14 BMP Tables
        //can be guaranteed to have this structure. We cannot 
        //necessarily assume this will stay the same in later subvers.
        if (bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5 &&
            bmpCtrlBlk.CTL_Flags >= BMP_INIT_TABLE_SUBVER_0x14)
        {
            BMP_Struc_Rev5_0x14 bmpInitTableInfo;

            rmStatus = BiosReadStructure(pDev, 
                                        (U008*)&bmpInitTableInfo,
                                        offset,
                                        (U032 *)0,
                                        BMP_INIT5_0x14_FMT);
            if (rmStatus == RM_OK)
            {
                //Read the 16 byte XLate table
                rmStatus = BiosReadBytes(pDev,
                                         fpXlateTable,
                                         bmpInitTableInfo.BMP_FPXlateTablePtr,
                                         sizeof( fpXlateTable )); 
                if (rmStatus == RM_OK)
                {
                    //Index into the XLate table to determine
                    //which FPTable we want.
                    fpTableIndex = fpXlateTable[pDev->Dac.PanelStrap];

                    //Multiply the index of the desired FPTable
                    //by the size of the FPTable and add that
                    //to the base pointer found in the BMP
                    //table. This should get us to exactly the
                    //FPTable we want.
                    rmStatus = BiosReadStructure(pDev,
                                                 &biosFPTable,
                                                 bmpInitTableInfo.BMP_FPTablePtr + 
                                                 (fpTableIndex * BMP_FP_TABLE_SIZE),
                                                 (U032 *)0, BMP_FP_TABLE_FMT);
                    if (rmStatus == RM_OK)
                    {
                        //Now that we have the FPTable, extract
                        //out everything we need to make an EDID.
                        dacInitFPTableToEDID(pDev, &biosFPTable, pDev->Dac.MobileEDID);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: MobileEDID ptr:", (U032)(NV_UINTPTR_T)(pDev->Dac.MobileEDID));
                    }
                }
            }
        }
        else
        {
            rmStatus = RM_ERROR;
        }
    }

    return rmStatus;
}


//Looks up numerical value of a character interpreted as a hex digit,
// and shifts it in to the low nibble of an 8-bit result.
// Non-hex characters have no effect.  This automatically handles
// most leading/trailing characters.  Returns TRUE is a hex char was found.
BOOL convNibbleFromHex(U008 textchar, U008 *cumulative)
{
    if ((textchar >= '0') && (textchar <= '9'))
        *cumulative = (*cumulative << 4) | (textchar - '0');
    else if ((textchar >= 'A') && (textchar <= 'F'))
        *cumulative = (*cumulative << 4) | (textchar - 'A' + 10);
    else if ((textchar >= 'a') && (textchar <= 'f'))
        *cumulative = (*cumulative << 4) | (textchar - 'a' + 10);
    else
        return FALSE;

    return TRUE;
}


// Read Straps from bios and create Mobile EDID
VOID dacPreInitEDID(PHWINFO pDev)
{
    // Check to see if we've initialized the panel strap
    if(!(pDev->Dac.DevicesEnabled & DAC_PRE_EDID_INITIALIZED))
    {
        // Create Mobile EDID
        if (pDev->Power.MobileOperation)
        {
            // Get Panel Strap
            U032 eax, ebx, ecx, edx;
            // FP Straps come back in CL.
            eax = 0x4F14;
            ebx = 0x0186;
            ecx = edx = 0;
            
            // Call BIOS to get strap
            osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, NULL);
            
            // If the BIOS call fails, it will return 0x014f
            if (eax == 0x014F)
                pDev->Dac.PanelStrap = 0;  // BIOS call didn't support it
            else if (eax == 0x004F)
                pDev->Dac.PanelStrap = ecx & 0xF; //We only care about the lower nibble.
            else
            {
                // In WinXP, this call can occur before the int10 handler has been
                // hooked, so that osCallVideoBIOS doesn't get to our vbios. In this
                // case, don't set the DAC_PRE_EDID_INITIALIZED flag, so we can try
                // again on a subsequent call.
                pDev->Dac.PanelStrap = 0;
                return;
            }
        
            dacInitGetMobileEDIDFromBios(pDev);
        }
        else
            pDev->Dac.PanelStrap = 0;  // Panel straps only for Mobile BIOSes
    
        // Set flag so we don't have to run this function again.
        pDev->Dac.DevicesEnabled |= DAC_PRE_EDID_INITIALIZED;
    }
}


//Calculate and assign the EDID checksum, defined as the value that causes the
// sum of all 128 bytes, mod 256, to total 0.
static VOID dacInitCalculateEDIDChkSum(PHWINFO pDev, U008 *pEdid)
{
    U032 i;
    U008 chksum = 0;

    for (i = 0; i < 127; i++)
    {
        chksum += pEdid[i];
    }

    pEdid[0x7F] = (~chksum) + 1;
}


#define DD_BLOCK_LENGTH 18
#define DD_BLOCK_DESC_LENGTH 5
#define MAX_MON_STRING_LENGTH ((DD_BLOCK_LENGTH - DD_BLOCK_DESC_LENGTH) * 3)

static VOID dacInitFPTableToEDID(PHWINFO pDev, PBIOSFPTable pFPTable, U008 *pEdid)
{
    U032 i, j, RegHImageSize, RegVImageSize;
    U008 HActive, HBlank, HAcHBlnk;
    U008 HSyncOffset, HSyncPW, HImageSize, HBorder;
    U008 VActive, VBlank, VAcVBlnk;
    U008 VSyncOffset, VSyncPW, VImageSize, VBorder;
    U008 VSyncOffPW, HVSyncOffPW, HVImageSize;
    U008 Flags;
    U032 panelStrap = pDev->Dac.PanelStrap;
    U032 numbytes;
    U032 HexManufacturerName = 0, blknum = 0, curblk;
    char PanelXX[16];// = "Panel";
    char EDIDPanelXX[16];// = "EDIDPanel";
    char *manufacturername = "NVD";
    char panelname[MAX_MON_STRING_LENGTH];// = "Nvidia Default Flat Panel";
    char featuresupport = (U008)0xEA;
    char PanelRegKeyVal[800];   //Needs to be big enough to hold a string describing
                                //a full EDID (128 * x chars per entry, e.g. "3, a, 4" or "0x23, 0x50")

    /* XXX  temporary hack to work around gcc curiosity on linux: gcc was
       implicity inserting a memset into this code to clear the bytes of
       PanelXX[] from after "Panel" through the end of the array (and
       likewise for EDIDPanelXX[] and panelname[] -- any statically
       sized character array that was assigned a string smaller than
       the array size).  This results in an unresolved symbol when insmod'ing
       NVdriver into a 2.2.x kernel.  The quick 'n dirty solution is to
       explicitly clear the memory and strcpy the default string values into
       the arrays, though I don't quite understand what the difference is
       between gcc's inserted memset, and the memset called by osMemSet.
       My guess is that the preprocessor does something with the memset
       called by osMemSet to change it into a symbol defined by the kernel,
       while the memset inserted by gcc gets inserted after preprocessing,
       and thus does not get translated into a symbol defined by the
       kernel... that's only a guess, though.
       
       remove this hack as soon as we find a better solution. */

    osMemSet (PanelXX, 0, 16);
    osStringCopy (PanelXX, "Panel");

    osMemSet (EDIDPanelXX, 0, 16);
    osStringCopy (EDIDPanelXX, "EDIDPanel");

    osMemSet (panelname, 0, MAX_MON_STRING_LENGTH);
    osStringCopy (panelname, "Nvidia Default Flat Panel");
    
    //Just in case
    for (i = 0; i < 128; i++)
    {
        pEdid[i] = 0x00;
    }

    //Construct registry key for individual parameter overrides.
    // Format is 'Panel'+ a 2-digit strap index.
    i = osStringLength(PanelXX);
    PanelXX[i++] = DIGIT(1, panelStrap);
    PanelXX[i++] = DIGIT(0, panelStrap);
    PanelXX[i] = NULL;

    //XXX: Not really needed here. Can be moved to edidConstructMobileInfo
    //Construct registry key for full-EDID override.
    // Format is 'EDIDPanel'+ a 2-digit strap index.
    i = osStringLength(EDIDPanelXX);
    EDIDPanelXX[i++] = DIGIT(1, panelStrap);
    EDIDPanelXX[i++] = DIGIT(0, panelStrap);
    EDIDPanelXX[i] = NULL;

    //Now read out field-based overrides.
    // The fields are all packed into one comma-separated string, with most commonly
    // overriden elements first.  In order to skip a field in the string without
    // overriding it, follow the preceding comma immediately with another comma.
    // Field order: Manufacturer descriptor string, manufacturer ID (3 chars), Feature Support
    numbytes = sizeof(PanelRegKeyVal);
    if (osReadRegistryBinary(pDev, strDevNodeRM, PanelXX, (U008 *)PanelRegKeyVal, &numbytes) == RM_OK) 
    {
        i = j = 0;

        while ((PanelRegKeyVal[j] != ',') && (PanelRegKeyVal[j] != '\0'))
        {
            panelname[i++] = PanelRegKeyVal[j++];
        }
        if (i) {  //if this field had at least one char
            for (;i < MAX_MON_STRING_LENGTH; i++) panelname[i] = '\0';  //pad the rest of the field with NULLs
        }

        if (PanelRegKeyVal[j] != '\0') {
            j++;
            i = 0;

            //Extract manufacturer code
            while ((PanelRegKeyVal[j] != ',') && (PanelRegKeyVal[j] != '\0'))
            {
                manufacturername[i++] = PanelRegKeyVal[j++];
            }
//            if (i) manufacturername[i] = '\0';  //if this field had at least one char

            if (PanelRegKeyVal[j] != '\0') {
                U008 entry = 0;
                j++;
                i = 0;

                while ((PanelRegKeyVal[j] != ',') && (PanelRegKeyVal[j] != '\0'))
                {
                    if (convNibbleFromHex(PanelRegKeyVal[j++], &entry)) i++;
                }
                if (i) featuresupport = entry;  //if this field had at least one digit
            }
        }
    }

    //Convert to 5 bit compressed ASCII to encode in 2 bytes of the EDID.
    HexManufacturerName = (COMPRESSEDASCIIVAL(manufacturername[0]) & 0x1F) << 10;
    HexManufacturerName |= (COMPRESSEDASCIIVAL(manufacturername[1]) & 0x1F) << 5;
    HexManufacturerName |= COMPRESSEDASCIIVAL(manufacturername[2]) & 0x1F;


    // Extract out all the relevant bits from the BIOS FP_TABLE
    // We need to fill in a Detailed Timing Descriptor (DTD) in an EDID.
    // The following is from the VESA EDID spec (sec 3.16) and descibes 
    // why we have to do all the shifting and masking below.

    /****************************************************************/
    /* Bytes|   Detailed Timing Desc.   |           Format          */
    /* ------------------------------------------------------------ */
    /*  2   | Pixel Clock/10,000        | Stored LSB First          */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Active         | Pixels, lower 8bits       */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Blanking       | Pixels, lower 8bits       */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Active:        | Upper nibble: Upper 4 bits*/
    /*      | Horizontal Blanking       | of Horizontal Active.     */
    /*      |                           | Lower nibble: Upper 4 bits*/
    /*      |                           | of Horzinontal Blanking   */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Active           | Lines, lower 8bits        */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Blanking         | Lines, lower 8bits        */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Active:          | Upper nibble: Upper 4 bits*/
    /*      | Vertical Blanking         | of Vertical Active.       */
    /*      |                           | Lower nibble: Upper 4 bits*/
    /*      |                           | of Vertical Blanking      */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Sync Offset    | Pixelss, from blanking    */
    /*      |                           | starts. Lower 8 bits      */
    /* ------------------------------------------------------------ */
    /*  1   | Horiz Sync Pulse Width    | Pixels, lower 8 bits      */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Sync Offset:     | Upper nibble: lines, lower*/
    /*      | Vertical Sync Pulse Width | 4 bits of VSync Offset.   */
    /*      |                           | Lower nibble: lines, lower*/
    /*      |                           | 4 bits of VSync PW        */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Sync Offset    | bits 7,6: upper 2bits HSO */
    /*      | HSy