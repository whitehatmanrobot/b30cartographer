ClCfgSrvLogger")


//****************************************************************************
//
// Global Static Variables
//
//****************************************************************************


IGlobalInterfaceTable * CClCfgSrvLogger::sm_pgit            = NULL;
CRITICAL_SECTION *      CClCfgSrvLogger::sm_pcritsec        = NULL;
bool                    CClCfgSrvLogger::sm_fRevokingFromGIT= false;
DWORD                   CClCfgSrvLogger::sm_cookieGITLogger = 0;


//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClCfgSrvLogger::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClCfgSrvLogger::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr;
    CClCfgSrvLogger *   pccsl = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccsl = new CClCfgSrvLogger();
    if ( pccsl == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccsl->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccsl->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pccsl != NULL )
    {
        pccsl->Release();
    } // if:

    HRETURN( hr );

} //*** CClCfgSrvLogger::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClCfgSrvLogger::CClCfgSrvLogger( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CClCfgSrvLogger::CClCfgSrvLogger( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CClCfgSrvLogger::CClCfgSrvLogger( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CClCfgSrvLogger::HrInit( )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClCfgSrvLogger::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    Assert( m_cRef == 1 );
    Assert( sm_pgit == NULL );

    // Create the Global Interface Table object.
    hr = THR( CoCreateInstance(
                      CLSID_StdGlobalInterfaceTable
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IGlobalInterfaceTable
                    , reinterpret_cast< void ** >( &sm_pgit )
                    ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Create a critical section so that the object can be removed from
    // the GIT in Release().
    //
    if ( sm_pcritsec == NULL )
    {
        PCRITICAL_SECTION pcritsecNew =
            (PCRITICAL_SECTION) HeapAlloc( GetProcessHeap(), 0, sizeof( CRITICAL_SECTION ) );
        if ( pcritsecNew == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } // if: creation failed

        InitializeCriticalSection( pcritsecNew );

        // Make sure we only have one log critical section
        InterlockedCompareExchangePointer( (PVOID *) &sm_pcritsec, pcritsecNew, 0 );
        if ( sm_pcritsec != pcritsecNew )
        {
            DeleteCriticalSection( pcritsecNew );
            HeapFree( GetProcessHeap(), 0, pcritsecNew );

        } // if: already have another critical section

    } // if: no critical section created yet

    // Open the log file.
    hr = THR( HrLogOpen() );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Release the critical section on the log file.
    hr = THR( HrLogRelease() );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** CClCfgSrvLogger::HrInit( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClCfgSrvLogger::~CClCfgSrvLogger( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CClCfgSrvLogger::~CClCfgSrvLogger( void )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( m_cRef == 0 );

    // Close the log file.
    THR( HrLogClose() );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClCfgSrvLogger::~CClCfgSrvLogger( )


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClCfgSrvLogger::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClCfgSrvLogger::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ILogger * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ILogger ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ILogger, this, 0 );
        hr = S_OK;
    } // else if: ILogger

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClCfgSrvLogger::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CClCfgSrvLogger::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClCfgSrvLogger::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CClCfgSrvLogger::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CClCfgSrvLogger::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClCfgSrvLogger::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    //
    // Need to use a critical section since we are using multiple variables.
    //
    EnterCriticalSection( sm_pcritsec );

    //
    // If the count will be reduced down to 1 and the interface has
    // been added to the GIT, then the only reference to this object
    // is from the GIT.  In this case, we want to the object to be
    // removed from the GIT and deleted.
    //

    if (    ( m_cRef == 2 )
        &&  ( sm_cookieGITLogger != 0 )
        &&  ( ! sm_fRevokingFromGIT ) )
    {
        //
        // Remove the interface from the GIT.
        // Indicate we are currently revoking from the GIT, then
        // exit the critical section so that we can be re-entered.
        //

        Assert( sm_pgit != NULL );
        sm_fRevokingFromGIT = true;
        LeaveCriticalSection( sm_pcritsec );

        THR( sm_pgit->RevokeInterfaceFromGlobal( sm_cookieGITLogger ) );

        EnterCriticalSection( sm_pcritsec );

        sm_fRevokingFromGIT = false;
        sm_cookieGITLogger = 0;

        sm_pgit->Release();
        sm_pgit = NULL;
    } // if: only the GIT holds a reference

    LeaveCriticalSection( sm_pcritsec );

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CClCfgSrvLogger::Release( )


//****************************************************************************
//
// ILogger
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClCfgSrvLogger::LogMsg(
//      LPCWSTR    pcszMsgIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClCfgSrvLogger::LogMsg(
    LPCWSTR pcszMsgIn
    )
{
    TraceFunc( "[ILogger]" );

    HRESULT     hr = S_OK;

    ::LogMsg( pcszMsgIn );

    HRETURN( hr );

} //*** CClCfgSrvLogger::LogMsg( )


//****************************************************************************
//
// Private Functions
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClCfgSrvLogger::S_HrGetLogger(
//      ILogger **  pplLoggerOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClCfgSrvLogger::S_HrGetLogger(
    ILogger **  pplLoggerOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    // Validate arguments.
    if ( pplLoggerOut == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // If the object has not been created yet, create one.
    // Otherwise, extract the interface from the GIT.
    //

    if ( sm_cookieGITLogger == 0 )
    {
        // Create a new object.
        hr = THR( CoCreateInstance(
                      CLSID_ClCfgSrvLogger
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    | CLSCTX_LOCAL_SERVER
                    , IID_ILogger
                    , reinterpret_cast< void ** >( pplLoggerOut )
                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        // Register this interface in the GIT.
        Assert( sm_pgit != NULL );
        hr = THR( sm_pgit->RegisterInterfaceInGlobal(
                              reinterpret_cast< IUnknown * >( *pplLoggerOut )
                            , IID_ILogger
                            , &sm_cookieGITLogger
                            ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: no object yet
    else
    {
        // Get the interface from the GIT.
        Assert( sm_pgit != NULL );
        hr = THR( sm_pgit->GetInterfaceFromGlobal(
                              sm_cookieGITLogger
                            , IID_ILogger
                            , reinterpret_cast< void ** >( pplLoggerOut )
                            ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // else: object already created

Cleanup:

    HRETURN( hr );

} //*** CClCfgSrvLogger::S_HrGetLogger( )


//****************************************************************************
//
// Global Functions
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClCfgSrvLogger::S_HrLogStatusReport(
//      LPCWSTR     pcszNodeNameIn,
//      CLSID       clsidTaskMajorIn,
//      CLSID       clsidTaskMinorIn,
//      ULONG       ulMinIn,
//      ULONG       ulMaxIn,
//      ULONG       ulCurrentIn,
//      HRESULT     hrStatusIn,
//      LPCWSTR     pcszDescriptionIn,
//      FILETIME *  pftTimeIn,
//      LPCWSTR     pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClCfgSrvLogger::S_HrLogStatusReport(
      ILogger *     plLogger
    , LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    FILETIME    ft;
    LPWSTR      psz         = NULL;
    BSTR        bstrLogMsg  = NULL;

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if: no file time specified

    //
    //  TODO:   21 NOV 2000 GalenB
    //
    //  Need to log the timestamp and reference params.
    //

    //
    //  Shorten the FDQN DNS name to only the hostname.
    //
    if ( pcszNodeNameIn != NULL )
    {
        psz = wcschr( pcszNodeNameIn, L'.' );
        if ( psz != NULL )
        {
            *psz = L'\0';
        } // if:
    } // if:

#define x "%1!ws!: %28!ws! (hr=0x%27!08x!,{%2!08X!-%3!04X!-%4!04X!-%5!02X!%6!02X!-%7!02X!%8!02X!%9!02X!%10!02X!%11!02X!%12!02X!},{%13!08X!-%14!04X!-%15!04X!-%16!02X!%17!02X!-%18!02X!%19!02X!%20!02X!%21!02X!%22!02X!%23!02X!},%24!u!,%25!u!,%26!u!), %29!ws!"

    hr = THR( HrFormatStringIntoBSTR(
                      g_hInstance
                    , IDS_FORMAT_LOG_MESSAGE
                    , &bstrLogMsg
                    , pcszNodeNameIn                // 1
                    , clsidTaskMajorIn.Data1        // 2
                    , clsidTaskMajorIn.Data2        // 3
                    , clsidTaskMajorIn.Data3        // 4
                    , clsidTaskMajorIn.Data4[ 0 ]   // 5
                    , clsidTaskMajorIn.Data4[ 1 ]   // 6
                    , clsidTaskMajorIn.Data4[ 2 ]   // 7
                    , clsidTaskMajorIn.Data4[ 3 ]   // 8
                    , clsidTaskMajorIn.Data4[ 4 ]   // 9
                    , clsidTaskMajorIn.Data4[ 5 ]   // 10
                    , clsidTaskMajorIn.Data4[ 6 ]   // 11
                    , clsidTaskMajorIn.Data4[ 7 ]   // 12
                    , clsidTaskMinorIn.Data1        // 13
                    , clsidTaskMinorIn.Data2        // 14
                    , clsidTaskMinorIn.Data3        // 15
                    , clsidTaskMinorIn.Data4[ 0 ]   // 16
                    , clsidTaskMinorIn.Data4[ 1 ]   // 17
                    , clsidTaskMinorIn.Data4[ 2 ]   // 18
                    , clsidTaskMinorIn.Data4[ 3 ]   // 19
                    , clsidTaskMinorIn.Data4[ 4 ]   // 20
                    , clsidTaskMinorIn.Data4[ 5 ]   // 21
                    , clsidTaskMinorIn.Data4[ 6 ]   // 22
                    , clsidTaskMinorIn.Data4[ 7 ]   // 23
                    , ulMinIn                       // 24
                    , ulMaxIn                       // 25
                    , ulCurrentIn                   // 26
                    , hrStatusIn                    // 27
                    , pcszDescriptionIn             // 28
                    , pcszReferenceIn               // 29
                    ) );

    //
    //  Restore the FQDN DNS name.
    //
    if ( psz != NULL )
    {
        *psz = L'.';
    }

    if ( hr == S_OK )
    {
        plLogger->LogMsg( bstrLogMsg );
    }

    TraceSysFreeString( bstrLogMsg );

    HRETURN( hr );

} //*** CClCfgSrvLogger::S_HrLogStatusReport( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\logmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      LogManager.cpp
//
//  Description:
//      Log Manager implementation.
//
//  Maintained By:
//      David Potter (DavidP)   07-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "Logger.h"
#include "LogManager.h"

DEFINE_THISCLASS("CLogManager")


//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CLogManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CLogManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT             hr;
    IServiceProvider *  psp;

    // Don't wrap - this can fail with E_POINTER.
    hr = CServiceManager::S_HrGetManagerPointer( &psp );

    if ( SUCCEEDED( hr ) )
    {
        hr = THR( psp->TypeSafeQS(
                          CLSID_LogManager
                        , IUnknown
                        , ppunkOut
                        ) );
        psp->Release( );

    } // if: service manager
    else if ( hr == E_POINTER )
    {
        //
        //  This happens when the Service Manager is first started.
        //
        CLogManager * plm = new CLogManager( );
        if ( plm != NULL )
        {
            hr = THR( plm->HrInit( ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( plm->TypeSafeQI( IUnknown, ppunkOut ) );
            } // if: success

            plm->Release( );

        } // if: got object
        else
        {
            hr = E_OUTOFMEMORY;
        }

    } // if: service manager doesn't exist
    else
    {
        THR( hr );
    } // else:

    HRETURN( hr );

} //*** CLogManager::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLogManager::CLogManager( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CLogManager::CLogManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_plLogger == NULL );
    Assert( m_cookieCompletion == 0 );
    Assert( m_hrResult == S_OK );
    Assert( m_bstrLogMsg == NULL );
    Assert( m_pcpcb == NULL );
    Assert( m_dwCookieCallback == NULL );

    TraceFuncExit();

} //*** CLogManager::CLogManager( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CLogManager::HrInit( )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    HRETURN( hr );

} //*** CLogManager::HrInit( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLogManager::~CLogManager( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CLogManager::~CLogManager( void )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( m_cRef == 0 );

    // Unadvise the IConnectionPoint interface.
    if ( m_dwCookieCallback != 0 )
    {
        Assert( m_pcpcb != NULL );
        hr = THR( m_pcpcb->Unadvise( m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            //goto Cleanup;
        }

        m_dwCookieCallback = 0;
    }

    // Release the IConnectionPoint interface.
    if ( m_pcpcb != NULL )
    {
        Assert( m_dwCookieCallback == 0 );
        m_pcpcb->Release();
        m_pcpcb = NULL;
    }

    // Release the ILogger interface.
    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
        m_plLogger = NULL;
    }

    // Decrement the global count of objects.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CLogManager::~CLogManager( )


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CLogManager::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ILogManager * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ILogManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ILogManager, this, 0 );
    } // else if: ILogManager
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
    } // else if: IClusCfgCallback
    else
    {
        hr = E_NOINTERFACE;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CLogManager::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CLogManager::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CLogManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CLogManager::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CLogManager::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CLogManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CLogManager::Release( )


//****************************************************************************
//
// ILogManager
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CLogManager::StartLogging( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::StartLogging( void )
{
    TraceFunc( "[ILogManager]" );

    HRESULT                     hr;
    IServiceProvider *          psp = NULL;
    IConnectionPointContainer * pcpc = NULL;
    DWORD                       cookieGITLogger;

    //
    // Get a ClCfgSrv ILogger instance.
    //
    hr = CClCfgSrvLogger::S_HrGetLogger( &m_plLogger );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // If not done already, get the connection point.
    //

    if ( m_pcpcb == NULL )
    {
        hr = THR( CServiceManager::S_HrGetManagerPointer( &psp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS(
                          CLSID_NotificationManager
                        , IConnectionPointContainer
                        , &pcpc
                        ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint(
                              IID_IClusCfgCallback
                            , &m_pcpcb
                            ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: connection point callback not retrieved yet

    //
    //  Register to get notification (if needed)
    //

    if ( m_dwCookieCallback == 0 )
    {
        hr = THR( m_pcpcb->Advise( static_cast< IClusCfgCallback * >( this ), &m_dwCookieCallback ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: advise cookie not retrieved yet

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( pcpc != NULL )
    {
        pcpc->Release( );
    }

    HRETURN( hr );

} //*** CLogManager::StartLogging( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CLogManager::StopLogging( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::StopLogging( void )
{
    TraceFunc( "[ILogManager]" );

    HRESULT     hr = S_OK;

    // Unadvise the IConnectionPoint interface.
    if ( m_dwCookieCallback != 0 )
    {
        Assert( m_pcpcb != NULL );
        hr = THR( m_pcpcb->Unadvise( m_dwCookieCallback ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_dwCookieCallback = 0;
    }

    // Release the IConnectionPoint interface.
    if ( m_pcpcb != NULL )
    {
        Assert( m_dwCookieCallback == 0 );
        m_pcpcb->Release();
        m_pcpcb = NULL;
    }

    // Release the ILogger interface.
    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
        m_plLogger = NULL;
    }

Cleanup:

    HRETURN( hr );

} //*** CLogManager::StopLogging( )


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CLogManager::SendStatusReport(
//      LPCWSTR     pcszNodeNameIn,
//      CLSID       clsidTaskMajorIn,
//      CLSID       clsidTaskMinorIn,
//      ULONG       ulMinIn,
//      ULONG       ulMaxIn,
//      ULONG       ulCurrentIn,
//      HRESULT     hrStatusIn,
//      LPCWSTR     pcszDescriptionIn,
//      FILETIME *  pftTimeIn,
//      LPCWSTR     pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLogManager::SendStatusReport(
    LPCWSTR     pcszNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    LPCWSTR     pcszDescriptionIn,
    FILETIME *  pftTimeIn,
    LPCWSTR     pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    hr = THR( CClCfgSrvLogger::S_HrLogStatusReport(
                      m_plLogger
                    , pcszNodeNameIn
                    , clsidTaskMajorIn
                    , clsidTaskMinorIn
                    , ulMinIn
                    , ulMaxIn
                    , ulCurrentIn
                    , hrStatusIn
                    , pcszDescriptionIn
                    , pftTimeIn
                    , pcszReferenceIn
                    ) );

    HRETURN( hr );

} //*** CLogManager::SendStatusReport( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\ipaddressinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      IPAddressInfo.h
//
//  Description:
//      This file contains the declaration of the CIPAddressInfo
//      class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

class CEnumIPAddresses;

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CIPAddressInfo
//
//  Description:
//      The class IPAddressInfo is the enumeration of
//      cluster manageable devices.
//
//  Interfaces:
//      IClusCfgIPAddressInfo
//      IGatherData
//      IExtendObjectManager
//
//--
//////////////////////////////////////////////////////////////////////////////
class CIPAddressInfo
    : public IExtendObjectManager
    , public IClusCfgIPAddressInfo
    , public IGatherData // private
{
friend class CEnumIPAddresses;
public:
    //
    // Public constructors and destructors
    //

    CIPAddressInfo( void );
    virtual ~CIPAddressInfo( void );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IGatherData
    //

    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    //
    // IClusCfgIPAddressInfo Interfaces.
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetIPAddress )( ULONG ulDottedQuad );

    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuad );

    // IObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

private:
    //
    // Private member functions and data
    //

    LONG                    m_cRef;
    ULONG                   m_ulIPAddress;
    ULONG                   m_ulIPSubnet;
    BSTR                    m_bstrUID;
    BSTR                    m_bstrName;

    // IExtendObjectManager

    // Private copy constructor to prevent copying.
    CIPAddressInfo( const CIPAddressInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CIPAddressInfo & operator = ( const CIPAddressInfo & nodeSrc );

    STDMETHOD( HrInit )( void );
    STDMETHOD( LoadName )( void );

}; //*** Class CIPAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\logmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      LogManager.h
//
//  Description:
//      Log Manager implementation.
//
//  Maintained By:
//      David Potter (DavidP)   07-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Forward Class Definitions
//////////////////////////////////////////////////////////////////////////////

class CLogManager;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CLogManager
//
//  Description:
//      Logs notifications to the log file.
//
//--
//////////////////////////////////////////////////////////////////////////////
class
CLogManager:
    public ILogManager,
    public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;                 // Reference counter.

    // ILogManager
    ILogger *           m_plLogger;             // ILogger for doing logging.

    // IClusCfgCallback
    OBJECTCOOKIE        m_cookieCompletion;     // Completion cookie.
    HRESULT             m_hrResult;             // Result of the analyze task.
    BSTR                m_bstrLogMsg;           // Reusable logging buffer.
    IConnectionPoint *  m_pcpcb;                // IClusCfgCallback Connection Point.
    DWORD               m_dwCookieCallback;     // Notification registration cookie.

private: // Methods
    CLogManager( void );
    ~CLogManager( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // ILogManager
    STDMETHOD( StartLogging )( void );
    STDMETHOD( StopLogging )( void );

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
          LPCWSTR       pcszNodeNameIn
        , CLSID         clsidTaskMajorIn
        , CLSID         clsidTaskMinorIn
        , ULONG         ulMinIn
        , ULONG         ulMaxIn
        , ULONG         ulCurrentIn
        , HRESULT       hrStatusIn
        , LPCWSTR       pcszDescriptionIn
        , FILETIME *    pftTimeIn
        , LPCWSTR       pcszReferenceIn
        );

}; //*** class CLogManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\manageddevice.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ManagedDevice.cpp
//
//  Description:
//      CManagedDevice implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ManagedDevice.h"

DEFINE_THISCLASS("CManagedDevice")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CManagedDevice::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CManagedDevice::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CManagedDevice * pmd = new CManagedDevice;
    if ( pmd != NULL )
    {
        hr = THR( pmd->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pmd->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pmd->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} //*** CManagedDevice::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedDevice::CManagedDevice( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CManagedDevice::CManagedDevice( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CManagedDevice::CManagedDevice( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::Init( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IClusCfgManagedResourceInfo
    Assert( m_bstrUID == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_fHasNameChanged == FALSE );
    Assert( m_bstrType == NULL );
    Assert( m_fIsManaged == FALSE );
    Assert( m_fIsQuorumDevice == FALSE );
    Assert( m_fIsQuorumCapable == FALSE );
    Assert( m_fIsQuorumJoinable == FALSE );
    Assert( m_dlmDriveLetterMapping.dluDrives[ 0 ] = dluUNUSED );

    // IExtendObjectManager

    HRETURN( hr );

} //*** CManagedDevice::Init( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedDevice::~CManagedDevice( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CManagedDevice::~CManagedDevice( void )
{
    TraceFunc( "" );

    if ( m_bstrUID != NULL )
    {
        TraceSysFreeString( m_bstrUID );
    }

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    if ( m_bstrType != NULL )
    {
        TraceSysFreeString( m_bstrType );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CManagedDevice::~CManagedDevice( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgManagedResourceInfo * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgManagedResourceInfo
    else if ( IsEqualIID( riidIn, IID_IGatherData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
        hr = S_OK;
    } // else if: IGatherData
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
        hr = S_OK;
    } // else if: IGatherData

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CManagedDevice::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CManagedDevice::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CManagedDevice::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CManagedDevice::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CManagedDevice::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CManagedDevice::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} //*** CManagedDevice::Release( )


// ************************************************************************
//
// IClusCfgManagedResourceInfo
//
// ************************************************************************


///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::GetUID(
//      BSTR * pbstrUIDOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
        goto InvalidPointer;

    if ( m_bstrUID == NULL )
        goto UnexpectedError;

    *pbstrUIDOut = SysAllocString( m_bstrUID );
    if ( *pbstrUIDOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedError:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CManagedDevice::GetUID( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::GetName(
//      BSTR * pbstrNameOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    if ( m_bstrName == NULL )
        goto UnexpectedError;

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedError:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CManagedDevice::GetName( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::SetName(
//      BSTR bstrNameIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ws'", ( pcszNameIn == NULL ? L"<null>" : pcszNameIn ) );

    HRESULT hr = S_OK; // Bug #294649
    BSTR    bstrNewName;

    if ( pcszNameIn == NULL )
        goto InvalidArg;

    bstrNewName = TraceSysAllocString( pcszNameIn );
    if ( bstrNewName == NULL )
        goto OutOfMemory;

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_bstrName = bstrNewName;
    m_fHasNameChanged = TRUE;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CManagedDevice::SetName( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::IsManaged( void )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedDevice::IsManaged( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::SetManaged(
//      BOOL fIsManagedIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::SetManaged(
    BOOL fIsManagedIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] fIsManagedIn = '%s'", BOOLTOSTRING( fIsManagedIn ) );

    m_fIsManaged = fIsManagedIn;

    HRETURN( S_OK );

} //*** CManagedDevice::SetManaged( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::IsQuorumDevice( void )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::IsQuorumDevice( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsQuorumDevice )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedDevice::IsQuorumDevice( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::SetQuorumedDevice(
//      BOOL fIsQuorumDeviceIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::SetQuorumedDevice(
    BOOL fIsQuorumDeviceIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] fIsQuorumDeviceIn = '%s'", BOOLTOSTRING( fIsQuorumDeviceIn ) );

    m_fIsQuorumDevice = fIsQuorumDeviceIn;

    HRETURN( S_OK );

} //*** CManagedDevice::SetQuorumedDevice( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::IsQuorumCapable( void )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsQuorumCapable )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedDevice::IsQuorumCapable( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::GetDriveLetterMappings(
//      SDriveLetterMapping * pdlmDriveLetterMappingOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    *pdlmDriveLetterMappingOut = m_dlmDriveLetterMapping;

    HRETURN( S_OK );

} //*** CManagedDevice::GetDriveLetterMappings( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::SetDriveLetterMappings(
//      SDriveLetterMapping dlmDriveLetterMappingIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_dlmDriveLetterMapping = dlmDriveLetterMappingIn;

    HRETURN( S_OK );

} //*** CManagedDevice::SetDriveLetterMappings( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::IsDeviceJoinable( void )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::IsDeviceJoinable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_fIsQuorumJoinable )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedDevice::IsDeviceJoinable( )


///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::SetDeviceJoinable( void )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::SetDeviceJoinable( BOOL fIsJoinableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CManagedDevice::SetDeviceJoinable( )

//****************************************************************************
//
//  IGatherData
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedDevice::Gather(
//      OBJECTCOOKIE    cookieParentIn,
//      IUnknown *      punkIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT hr;

    BSTR    bstr = NULL;

    IClusCfgManagedResourceInfo * pccmri = NULL;

    //
    //  Check parameters
    //

    if ( punkIn == NULL )
        goto InvalidArg;

    //
    //  Find the inteface we need to gather our info.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgManagedResourceInfo, &pccmri ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Gather UID
    //

    hr = THR( pccmri->GetUID( &m_bstrUID ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrUID );

    //
    //  Gather Name
    //

    hr = THR( pccmri->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrName );

    //
    //  Gather IsManaged
    //

    hr = STHR( pccmri->IsManaged( ) );
    if ( FAILED( hr ) )
        goto Error;

    if ( hr == S_OK )
    {
        m_fIsManaged = TRUE;
    }
    else
    {
        m_fIsManaged = FALSE;
    }

    //
    //  Gather Quorum Capable
    //

    hr = STHR( pccmri->IsQuorumCapable( ) );
    if ( FAILED( hr ) )
        goto Error;

    if ( hr == S_OK )
    {
        m_fIsQuorumCapable = TRUE;
    }
    else
    {
        m_fIsQuorumCapable = FALSE;
    }

    //
    // If the device is quorumable, does it allow joins.
    //
    if(m_fIsQuorumCapable)
    {
        hr = STHR( pccmri->IsDeviceJoinable( ) );
        if( FAILED( hr ) )
            goto Error;

        if( hr == S_OK )
        {
            m_fIsQuorumJoinable = TRUE;
        }
        else
        {
            m_fIsQuorumJoinable = FALSE;
        }
    }
    else
    {
        m_fIsQuorumJoinable = FALSE;
    }

    //
    //  Gather if resource is the quorum resource.
    //

    hr = STHR( pccmri->IsQuorumDevice( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( hr == S_OK )
    {
        m_fIsQuorumDevice = TRUE;
    }
    else
    {
        m_fIsQuorumDevice = FALSE;
    }

    //
    //  Gather Device Mappings
    //

    hr = STHR( pccmri->GetDriveLetterMappings( &m_dlmDriveLetterMapping ) );
    if ( FAILED( hr ) )
        goto Error;

    if ( hr == S_FALSE )
    {
        //  Make sure this is nuked
        ZeroMemory( &m_dlmDriveLetterMapping, sizeof(m_dlmDriveLetterMapping) );
    }

    //
    //  Anything else to gather??
    //

    hr = S_OK;

Cleanup:
    if ( pccmri != NULL )
    {
        pccmri->Release( );
    }

    HRETURN( hr );

Error:
    //
    //  On error, invalidate all data.
    //
    if ( m_bstrUID != NULL )
    {
        TraceSysFreeString( m_bstrUID );
        m_bstrUID = NULL;
    }
    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
        m_bstrName = NULL;
    }
    if ( m_bstrType != NULL )
    {
        TraceSysFreeString( m_bstrType );
        m_bstrType = NULL;
    }
    m_fIsManaged = FALSE;
    m_fIsQuorumCapable = FALSE;
    m_fIsQuorumJoinable = FALSE;
    m_fIsQuorumDevice = FALSE;
    ZeroMemory( &m_dlmDriveLetterMapping, sizeof( m_dlmDriveLetterMapping ) );
    goto Cleanup;

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CManagedDevice::Gather( )


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
// STDMETHODIMP
// CManagedDevice::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedDevice::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = E_UNEXPECTED;

    //
    //  Validate arguments.
    //

    if ( cookieIn == 0 )
        goto InvalidArg;

    if ( rclsidTypeIn != CLSID_ManagedResourceType )
        goto InvalidArg;

    if ( pcszNameIn == NULL )
        goto InvalidArg;

    if ( ppunkOut == NULL )
        goto InvalidPointer;

    hr = THR( QueryInterface( DFGUID_ManagedResource,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CManagedDevice::FindObject( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\managednetwork.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ManagedNetwork.h
//
//  Description:
//      CManagedNetwork implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumManageableNetworks;

// CManagedNetwork
class
CManagedNetwork:
    public IExtendObjectManager,
    public IClusCfgNetworkInfo,
    public IEnumClusCfgIPAddresses,
    public IGatherData  // Private Interface
{
friend class CEnumManageableNetworks;
private:
    // IUnknown
    LONG                m_cRef;

    // Async/IClusCfgNetworkInfo
    BOOL                m_fGathered:1;                  // TRUE if the object has already gathered its information
    BSTR                m_bstrUID;                      // Unique Identifier
    BSTR                m_bstrName;                     // Display Name
    BOOL                m_fHasNameChanged:1;            // If the name was changed by the user....
    BSTR                m_bstrDescription;              // Description
    BOOL                m_fHasDescriptionChanged:1;     // If the description was changed by the user...
    BOOL                m_fIsPublic:1;                  // If the interface is for public traffic...
    BOOL                m_fIsPrivate:1;                 // If the interface is for private traffic...
    IUnknown *          m_punkPrimaryAddress;           // Primary IP address info.
    ULONG               m_cAllocedIPs;                  //  Count of allocated IPs
    ULONG               m_cCurrentIPs;                  //  Count of currently used IPs
    ULONG               m_cIter;                        //  Iter counter
    IUnknown **         m_ppunkIPs;                     //  List of child IP addresses

    // IExtendObjectManager

private: // Methods
    CManagedNetwork( );
    ~CManagedNetwork();
    STDMETHOD( Init )( void );
    STDMETHOD( EnumChildrenAndTransferInformation )( OBJECTCOOKIE cookieIn, IEnumClusCfgIPAddresses * pecciaIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgNetworkInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( GetDescription )( BSTR * pbstrDescriptionOut );
    STDMETHOD( SetDescription )( LPCWSTR pcszDescriptionIn );
    STDMETHOD( GetPrimaryNetworkAddress )( IClusCfgIPAddressInfo ** ppIPAddressOut );
    STDMETHOD( SetPrimaryNetworkAddress )( IClusCfgIPAddressInfo * pIPAddressIn );
    STDMETHOD( IsPublic )( void );
    STDMETHOD( SetPublic )( BOOL fIsPublicIn );
    STDMETHOD( IsPrivate )( void );
    STDMETHOD( SetPrivate )( BOOL fIsPrivateIn );

    // IGatherData
    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

    // IEnumClusCfgIPAddresses
    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgIPAddressInfo ** rgpIPAddressInfoOut, ULONG * pcNumberFetchedOut );
    STDMETHOD( Skip )( ULONG cNumberToSkipIn );
    STDMETHOD( Reset )( void );
    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

}; // class CManagedNetwork
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\managednetwork.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ManagedNetwork.cpp
//
//  Description:
//      CManagedNetwork implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-NOV-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "IPAddressInfo.h"
#include "ManagedNetwork.h"

DEFINE_THISCLASS("CManagedNetwork")

#define IPADDRESS_INCREMENT 10

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CManagedNetwork::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CManagedNetwork::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CManagedNetwork * pmn = new CManagedNetwork;
    if ( pmn != NULL )
    {
        hr = THR( pmn->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pmn->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pmn->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} //*** CManagedNetwork::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedNetwork::CManagedNetwork( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CManagedNetwork::CManagedNetwork( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CManagedNetwork::CManagedNetwork( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Init( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // Async/IClusCfgNetworkInfo
    Assert( m_bstrUID == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_fHasNameChanged == FALSE );
    Assert( m_bstrDescription == NULL );
    Assert( m_fHasDescriptionChanged == FALSE );
    Assert( m_fIsPublic == FALSE );
    Assert( m_fIsPrivate == FALSE );
    Assert( m_punkPrimaryAddress == NULL );

    // IExtendObjectManager

    HRETURN( hr );

} //*** CManagedNetwork::Init( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CManagedNetwork::~CManagedNetwork( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CManagedNetwork::~CManagedNetwork( void )
{
    TraceFunc( "" );

    if ( m_ppunkIPs != NULL )
    {
        while ( m_cCurrentIPs != 0 )
        {
            m_cCurrentIPs --;
            Assert( m_ppunkIPs[ m_cCurrentIPs ] != NULL );
            if ( m_ppunkIPs[ m_cCurrentIPs ] != NULL )
            {
                m_ppunkIPs[ m_cCurrentIPs ]->Release( );
            }
        }

        TraceFree( m_ppunkIPs );
    }

    if ( m_punkPrimaryAddress != NULL )
    {
        m_punkPrimaryAddress->Release();
    } // if:

    TraceSysFreeString( m_bstrUID );
    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrDescription );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CManagedNetwork::~CManagedNetwork( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgNetworkInfo * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgNetworkInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgNetworkInfo, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgNetworkInfo
    else if ( IsEqualIID( riidIn, IID_IGatherData ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
        hr = S_OK;
    } // else if: IGatherData
    else if ( IsEqualIID( riidIn, IID_IExtendObjectManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
        hr = S_OK;
    } // else if: IExtendObjectManager
    else if ( IsEqualIID( riidIn, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
        hr = S_OK;
    } // else if: IEnumClusCfgIPAddresses

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CManagedNetwork::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CManagedNetwork::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CManagedNetwork::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CManagedNetwork::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CManagedNetwork::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CManagedNetwork::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} //*** CManagedNetwork::Release( )


// ************************************************************************
//
// IClusCfgNetworkInfo
//
// ************************************************************************


///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::GetUID(
//      BSTR * pbstrUIDOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
        goto InvalidPointer;

    if ( m_bstrUID == NULL )
        goto UnexpectedError;

    *pbstrUIDOut = SysAllocString( m_bstrUID );
    if ( *pbstrUIDOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedError:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CManagedNetwork::GetUID( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::GetName(
//      BSTR * pbstrNameOut
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    if ( m_bstrName == NULL )
        goto UnexpectedError;

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedError:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CManagedNetwork::GetName( )

///////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::SetName(
//      LPCWSTR pcszNameIn
//      )
//
//--
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszNameIn = '%ws'", ( pcszNameIn == NULL ? L"<null>" : pcszNameIn ) );

    HRESULT hr = S_OK;
    BSTR    bstrNewName;

    if ( pcszNameIn == NULL )
        goto InvalidArg;

    bstrNewName = TraceSysAllocString( pcszNameIn );
    if ( bstrNewName == NULL )
        goto OutOfMemory;

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_bstrName = bstrNewName;
    m_fHasNameChanged = TRUE;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CManagedNetwork::SetName( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::GetDescription(
//      BSTR * pbstrDescriptionOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::GetDescription(
    BSTR * pbstrDescriptionOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;

    if ( pbstrDescriptionOut == NULL )
        goto InvalidPointer;

    if ( m_bstrDescription == NULL )
        goto UnexpectedError;

    *pbstrDescriptionOut = SysAllocString( m_bstrDescription );
    if ( *pbstrDescriptionOut == NULL )
        goto OutOfMemory;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedError:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CManagedNetwork::GetDescription( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::SetDescription(
//      LPCWSTR pcszDescriptionIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetDescription(
    LPCWSTR pcszDescriptionIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszNameIn = '%ws'", ( pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn ) );

    HRESULT hr = S_OK;
    BSTR    bstrNewDescription;

    if ( pcszDescriptionIn == NULL )
        goto InvalidArg;

    bstrNewDescription = TraceSysAllocString( pcszDescriptionIn );
    if ( bstrNewDescription == NULL )
        goto OutOfMemory;

    if ( m_bstrDescription != NULL )
    {
        TraceSysFreeString( m_bstrDescription );
    }

    m_bstrDescription = bstrNewDescription;
    m_fHasDescriptionChanged = TRUE;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
} //*** CManagedNetwork::SetDescription( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgNetworkInfo::GetPrimaryNetworkAddress()
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::GetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo ** ppIPAddressOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkPrimaryAddress != NULL );

    HRESULT hr;

    if ( ppIPAddressOut == NULL )
    {
        hr = THR( E_POINTER );
    } // if:
    else
    {
        hr = THR( m_punkPrimaryAddress->TypeSafeQI( IClusCfgIPAddressInfo, ppIPAddressOut ) );
    } // else:

    HRETURN( hr );

} //*** CManagedNetwork::GetPrimaryNetworkAddress()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgNetworkInfo::SetPrimaryNetworkAddress()
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo * pIPAddressIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CManagedNetwork::SetPrimaryNetworkAddress()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::IsPublic( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::IsPublic( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;

    if ( m_fIsPublic )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedNetwork::IsPublic( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::SetPublic(
//      BOOL fIsPublicIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetPublic(
    BOOL fIsPublicIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] fIsPublic = %s", BOOLTOSTRING( fIsPublicIn ) );

    HRESULT hr = S_OK;

    m_fIsPublic = fIsPublicIn;

    HRETURN( hr );

} //*** CManagedNetwork::SetPublic( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::IsPrivate( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::IsPrivate( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;

    if ( m_fIsPrivate )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedNetwork::IsPrivate( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::SetPrivate(
//      BOOL fIsPrivateIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::SetPrivate(
    BOOL fIsPrivateIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] fIsPrivate = %s", BOOLTOSTRING( fIsPrivateIn ) );

    HRESULT hr = S_OK;

    m_fIsPrivate = fIsPrivateIn;

    HRETURN( hr );

} //*** CManagedNetwork::SetPrivate( )


//****************************************************************************
//
//  IGatherData
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Gather(
//      OBJECTCOOKIE    cookieParentIn,
//      IUnknown *      punkIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT hr;

    IUnknown *                  punk = NULL;
    IClusCfgNetworkInfo *       pccni = NULL;
    IEnumClusCfgIPAddresses *   peccia = NULL;
    IObjectManager *            pom = NULL;
    OBJECTCOOKIE                cookie;
    IServiceProvider *          psp = NULL;
    IGatherData *               pgd = NULL;
    IClusCfgIPAddressInfo *     piccipai = NULL;

    //
    //  Make sure we don't "gather" the same object twice.
    //

    if ( m_fGathered )
        goto UnexpectedError;

    //
    //  Check parameters.
    //

    if ( punkIn == NULL )
        goto InvalidArg;

    //
    //  Gather the information.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgNetworkInfo, &pccni ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Gather UID
    //

    hr = THR( pccni->GetUID( &m_bstrUID ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrUID );

    //
    //  Gather Name
    //

    hr = THR( pccni->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrName );

    //
    //  Gather Description
    //

    hr = THR( pccni->GetDescription( &m_bstrDescription ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrDescription );

    //
    //  Gather IsPrivate
    //

    hr = STHR( pccni->IsPrivate( ) );
    if ( FAILED( hr ) )
        goto Error;

    if ( hr == S_OK )
    {
        m_fIsPrivate = TRUE;
    }
    else
    {
        m_fIsPrivate = FALSE;
    }

    //
    //  Gather IsPublic
    //

    hr = STHR( pccni->IsPublic( ) );
    if ( FAILED( hr ) )
        goto Error;

    if ( hr == S_OK )
    {
        m_fIsPublic = TRUE;
    }
    else
    {
        m_fIsPublic = FALSE;
    }

    //
    //
    //  If the parent cookie is ZERO, then we don't grab the secondary IP
    //  address information.
    //

    if ( cookieParentIn != 0 )
    {
        //  Gather the IP Addresses
        //

        hr = THR( punkIn->TypeSafeQI( IEnumClusCfgIPAddresses, &peccia ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Gather the object manager.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                                   IObjectManager,
                                   &pom
                                   ) );
        psp->Release( );        // release promptly
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pom->FindObject( CLSID_NetworkType,
                                   cookieParentIn,
                                   m_bstrUID,
                                   IID_NULL,
                                   &cookie,
                                   &punk // dummy
                                   ) );
        Assert( punk == NULL );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( EnumChildrenAndTransferInformation( cookie, peccia ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    //
    //  Gather Primary Network Address
    //

    hr = THR( pccni->GetPrimaryNetworkAddress( &piccipai ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( CIPAddressInfo::S_HrCreateInstance( &m_punkPrimaryAddress ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_punkPrimaryAddress->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pgd->Gather( cookieParentIn, piccipai ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Anything else to gather??
    //

    hr = S_OK;
    m_fGathered = TRUE;

Cleanup:
    if ( pgd != NULL )
    {
        pgd->Release();
    } // if:
    if ( piccipai != NULL )
    {
        piccipai->Release();
    } // if:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( peccia != NULL )
    {
        peccia->Release();
    } // if:
    if ( pccni != NULL )
    {
        pccni->Release( );
    }

    HRETURN( hr );

Error:
    //
    //  On error, invalidate all data.
    //
    if ( m_bstrUID != NULL )
    {
        TraceSysFreeString( m_bstrUID );
        m_bstrUID = NULL;
    }
    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
        m_bstrName = NULL;
    }
    if ( m_bstrDescription != NULL )
    {
        TraceSysFreeString( m_bstrDescription );
        m_bstrDescription = NULL;
    }
    m_fIsPrivate = FALSE;
    m_fIsPublic = FALSE;
    goto Cleanup;

UnexpectedError:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;   // don't cleanup the object.

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CManagedNetwork::Gather( )


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
// STDMETHODIMP
// CManagedNetwork::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters.
    //

    //  We need a cookie.
    if ( cookieIn == NULL )
        goto InvalidArg;

    //  We need to be representing a NetworkType
    if ( !IsEqualIID( rclsidTypeIn, CLSID_NetworkType ) )
        goto InvalidArg;

    //  We need to have a name.
    if ( pcszNameIn == NULL )
        goto InvalidArg;

    hr = THR( QueryInterface( DFGUID_NetworkResource,
                              reinterpret_cast< void ** >( ppunkOut )
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CManagedNetwork::FindObject( )


// ************************************************************************
//
//  Private methods.
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::EnumChildrenAndTransferInformation(
//      IEnumClusCfgIPAddresses * pecciaIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::EnumChildrenAndTransferInformation(
    OBJECTCOOKIE                cookieIn,
    IEnumClusCfgIPAddresses *   pecciaIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IClusCfgIPAddressInfo * pccipai = NULL;
    ULONG                   cFetched;
    IGatherData *           pgd = NULL;
    IUnknown *              punk = NULL;
    DWORD                   cIPs = 0;

    Assert( m_ppunkIPs == NULL );
    Assert( m_cCurrentIPs == 0 );
    Assert( m_cAllocedIPs == 0 );

    hr = THR( pecciaIn->Count( &cIPs ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( cIPs > 0 )
    {
        m_ppunkIPs = (IUnknown **) TraceAlloc( HEAP_ZERO_MEMORY, cIPs * sizeof(IUnknown *) );
        if ( m_ppunkIPs == NULL )
            goto OutOfMemory;
    }

    m_cAllocedIPs = cIPs;

    for ( m_cCurrentIPs = 0 ; m_cCurrentIPs < m_cAllocedIPs ; m_cCurrentIPs += 1 )
    {
        //
        //  Grab the next address.
        //

        hr = STHR( pecciaIn->Next( 1, &pccipai, &cFetched ) );
        if (FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            break;  // exit condition

        Assert( cFetched == 1 );

        //
        //  Create a new IP Address object.
        //

        hr = THR( CIPAddressInfo::S_HrCreateInstance( &punk ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Retrieve the information.
        //

        hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pgd->Gather( cookieIn, pccipai ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Place it in the array.
        //

        m_ppunkIPs[ m_cCurrentIPs ] = punk;
        punk = NULL; // not released because it's now in the m_ppunkIPs array

        //
        //  Release temporary objects.
        //
        pgd->Release( );
        pgd = NULL;

        pccipai->Release( );
        pccipai = NULL;
    } // for:

    m_cIter = 0;

    hr = S_OK;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    } // if:
    if ( pgd != NULL )
    {
        pgd->Release();
    } // if:
    if ( pccipai != NULL )
    {
        pccipai->Release( );
    }

    HRETURN( hr );

OutOfMemory:
    hr = THR( E_OUTOFMEMORY );
    goto Cleanup;

} //*** CManagedNetwork::EnumChildrenAndTransferInformation( )


//****************************************************************************
//
//  IEnumClusCfgIPAddresses
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Next(
//      ULONG                       celt,
//      IClusCfgIPAddressInfo **    rgOut,
//      ULONG *                     pceltFetchedOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Next(
    ULONG                       celt,
    IClusCfgIPAddressInfo **    rgOut,
    ULONG *                     pceltFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    ULONG   celtFetched;

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters
    //

    if ( rgOut == NULL || celt == 0 )
        goto InvalidPointer;

    //
    //  Zero the return count.
    //

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = 0;
    }

    //
    //  Clear the buffer
    //

    ZeroMemory( rgOut, celt * sizeof(rgOut[0]) );

    //
    //  Loop thru copying the interfaces.
    //

    for( celtFetched = 0
       ; celtFetched + m_cIter < m_cCurrentIPs && celtFetched < celt
       ; celtFetched ++
       )
    {
        hr = THR( m_ppunkIPs[ m_cIter + celtFetched ]->TypeSafeQI( IClusCfgIPAddressInfo, &rgOut[ celtFetched ] ) );
        if ( FAILED( hr ) )
            goto CleanupList;

    } // for: celtFetched

    if ( pceltFetchedOut != NULL )
    {
        *pceltFetchedOut = celtFetched;
    }

    m_cIter += celtFetched;

    if ( celtFetched != celt )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

CleanupList:
    for ( ; celtFetched != 0 ; )
    {
        celtFetched --;
        rgOut[ celtFetched ]->Release( );
        rgOut[ celtFetched ] = NULL;
    }
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CManagedNetwork::Next( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Skip(
//      ULONG cNumberToSkipIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Skip(
    ULONG cNumberToSkipIn
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_cIter += cNumberToSkipIn;

    if ( m_cIter >= m_cCurrentIPs )
    {
        m_cIter = m_cCurrentIPs;
        hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CManagedNetwork::Skip( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Reset( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_cIter = 0;

    HRETURN( hr );

} //*** CManagedNetwork::Reset( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CManagedNetwork::Clone(
//      IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Clone(
    IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    //
    //  KB: GPease  31-JUL-2000
    //      Not going to implement this.
    //
    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CManagedNetwork::Clone( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CManagedNetwork::Count(
//      DWORD * pnCountOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CManagedNetwork::Count(
    DWORD * pnCountOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cCurrentIPs;

Cleanup:
    HRETURN( hr );
}// Count( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\manageddevice.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ManagedDevice.h
//
//  Description:
//      CManagedDevice implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumManageableResources;

class
CManagedDevice:
    public IExtendObjectManager,
    public IClusCfgManagedResourceInfo,
    public IGatherData  // Private Interface
{
friend class CEnumManageableResources;
private:
    // IUnknown
    LONG                m_cRef;

    // Async/IClusCfgManagedResourceInfo
    BSTR                m_bstrUID;                      // Unique Identifier
    BSTR                m_bstrName;                     // Display Name
    BOOL                m_fHasNameChanged:1;            // Indicates the user changed the name
    BSTR                m_bstrType;                     // Display Type Name
    BOOL                m_fIsManaged:1;                 // If the user wants to manage this device...
    BOOL                m_fIsQuorumDevice:1;            // If the user wants this device to be the quorum...
    BOOL                m_fIsQuorumCapable:1;           // If the device supports quorum...
    BOOL                m_fIsQuorumJoinable:1;          // Does the quorum capable device allow join.
    SDriveLetterMapping m_dlmDriveLetterMapping;        // Drive letter representations hosted on this device.

    // IExtendObjectManager

private: // Methods
    CManagedDevice( );
    ~CManagedDevice();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgManagedResourceInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( IsManaged )( void );
    STDMETHOD( SetManaged )( BOOL fIsManagedIn );
    STDMETHOD( IsQuorumDevice )( void );
    STDMETHOD( SetQuorumedDevice )( BOOL fIsQuorumDeviceIn );
    STDMETHOD( IsQuorumCapable )( void );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingsOut );
    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappingsIn );
    STDMETHOD( IsDeviceJoinable )( void );
    STDMETHOD( SetDeviceJoinable )( BOOL fIsJoinableIn );

    // IGatherData
    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    // IExtendOjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; // class CManagedDevice
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\middletierguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      MiddleTierGuids.h
//
//  Description:
//      This file contains the guids used in MiddleTier.
//
//  Documentation:
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-FEB-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <InitGuid.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


// {6803B9B3-05D1-41ac-89FB-AF98854FD9CC}
DEFINE_GUID( CLSID_ClusterCompletionCookie,
0x6803b9b3, 0x5d1, 0x41ac, 0x89, 0xfb, 0xaf, 0x98, 0x85, 0x4f, 0xd9, 0xcc);

// {342EAA5D-EF9E-49de-8A14-5E5463401020}
DEFINE_GUID( TASKID_Minor_BeginTask_CoCreate_Service_Manager,
0x342eaa5d, 0xef9e, 0x49de, 0x8a, 0x14, 0x5e, 0x54, 0x63, 0x40, 0x10, 0x20);

// {B798626A-CCE5-4403-9E89-714036AA7C6A}
DEFINE_GUID( TASKID_Minor_BeginTask_QueryService_Notification_Manager,
0xb798626a, 0xcce5, 0x4403, 0x9e, 0x89, 0x71, 0x40, 0x36, 0xaa, 0x7c, 0x6a);

// {21CC21CB-FBD5-45c8-B6E1-A26E85DE426F}
DEFINE_GUID( TASKID_Minor_BeginTask_NotificationMan_FindConnectionPoint,
0x21cc21cb, 0xfbd5, 0x45c8, 0xb6, 0xe1, 0xa2, 0x6e, 0x85, 0xde, 0x42, 0x6f);

// {70DBDF3F-F4A3-46b7-BB99-E3E4A8FD3ECA}
DEFINE_GUID( TASKID_Minor_BeginTask_NotificationMan_FindConnectionPoint_QI_INotifyUI,
0x70dbdf3f, 0xf4a3, 0x46b7, 0xbb, 0x99, 0xe3, 0xe4, 0xa8, 0xfd, 0x3e, 0xca);

// {F0972FFF-4453-4047-84A6-9EC4076D4647}
DEFINE_GUID( TASKID_Minor_BeginTask_QueryService_TaskManager,
0xf0972fff, 0x4453, 0x4047, 0x84, 0xa6, 0x9e, 0xc4, 0x7, 0x6d, 0x46, 0x47);

// {02BD5229-289B-4543-9CC5-103C818ED3FB}
DEFINE_GUID( TASKID_Minor_BeginTask_QueryService_ObjectManager,
0x2bd5229, 0x289b, 0x4543, 0x9c, 0xc5, 0x10, 0x3c, 0x81, 0x8e, 0xd3, 0xfb);

// {001EEE37-48FA-46c3-AA76-ADF0AFB101B9}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject,
0x1eee37, 0x48fa, 0x46c3, 0xaa, 0x76, 0xad, 0xf0, 0xaf, 0xb1, 0x1, 0xb9);

// {6FC0DE15-0E2A-4b89-A7EE-0B23C76AF7BE}
DEFINE_GUID( TASKID_Minor_BeginTask_SetStatus,
0x6fc0de15, 0xe2a, 0x4b89, 0xa7, 0xee, 0xb, 0x23, 0xc7, 0x6a, 0xf7, 0xbe);

// {8B3CD36A-2128-48d9-8594-1FB2A8CFEBF8}
DEFINE_GUID( TASKID_Minor_BeginTask_ObjectChanged,
0x8b3cd36a, 0x2128, 0x48d9, 0x85, 0x94, 0x1f, 0xb2, 0xa8, 0xcf, 0xeb, 0xf8);

// {5456765D-BF37-4fc6-9B9D-4B0DFEB52F92}
DEFINE_GUID( TASKID_Minor_BeginTask_Win32Error,
0x5456765d, 0xbf37, 0x4fc6, 0x9b, 0x9d, 0x4b, 0xd, 0xfe, 0xb5, 0x2f, 0x92);

// {B4A70325-9676-4e9e-857E-C05DF11C0B4E}
DEFINE_GUID( TASKID_Minor_ObjectChanged_Win32Error,
0xb4a70325, 0x9676, 0x4e9e, 0x85, 0x7e, 0xc0, 0x5d, 0xf1, 0x1c, 0xb, 0x4e);

// {CACAF6D3-8701-4957-8E46-0DA460ADF87E}
DEFINE_GUID( TASKID_Minor_WaitForCluster_CreateCompletionCookie,
0xcacaf6d3, 0x8701, 0x4957, 0x8e, 0x46, 0xd, 0xa4, 0x60, 0xad, 0xf8, 0x7e);

// {85F0D366-B2DE-45c4-BD17-91426E5217F5}
DEFINE_GUID( TASKID_Minor_WaitForCluster_CreateTask,
0x85f0d366, 0xb2de, 0x45c4, 0xbd, 0x17, 0x91, 0x42, 0x6e, 0x52, 0x17, 0xf5);

// {1F4DD563-1033-4fef-8203-3F85AB303292}
DEFINE_GUID( TASKID_Minor_WaitForCluster_CreateTask_QI,
0x1f4dd563, 0x1033, 0x4fef, 0x82, 0x3, 0x3f, 0x85, 0xab, 0x30, 0x32, 0x92);

// {C2665106-1D2F-4915-A383-C0A66A40FCB7}
DEFINE_GUID( TASKID_Minor_WaitForCluster_SetCookie,
0xc2665106, 0x1d2f, 0x4915, 0xa3, 0x83, 0xc0, 0xa6, 0x6a, 0x40, 0xfc, 0xb7);

// {FF1193DA-A11A-4c2f-B8AB-D9B36C0AF6EC}
DEFINE_GUID( TASKID_Minor_WaitForCluster_SetCompletionCookie,
0xff1193da, 0xa11a, 0x4c2f, 0xb8, 0xab, 0xd9, 0xb3, 0x6c, 0xa, 0xf6, 0xec);

// {D6DA7600-974B-4573-BC00-B1F47A478282}
DEFINE_GUID( TASKID_Minor_WaitForCluster_SubmitTask,
0xd6da7600, 0x974b, 0x4573, 0xbc, 0x0, 0xb1, 0xf4, 0x7a, 0x47, 0x82, 0x82);

// {AE51A218-0D13-412b-B53B-B96C8FD37388}
DEFINE_GUID( TASKID_Minor_WaitForCluster_GetObject,
0xae51a218, 0xd13, 0x412b, 0xb5, 0x3b, 0xb9, 0x6c, 0x8f, 0xd3, 0x73, 0x88);

// {E59966AF-F01E-4398-8D80-737525C5320C}
DEFINE_GUID( TASKID_Minor_WaitForCluster_GetObject_QI,
0xe59966af, 0xf01e, 0x4398, 0x8d, 0x80, 0x73, 0x75, 0x25, 0xc5, 0x32, 0xc);

// {941FCD0F-2F59-48ea-9C9E-2354FCB12E7F}
DEFINE_GUID( TASKID_Minor_WaitForCluster_GetStatus,
0x941fcd0f, 0x2f59, 0x48ea, 0x9c, 0x9e, 0x23, 0x54, 0xfc, 0xb1, 0x2e, 0x7f);

// {FBC23EAD-AE0C-47f4-B2A6-97BB9E9C4DA5}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_GetObject,
0xfbc23ead, 0xae0c, 0x47f4, 0xb2, 0xa6, 0x97, 0xbb, 0x9e, 0x9c, 0x4d, 0xa5);

// {2EB0D9CE-D86E-47e9-87AA-B89534D2C5D0}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_GetObject_QI,
0x2eb0d9ce, 0xd86e, 0x47e9, 0x87, 0xaa, 0xb8, 0x95, 0x34, 0xd2, 0xc5, 0xd0);

// {ED7CC4A7-E681-4c3b-BD48-5C43A2C28331}
DEFINE_GUID( TASKID_Minor_WaitForCluster_OutOfMemory,
0xed7cc4a7, 0xe681, 0x4c3b, 0xbd, 0x48, 0x5c, 0x43, 0xa2, 0xc2, 0x83, 0x31);

// {FDB648B4-B632-4e3a-B4B6-0D9976DBB7ED}
DEFINE_GUID( TASKID_Minor_WaitForCluster_GetName,
0xfdb648b4, 0xb632, 0x4e3a, 0xb4, 0xb6, 0xd, 0x99, 0x76, 0xdb, 0xb7, 0xed);

// {31F05D8E-0E72-463a-89D4-6A20439A0D48}
DEFINE_GUID( TASKID_Minor_CountNodes_FindObject,
0x31f05d8e, 0xe72, 0x463a, 0x89, 0xd4, 0x6a, 0x20, 0x43, 0x9a, 0xd, 0x48);

// {C1683A23-F943-4539-A1CA-589E1BCE11FE}
DEFINE_GUID( TASKID_Minor_CountNodes_FindObject_QI,
0xc1683a23, 0xf943, 0x4539, 0xa1, 0xca, 0x58, 0x9e, 0x1b, 0xce, 0x11, 0xfe);

// {87992486-0B67-4887-868B-773BA96E4E72}
DEFINE_GUID( TASKID_Minor_CountNodes_LoadString,
0x87992486, 0xb67, 0x4887, 0x86, 0x8b, 0x77, 0x3b, 0xa9, 0x6e, 0x4e, 0x72);

// {06B67A64-6F85-410b-BA5F-7DCA5172CD49}
DEFINE_GUID( TASKID_Minor_CountNodes_EnumNodes_Next,
0x6b67a64, 0x6f85, 0x410b, 0xba, 0x5f, 0x7d, 0xca, 0x51, 0x72, 0xcd, 0x49);

// {F01FD589-6247-44b7-BF7D-F935064E2FBB}
DEFINE_GUID( TASKID_Minor_CountNodes_EnumNodes_GetObject,
0xf01fd589, 0x6247, 0x44b7, 0xbf, 0x7d, 0xf9, 0x35, 0x6, 0x4e, 0x2f, 0xbb);

// {2931E4F5-1FDA-422e-BA04-14C8C53A6B45}
DEFINE_GUID( TASKID_Minor_CountNodes_EnumNodes_GetObject_QI,
0x2931e4f5, 0x1fda, 0x422e, 0xba, 0x4, 0x14, 0xc8, 0xc5, 0x3a, 0x6b, 0x45);

// {09CAB4FF-8038-4d7a-82AF-793B0D9ADB80}
DEFINE_GUID( TASKID_Minor_CountNodes_EnumNodes_GetStatus,
0x9cab4ff, 0x8038, 0x4d7a, 0x82, 0xaf, 0x79, 0x3b, 0xd, 0x9a, 0xdb, 0x80);

// {7EEBE1F7-5D39-49fc-B8C4-B13A9B236885}
DEFINE_GUID( TASKID_Minor_CountNodes_EnumNodes_GetName,
0x7eebe1f7, 0x5d39, 0x49fc, 0xb8, 0xc4, 0xb1, 0x3a, 0x9b, 0x23, 0x68, 0x85);

// {547919D9-E4EF-4948-84F7-A8783C4B65AB}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_FindObject,
0x547919d9, 0xe4ef, 0x4948, 0x84, 0xf7, 0xa8, 0x78, 0x3c, 0x4b, 0x65, 0xab);

// {22BFD3BF-9077-46d0-BF7B-360E8B2E51EE}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_FindObject_QI,
0x22bfd3bf, 0x9077, 0x46d0, 0xbf, 0x7b, 0x36, 0xe, 0x8b, 0x2e, 0x51, 0xee);

// {AFAE75CF-B0C7-4f30-87FF-53886DACBE29}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_Win32Error,
0xafae75cf, 0xb0c7, 0x4f30, 0x87, 0xff, 0x53, 0x88, 0x6d, 0xac, 0xbe, 0x29);

// {5F9FCEDC-1FBC-4bec-9524-0BAD86D41F0C}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_OutOfMemory,
0x5f9fcedc, 0x1fbc, 0x4bec, 0x95, 0x24, 0xb, 0xad, 0x86, 0xd4, 0x1f, 0xc);

// {E1CB34AB-A503-434a-832D-E6FF0E3AFD22}
DEFINE_GUID( TASKID_Minor_GatherInformation_FindObject,
0xe1cb34ab, 0xa503, 0x434a, 0x83, 0x2d, 0xe6, 0xff, 0xe, 0x3a, 0xfd, 0x22);

// {135D7254-3E5F-4808-AF7A-E0F819242E7A}
DEFINE_GUID( TASKID_Minor_GatherInformation_FindObject_QI,
0x135d7254, 0x3e5f, 0x4808, 0xaf, 0x7a, 0xe0, 0xf8, 0x19, 0x24, 0x2e, 0x7a);

// {C764E6DC-A61A-43cb-A94F-4C75ADDCB0FA}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_Next,
0xc764e6dc, 0xa61a, 0x43cb, 0xa9, 0x4f, 0x4c, 0x75, 0xad, 0xdc, 0xb0, 0xfa);

// {00910AE8-2DF8-498a-8D95-D6B4C377CC20}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_GetObject,
0x910ae8, 0x2df8, 0x498a, 0x8d, 0x95, 0xd6, 0xb4, 0xc3, 0x77, 0xcc, 0x20);

// {82649EC7-6277-4eb5-82F7-EA149FA0C59F}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_GetObject_QI,
0x82649ec7, 0x6277, 0x4eb5, 0x82, 0xf7, 0xea, 0x14, 0x9f, 0xa0, 0xc5, 0x9f);

// {A3A398A5-B508-4b14-B1F5-B9D703FC8B84}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_GetName,
0xa3a398a5, 0xb508, 0x4b14, 0xb1, 0xf5, 0xb9, 0xd7, 0x3, 0xfc, 0x8b, 0x84);

// {826AE014-19E5-41b2-89BC-8511FEE95D7A}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_CompletionCookie_FindObject,
0x826ae014, 0x19e5, 0x41b2, 0x89, 0xbc, 0x85, 0x11, 0xfe, 0xe9, 0x5d, 0x7a);

// {C60A3304-DE02-427a-8A2E-F6269AC8FB0D}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_CompletionCookie_FindObject_QI,
0xc60a3304, 0xde02, 0x427a, 0x8a, 0x2e, 0xf6, 0x26, 0x9a, 0xc8, 0xfb, 0xd);

// {5F1F6DBB-ED39-4951-AF43-AEE096894118}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_CreateTask,
0x5f1f6dbb, 0xed39, 0x4951, 0xaf, 0x43, 0xae, 0xe0, 0x96, 0x89, 0x41, 0x18);

// {62B97544-6D8F-4631-A98F-BB51174CDC1C}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_QI_GatherNodeInfo,
0x62b97544, 0x6d8f, 0x4631, 0xa9, 0x8f, 0xbb, 0x51, 0x17, 0x4c, 0xdc, 0x1c);

// {BC27FEBB-2EE4-44e3-9446-007E196FDA14}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SetCompletionCookie,
0xbc27febb, 0x2ee4, 0x44e3, 0x94, 0x46, 0x0, 0x7e, 0x19, 0x6f, 0xda, 0x14);

// {E7A6830C-E8E8-4398-9A69-63F97B1CED51}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SetCookie,
0xe7a6830c, 0xe8e8, 0x4398, 0x9a, 0x69, 0x63, 0xf9, 0x7b, 0x1c, 0xed, 0x51);

// {EBFFD21B-8C76-4b59-A6B2-710F6B632982}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SetJoining,
0xebffd21b, 0x8c76, 0x4b59, 0xa6, 0xb2, 0x71, 0xf, 0x6b, 0x63, 0x29, 0x82);

// {387AA6B4-27E8-43fc-A648-077476D475C7}
DEFINE_GUID( TASKID_Minor_GatherInformation_EnumNodes_SubmitTask,
0x387aa6b4, 0x27e8, 0x43fc, 0xa6, 0x48, 0x7, 0x74, 0x76, 0xd4, 0x75, 0xc7);

// {D95A524F-09F7-4635-A5FF-E776129C992D}
DEFINE_GUID( TASKID_Minor_GatherInformation_GetStatus,
0xd95a524f, 0x9f7, 0x4635, 0xa5, 0xff, 0xe7, 0x76, 0x12, 0x9c, 0x99, 0x2d);

// {307B317B-F76F-45f5-923F-F078FB02B1FE}
DEFINE_GUID( TASKID_Minor_GatherInformation_Win32Error,
0x307b317b, 0xf76f, 0x45f5, 0x92, 0x3f, 0xf0, 0x78, 0xfb, 0x2, 0xb1, 0xfe);

// {41CE2C9D-A57E-4bde-A9AA-2309ED15F241}
DEFINE_GUID( TASKID_Minor_GatherInformation_OutOfMemory,
0x41ce2c9d, 0xa57e, 0x4bde, 0xa9, 0xaa, 0x23, 0x9, 0xed, 0x15, 0xf2, 0x41);

// {F7BB5004-500F-4094-A7F7-95742D4AFD5D}
DEFINE_GUID( TASKID_Minor_BeginTask_Advise,
0xf7bb5004, 0x500f, 0x4094, 0xa7, 0xf7, 0x95, 0x74, 0x2d, 0x4a, 0xfd, 0x5d);

// {CDA70081-9627-4671-BBC3-0FA65B93A5ED}
DEFINE_GUID( TASKID_Minor_BeginTask_Unadvise,
0xcda70081, 0x9627, 0x4671, 0xbb, 0xc3, 0xf, 0xa6, 0x5b, 0x93, 0xa5, 0xed);

// {E3300019-A3AE-4f3e-87DB-599EAE8FB7C9}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_Next,
0xe3300019, 0xa3ae, 0x4f3e, 0x87, 0xdb, 0x59, 0x9e, 0xae, 0x8f, 0xb7, 0xc9);

// {7ED16DED-D6FD-4c39-B922-DAFCB7837C6D}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_GetName,
0x7ed16ded, 0xd6fd, 0x4c39, 0xb9, 0x22, 0xda, 0xfc, 0xb7, 0x83, 0x7c, 0x6d);

// {607777CB-40E0-491b-9CE8-33EDAD7B86FE}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_LoadString_Connecting,
0x607777cb, 0x40e0, 0x491b, 0x9c, 0xe8, 0x33, 0xed, 0xad, 0x7b, 0x86, 0xfe);

// {57113590-DD6E-4b16-BC24-92C09584942B}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_GetCookie_FindObject,
0x57113590, 0xdd6e, 0x4b16, 0xbc, 0x24, 0x92, 0xc0, 0x95, 0x84, 0x94, 0x2b);

// {8C2523D6-3530-4915-8749-EA9498D72207}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_CreateTask,
0x8c2523d6, 0x3530, 0x4915, 0x87, 0x49, 0xea, 0x94, 0x98, 0xd7, 0x22, 0x7);

// {DCDC9B6A-A9E6-4919-B5FD-E859BEC1FACA}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_QI_GatherNodeInfo,
0xdcdc9b6a, 0xa9e6, 0x4919, 0xb5, 0xfd, 0xe8, 0x59, 0xbe, 0xc1, 0xfa, 0xca);

// {52FEE1B7-B603-4942-A508-2FE991A9ABD4}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_SetCookie,
0x52fee1b7, 0xb603, 0x4942, 0xa5, 0x8, 0x2f, 0xe9, 0x91, 0xa9, 0xab, 0xd4);

// {9AF871B2-C843-4086-8AC3-28755E078BDB}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_SetCompletionCookie,
0x9af871b2, 0xc843, 0x4086, 0x8a, 0xc3, 0x28, 0x75, 0x5e, 0x7, 0x8b, 0xdb);

// {70FC1231-B5DE-463b-B30C-C93A6C74C64E}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_CompletionCookie_FindObject,
0x70fc1231, 0xb5de, 0x463b, 0xb3, 0xc, 0xc9, 0x3a, 0x6c, 0x74, 0xc6, 0x4e);

// {D34C8E79-EDF3-4aaa-9B6C-CB439F654088}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_CompletionCookie_FindObject_QI,
0xd34c8e79, 0xedf3, 0x4aaa, 0x9b, 0x6c, 0xcb, 0x43, 0x9f, 0x65, 0x40, 0x88);

// {488BDFE5-9371-4a8a-B3C8-9F479923E530}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_NodeCookie_FindObject,
0x488bdfe5, 0x9371, 0x4a8a, 0xb3, 0xc8, 0x9f, 0x47, 0x99, 0x23, 0xe5, 0x30);

// {E38B87A7-F41F-45fd-8EB9-E5C02FC3545B}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_SetJoining,
0xe38b87a7, 0xf41f, 0x45fd, 0x8e, 0xb9, 0xe5, 0xc0, 0x2f, 0xc3, 0x54, 0x5b);

// {CF14436D-2012-4652-A34D-A572B3445A2F}
DEFINE_GUID( TASKID_Minor_CreateNodeTasks_EnumNodes_SubmitTask,
0xcf14436d, 0x2012, 0x4652, 0xa3, 0x4d, 0xa5, 0x72, 0xb3, 0x44, 0x5a, 0x2f);

// {954ADE6B-4E1E-4174-8397-72402CC4538E}
DEFINE_GUID( TASKID_Minor_AddJoinedNodes_OpenCluster,
0x954ade6b, 0x4e1e, 0x4174, 0x83, 0x97, 0x72, 0x40, 0x2c, 0xc4, 0x53, 0x8e);

// {9DBFB402-E1AF-4437-959A-4801AE21E447}
DEFINE_GUID( TASKID_Minor_AddJoinedNodes_ClusterOpenEnum,
0x9dbfb402, 0xe1af, 0x4437, 0x95, 0x9a, 0x48, 0x1, 0xae, 0x21, 0xe4, 0x47);

// {94138C41-401F-49b9-B258-B955E73E43EF}
DEFINE_GUID( TASKID_Minor_AddJoinedNodes_ClusterEnum,
0x94138c41, 0x401f, 0x49b9, 0xb2, 0x58, 0xb9, 0x55, 0xe7, 0x3e, 0x43, 0xef);

// {F00D6834-73BB-432e-9D04-8D37E3CCE566}
DEFINE_GUID( TASKID_Minor_AddJoinedNodes_OutOfMemory,
0xf00d6834, 0x73bb, 0x432e, 0x9d, 0x4, 0x8d, 0x37, 0xe3, 0xcc, 0xe5, 0x66);

// {9AEB5CCD-C7CF-4890-9BDD-238E8F68C101}
DEFINE_GUID( TASKID_Minor_AddJoinedNodes_FindObject,
0x9aeb5ccd, 0xc7cf, 0x4890, 0x9b, 0xdd, 0x23, 0x8e, 0x8f, 0x68, 0xc1, 0x1);

// {B9C3B658-477D-4ed1-A92D-B7CF2D11D751}
DEFINE_GUID( TASKID_Minor_CheckMembership_FindObject,
0xb9c3b658, 0x477d, 0x4ed1, 0xa9, 0x2d, 0xb7, 0xcf, 0x2d, 0x11, 0xd7, 0x51);

// {C96092B1-FCAE-41b3-89DE-BC8970395C9F}
DEFINE_GUID( TASKID_Minor_CheckMembership_FindObject_QI,
0xc96092b1, 0xfcae, 0x41b3, 0x89, 0xde, 0xbc, 0x89, 0x70, 0x39, 0x5c, 0x9f);

// {40A6A866-D4F1-44eb-A201-2B73CD4EE7F0}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_Next,
0x40a6a866, 0xd4f1, 0x44eb, 0xa2, 0x1, 0x2b, 0x73, 0xcd, 0x4e, 0xe7, 0xf0);

// {14757B27-5DDC-4309-A726-CB2485D29C44}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_IsMemberOfCluster,
0x14757b27, 0x5ddc, 0x4309, 0xa7, 0x26, 0xcb, 0x24, 0x85, 0xd2, 0x9c, 0x44);

// {9F022D5F-47D4-4aa1-96EB-CB10FD42DEFF}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_GetClusterConfigInfo,
0x9f022d5f, 0x47d4, 0x4aa1, 0x96, 0xeb, 0xcb, 0x10, 0xfd, 0x42, 0xde, 0xff);

// {D8AD7746-5724-484b-A98D-990E5C956E43}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_GetName,
0xd8ad7746, 0x5724, 0x484b, 0xa9, 0x8d, 0x99, 0xe, 0x5c, 0x95, 0x6e, 0x43);

// {318F9A4A-B4A9-4762-B45E-0A87FAB04D00}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_GetNodeName,
0x318f9a4a, 0xb4a9, 0x4762, 0xb4, 0x5e, 0xa, 0x87, 0xfa, 0xb0, 0x4d, 0x0);

// {045D9A03-BED1-47b5-A8B9-69D5E05B0D1F}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_FormatMessage,
0x45d9a03, 0xbed1, 0x47b5, 0xa8, 0xb9, 0x69, 0xd5, 0xe0, 0x5b, 0xd, 0x1f);

// {EA7534CF-7B9A-453f-B18C-7231158BD08D}
DEFINE_GUID( TASKID_Minor_CheckMembership_FormatMessage,
0xea7534cf, 0x7b9a, 0x453f, 0xb1, 0x8c, 0x72, 0x31, 0x15, 0x8b, 0xd0, 0x8d);

// {1D11320B-30D5-4c12-BA07-3BCD3ED5FA67}
DEFINE_GUID( TASKID_Minor_Compare_Enum_Nodes_Find_Object,
0x1d11320b, 0x30d5, 0x4c12, 0xba, 0x7, 0x3b, 0xcd, 0x3e, 0xd5, 0xfa, 0x67);

// {822A1887-125A-424a-B5B1-A8ADEEFD184E}
DEFINE_GUID( TASKID_Minor_Compare_Enum_Nodes_Find_Object_QI,
0x822a1887, 0x125a, 0x424a, 0xb5, 0xb1, 0xa8, 0xad, 0xee, 0xfd, 0x18, 0x4e);

// {42E2F3FE-156A-4cd4-946F-97DCBEC2C186}
DEFINE_GUID( TASKID_Minor_Compare_Enum_Nodes_Next,
0x42e2f3fe, 0x156a, 0x4cd4, 0x94, 0x6f, 0x97, 0xdc, 0xbe, 0xc2, 0xc1, 0x86);

// {7105C17E-B076-4e61-B928-F91AF3B1691C}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Find_Formed_Node,
0x7105c17e, 0xb076, 0x4e61, 0xb9, 0x28, 0xf9, 0x1a, 0xf3, 0xb1, 0x69, 0x1c);

// {7105C17E-B076-4e61-B928-F91AF3B1691C}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Find_Formed_Node_Next,
0x7105c17e, 0xb076, 0x4e61, 0xb9, 0x28, 0xf9, 0x1a, 0xf3, 0xb1, 0x69, 0x1c);

// {7105C17E-B076-4e61-B928-F91AF3B1691C}
DEFINE_GUID( TASKID_Minor_CompareResources_NodeInfo_FindObject,
0x7105c17e, 0xb076, 0x4e61, 0xb9, 0x28, 0xf9, 0x1a, 0xf3, 0xb1, 0x69, 0x1c);

// {7105C17E-B076-4e61-B928-F91AF3B1691C}
DEFINE_GUID( TASKID_Minor_CompareResources_NodeInfo_FindObject_QI,
0x7105c17e, 0xb076, 0x4e61, 0xb9, 0x28, 0xf9, 0x1a, 0xf3, 0xb1, 0x69, 0x1c);

// {932AACD5-2D37-4c51-B2FF-E279FF2BF96D}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Find_Object,
0x932aacd5, 0x2d37, 0x4c51, 0xb2, 0xff, 0xe2, 0x79, 0xff, 0x2b, 0xf9, 0x6d);

// {B8F19E4E-D34E-4740-833A-99265A33A5E0}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Find_Object_QI,
0xb8f19e4e, 0xd34e, 0x4740, 0x83, 0x3a, 0x99, 0x26, 0x5a, 0x33, 0xa5, 0xe0);

// {18EAD8A8-9E7D-4885-9360-15AE2E7D4148}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Next,
0x18ead8a8, 0x9e7d, 0x4885, 0x93, 0x60, 0x15, 0xae, 0x2e, 0x7d, 0x41, 0x48);

// {C4896D7E-F32A-4a79-8F02-E0D5005BFBA1}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Get_Quorum_UID,
0xc4896d7e, 0xf32a, 0x4a79, 0x8f, 0x2, 0xe0, 0xd5, 0x0, 0x5b, 0xfb, 0xa1);

// {ADFBE9CD-AC9B-450c-9655-2ADD2E414580}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Reset,
0xadfbe9cd, 0xac9b, 0x450c, 0x96, 0x55, 0x2a, 0xdd, 0x2e, 0x41, 0x45, 0x80);

// {74F939BF-6C06-40ca-9D23-9E7EF8147217}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Next,
0x74f939bf, 0x6c06, 0x40ca, 0x9d, 0x23, 0x9e, 0x7e, 0xf8, 0x14, 0x72, 0x17);

// {C4B183CF-9C19-4ed5-BF95-A52170EC5CA9}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Find_Object,
0xc4b183cf, 0x9c19, 0x4ed5, 0xbf, 0x95, 0xa5, 0x21, 0x70, 0xec, 0x5c, 0xa9);

// {260446BA-0D48-468a-B6F4-F14A315AF771}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Find_Object_QI,
0x260446ba, 0xd48, 0x468a, 0xb6, 0xf4, 0xf1, 0x4a, 0x31, 0x5a, 0xf7, 0x71);

// {C7115544-E677-4700-9065-D6E4B7472E2B}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Next,
0xc7115544, 0xe677, 0x4700, 0x90, 0x65, 0xd6, 0xe4, 0xb7, 0x47, 0x2e, 0x2b);

// {18E698F5-6F9F-40d4-A81B-3D711F8B46A8}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_GetUID,
0x18e698f5, 0x6f9f, 0x40d4, 0xa8, 0x1b, 0x3d, 0x71, 0x1f, 0x8b, 0x46, 0xa8);

// {241B61F5-08D9-45b2-83A6-CB2632E25556}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Find_Object,
0x241b61f5, 0x8d9, 0x45b2, 0x83, 0xa6, 0xcb, 0x26, 0x32, 0xe2, 0x55, 0x56);

// {100CC244-19CC-4f22-B1CF-9E4CB97F1589}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Find_Object_QI,
0x100cc244, 0x19cc, 0x4f22, 0xb1, 0xcf, 0x9e, 0x4c, 0xb9, 0x7f, 0x15, 0x89);

// {ED0C2913-F414-4cad-A87B-AD03B5B3EFF9}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Next,
0xed0c2913, 0xf414, 0x4cad, 0xa8, 0x7b, 0xad, 0x3, 0xb5, 0xb3, 0xef, 0xf9);

// {6D2B1639-5F69-4638-8091-C94421FD5690}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetUID,
0x6d2b1639, 0x5f69, 0x4638, 0x80, 0x91, 0xc9, 0x44, 0x21, 0xfd, 0x56, 0x90);

// {D7A8AC9D-3C1C-4754-9D92-4E12464AA2F9}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsQuorumCapable,
0xd7a8ac9d, 0x3c1c, 0x4754, 0x9d, 0x92, 0x4e, 0x12, 0x46, 0x4a, 0xa2, 0xf9);

// {ED3FF704-C8E8-42a4-AACF-E3498CCEF79F}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsQuorumCapable_Cluster,
0xed3ff704, 0xc8e8, 0x42a4, 0xaa, 0xcf, 0xe3, 0x49, 0x8c, 0xce, 0xf7, 0x9f);

// {71911EEC-7D22-4a63-8E9F-89FBB61D6FFF}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsQuorumCapable_Node,
0x71911eec, 0x7d22, 0x4a63, 0x8e, 0x9f, 0x89, 0xfb, 0xb6, 0x1d, 0x6f, 0xff);

// {1FD0B09A-42FC-4d2e-82FB-AF2B80899578}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetName,
0x1fd0b09a, 0x42fc, 0x4d2e, 0x82, 0xfb, 0xaf, 0x2b, 0x80, 0x89, 0x95, 0x78);

// {C2B337AF-F069-4f51-B094-AC1E52237E81}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsManaged,
0xc2b337af, 0xf069, 0x4f51, 0xb0, 0x94, 0xac, 0x1e, 0x52, 0x23, 0x7e, 0x81);

// {351ED057-2974-4e13-96F5-4D0B25119736}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetManaged,
0x351ed057, 0x2974, 0x4e13, 0x96, 0xf5, 0x4d, 0xb, 0x25, 0x11, 0x97, 0x36);

// {66740A6A-3CE3-4e13-A14B-E784CE42C8C5}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetResName,
0x66740a6a, 0x3ce3, 0x4e13, 0xa1, 0x4b, 0xe7, 0x84, 0xce, 0x42, 0xc8, 0xc5);

// {64F7FADA-E29F-4bff-A7AA-D9AE2D4C6FF9}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetResName,
0x64f7fada, 0xe29f, 0x4bff, 0xa7, 0xaa, 0xd9, 0xae, 0x2d, 0x4c, 0x6f, 0xf9);

// {22F2511B-D66E-4293-B14E-54BDF79F0AEC}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Cluster,
0x22f2511b, 0xd66e, 0x4293, 0xb1, 0x4e, 0x54, 0xbd, 0xf7, 0x9f, 0xa, 0xec);

// {3A68E842-092B-42f8-B3DC-AFD27FFF70F1}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_GetUID,
0x3a68e842, 0x92b, 0x42f8, 0xb3, 0xdc, 0xaf, 0xd2, 0x7f, 0xff, 0x70, 0xf1);

// {1A4108DF-BD13-4032-9CBF-36626658F156}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Node_True,
0x1a4108df, 0xbd13, 0x4032, 0x9c, 0xbf, 0x36, 0x62, 0x66, 0x58, 0xf1, 0x56);

// {26D53BBF-7649-4d90-9C32-EF4CBFB834AE}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Node_False,
0x26d53bbf, 0x7649, 0x4d90, 0x9c, 0x32, 0xef, 0x4c, 0xbf, 0xb8, 0x34, 0xae);

// {066375FC-9F94-4cc1-BF6A-3676E2733619}
DEFINE_GUID( TASKID_Minor_Create_Resource_GetUID,
0x66375fc, 0x9f94, 0x4cc1, 0xbf, 0x6a, 0x36, 0x76, 0xe2, 0x73, 0x36, 0x19);

// {BD8FF82B-9C3B-420f-892E-80B0E484F2F5}
DEFINE_GUID( TASKID_Minor_Create_Resource_FindObject,
0xbd8ff82b, 0x9c3b, 0x420f, 0x89, 0x2e, 0x80, 0xb0, 0xe4, 0x84, 0xf2, 0xf5);

// {C87EA962-1711-49db-9FDB-ED4768BA8701}
DEFINE_GUID( TASKID_Minor_Create_Resource_FindObject_QI,
0xc87ea962, 0x1711, 0x49db, 0x9f, 0xdb, 0xed, 0x47, 0x68, 0xba, 0x87, 0x1);

// {8A8DB3C4-4AC9-4746-9B09-3442735020A5}
DEFINE_GUID( TASKID_Minor_Create_Resource_Gather,
0x8a8db3c4, 0x4ac9, 0x4746, 0x9b, 0x9, 0x34, 0x42, 0x73, 0x50, 0x20, 0xa5);

// {135F96E8-3C89-48ec-AF53-46424621033D}
DEFINE_GUID( TASKID_Minor_Create_Resource_QI,
0x135f96e8, 0x3c89, 0x48ec, 0xaf, 0x53, 0x46, 0x42, 0x46, 0x21, 0x3, 0x3d);

// {FDF30CC5-B392-4ddb-8CA6-360AC8138C69}
DEFINE_GUID( TASKID_Minor_Check_Common_FindObject,
0xfdf30cc5, 0xb392, 0x4ddb, 0x8c, 0xa6, 0x36, 0xa, 0xc8, 0x13, 0x8c, 0x69);

// {8D801358-7C6B-4699-9DAE-E4E7C0CED09D}
DEFINE_GUID( TASKID_Minor_Check_Common_FindObject_QI,
0x8d801358, 0x7c6b, 0x4699, 0x9d, 0xae, 0xe4, 0xe7, 0xc0, 0xce, 0xd0, 0x9d);

// {DC8A5E76-FE76-41ef-9171-EFFC272C81B4}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_Next,
0xdc8a5e76, 0xfe76, 0x41ef, 0x91, 0x71, 0xef, 0xfc, 0x27, 0x2c, 0x81, 0xb4);

// {F0DABE6E-348F-4308-BC7E-5C781536E938}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_FindObject,
0xf0dabe6e, 0x348f, 0x4308, 0xbc, 0x7e, 0x5c, 0x78, 0x15, 0x36, 0xe9, 0x38);

// {8A3EB407-824F-4908-B675-3F2C79A4A2FF}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_FindObject_QI,
0x8a3eb407, 0x824f, 0x4908, 0xb6, 0x75, 0x3f, 0x2c, 0x79, 0xa4, 0xa2, 0xff);

// {79D4E66E-D75B-4492-8383-3D322E128551}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_Enum_Resources_Next,
0x79d4e66e, 0xd75b, 0x4492, 0x83, 0x83, 0x3d, 0x32, 0x2e, 0x12, 0x85, 0x51);

// {2D2D5E3B-F524-4a29-B969-F7274315C102}
DEFINE_GUID( TASKID_Minor_Check_Common_Enum_Nodes_Enum_Resources_GetUID,
0x2d2d5e3b, 0xf524, 0x4a29, 0xb9, 0x69, 0xf7, 0x27, 0x43, 0x15, 0xc1, 0x2);

// {C02A8E01-82A9-4e82-9D8F-BFB84AEDD283}
DEFINE_GUID( TASKID_Minor_Check_Common_Failure,
0xc02a8e01, 0x82a9, 0x4e82, 0x9d, 0x8f, 0xbf, 0xb8, 0x4a, 0xed, 0xd2, 0x83);

// {EE31B8EE-4588-4475-AFBF-9920B8E7F557}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_FindObject,
0xee31b8ee, 0x4588, 0x4475, 0xaf, 0xbf, 0x99, 0x20, 0xb8, 0xe7, 0xf5, 0x57);

// {F02940F8-B2FB-4dc7-9A06-10EFE276CFB5}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_FindObject_QI,
0xf02940f8, 0xb2fb, 0x4dc7, 0x9a, 0x6, 0x10, 0xef, 0xe2, 0x76, 0xcf, 0xb5);

// {5152ACA0-2011-4ac8-ACC7-B5BA6A300A66}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_Next,
0x5152aca0, 0x2011, 0x4ac8, 0xac, 0xc7, 0xb5, 0xba, 0x6a, 0x30, 0xa, 0x66);

// {DA0CA708-E77B-46e8-A6E3-F18D1FBC95E0}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumResources_FindObject,
0xda0ca708, 0xe77b, 0x46e8, 0xa6, 0xe3, 0xf1, 0x8d, 0x1f, 0xbc, 0x95, 0xe0);

// {5F1CD55C-4581-42f0-A474-2A95A22987AD}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumResources_FindObject_QI,
0x5f1cd55c, 0x4581, 0x42f0, 0xa4, 0x74, 0x2a, 0x95, 0xa2, 0x29, 0x87, 0xad);

// {A47B3BA8-E3FB-4ddf-A38C-D90B38408E59}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetwork_Next,
0xa47b3ba8, 0xe3fb, 0x4ddf, 0xa3, 0x8c, 0xd9, 0xb, 0x38, 0x40, 0x8e, 0x59);

// {A1CA99F5-7109-484e-97A4-782681ACA8B3}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_NextNode,
0xa1ca99f5, 0x7109, 0x484e, 0x97, 0xa4, 0x78, 0x26, 0x81, 0xac, 0xa8, 0xb3);

// {B389AF6F-19B1-4e2f-B625-77AF3630272D}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_Next_FindObject,
0xb389af6f, 0x19b1, 0x4e2f, 0xb6, 0x25, 0x77, 0xaf, 0x36, 0x30, 0x27, 0x2d);

// {D8E74B78-4DC5-4f95-8D1A-948D9F95BA6A}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_Next_LoadString,
0xd8e74b78, 0x4dc5, 0x4f95, 0x8d, 0x1a, 0x94, 0x8d, 0x9f, 0x95, 0xba, 0x6a);

// {1837239C-C526-4121-A76E-0A5E0CEABDC0}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_Reset,
0x1837239c, 0xc526, 0x4121, 0xa7, 0x6e, 0xa, 0x5e, 0xc, 0xea, 0xbd, 0xc0);

// {297F270C-F27E-4f22-9FFE-DD6D29FBE296}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Next,
0x297f270c, 0xf27e, 0x4f22, 0x9f, 0xfe, 0xdd, 0x6d, 0x29, 0xfb, 0xe2, 0x96);

// {A6DA4ED7-B022-4837-AC90-78DF0B788064}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_GetUID,
0xa6da4ed7, 0xb022, 0x4837, 0xac, 0x90, 0x78, 0xdf, 0xb, 0x78, 0x80, 0x64);

// {4CD0FECB-B1C7-49dc-AB03-5D014919E421}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_FindObject,
0x4cd0fecb, 0xb1c7, 0x49dc, 0xab, 0x3, 0x5d, 0x1, 0x49, 0x19, 0xe4, 0x21);

// {33A004D1-B5CA-4a15-B752-93D64E69C647}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_FindObject_QI,
0x33a004d1, 0xb5ca, 0x4a15, 0xb7, 0x52, 0x93, 0xd6, 0x4e, 0x69, 0xc6, 0x47);

// {AC7F4906-4CB0-47ca-B214-3912C79BE775}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Cluster_Next,
0xac7f4906, 0x4cb0, 0x47ca, 0xb2, 0x14, 0x39, 0x12, 0xc7, 0x9b, 0xe7, 0x75);

// {9BEE7C48-9BF3-4185-9064-83A40F4FD7D5}
DEFINE_GUID( TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Cluster_GetUID,
0x9bee7c48, 0x9bf3, 0x4185, 0x90, 0x64, 0x83, 0xa4, 0xf, 0x4f, 0xd7, 0xd5);

// {6438F7AF-767C-46d2-8A5E-F0589D97951C}
DEFINE_GUID( TASKID_Minor_CreateNetwork_GetUID,
0x6438f7af, 0x767c, 0x46d2, 0x8a, 0x5e, 0xf0, 0x58, 0x9d, 0x97, 0x95, 0x1c);

// {97FEC5B9-7A4B-49ec-89C7-87C7818EDF25}
DEFINE_GUID( TASKID_Minor_CreateNetwork_FindObject,
0x97fec5b9, 0x7a4b, 0x49ec, 0x89, 0xc7, 0x87, 0xc7, 0x81, 0x8e, 0xdf, 0x25);

// {AE5A5682-5C27-4e33-B580-8DE3E6BEDF43}
DEFINE_GUID( TASKID_Minor_CreateNetwork_FindObject_QI,
0xae5a5682, 0x5c27, 0x4e33, 0xb5, 0x80, 0x8d, 0xe3, 0xe6, 0xbe, 0xdf, 0x43);

// {E06795C9-C796-409e-BC41-CF7C094399F4}
DEFINE_GUID( TASKID_Minor_CreateNetwork_Gather,
0xe06795c9, 0xc796, 0x409e, 0xbc, 0x41, 0xcf, 0x7c, 0x9, 0x43, 0x99, 0xf4);

// {F4299F9D-5682-42a4-A199-FBA3F7F79CDB}
DEFINE_GUID( TASKID_Minor_CreateNetwork_QI,
0xf4299f9d, 0x5682, 0x42a4, 0xa1, 0x99, 0xfb, 0xa3, 0xf7, 0xf7, 0x9c, 0xdb);

// {AA8A3BA0-D2A9-44e8-BF8F-6C6C264BFD75}
DEFINE_GUID( TASKID_Minor_HrRetrieveCookiesName_FindObject_StandardInfo,
0xaa8a3ba0, 0xd2a9, 0x44e8, 0xbf, 0x8f, 0x6c, 0x6c, 0x26, 0x4b, 0xfd, 0x75);

// {F0A2D17C-F600-4a4d-9FB2-86C767D709B3}
DEFINE_GUID( TASKID_Minor_HrRetrieveCookiesName_FindObject_StandardInfo_QI_psi,
0xf0a2d17c, 0xf600, 0x4a4d, 0x9f, 0xb2, 0x86, 0xc7, 0x67, 0xd7, 0x9, 0xb3);

// {02736FEE-F2ED-4bd7-A298-B9949B0F5B0D}
DEFINE_GUID( TASKID_Minor_HrRetrieveCookiesName_GetName,
0x2736fee, 0xf2ed, 0x4bd7, 0xa2, 0x98, 0xb9, 0x94, 0x9b, 0xf, 0x5b, 0xd);

// {0ED1309D-B4B8-419a-B516-17987B862450}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FindObject,
0xed1309d, 0xb4b8, 0x419a, 0xb5, 0x16, 0x17, 0x98, 0x7b, 0x86, 0x24, 0x50);

// {291B68A8-EFC4-4ba4-96D5-C70ECAED2378}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FindObject_QI,
0x291b68a8, 0xefc4, 0x4ba4, 0x96, 0xd5, 0xc7, 0xe, 0xca, 0xed, 0x23, 0x78);

// {B3BB91E8-95D2-4df7-B1F0-19ECA8AEB1F3}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_EnumNode_Next,
0xb3bb91e8, 0x95d2, 0x4df7, 0xb1, 0xf0, 0x19, 0xec, 0xa8, 0xae, 0xb1, 0xf3);

// {D3EDF63A-8949-4ad5-9014-A6B1D4AEB9A9}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_LoadString_Checking,
0xd3edf63a, 0x8949, 0x4ad5, 0x90, 0x14, 0xa6, 0xb1, 0xd4, 0xae, 0xb9, 0xa9);

// {F2B650B0-EB7E-43fd-B308-26DD085CA4FE}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_GetConnectionObject,
0xf2b650b0, 0xeb7e, 0x43fd, 0xb3, 0x8, 0x26, 0xdd, 0x8, 0x5c, 0xa4, 0xfe);

// {0E0BC8DE-6558-4fea-BAB5-E64259F8FA8C}
DEFINE_GUID( TASKID_Minor_BeginTask_QueryService_ConnectionManager,
0xe0bc8de, 0x6558, 0x4fea, 0xba, 0xb5, 0xe6, 0x42, 0x59, 0xf8, 0xfa, 0x8c);

// {9C80CF68-C9A6-4b2c-A7F3-31E5F9AA0B36}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_ConfigConnection_QI,
0x9c80cf68, 0xc9a6, 0x4b2c, 0xa7, 0xf3, 0x31, 0xe5, 0xf9, 0xaa, 0xb, 0x36);

// {23D9B0CC-8CA0-4532-9245-1703C4CF05D0}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_Node_GetClusterVersion,
0x23d9b0cc, 0x8ca0, 0x4532, 0x92, 0x45, 0x17, 0x3, 0xc4, 0xcf, 0x5, 0xd0);

// {794B6A37-85D9-400c-9446-38115D12F2E8}`
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_GetName,
0x794b6a37, 0x85d9, 0x400c, 0x94, 0x46, 0x38, 0x11, 0x5d, 0x12, 0xf2, 0xe8);

// {BF2291E2-998C-4cc0-9AA7-5E4E41285044}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FormatString,
0xbf2291e2, 0x998c, 0x4cc0, 0x9a, 0xa7, 0x5e, 0x4e, 0x41, 0x28, 0x50, 0x44);

// {360FF725-66DE-4833-9EBD-6EB00C30CB8A}
DEFINE_GUID( TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_Node_IsMemberOfCluster,
0x360ff725, 0x66de, 0x4833, 0x9e, 0xbd, 0x6e, 0xb0, 0xc, 0x30, 0xcb, 0x8a);

// {323E1796-5285-4fed-8CC3-B50A145A7813}
DEFINE_GUID( TASKID_Minor_CheckInteroperability,
0x323e1796, 0x5285, 0x4fed, 0x8c, 0xc3, 0xb5, 0xa, 0x14, 0x5a, 0x78, 0x13);

// {786D2E6E-448A-4b83-8E90-03974528B1EE}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_CsRpcGetJoinVersionData,
0x786d2e6e, 0x448a, 0x4b83, 0x8e, 0x90, 0x3, 0x97, 0x45, 0x28, 0xb1, 0xee);

// {462C6516-C855-4622-9299-1CD2D4C27EAC}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_RpcStringBindingComposeW,
0x462c6516, 0xc855, 0x4622, 0x92, 0x99, 0x1c, 0xd2, 0xd4, 0xc2, 0x7e, 0xac);

// {73F18E00-56D9-49eb-8D9B-AFFC08186BC3}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_RpcBindingFromStringBindingW,
0x73f18e00, 0x56d9, 0x49eb, 0x8d, 0x9b, 0xaf, 0xfc, 0x8, 0x18, 0x6b, 0xc3);

// {0E041CD6-4E86-480e-A5E2-114F7C7E9B5D}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_RpcEpResolveBinding,
0xe041cd6, 0x4e86, 0x480e, 0xa5, 0xe2, 0x11, 0x4f, 0x7c, 0x7e, 0x9b, 0x5d);

// {01A61755-7ECE-41e8-A733-BF85B8CC3E2B}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_RpcBindingSetAuthInfoW,
0x1a61755, 0x7ece, 0x41e8, 0xa7, 0x33, 0xbf, 0x85, 0xb8, 0xcc, 0x3e, 0x2b);

// {3CA8DF73-8310-40a9-9429-109805A25A62}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_FindObject,
0x3ca8df73, 0x8310, 0x40a9, 0x94, 0x29, 0x10, 0x98, 0x5, 0xa2, 0x5a, 0x62);

// {0C9BF0DE-5512-44a0-B502-557C0E95416A}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_FindObject_QI,
0xc9bf0de, 0x5512, 0x44a0, 0xb5, 0x2, 0x55, 0x7c, 0xe, 0x95, 0x41, 0x6a);

// {AD611B3F-948C-41d6-9379-6D139AD7D426}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_EnumCookies_Next,
0xad611b3f, 0x948c, 0x41d6, 0x93, 0x79, 0x6d, 0x13, 0x9a, 0xd7, 0xd4, 0x26);

// {E7BF32C6-AFC1-4e65-805E-727416CD8C56}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_EnumCookies_Reset,
0xe7bf32c6, 0xafc1, 0x4e65, 0x80, 0x5e, 0x72, 0x74, 0x16, 0xcd, 0x8c, 0x56);

// {ABF39F3E-8E8B-4a46-A4DF-B9348FB7577B}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_EnumCookies_Next2,
0xabf39f3e, 0x8e8b, 0x4a46, 0xa4, 0xdf, 0xb9, 0x34, 0x8f, 0xb7, 0x57, 0x7b);

// {E834435A-71DF-4695-BA0A-88E884100559}
DEFINE_GUID( TASKID_Minor_GetUsersNodesCookies_OutOfMemory,
0xe834435a, 0x71df, 0x4695, 0xba, 0xa, 0x88, 0xe8, 0x84, 0x10, 0x5, 0x59);

// {E834435A-71DF-4695-BA0A-88E88410055a}
DEFINE_GUID( TASKID_Minor_Compare_Resources_Enum_First_Node_Is_Device_Joinable,
0xe834435a, 0x71df, 0x4695, 0xba, 0xa, 0x88, 0xe8, 0x84, 0x10, 0x5, 0x5a);

// {C841C953-E709-4d53-BD16-7ECA04EE1998}
DEFINE_GUID( TASKID_Minor_BeginTask_CoUnMarshall,
0xc841c953, 0xe709, 0x4d53, 0xbd, 0x16, 0x7e, 0xca, 0x4, 0xee, 0x19, 0x98);

// {CA8148D2-43BF-4b87-B160-8E7157B38871}
DEFINE_GUID( TASKID_Minor_BeginTask_CoCreate_ServiceManager,
0xca8148d2, 0x43bf, 0x4b87, 0xb1, 0x60, 0x8e, 0x71, 0x57, 0xb3, 0x88, 0x71);

// {C43488F6-E9F9-4d94-B916-78E876017524}
DEFINE_GUID( TASKID_Minor_BeginTask_QS_ObjectManager,
0xc43488f6, 0xe9f9, 0x4d94, 0xb9, 0x16, 0x78, 0xe8, 0x76, 0x1, 0x75, 0x24);

// {E36BE0F5-2F33-449e-95E3-537D10C38426}
DEFINE_GUID( TASKID_Minor_BeginTask_QS_NotificationManager,
0xe36be0f5, 0x2f33, 0x449e, 0x95, 0xe3, 0x53, 0x7d, 0x10, 0xc3, 0x84, 0x26);

// {4E2FBE24-E98C-4fb5-845C-173EFE7645CF}
DEFINE_GUID( TASKID_Minor_BeginTask_FindConnectionPoint,
0x4e2fbe24, 0xe98c, 0x4fb5, 0x84, 0x5c, 0x17, 0x3e, 0xfe, 0x76, 0x45, 0xcf);

// {AE4C7616-1A0E-420e-B608-4B5F8F6B7B16}
DEFINE_GUID( TASKID_Minor_BeginTask_QI_pnui,
0xae4c7616, 0x1a0e, 0x420e, 0xb6, 0x8, 0x4b, 0x5f, 0x8f, 0x6b, 0x7b, 0x16);

// {0C39239E-F590-45dc-BD61-0CFE87E11159}
DEFINE_GUID( TASKID_Minor_BeginTask_QS_ClusterConnectionManager,
0xc39239e, 0xf590, 0x45dc, 0xbd, 0x61, 0xc, 0xfe, 0x87, 0xe1, 0x11, 0x59);

// {5742FB88-7180-43f3-9969-29506E3B3BC6}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_StandardInfo,
0x5742fb88, 0x7180, 0x43f3, 0x99, 0x69, 0x29, 0x50, 0x6e, 0x3b, 0x3b, 0xc6);

// {28AEFD58-FDB7-478c-AED1-933C3DFCC4AE}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_StandardInfo_QI,
0x28aefd58, 0xfdb7, 0x478c, 0xae, 0xd1, 0x93, 0x3c, 0x3d, 0xfc, 0xc4, 0xae);

// {43527583-74CC-4abe-868D-D50EB3623316}
DEFINE_GUID( TASKID_Minor_BeginTask_GetName,
0x43527583, 0x74cc, 0x4abe, 0x86, 0x8d, 0xd5, 0xe, 0xb3, 0x62, 0x33, 0x16);

// {A99EEB3A-F6B7-453c-AFC6-5E80F5F98B85}
DEFINE_GUID( TASKID_Minor_BeginTask_LoadString,
0xa99eeb3a, 0xf6b7, 0x453c, 0xaf, 0xc6, 0x5e, 0x80, 0xf5, 0xf9, 0x8b, 0x85);

// {7DACE324-695E-48bf-8EA4-00F4DCE2FCAF}
DEFINE_GUID( TASKID_Minor_BeginTask_GetConnectionToObject_QI_m_pccs,
0x7dace324, 0x695e, 0x48bf, 0x8e, 0xa4, 0x0, 0xf4, 0xdc, 0xe2, 0xfc, 0xaf);

// {2F47A4E0-BA74-4ac0-B7D8-582A4AD2C8A0}
DEFINE_GUID( TASKID_Minor_BeginTask_QI_pccc,
0x2f47a4e0, 0xba74, 0x4ac0, 0xb7, 0xd8, 0x58, 0x2a, 0x4a, 0xd2, 0xc8, 0xa0);

// {1EEA1B8B-9D30-4cb1-99AF-43B16FDD40A8}
DEFINE_GUID( TASKID_Minor_BeginTask_CanNodeBeClustered,
0x1eea1b8b, 0x9d30, 0x4cb1, 0x99, 0xaf, 0x43, 0xb1, 0x6f, 0xdd, 0x40, 0xa8);

// {6D453A8F-7E4A-43b3-A510-6F0994A8388A}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_QI_Failed,
0x6d453a8f, 0x7e4a, 0x43b3, 0xa5, 0x10, 0x6f, 0x9, 0x94, 0xa8, 0x38, 0x8a);

// {97FEDAD7-62C6-4160-90F3-47F2DACAAA16}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_Failed,
0x97fedad7, 0x62c6, 0x4160, 0x90, 0xf3, 0x47, 0xf2, 0xda, 0xca, 0xaa, 0x16);

// {E55C3025-5801-4290-BB17-DEC11315D621}
DEFINE_GUID( TASKID_Minor_GatherResources_GetManagedResourcesEnum,
0xe55c3025, 0x5801, 0x4290, 0xbb, 0x17, 0xde, 0xc1, 0x13, 0x15, 0xd6, 0x21);

// {0F24E7FD-4CEB-4c07-A7B6-70DFBF9F4D9B}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_Next,
0xf24e7fd, 0x4ceb, 0x4c07, 0xa7, 0xb6, 0x70, 0xdf, 0xbf, 0x9f, 0x4d, 0x9b);

// {E79F53D5-4EAF-40f8-9DB3-0C562FBF1F97}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_GetUID,
0xe79f53d5, 0x4eaf, 0x40f8, 0x9d, 0xb3, 0xc, 0x56, 0x2f, 0xbf, 0x1f, 0x97);

// {823C1D94-D130-4b77-8FA5-0E4E8F4048A1}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_FindObject,
0x823c1d94, 0xd130, 0x4b77, 0x8f, 0xa5, 0xe, 0x4e, 0x8f, 0x40, 0x48, 0xa1);

// {357189DE-6009-489e-AE6D-746256ED56D5}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_FindObject_QI_pccmriNew,
0x357189de, 0x6009, 0x489e, 0xae, 0x6d, 0x74, 0x62, 0x56, 0xed, 0x56, 0xd5);

// {79A880DB-316C-4c2d-8D02-E281125CB89D}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_FindObject_QI_pgd,
0x79a880db, 0x316c, 0x4c2d, 0x8d, 0x2, 0xe2, 0x81, 0x12, 0x5c, 0xb8, 0x9d);

// {23C1373D-6471-431c-AD07-2B29605CCAB8}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_Gather,
0x23c1373d, 0x6471, 0x431c, 0xad, 0x7, 0x2b, 0x29, 0x60, 0x5c, 0xca, 0xb8);

// {583B3111-A81F-4951-8B2C-2C9356469313}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_IsQuorumCapable,
0x583b3111, 0xa81f, 0x4951, 0x8b, 0x2c, 0x2c, 0x93, 0x56, 0x46, 0x93, 0x13);

// {B487E965-B64F-4c29-9982-CFF8856EE7BD}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_Next,
0xb487e965, 0xb64f, 0x4c29, 0x99, 0x82, 0xcf, 0xf8, 0x85, 0x6e, 0xe7, 0xbd);

// {73BA6A91-294B-4446-B16D-99A98F59EAD4}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_GetSize,
0x73ba6a91, 0x294b, 0x4446, 0xb1, 0x6d, 0x99, 0xa9, 0x8f, 0x59, 0xea, 0xd4);

// {A305BEFF-5BA8-40ec-BD14-021AECD4C163}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_SetNEWQuorumedDevice,
0xa305beff, 0x5ba8, 0x40ec, 0xbd, 0x14, 0x2, 0x1a, 0xec, 0xd4, 0xc1, 0x63);

// {59720E26-9517-455d-810A-22F6ED7764BA}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_SetOLDQuorumedDevice,
0x59720e26, 0x9517, 0x455d, 0x81, 0xa, 0x22, 0xf6, 0xed, 0x77, 0x64, 0xba);

// {DBD77FC5-7E1B-43fc-985D-3E4352993682}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_QI_peccp,
0xdbd77fc5, 0x7e1b, 0x43fc, 0x98, 0x5d, 0x3e, 0x43, 0x52, 0x99, 0x36, 0x82);

// {82879908-860B-491e-AB76-25985BBE87F2}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_GetName,
0x82879908, 0x860b, 0x491e, 0xab, 0x76, 0x25, 0x98, 0x5b, 0xbe, 0x87, 0xf2);

// {D322C829-070F-417b-BB9F-04C7092734AA}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_FormatMessage,
0xd322c829, 0x70f, 0x417b, 0xbb, 0x9f, 0x4, 0xc7, 0x9, 0x27, 0x34, 0xaa);

// {7AE1050F-2A8D-4b71-AF98-BD5FC6983A1E}
DEFINE_GUID( TASKID_Minor_GatherResources_Failed,
0x7ae1050f, 0x2a8d, 0x4b71, 0xaf, 0x98, 0xbd, 0x5f, 0xc6, 0x98, 0x3a, 0x1e);

// {5EA64338-52EC-428d-B282-869EAA1F1D40}
DEFINE_GUID( TASKID_Minor_GatherNetworks_GetNetworksEnum,
0x5ea64338, 0x52ec, 0x428d, 0xb2, 0x82, 0x86, 0x9e, 0xaa, 0x1f, 0x1d, 0x40);

// {7090D190-E227-4b3f-AEE3-9BB8970E2171}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_Next,
0x7090d190, 0xe227, 0x4b3f, 0xae, 0xe3, 0x9b, 0xb8, 0x97, 0xe, 0x21, 0x71);

// {0FF8B900-077F-4ea2-A32D-82232F14B57F}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_GetUID,
0xff8b900, 0x77f, 0x4ea2, 0xa3, 0x2d, 0x82, 0x23, 0x2f, 0x14, 0xb5, 0x7f);

// {81B91246-E3B5-4620-8155-AB189BD734E7}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_FindObject,
0x81b91246, 0xe3b5, 0x4620, 0x81, 0x55, 0xab, 0x18, 0x9b, 0xd7, 0x34, 0xe7);

// {0F6E5610-9640-47d7-80B6-A7C41BB801DC}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_FindObject_QI_pccniLocal,
0xf6e5610, 0x9640, 0x47d7, 0x80, 0xb6, 0xa7, 0xc4, 0x1b, 0xb8, 0x1, 0xdc);

// {A36B3A00-78A9-442b-BBA2-A2219F36221E}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_FindObject_QI_pgd,
0xa36b3a00, 0x78a9, 0x442b, 0xbb, 0xa2, 0xa2, 0x21, 0x9f, 0x36, 0x22, 0x1e);

// {D0895D03-3056-475d-BE91-C875681E5906}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_Gather,
0xd0895d03, 0x3056, 0x475d, 0xbe, 0x91, 0xc8, 0x75, 0x68, 0x1e, 0x59, 0x6);

// {6CAB7D74-DFD8-4260-BB51-3B02A7A060D2}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_GetName,
0x6cab7d74, 0xdfd8, 0x4260, 0xbb, 0x51, 0x3b, 0x2, 0xa7, 0xa0, 0x60, 0xd2);

// {DDDEAA8B-6E7C-4748-8AE8-555399B02E15}
DEFINE_GUID( TASKID_Minor_GatherNetworks_EnumNetworks_FormatMessage,
0xdddeaa8b, 0x6e7c, 0x4748, 0x8a, 0xe8, 0x55, 0x53, 0x99, 0xb0, 0x2e, 0x15);

// {20E452C0-96CA-44cd-8CC3-191B5712D7F4}
DEFINE_GUID( TASKID_Minor_GatherResources_EnumResources_EnumPartitions_GetUID,
0x20e452c0, 0x96ca, 0x44cd, 0x8c, 0xc3, 0x19, 0x1b, 0x57, 0x12, 0xd7, 0xf4);

// {C31C6231-2102-4595-85BB-2D28322775F1}
DEFINE_GUID( TASKID_Minor_Marking_Quorum_Capable_Resource,
0xc31c6231, 0x2102, 0x4595, 0x85, 0xbb, 0x2d, 0x28, 0x32, 0x27, 0x75, 0xf1);

// {8AC8F1B6-2AE8-4bf0-8312-1BE754BE21EF}
DEFINE_GUID( TASKID_Minor_LoginDomain_BeginTask_Unmarshal_ITaskLoginDomainCallback,
0x8ac8f1b6, 0x2ae8, 0x4bf0, 0x83, 0x12, 0x1b, 0xe7, 0x54, 0xbe, 0x21, 0xef);

// {7B919A1D-099F-432c-BEE2-92D9CFD53C81}
DEFINE_GUID( TASKID_Minor_LoginDomain_BeginTask_Get_SAM_Compatible_Name,
0x7b919a1d, 0x99f, 0x432c, 0xbe, 0xe2, 0x92, 0xd9, 0xcf, 0xd5, 0x3c, 0x81);

// {2E3B7359-5CDE-4d9a-8B50-7EA831D09277}
DEFINE_GUID( TASKID_Minor_LoginDomain_BeginTask_Get_SAM_Compatible_Name_2,
0x2e3b7359, 0x5cde, 0x4d9a, 0x8b, 0x50, 0x7e, 0xa8, 0x31, 0xd0, 0x92, 0x77);

// {1BCD4CC1-6A98-4607-AAF5-CC1E166453DB}
DEFINE_GUID( TASKID_Minor_LoginDomain_BeginTask_LookupAccountName,
0x1bcd4cc1, 0x6a98, 0x4607, 0xaa, 0xf5, 0xcc, 0x1e, 0x16, 0x64, 0x53, 0xdb);

// {14A900DF-1C06-475a-986E-AC3523FE9A2F}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_CoCreate_ServiceManager,
0x14a900df, 0x1c06, 0x475a, 0x98, 0x6e, 0xac, 0x35, 0x23, 0xfe, 0x9a, 0x2f);

// {0BB14957-05BC-43e3-A2D0-8E5AD1B91018}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_QS_ObjectManager,
0xbb14957, 0x5bc, 0x43e3, 0xa2, 0xd0, 0x8e, 0x5a, 0xd1, 0xb9, 0x10, 0x18);

// {8614BC60-373B-4f57-B737-9C6619B8A87D}
DEFINE_GUID( TASKID_Minor_BeginTask_QS_ConnectionManager,
0x8614bc60, 0x373b, 0x4f57, 0xb7, 0x37, 0x9c, 0x66, 0x19, 0xb8, 0xa8, 0x7d);

// {12116CA5-C0EB-4073-B850-FB64A32D6BE1}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_QS_NotificationManager,
0x12116ca5, 0xc0eb, 0x4073, 0xb8, 0x50, 0xfb, 0x64, 0xa3, 0x2d, 0x6b, 0xe1);

// {706948F5-9D79-4ef7-BD29-EA6191375125}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_FindConnectionPoint,
0x706948f5, 0x9d79, 0x4ef7, 0xbd, 0x29, 0xea, 0x61, 0x91, 0x37, 0x51, 0x25);

// {4363DCC3-9770-4aef-9026-A8A46100758F}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_FindConnectionPoint_QI,
0x4363dcc3, 0x9770, 0x4aef, 0x90, 0x26, 0xa8, 0xa4, 0x61, 0x0, 0x75, 0x8f);

// {0B98DDB9-3765-40ef-A2C6-7E2E57156253}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_GetObject_StandardInfo,
0xb98ddb9, 0x3765, 0x40ef, 0xa2, 0xc6, 0x7e, 0x2e, 0x57, 0x15, 0x62, 0x53);

// {D0091DE4-55C3-4d09-B706-81EAD19120DB}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_GetObject_StandardInfo_QI_psi,
0xd0091de4, 0x55c3, 0x4d09, 0xb7, 0x6, 0x81, 0xea, 0xd1, 0x91, 0x20, 0xdb);

// {DB1FC868-1D44-41f4-B805-9AC8FAF5C694}
DEFINE_GUID( TASKID_Minor_GatherNodeInfo_GetName,
0xdb1fc868, 0x1d44, 0x41f4, 0xb8, 0x5, 0x9a, 0xc8, 0xfa, 0xf5, 0xc6, 0x94);

// {37F7C8CB-23A3-4e7b-BD3A-FAB1A7F83024}
DEFINE_GUID( TASKID_Minor_BeginTask_LoadString_Connecting,
0x37f7c8cb, 0x23a3, 0x4e7b, 0xbd, 0x3a, 0xfa, 0xb1, 0xa7, 0xf8, 0x30, 0x24);

// {20926479-AA45-47a6-9DF7-E0144D5D03AB}
DEFINE_GUID( TASKID_Minor_BeginTask_GetConnectionToObject,
0x20926479, 0xaa45, 0x47a6, 0x9d, 0xf7, 0xe0, 0x14, 0x4d, 0x5d, 0x3, 0xab);

// {93DC925D-EF1A-43c0-8818-9AD21C621DF5}
DEFINE_GUID( TASKID_Minor_BeginTask_GetConnectionToObject_QI_pccs,
0x93dc925d, 0xef1a, 0x43c0, 0x88, 0x18, 0x9a, 0xd2, 0x1c, 0x62, 0x1d, 0xf5);

// {50FF0070-2123-4b7e-B16F-888784596D33}
DEFINE_GUID( TASKID_Minor_BeginTask_GetClusterNodeInfo,
0x50ff0070, 0x2123, 0x4b7e, 0xb1, 0x6f, 0x88, 0x87, 0x84, 0x59, 0x6d, 0x33);

// {FEC1CD2A-F587-4f26-B613-8156DBC80050}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_NodeInformation,
0xfec1cd2a, 0xf587, 0x4f26, 0xb6, 0x13, 0x81, 0x56, 0xdb, 0xc8, 0x0, 0x50);

// {1CAAC823-18B3-426b-8452-FBADA6A48D66}
DEFINE_GUID( TASKID_Minor_BeginTask_GetObject_NodeInformation_QI_pgd,
0x1caac823, 0x18b3, 0x426b, 0x84, 0x52, 0xfb, 0xad, 0xa6, 0xa4, 0x8d, 0x66);

// {46DBC66F-4C50-400b-A9B8-191CCF60ED11}
DEFINE_GUID( TASKID_Minor_BeginTask_GetParent,
0x46dbc66f, 0x4c50, 0x400b, 0xa9, 0xb8, 0x19, 0x1c, 0xcf, 0x60, 0xed, 0x11);

// {193CC9C7-174A-4f58-8B46-6DFA68595171}
DEFINE_GUID( TASKID_Minor_BeginTask_Gather,
0x193cc9c7, 0x174a, 0x4f58, 0x8b, 0x46, 0x6d, 0xfa, 0x68, 0x59, 0x51, 0x71);

// {421634CD-465A-4d24-81F0-66E6DE5C9458}
DEFINE_GUID( TASKID_Minor_HrCheckInteroperability_GetBindingString,
0x421634cd, 0x465a, 0x4d24, 0x81, 0xf0, 0x66, 0xe6, 0xde, 0x5c, 0x94, 0x58);

// {C18E8743-4862-4e82-A5EE-AF0A4FECDFAB}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_GetConnectionObject,
0xc18e8743, 0x4862, 0x4e82, 0xa5, 0xee, 0xaf, 0xa, 0x4f, 0xec, 0xdf, 0xab);

// {AC33F963-060C-4b68-AAB4-33BEC30A8CA7}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_ConfigConnection_QI,
0xac33f963, 0x60c, 0x4b68, 0xaa, 0xb4, 0x33, 0xbe, 0xc3, 0xa, 0x8c, 0xa7);

// {EEF08886-323E-45ca-81F7-A7103B1B0287}
DEFINE_GUID( TASKID_Minor_HrAddJoinedNodes_GetBindingString,
0xeef08886, 0x323e, 0x45ca, 0x81, 0xf7, 0xa7, 0x10, 0x3b, 0x1b, 0x2, 0x87);

// {1B606398-7193-4a48-AFBD-98AC8BACB690}
DEFINE_GUID( TASKID_Minor_Remote_Node_Connection_Requests,
0x1b606398, 0x7193, 0x4a48, 0xaf, 0xbd, 0x98, 0xac, 0x8b, 0xac, 0xb6, 0x90);

// {26015CA7-EAE1-43f4-AC1E-718D80629E93}
DEFINE_GUID( TASKID_Minor_Requesting_Remote_Connection,
0x26015ca7, 0xeae1, 0x43f4, 0xac, 0x1e, 0x71, 0x8d, 0x80, 0x62, 0x9e, 0x93);

// {66080927-EF7D-43e1-8752-3A4D51B21FB3}
DEFINE_GUID( TASKID_Minor_Cluster_Name_Match,
0x66080927, 0xef7d, 0x43e1, 0x87, 0x52, 0x3a, 0x4d, 0x51, 0xb2, 0x1f, 0xb3);

// {FC036E7F-4785-4234-8AAA-D7F7162D39BC}
DEFINE_GUID( TASKID_Minor_CheckMembership_EnumNode_FormatMessage1,
0xfc036e7f, 0x4785, 0x4234, 0x8a, 0xaa, 0xd7, 0xf7, 0x16, 0x2d, 0x39, 0xbc);

// {F5689B48-954E-417f-AB96-C00BF2CB61AE}
DEFINE_GUID( TASKID_Minor_HrIsUserAddedNode_GetObject,
0xf5689b48, 0x954e, 0x417f, 0xab, 0x96, 0xc0, 0xb, 0xf2, 0xcb, 0x61, 0xae);

// {42162DB8-4E4A-4f26-8C82-C224F7E2B412}
DEFINE_GUID( TASKID_Minor_HrIsUserAddedNode_GetObject_QI,
0x42162db8, 0x4e4a, 0x4f26, 0x8c, 0x82, 0xc2, 0x24, 0xf7, 0xe2, 0xb4, 0x12);

// {6FB4AF3C-6304-407c-AC9D-CDB558350CF7}
DEFINE_GUID( TASKID_Minor_HrIsUserAddedNode_GetName,
0x6fb4af3c, 0x6304, 0x407c, 0xac, 0x9d, 0xcd, 0xb5, 0x58, 0x35, 0xc, 0xf7);

// {A678963B-9173-4393-B21B-0B4337B28EE2}
DEFINE_GUID( TASKID_Minor_No_Nodes_To_Process,
0xa678963b, 0x9173, 0x4393, 0xb2, 0x1b, 0xb, 0x43, 0x37, 0xb2, 0x8e, 0xe2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\nodeinformation.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      NodeInformation.h
//
//  Description:
//      CNodeInformation implementation.
//
//  Maintained By:
//      Galen barbee (GalenB) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CEnumNodeInformation;

// CNodeInformation
class
CNodeInformation:
    public IExtendObjectManager,
    public IClusCfgNodeInfo,
    public IGatherData  // internal
{
friend class CEnumNodeInformation;
private:
    // IUnknown
    LONG                    m_cRef;

    // Async/IClusNodeInfo
    BSTR                    m_bstrName;                 // Name of the node
    BOOL                    m_fHasNameChanged:1;        // If the node name was changed...
    BOOL                    m_fIsMember:1;              // If the node is a member of a cluster...
    IClusCfgClusterInfo *   m_pccci;                    // Interface to the node's cluster info (might not be the same as the cluster we are joining)
    DWORD                   m_dwHighestVersion;         //
    DWORD                   m_dwLowestVersion;          //
    DWORD                   m_dwMajorVersion;           // OS Major version.  See OSVERSIONINFOEX
    DWORD                   m_dwMinorVersion;           // OS Minor version.  See OSVERSIONINFOEX
    WORD                    m_wSuiteMask;               // Product suite mask.  See OSVERSIONINFOEX
    BYTE                    m_bProductType;             // OS product type.  See OSVERSIONINFOEX
    BSTR                    m_bstrCSDVersion;           // Service pack info.  See OSVERSIONINFOEX
    SDriveLetterMapping     m_dlmDriveLetterMapping;    // Drive letter mappings

    // IExtendObjectManager

private: // Methods
    CNodeInformation( );
    ~CNodeInformation();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgNodeInfo
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR bstrNameIn );
    STDMETHOD( IsMemberOfCluster )( void );
    STDMETHOD( GetClusterConfigInfo )( IClusCfgClusterInfo * * ppClusCfgClusterInfoOut );
    STDMETHOD( GetOSVersion )(
                DWORD * pdwMajorVersionOut,
                DWORD * pdwMinorVersionOut,
                WORD *  pwSuiteMaskOut,
                BYTE *  pbProductTypeOut,
                BSTR *  pbstrCSDVersionOut
                );
    STDMETHOD( GetClusterVersion )( DWORD * pdwNodeHighestVersion, DWORD * pdwNodeLowestVersion );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );

    // IGatherData
    STDMETHOD( Gather )( OBJECTCOOKIE cookieParentIn, IUnknown * punkIn );

    // IExtendObjectManager
    STDMETHOD( FindObject )(
                  OBJECTCOOKIE  cookieIn
                , REFCLSID      rclsidTypeIn
                , LPCWSTR       pcszNameIn
                , LPUNKNOWN *   ppunkOut
                );

}; // class CNodeInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\nodeinformation.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      NodeInformation.cpp
//
//  Description:
//      Node Information object implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "NodeInformation.h"
#include "ClusterConfiguration.h"

DEFINE_THISCLASS("CNodeInformation")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CNodeInformation::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CNodeInformation::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CNodeInformation * pmd = new CNodeInformation;
    if ( pmd != NULL )
    {
        hr = THR( pmd->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pmd->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pmd->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CNodeInformation::CNodeInformation( void )
//
//////////////////////////////////////////////////////////////////////////////
CNodeInformation::CNodeInformation( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CNodeInformation()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    // IClusCfgNodeInfo
    Assert( m_bstrName == NULL );
    Assert( m_fHasNameChanged == FALSE );
    Assert( m_fIsMember == FALSE );
    Assert( m_pccci == NULL );
    Assert( m_dwHighestVersion == 0 );
    Assert( m_dwLowestVersion == 0 );
    Assert( m_dwMajorVersion == 0 );
    Assert( m_dwMinorVersion == 0 );
    Assert( m_wSuiteMask == 0 );
    Assert( m_bProductType == 0 );
    Assert( m_bstrCSDVersion == NULL );
    Assert( m_dlmDriveLetterMapping.dluDrives[ 0 ] == 0 );

    // IExtendObjectManager

    HRETURN( hr );

} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CNodeInformation::~CNodeInformation()
//
//////////////////////////////////////////////////////////////////////////////
CNodeInformation::~CNodeInformation()
{
    TraceFunc( "" );

    if ( m_pccci != NULL )
    {
        m_pccci->Release();
    }

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    if ( m_bstrCSDVersion != NULL )
    {
        TraceSysFreeString( m_bstrCSDVersion );
    } // if:

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CNodeInformation()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgNodeInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgNodeInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgNodeInfo, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgNodeInfo
    else if ( IsEqualIID( riid, IID_IGatherData ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IGatherData, this, 0 );
        hr = S_OK;
    } // else if: IGatherData
    else if ( IsEqualIID( riid, IID_IExtendObjectManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IExtendObjectManager, this, 0 );
        hr = S_OK;
    } // else if: IExtendObjectManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CNodeInformation::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CNodeInformation::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CNodeInformation::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CNodeInformation::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release()


// ************************************************************************
//
//  IClusCfgNodeInfo
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetName(
//      BSTR * pbstrNameOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    if ( m_bstrName == NULL )
        goto UnexpectedError;

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedError:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // GetName()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::SetName(
//      LPCWSTR pcszNameIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    BSTR    bstrNewName;

    if ( pcszNameIn == NULL )
        goto InvalidArg;

    bstrNewName = TraceSysAllocString( pcszNameIn );
    if ( bstrNewName == NULL )
        goto OutOfMemory;

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_fHasNameChanged = TRUE;
    m_bstrName        = bstrNewName;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetName()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::IsMemberOfCluster( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::IsMemberOfCluster( void )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( m_fIsMember == FALSE )
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} // IsMemberOfCluster()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetClusterConfigInfo(
//      IClusCfgClusterInfo * * ppClusCfgClusterInfoOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetClusterConfigInfo(
    IClusCfgClusterInfo * * ppClusCfgClusterInfoOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr;

    if ( ppClusCfgClusterInfoOut == NULL )
        goto InvalidPointer;

    if ( m_pccci == NULL )
        goto ErrorUnexpected;

    hr = THR( m_pccci->TypeSafeQI( IClusCfgClusterInfo, ppClusCfgClusterInfoOut ) );

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

ErrorUnexpected:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;

} // GetClusterConfigInfo()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetOSVersion(
//      DWORD * pdwMajorVersionOut,
//      DWORD * pdwMinorVersionOut,
//      WORD *  pwSuiteMaskOut,
//      BYTE *  pbProductTypeOut
//      BSTR *  pbstrCSDVersionOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetOSVersion(
    DWORD * pdwMajorVersionOut,
    DWORD * pdwMinorVersionOut,
    WORD *  pwSuiteMaskOut,
    BYTE *  pbProductTypeOut,
    BSTR *  pbstrCSDVersionOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pdwMajorVersionOut == NULL
      || pdwMinorVersionOut == NULL
      || pwSuiteMaskOut == NULL
      || pbProductTypeOut == NULL
      || pbstrCSDVersionOut == NULL
       )
    {
        goto InvalidPointer;
    }

    *pdwMajorVersionOut = m_dwMajorVersion;
    *pdwMinorVersionOut  = m_dwMinorVersion;
    *pwSuiteMaskOut = m_wSuiteMask;
    *pbProductTypeOut = m_bProductType;

    *pbstrCSDVersionOut = TraceSysAllocString( m_bstrCSDVersion );
    if ( *pbstrCSDVersionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // GetOSVersion()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetClusterVersion(
//      DWORD * pdwNodeHighestVersion,
//      DWORD * pdwNodeLowestVersion
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetClusterVersion(
    DWORD * pdwNodeHighestVersion,
    DWORD * pdwNodeLowestVersion
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pdwNodeHighestVersion == NULL
      || pdwNodeLowestVersion == NULL
       )
    {
        goto InvalidPointer;
    }

    *pdwNodeHighestVersion = m_dwHighestVersion;
    *pdwNodeLowestVersion  = m_dwLowestVersion;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // GetClusterVersion()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::GetDriveLetterMappings(
//      SDriveLetterMapping * pdlmDriveLetterUsageOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )

{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    *pdlmDriveLetterUsageOut = m_dlmDriveLetterMapping;

    HRETURN( hr );

} // GetDriveLetterMappings()


//****************************************************************************
//
//  IGatherData
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNodeInformation::Gather(
//      OBJECTCOOKIE    cookieParentIn,
//      IUnknown *      punkIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::Gather(
    OBJECTCOOKIE    cookieParentIn,
    IUnknown *      punkIn
    )
{
    TraceFunc( "[IGatherData]" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;

    IServiceProvider *  psp;

    BSTR    bstrClusterName = NULL;
    BSTR    bstrClusterNameLocal = NULL;

    IUnknown *              punk  = NULL;
    IObjectManager *        pom   = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgNodeInfo *      pccni = NULL;

    //
    //  Check parameters.
    //

    if ( punkIn == NULL )
        goto InvalidArg;

    //
    //  Grab the right interface.
    //

    hr = THR( punkIn->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Gather the object manager.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    psp->Release();        // release promptly
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Gather Name
    //

    hr = THR( pccni->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrName );

    m_fHasNameChanged = FALSE;

    //
    //  Gather Is Member?
    //

    hr = STHR( pccni->IsMemberOfCluster() );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( hr == S_OK )
    {
        m_fIsMember = TRUE;
    }
    else
    {
        m_fIsMember = FALSE;
    }

    if ( m_fIsMember )
    {
        IGatherData * pgd;

        //
        //  Gather Cluster Configuration
        //

        hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( CClusterConfiguration::S_HrCreateInstance( &punk ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pgd->Gather( NULL, pccci ) );
        pgd->Release();    // release promptly
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &m_pccci ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pccci->Release();
        pccci = NULL;

    } // if: node if a member of a cluster

    //
    //  Gather OS Version
    //

    hr = THR( pccni->GetOSVersion(
                        &m_dwMajorVersion,
                        &m_dwMinorVersion,
                        &m_wSuiteMask,
                        &m_bProductType,
                        &m_bstrCSDVersion
                        ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Gather Cluster Version
    //

    hr = THR( pccni->GetClusterVersion( &m_dwHighestVersion, &m_dwLowestVersion ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Gather Drive Letter Mappings
    //

    hr = STHR( pccni->GetDriveLetterMappings( &m_dlmDriveLetterMapping ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Anything else to gather??
    //

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( bstrClusterName != NULL )
    {
        TraceSysFreeString( bstrClusterName );
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }

    HRETURN( hr );

Error:
    //
    //  On error, invalidate all data.
    //
    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
        m_bstrName = NULL;
    }
    m_fHasNameChanged = FALSE;
    m_fIsMember = FALSE;
    if ( m_pccci != NULL )
    {
        m_pccci->Release();
        m_pccci = NULL;
    }
    m_dwHighestVersion = 0;
    m_dwLowestVersion = 0;
    ZeroMemory( &m_dlmDriveLetterMapping, sizeof( m_dlmDriveLetterMapping ) );
    goto Cleanup;

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} // Gather()


// ************************************************************************
//
//  IExtendObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CNodeInformation::FindObject(
//        OBJECTCOOKIE  cookieIn
//      , REFCLSID      rclsidTypeIn
//      , LPCWSTR       pcszNameIn
//      , LPUNKNOWN *   punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNodeInformation::FindObject(
      OBJECTCOOKIE  cookieIn
    , REFCLSID      rclsidTypeIn
    , LPCWSTR       pcszNameIn
    , LPUNKNOWN *   ppunkOut
    )
{
    TraceFunc( "[IExtendObjectManager]" );

    HRESULT hr = E_UNEXPECTED;

    //
    //  Check parameters...
    //

    //  Gotta have a cookie
    if ( cookieIn == NULL )
        goto InvalidArg;

    //  We need to be representing a NodeType.
    if ( !IsEqualIID( rclsidTypeIn, CLSID_NodeType ) )
        goto InvalidArg;

    //  We need a name.
    if ( pcszNameIn == NULL )
        goto InvalidArg;

    //
    //  Save our name.
    //
    m_bstrName = TraceSysAllocString( pcszNameIn );
    if ( m_bstrName == NULL )
        goto OutOfMemory;

    //
    //  Get the pointer.
    //
    if ( ppunkOut != NULL )
    {
        hr = THR( QueryInterface( DFGUID_NodeInformation,
                                  reinterpret_cast< void ** > ( ppunkOut )
                                  ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // if: ppunkOut

    //
    //  Tell caller that the data is pending.
    //
    hr = E_PENDING;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} // FindObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\notificationmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NotificationMgr.h
//
//  Description:
//      Notification Manager implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CConnPointEnum;

// CNotificationManager
class 
CNotificationManager:
    public INotificationManager,
    public IConnectionPointContainer
{
private:
    // IUnknown
    LONG                m_cRef;     //  Reference counter

    // IConnectionPointContainer
    CConnPointEnum *    m_penumcp;  //  CP Enumerator and list

private: // Methods
    CNotificationManager( );
    ~CNotificationManager();
    STDMETHOD(Init)( );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // INotificationManager
    STDMETHOD( AddConnectionPoint )( REFIID riidIn, IConnectionPoint * pcpIn );

    // IConnectionPointContainer
    STDMETHOD( EnumConnectionPoints )( IEnumConnectionPoints **ppEnumOut );
    STDMETHOD( FindConnectionPoint )( REFIID riidIn, IConnectionPoint **ppCPOut );

}; // class CNotificationManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\notificationmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NotificationMgr.cpp
//
//  Description:
//      Notification Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ConnPointEnum.h"
#include "NotificationManager.h"
#include "CPINotifyUI.h"
#include "CPIClusCfgCallback.h"

DEFINE_THISCLASS("CNotificationManager")


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CNotificationManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CNotificationManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;
    IServiceProvider * psp;

    // Don't wrap - this can fail with E_POINTER.
    hr = CServiceManager::S_HrGetManagerPointer( &psp );
    
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, 
                                   IUnknown, 
                                   ppunkOut
                                   ) );
        psp->Release( );

    } // if: service manager
    else if ( hr == E_POINTER )
    {
        //
        //  This happens when the Service Manager is first started.
        //
        CNotificationManager * lpcc = new CNotificationManager( );
        if ( lpcc != NULL )
        {
            hr = THR( lpcc->Init( ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( lpcc->TypeSafeQI( IUnknown, ppunkOut ) );
            } // if: success

            lpcc->Release( );

        } // if: got object
        else
        {
            hr = E_OUTOFMEMORY;
        }

    } // if: service manager doesn't exist
    else
    {
        THR( hr );
    } // else:

    HRETURN( hr );

} // S_HrCreateInstance( )

//
// Constructor
//
CNotificationManager::CNotificationManager( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CNotificationManager( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNotificationManager::Init( )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNotificationManager::Init( )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    IUnknown * punk = NULL;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );  // Add one count

    // IConnectionPointContainer
    Assert( m_penumcp == NULL );

    m_penumcp = new CConnPointEnum( );
    if ( m_penumcp == NULL )
        goto OutOfMemory;

    hr = THR( m_penumcp->Init( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( CCPINotifyUI::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_penumcp->HrAddConnection( IID_INotifyUI, punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    hr = THR( CCPIClusCfgCallback::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_penumcp->HrAddConnection( IID_IClusCfgCallback, punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CNotificationManager::~CNotificationManager( )
//
//////////////////////////////////////////////////////////////////////////////
CNotificationManager::~CNotificationManager( )
{
    TraceFunc( "" );

    if ( m_penumcp != NULL )
    {
        m_penumcp->Release( );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CNotificationManager( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNotificationManager::QueryInterface( 
//      REFIID riid, 
//      LPVOID *ppv 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNotificationManager::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv 
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< INotificationManager * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_INotificationManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, INotificationManager, this, 0 );
        hr   = S_OK;
    } // else if: INotificationManager
    else if ( IsEqualIID( riid, IID_IConnectionPointContainer ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IConnectionPointContainer, this, 0 );
        hr   = S_OK;
    } // else if: IConnectionPointContainer

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CNotificationManager::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CNotificationManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CNotificationManager::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CNotificationManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
// INotificationManager
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CNotificationManager::AddConnectionPoint( 
//      REFIID riidIn, 
//      IConnectionPoint * pcpIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNotificationManager::AddConnectionPoint( 
    REFIID riidIn, 
    IConnectionPoint * pcpIn
    )
{
    TraceFunc( "[INotificationManager]" );

    HRESULT hr;

    hr = THR( m_penumcp->HrAddConnection( riidIn, pcpIn ) );

    HRETURN( hr );

} // AddConnectionPoint( )


// ************************************************************************
//
// IConnectionPointContainer
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CNotificationManager::EnumConnectionPoints( 
//      IEnumConnectionPoints **ppEnumOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CNotificationManager::EnumConnectionPoints( 
    IEnumConnectionPoints **ppEnumOut 
    )
{
    TraceFunc( "[IConnectionPointContainer]" );

    HRESULT hr = E_UNEXPECTED;

    if ( ppEnumOut == NULL )
        goto InvalidPointer;

    if ( m_penumcp != NULL )
    {
        hr = THR( m_penumcp->Clone( ppEnumOut ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // EnumConnectionPoints( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CNotificationManager::FindConnectionPoint( 
//      REFIID riidIn, 
//      IConnectionPoint **ppCPOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CNotificationManager::FindConnectionPoint( 
    REFIID riidIn, 
    IConnectionPoint **ppCPOut 
    )
{
    TraceFunc( "[IConnectionPointContainer]" );

    IID iid;

    HRESULT hr = E_UNEXPECTED;

    IConnectionPoint * pcp = NULL;

    if ( ppCPOut == NULL )
        goto InvalidPointer;

    hr = THR( m_penumcp->Reset( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    for ( ; ; ) // ever
    {
        if ( pcp != NULL )
        {
            pcp->Release( );
            pcp = NULL;
        }

        hr = STHR( m_penumcp->Next( 1, &pcp, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
        {
            hr = THR( CONNECT_E_NOCONNECTION );
            break;  // exit condition
        }

        hr = THR( pcp->GetConnectionInterface( &iid ) );
        if ( FAILED( hr ) )
            continue;   // ignore it

        if ( iid != riidIn )
            continue;   // not the right interface

        //
        //  Found it. Give up ownership and exit loop.
        //

        *ppCPOut = pcp;
        pcp = NULL;

        hr = S_OK;

        break;
    }

Cleanup:
    if ( pcp != NULL )
    {
        pcp->Release( );
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} // FindConnectionPoint( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-OCT-1999
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define SECURITY_WIN32

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <shlwapi.h>
#include <objbase.h>
#include <ocidl.h>
#include <olectl.h>
#include <ComCat.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h>
#include <windns.h>
#include <clusapi.h>
#include <crt\limits.h>
#include <security.h>

#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <Common.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>
#include <ObjectCookie.h>
#include <ClusCfgClient.h>
#include "ServiceManager.h"
#include <ClusCfgGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>
#include <LoadString.h>

#include "MiddleTierGuids.h"

#include "..\Wizard\resource.h"
#include <ClusCfgConstants.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constants
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\objectmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ObjectManager.h
//
//  Description:
//      Data Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CStandardInfo;

//  CObjectManager
class
CObjectManager:
    public IObjectManager
{
private:
    // IUnknown
    LONG                    m_cRef;

    // data
    ULONG                   m_cAllocSize;       //  Size of the cookie array.
    ULONG                   m_cCurrentUsed;     //  Current count used in the cookie array.
    CStandardInfo **        m_pCookies;         //  Cookie array (note: zero-th element is not used)

private: // Methods
    CObjectManager( void );
    ~CObjectManager( void );
    STDMETHOD(Init)( void );

    HRESULT
        HrSearchForExistingCookie( REFCLSID rclsidTypeIn,
                                   OBJECTCOOKIE     cookieParentIn,
                                   LPCWSTR          pcszNameIn,
                                   OBJECTCOOKIE *   pcookieOut
                                   );
    HRESULT
        HrDeleteCookie( OBJECTCOOKIE  cookieIn );
    HRESULT
        HrDeleteInstanceAndChildren( OBJECTCOOKIE cookieIn );
    HRESULT
        HrCreateNewCookie( REFCLSID        rclsidTypeIn,
                           OBJECTCOOKIE    cookieParentIn,
                           LPCWSTR         pcszNameIn,
                           OBJECTCOOKIE *  pcookieOut
                           );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IObjectManager
    STDMETHOD( FindObject )( REFCLSID             rclsidTypeIn,
                             OBJECTCOOKIE         cookieParent,
                             LPCWSTR              pcszNameIn,
                             REFCLSID             rclsidFormatIn,
                             OBJECTCOOKIE *       pcookieOut,
                             LPUNKNOWN *          ppunkOut
                             );
    STDMETHOD( GetObject )( REFCLSID              rclsidFormatIn,
                            OBJECTCOOKIE          cookieIn,
                            LPUNKNOWN *           ppunkOut
                            );
    STDMETHOD( RemoveObject )( OBJECTCOOKIE       cookieIn );
    STDMETHOD( SetObjectStatus )( OBJECTCOOKIE    cookieIn,
                                  HRESULT         hrIn
                                  );

}; // class CObjectManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\servicemanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ServiceMgr.h
//
//  Description:
//      Service Manager implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CServiceManager
class 
CServiceManager:
    public IServiceProvider
{
private:
    // IUnknown
    LONG                        m_cRef;                         //  Reference counter

    // IServiceProvider
    DWORD                       m_dwObjectManagerCookie;        //  Cookie for Object Manager
    DWORD                       m_dwTaskManagerCookie;          //  Cookie for Task Manager
    DWORD                       m_dwNotificationManagerCookie;  //  Cookie for Notification Manager
    DWORD                       m_dwConnectionManagerCookie;    //  Cookie for Connection Manager
    DWORD                       m_dwLogManagerCookie;           //  Cookie for Log Manager
    IGlobalInterfaceTable *     m_pgit;                         //  Global Interface Table

    static CRITICAL_SECTION *   sm_pcs;                         //  Access control critical section
    static BOOL                 sm_fShutDown;                   //  TRUE if process shutting down.

private: // Methods
    CServiceManager( );
    ~CServiceManager();
    STDMETHOD(Init)( );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );
    static HRESULT
        S_HrGetManagerPointer( IServiceProvider ** pspOut );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IServiceProvider
    STDMETHOD(QueryService)( REFCLSID rclsidIn, REFIID   riidIn, void **  ppvOut );

}; // class CServiceManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\standardinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      StandardInfo.cpp
//
//  Description:
//      CStandardInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "StandardInfo.h"

DEFINE_THISCLASS("CStandardInfo")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CStandardInfo::S_HrCreateInstance(
//      IUnknown **     ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStandardInfo::S_HrCreateInstance(
    IUnknown **     ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CStandardInfo * psi = new CStandardInfo;
    if ( psi != NULL )
    {
        hr = THR( psi->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( psi->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        psi->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} //*** CStandardInfo::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStandardInfo::CStandardInfo( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CStandardInfo::CStandardInfo( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CStandardInfo::CStandardInfo( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStandardInfo::CStandardInfo(
//      CLSID *      pclsidTypeIn,
//      OBJECTCOOKIE cookieParentIn,
//      BSTR         bstrNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CStandardInfo::CStandardInfo(
    CLSID *      pclsidTypeIn,
    OBJECTCOOKIE cookieParentIn,
    BSTR         bstrNameIn
    )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    THR( Init( ) );

    m_clsidType     = *pclsidTypeIn;
    m_cookieParent  = cookieParentIn;
    m_bstrName      = bstrNameIn;

    TraceFuncExit( );

} //*** CStandardInfo::CStandardInfo( ... )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::Init( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IStandardInfo
    Assert( m_clsidType == IID_NULL );
    Assert( m_cookieParent == 0 );
    Assert( m_bstrName == NULL );
    Assert( m_hrStatus == 0 );
    Assert( m_pci == NULL );
    Assert( m_pExtObjList == NULL );

    HRETURN( hr );

} //*** CStandardInfo::Init( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStandardInfo::~CStandardInfo( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CStandardInfo::~CStandardInfo( void )
{
    TraceFunc( "" );

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    if ( m_pci != NULL )
    {
        m_pci->Release( );
    }

    while ( m_pExtObjList != NULL )
    {
        ExtObjectEntry * pnext = m_pExtObjList->pNext;

        m_pExtObjList->punk->Release( );

        TraceFree( m_pExtObjList );

        m_pExtObjList = pnext;
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CStandardInfo::~CStandardInfo( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IStandardInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IStandardInfo ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IStandardInfo, this, 0 );
        hr = S_OK;
    } // else if: IStandardInfo

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CStandardInfo::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CStandardInfo::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CStandardInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CStandardInfo::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CStandardInfo::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CStandardInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} //*** CStandardInfo::Release( )



//****************************************************************************
//
//  IStandardInfo
//
//****************************************************************************



//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::GetType(
//      CLSID * pclsidTypeOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::GetType(
    CLSID * pclsidTypeOut
    )
{
    TraceFunc( "[IStandardInfo]" );

    HRESULT hr = S_OK;

    if ( pclsidTypeOut == NULL )
        goto InvalidPointer;

    CopyMemory( pclsidTypeOut, &m_clsidType, sizeof( *pclsidTypeOut ) );

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CStandardInfo::GetType( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::GetName(
//      BSTR * pbstrNameOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IStandardInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // GetName( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::SetName(
//      LPCWSTR pcszNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IStandardInfo] pcszNameIn = '%ws'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;

    BSTR    bstrNew;

    if ( pcszNameIn == NULL )
        goto InvalidArg;

    bstrNew = TraceSysAllocString( pcszNameIn );
    if ( bstrNew == NULL )
        goto OutOfMemory;

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_bstrName = bstrNew;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CStandardInfo::SetName( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::GetParent(
//      OBJECTCOOKIE * pcookieOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::GetParent(
    OBJECTCOOKIE * pcookieOut
    )
{
    TraceFunc( "[IStandardInfo]" );

    HRESULT hr = S_OK;

    if ( pcookieOut == NULL )
        goto InvalidPointer;

    *pcookieOut = m_cookieParent;

    if ( m_cookieParent == NULL )
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CStandardInfo::GetParent( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::GetStatus(
//      HRESULT * phrOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::GetStatus(
    HRESULT * phrStatusOut
    )
{
    TraceFunc( "[IStandardInfo]" );

    HRESULT hr = S_OK;

    if ( phrStatusOut == NULL )
        goto InvalidPointer;

    *phrStatusOut = m_hrStatus;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CStandardInfo::GetStatus( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStandardInfo::SetStatus(
//      HRESULT hrIn
//      )
//

//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStandardInfo::SetStatus(
    HRESULT hrIn
    )
{
    TraceFunc1( "[IStandardInfo] hrIn = %#08x", hrIn );

    HRESULT hr = S_OK;

    m_hrStatus = hrIn;

    HRETURN( hr );

} //*** CStandardInfo::SetStatus( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\standardinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      StandardInfo.h
//
//  Description:
//      CStandardInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CObjectManager;

//  Link list of extension object that are persisted.
typedef struct _ExtObjectEntry {
    struct _ExtObjectEntry *    pNext;          //  Next item in list
    CLSID                       iid;            //  Interface ID
    IUnknown *                  punk;           //  Punk to object
} ExtObjectEntry;

//  CStandardInfo
class
CStandardInfo:
    public IStandardInfo
{
friend class CObjectManager;
private:
    // IUnknown
    LONG                m_cRef;

    // IStandardInfo
    CLSID               m_clsidType;          //  Type of object
    OBJECTCOOKIE        m_cookieParent;       //  Parent of object (if any - NULL means none)
    BSTR                m_bstrName;           //  Name of object
    HRESULT             m_hrStatus;           //  Object status
    IConnectionInfo *   m_pci;                //  Connection to the object (used by Connection Manager)
    ExtObjectEntry *    m_pExtObjList;        //  List of extended objects

private: // Methods
    CStandardInfo(  void );
    CStandardInfo( CLSID *      pclsidTypeIn,
                   OBJECTCOOKIE cookieParentIn,
                   BSTR         bstrNameIn
                   );
    ~CStandardInfo( void );
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IStandardInfo
    STDMETHOD( GetType )( CLSID * pclsidTypeOut );
    STDMETHOD( GetName )( BSTR * bstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( GetParent )( OBJECTCOOKIE * pcookieOut );
    STDMETHOD( GetStatus )( HRESULT * phrStatusOut );
    STDMETHOD( SetStatus )( HRESULT hrIn );

}; // class CStandardInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\objectmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ObjectManager.cpp
//
//  Description:
//      Object Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ObjectManager.h"
#include "ConnectionInfo.h"
#include "StandardInfo.h"
#include "EnumCookies.h"

DEFINE_THISCLASS("CObjectManager")

#define COOKIE_BUFFER_GROW_SIZE 100

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  LPUNKNOWN
//  CObjectManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;
    IServiceProvider * psp;

    // Don't wrap - this can fail with E_POINTER.
    hr = CServiceManager::S_HrGetManagerPointer( &psp );

    if ( SUCCEEDED( hr ) )
    {
        hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                                   IUnknown,
                                   ppunkOut
                                   ) );
        psp->Release( );

    } // if: service manager
    else if ( hr == E_POINTER )
    {
        //
        //  This happens when the Service Manager is first started.
        //
        CObjectManager * pom = new CObjectManager( );
        if ( pom != NULL )
        {
            hr = THR( pom->Init( ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( pom->TypeSafeQI( IUnknown, ppunkOut ) );
            } // if: success

            pom->Release( );

        } // if: got object
        else
        {
            hr = E_OUTOFMEMORY;
        }

    } // if: service manager doesn't exists
    else
    {
        THR( hr );
    } // else:

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CObjectManager::CObjectManager( void )
//
//////////////////////////////////////////////////////////////////////////////
CObjectManager::CObjectManager( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();
} // CObjectManager( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CObjectManager::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    //  IObjectManager
    Assert( m_cAllocSize == 0 );
    Assert( m_cCurrentUsed == 0 );
    Assert( m_pCookies == NULL );

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CObjectManager::~CObjectManager( )
//
//////////////////////////////////////////////////////////////////////////////
CObjectManager::~CObjectManager( )
{
    TraceFunc( "" );

    if ( m_pCookies != NULL )
    {
        while ( m_cCurrentUsed != 0 )
        {
            m_cCurrentUsed --;

            if ( m_pCookies[ m_cCurrentUsed ] != NULL )
            {
                m_pCookies[ m_cCurrentUsed ]->Release( );
            }
        }

        TraceFree( m_pCookies );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
} // ~CObjectManager( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CObjectManager::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< LPUNKNOWN >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IObjectManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IObjectManager, this, 0 );
        hr   = S_OK;
    } // else if: IObjectManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );
}

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CObjectManager::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CObjectManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CObjectManager::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CObjectManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
//  IObjectManager
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CObjectManager::FindObject(
//      REFCLSID            rclsidTypeIn,
//      OBJECTCOOKIE        cookieParentIn,
//      LPCWSTR             pcszNameIn,
//      REFCLSID            rclsidFormatIn,
//      OBJECTCOOKIE *      cookieOut,
//      LPUNKNOWN *         punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::FindObject(
    REFCLSID            rclsidTypeIn,
    OBJECTCOOKIE        cookieParentIn,
    LPCWSTR             pcszNameIn,
    REFCLSID            rclsidFormatIn,
    OBJECTCOOKIE *      pcookieOut,
    LPUNKNOWN *         ppunkOut
    )
{
    TraceFunc( "[IObjectManager]" );

    ExtObjectEntry * pentry;

    HRESULT hr = E_UNEXPECTED;

    OBJECTCOOKIE cookie = 0;

    CStandardInfo *  pcsi = NULL;      // don't free

    BOOL    fTempCookie = FALSE;

    CEnumCookies *          pcec = NULL;
    IUnknown *              punk = NULL;
    IExtendObjectManager *  peom = NULL;

    //
    //  Check to see if we already have an object.
    //

    if ( pcszNameIn != NULL )
    {
        hr = STHR( HrSearchForExistingCookie( rclsidTypeIn, cookieParentIn, pcszNameIn, &cookie ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
        {
            hr = THR( HrCreateNewCookie( rclsidTypeIn, cookieParentIn, pcszNameIn, &cookie ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            pcsi = m_pCookies[ cookie ];
            Assert( pcsi != NULL );
        }
        else if ( hr == S_OK )
        {
            //
            //  Found an existing cookie.
            //

            if ( pcookieOut != NULL )
            {
                *pcookieOut = cookie;
            }

            if ( ppunkOut != NULL )
            {
                pcsi = m_pCookies[ cookie ];

                //
                //  Is the object still in an failed state or still pending?
                //

                if ( FAILED( pcsi->m_hrStatus ) )
                {
                    hr = pcsi->m_hrStatus;
                    goto Cleanup;
                }

                //
                //  Retrieve the requested format.
                //

                hr = THR( GetObject( rclsidFormatIn, cookie, ppunkOut ) );
                //  we always jump to cleanup. No need to check hr here.

                goto Cleanup;
            }

        }
        else
        {
            //
            //  Unexpected error_success - now what?
            //
            Assert( !hr );
            goto Cleanup;
        }

    } // if: named object
    else
    {
        Assert( pcsi == NULL );
    }

    //
    //  Create a new object.
    //

    if ( IsEqualIID( rclsidFormatIn, IID_NULL )
      || ppunkOut == NULL
       )
    {
        //
        //  No-op.
        //
        hr = S_OK;
    }
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_StandardInfo ) )
    {
        hr = THR( pcsi->QueryInterface( DFGUID_StandardInfo,
                                        reinterpret_cast< void ** >( ppunkOut )
                                        ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_ConnectionInfoFormat ) )
    {
        if ( pcsi->m_pci != NULL )
        {
            *ppunkOut = TraceInterface( L"CConnectionInfo!ObjectManager", IConnectionInfo, pcsi->m_pci, 0 );
            (*ppunkOut)->AddRef( );
            hr = S_OK;
        }
        else
        {
            hr = THR( CConnectionInfo::S_HrCreateInstance( &punk,
                                                           pcsi->m_cookieParent
                                                           ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( punk->TypeSafeQI( IConnectionInfo,
                                        &pcsi->m_pci
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( punk->QueryInterface( IID_IConnectionInfo,
                                            reinterpret_cast< void ** >( ppunkOut )
                                            ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }
    }
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_EnumCookies ) )
    {
        ULONG   cIter;

        //
        //  Create a new cookie enumerator.
        //

        pcec = new CEnumCookies;
        if ( pcec == NULL )
            goto OutOfMemory;

        //
        //  Initialize the enumerator. This also cause an AddRef( ).
        //

        hr = THR( pcec->Init( ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  See who matches our citeria.
        //

        pcec->m_cIter = 0;

        for( cIter = 1; cIter < m_cCurrentUsed; cIter ++ )
        {
            pcsi = m_pCookies[ cIter ];

            if ( pcsi != NULL )
            {
                if ( rclsidTypeIn == IID_NULL
                  || pcsi->m_clsidType == rclsidTypeIn
                   )
                {
                    if ( cookieParentIn == NULL
                      || pcsi->m_cookieParent == cookieParentIn
                       )
                    {
                        if ( ( pcszNameIn == NULL )
                          ||    ( ( pcsi->m_bstrName != NULL )
                               && ( StrCmpI( pcsi->m_bstrName, pcszNameIn ) == 0 )
                                )
                           )
                        {
                            //
                            //  Match!
                            //
                            pcec->m_cIter ++;

                        } // if: names match

                    } // if: parents match

                } // if: match parent and type

            } // if: valid element

        } // for: cIter

        if ( pcec->m_cIter == 0 )
            goto ErrorNotFound;

        //
        //  Alloc an array to hold the cookies.
        //

        pcec->m_pList = (OBJECTCOOKIE*) TraceAlloc( HEAP_ZERO_MEMORY, pcec->m_cIter * sizeof(OBJECTCOOKIE) );
        if ( pcec->m_pList == NULL )
            goto OutOfMemory;

        pcec->m_cAlloced = pcec->m_cIter;
        pcec->m_cIter = 0;

        for( cIter = 1; cIter < m_cCurrentUsed; cIter ++ )
        {
            pcsi = m_pCookies[ cIter ];

            if ( pcsi != NULL )
            {
                if ( rclsidTypeIn == IID_NULL
                  || pcsi->m_clsidType == rclsidTypeIn
                   )
                {
                    if ( cookieParentIn == NULL
                      || pcsi->m_cookieParent == cookieParentIn
                      )
                    {
                        if ( ( pcszNameIn == NULL )
                          ||    ( ( pcsi->m_bstrName != NULL )
                               && ( StrCmpI( pcsi->m_bstrName, pcszNameIn ) == 0 )
                                )
                           )
                        {
                            //
                            //  Match!
                            //

                            pcec->m_pList[ pcec->m_cIter ] = cIter;

                            pcec->m_cIter ++;

                        } // if: names match

                    } // if: parents match

                } // if: match parent and type

            } // if: valid element

        } // for: cIter

        Assert( pcec->m_cIter != 0 );
        pcec->m_cCookies = pcec->m_cIter;
        pcec->m_cIter = 0;

        //
        //  Grab the inteface on the way out.
        //

        hr = THR( pcec->QueryInterface( IID_IEnumCookies,
                                        reinterpret_cast< void ** >( ppunkOut )
                                        ) );
        if ( FAILED( hr ) )
            goto Cleanup;

    }
    else
    {
        //
        //  Check for extension formats.
        //

        //
        //  See if the format already exists for this cookie.
        //

        if ( punk != NULL )
        {
            punk->Release( );
            punk = NULL;
        }

        if ( pcsi != NULL )
        {
            for( pentry = pcsi->m_pExtObjList; pentry != NULL; pentry = pentry->pNext )
            {
                if ( pentry->iid == rclsidFormatIn )
                {
                    hr = THR( pentry->punk->QueryInterface( rclsidFormatIn,
                                                            reinterpret_cast< void ** >( &punk )
                                                            ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    break; // exit loop
                }

            } // for: pentry

        } // if: have cookie
        else
        {
            //
            //  Create a temporary cookie.
            //

            Assert( pcszNameIn == NULL );

            hr = THR( HrCreateNewCookie( IID_NULL, cookieParentIn, NULL, &cookie ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            fTempCookie = TRUE;

            Assert( pcsi == NULL );

        } // else: need a temporary cookie

        if ( punk == NULL )
        {
            //
            //  Possibly a new or externally object, try creating it and querying.
            //

            hr = THR( HrCoCreateInternalInstance( rclsidFormatIn,
                                                  NULL,
                                                  CLSCTX_ALL,
                                                  TypeSafeParams( IExtendObjectManager, &peom )
                                                  ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            Assert( punk == NULL );
            // Can't wrap with THR because it can return E_PENDING.
            hr = peom->FindObject( cookie,
                                   rclsidTypeIn,
                                   pcszNameIn,
                                   &punk
                                   );
            if ( hr == E_PENDING )
            {
                // ignore
            }
            else if ( FAILED( hr ) )
            {
                THR( hr );
                goto Cleanup;
            }

            if ( fTempCookie )
            {
                (m_pCookies[ cookie ])->Release( );
                m_pCookies[ cookie ] = NULL;
            }
            else
            {
                //
                //  Keep track of the format (if extension wants)
                //

                if (  (  ( SUCCEEDED( hr )
                        && hr != S_FALSE
                         )
                     || hr == E_PENDING
                      )
                  && punk != NULL
                  && pcsi != NULL
                   )
                {
                    pentry = (ExtObjectEntry *) TraceAlloc( 0, sizeof(ExtObjectEntry) );
                    if ( pentry == NULL )
                        goto OutOfMemory;

                    pentry->iid   = rclsidFormatIn;
                    pentry->pNext = pcsi->m_pExtObjList;
                    pentry->punk  = punk;
                    pentry->punk->AddRef( );

                    pcsi->m_pExtObjList = pentry;   //  update header of list (LIFO)
                    pcsi->m_hrStatus    = hr;       //  update status
                }

            } // else: persistent cookie

            if ( SUCCEEDED( hr ) )
            {
                //  Give up ownership
                *ppunkOut = punk;
                punk = NULL;
            }

        } // if: creating new object

    } // else: possible extension format

    //
    //  Save stuff for the caller.
    //

    if ( pcookieOut != NULL )
    {
        *pcookieOut = cookie;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( peom != NULL )
    {
        peom->Release( );
    }
    if ( pcec != NULL )
    {
        pcec->Release( );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

ErrorNotFound:
    // The error text is better than the coding value.
    hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
    goto Cleanup;

} // FindObject( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CObjectManager::GetObject(
//      REFCLSID        rclsidFormatIn,
//      OBJECTCOOKIE    cookieIn,
//      LPUNKNOWN *     ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::GetObject(
    REFCLSID        rclsidFormatIn,
    OBJECTCOOKIE    cookieIn,
    LPUNKNOWN *     ppunkOut
    )
{
    TraceFunc( "[IObjectManager]" );

    CStandardInfo * pcsi;
    ExtObjectEntry * pentry;

    HRESULT hr = E_UNEXPECTED;

    IUnknown *             punk = NULL;
    IExtendObjectManager * peom = NULL;

    //
    //  Check parameters
    //
    if ( cookieIn == 0 || cookieIn >= m_cCurrentUsed )
        goto InvalidArg;

    pcsi = m_pCookies[ cookieIn ];
    if ( pcsi == NULL )
        goto ErrorNotFound;

    //
    //  Create the request format object.
    //

    if ( IsEqualIID( rclsidFormatIn, IID_NULL )
      || ppunkOut == NULL
       )
    {
        //
        //  No-op.
        //
        hr = S_OK;
    }
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_StandardInfo ) )
    {
        hr = THR( pcsi->QueryInterface( DFGUID_StandardInfo,
                                        reinterpret_cast< void ** >( ppunkOut )
                                        ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }
    else if ( IsEqualIID( rclsidFormatIn, DFGUID_ConnectionInfoFormat ) )
    {
        if ( pcsi->m_pci != NULL )
        {
            *ppunkOut = pcsi->m_pci;
            (*ppunkOut)->AddRef( );
            hr = S_OK;
        }
        else
        {
            hr = THR( CConnectionInfo::S_HrCreateInstance( &punk,
                                                           pcsi->m_cookieParent
                                                           ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( punk->TypeSafeQI( IConnectionInfo,
                                        &pcsi->m_pci
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( punk->QueryInterface( IID_IConnectionInfo,
                                            reinterpret_cast< void ** >( ppunkOut )
                                            ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }
    }
    else
    {
        //
        //  See if the format already exists for this cookie.
        //

        if ( punk != NULL )
        {
            punk->Release( );
            punk = NULL;
        }

        for( pentry = pcsi->m_pExtObjList; pentry != NULL; pentry = pentry->pNext )
        {
            if ( pentry->iid == rclsidFormatIn )
            {
                hr = THR( pentry->punk->QueryInterface( rclsidFormatIn,
                                                        reinterpret_cast< void ** >( &punk )
                                                        ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                break; // exit loop
            }

        } // for: pentry

        if ( punk == NULL )
            goto ErrorNotFound;

        //  Give up ownership
        *ppunkOut = punk;
        punk = NULL;

    } // else: external?

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( peom != NULL )
    {
        peom->Release( );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

ErrorNotFound:
    hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
    goto Cleanup;
#if 0
OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
#endif

} // GetObject( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CObjectManager::RemoveObject(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::RemoveObject(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[IObjectManager]" );

    HRESULT hr = E_UNEXPECTED;
    CStandardInfo * pcsi;

    BOOL    fLocked = FALSE;

    //
    //  Check parameters
    //
    if ( cookieIn == 0 || cookieIn >= m_cCurrentUsed )
        goto InvalidArg;

    pcsi = m_pCookies[ cookieIn ];
    if ( pcsi == NULL )
        goto ErrorNotFound;

    hr = THR( HrDeleteInstanceAndChildren( cookieIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

ErrorNotFound:
    hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
    goto Cleanup;

} // RemoveObject( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CObjectManager::SetObjectStatus(
//      OBJECTCOOKIE          cookieIn,
//      HRESULT               hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjectManager::SetObjectStatus(
    OBJECTCOOKIE    cookieIn,
    HRESULT         hrIn
    )
{
    TraceFunc( "[IObjectManager]" );

    HRESULT hr = S_OK;
    CStandardInfo * pcsi;

    //
    //  Check parameters
    //

    if ( cookieIn == 0 || cookieIn >= m_cCurrentUsed )
        goto InvalidArg;

    pcsi = m_pCookies[ cookieIn ];
    if ( pcsi == NULL )
        goto ErrorNotFound;

    //
    //  Update the status.
    //

    pcsi->m_hrStatus = hrIn;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

ErrorNotFound:
    hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
    goto Cleanup;

} // SetObjectStatus( )


//****************************************************************************
//
//  Privates
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CObjectManager::HrDeleteCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::HrDeleteCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc1( "cookieIn = %#X", cookieIn );

    HRESULT hr = S_OK;

    CStandardInfo * pcsi;

    Assert( cookieIn != 0 && cookieIn < m_cCurrentUsed );

    pcsi = m_pCookies[ cookieIn ];
    Assert( pcsi != NULL );
    pcsi->Release( );
    m_pCookies[ cookieIn ] = NULL;

    HRETURN( hr );

} // HrDeleteCookie( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CObjectManager::HrSearchForExistingCookie(
//      OBJECTCOOKIE cookieIn,
//      LPUNKNOWN ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::HrSearchForExistingCookie(
    REFCLSID        rclsidTypeIn,
    OBJECTCOOKIE    cookieParentIn,
    LPCWSTR         pcszNameIn,
    OBJECTCOOKIE *  pcookieOut
    )
{
    TraceFunc( "" );

    Assert( pcszNameIn != NULL );
    Assert( pcookieOut != NULL );

    HRESULT hr = S_FALSE;
    ULONG   idx;

    CStandardInfo * pcsi;

    //
    //  Search the list.
    //
    for( idx = 1; idx < m_cCurrentUsed; idx ++ )
    {
        pcsi = m_pCookies[ idx ];

        if ( pcsi != NULL )
        {
            if ( pcsi->m_cookieParent == cookieParentIn          // matching parents
              && IsEqualIID( pcsi->m_clsidType, rclsidTypeIn )   // matching types
              && StrCmpI( pcsi->m_bstrName, pcszNameIn ) == 0    // matching names
               )
            {
                //
                //  Found a match.
                //

                *pcookieOut = idx;
                hr = S_OK;

                break;  // exit loop

            } // if: match

        } // if: cookie exists

    } // while: pcsi

    HRETURN( hr );

} // HrSearchForExistingCookie( )


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CObjectManager::HrDeleteInstanceAndChildren(
//      OBJECTCOOKIE   pcsiIn
//      )
//
//  Notes:
//      This should be called while the ListLock is held!
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::HrDeleteInstanceAndChildren(
    OBJECTCOOKIE   cookieIn
    )
{
    TraceFunc1( "cookieIn = %#X", cookieIn );

    ULONG   idx;
    CStandardInfo * pcsi;

    HRESULT hr = S_OK;

    hr = THR( HrDeleteCookie( cookieIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    for ( idx = 1; idx < m_cCurrentUsed; idx ++ )
    {
        pcsi = m_pCookies[ idx ];

        if ( pcsi != NULL
          && pcsi->m_cookieParent == cookieIn )
        {
            hr = THR( HrDeleteInstanceAndChildren( idx ) );
            if ( FAILED( hr ) )
                goto Cleanup;

        } // if:

    } // while:

Cleanup:
    HRETURN( hr );

} // HrDeleteInstanceAndChildren( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CObjectManager::HrCreateNewCookie(
//      REFCLSID        rclsidTypeIn
//      OBJECTCOOKIE    cookieParentIn,
//      BSTR            pcszNameIn,
//      OBJECTCOOKIE *  pcookieOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CObjectManager::HrCreateNewCookie(
    REFCLSID        rclsidTypeIn,
    OBJECTCOOKIE    cookieParentIn,
    LPCWSTR         pcszNameIn,
    OBJECTCOOKIE *  pcookieOut
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    CStandardInfo * pcsi = NULL;

    Assert( pcookieOut != NULL );

    *pcookieOut = 0;

    //
    //  Create some space for it.
    //

    if ( m_cCurrentUsed == m_cAllocSize )
    {
        CStandardInfo ** pnew = (CStandardInfo **) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(CStandardInfo *) * ( m_cAllocSize + COOKIE_BUFFER_GROW_SIZE ) );
        if ( pnew == NULL )
            goto OutOfMemory;

        if ( m_pCookies != NULL )
        {
            CopyMemory( pnew, m_pCookies, sizeof(CStandardInfo *) * m_cCurrentUsed );
            TraceFree( m_pCookies );
        }

        m_pCookies = pnew;

        m_cAllocSize += COOKIE_BUFFER_GROW_SIZE;

        if ( m_cCurrentUsed == 0 )
        {
            //
            //  Always skip zero.
            //
            m_cCurrentUsed = 1;
        }
    }

    pcsi = new CStandardInfo( );
    if ( pcsi == NULL )
        goto OutOfMemory;

    hr = THR( pcsi->Init( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    m_pCookies[ m_cCurrentUsed ] = pcsi;

    //
    //  Initialize the rest of the structure.
    //

    pcsi->m_cookieParent = cookieParentIn;
    pcsi->m_hrStatus     = E_PENDING;

    CopyMemory( &pcsi->m_clsidType, &rclsidTypeIn, sizeof( pcsi->m_clsidType ) );

    if ( pcszNameIn != NULL )
    {
        pcsi->m_bstrName = TraceSysAllocString( pcszNameIn );
        if ( pcsi->m_bstrName == NULL )
        {
            m_cCurrentUsed --;
            goto OutOfMemory;
        } // if: out of memory
    }

    Assert( pcsi->m_pci == NULL );
    Assert( pcsi->m_pExtObjList == NULL );

    //
    //  Keep it around and return SUCCESS!
    //

    pcsi = NULL;
    *pcookieOut = m_cCurrentUsed;
    m_cCurrentUsed ++;
    hr  = S_OK;

Cleanup:
    if ( pcsi != NULL )
    {
        pcsi->Release( );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // HrCreateNewCookie( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskanalyzecluster.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeCluster.cpp
//
//  Description:
//      CTaskAnalyzeCluster implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskAnalyzeCluster.h"
#include "ManagedDevice.h"
#include <nameutil.h>

// For CsRpcGetJoinVersionData() and constants like JoinVersion_v2_0_c_ifspec
#include <ClusRPC.h>
#include <ClusVerp.h>

DEFINE_THISCLASS( "CTaskAnalyzeCluster" )


//
//  Failure code.
//

#define SSR_ANALYSIS_FAILED( _major, _minor, _hr ) \
    {   \
        HRESULT hrTemp; \
        BSTR    bstrNotification = NULL;    \
        THR( HrLoadStringIntoBSTR( g_hInstance, IDS_ERR_ANALYSIS_FAILED_TRY_TO_REANALYZE, &bstrNotification ) ); \
        hrTemp = THR( SendStatusReport( NULL, _major, _minor, 0, 1, 1, _hr, bstrNotification, NULL, NULL ) );   \
        TraceSysFreeString( bstrNotification ); \
        if ( FAILED( hrTemp ) ) \
        {   \
            _hr = hrTemp;   \
        }   \
    }

//****************************************************************************
//
//  Constants
//
//****************************************************************************

#define CHECKING_TIMEOUT    90 // seconds

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CTaskAnalyzeCluster * ptac = new CTaskAnalyzeCluster;
    if ( ptac != NULL )
    {
        hr = THR( ptac->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( ptac->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        ptac->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskAnalyzeCluster::CTaskAnalyzeCluster( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskAnalyzeCluster::CTaskAnalyzeCluster( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskAnalyzeCluster::CTaskAnalyzeCluster()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    // IDoTask / ITaskAnalyzeCluster
    Assert( m_cookieCompletion == 0 );
    Assert( m_pcccb == NULL );
    Assert( m_pcookies == NULL );
    Assert( m_cNodes == 0 );
    Assert( m_event == NULL );
    Assert( m_cookieCluster == NULL );
    Assert( m_fJoiningMode == FALSE );
    Assert( m_cUserNodes == 0 );
    Assert( m_pcookiesUser == NULL );

    Assert( m_pnui == NULL );
    Assert( m_pom == NULL );
    Assert( m_ptm == NULL );
    Assert( m_pcm == NULL );
    Assert( m_fStop == false );

    // INotifyUI
    Assert( m_cSubTasksDone == 0 );
    Assert( m_hrStatus == 0 );

    hr = HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName );

    HRETURN( hr );

} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskAnalyzeCluster::~CTaskAnalyzeCluster( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskAnalyzeCluster::~CTaskAnalyzeCluster( void )
{
    TraceFunc( "" );

    // m_cRef

    // m_cookieCompletion

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pcookies != NULL )
    {
        THR( HrFreeCookies() );
    }

    // m_cCookies
    // m_cNodes

    if ( m_event != NULL )
    {
        CloseHandle( m_event );
    }

    // m_cookieCluster

    TraceMoveFromMemoryList( m_bstrClusterName, g_GlobalMemoryList );
    TraceSysFreeString( m_bstrClusterName );

    TraceSysFreeString( m_bstrNodeName );

    // m_fJoiningMode
    // m_cUserNodes

    if ( m_pcookiesUser != NULL )
    {
        TraceFree( m_pcookiesUser );
    }

    if ( m_pnui != NULL )
    {
        m_pnui->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    if ( m_ptm != NULL )
    {
        m_ptm->Release();
    }

    if ( m_pcm != NULL )
    {
        m_pcm->Release();
    } // if:

    TraceSysFreeString( m_bstrQuorumUID );

    // m_cSubTasksDone
    // m_hrStatus

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskAnalyzeCluster::~CTaskAnalyzeCluster()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskAnalyzeCluster * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskAnalyzeCluster ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskAnalyzeCluster, this, 0 );
        hr = S_OK;
    } // else if: ITaskAnalyzeCluster
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr = S_OK;
    } // else if: IDoTask
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgCallback
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
        hr = S_OK;
    } // else if: INotifyUI

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskAnalyzeCluster::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CTaskAnalyzeCluster::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskAnalyzeCluster::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CTaskAnalyzeCluster::AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CTaskAnalyzeCluster::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskAnalyzeCluster::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CTaskAnalyzeCluster::Release()


// ************************************************************************
//
// IDoTask / ITaskAnalyzeCluster
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::BeginTask( void );
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;

    DWORD   dwCookie = 0;

    IServiceProvider *          psp  = NULL;
    IConnectionPointContainer * pcpc = NULL;
    IConnectionPoint *          pcp  = NULL;

    TraceInitializeThread( L"TaskAnalyzeCluster" );

    //
    //  Gather the managers we need to complete the task.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_CoCreate_Service_Manager, hr );
        goto Cleanup;
    }

    Assert( m_pnui == NULL );
    Assert( m_ptm == NULL );
    Assert( m_pom == NULL );

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_QueryService_Notification_Manager, hr );
        goto Cleanup;
    }

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_NotificationMan_FindConnectionPoint, hr );
        goto Cleanup;
    }

    pcp = TraceInterface( L"CTaskAnalyzeCluster!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &m_pnui ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_NotificationMan_FindConnectionPoint_QI_INotifyUI, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &m_ptm ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_QueryService_TaskManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &m_pom ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_QueryService_ObjectManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager, IConnectionManager, &m_pcm ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_BeginTask_QueryService_ConnectionManager, hr );
        goto Cleanup;
    } // if:

    //
    //  Release the Service Manager.
    //

    psp->Release();
    psp = NULL;

    //
    //  Create an event to wait upon.
    //

    m_event = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_event == NULL )
        goto Win32Error;

    //
    //  Register with the Notification Manager to get notified.
    //

    Assert( m_cCookies == 0 && m_pcookies == NULL && m_cSubTasksDone == 0 );
    hr = THR( pcp->Advise( static_cast< INotifyUI * >( this ), &dwCookie ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_BeginTask_Advise, hr );
        goto Cleanup;
    }

    //
    //  Wait for the cluster connection to stablize.
    //

    hr = STHR( HrWaitForClusterConnection() );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    Assert( m_bstrClusterName != NULL );

    //
    //  Tell the UI layer we are starting this task.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Establish_Connection,
                                TASKID_Minor_Update_Progress,
                                0,
                                CHECKING_TIMEOUT,
                                0,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Count the number of nodes to be analyzed.
    //

    hr = STHR( HrCountNumberOfNodes() );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    //
    //  Create separate tasks to gather node information.
    //

    hr = STHR( HrCreateSubTasksToGatherNodeInfo() );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    //
    //  Tell the UI layer we have completed this task.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Establish_Connection,
                                TASKID_Minor_Update_Progress,
                                0,
                                CHECKING_TIMEOUT,
                                CHECKING_TIMEOUT,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Create separate tasks to gather node resources and networks.
    //

    hr = STHR( HrCreateSubTasksToGatherNodeResourcesAndNetworks() );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    //
    //  Count the number of nodes to be analyzed again. TaskGatherInformation
    //  will delete the cookies of unresponsive nodes.
    //

    hr = STHR( HrCountNumberOfNodes() );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

    //
    //  Create the feasibility task.
    //

    hr = STHR( HrCheckClusterFeasibility() );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( FAILED( m_hrStatus ) )
    {
        hr = THR( m_hrStatus );
        goto Cleanup;
    }

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        HRESULT hr2;

        hr2 = THR( pcp->Unadvise( dwCookie ) );
        if ( FAILED( hr2 ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_Unadvise, hr2 );
        }

        pcp->Release();
    }

    if ( m_cookieCompletion != 0 )
    {
        if ( m_pom != NULL )
        {
            HRESULT hr2;
            IUnknown * punk;
            hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieCompletion, &punk ) );
            if ( SUCCEEDED( hr2 ) )
            {
                IStandardInfo * psi;

                hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
                punk->Release();

                if ( SUCCEEDED( hr2 ) )
                {
                    hr2 = THR( psi->SetStatus( hr ) );
                    psi->Release();
                }
                else
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_SetStatus, hr2 );
                }
            }
            else
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject, hr2 );
            }
        }

        if ( m_pnui != NULL )
        {
            //
            //  Have the notification manager signal the completion cookie.
            //
            HRESULT hr2 = THR( m_pnui->ObjectChanged( m_cookieCompletion ) );
            if ( FAILED( hr2 ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_ObjectChanged, hr2 );
            }
        }

        m_cookieCompletion = 0;
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
    SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_Win32Error, hr );
    goto Cleanup;

} //*** CTaskAnalyzeCluster::BeginTask()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    LogMsg( L"[MT] The client has requested that this task, TaskAnalyzeCluster, be canceled" );

    m_fStop = true;

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::StopTask()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::SetJoiningMode( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::SetJoiningMode( void )
{
    TraceFunc( "[ITaskAnalyzeCluster]" );

    HRESULT hr = S_OK;

    m_fJoiningMode = TRUE;

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::SetJoiningMode()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::SetCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskAnalyzeCluster]" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::SetCookie()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::SetClusterCookie(
//      OBJECTCOOKIE    cookieClusterIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::SetClusterCookie(
    OBJECTCOOKIE    cookieClusterIn
    )
{
    TraceFunc( "[ITaskAnalyzeCluster]" );

    HRESULT hr = S_OK;

    m_cookieCluster = cookieClusterIn;

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::SetClusterCookie()


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                                   IConnectionPointContainer,
                                   &pcpc
                                   ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport(
                                  pcszNodeNameIn != NULL ? pcszNodeNameIn : m_bstrNodeName
                                , clsidTaskMajorIn
                                , clsidTaskMinorIn
                                , ulMinIn
                                , ulMaxIn
                                , ulCurrentIn
                                , hrStatusIn
                                , pcszDescriptionIn
                                , pftTimeIn
                                , pcszReferenceIn
                                ) );

    if ( m_fStop )
    {
        hr = E_ABORT;
    } // if:

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }

    if ( pcpc != NULL )
    {
        pcpc->Release();
    }

    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::SendStatusReport()


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskAnalyzeCluster::ObjectChanged(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskAnalyzeCluster::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    BOOL    b;
    ULONG   cCookies;

    HRESULT hr = S_OK;

    Assert( cookieIn != 0 );

    for ( cCookies = 0; cCookies < m_cCookies; cCookies ++ )
    {
        Assert( m_pcookies != NULL );

        if ( cookieIn == m_pcookies[ cCookies ] )
        {
            //
            //  Make sure it won't be signalled twice.
            //

            OBJECTCOOKIE cookie = m_pcookies[ cCookies ];
            m_pcookies[ cCookies ] = NULL;

            // don't care if this fails, but it really shouldn't
            THR( m_pom->RemoveObject( cookie ) );

            InterlockedIncrement( reinterpret_cast< long * >( &m_cSubTasksDone ) );

            if ( m_cSubTasksDone == m_cCookies )
            {
                //
                //  Signal the event if all the nodes are done.
                //
                b = SetEvent( m_event );
                if ( !b )
                    goto Win32Error;

            } // if: all done

        } // if: matched cookie

    } // for: cCookies

Cleanup:
    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
    SSR_ANALYSIS_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ObjectChanged_Win32Error, hr );
    goto Cleanup;

} //*** CTaskAnalyzeCluster::ObjectChanged()


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrWaitForClusterConnection( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrWaitForClusterConnection( void )
{
    TraceFunc( "" );

    HRESULT                     hrStatus;
    ULONG                       ulCurrent;
    DWORD                       sc;
    OBJECTCOOKIE *              pcookies;
    HRESULT                     hr = S_OK;
    BSTR                        bstrDescription = NULL;
    IUnknown *                  punk = NULL;
    ITaskGatherClusterInfo *    ptgci = NULL;
    IStandardInfo *             psi = NULL;

    //
    //  Tell the UI layer that we are starting to search for an existing cluster.
    //

    THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER, &bstrDescription ) );
    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Checking_For_Existing_Cluster,
                                TASKID_Minor_Update_Progress,
                                0,
                                CHECKING_TIMEOUT,
                                0,
                                S_OK,
                                bstrDescription,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Get the cluster name
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo, m_cookieCluster, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetObject_QI, hr );
        goto Cleanup;
    }

    psi = TraceInterface( L"TaskAnalyzeCluster!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Retrieve the cluster's name.
    //

    hr = THR( psi->GetName( &m_bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetName, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( m_bstrClusterName );
    TraceMoveToMemoryList( m_bstrClusterName, g_GlobalMemoryList );

    //
    //  Create a completion cookie list.
    //

    Assert( m_cCookies == 0 );
    Assert( m_pcookies == NULL );
    Assert( m_cSubTasksDone == 0 );
    m_pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( 0, sizeof( OBJECTCOOKIE ) ) );
    if ( m_pcookies == NULL )
        goto OutOfMemory;

    hr = THR( m_pom->FindObject( CLSID_ClusterCompletionCookie, m_cookieCluster, m_bstrClusterName, IID_NULL, &m_pcookies[ 0 ], &punk ) );
    Assert( punk == NULL );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_CreateCompletionCookie, hr );
        goto Cleanup;
    }

    m_cCookies = 1;

    //
    //  Create the task object.
    //

    hr = THR( m_ptm->CreateTask( TASK_GatherClusterInfo,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_CreateTask, hr );
        goto Cleanup;
    }

    Assert( punk != NULL );

    hr = THR( punk->TypeSafeQI( ITaskGatherClusterInfo, &ptgci ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_CreateTask_QI, hr );
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    //
    //  Set the object cookie in the task.
    //

    hr = THR( ptgci->SetCookie( m_cookieCluster ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_SetCookie, hr );
        goto Cleanup;
    }

    hr = THR( ptgci->SetCompletionCookie( m_pcookies[ 0 ] ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_SetCompletionCookie, hr );
        goto Cleanup;
    }

    //
    //  Submit the task.
    //

    hr = THR( m_ptm->SubmitTask( ptgci ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_SubmitTask, hr );
        goto Cleanup;
    }

    //
    //  Now wait for the work to be done.
    //

    for ( ulCurrent = 0, sc = WAIT_OBJECT_0 + 1
        ; sc != WAIT_OBJECT_0
        ;
        )
    {
        MSG msg;
        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        sc = MsgWaitForMultipleObjectsEx( 1,
                                             &m_event,
                                             1000,  // 1 second
                                             QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE,
                                             0
                                             );

        //
        //  Tell the UI layer that we are still searching for the cluster. BUT
        //  don't let the progress reach 100% if it is taking longer than
        //  CHECKING_TIMEOUT seconds.
        //
        if ( ulCurrent != CHECKING_TIMEOUT )
        {
            ulCurrent ++;
            Assert( ulCurrent != CHECKING_TIMEOUT );

            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Checking_For_Existing_Cluster,
                                        TASKID_Minor_Update_Progress,
                                        0,
                                        CHECKING_TIMEOUT,
                                        ulCurrent,
                                        S_OK,
                                        NULL,
                                        NULL,
                                        NULL
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }

    } // for: sc != WAIT_OBJECT_0

    //
    //  Cleanup the completion cookies
    //

    THR( HrFreeCookies() );

    //
    //  Check out the status of the cluster.
    //

    hr = THR( psi->GetStatus( &hrStatus ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_GetStatus, hr );
        goto Cleanup;
    }

    //
    //  If we are in joining mode and can't connect to the cluster, this
    //  should be deemed a bad thing!
    //

    if ( m_fJoiningMode )
    {
        //
        //  JOINING
        //

        switch ( hrStatus )
        {
        case S_OK:
            //
            //  This is what we are expecting.
            //
            break;

        case HR_S_RPC_S_SERVER_UNAVAILABLE:
            {
                //
                //  If we failed to connect to the server....
                //
                THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CLUSTER_NOT_FOUND, &bstrDescription ) );

                hr = THR( SendStatusReport( m_bstrClusterName,
                                            TASKID_Major_Checking_For_Existing_Cluster,
                                            TASKID_Minor_Cluster_Not_Found,
                                            0,
                                            CHECKING_TIMEOUT,
                                            CHECKING_TIMEOUT,
                                            HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ),
                                            bstrDescription,
                                            NULL,
                                            NULL
                                            ) );

                hr = THR( HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) );
            }
            goto Cleanup;

        default:
            {
                //
                //  If something else goes wrong, stop.
                //
                hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                                IDS_TASKID_MINOR_ERROR_CONTACTING_CLUSTER,
                                                &bstrDescription
                                                ) );

                hr = THR( SendStatusReport( m_bstrClusterName,
                                            TASKID_Major_Checking_For_Existing_Cluster,
                                            TASKID_Minor_Error_Contacting_Cluster,
                                            0,
                                            CHECKING_TIMEOUT,
                                            CHECKING_TIMEOUT,
                                            hrStatus,
                                            bstrDescription,
                                            NULL,
                                            NULL
                                            ) );

                hr = THR( hrStatus );
            }
            goto Cleanup;

        } // switch: hrStatus

    } // if: joining
    else
    {
        //
        //  FORMING
        //

        switch ( hrStatus )
        {
        case HR_S_RPC_S_SERVER_UNAVAILABLE:
            //
            //  This is what we are expecting.
            //
            break;

        case HRESULT_FROM_WIN32( ERROR_CONNECTION_REFUSED ):
        case REGDB_E_CLASSNOTREG:
        case E_ACCESSDENIED:
        case S_OK:
            {
                //
                //  If we are forming and we find an existing cluster with the same name
                //  that we trying to form, we shouldn't let the user continue.
                //
                //  NOTE that some error conditions indicate that "something" is hosting
                //  the cluster name.
                //
                hr = THR( HrFormatStringIntoBSTR(
                                                  g_hInstance
                                                , IDS_TASKID_MINOR_EXISTING_CLUSTER_FOUND
                                                , &bstrDescription
                                                , m_bstrClusterName
                                                ) );

                hr = THR( SendStatusReport( m_bstrClusterName,
                                            TASKID_Major_Checking_For_Existing_Cluster,
                                            TASKID_Minor_Existing_Cluster_Found,
                                            0,
                                            CHECKING_TIMEOUT,
                                            CHECKING_TIMEOUT,
                                            HRESULT_FROM_WIN32( ERROR_DUP_NAME ),
                                            bstrDescription,
                                            NULL,
                                            NULL
                                            ) );

                hr = THR( HRESULT_FROM_WIN32( ERROR_DUP_NAME ) );
            }
            goto Cleanup;

        default:
            {
                //
                //  If something else goes wrong, stop.
                //
                hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                                IDS_TASKID_MINOR_ERROR_CONTACTING_CLUSTER,
                                                &bstrDescription
                                                ) );

                hr = THR( SendStatusReport( m_bstrClusterName,
                                            TASKID_Major_Checking_For_Existing_Cluster,
                                            TASKID_Minor_Error_Contacting_Cluster,
                                            0,
                                            CHECKING_TIMEOUT,
                                            CHECKING_TIMEOUT,
                                            hrStatus,
                                            bstrDescription,
                                            NULL,
                                            NULL
                                            ) );

                hr = THR( hrStatus );
            }
            goto Cleanup;

        } // switch: hrStatus

    } // else: forming


    if ( m_fJoiningMode )
    {
        //
        //  Memorize the cookies of the objects that the user entered.
        //

        hr = THR( HrGetUsersNodesCookies() );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Create cookies for the existing nodes.
        //

        hr = THR( HrAddJoinedNodes() );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    //
    //  Tell the UI layer that we are done searching for the cluster.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Checking_For_Existing_Cluster,
                                TASKID_Minor_Update_Progress,
                                0,
                                CHECKING_TIMEOUT,
                                CHECKING_TIMEOUT,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }

    TraceSysFreeString( bstrDescription );

    if ( ptgci != NULL )
    {
        ptgci->Release();
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_ANALYSIS_FAILED( TASKID_Major_Checking_For_Existing_Cluster, TASKID_Minor_WaitForCluster_OutOfMemory, hr );
    goto Cleanup;

} //*** CTaskAnalyzeCluster::HrWaitForClusterConnection()


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCountNumberOfNodes( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCountNumberOfNodes()
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieDummy;

    IUnknown *      punk = NULL;
    IEnumCookies *  pec  = NULL;

    //
    //  Make sure all the node object that (will) make up the cluster
    //  are in a stable state.
    //
    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CountNodes_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CountNodes_FindObject_QI, hr );
        goto Cleanup;
    }

    pec = TraceInterface( L"CTaskAnalyzeCluster!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release();
    punk = NULL;

    //  While we're checking the node's statuses, we'll also count how
    //  many nodes there are.
    m_cNodes  = 0;
    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        HRESULT hrStatus;
        ULONG   celtDummy;

        hr = STHR( pec->Next( 1, &cookie, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CountNodes_EnumNodes_Next, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
            break;  // exit condition

        m_cNodes ++;

    } // while: hr == S_OK

    if ( hr == S_FALSE)
    {
        hr = S_OK;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCountNumberOfNodes()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  HrCreateSubTasksToGatherNodeInfo( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCreateSubTasksToGatherNodeInfo( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   cNode;
    ULONG   cNodesToProcess;
    ULONG   ulCurrent;
    DWORD   sc;

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieDummy;
    OBJECTCOOKIE    cookieNode;

    BSTR    bstrName = NULL;
    BSTR    bstrNotification = NULL;

    IUnknown *               punk  = NULL;
    IConnectionPoint *       pcp   = NULL;
    IClusCfgNodeInfo *       pccni = NULL;
    IEnumCookies *           pec   = NULL;
    ITaskGatherNodeInfo   *  ptgni = NULL;
    IStandardInfo *          psi   = NULL;
    IStandardInfo **         psiCompletion = NULL;

    Assert( m_hrStatus == S_OK );

    //
    //  Get the enum of the nodes.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_FindObject_QI, hr );
        goto Cleanup;
    }

    pec = TraceInterface( L"CTaskAnalyzeCluster!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Allocate a buffer to collect cookies
    //

    Assert( m_cCookies == 0 );
    Assert( m_pcookies == NULL );
    Assert( m_cSubTasksDone == 0 );
    m_pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( 0, m_cNodes * sizeof( OBJECTCOOKIE ) ) );
    if ( m_pcookies == NULL )
        goto OutOfMemory;

    //
    //  KB: gpease  29-NOV-2000
    //      Create a list of "interesting" completion cookie StandardInfo-s. If any of the
    //      statuses return from this list are FAILED, then abort the analysis.
    //
    psiCompletion = reinterpret_cast< IStandardInfo ** >( TraceAlloc( HEAP_ZERO_MEMORY, m_cNodes * sizeof( IStandardInfo * ) ) );
    if ( psiCompletion == NULL )
        goto OutOfMemory;

    //
    //  Loop thru the nodes, creating cookies and allocating a gather task for
    //  that node.
    //
    for ( cNode = 0; cNode < m_cNodes; cNode ++ )
    {
        LPWSTR  psz;
        ULONG   celtDummy;
        ULONG   idx;
        BOOL    fFound;

        //
        //  Grab the next node.
        //

        hr = STHR( pec->Next( 1, &cookieNode, &celtDummy ) );
        if ( hr == S_FALSE )
            break;  // exit condition

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_Next, hr );
            goto Cleanup;
        }

        //
        //  Get the nodes name. We are using this to distinguish one nodes
        //  completion cookie from another. It might also make debugging
        //  easier (??).
        //

        hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieNode, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_GetObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_GetObject_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        hr = THR( pccni->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_GetName, hr );
            goto Cleanup;
        }

        TraceMemoryAddBSTR( bstrName );

        //
        //  Create a completion cookie.
        //

        hr = THR( m_pom->FindObject( IID_NULL, m_cookieCluster, bstrName, DFGUID_StandardInfo, &m_pcookies[ cNode ], &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_CompletionCookie_FindObject, hr );
            goto Cleanup;
        }

        //
        //  Increment the cookie counter.
        //

        m_cCookies ++;

        //
        //  See if this node is one of the user entered nodes.
        //

        if ( !m_fJoiningMode )
        {
            //
            //  All nodes are "interesting" during a form operation.
            //

            Assert( m_cUserNodes == 0 );
            Assert( m_pcookiesUser == NULL );

            fFound = TRUE;
        }
        else
        {
            //
            //  Only the nodes the user entered are interesting during a join operation.
            //

            for ( fFound = FALSE, idx = 0; idx < m_cUserNodes; idx ++ )
            {
                if ( m_pcookiesUser[ idx ] == cookieNode )
                {
                    fFound = TRUE;
                    break;
                }
            }
        }

        if ( fFound )
        {
            hr = THR( punk->TypeSafeQI( IStandardInfo, &psiCompletion[ cNode ] ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_CompletionCookie_FindObject_QI, hr );
                goto Cleanup;
            }
        }
        else
        {
            Assert( psiCompletion[ cNode ] == NULL );
        }

        punk->Release();
        punk = NULL;

        //
        //  Create a task to gather this nodes information.
        //

        hr = THR( m_ptm->CreateTask( TASK_GatherNodeInfo,
                                     &punk
                                     ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_CreateTask, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( ITaskGatherNodeInfo, &ptgni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_QI_GatherNodeInfo, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        //
        //  Set the tasks completion cookie.
        //

        hr = THR( ptgni->SetCompletionCookie( m_pcookies[ cNode ] ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_SetCompletionCookie, hr );
            goto Cleanup;
        }

        //
        //  Tell it what node it is suppose to gather information from.
        //

        hr = THR( ptgni->SetCookie( cookieNode ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_SetCookie, hr );
            goto Cleanup;
        }

        //
        //  Submit the task.
        //

        hr = THR( m_ptm->SubmitTask( ptgni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_EnumNodes_SubmitTask, hr );
            goto Cleanup;
        }

        //
        //  Cleanup for the next node.
        //

        pccni->Release();
        pccni = NULL;

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        ptgni->Release();
        ptgni = NULL;

    } // while: looping thru nodes

    Assert( m_cCookies == m_cNodes );

    //
    //  Reset the signal event.
    //

    {
        BOOL bRet = ResetEvent( m_event );
        Assert( bRet );
    }

    //
    //  Now wait for the work to be done.
    //

    for ( ulCurrent = 0, sc = WAIT_OBJECT_0 + 1
        ; sc != WAIT_OBJECT_0
        ;
        )
    {
        MSG msg;
        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        sc = MsgWaitForMultipleObjectsEx( 1,
                                             &m_event,
                                             INFINITE,
                                             QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE,
                                             0
                                             );

        if ( ulCurrent != CHECKING_TIMEOUT )
        {
            ulCurrent ++;
            Assert( ulCurrent != CHECKING_TIMEOUT );

            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Establish_Connection,
                                        TASKID_Minor_Update_Progress,
                                        0,
                                        CHECKING_TIMEOUT,
                                        ulCurrent,
                                        S_OK,
                                        NULL,
                                        NULL,
                                        NULL
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }

    } // while: sc == WAIT_OBJECT_0

    //
    //  Now check the results using the list of completion cookie StandardInfo-s
    //  built earlier of interesting objects. If any of these "interesting" cookies
    //  return a FAILED status, then abort the analysis.
    //

    for ( cNode = 0, cNodesToProcess = 0; cNode < m_cNodes; cNode++ )
    {
        HRESULT hrStatus;

        if ( psiCompletion[ cNode ] == NULL )
            continue;

        hr = THR( psiCompletion[ cNode ]->GetStatus( &hrStatus ) );
        if ( FAILED( hrStatus ) )
        {
            hr = THR( hrStatus );
            goto Cleanup;
        }

        if ( hrStatus == S_OK )
        {
            cNodesToProcess++;
        } // if:

    } // for: cNode

    if ( cNodesToProcess == 0 )
    {
        BSTR    bstr = NULL;

        hr = HRESULT_FROM_WIN32( TW32( ERROR_NODE_NOT_AVAILABLE ) );

        THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NO_NODES_TO_PROCESS, &bstr ) );
        THR( SendStatusReport(
                      bstrName
                    , TASKID_Major_Establish_Connection
                    , TASKID_Minor_No_Nodes_To_Process
                    , 0
                    , 1
                    , 1
                    , hr
                    , bstr
                    , NULL
                    , NULL
                    ) );
        TraceSysFreeString( bstr );
        goto Cleanup;
    } // if:

    hr = S_OK;

Cleanup:
    THR( HrFreeCookies() );

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }
    if ( ptgni != NULL )
    {
        ptgni->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( psiCompletion != NULL )
    {
        for ( cNode = 0; cNode < m_cNodes; cNode++ )
        {
            if ( psiCompletion[ cNode ] != NULL )
            {
                psiCompletion[ cNode ]->Release();
            }
        }

        TraceFree( psiCompletion );
    }

    HRETURN( hr );

//Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_Win32Error, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_CreateNodeTasks_OutOfMemory, hr );
    goto Cleanup;

} //*** CTaskAnalyzeCluster::HrCreateSubTasksToGatherNodeInfo()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  HrCreateSubTasksToGatherNodeResourcesAndNetworks( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCreateSubTasksToGatherNodeResourcesAndNetworks( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   idxNode;
    ULONG   ulCurrent;
    DWORD   sc;

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieDummy;
    OBJECTCOOKIE    cookieNode;
    OBJECTCOOKIE *  pcookies;

    BSTR    bstrName = NULL;
    BSTR    bstrNotification = NULL;

    IUnknown *               punk  = NULL;
    IConnectionPoint *       pcp   = NULL;
    IClusCfgNodeInfo *       pccni = NULL;
    IEnumCookies *           pec   = NULL;
    ITaskGatherInformation * ptgi  = NULL;
    IStandardInfo *          psi   = NULL;
    IStandardInfo **         ppsiStatuses = NULL;

    Assert( m_hrStatus == S_OK );


    //
    //  Tell the UI layer we are starting to retrieve the resources/networks.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Find_Devices,
                                TASKID_Minor_Update_Progress,
                                0,
                                CHECKING_TIMEOUT,
                                0,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Get the enum of the nodes.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_FindObject_QI, hr );
        goto Cleanup;
    }

    pec = TraceInterface( L"CTaskAnalyzeCluster!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Allocate a buffer to collect cookies
    //

    Assert( m_cCookies == 0 );
    Assert( m_pcookies == NULL );
    Assert( m_cSubTasksDone == 0 );
    m_pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( 0, m_cNodes * sizeof( OBJECTCOOKIE ) ) );
    if ( m_pcookies == NULL )
        goto OutOfMemory;

    ppsiStatuses = reinterpret_cast< IStandardInfo ** >( TraceAlloc( 0, m_cNodes * sizeof( IStandardInfo * ) ) );
    if ( ppsiStatuses == NULL )
        goto OutOfMemory;

    //
    //  Loop thru the nodes, creating cookies and allocating a gather task for
    //  that node.
    //
    for ( idxNode = 0 ; idxNode < m_cNodes ; idxNode++ )
    {
        LPWSTR  psz;
        ULONG   celtDummy;

        //
        //  Grab the next node.
        //

        hr = STHR( pec->Next( 1, &cookieNode, &celtDummy ) );
        if ( hr == S_FALSE )
            break;  // exit condition

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_Next, hr );
            goto Cleanup;
        }

        //
        //  Get the node's name. We are using this to distinguish one node's
        //  completion cookie from another. It might also make debugging
        //  easier (??).
        //

        hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieNode, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_GetObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_GetObject_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        hr = THR( pccni->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_GetName, hr );
            goto Cleanup;
        }

        TraceMemoryAddBSTR( bstrName );

        //
        //  Create a completion cookie.
        //

        hr = THR( m_pom->FindObject( IID_NULL, m_cookieCluster, bstrName, DFGUID_StandardInfo, &m_pcookies[ idxNode ], &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_CompletionCookie_FindObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IStandardInfo, &ppsiStatuses[ idxNode ] ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_CompletionCookie_FindObject_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        //
        //  Increment the cookie counter.
        //

        m_cCookies ++;

        //
        //  Create a task to gather this node's information.
        //

        hr = THR( m_ptm->CreateTask( TASK_GatherInformation, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_CreateTask, hr );
            goto Cleanup;
        }

        TraceMoveFromMemoryList( punk, g_GlobalMemoryList );

        hr = THR( punk->TypeSafeQI( ITaskGatherInformation, &ptgi ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_QI_GatherNodeInfo, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        //
        //  Set the tasks completion cookie.
        //

        hr = THR( ptgi->SetCompletionCookie( m_pcookies[ idxNode ] ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SetCompletionCookie, hr );
            goto Cleanup;
        }

        //
        //  Tell it what node it is suppose to gather information from.
        //

        hr = THR( ptgi->SetNodeCookie( cookieNode ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SetCookie, hr );
            goto Cleanup;
        }

        //
        //  Tell it if we are joining or not.
        //

        if ( m_fJoiningMode )
        {
            hr = THR( ptgi->SetJoining() );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SetJoining, hr );
                goto Cleanup;
            }
        }

        //
        //  Submit the task.
        //

        hr = THR( m_ptm->SubmitTask( ptgi ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_EnumNodes_SubmitTask, hr );
            goto Cleanup;
        }

        //
        //  Cleanup for the next node.
        //

        pccni->Release();
        pccni = NULL;

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        ptgi->Release();
        ptgi = NULL;

    } // while: looping thru nodes

    Assert( m_cCookies == m_cNodes );

    //
    //  Reset the signal event.
    //

    {
        BOOL bRet = ResetEvent( m_event );
        Assert( bRet );
    }

    //
    //  Now wait for the work to be done.
    //

    for ( ulCurrent = 0, sc = WAIT_OBJECT_0 + 1
        ; sc != WAIT_OBJECT_0
        ;
        )
    {
        MSG msg;
        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        sc = MsgWaitForMultipleObjectsEx( 1,
                                             &m_event,
                                             INFINITE,
                                             QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE,
                                             0
                                             );

        if ( ulCurrent != CHECKING_TIMEOUT )
        {
            ulCurrent ++;
            Assert( ulCurrent != CHECKING_TIMEOUT );

            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_Update_Progress,
                                        0,
                                        CHECKING_TIMEOUT,
                                        ulCurrent,
                                        S_OK,
                                        NULL,
                                        NULL,
                                        NULL
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }

    } // while: sc == WAIT_OBJECT_0

    //
    //  See if anything went wrong.
    //

    for ( idxNode = 0 ; idxNode < m_cNodes ; idxNode++ )
    {
        HRESULT hrStatus;

        if ( ppsiStatuses[ idxNode ] == NULL )
            continue;

        hr = THR( ppsiStatuses[ idxNode ]->GetStatus( &hrStatus ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_GetStatus, hr );
            goto Cleanup;
        }

        if ( FAILED( hrStatus ) )
        {
            hr = THR( hrStatus );
            goto Cleanup;
        }
    }

    //
    //  Tell the UI we are done.
    //

    hr = THR( SendStatusReport(
                  NULL
                , TASKID_Major_Find_Devices
                , TASKID_Minor_Update_Progress
                , 0
                , CHECKING_TIMEOUT
                , CHECKING_TIMEOUT
                , S_OK
                , NULL
                , NULL
                , NULL
                ) );

Cleanup:
    THR( HrFreeCookies() );

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }
    if ( ptgi != NULL )
    {
        ptgi->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( ppsiStatuses != NULL )
    {
        for ( idxNode = 0 ; idxNode < m_cNodes ; idxNode++ )
        {
            if ( ppsiStatuses[ idxNode ] != NULL )
            {
                ppsiStatuses[ idxNode ]->Release();
            }
        }

        TraceFree( ppsiStatuses );
    }

    HRETURN( hr );

//Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_Win32Error, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_GatherInformation_OutOfMemory, hr );
    goto Cleanup;

} //*** CTaskAnalyzeCluster::HrCreateSubTasksToGatherNodeResourcesAndNetworks()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCheckClusterFeasibility( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCheckClusterFeasibility( void )
{
    TraceFunc( "" );

    HRESULT hr;

    BOOL    fNeedToCheckMembership = FALSE;

    IEnumNodes *            pen   = NULL;
    IClusCfgNodeInfo *      pccni = NULL;

    //
    //  Notify the UI layer that we have started.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_Update_Progress,
                                0,
                                5,
                                0,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Check membership.
    //

    hr = THR( HrCheckClusterMembership() );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_Update_Progress,
                                0,
                                5,
                                1,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Check version interoperability.
    //

    hr = STHR( HrCheckInteroperability() );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_Update_Progress,
                                0,
                                5,
                                2,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Compare the devices.
    //

    hr = THR( HrCompareResources() );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_Update_Progress,
                                0,
                                5,
                                3,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Compare the networks.
    //

    hr = THR( HrCompareNetworks() );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_Update_Progress,
                                0,
                                5,
                                4,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Now check to see if the nodes can all see the selected quorum resource.
    //

    hr = THR( HrCheckForCommonQuorumResource() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Notify the UI layer that we are done.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_Update_Progress,
                                0,
                                5,
                                5,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
Cleanup:
    if ( pen != NULL )
    {
        pen->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCheckClusterFeasibility()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrAddJoinedNodes( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrAddJoinedNodes( void )
{
    TraceFunc( "" );

    HRESULT             hr;
    ULONG               idx;
    DWORD               dw;
    DWORD               dwType;
    DWORD               cchName;
    WCHAR               szName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    OBJECTCOOKIE        cookieDummy;
    LPWSTR              pszDomain;
    BSTR                bstrFQDNName = NULL;
    BSTR                bstrBindingString = NULL;
    HCLUSTER            hCluster = NULL;
    HCLUSENUM           hClusEnum = NULL;
    IUnknown *          punkDummy = NULL;
    IUnknown *          punk = NULL;
    IClusCfgServer *    piccs = NULL;
//    CLSID               clsidLog;

//    CopyMemory( &clsidLog, &TASKID_Major_Establish_Connection, sizeof( clsidLog ) );

    hr = THR( m_pcm->GetConnectionToObject( m_cookieCluster, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_GetConnectionObject, hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &piccs ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_ConfigConnection_QI, hr );
        goto Cleanup;
    } // if:

    hr = THR( piccs->GetBindingString( &bstrBindingString ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrAddJoinedNodes_GetBindingString, hr );
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( bstrBindingString );

    pszDomain = wcschr( m_bstrClusterName, L'.' ); //  we don't need to move past the dot.

    hCluster = OpenCluster( bstrBindingString );
    if ( hCluster == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_AddJoinedNodes_OpenCluster, hr );
        goto Cleanup;
    }

    hClusEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_NODE );
    if ( hClusEnum == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_AddJoinedNodes_ClusterOpenEnum, hr );
        goto Cleanup;
    }

    for ( idx = 0; ; idx ++ )
    {
        //
        //  Cleanup
        //

        TraceSysFreeString( bstrFQDNName );
        bstrFQDNName = NULL;
//        TraceSysFreeString( bstrBindingString );
//        bstrBindingString = NULL;

        //
        //  Get the next node name from the cluster.
        //

        cchName = ARRAYSIZE( szName );

        // can't wrap can return ERROR_NO_MORE_ITEMS.
        dw = ClusterEnum( hClusEnum, idx, &dwType, szName, &cchName );
        if ( dw == ERROR_NO_MORE_ITEMS )
            break;  // exit condition

        if ( dw != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( TW32( dw ) );
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_AddJoinedNodes_ClusterEnum, hr );
            goto Cleanup;
        }

        //
        //  Build the FQDN name of the node.
        //

        cchName += wcslen( pszDomain ) + 1 /* NULL */;

        bstrFQDNName = TraceSysAllocStringLen( NULL, cchName );
        if ( bstrFQDNName == NULL )
            goto OutOfMemory;

        wcscpy( bstrFQDNName, szName );
        wcscat( bstrFQDNName, pszDomain );

//        hr = THR( HrCreateBinding( this, &clsidLog, bstrFQDNName, &bstrBindingString ) );
//        if ( FAILED( hr ) )
//        {
//            hr = HR_S_RPC_S_SERVER_UNAVAILABLE;
//            goto Cleanup;
//        }

        //
        //  Prime the object manager to retrieve the node information.
        //

        // can't wrap - should return E_PENDING
        hr = m_pom->FindObject( CLSID_NodeType, m_cookieCluster, bstrFQDNName, DFGUID_NodeInformation, &cookieDummy, &punkDummy );
        if ( FAILED( hr ) )
        {
            Assert( punkDummy == NULL );
            if ( hr == E_PENDING )
            {
                continue;   // expected error
            }

            THR( hr );
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_AddJoinedNodes_FindObject, hr );
            goto Cleanup;
        }

        punkDummy->Release();
        punkDummy = NULL;

    } // for: idx

    hr = S_OK;

Cleanup:
    Assert( punkDummy == NULL );
    TraceSysFreeString( bstrFQDNName );
    TraceSysFreeString( bstrBindingString );

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( piccs != NULL )
    {
        piccs->Release();
    }

    if ( hClusEnum != NULL )
    {
        ClusterCloseEnum( hClusEnum );
    }

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_AddJoinedNodes_OutOfMemory, hr );
    goto Cleanup;

} //*** CTaskAnalyzeCluster::HrAddJoinedNodes()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCheckClusterMembership( void )
//
//  ERROR_CLUSTER_NODE_EXISTS
//  ERROR_CLUSTER_NODE_ALREADY_MEMBER
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCheckClusterMembership( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    IClusCfgClusterInfo *   pccci;

    BSTR    bstrNodeName     = NULL;
    BSTR    bstrClusterName  = NULL;
    BSTR    bstrNotification = NULL;

    IUnknown *         punk  = NULL;
    IEnumNodes *       pen   = NULL;
    IClusCfgNodeInfo * pccni = NULL;

    //
    //  Ask the object manager for the node enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumNodes,&cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_FindObject_QI, hr );
        goto Cleanup;
    }

    //
    //  If we are joining an existing cluster, make sure that all the other
    //  nodes are members of the same cluster.
    //

    Assert( SUCCEEDED( hr ) );
    while ( SUCCEEDED( hr ) )
    {
        ULONG   celtDummy;

        //
        //  Cleanup
        //

        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        }

        TraceSysFreeString( bstrClusterName );
        bstrClusterName = NULL;

        //
        //  Get the next node.
        //

        hr = STHR( pen->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
            break;  // exit condition

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_Next, hr );
            goto Cleanup;
        }

        //
        //  Check to see if we need to "form a cluster" by seeing if any
        //  of the nodes are already clustered.
        //

        hr = STHR( pccni->IsMemberOfCluster() );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_IsMemberOfCluster, hr );
            goto Cleanup;
        }

        if ( hr == S_OK )
        {
            //
            //  Retrieve the name and make sure they match.
            //

            hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_GetClusterConfigInfo, hr );
                goto Cleanup;
            }

            hr = THR( pccci->GetName( &bstrClusterName ) );
            pccci->Release();      // release promptly
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_GetName, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrClusterName );

            hr = THR( pccni->GetName( &bstrNodeName ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_GetNodeName, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrNodeName );

            if ( StrCmpI( m_bstrClusterName, bstrClusterName ) != 0 )
            {
                //
                //  They don't match! Tell the UI layer!
                //

                hr = THR( pccni->GetName( &bstrNodeName ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_GetNodeName, hr );
                    goto Cleanup;
                }

                TraceMemoryAddBSTR( bstrNodeName );

                hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CLUSTER_NAME_MISMATCH, &bstrNotification, bstrClusterName ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_FormatMessage, hr );
                    goto Cleanup;
                }

                hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DATA ) );

                THR( SendStatusReport( bstrNodeName,
                                       TASKID_Major_Check_Cluster_Feasibility,
                                       TASKID_Minor_Cluster_Name_Mismatch,
                                       0,
                                       1,
                                       1,
                                       hr,
                                       bstrNotification,
                                       NULL,
                                       NULL
                                       ) );

                //
                //  We don't care what the return value is since we are bailing the analysis.
                //

                goto Cleanup;
            } // if: cluster names don't match
            else
            {
                hr = STHR( HrIsUserAddedNode( bstrNodeName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                if ( hr == S_OK )
                {
                    hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NODE_ALREADY_IS_MEMBER, &bstrNotification, bstrNodeName, bstrClusterName ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_EnumNode_FormatMessage1, hr );
                        goto Cleanup;
                    }

                    //
                    //  Make this a success code because we don't want to abort.  We simply want to tell the user...
                    //
                    hr = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_CLUSTER_NODE_ALREADY_MEMBER );

                    THR( SendStatusReport( bstrNodeName,
                                           TASKID_Major_Check_Cluster_Feasibility,
                                           TASKID_Minor_Cluster_Name_Match,
                                           0,
                                           1,
                                           1,
                                           hr,
                                           bstrNotification,
                                           NULL,
                                           NULL
                                           ) );
                } // if:
            } // else: cluster names do match then this node is already a member of this cluster

            TraceSysFreeString( bstrNodeName );
            bstrNodeName = NULL;
        } // if: cluster member

    } // while: hr

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CLUSTER_MEMBERSHIP_VERIFIED, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_CheckMembership_FormatMessage, hr );
        goto Cleanup;
    }

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_Cluster_Membership_Verified,
                                0,
                                1,
                                1,
                                hr,
                                NULL,
                                NULL,
                                NULL
                                ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    }

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCheckClusterMembership()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCompareResources( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCompareResources( void )
{
    TraceFunc( "" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieNode;
    OBJECTCOOKIE    cookieDummy;
    OBJECTCOOKIE    cookieFirst;

    BSTR    bstrUIDExisting;
    ULONG   celtDummy;

    IClusCfgManagedResourceInfo *  pccmriNew = NULL;

    HRESULT hr = S_OK;

    BSTR    bstrName = NULL;
    BSTR    bstrUID = NULL;
    BSTR    bstrNotification = NULL;
    BSTR    bstrResName = NULL;

    IUnknown *                     punk       = NULL;
    IEnumCookies *                 pecNodes   = NULL;
    IEnumClusCfgManagedResources * peccmr     = NULL;
    IEnumClusCfgManagedResources * peccmrCluster = NULL;
    IClusCfgManagedResourceInfo *  pccmri     = NULL;
    IClusCfgManagedResourceInfo *  pccmriCluster = NULL;
    IClusCfgNodeInfo *             pccni      = NULL;

    //
    //  Get the node cookie enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Enum_Nodes_Find_Object, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pecNodes ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Enum_Nodes_Find_Object_QI, hr );
        goto Cleanup;
    }

    pecNodes = TraceInterface( L"CTaskAnalyzeCluster!IEnumCookies", IEnumCookies, pecNodes, 1 );

    punk->Release();
    punk = NULL;

    //
    //  If forming, it doesn't matter who we pick to prime the cluster configuration
    //
    if ( !m_fJoiningMode )
    {
        //
        //  The first guy thru, we just copy his resources under the cluster
        //  configuration.
        //

        hr = THR( pecNodes->Next( 1, &cookieFirst, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Enum_Nodes_Next, hr );
            goto Cleanup;
        }
    } // if: not joining
    else
    {
        //
        //  We are joining nodes to the cluster. Find a node that has current
        //  configuration and use it to prime the new configuration.
        //

        for ( ;; )
        {
            //
            //  Cleanup
            //
            if ( pccni != NULL )
            {
                pccni->Release();
                pccni = NULL;
            }

            hr = STHR( pecNodes->Next( 1, &cookieFirst, &celtDummy ) );
            if ( hr == S_FALSE )
            {
                //
                //  We shouldn't make it here. There should be at least one node
                //  in the cluster that we are joining.
                //

                hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Find_Formed_Node_Next, hr );
                goto Cleanup;
            }

            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Find_Formed_Node_Next, hr );
                goto Cleanup;
            }

            //
            //  Retrieve the node information.
            //

            hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookieFirst, &punk ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareResources_NodeInfo_FindObject, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareResources_NodeInfo_FindObject_QI, hr );
                goto Cleanup;
            }

            pccni = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgNodeInfo", IClusCfgNodeInfo, pccni, 1 );

            punk->Release();
            punk = NULL;

            hr = STHR( pccni->IsMemberOfCluster() );
            if ( hr == S_OK )
                break;  // exit condition

        } // for: ever
    } // else:  joining

    //
    //  Retrieve the node's name for error messages.
    //

    hr = THR( HrRetrieveCookiesName( TASKID_Major_Find_Devices, cookieFirst, &bstrName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Retrieve the managed resources enumer.
    //

    hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, cookieFirst, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
    if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NO_MANAGED_RESOURCES_FOUND, &bstrNotification ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( SendStatusReport( bstrName,
                                    TASKID_Major_Find_Devices,
                                    TASKID_Minor_No_Managed_Resources_Found,
                                    0,
                                    1,
                                    1,
                                    MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND ),
                                    bstrNotification,
                                    NULL,
                                    NULL
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );

        // fall thru - the while ( hr == S_OK ) will be false and keep going
    }
    else if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_First_Node_Find_Object, hr );
        goto Cleanup;
    }
    else
    {
        hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_First_Node_Find_Object_QI, hr );
            goto Cleanup;
        }

        peccmr = TraceInterface( L"CTaskAnalyzeCluster!IEnumClusCfgManagedResources", IEnumClusCfgManagedResources, peccmr, 1 );

        punk->Release();
        punk = NULL;
    }

    //
    //  Loop thru the first nodes resources create an equalivant resource
    //  under the cluster configuration object/cookie.
    //

    while ( hr == S_OK )
    {

        //  Cleanup
        if ( pccmri != NULL )
        {
            pccmri->Release();
            pccmri = NULL;
        }

        //  Get next resource
        hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_First_Node_Next, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
            break;  // exit condition

        //  create a new object
        hr = THR( HrCreateNewManagedResourceInClusterConfiguration( pccmri, &pccmriNew ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = STHR( pccmriNew->IsQuorumDevice() );
        if ( hr == S_OK )
        {
            Assert( m_bstrQuorumUID == NULL );
            hr = THR( pccmriNew->GetUID( &m_bstrQuorumUID ) );

            TraceMemoryAddBSTR( m_bstrQuorumUID );

            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_First_Node_Get_Quorum_UID, hr );
                goto Cleanup;
            }

            // Checking that the quorum is joinable if we are in join mode.
            if ( ( hr == S_OK ) && m_fJoiningMode )
            {
                hr = THR( pccmriNew->IsDeviceJoinable() );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_First_Node_Is_Device_Joinable, hr );
                    goto Cleanup;
                }
                else if ( hr == S_FALSE )
                {
                    // Souldn't allow this to proceed, no joinable quorum in join mode.
                    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                IDS_TASKID_MINOR_MISSING_JOINABLE_QUORUM_RESOURCE,
                                &bstrNotification
                                ) );

                    hr = THR( SendStatusReport( NULL,
                            TASKID_Major_Find_Devices,
                            TASKID_Minor_Compare_Resources_Enum_First_Node_Is_Device_Joinable,
                            0,
                            1,
                            1,
                            HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) ),
                            bstrNotification,
                            NULL,
                            NULL
                            ) );


                    hr = HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) );
                    goto Cleanup;
                }
            } // if:

            pccmriNew->Release();
            pccmriNew = NULL;
        }
        else
        {
            pccmriNew->Release();
            pccmriNew = NULL;
            hr = S_OK;
        }

    } // while: S_OK

    hr = THR( pecNodes->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Reset, hr );
        goto Cleanup;
    }

    //
    //  Loop thru the rest of the nodes comparing the resources.
    //

    for ( ; ; )
    {
        //
        //  Cleanup
        //

        if ( peccmr != NULL )
        {
            peccmr->Release();
            peccmr = NULL;
        }
        TraceSysFreeString( bstrName );
        bstrName = NULL;

        //
        //  Get the next node.
        //

        hr = STHR( pecNodes->Next( 1, &cookieNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Next, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
            break;  // exit condition

        //
        //  Skip the "first" node since we already have its configuration.
        //
        if ( cookieFirst == cookieNode )
            continue;

        //
        //  Retrieve the node's name for error messages.
        //

        hr = THR( HrRetrieveCookiesName( TASKID_Major_Find_Devices, cookieNode, &bstrName ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Retrieve the managed resources enumer.
        //

        hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, cookieNode, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NO_MANAGED_RESOURCES_FOUND, &bstrNotification ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( SendStatusReport( bstrName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_No_Managed_Resources_Found,
                                        0,
                                        1,
                                        1,
                                        MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND ),
                                        bstrNotification,
                                        NULL,
                                        NULL
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            continue;   // skip this node
        }
        else if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Find_Object, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Find_Object_QI, hr );
            goto Cleanup;
        }

        peccmr = TraceInterface( L"CTaskAnalyzeCluster!IEnumClusCfgManagedResources", IEnumClusCfgManagedResources, peccmr, 1 );

        punk->Release();
        punk = NULL;

        //
        //  Loop thru the managed resources already that the node has.
        //

        for ( ; ; )
        {
            //
            //  Cleanup
            //

            if ( pccmri != NULL )
            {
                pccmri->Release();
                pccmri = NULL;
            }
            TraceSysFreeString( bstrUID );
            bstrUID = NULL;

            if ( peccmrCluster != NULL )
            {
                peccmrCluster->Release();
                peccmrCluster = NULL;
            }

            //
            //  Get next resource
            //

            hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Next, hr );
                goto Cleanup;
            }

            if ( hr == S_FALSE )
                break;  // exit condition

            pccmri = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgManagedResourceInfo", IClusCfgManagedResourceInfo, pccmri, 1 );

            //
            //  Grab the resource's UUID.
            //

            hr = THR( pccmri->GetUID( &bstrUID ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_GetUID, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrUID );

            //
            //  See if it matches a resource already in the cluster configuration.
            //

            hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, m_cookieCluster, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
            if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
            {
                hr = S_FALSE;   // create a new object.
                // fall thru
            }
            else if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Find_Object, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmrCluster ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Find_Object_QI, hr );
                goto Cleanup;
            }

            punk->Release();
            punk = NULL;

            //
            //  Loop thru the configured cluster resources to see what matches.
            //

            while( hr == S_OK )
            {
                HRESULT hrCluster;

                BOOL    fMatch;

                //
                //  Cleanup
                //

                if ( pccmriCluster != NULL )
                {
                    pccmriCluster->Release();
                    pccmriCluster = NULL;
                }

                hr = STHR( peccmrCluster->Next( 1, &pccmriCluster, &celtDummy ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_Next, hr );
                    goto Cleanup;
                }

                if ( hr == S_FALSE )
                    break;  // exit condition

                hr = THR( pccmriCluster->GetUID( &bstrUIDExisting ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetUID, hr );
                    goto Cleanup;
                }

                TraceMemoryAddBSTR( bstrUIDExisting );

                fMatch = ( wcscmp( bstrUID, bstrUIDExisting ) == 0 );
                TraceSysFreeString( bstrUIDExisting );

                if ( !fMatch )
                    continue;   // keep looping

                //
                //  A resource is already in the database. See if it is the same from
                //  the POV of management.
                //

                //
                //  Check the quorum capabilities.
                //

                hrCluster = STHR( pccmriCluster->IsQuorumCapable() );
                if ( FAILED( hrCluster ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsQuorumCapable_Cluster, hr );
                    goto Cleanup;
                }

                hr = STHR( pccmri->IsQuorumCapable() );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsQuorumCapable_Node, hr );
                    goto Cleanup;
                }

                if ( hr != hrCluster )
                {
                    //
                    //  The quorum capabilities don't match. Tell the user.
                    //

                    BSTR    bstrResource;

                    hr = THR( pccmriCluster->GetName( &bstrResource ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetName, hr );
                        goto Cleanup;
                    }

                    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                                       IDS_TASKID_MINOR_RESOURCE_CAPABILITIES_DONT_MATCH,
                                                       &bstrNotification,
                                                       bstrResource
                                                       ) );

                    TraceSysFreeString( bstrResource );

                    hr = THR( SendStatusReport( bstrName,
                                                TASKID_Major_Check_Cluster_Feasibility,
                                                TASKID_Minor_Resource_Capabilities_Dont_Match,
                                                0,
                                                1,
                                                1,
                                                E_FAIL,
                                                bstrNotification,
                                                NULL,
                                                NULL
                                                ) );

                    hr = THR( E_FAIL );
                    goto Cleanup; // bail!
                }

                //
                //
                //  If we made it here then we think it truely is the same resource. The
                //  rest is stuff we need to fixup during the commit phase.
                //
                //

                //
                //  Is this node wants its resources managed, mark it as being managed in the cluster
                //  configuration as well.
                //

                hr = STHR( pccmri->IsManaged() );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_IsManaged, hr );
                    goto Cleanup;
                }

                if ( hr == S_OK )
                {
                    hr = THR( pccmriCluster->SetManaged( TRUE ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetManaged, hr );
                        goto Cleanup;
                    }

                    //
                    // Since this node manages this resource, it should be able to provide us with a name.
                    // We will use this name to overwrite whatever we currently have, except for the quorum
                    // resource, which already has the correct name.
                    //
                    hr = STHR( pccmri->IsQuorumDevice() );
                    if ( hr == S_FALSE )
                    {
                        hr = THR( pccmri->GetName( &bstrResName ) );
                        if ( FAILED( hr ) )
                        {
                            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_GetResName, hr );
                            goto Cleanup;
                        }

                        TraceMemoryAddBSTR( bstrResName );
                        hr = THR( pccmriCluster->SetName( bstrResName ) );
                        if ( FAILED( hr ) )
                        {
                            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetResName, hr );
                            goto Cleanup;
                        }
                        TraceSysFreeString( bstrResName );
                        bstrResName = NULL;
                    }
                }

                //
                //  Check to see if the resource is the quorum resource. If so, mark that
                //  we found a common quorum resource.
                //

                if ( m_bstrQuorumUID == NULL )
                {
                    //
                    //  No previous quorum has been set. See if this is the quorum resource.
                    //

                    hr = STHR( pccmri->IsQuorumDevice() );
                    if ( hr == S_OK )
                    {
                        //
                        //  Yes it is. The mark it in the configuration as such.
                        //

                        hr = THR( pccmriCluster->SetQuorumedDevice( TRUE ) );
                        if ( FAILED( hr ) )
                        {
                            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Cluster, hr );
                            goto Cleanup;
                        }

                        //
                        //  Remember that this resource is the quorum.
                        //

                        hr = THR( pccmriCluster->GetUID( &m_bstrQuorumUID ) );
                        if ( FAILED( hr ) )
                        {
                            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_GetUID, hr );
                            goto Cleanup;
                        }

                        TraceMemoryAddBSTR( m_bstrQuorumUID );
                    }
                }
                else if ( wcscmp( m_bstrQuorumUID, bstrUID ) == 0 )
                {
                    //
                    //  This is the same quorum. Mark the Node's configuration.
                    //

                    hr = THR( pccmri->SetQuorumedDevice( TRUE ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Node_True, hr );
                        goto Cleanup;
                    }
                }
                else
                {
                    //
                    //  Otherwize, make sure that the device isn't marked as quorum. (paranoid)
                    //

                    hr = THR( pccmri->SetQuorumedDevice( FALSE ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Enum_Nodes_Enum_Resources_Enum_Cluster_SetQuorumDevice_Node_False, hr );
                        goto Cleanup;
                    }
                }

                //
                //  Exit the loop with S_OK so we don't create a new resource.
                //

                hr = S_OK;
                break;  // exit loop

            } // while: S_OK

            if ( hr == S_FALSE )
            {
                //
                //  Need to create a new object.
                //

                Assert( pccmri != NULL );

                hr = THR( HrCreateNewManagedResourceInClusterConfiguration( pccmri, &pccmriNew ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                Assert( hr == S_OK );

                hr = STHR( pccmriNew->IsQuorumDevice() );
                if ( hr == S_OK )
                {
                    //
                    //  Remember the quorum device's UID.
                    //

                    Assert( m_bstrQuorumUID == NULL );
                    m_bstrQuorumUID = bstrUID;
                    bstrUID = NULL;
                }
                else
                {
                    pccmriNew->Release();
                    pccmriNew = NULL;
                    hr = S_OK;
                }

            } // if: object not found

        } // for: resources

    } // for: nodes

    hr = S_OK;

Cleanup:
    if ( pccmriNew != NULL )
    {
        pccmriNew->Release();
    } // if:

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrUID );
    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrResName );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    }
    if ( peccmr != NULL )
    {
        peccmr->Release();
    }
    if ( peccmrCluster != NULL )
    {
        peccmrCluster->Release();
    }
    if ( pccmri != NULL )
    {
        pccmri->Release();
    }
    if ( pccmriCluster != NULL )
    {
        pccmriCluster->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCompareResources()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCreateNewManagedResourceInClusterConfiguration(
//      IClusCfgManagedResourceInfo * pccmriIn,
//      IClusCfgManagedResourceInfo ** ppccmriNewOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCreateNewManagedResourceInClusterConfiguration(
    IClusCfgManagedResourceInfo * pccmriIn,
    IClusCfgManagedResourceInfo ** ppccmriNewOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    BSTR    bstrUID = NULL;

    IUnknown *                    punk   = NULL;
    IGatherData *                 pgd    = NULL;
    IClusCfgManagedResourceInfo * pccmri = NULL;

    //
    //  TODO:   gpease  28-JUN-2000
    //          Make this dynamic - for now we'll just create a "managed device."
    //

    //  grab the name
    hr = THR( pccmriIn->GetUID( &bstrUID ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_GetUID, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( bstrUID );

    //  create an object in the object manager.
    hr = THR( m_pom->FindObject( CLSID_ManagedResourceType,
                                 m_cookieCluster,
                                 bstrUID,
                                 DFGUID_ManagedResource,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_FindObject, hr );
        goto Cleanup;
    }

    //  find the IGatherData interface
    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_FindObject_QI, hr );
        goto Cleanup;
    }

    //  have the new object gather all information it needs
    hr = THR( pgd->Gather( m_cookieCluster, pccmriIn ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_Gather, hr );
        goto Cleanup;
    }

    //  hand the object out if requested
    if ( ppccmriNewOut != NULL )
    {
        // find the IClusCfgManagedResourceInfo
        hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccmri ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Create_Resource_QI, hr );
            goto Cleanup;
        }

        *ppccmriNewOut = TraceInterface( L"ManagedDevice!ICCMRI", IClusCfgManagedResourceInfo, pccmri, 0 );
        (*ppccmriNewOut)->AddRef();
    }

Cleanup:
    TraceSysFreeString( bstrUID );

    if ( pccmri != NULL )
    {
        pccmri->Release();
    }
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCreateNewManagedResourceInClusterConfiguration()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCheckForCommonQuorumResource( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCheckForCommonQuorumResource( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieDummy;

    ULONG   cMatchedNodes = 0;
    ULONG   cAnalyzedNodes = 0;
    BOOL    fNodeCanAccess = FALSE;
    BSTR    bstrUID = NULL;
    BSTR    bstrNotification = NULL;
    BSTR    bstrNodeName = NULL;

    IUnknown *                      punk = NULL;
    IEnumCookies *                  pecNodes = NULL;
    IEnumClusCfgManagedResources *  peccmr = NULL;
    IClusCfgManagedResourceInfo  *  pccmri = NULL;
    IClusCfgNodeInfo *              piccni = NULL;

    //
    //  BUGBUG: 08-MAY-2001 GalenB
    //
    //  There is no status or progress for this feasibility step.  It simply "hangs" until it succeeds or fails.
    //
    /*
    THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FOUND_COMMON_QUORUM_RESOURCE, &bstrNotification ) );
    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_Finding_Common_Quorum_Device,
                                0,
                                0,
                                1,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    */
    if ( m_bstrQuorumUID != NULL )
    {
        //
        //  Grab the cookie enumer for nodes in our cluster configuration.
        //

        hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_FindObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IEnumCookies, &pecNodes ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_FindObject_QI, hr );
            goto Cleanup;
        }

        pecNodes = TraceInterface( L"CTaskAnalyzeCluster!IEnumCookies", IEnumCookies, pecNodes, 1 );

        punk->Release();
        punk = NULL;

        //
        //  Scan the cluster configurations looking for the quorum resource.
        //
        for ( ;; )
        {
            ULONG   celtDummy;

            if ( peccmr != NULL )
            {
                peccmr->Release();
                peccmr = NULL;
            } // if:

            hr = STHR( pecNodes->Next( 1, &cookie, &celtDummy ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_Next, hr );
                goto Cleanup;
            } // if:

            if ( hr == S_FALSE )
                break;  // exit condition

            hr = THR( m_pom->GetObject( DFGUID_NodeInformation, cookie, &punk ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &piccni ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            punk->Release();
            punk = NULL;

            TraceSysFreeString( bstrNodeName );
            bstrNodeName = NULL;

            hr = THR( piccni->GetName( &bstrNodeName ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            TraceMemoryAddBSTR( bstrNodeName );

            //
            // increment counter for a "nice" progress bar
            //

            cAnalyzedNodes ++;

            THR( HrFormatStringIntoBSTR( g_hInstance,
                                         IDS_TASKID_MINOR_FINDING_COMMON_QUORUM_DEVICE,
                                         &bstrNotification,
                                         bstrNodeName ) );
            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Check_Cluster_Feasibility,
                                        TASKID_Minor_Finding_Common_Quorum_Device,
                                        0,
                                        m_cNodes + 1,
                                        cAnalyzedNodes,
                                        S_OK,
                                        bstrNotification,
                                        NULL,
                                        NULL
                                        ) );

            //
            //  Grab the managed resource enumer for resources that our node has.
            //

            hr = THR( m_pom->FindObject( CLSID_ManagedResourceType, cookie, NULL, DFGUID_EnumManageableResources, &cookieDummy, &punk ) );
            if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
            {
                continue; // ignore and continue
            }
            else if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_FindObject, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_FindObject_QI, hr );
                goto Cleanup;
            }

            peccmr = TraceInterface( L"CTaskAnalyzeCluster!IEnumClusCfgManagedResources", IEnumClusCfgManagedResources, peccmr, 1 );

            punk->Release();
            punk = NULL;

            fNodeCanAccess = FALSE;

            //
            //  Loop thru the resources trying to match the UID of the quorum resource.
            //
            for ( ;; )
            {
                ULONG   celtDummy;

                TraceSysFreeString( bstrUID );
                bstrUID = NULL;

                if ( pccmri != NULL )
                {
                    pccmri->Release();
                    pccmri = NULL;
                }

                hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_Enum_Resources_Next, hr );
                    goto Cleanup;
                }

                if ( hr == S_FALSE )
                    break;  // exit condition

                pccmri = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgManagedResourceInfo", IClusCfgManagedResourceInfo, pccmri, 1 );

                hr = THR( pccmri->GetUID( &bstrUID ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_Check_Common_Enum_Nodes_Enum_Resources_GetUID, hr );
                    goto Cleanup;
                }

                TraceMemoryAddBSTR( bstrUID );

                if ( wcscmp( bstrUID, m_bstrQuorumUID ) != 0 )
                    continue;   // doesn't match - keep going

                cMatchedNodes ++;
                fNodeCanAccess = TRUE;

                break;  // exit condition

            } // while: S_OK

            //
            // Give the UI feedback if this node has no access to the quorum
            //

            if ( !fNodeCanAccess )
            {

                THR( HrLoadStringIntoBSTR( g_hInstance,
                                             IDS_TASKID_MINOR_NODE_CANNOT_ACCESS_QUORUM,
                                             &bstrNotification ) );

                hr = THR( SendStatusReport( bstrNodeName,
                                            TASKID_Major_Check_Cluster_Feasibility,
                                            TASKID_Minor_Node_Cannot_Access_Quorum,
                                            0,
                                            1,
                                            1,
                                            HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) ),
                                            bstrNotification,
                                            NULL,
                                            NULL
                                            ) );
            } // if ( !fNodeCanAccess )
        } // while: S_OK
    } // if: m_bstrQuorumUID != NULL

    //
    //  Figure out if we ended up with a common quorum device.
    //

    if ( cMatchedNodes == m_cNodes )
    {
        //
        //  We found a device that can be used as a common quorum device.
        //

        THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FOUND_COMMON_QUORUM_RESOURCE, &bstrNotification ) );
        hr = THR( SendStatusReport( NULL,
                                    TASKID_Major_Check_Cluster_Feasibility,
                                    TASKID_Minor_Finding_Common_Quorum_Device,
                                    0,
                                    m_cNodes + 1,
                                    m_cNodes + 1,
                                    S_OK,
                                    bstrNotification,
                                    NULL,
                                    NULL
                                    ) );
        // error checked outside if/else statement
    }
    else
    {
        if ( ( m_cNodes == 1 ) && ( !m_fJoiningMode ) )
        {
            //
            //  We didn't find a common quorum device, but we're only forming. We can
            //  create the cluster with a local quorum. Just put up a warning.
            //

            THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FORCED_LOCAL_QUORUM, &bstrNotification ) );
            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Check_Cluster_Feasibility,
                                        TASKID_Minor_Finding_Common_Quorum_Device,
                                        0,
                                        m_cNodes + 1,
                                        m_cNodes + 1,
                                        MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_QUORUM_DISK_NOT_FOUND ),
                                        bstrNotification,
                                        NULL,
                                        NULL
                                        ) );
            // error checked outside if/else statement
        }
        else
        {
            //
            //  We didn't find a common quorum device.
            //

            THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE, &bstrNotification ) );
            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Check_Cluster_Feasibility,
                                        TASKID_Minor_Finding_Common_Quorum_Device,
                                        0,
                                        m_cNodes + 1,
                                        m_cNodes + 1,
                                        HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) ),
                                        bstrNotification,
                                        NULL,
                                        NULL
                                        ) );
            //  we always bail.
            hr = HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) );
            goto Cleanup;
        }
    }

    //
    //  Check to see if any of the SendStatusReports() returned anything
    //  of interest.
    //

    if ( FAILED( hr ) )
        goto Cleanup;

    hr = S_OK;

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrUID );

    if ( pccmri != NULL )
    {
        pccmri->Release();
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release();
    } // if:

    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCheckForCommonQuorumResource()


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCompareNetworks( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCompareNetworks( void )
{
    TraceFunc( "" );

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieNode;
    OBJECTCOOKIE    cookieDummy;
    OBJECTCOOKIE    cookieFirst;

    BSTR    bstrUIDExisting;
    ULONG   celtDummy;

    IClusCfgNetworkInfo *  pccmriNew;

    HRESULT hr = S_OK;

    BSTR    bstrUID = NULL;
    BSTR    bstrName = NULL;
    BSTR    bstrNotification = NULL;

    IUnknown *              punk         = NULL;
    IEnumCookies *          pecNodes     = NULL;
    IEnumClusCfgNetworks *  peccn        = NULL;
    IEnumClusCfgNetworks *  peccnCluster = NULL;
    IClusCfgNetworkInfo *   pccni        = NULL;
    IClusCfgNetworkInfo *   pccniCluster = NULL;
    IClusCfgNodeInfo *      pccNode      = NULL;

    hr = THR( m_pom->FindObject( CLSID_NodeType,
                                 m_cookieCluster,
                                 NULL,
                                 DFGUID_EnumCookies,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pecNodes ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_FindObject_QI, hr );
        goto Cleanup;
    }

    pecNodes = TraceInterface( L"CTaskAnalyzeCluster!IEnumCookies", IEnumCookies, pecNodes, 1 );

    punk->Release();
    punk = NULL;

    if ( !m_fJoiningMode )
    {
        //
        //  The first guy thru, we just copy his networks under the cluster
        //  configuration.
        //

        hr = THR( pecNodes->Next( 1, &cookieFirst, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_Next, hr );
            goto Cleanup;
        }
    }
    else
    {
        //
        //  We are joining nodes to the cluster. Find a node that has current
        //  configuration and use it to prime the new configuration.
        //

        for ( ;; )
        {
            //
            //  Cleanup
            //
            if ( pccNode != NULL )
            {
                pccNode->Release();
                pccNode = NULL;
            }

            hr = STHR( pecNodes->Next( 1, &cookieFirst, &celtDummy ) );
            if ( hr == S_FALSE )
            {
                //
                //  We shouldn't make it here. There should be at least one node
                //  in the cluster that we are joining.
                //

                hr = THR( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Find_Formed_Node_Next, hr );
                goto Cleanup;
            }

            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_Compare_Resources_Find_Formed_Node_Next, hr );
                goto Cleanup;
            }

            //
            //  Retrieve the node information.
            //

            hr = THR( m_pom->GetObject( DFGUID_NodeInformation,
                                        cookieFirst,
                                        &punk
                                        ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareResources_NodeInfo_FindObject, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccNode ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareResources_NodeInfo_FindObject_QI, hr );
                goto Cleanup;
            }

            pccNode = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgNodeInfo", IClusCfgNodeInfo, pccNode, 1 );

            punk->Release();
            punk = NULL;

            hr = STHR( pccNode->IsMemberOfCluster() );
            if ( hr == S_OK )
                break;  // exit condition

        } // for: ever

    } // else: joining

    //
    //  Retrieve the node name in case of errors.
    //

    hr = THR( HrRetrieveCookiesName( TASKID_Major_Find_Devices,
                                     cookieFirst,
                                     &bstrName
                                     ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Retrieve the networks enumer.
    //

    hr = THR( m_pom->FindObject( CLSID_NetworkType,
                                 cookieFirst,
                                 NULL,
                                 DFGUID_EnumManageableNetworks,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                          IDS_TASKID_MINOR_NO_MANAGED_NETWORKS_FOUND,
                                          &bstrNotification
                                          ) );

        hr = THR( SendStatusReport( bstrName,
                                    TASKID_Major_Find_Devices,
                                    TASKID_Minor_No_Managed_Networks_Found,
                                    0,
                                    1,
                                    1,
                                    MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND ),
                                    bstrNotification,
                                    NULL,
                                    NULL
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );

        // fall thru - the while ( hr == S_OK ) will be false and keep going
    }
    else if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumResources_FindObject, hr );
        goto Cleanup;
    }
    else
    {
        hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumResources_FindObject_QI, hr );
            goto Cleanup;
        }

        peccn = TraceInterface( L"CTaskAnalyzeCluster!IEnumClusCfgNetworks", IEnumClusCfgNetworks, peccn, 1 );

        punk->Release();
        punk = NULL;
    }

    //
    //  Loop thru the first nodes networks create an equalivant network
    //  under the cluster configuration object/cookie.
    //

    while ( hr == S_OK )
    {

        //  Cleanup
        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        }

        //  Get next network
        hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetwork_Next, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
            break;  // exit condition

        pccni = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgNetworkInfo", IClusCfgNetworkInfo, pccni, 1 );

        //  create a new object
        hr = THR( HrCreateNewNetworkInClusterConfiguration( pccni, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;

    } // while: S_OK

    //
    //  Reset the enumeration.
    //

    hr = THR( pecNodes->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_Reset, hr );
        goto Cleanup;
    }

    //
    //  Loop thru the rest of the nodes comparing the networks.
    //

    do
    {
        //
        //  Cleanup
        //

        if ( peccn != NULL )
        {
            peccn->Release();
            peccn = NULL;
        }
        TraceSysFreeString( bstrName );
        bstrName = NULL;

        //
        //  Get the next node.
        //

        hr = STHR( pecNodes->Next( 1, &cookieNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_NextNode, hr );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
            break;  // exit condition

        if ( cookieNode == cookieFirst )
            continue;   // skip it

        //
        //  Retrieve the node's name
        //

        hr = THR( HrRetrieveCookiesName( TASKID_Major_Find_Devices,
                                         cookieNode,
                                         &bstrName
                                         ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Retrieve the networks enumer.
        //

        hr = THR( m_pom->FindObject( CLSID_NetworkType,
                                     cookieNode,
                                     NULL,
                                     DFGUID_EnumManageableNetworks,
                                     &cookieDummy,
                                     &punk
                                     ) );
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                              IDS_TASKID_MINOR_NO_MANAGED_NETWORKS_FOUND,
                                              &bstrNotification
                                              ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_Next_LoadString, hr );
                goto Cleanup;
            }

            hr = THR( SendStatusReport( bstrName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_No_Managed_Networks_Found,
                                        0,
                                        1,
                                        1,
                                        MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NOT_FOUND ),
                                        bstrNotification,
                                        NULL,
                                        NULL
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            continue;   // skip this node
        }
        else if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_Next_FindObject, hr );
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        peccn = TraceInterface( L"CTaskAnalyzeCluster!IEnumClusCfgNetworks", IEnumClusCfgNetworks, peccn, 1 );

        punk->Release();
        punk = NULL;

        //
        //  Loop thru the networks already that the node has.
        //

        do
        {
            //
            //  Cleanup
            //

            if ( pccni != NULL )
            {
                pccni->Release();
                pccni = NULL;
            }
            TraceSysFreeString( bstrUID );
            bstrUID = NULL;

            if ( peccnCluster != NULL )
            {
                peccnCluster->Release();
                peccnCluster = NULL;
            }

            //
            //  Get next network
            //

            hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Next, hr );
                goto Cleanup;
            }

            if ( hr == S_FALSE )
                break;  // exit condition

            pccni = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgNetworkInfo", IClusCfgNetworkInfo, pccni, 1 );

            //
            //  Grab the network's UUID.
            //

            hr = THR( pccni->GetUID( &bstrUID ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_GetUID, hr );
                goto Cleanup;
            }

            TraceMemoryAddBSTR( bstrUID );

            //
            //  See if it matches a network already in the cluster configuration.
            //

            hr = THR( m_pom->FindObject( CLSID_NetworkType,
                                         m_cookieCluster,
                                         NULL,
                                         DFGUID_EnumManageableNetworks,
                                         &cookieDummy,
                                         &punk
                                         ) );
            if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
            {
                hr = S_FALSE;   // create a new object.
                // fall thru
            }
            else if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_FindObject, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccnCluster ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_FindObject_QI, hr );
                goto Cleanup;
            }

            peccnCluster = TraceInterface( L"CTaskAnalyzeCluster!IEnumClusCfgNetworks", IEnumClusCfgNetworks, peccnCluster, 1 );

            punk->Release();
            punk = NULL;

            //
            //  Loop thru the configured cluster network to see what matches.
            //

            while( hr == S_OK )
            {
                HRESULT hrCluster;

                BOOL    fMatch;

                //
                //  Cleanup
                //

                if ( pccniCluster != NULL )
                {
                    pccniCluster->Release();
                    pccniCluster = NULL;
                }

                hr = STHR( peccnCluster->Next( 1, &pccniCluster, &celtDummy ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Cluster_Next, hr );
                    goto Cleanup;
                }

                if ( hr == S_FALSE )
                    break;  // exit condition

                pccniCluster = TraceInterface( L"CTaskAnalyzeCluster!IClusCfgNetworkInfo", IClusCfgNetworkInfo, pccniCluster, 1 );

                hr = THR( pccniCluster->GetUID( &bstrUIDExisting ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CompareNetworks_EnumNodes_EnumNetworks_Cluster_GetUID, hr );
                    goto Cleanup;
                }

                TraceMemoryAddBSTR( bstrUIDExisting );

                fMatch = ( wcscmp( bstrUID, bstrUIDExisting ) == 0 );
                TraceSysFreeString( bstrUIDExisting );

                if ( !fMatch )
                    continue;   // keep looping

                //
                //
                //  If we made it here then we think it truely is the same network. The
                //  rest is stuff we need to fixup during the commit phase.
                //
                //

                //
                //  Exit the loop with S_OK so we don't create a new network.
                //

                hr = S_OK;
                break;  // exit loop

            } // while: S_OK

            if ( hr == S_FALSE )
            {
                //
                //  Need to create a new object.
                //

                Assert( pccni != NULL );

                hr = THR( HrCreateNewNetworkInClusterConfiguration( pccni, NULL ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

            } // if: object not found

        } while ( hr == S_OK ); // networks

    } while ( hr == S_OK ); // nodes


    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrUID );
    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pecNodes != NULL )
    {
        pecNodes->Release();
    }
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( peccnCluster != NULL )
    {
        peccnCluster->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pccniCluster != NULL )
    {
        pccniCluster->Release();
    }
    if ( pccNode != NULL )
    {
        pccNode->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCompareNetworks()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCreateNewNetworkInClusterConfiguration(
//      IClusCfgNetworkInfo * pccniIn,
//      IClusCfgNetworkInfo ** pccniNewOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCreateNewNetworkInClusterConfiguration(
    IClusCfgNetworkInfo * pccniIn,
    IClusCfgNetworkInfo ** ppccniNewOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    BSTR    bstrUID = NULL;

    IUnknown *            punk  = NULL;
    IGatherData *         pgd   = NULL;
    IClusCfgNetworkInfo * pccni = NULL;

    //  grab the name
    hr = THR( pccniIn->GetUID( &bstrUID ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_GetUID, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( bstrUID );

    //  create an object in the object manager.
    hr = THR( m_pom->FindObject( CLSID_NetworkType,
                                 m_cookieCluster,
                                 bstrUID,
                                 DFGUID_NetworkResource,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_FindObject, hr );
        goto Cleanup;
    }

    //  find the IGatherData interface
    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_FindObject_QI, hr );
        goto Cleanup;
    }

    //  have the new object gather all information it needs
    hr = THR( pgd->Gather( m_cookieCluster, pccniIn ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_Gather, hr );
        goto Cleanup;
    }

    //  hand the object out if requested
    if ( ppccniNewOut != NULL )
    {
        // find the IClusCfgManagedResourceInfo
        hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Find_Devices, TASKID_Minor_CreateNetwork_QI, hr );
            goto Cleanup;
        }

        *ppccniNewOut = TraceInterface( L"ManagedDevice!ICCNI", IClusCfgNetworkInfo, pccni, 0 );
        (*ppccniNewOut)->AddRef();
    }

Cleanup:
    TraceSysFreeString( bstrUID );

    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCreateNewNetworkInClusterConfiguration()

//////////////////////////////////////////////////////////////////////////////
//
//
//  HRESULT
//  CTaskAnalyzeCluster::HrFreeCookies( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrFreeCookies( void )
{
    TraceFunc( "" );

    HRESULT hr;

    HRESULT hrReturn = S_OK;

    Assert( m_pom != NULL );

    while( m_cCookies != 0 )
    {
        m_cCookies --;

        if ( m_pcookies[ m_cCookies ] != NULL )
        {
            hr = THR( m_pom->RemoveObject( m_pcookies[ m_cCookies ] ) );
            if ( FAILED( hr ) )
            {
                hrReturn = hr;
            }
        }
    }

    Assert( m_cCookies == 0 );
    m_cSubTasksDone = 0;
    TraceFree( m_pcookies );
    m_pcookies = NULL;

    HRETURN( hrReturn );

} //*** CTaskAnalyzeCluster::HrFreeCookies()


//////////////////////////////////////////////////////////////////////////////
//
//
//  HRESULT
//  CTaskAnalyzeCluster::HrRetrieveCookiesName(
//      CLSID           clsidMajorIn,
//      OBJECTCOOKIE    cookieIn,
//      BSTR *          pbstrNameOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrRetrieveCookiesName(
    CLSID           clsidMajorIn,
    OBJECTCOOKIE    cookieIn,
    BSTR *          pbstrNameOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    IUnknown *      punk = NULL;
    IStandardInfo * psi  = NULL;

    Assert( cookieIn != NULL );
    Assert( pbstrNameOut != NULL );

    //
    //  Retrieve the node name in case of errors.
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                cookieIn,
                                &punk
                                ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( clsidMajorIn, TASKID_Minor_HrRetrieveCookiesName_FindObject_StandardInfo, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( clsidMajorIn, TASKID_Minor_HrRetrieveCookiesName_FindObject_StandardInfo_QI_psi, hr );
        goto Cleanup;
    }

    hr = THR( psi->GetName( pbstrNameOut ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( clsidMajorIn, TASKID_Minor_HrRetrieveCookiesName_GetName, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( *pbstrNameOut );

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrRetrieveCookiesName

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrCheckInteroperability( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrCheckInteroperability( void )
{
    TraceFunc( "" );
    Assert( m_pcm != NULL );

    HRESULT             hr = S_OK;
    RPC_STATUS          rpcs = RPC_S_OK;
    RPC_BINDING_HANDLE  rbhBindingHandle = NULL;
    LPWSTR              pszBindingString = NULL;
    BSTR                bstrNodeName = NULL;
    BSTR                bstrNotification = NULL;
    BSTR                bstrBindingString = NULL;
    DWORD               sc;
    IUnknown *          punk = NULL;
    bool                fAllNodesMatch;
    DWORD               dwSponsorNodeId;
    DWORD               dwClusterHighestVersion;
    DWORD               dwClusterLowestVersion;
    DWORD               dwJoinStatus;
    DWORD               dwNodeHighestVersion;
    DWORD               dwNodeLowestVersion;
    bool                fVersionMismatch = false;
    IClusCfgServer *    piccs = NULL;

    //
    //  If were are forming there is no need to do this check.
    //
    if ( !m_fJoiningMode )
    {
        goto Cleanup;
    } // if:

    //
    //  Tell the UI were are starting this.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CHECKINTEROPERABILITY, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_LoadString_Checking, hr );
        goto Cleanup;
    }

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Check_Cluster_Feasibility,
                                TASKID_Minor_CheckInteroperability,
                                0,
                                0,
                                1,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  All nodes must be at the same level diring a bulk add.
    //
    hr = STHR( HrEnsureAllJoiningNodesSameVersion( &dwNodeHighestVersion, &dwNodeLowestVersion, &fAllNodesMatch ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    //
    //  Just bail if no nodes found that are joining, then there isn't a need to
    //  do this check.
    //
    if ( hr == S_FALSE )
        goto Cleanup;

    if ( !fAllNodesMatch )
    {
        hr = THR( HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS ) );
        goto Cleanup;
    } // if:

    hr = THR( m_pcm->GetConnectionToObject( m_cookieCluster, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_GetConnectionObject, hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &piccs ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_ConfigConnection_QI, hr );
        goto Error;
    } // if:

    hr = THR( piccs->GetBindingString( &bstrBindingString ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_GetBindingString, hr );
        goto Error;
    } // if:

    TraceMemoryAddBSTR( bstrBindingString );

    // Create a string binding handle.
    rpcs = TW32( RpcStringBindingComposeW(
                  L"6e17aaa0-1a47-11d1-98bd-0000f875292e"
                , L"ncadg_ip_udp"
                , bstrBindingString
                , NULL
                , NULL
                , &pszBindingString
                ) );
    if ( rpcs != RPC_S_OK )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_RpcStringBindingComposeW, hr );
        goto RpcError;
    } // if: RpcStringBindingComposeW() failed

    // Get the actual binding handle
    rpcs = TW32( RpcBindingFromStringBindingW( pszBindingString, &rbhBindingHandle ) );
    if ( rpcs != RPC_S_OK )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_RpcBindingFromStringBindingW, hr );
        goto RpcError;
    } // if: RpcBindingFromStringBindingW() failed

    // Resolve the binding handle
    rpcs = TW32( RpcEpResolveBinding( rbhBindingHandle, JoinVersion_v2_0_c_ifspec ) );
    if ( rpcs != RPC_S_OK )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_RpcEpResolveBinding, hr );
        goto RpcError;
    } // if: RpcEpResolveBinding() failed

    // Set RPC security
    rpcs = TW32( RpcBindingSetAuthInfoW(
                      rbhBindingHandle
                    , NULL
                    , RPC_C_AUTHN_LEVEL_CONNECT
                    , RPC_C_AUTHN_WINNT
                    , NULL
                    , RPC_C_AUTHZ_NAME
                    ) );

    if ( rpcs != RPC_S_OK )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_RpcBindingSetAuthInfoW, hr );
        goto RpcError;
    } // if: RpcBindingSetAuthInfoW() failed

    //
    // Get and verify the sponsor version
    //
    //
    // From Whistler onwards, CsRpcGetJoinVersionData() will return a failure code in its last parameter
    // if the version of this node is not compatible with the sponsor version. Prior to this, the last
    // parameter always contained a success value and the cluster versions had to be compared subsequent to this
    // call. This will, however, still have to be done as long as interoperability with Win2K
    // is a requirement, since Win2K sponsors do not return an error in the last parameter.
    //

    sc = TW32( CsRpcGetJoinVersionData(
                          rbhBindingHandle
                        , 0
                        , dwNodeHighestVersion
                        , dwNodeLowestVersion
                        , &dwSponsorNodeId
                        , &dwClusterHighestVersion
                        , &dwClusterLowestVersion
                        , &dwJoinStatus
                        ) );

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrCheckInteroperability_CsRpcGetJoinVersionData, hr );
        goto Cleanup;
    } // if: CsRpcGetJoinVersionData() failed

    LogMsg(
          "[MT] ( Node Highest, Node Lowest ) = ( %#08x, %#08x ), ( Cluster Highest, Cluster Lowest ) = ( %#08x, %#08x )."
        , dwNodeHighestVersion
        , dwNodeLowestVersion
        , dwClusterHighestVersion
        , dwClusterLowestVersion
        );

    if ( dwJoinStatus == ERROR_SUCCESS )
    {
        DWORD   dwClusterMajorVersion = CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion );

        Assert( dwClusterMajorVersion >= ( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION - 1 ) );

        //
        //  Only want to join clusters that are no more than one version back.
        //
        if ( dwClusterMajorVersion < ( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION - 1 ) )
        {
            fVersionMismatch = true;
        } // if:
    } // if:  the join status was ok
    else
    {
        fVersionMismatch = true;
    } // else: join is not possible

    if ( fVersionMismatch )
    {
        hr = THR( HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS ) );
    } // if: there was a version mismatch
    else
    {
        Assert( hr == S_OK );
    }

    goto UpdateStatus;

RpcError:
    hr = HRESULT_FROM_WIN32( rpcs );

Error:
UpdateStatus:
    {
        HRESULT hr2;

        hr2 = THR( SendStatusReport( NULL,
                                     TASKID_Major_Check_Cluster_Feasibility,
                                     TASKID_Minor_CheckInteroperability,
                                     0,
                                     1,
                                     1,
                                     hr,
                                     NULL,
                                     NULL,
                                     NULL
                                     ) );
        if ( FAILED( hr2 ) )
        {
            hr = hr2;
        }
    }

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( rbhBindingHandle != NULL )
    {
        RpcBindingFree( &rbhBindingHandle );
    } // if:

    if ( pszBindingString != NULL )
    {
        RpcStringFree( &pszBindingString );
    } // if:

    if ( piccs != NULL )
    {
        piccs->Release();
    } // if:

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrBindingString );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrCheckInteroperability()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrEnsureAllJoiningNodesSameVersion(
//      DWORD * pdwNodeHighestVersionOut,
//      DWORD * pdwNodeLowestVersionOut,
//      bool *  pfAllNodesMatchOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrEnsureAllJoiningNodesSameVersion(
    DWORD * pdwNodeHighestVersionOut,
    DWORD * pdwNodeLowestVersionOut,
    bool *  pfAllNodesMatchOut
    )
{
    TraceFunc( "" );
    Assert( m_fJoiningMode );
    Assert( pdwNodeHighestVersionOut != NULL );
    Assert( pdwNodeLowestVersionOut != NULL );
    Assert( pfAllNodesMatchOut != NULL );

    HRESULT             hr = S_OK;
    OBJECTCOOKIE        cookieDummy;
    IUnknown *          punk  = NULL;
    IEnumNodes *        pen   = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    DWORD               rgdwNodeHighestVersion[ 2 ];
    DWORD               rgdwNodeLowestVersion[ 2 ];
    int                 idx = 0;
    BSTR                bstrDescription = NULL;
    BSTR                bstrNodeName = NULL;
    BSTR                bstrFirstNodeName = NULL;
    BOOL                fFoundAtLeastOneJoiningNode = FALSE;

    *pfAllNodesMatchOut = true;

    ZeroMemory( rgdwNodeHighestVersion, sizeof( rgdwNodeHighestVersion ) );
    ZeroMemory( rgdwNodeLowestVersion, sizeof( rgdwNodeLowestVersion ) );

    //
    //  Ask the object manager for the node enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType,
                                 m_cookieCluster,
                                 NULL,
                                 DFGUID_EnumNodes,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FindObject_QI, hr );
        goto Cleanup;
    }

    //
    //  Look at each node and ensure that they all have the same version.
    //

    Assert( SUCCEEDED( hr ) );
    while ( SUCCEEDED( hr ) )
    {
        ULONG   celtDummy;

        //
        //  Cleanup
        //

        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        } // if:

        //
        //  Get the next node.
        //

        hr = STHR( pen->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;  // exit condition
        } // if:

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_EnumNode_Next, hr );
            goto Cleanup;
        } // if:

        hr = STHR( pccni->IsMemberOfCluster() );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_Node_IsMemberOfCluster, hr );
            goto Cleanup;
        } // if:

        //
        //  Only want to check those nodes that are not already members of a cluster.  The nodes being added.
        //
        if ( hr == S_FALSE )
        {
            fFoundAtLeastOneJoiningNode = TRUE;

            hr = THR( pccni->GetClusterVersion( &rgdwNodeHighestVersion[ idx ], &rgdwNodeLowestVersion[ idx ] ) );
            if ( FAILED( hr ) )
            {
                SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_Node_GetClusterVersion, hr );
                goto Cleanup;
            } // if:

            idx++;

            //
            //  Need to get the another node's version.
            //
            if ( idx == 1 )
            {
                WCHAR * psz = NULL;

                hr = THR( pccni->GetName( &bstrFirstNodeName ) );
                if ( FAILED( hr ) )
                {
                    SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_GetName, hr );
                    goto Cleanup;
                } // if:

                psz = wcschr( bstrFirstNodeName, L'.' );
                if ( psz != NULL )
                {
                    *psz = L'\0';       // change from an FQDN to a simple node name.
                } // if:

                continue;
            } // if:

            //
            //  Let's compare two nodes at a time...
            //
            if ( idx == 2 )
            {
                if ( ( rgdwNodeHighestVersion[ 0 ] == rgdwNodeHighestVersion[ 1 ] )
                  && ( rgdwNodeLowestVersion[ 1 ] == rgdwNodeLowestVersion[ 1 ] ) )
                {
                    idx = 1;    // reset to put the next node's version values at the second position...
                    continue;
                } // if:
                else
                {
                    *pfAllNodesMatchOut = false;

                    hr = THR( pccni->GetName( &bstrNodeName ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_GetName, hr );
                        goto Cleanup;
                    } // if:

                    hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_NODES_VERSION_MISMATCH, &bstrDescription, bstrFirstNodeName ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrEnsureAllJoiningNodesSameVersion_FormatString, hr );
                        goto Cleanup;
                    } // if:

                    hr = THR( SendStatusReport( bstrNodeName,
                                                TASKID_Major_Check_Cluster_Feasibility,
                                                TASKID_Minor_CheckInteroperability,
                                                0,
                                                0,
                                                1,
                                                HRESULT_FROM_WIN32( ERROR_CLUSTER_INCOMPATIBLE_VERSIONS ),
                                                bstrDescription,
                                                NULL,
                                                NULL
                                                ) );
                    goto Cleanup;
                } // else:
            } // if:
        } // if:
    } // while: hr

    if ( !fFoundAtLeastOneJoiningNode )
    {
        THR( HrLoadStringIntoBSTR( g_hInstance,
                                   IDS_TASKID_MINOR_NO_JOINING_NODES_FOUND_FOR_VERSION_CHECK,
                                   &bstrDescription
                                   ) );

        hr = THR( SendStatusReport( NULL,
                                    TASKID_Major_Check_Cluster_Feasibility,
                                    TASKID_Minor_CheckInteroperability,
                                    0,
                                    1,
                                    1,
                                    S_FALSE,
                                    bstrDescription,
                                    NULL,
                                    NULL
                                    ) );

        hr = S_FALSE;
        goto Cleanup;
    }

    //
    //  Fill in the out args...
    //
    *pdwNodeHighestVersionOut = rgdwNodeHighestVersion[ 0 ];
    *pdwNodeLowestVersionOut = rgdwNodeLowestVersion[ 0 ];

    hr = S_OK;

Cleanup:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    if ( pen != NULL )
    {
        pen->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrFirstNodeName );
    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrEnsureAllJoiningNodesSameVersion()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrGetUsersNodesCookies( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrGetUsersNodesCookies( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   ulDummy;

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE    cookieDummy;

    ULONG   cNode;

    IUnknown *      punk = NULL;
    IEnumCookies *  pec  = NULL;

    //
    //  Get the cookie enumerator.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType, m_cookieCluster, NULL, DFGUID_EnumCookies, &cookieDummy, &punk ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_FindObject, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_FindObject_QI, hr );
        goto Cleanup;
    }

    pec = TraceInterface( L"CTaskAnalyzeCluster!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Enumerate the cookies to figure out how big a buffer to allocate.
    //

    for ( m_cUserNodes = 0; ; )
    {
        hr = STHR( pec->Next( 1, &cookie, &ulDummy ) );
        if ( hr == S_FALSE )
            break; // exit condition

        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_EnumCookies_Next, hr );
            goto Cleanup;
        }

        m_cUserNodes ++;

    } // for: ever

    //
    //  Allocate a buffer for the cookies.
    //

    m_pcookiesUser = (OBJECTCOOKIE *) TraceAlloc( 0, sizeof( OBJECTCOOKIE ) * m_cUserNodes );
    if ( m_pcookiesUser == NULL )
        goto OutOfMemory;

    //
    //  Reset the enumerator.
    //

    hr = THR( pec->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_EnumCookies_Reset, hr );
        goto Cleanup;
    }

    //
    //  Enumerate them again this time putting the cookies into the buffer.
    //

    for ( cNode = 0; cNode < m_cUserNodes; cNode ++ )
    {
        hr = THR( pec->Next( 1, &m_pcookiesUser[ cNode ], &ulDummy ) );
        AssertMsg( hr != S_FALSE, "We should never hit this because the count of nodes should change!" );
        if ( hr != S_OK )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_EnumCookies_Next2, hr );
            goto Cleanup;
        }

    } // for:

    Assert( cNode == m_cUserNodes );

#ifdef DEBUG
    hr = STHR( pec->Next( 1, &cookie, &ulDummy ) );
    Assert( hr == S_FALSE );
#endif

    hr = S_OK;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pec != NULL )
    {
        pec->Release();
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_ANALYSIS_FAILED( TASKID_Major_Establish_Connection, TASKID_Minor_GetUsersNodesCookies_OutOfMemory, hr );
    goto Cleanup;

} //*** CTaskAnalyzeCluster::HrGetUsersNodesCookies()


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskAnalyzeCluster::HrIsUserAddedNode( BSTR bstrNodeNameIn )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskAnalyzeCluster::HrIsUserAddedNode( BSTR bstrNodeNameIn )
{
    TraceFunc( "HrGetUsersNodesCookies( ... )\n" );

    HRESULT             hr;
    ULONG               cNode;
    IUnknown *          punk = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    BSTR                bstrNodeName = NULL;

    for ( cNode = 0; cNode < m_cUserNodes; cNode ++ )
    {
        hr = THR( m_pom->GetObject( DFGUID_NodeInformation, m_pcookiesUser[ cNode ], &punk ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrIsUserAddedNode_GetObject, hr );
            goto Cleanup;
        } // if:

        hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrIsUserAddedNode_GetObject_QI, hr );
            goto Cleanup;
        }

        punk->Release();
        punk = NULL;

        hr = THR( pccni->GetName( &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            SSR_ANALYSIS_FAILED( TASKID_Major_Check_Cluster_Feasibility, TASKID_Minor_HrIsUserAddedNode_GetName, hr );
            goto Cleanup;
        }

        TraceMemoryAddBSTR( bstrNodeName );

        pccni->Release();
        pccni = NULL;

        if ( wcscmp( bstrNodeNameIn, bstrNodeName ) == 0 )
        {
            hr = S_OK;
            break;
        } // if:

        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;

        hr = S_FALSE;
    } // for:

Cleanup:

    if ( pccni != NULL )
    {
        pccni->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** CTaskAnalyzeCluster::HrIsUserAddedNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\servicemanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ServiceMgr.cpp
//
//  Description:
//      Service Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
// #include "ServiceMgr.h" - already included in DLL.H

DEFINE_THISCLASS("CServiceManager")
#define CServiceManager CServiceManager
#define LPTHISCLASS CServiceManager *

//****************************************************************************
//
// Protected Global
//
//****************************************************************************
IServiceProvider * g_pspServiceManager = NULL;

//****************************************************************************
//
// Class Static Variables
//
//****************************************************************************
CRITICAL_SECTION *  CServiceManager::sm_pcs       = NULL;
BOOL                CServiceManager::sm_fShutDown = FALSE;

//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CServiceManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CServiceManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT     hr;
    LPUNKNOWN   punk = NULL;

    //
    // Create a critical section to prevent lines from being fragmented.
    //
    if ( CServiceManager::sm_pcs == NULL )
    {
        PCRITICAL_SECTION pNewCritSect =
            (PCRITICAL_SECTION) HeapAlloc( GetProcessHeap(), 0, sizeof( CRITICAL_SECTION ) );
        if ( pNewCritSect == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } // if: creation failed

        InitializeCriticalSection( pNewCritSect );

        // Make sure we only have one log critical section
        InterlockedCompareExchangePointer( (PVOID *) &CServiceManager::sm_pcs, pNewCritSect, 0 );
        if ( CServiceManager::sm_pcs != pNewCritSect )
        {
            DeleteCriticalSection( pNewCritSect );
            HeapFree( GetProcessHeap(), 0, pNewCritSect );

        } // if: already have another critical section

    } // if: no critical section created yet

    Assert( CServiceManager::sm_pcs != NULL );
    EnterCriticalSection( CServiceManager::sm_pcs );

    if ( g_pspServiceManager != NULL )
    {
        hr = THR( g_pspServiceManager->TypeSafeQI( IUnknown, ppunkOut ) );

    } // if: assign new service manager
    else
    {
        LPTHISCLASS pthis = new CServiceManager( );
        if ( pthis != NULL )
        {
            //
            //  Can't hold CS in Init.
            //
            LeaveCriticalSection( CServiceManager::sm_pcs );

            hr = THR( pthis->Init( ) );
            if ( SUCCEEDED( hr ) )
            {
                EnterCriticalSection( CServiceManager::sm_pcs );

                if ( g_pspServiceManager == NULL )
                {
                    // No REF - or we'll never die!
                    g_pspServiceManager = static_cast< IServiceProvider * >( pthis );
                    TraceMoveToMemoryList( g_pspServiceManager, g_GlobalMemoryList );
                }

                if ( SUCCEEDED( hr ) )
                {
                    hr = THR( g_pspServiceManager->TypeSafeQI( IUnknown, ppunkOut ) );
                }


            } // if: its our pointer

        } // if: got object

        pthis->Release( );

    } // else: create new one

    LeaveCriticalSection( CServiceManager::sm_pcs );

Cleanup:
    HRETURN( hr );

} //*** CServiceManager::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CServiceManager::CServiceManager( void )
//
//////////////////////////////////////////////////////////////////////////////
CServiceManager::CServiceManager( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CServiceManager::CServiceManager( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CServiceManager::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceManager::Init( void )
{
    TraceFunc( "" );

    HRESULT hr;

    ITaskManager    *       ptm = NULL;
    IDoTask         *       pdt = NULL;
    IObjectManager *        pom = NULL;
    INotificationManager *  pnm = NULL;
    IConnectionManager *    pcm = NULL;
    ILogManager *           plm = NULL;


    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );

    // IServiceProvider
    Assert( m_dwLogManagerCookie == 0 );
    Assert( m_dwConnectionManagerCookie == 0 );
    Assert( m_dwNotificationManagerCookie == 0 );
    Assert( m_dwObjectManagerCookie == 0 );
    Assert( m_dwTaskManagerCookie == 0 );
    Assert( m_pgit == NULL );

    // IServiceProvider stuff
    hr = THR( HrCoCreateInternalInstance( CLSID_ObjectManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IObjectManager, &pom ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( HrCoCreateInternalInstance( CLSID_TaskManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( ITaskManager, &ptm ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( HrCoCreateInternalInstance( CLSID_NotificationManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( INotificationManager, &pnm ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( HrCoCreateInternalInstance( CLSID_ClusterConnectionManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IConnectionManager, &pcm ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( HrCoCreateInternalInstance( CLSID_LogManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( ILogManager, &plm ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Store the interfaces in the GIT.
    //

    hr = THR( CoCreateInstance(
                      CLSID_StdGlobalInterfaceTable
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IGlobalInterfaceTable
                    , reinterpret_cast< void ** >( &m_pgit )
                    ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_pgit->RegisterInterfaceInGlobal( pom, IID_IObjectManager, &m_dwObjectManagerCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_pgit->RegisterInterfaceInGlobal( ptm, IID_ITaskManager, &m_dwTaskManagerCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_pgit->RegisterInterfaceInGlobal( pnm, IID_INotificationManager, &m_dwNotificationManagerCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_pgit->RegisterInterfaceInGlobal( pcm, IID_IConnectionManager, &m_dwConnectionManagerCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_pgit->RegisterInterfaceInGlobal( plm, IID_ILogManager, &m_dwLogManagerCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( pnm != NULL )
    {
        pnm->Release( );
    }
    if ( pcm != NULL )
    {
        pcm->Release( );
    }
    if ( plm != NULL )
    {
        plm->Release( );
    }
    if ( ptm != NULL )
    {
        ptm->Release( );
    }
    if ( pdt != NULL )
    {
        pdt->Release( );
    }

    HRETURN( hr );

} //*** CServiceManager::Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CServiceManager::~CServiceManager( void )
//
//////////////////////////////////////////////////////////////////////////////
CServiceManager::~CServiceManager( void )
{
    TraceFunc( "" );

    //HRESULT                 hr;
    //ITaskManager    *       ptm = NULL;
    //IDoTask         *       pdt = NULL;
    //IObjectManager *        pom = NULL;
    //INotificationManager *  pnm = NULL;
    //IConnectionManager *    pcm = NULL;
    //ILogManager *           plm = NULL;

    //
    // Indicate that we are shutting down.
    //
    sm_fShutDown = TRUE;

    EnterCriticalSection( CServiceManager::sm_pcs );

    if ( g_pspServiceManager == static_cast< IServiceProvider * >( this ) )
    {
        TraceMoveFromMemoryList( g_pspServiceManager, g_GlobalMemoryList );
        g_pspServiceManager = NULL;
    } // if: its our pointer

    if ( m_pgit != NULL )
    {
        if ( m_dwLogManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwLogManagerCookie ) );
        }

        if ( m_dwConnectionManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwConnectionManagerCookie ) );
        }

        if ( m_dwNotificationManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwNotificationManagerCookie ) );
        }

        if ( m_dwObjectManagerCookie != 0 )
        {

            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwObjectManagerCookie ) );
        }

        if ( m_dwTaskManagerCookie != 0 )
        {
            THR( m_pgit->RevokeInterfaceFromGlobal( m_dwTaskManagerCookie ) );
        }

        m_pgit->Release( );
    }

    LeaveCriticalSection( CServiceManager::sm_pcs );

    //
    //  TODO:   gpease  01-AUG-2000
    //          Figure out a way to free the CS.
    //

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CServiceManager::~CServiceManager( )


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CServiceManager::QueryInterface(
//      REFIID riidIn,
//      LPVOID *ppvOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceManager::QueryInterface(
    REFIID riidIn,
    LPVOID *ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< LPUNKNOWN >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IServiceProvider ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IServiceProvider, this, 0 );
        hr = S_OK;
    } // else if: IQueryService

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CServiceManager::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CServiceManager::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CServiceManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CServiceManager::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CServiceManager::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CServiceManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CServiceManager::Release( )


//****************************************************************************
//
// IServiceProvider
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CServiceManager::QueryService(
//      REFCLSID rclsidIn,
//      REFIID   riidInIn,
//      void **  ppvOutOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceManager::QueryService(
    REFCLSID rclsidIn,
    REFIID   riidInIn,
    void **  ppvOutOut
    )
{
    TraceFunc( "[IServiceProvider]" );

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    if ( m_pgit != NULL )
    {
        if ( IsEqualIID( rclsidIn, CLSID_ObjectManager ) )
        {
            IObjectManager * pom;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwObjectManagerCookie, TypeSafeParams( IObjectManager, &pom ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pom->QueryInterface( riidInIn, ppvOutOut ) );
            pom->Release( );
            // fall thru
        }
        else if ( IsEqualIID( rclsidIn, CLSID_TaskManager ) )
        {
            ITaskManager * ptm;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwTaskManagerCookie, TypeSafeParams( ITaskManager, &ptm ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( ptm->QueryInterface( riidInIn, ppvOutOut ) );
            ptm->Release( );
            // fall thru
        }
        else if ( IsEqualIID( rclsidIn, CLSID_NotificationManager ) )
        {
            INotificationManager * pnm;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwNotificationManagerCookie, TypeSafeParams( INotificationManager, &pnm ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pnm->QueryInterface( riidInIn, ppvOutOut ) );
            pnm->Release( );
            // fall thru
        }
        else if ( IsEqualIID( rclsidIn, CLSID_ClusterConnectionManager ) )
        {
            IConnectionManager * pcm;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwConnectionManagerCookie, TypeSafeParams( IConnectionManager, &pcm ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pcm->QueryInterface( riidInIn, ppvOutOut ) );
            pcm->Release( );
            // fall thru
        }
        else if ( IsEqualIID( rclsidIn, CLSID_LogManager ) )
        {
            ILogManager * plm;

            hr = THR( m_pgit->GetInterfaceFromGlobal( m_dwLogManagerCookie, TypeSafeParams( ILogManager, &plm ) ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( plm->QueryInterface( riidInIn, ppvOutOut ) );
            plm->Release( );
            // fall thru
        }
    }

Cleanup:
    HRETURN( hr );

} //*** CServiceManager::QueryService( )


//****************************************************************************
//
// Private Methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
// HRESULT
// CServiceManager::S_HrGetManagerPointer(
//      IServiceProvider ** ppspOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CServiceManager::S_HrGetManagerPointer(
    IServiceProvider ** ppspOut
    )
{
    TraceFunc( "ppspOut" );

    HRESULT hr = HRESULT_FROM_WIN32( ERROR_PROCESS_ABORTED );

    if ( CServiceManager::sm_fShutDown == FALSE )
    {
        EnterCriticalSection( CServiceManager::sm_pcs );

        if ( g_pspServiceManager != NULL )
        {
            *ppspOut = TraceInterface( __THISCLASS__,
                                       IServiceProvider,
                                       g_pspServiceManager,
                                       0
                                       );
            (*ppspOut)->AddRef( );
            hr = S_OK;
        } // if: valid service manager
        else
        {
            hr = E_POINTER;
        } // else: no pointer

        LeaveCriticalSection( CServiceManager::sm_pcs );

    } // if: still up

    HRETURN ( hr );

} //*** CServiceManager::S_HrGetManagerPointer( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskanalyzecluster.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskAnalyzeCluster.h
//
//  Description:
//      CTaskAnalyzeCluster implementation.
//
//  Maintained By:
//      Galen Barbee    (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskAnalyzeCluster
class
CTaskAnalyzeCluster:
    public ITaskAnalyzeCluster,
    public IClusCfgCallback,
    public INotifyUI
{
private:
    // IUnknown
    LONG                    m_cRef;

    // ITaskAnalyzeCluster
    OBJECTCOOKIE            m_cookieCompletion; // Task completion cookie
    IClusCfgCallback *      m_pcccb;            // Callback interface
    OBJECTCOOKIE *          m_pcookies;         // Completion cookies for the subtasks.
    ULONG                   m_cCookies;         // Count of completion cookies in m_pcookies
    ULONG                   m_cNodes;           // Count of nodes in configuration
    HANDLE                  m_event;            // Synchronization event to signal when subtasks have completed.
    OBJECTCOOKIE            m_cookieCluster;    // Cookie of the cluster to analyze
    BSTR                    m_bstrClusterName;  // Name of the cluster to analyze
    BOOL                    m_fJoiningMode;     // FALSE = forming mode. TRUE = joining mode.
    ULONG                   m_cUserNodes;       // The count of nodes that the user entered. It is also the "sizeof" the array, m_pcookiesUser.
    OBJECTCOOKIE *          m_pcookiesUser;     // The cookies of nodes that the user entered.
    BSTR                    m_bstrNodeName;

    INotifyUI *             m_pnui;
    IObjectManager *        m_pom;
    ITaskManager *          m_ptm;
    IConnectionManager *    m_pcm;

    BSTR                    m_bstrQuorumUID;    //  Quorum device UID

    bool                    m_fStop;

    // INotifyUI
    ULONG                   m_cSubTasksDone;    // The number of subtasks done.
    HRESULT                 m_hrStatus;         // Status of callbacks

    CTaskAnalyzeCluster( void );
    ~CTaskAnalyzeCluster( void );
    STDMETHOD( Init )( void );

    HRESULT HrWaitForClusterConnection( void );
    HRESULT HrCountNumberOfNodes( void );
    HRESULT HrCreateSubTasksToGatherNodeInfo( void );
    HRESULT HrCreateSubTasksToGatherNodeResourcesAndNetworks( void );
    HRESULT HrCheckClusterFeasibility( void );
    HRESULT HrAddJoinedNodes( void );
    HRESULT HrCheckClusterMembership( void );
    HRESULT HrCompareResources( void );
    HRESULT HrCreateNewManagedResourceInClusterConfiguration( IClusCfgManagedResourceInfo * pccmriIn, IClusCfgManagedResourceInfo ** ppccmriNewOut );
    HRESULT HrCheckForCommonQuorumResource( void );
    HRESULT HrCompareNetworks( void );
    HRESULT HrCreateNewNetworkInClusterConfiguration( IClusCfgNetworkInfo * pccmriIn, IClusCfgNetworkInfo ** ppccmriNewOut );
    HRESULT HrFreeCookies( void );
    HRESULT HrRetrieveCookiesName( CLSID clsidMajorIn, OBJECTCOOKIE cookieIn, BSTR * pbstrNameOut );
    HRESULT HrCheckInteroperability( void );
    HRESULT HrEnsureAllJoiningNodesSameVersion( DWORD * pdwNodeHighestVersionOut, DWORD * pdwNodeLowestVersionOut, bool * pfAllNodesMatchOut );
    HRESULT HrGetUsersNodesCookies( void );
    HRESULT HrIsUserAddedNode( BSTR bstrNodeNameIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskAnalyzeCluster
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetJoiningMode )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetClusterCookie )( OBJECTCOOKIE cookieClusterIn );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    // INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn );

}; // class CTaskAnalyzeCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskcompareandpushinformation.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskCompareAndPushInformation.h
//
//  Description:
//      CTaskCompareAndPushInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskCompareAndPushInformation
class
CTaskCompareAndPushInformation
    : public ITaskCompareAndPushInformation
    , public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;

    // IDoTask / ITaskCompareAndPushInformation
    OBJECTCOOKIE        m_cookieCompletion;
    OBJECTCOOKIE        m_cookieNode;
    IClusCfgCallback *  m_pcccb;                // Marshalled interface

    // INotifyUI
    HRESULT             m_hrStatus;             // Status of callbacks

    IObjectManager *    m_pom;
    BSTR                m_bstrNodeName;

    CTaskCompareAndPushInformation( void );
    ~CTaskCompareAndPushInformation( void );

    STDMETHOD( Init )( void );

    HRESULT HrVerifyCredentials( IClusCfgServer * pccsIn, OBJECTCOOKIE cookieClusterIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskCompareAndPushInformation
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetNodeCookie )( OBJECTCOOKIE cookieIn );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; // class CTaskCompareAndPushInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskcompareandpushinformation.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskCompareAndPushInformation.cpp
//
//  Description:
//      CTaskCompareAndPushInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 21-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskCompareAndPushInformation.h"
#include "ManagedDevice.h"
#include "ManagedNetwork.h"

DEFINE_THISCLASS("CTaskCompareAndPushInformation")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCompareAndPushInformation::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCompareAndPushInformation::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CTaskCompareAndPushInformation * ptcapi = new CTaskCompareAndPushInformation;
    if ( ptcapi != NULL )
    {
        hr = THR( ptcapi->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( ptcapi->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        ptcapi->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskCompareAndPushInformation::CTaskCompareAndPushInformation( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskCompareAndPushInformation::CTaskCompareAndPushInformation( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CTaskCompareAndPushInformation()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    // IDoTask / ITaskCompareAndPushInformation
    Assert( m_cookieCompletion == NULL );
    Assert( m_cookieNode == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_pom == NULL );
    Assert( m_hrStatus == S_OK );
    Assert( m_bstrNodeName == NULL );

    HRETURN( hr );
} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskCompareAndPushInformation::~CTaskCompareAndPushInformation()
//
//////////////////////////////////////////////////////////////////////////////
CTaskCompareAndPushInformation::~CTaskCompareAndPushInformation()
{
    TraceFunc( "" );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    TraceSysFreeString( m_bstrNodeName );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CTaskCompareAndPushInformation()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< ITaskCompareAndPushInformation * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IDoTask ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr   = S_OK;
    } // else if: IDoTask
    else if ( IsEqualIID( riid, IID_ITaskCompareAndPushInformation ) )
    {
        *ppv = TraceInterface( __THISCLASS__, ITaskCompareAndPushInformation, this, 0 );
        hr   = S_OK;
    } // else if: ITaskCompareAndPushInformation

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskCompareAndPushInformation::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskCompareAndPushInformation::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskCompareAndPushInformation::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskCompareAndPushInformation::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release()



//****************************************************************************
//
//  ITaskCompareAndPushInformation
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::BeginTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;
    ULONG   celt;
    ULONG   celtDummy;

    OBJECTCOOKIE    cookieCluster;
    OBJECTCOOKIE    cookieDummy;

    SDriveLetterMapping dlm;

    BSTR    bstrNotification = NULL;
    BSTR    bstrRemote       = NULL;    // reused many times
    BSTR    bstrLocal        = NULL;    // reuser many times

    ULONG   celtFetched = 0;

    IServiceProvider *          psp   = NULL;
    IUnknown *                  punk  = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    IConnectionManager *        pcm   = NULL;
    IClusCfgServer *            pccs  = NULL;
    IStandardInfo *             psi   = NULL;
    INotifyUI *                 pnui  = NULL;

    IEnumClusCfgNetworks *      peccnLocal    = NULL;
    IEnumClusCfgNetworks *      peccnRemote   = NULL;

    IEnumClusCfgManagedResources * peccmrLocal = NULL;
    IEnumClusCfgManagedResources * peccmrRemote = NULL;

    IClusCfgManagedResourceInfo *  pccmri[ 10 ] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    IClusCfgManagedResourceInfo *  pccmriLocal = NULL;

    IClusCfgNetworkInfo *          pccni[ 10 ]  = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    IClusCfgNetworkInfo *          pccniLocal = NULL;


    TraceInitializeThread( L"TaskCompareAndPushInformation" );

    //
    //  Gather the manager we need to complete our tasks.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &m_pom
                               ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               &pcpc
                               ) );
    if ( FAILED( hr ) )
        goto Error;

    pcpc = TraceInterface( L"CTaskCompareAndPushInformation!IConnectionPointContainer", IConnectionPointContainer, pcpc, 1 );

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
        goto Error;

    pcp = TraceInterface( L"CTaskCompareAndPushInformation!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Error;

//    TraceMoveFromMemoryList( pnui, g_GlobalMemoryList );

    pnui = TraceInterface( L"CTaskCompareAndPushInformation!INotifyUI", INotifyUI, pnui, 1 );

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager,
                               IConnectionManager,
                               &pcm
                               ) );
    if ( FAILED( hr ) )
        goto Error;

    psp->Release();            // release promptly
    psp = NULL;

    //
    //  Ask the object manager for the name of the node.
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo,
                              m_cookieNode,
                              &punk
                              ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
        goto Error;

    psi = TraceInterface( L"TaskCompareAndPushInformation!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    hr = THR( psi->GetName( &m_bstrNodeName ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrNodeName );

    // done with it.
    psi->Release();
    psi = NULL;

    //
    //  Tell the UI layer we're starting to gather the resources.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_TASKID_MINOR_GATHERING_MANAGED_DEVICES,
                                    &bstrNotification
                                    ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Reanalyze,
                                TASKID_Minor_Gathering_Managed_Devices,
                                0,
                                2,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Ask the connection manager for a connection to the node.
    //

    hr = THR( pcm->GetConnectionToObject( m_cookieNode,
                                          &punk
                                          ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
        goto Error;

    punk->Release();
    punk = NULL;

    //
    //  Figure out the parent cluster of the node.
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo,
                              m_cookieNode,
                              &punk
                              ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
        goto Error;

    psi = TraceInterface( L"TaskCompareAndPushInformation!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    hr = THR( psi->GetParent( &cookieCluster ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  This function does its own error reporting.  No need to goto error and
    //  report it again.
    //
    hr = THR( HrVerifyCredentials( pccs, cookieCluster ) );
    if ( FAILED( hr ) )
        goto Cleanup;   // silently fail

    //
    //  Ask the connection for the enumer for managed resources.
    //

    hr = THR( pccs->GetManagedResourcesEnum( &peccmrRemote ) );
    if ( FAILED( hr ) )
        goto Error;

    peccmrRemote = TraceInterface( L"CTaskCompareAndPushInformation!GetManagedResourceEnum", IEnumClusCfgManagedResources, peccmrRemote, 1 );

    //
    //  Ask the Object Manager for the enumer for managed resources.
    //
    // Don't wrap - this can fail.
    hr = m_pom->FindObject( CLSID_ManagedResourceType,
                          cookieCluster,
                          NULL,
                          DFGUID_EnumManageableResources,
                          &cookieDummy,
                          &punk
                          );
    if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) )
        goto PushNetworks;

    if ( FAILED( hr ) )
    {
        Assert( punk == NULL );
        THR( hr );
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources,
                                &peccmrLocal
                                ) );
    if ( FAILED( hr ) )
        goto Error;

    peccmrLocal = TraceInterface( L"CTaskCompareAndPushInformation!IEnumClusCfgManagedResources", IEnumClusCfgManagedResources, peccmrLocal, 1 );

    punk->Release();
    punk = NULL;

    //
    //  Enumerate the next 10 resources.
    //
    for( ;; )
    {
        //
        //  Get next remote managed device(s).
        //

        hr = STHR( peccmrRemote->Next( 10, pccmri, &celtFetched ) );
        if ( hr == S_FALSE && celtFetched == 0 )
            break;  // exit loop

        if ( FAILED( hr ) )
            goto Error;

        //
        //  Loop thru the resource gather information out of each of them
        //  and then release them.
        //
        for( celt = 0; celt < celtFetched; celt ++ )
        {
            DWORD   dwLenRemote;

            //
            //  Error
            //

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            Assert( pccmri[ celt ] != NULL );

            //
            //  Get the UID of the remote resource.
            //

            hr = THR( pccmri[ celt ]->GetUID( &bstrRemote ) );
            if ( FAILED( hr ) )
                goto Error;

            TraceMemoryAddBSTR( bstrRemote );

            dwLenRemote = SysStringByteLen( bstrRemote );

            //
            //  Try to match this resource with one in the object manager.
            //

            hr = THR( peccmrLocal->Reset() );
            if ( FAILED( hr ) )
            {
                goto Error;
            } // if:

            for( ;; )
            {
                DWORD   dwLenLocal;

                //
                //  Error
                //

                TraceSysFreeString( bstrLocal );
                bstrLocal = NULL;

                //
                //  Get next local managed device.
                //

                hr = STHR( peccmrLocal->Next( 1, &pccmriLocal, &celtDummy ) );
                if ( hr == S_FALSE )
                {
                    //
                    //  If we exhausted all the devices but did not match the device
                    //  in our cluster configuration, this means something changed
                    //  on the remote node. Send up an error!
                    //

                    //
                    //  TODO:   gpease  24-MAR-2000
                    //          Find a better error code and SendStatusReport!
                    //
                    hr = THR( ERROR_RESOURCE_NOT_FOUND );
                    goto Error;
                }

                if ( FAILED( hr ) )
                    goto Error;

                hr = THR( pccmriLocal->GetUID( &bstrLocal ) );
                if ( FAILED( hr ) )
                    goto Error;

                TraceMemoryAddBSTR( bstrLocal );

                dwLenLocal  = SysStringByteLen( bstrLocal );

                if ( dwLenRemote == dwLenLocal
                  && memcmp( bstrRemote, bstrLocal, dwLenLocal ) == 0
                   )
                {
                    Assert( hr == S_OK );
                    break;  // match!
                }

            } // for: hr

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  If we made it here, we have a resource in pccmriLocal that matches
            //  the resource in pccmri[ celt ].
            //
            Assert( pccmriLocal != NULL );

            //
            //
            //  Push the data down to the node.
            //
            //

            //
            //  Update the name (if needed).
            //

            hr = THR( pccmriLocal->GetName( &bstrLocal ) );
            if ( FAILED( hr ) )
                goto Error;

            TraceMemoryAddBSTR( bstrLocal );

            hr = THR( pccmri[ celt ]->GetName( &bstrRemote ) );
            if ( FAILED( hr ) )
                goto Error;

            TraceMemoryAddBSTR( bstrRemote );

            if ( wcscmp( bstrLocal, bstrRemote ) != 0 )
            {
                hr = STHR( pccmri[ celt ]->SetName( bstrLocal ) );
                if ( FAILED( hr ) )
                    goto Error;
            }

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  Update IsManaged?
            //

            hr = STHR( pccmriLocal->IsManaged() );
            if ( FAILED( hr ) )
                goto Error;

            hr = THR( pccmri[ celt ]->SetManaged( hr == S_OK ) );
            if ( FAILED( hr ) )
                goto Error;

            //
            //  Update IsQuorum?
            //

            hr = STHR( pccmriLocal->IsQuorumDevice() );
            if ( FAILED( hr ) )
                goto Error;

            hr = THR( pccmri[ celt ]->SetQuorumedDevice( hr == S_OK ) );
            if ( FAILED( hr ) )
                goto Error;

            //
            //  Update DriveLetterMappings
            //

            //
            //  KB: gpease  31-JUL-2000
            //      We currently don't support setting the drive letter mappings
            //

            //  release the interface
            pccmri[ celt ]->Release();
            pccmri[ celt ] = NULL;

            pccmriLocal->Release();
            pccmriLocal = NULL;

        } // for: celt

    } // while: hr

PushNetworks:

#if defined(DEBUG)
    //
    //  Make sure the strings are really freed after exitting the loop.
    //
    Assert( bstrLocal == NULL );
    Assert( bstrRemote == NULL );
#endif // DEBUG

    //
    //  Tell the UI layer we're done will gathering the resources.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Reanalyze,
                                TASKID_Minor_Gathering_Managed_Devices,
                                0,
                                2,
                                1,
                                S_OK,
                                NULL,   // don't need to update message
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Now gather the networks from the node.
    //


    //
    //  Ask the connection for the enumer for the networks.
    //

    hr = THR( pccs->GetNetworksEnum( &peccnRemote ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Ask the Object Manager for the enumer for managed resources.
    //

    hr = THR( m_pom->FindObject( CLSID_NetworkType,
                               NULL,
                               NULL,
                               DFGUID_EnumManageableNetworks,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccnLocal ) );
    if ( FAILED( hr ) )
        goto Error;

    punk->Release();
    punk = NULL;

    //
    //  Enumerate the next 10 networks.
    //
    for( ;; )
    {
        //
        //  Get the next 10 networks.
        //

        hr = STHR( peccnRemote->Next( 10, pccni, &celtFetched ) );
        if ( hr == S_FALSE && celtFetched == 0 )
            break;  // exit loop

        if ( FAILED( hr ) )
            goto Error;

        //
        //  Loop thru the networks gather information out of each of them
        //  and then release them.
        //

        for( celt = 0; celt < celtFetched; celt ++ )
        {
            DWORD   dwLenRemote;

            //
            //  Error
            //

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  Get the UID of the remote network.
            //

            hr = THR( pccni[ celt ]->GetUID( &bstrRemote ) );
            if ( FAILED( hr ) )
                goto Error;

            TraceMemoryAddBSTR( bstrRemote );

            dwLenRemote = SysStringByteLen( bstrRemote );

            //
            //  Try to match this resource with one in the object manager.
            //

            hr = THR( peccnLocal->Reset() );
            if ( FAILED( hr ) )
            {
                goto Error;
            } // if:

            for ( ;; )
            {
                DWORD   dwLenLocal;

                //
                //  Error
                //

                TraceSysFreeString( bstrLocal );
                bstrLocal = NULL;

                //
                //  Get next network from the cluster configuration.
                //

                hr = STHR( peccnLocal->Next( 1, &pccniLocal, &celtDummy ) );
                if ( hr == S_FALSE )
                    break;

                if ( FAILED( hr ) )
                    goto Error;

                hr = THR( pccniLocal->GetUID( &bstrLocal ) );
                if ( FAILED( hr ) )
                    goto Error;

                TraceMemoryAddBSTR( bstrLocal );

                dwLenLocal  = SysStringByteLen( bstrLocal );

                if ( dwLenRemote == dwLenLocal
                  && memcmp( bstrRemote, bstrLocal, dwLenLocal ) == 0
                   )
                {
                    Assert( hr == S_OK );
                    break;  // match!
                }

            } // while: hr

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  If we come out of the loop with S_FALSE, that means the
            //  node has a resource that we did not see during the analysis.
            //  Send up an error.
            //
            if ( hr == S_FALSE )
            {
                //
                //  TODO:   gpease  24-MAR-2000
                //          Find a better error code.
                //
                hr = THR( E_FAIL );
                goto Error;
            }

            //
            //  If we made it here, we have a resource in pccniLocal that matches
            //  the resource in pccmri[ celt ].
            //
            Assert( pccniLocal != NULL );

            //
            //
            //  Push the data down to the node.
            //
            //

            //
            //  Set Name
            //

            hr = THR( pccniLocal->GetName( &bstrLocal ) );
            if ( FAILED( hr ) )
                goto Error;

            TraceMemoryAddBSTR( bstrLocal );

            hr = THR( pccni[ celt ]->GetName( &bstrRemote ) );
            if ( FAILED( hr ) )
                goto Error;

            TraceMemoryAddBSTR( bstrRemote );

            if ( wcscmp( bstrLocal, bstrRemote ) != 0 )
            {
                hr = STHR( pccni[ celt ]->SetName( bstrLocal ) );
                if ( FAILED( hr ) )
                    goto Error;
            }

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  Set Description
            //

            hr = THR( pccniLocal->GetDescription( &bstrLocal ) );
            if ( FAILED( hr ) )
                goto Error;

            TraceMemoryAddBSTR( bstrLocal );

            hr = THR( pccni[ celt ]->GetDescription( &bstrRemote ) );
            if ( FAILED( hr ) )
                goto Error;

            TraceMemoryAddBSTR( bstrRemote );

            if ( wcscmp( bstrLocal, bstrRemote ) != 0 )
            {
                hr = STHR( pccni[ celt ]->SetDescription( bstrLocal ) );
                if ( FAILED( hr ) )
                    goto Error;
            }

            TraceSysFreeString( bstrLocal );
            bstrLocal = NULL;

            TraceSysFreeString( bstrRemote );
            bstrRemote = NULL;

            //
            //  KB: gpease  31-JUL-2000
            //      We don't support reconfiguring the IP Address remotely because
            //      our connection to the server will be cut when the IP stack on
            //      the remote machine reconfigs.
            //

            //
            //  Set IsPublic?
            //

            hr = STHR( pccniLocal->IsPublic() );
            if ( FAILED( hr ) )
                goto Error;

            hr = THR( pccni[ celt ]->SetPublic( hr == S_OK ) );
            if ( FAILED( hr ) )
                goto Error;

            //
            //  Set IsPrivate?
            //

            hr = STHR( pccniLocal->IsPrivate() );
            if ( FAILED( hr ) )
                goto Error;

            hr = THR( pccni[ celt ]->SetPrivate( hr == S_OK ) );
            if ( FAILED( hr ) )
                goto Error;

            //  release the interface
            pccni[ celt ]->Release();
            pccni[ celt ] = NULL;

            pccniLocal->Release();
            pccniLocal = NULL;

        } // for: celt

    } // while: hr

#if defined(DEBUG)
    //
    //  Make sure the strings are really freed after exitting the loop.
    //
    Assert( bstrLocal == NULL );
    Assert( bstrRemote == NULL );
#endif // DEBUG

    hr = S_OK;

Error:
    //
    //  Tell the UI layer we're done will gathering and what the resulting
    //  status was.
    //

    THR( SendStatusReport( m_bstrNodeName,
                           TASKID_Major_Reanalyze,
                           TASKID_Minor_Gathering_Managed_Devices,
                           0,
                           2,
                           2,
                           hr,
                           NULL,    // don't need to update message
                           NULL,
                           NULL
                           ) );

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrRemote );
    TraceSysFreeString( bstrLocal );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( m_pom != NULL )
    {
        HRESULT hr2;
        IUnknown * punk;

        hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                   m_cookieCompletion,
                                   &punk
                                   ) );

        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pcm != NULL )
    {
        pcm->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( pnui != NULL )
    {
        THR( pnui->ObjectChanged( m_cookieCompletion ) );
        pnui->Release();
    }
    if ( peccnLocal != NULL )
    {
        peccnLocal->Release();
    }
    if ( peccnRemote != NULL )
    {
        peccnRemote->Release();
    }
    if ( peccmrLocal != NULL )
    {
        peccmrLocal->Release();
    }
    if ( peccmrRemote != NULL )
    {
        peccmrRemote->Release();
    }
    for( celt = 0; celt < 10; celt ++ )
    {
        if ( pccmri[ celt ] != NULL )
        {
            pccmri[ celt ]->Release();
        }
        if ( pccni[ celt ] != NULL )
        {
            pccni[ celt ]->Release();
        }

    } // for: celt
    if ( pccmriLocal != NULL )
    {
        pccmriLocal->Release();
    }
    if ( pccniLocal != NULL )
    {
        pccniLocal->Release();
    }

    HRETURN( hr );

} // BeginTask()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CTaskCompareAndPushInformation::StopTask


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::SetCompletionCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::SetCompletionCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskCompareAndPushInformation]" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} // SetCompletionCookie()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::SetNodeCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::SetNodeCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskCompareAndPushInformation]" );

    HRESULT hr = S_OK;

    m_cookieNode = cookieIn;

    HRETURN( hr );

} // SetNodeCookie()


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCompareAndPushInformation::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCompareAndPushInformation::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                                   IConnectionPointContainer,
                                   &pcpc
                                   ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                         clsidTaskMajorIn,
                                         clsidTaskMinorIn,
                                         ulMinIn,
                                         ulMaxIn,
                                         ulCurrentIn,
                                         hrStatusIn,
                                         pcszDescriptionIn,
                                         pftTimeIn,
                                         pcszReferenceIn
                                         ) );

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} // SendStatusReport()


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCompareAndPushInformation::HrVerifyCredentials(
//      IClusCfgServer * pccsIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCompareAndPushInformation::HrVerifyCredentials(
    IClusCfgServer *    pccsIn,
    OBJECTCOOKIE        cookieClusterIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    BSTR    bstrNotification = NULL;
    BSTR    bstrAccountName = NULL;
    BSTR    bstrAccountPassword = NULL;
    BSTR    bstrAccountDomain = NULL;

    IUnknown *              punk  = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgCredentials *   piccc = NULL;
    IClusCfgNetworkInfo *   pccni = NULL;
    IClusCfgVerify *        pccv = NULL;

    //
    //  Ask the object manager for the cluster configuration object.
    //

    hr = THR( m_pom->GetObject( DFGUID_ClusterConfigurationInfo,
                                cookieClusterIn,
                                &punk
                                ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( piccc->GetCredentials( &bstrAccountName, &bstrAccountDomain, &bstrAccountPassword ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccsIn->TypeSafeQI( IClusCfgVerify, &pccv ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccv->VerifyCredentials( bstrAccountName, bstrAccountDomain, bstrAccountPassword ) );
    if ( FAILED( hr ) )
        goto Error;

Cleanup:
    TraceSysFreeString( bstrNotification );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccv != NULL )
    {
        pccv->Release();
    }

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer about the failure.
    //

    THR( HrLoadStringIntoBSTR( g_hInstance,
                               IDS_TASKID_MINOR_BAD_CREDENTIALS,
                               &bstrNotification
                               ) );

    THR( SendStatusReport( m_bstrNodeName,
                           TASKID_Major_Reanalyze,
                           TASKID_Minor_Bad_Credentials,
                           0,
                           0,
                           0,
                           hr,
                           bstrNotification,
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} // HrVerifyCredentials()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskcommitclusterchanges.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskCommitClusterChanges.h
//
//  Description:
//      CTaskCommitClusterChanges implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskCommitClusterChanges
class
CTaskCommitClusterChanges
    : public ITaskCommitClusterChanges
    , public INotifyUI
    , public IClusCfgCallback
{
private:
    // IUnknown
    LONG                    m_cRef;

    // ITaskCommitClusterChanges
    BOOL                    m_fJoining;                 // If we are attempting to join...
    OBJECTCOOKIE            m_cookie;                   // Task completion cookie
    IClusCfgCallback *      m_pcccb;                    // Marshalled callback interface
    OBJECTCOOKIE *          m_pcookies;                 // Completion cookies for the subtasks.
    ULONG                   m_cNodes;                   // Count of nodes/subtasks that need to signal completion.
    HANDLE                  m_event;                    // Synchronization event to signal when subtasks have completed.
    OBJECTCOOKIE            m_cookieCluster;            // Cookie of the cluster to commit changes

    OBJECTCOOKIE            m_cookieFormingNode;        // Cookie of the forming node.
    IUnknown *              m_punkFormingNode;          // The node to form the cluster.
    BSTR                    m_bstrClusterName;          // The cluster to form
    BSTR                    m_bstrClusterBindingString; // The cluster to form
    BSTR                    m_bstrAccountName;          // The name of credentials used to run the cluster.
    BSTR                    m_bstrAccountPassword;      // The password of credentials used to run the cluster.
    BSTR                    m_bstrAccountDomain;        // The domain of credentials used to run the cluster.
    ULONG                   m_ulIPAddress;              // IP address of the new cluster.
    ULONG                   m_ulSubnetMask;             // IP subnet mask of the new cluster.
    BSTR                    m_bstrNetworkUID;           // UID of the network the IP should be advertized.

    IEnumNodes *            m_pen;                      // Nodes to form/join

    INotifyUI *             m_pnui;
    IObjectManager *        m_pom;
    ITaskManager *          m_ptm;
    IConnectionManager *    m_pcm;

    // INotifyUI
    ULONG                   m_cSubTasksDone;        // The number of subtasks done.
    HRESULT                 m_hrStatus;             // Status of callbacks


    CTaskCommitClusterChanges( void );
    ~CTaskCommitClusterChanges( void );
    STDMETHOD( Init )( void );

    HRESULT
        HrCompareAndPushInformationToNodes( void );
    HRESULT
        HrGatherClusterInformation( void );
    HRESULT
        HrFormFirstNode( void );
    HRESULT
        HrAddJoiningNodes( void );
    HRESULT
        HrAddAJoiningNode( BSTR bstrNameIn, OBJECTCOOKIE cookieIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskCommitClusterChanges
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetClusterCookie )( OBJECTCOOKIE cookieClusterIn );
    STDMETHOD( SetJoining )( void );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    // INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn );

}; // class CTaskCommitClusterChanges
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskcommitclusterchanges.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskCommitClusterChanges.cpp
//
//  Description:
//      CTaskCommitClusterChanges implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskCommitClusterChanges.h"

DEFINE_THISCLASS("CTaskCommitClusterChanges")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CTaskCommitClusterChanges * ptccc = new CTaskCommitClusterChanges;
    if ( ptccc != NULL )
    {
        hr = THR( ptccc->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( ptccc->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        ptccc->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskCommitClusterChanges::CTaskCommitClusterChanges( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskCommitClusterChanges::CTaskCommitClusterChanges( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CTaskCommitClusterChanges()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    // IDoTask / ITaskCommitClusterChanges
    Assert( m_cookie == 0 );
    Assert( m_pcccb == NULL );
    Assert( m_pcookies == NULL );
    Assert( m_cNodes == 0 );
    Assert( m_event == NULL );
    Assert( m_cookieCluster == NULL );

    Assert( m_cookieFormingNode == NULL );
    Assert( m_punkFormingNode == NULL );
    Assert( m_bstrClusterName == NULL );
    Assert( m_bstrClusterBindingString == NULL );
    Assert( m_bstrAccountName == NULL );
    Assert( m_bstrAccountPassword == NULL );
    Assert( m_bstrAccountDomain == NULL );
    Assert( m_ulIPAddress == 0 );
    Assert( m_ulSubnetMask == 0 );
    Assert( m_bstrNetworkUID == 0 );

    Assert( m_pen == NULL );

    Assert( m_pnui == NULL );
    Assert( m_pom == NULL );
    Assert( m_ptm == NULL );
    Assert( m_pcm == NULL );

    // INotifyUI
    Assert( m_cNodes == 0 );
    Assert( m_hrStatus == S_OK );

    HRETURN( hr );

} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskCommitClusterChanges::~CTaskCommitClusterChanges()
//
//////////////////////////////////////////////////////////////////////////////
CTaskCommitClusterChanges::~CTaskCommitClusterChanges()
{
    TraceFunc( "" );

    // m_cRef

    // m_cookie

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pcookies != NULL )
    {
        TraceFree( m_pcookies );
    }

    // m_cNodes

    if ( m_event != NULL )
    {
        CloseHandle( m_event );
    }

    // m_cookieCluster

    // m_cookieFormingNode

    if ( m_punkFormingNode != NULL )
    {
        m_punkFormingNode->Release();
    }

    TraceSysFreeString( m_bstrClusterName );
    TraceSysFreeString( m_bstrAccountName );
    TraceSysFreeString( m_bstrClusterBindingString );

    if ( m_bstrAccountPassword != NULL )
    {
        DWORD dwLen = SysStringLen( m_bstrAccountPassword );
        // need to trash the password.
        memset( m_bstrAccountPassword, 0, dwLen * sizeof( WCHAR ) );
        TraceSysFreeString( m_bstrAccountPassword );
    }

    TraceSysFreeString( m_bstrAccountDomain );

    // m_ulIPAddress

    // m_ulSubnetMask

    TraceSysFreeString( m_bstrNetworkUID );
    if ( m_pen != NULL )
    {
        m_pen->Release();
    }

    if ( m_pnui != NULL )
    {
        m_pnui->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    if ( m_ptm != NULL )
    {
        m_ptm->Release();
    }

    if ( m_pcm != NULL )
    {
        m_pcm->Release();
    }

    // m_cSubTasksDone

    // m_hrStatus

    // m_lLockCallback

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CTaskCommitClusterChanges()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< ITaskCommitClusterChanges * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_ITaskCommitClusterChanges ) )
    {
        *ppv = TraceInterface( __THISCLASS__, ITaskCommitClusterChanges, this, 0 );
        hr   = S_OK;
    } // else if: ITaskCommitClusterChanges
    else if ( IsEqualIID( riid, IID_IDoTask ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr   = S_OK;
    } // else if: IDoTask
    else if ( IsEqualIID( riid, IID_INotifyUI ) )
    {
        *ppv = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
        hr   = S_OK;
    } // else if: INotifyUI
    else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskCommitClusterChanges::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskCommitClusterChanges::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskCommitClusterChanges::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskCommitClusterChanges::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release()


// ************************************************************************
//
// IDoTask / ITaskCommitClusterChanges
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::BeginTask( void );
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    IServiceProvider *          psp  = NULL;
    IUnknown *                  punk = NULL;
    IConnectionPointContainer * pcpc = NULL;
    IConnectionPoint *          pcp  = NULL;

    TraceInitializeThread( L"TaskCommitClusterChanges" );

    //
    //  Gather the managers we need to complete the task.
    //
    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               &pcpc
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pcpc = TraceInterface( L"CTaskCommitClusterChanges!IConnectionPointContainer", IConnectionPointContainer, pcpc, 1 );

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pcp = TraceInterface( L"CTaskCommitClusterChanges!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &m_pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

//    TraceMoveFromMemoryList( m_pnui, g_GlobalMemoryList );

    m_pnui = TraceInterface( L"CTaskCommitClusterChanges!INotifyUI", INotifyUI, m_pnui, 1 );

    hr = THR( psp->TypeSafeQS( CLSID_TaskManager,
                               ITaskManager,
                               &m_ptm
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &m_pom
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager, IConnectionManager, &m_pcm ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Release the service manager.
    //
    psp->Release();
    psp = NULL;

    //
    //  Get the enum of the nodes.
    //

    hr = THR( m_pom->FindObject( CLSID_NodeType,
                                 m_cookieCluster,
                                 NULL,
                                 DFGUID_EnumNodes,
                                 &cookieDummy,
                                 &punk
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IEnumNodes, &m_pen ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Compare and push information to the nodes.
    //

    hr = THR( HrCompareAndPushInformationToNodes() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Gather information about the cluster we are to form/join.
    //

    hr = THR( HrGatherClusterInformation() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Check to see if we need to "form" a cluster first.
    //

    if ( m_punkFormingNode != NULL )
    {
        hr = THR( HrFormFirstNode() );
        if ( FAILED( hr ) )
            goto Cleanup;

    } // if: m_punkFormingNode

    //
    //  Join the additional nodes.
    //

    hr = THR( HrAddJoiningNodes() );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( m_cookie != 0 )
    {
        if ( m_pom != NULL )
        {
            HRESULT hr2;
            IUnknown * punk;

            hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                         m_cookie,
                                         &punk
                                         ) );
            if ( SUCCEEDED( hr2 ) )
            {
                IStandardInfo * psi;

                hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
                punk->Release();

                if ( SUCCEEDED( hr2 ) )
                {
                    hr2 = THR( psi->SetStatus( hr ) );
                    psi->Release();
                }
            }
        }
        if ( m_pnui != NULL )
        {
            //  Signal that the task completed.
            THR( m_pnui->ObjectChanged( m_cookie ) );
        }
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} // BeginTask()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CTaskCommitClusterChanges::StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::SetCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskCommitClusterChanges]" );

    HRESULT hr = S_OK;

    m_cookie = cookieIn;

    HRETURN( hr );

} // SetCookie()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::SetClusterCookie(
//      OBJECTCOOKIE    cookieClusterIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::SetClusterCookie(
    OBJECTCOOKIE    cookieClusterIn
    )
{
    TraceFunc( "[ITaskCommitClusterChanges]" );

    HRESULT hr = S_OK;

    m_cookieCluster = cookieClusterIn;

    HRETURN( hr );

} // SetClusterCookie()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::SetJoining( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::SetJoining( void )
{
    TraceFunc( "[ITaskCommitClusterChanges]" );

    HRESULT hr = S_OK;

    m_fJoining = TRUE;

    HRETURN( hr );

} // SetJoining()


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                                   IConnectionPointContainer,
                                   &pcpc
                                   ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                         clsidTaskMajorIn,
                                         clsidTaskMinorIn,
                                         ulMinIn,
                                         ulMaxIn,
                                         ulCurrentIn,
                                         hrStatusIn,
                                         pcszDescriptionIn,
                                         pftTimeIn,
                                         pcszReferenceIn
                                         ) );

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} // SendStatusReport()


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskCommitClusterChanges::ObjectChanged(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCommitClusterChanges::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    BOOL    b;
    ULONG   cNodes;

    HRESULT hr = S_OK;

    for ( cNodes = 0; cNodes < m_cNodes; cNodes ++ )
    {
        if ( cookieIn == m_pcookies[ cNodes ] )
        {
            //
            //  Make sure it won't be signalled twice.
            //
            m_pcookies[ cNodes ] = NULL;

            InterlockedIncrement( reinterpret_cast< long * >( &m_cSubTasksDone ) );

            if ( m_cSubTasksDone == m_cNodes )
            {
                //
                //  Signal the event if all the nodes are done.
                //
                b = SetEvent( m_event );
                if ( !b )
                    goto Win32Error;

            } // if: all done

        } // if: matched cookie

    } // for: cNodes

Cleanup:
    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
    goto Cleanup;

} // ObjectChanged()


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrCompareAndPushInformationToNodes( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrCompareAndPushInformationToNodes( void )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   dwCookie;
    DWORD   dwErr;
    ULONG   cNodes;
    ULONG   celtDummy;

    OBJECTCOOKIE    cookie;
    OBJECTCOOKIE *  pcookies = NULL;

    BOOL    fDeterminedForming = FALSE;

    BSTR    bstrName           = NULL;
    BSTR    bstrNotification   = NULL;

    IUnknown *          punk  = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    IConnectionPoint *  pcp   = NULL;
    IStandardInfo *     psi   = NULL;

    ITaskCompareAndPushInformation *    ptcapi = NULL;

    //
    //  Tell the UI layer that we are starting to connect to the nodes.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Reanalyze,
                                TASKID_Minor_Update_Progress,   // just twiddle the icon
                                0,
                                1,
                                0,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Count the number of nodes.
    //

    m_cNodes = 0;
    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( m_pen->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
            break;  // end of list

        if ( FAILED( hr ) )
            goto Error;

        pccni->Release();
        pccni = NULL;

        m_cNodes ++;

    } // while: hr == S_OK

    //
    //  Reset the enum to use again.
    //

    hr = THR( m_pen->Reset() );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Create an event to signal when all the "push" tasks have been
    //  completed.
    //
    m_event = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_event == NULL )
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
        goto Error;
    }

    //
    //  Register with the Notification Manager to get notified.
    //

    hr = THR( m_pnui->TypeSafeQI( IConnectionPoint,
                                  &pcp
                                  ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pcp->Advise( static_cast< INotifyUI * >( this ), &dwCookie ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Allocate a buffer to collect cookies
    //

    m_pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( 0, m_cNodes * sizeof( OBJECTCOOKIE ) ) );
    if ( m_pcookies == NULL )
        goto OutOfMemory;

    //
    //  This copy is to find out the status of the subtasks.
    //

    pcookies = reinterpret_cast< OBJECTCOOKIE * >( TraceAlloc( 0, m_cNodes * sizeof( OBJECTCOOKIE ) ) );
    if ( pcookies == NULL )
        goto OutOfMemory;

    //
    //  Loop thru the nodes, creating cookies and compare data for that node.
    //
    Assert( hr == S_OK );
    for( cNodes = 0; hr == S_OK; cNodes ++ )
    {
        //
        //  Grab the next node.
        //

        hr = STHR( m_pen->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
            break;

        if ( FAILED( hr ) )
            goto Error;

        //
        //  Get the nodes name. We are using this to distinguish one nodes
        //  completion cookie from another. It might also make debugging
        //  easier (??).
        //
        hr = THR( pccni->GetName( &bstrName ) );
        if ( FAILED( hr ) )
            goto Error;

        TraceMemoryAddBSTR( bstrName );

        //
        //  Update the notification in case something goes wrong.
        //

        hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                           IDS_TASKID_MINOR_CONNECTING_TO_NODES,
                                           &bstrNotification,
                                           bstrName
                                           ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Create a completion cookie.
        //
        //  KB: These will probably be the same cookie from TaskAnalyzeCluster.
        //

        //  Wrap this because we're just generating a cookie
        hr = THR( m_pom->FindObject( IID_NULL,
                                     m_cookieCluster,
                                     bstrName,
                                     IID_NULL,
                                     &m_pcookies[ cNodes ],
                                     &punk  // dummy
                                     ) );
        Assert( punk == NULL );
        if ( FAILED( hr ) )
            goto Error;

        //
        //  This copy is for determining the status of the sub-tasks.
        //
        pcookies[ cNodes ] = m_pcookies[ cNodes ];

        //
        //  Figure out if this node is already part of a cluster.
        //

        hr = STHR( pccni->IsMemberOfCluster() );
        if ( FAILED( hr ) )
            goto Error;

        //
        //  Figure out the forming node.
        //

        if ( m_punkFormingNode == NULL    // no forming node selected
          && !fDeterminedForming          // no forming node determined
          && hr == S_FALSE                // node isn't a member of a cluster
           )
        {
            //
            //  If it isn't a member of a cluster, select it as the forming node.
            //

            Assert( m_punkFormingNode == NULL );
            hr = THR( pccni->TypeSafeQI( IUnknown, &m_punkFormingNode ) );
            if ( FAILED( hr ) )
                goto Error;

            //
            //  Retrieve the cookie for the forming node.
            //

            //  Wrap this because all Nodes should be in the database by now.
            hr = THR( m_pom->FindObject( CLSID_NodeType,
                                         m_cookieCluster,
                                         bstrName,
                                         IID_NULL,
                                         &m_cookieFormingNode,
                                         &punk  // dummy
                                         ) );
            Assert( punk == NULL );
            if ( FAILED( hr ) )
                goto Error;

            //
            //  Set this flag to once a node has been determined to be the
            //  forming node to keep other nodes from being selected.
            //

            fDeterminedForming = TRUE;

        } // if:
        else if ( hr == S_OK ) // node is a member of a cluster
        {
            //
            //  Figured out that this node has already formed therefore there
            //  shouldn't be a "forming node." "Unselect" the forming node by
            //  releasing the punk and setting it to NULL.
            //

            if ( m_punkFormingNode != NULL  )
            {
                m_punkFormingNode->Release();
                m_punkFormingNode = NULL;
            }

            //
            //  Set this flag to once a node has been determined to be the
            //  forming node to keep other nodes from being selected.
            //

            fDeterminedForming = TRUE;

        } // else:

        //
        //  Create a task to gather this nodes information.
        //

        hr = THR( m_ptm->CreateTask( TASK_CompareAndPushInformation,
                                     &punk
                                     ) );
        if ( FAILED( hr ) )
            goto Error;

        hr = THR( punk->TypeSafeQI( ITaskCompareAndPushInformation, & ptcapi ) );
        punk->Release();
        punk = NULL;
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Set the tasks completion cookie.
        //

        hr = THR( ptcapi->SetCompletionCookie( m_pcookies[ cNodes ] ) );
        if ( FAILED( hr ) )
            goto Error;

        //
        //  Tell it what node it is suppose to gather information from.
        //

        //  Find the cookie first!
        hr = THR( m_pom->FindObject( CLSID_NodeType,
                                     m_cookieCluster,
                                     bstrName,
                                     IID_NULL,
                                     &cookie,
                                     &punk // dummy
                                     ) );
        Assert( punk == NULL );
        if ( FAILED( hr ) )
            goto Error;

        hr = THR( ptcapi->SetNodeCookie( cookie ) );
        if ( FAILED( hr ) )
            goto Error;

        //
        //  Submit the task.
        //

        hr = THR( m_ptm->SubmitTask( ptcapi ) );
        if ( FAILED( hr ) )
            goto Error;

        //
        //  Cleanup for the next node.
        //

        pccni->Release();
        pccni = NULL;

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        ptcapi->Release();
        ptcapi = NULL;

    } // while: looping thru nodes

    Assert( cNodes == m_cNodes );

    //
    //  Now wait for the work to be done.
    //

    dwErr = -1;
    Assert( dwErr != WAIT_OBJECT_0 );
    while ( dwErr != WAIT_OBJECT_0 )
    {
        MSG msg;
        while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }

        dwErr = MsgWaitForMultipleObjectsEx( 1,
                                             &m_event,
                                             INFINITE,
                                             QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE,
                                             0
                                             );

    } // while: dwErr == WAIT_OBJECT_0

    //
    //  Check the status to make sure everyone was happy, if not abort the task.
    //

    for( cNodes = 0; cNodes < m_cNodes; cNodes ++ )
    {
        HRESULT hrStatus;

        hr = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                    pcookies[ cNodes ],
                                    &punk
                                    ) );
        if ( FAILED( hr ) )
            goto Error;

        hr = THR( punk->TypeSafeQI( IStandardInfo,
                                    &psi
                                    ) );
        punk->Release();
        punk = NULL;
        if ( FAILED( hr ) )
            goto Error;

        hr = THR( psi->GetStatus( &hrStatus ) );
        if ( FAILED( hr ) )
            goto Error;

        if ( hrStatus != S_OK )
        {
            hr = hrStatus;
            goto Cleanup;
        }
    }

    hr = S_OK;

Cleanup:
    Assert( punk == NULL );
    if ( pcookies != NULL )
    {
        for ( cNodes = 0; cNodes < m_cNodes; cNodes++ )
        {
            if ( pcookies[ cNodes ] != NULL )
            {
                THR( m_pom->RemoveObject( pcookies[ cNodes ] ) );
            }
        }
        TraceFree( pcookies );
    }

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );

    if ( ptcapi != NULL )
    {
        ptcapi->Release();
    }
    if ( pcp != NULL )
    {
        if ( dwCookie != 0 )
        {
            THR( pcp->Unadvise( dwCookie ) );
        }

        pcp->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer about the failure.
    //

    THR( SendStatusReport( NULL,
                           TASKID_Major_Reanalyze,
                           TASKID_Minor_Update_Progress,    // todo: fill this in
                           0,
                           0,
                           0,
                           hr,
                           bstrNotification,
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

} // HrCompareAndPushInformationToNodes()


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrGatherClusterInformation( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrGatherClusterInformation( void )
{
    TraceFunc( "" );

    HRESULT hr;

    BSTR    bstrNotification = NULL;

    IUnknown *              punk  = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgCredentials *   piccc = NULL;
    IClusCfgNetworkInfo *   pccni = NULL;

    //
    //  Ask the object manager for the cluster configuration object.
    //

    hr = THR( m_pom->GetObject( DFGUID_ClusterConfigurationInfo, m_cookieCluster, &punk ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Gather common properties.
    //

    hr = THR( pccci->GetName( &m_bstrClusterName ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrClusterName );

    hr = STHR( pccci->GetBindingString( &m_bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    } // if:

    TraceMemoryAddBSTR( m_bstrClusterBindingString );

    LogMsg( L"[MT] Cluster binding string is {%ws}.", m_bstrClusterBindingString );

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( piccc->GetCredentials( &m_bstrAccountName, &m_bstrAccountDomain, &m_bstrAccountPassword ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->GetIPAddress( &m_ulIPAddress ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->GetSubnetMask( &m_ulSubnetMask ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->GetNetworkInfo( &pccni ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccni->GetUID( &m_bstrNetworkUID ) );
    if ( FAILED( hr ) )
        goto Error;

    TraceMemoryAddBSTR( m_bstrNetworkUID );

Cleanup:
    TraceSysFreeString( bstrNotification );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer about the failure.
    //

    THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_INCONSISTANT_MIDDLETIER_DATABASE, &bstrNotification ) );

    THR( SendStatusReport( NULL,
                           TASKID_Major_Reanalyze,
                           TASKID_Minor_Inconsistant_MiddleTier_Database,
                           0,
                           0,
                           0,
                           hr,
                           bstrNotification,
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} // HrGatherClusterInformation()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrFormFirstNode( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrFormFirstNode( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   celtDummy;

    BSTR    bstrName         = NULL;
    BSTR    bstrNotification = NULL;
    BSTR    bstrUID          = NULL;

    IUnknown *                  punk  = NULL;
    IClusCfgCredentials *       piccc = NULL;
    IClusCfgNodeInfo *          pccni = NULL;
    IClusCfgClusterInfo *       pccci = NULL;
    IClusCfgServer *            pccs  = NULL;
    IEnumClusCfgNetworks *      peccn = NULL;
    IClusCfgNetworkInfo *       pccneti = NULL;

    //
    //  TODO:   gpease  25-MAR-2000
    //          Figure out what additional work to do here.
    //

    //
    //  Get the name of the node.
    //

    hr = THR( m_pom->GetObject( DFGUID_NodeInformation,
                                m_cookieFormingNode,
                                &punk
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release();
    punk = NULL;

    hr = THR( pccni->GetName( &bstrName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    TraceMemoryAddBSTR( bstrName );

    //
    //  Create notification string.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_TASKID_MINOR_FORMING_NODE,
                                    &bstrNotification
                                    ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Update the UI layer telling it that we are about to start.
    //

    hr = THR( SendStatusReport( bstrName,
                                TASKID_Major_Configure_Cluster_Services,
                                TASKID_Minor_Forming_Node,
                                0,
                                2,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Connection Manager for a connection to the node.
    //

    hr = THR( m_pcm->GetConnectionToObject( m_cookieFormingNode, &punk ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
        goto Error;

    punk->Release();
    punk = NULL;

    //
    //  Get the node info interface.
    //

    hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Retrieve the server's Cluster Configuration Object..
    //

    hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Put the properties into the remoted object.
    //

    hr = THR( pccci->SetName( m_bstrClusterName ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = STHR( pccci->SetBindingString( m_bstrClusterBindingString ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( piccc->SetCredentials( m_bstrAccountName, m_bstrAccountDomain, m_bstrAccountPassword ) );
    if( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->SetIPAddress( m_ulIPAddress ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->SetSubnetMask( m_ulSubnetMask ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Find the network that matches the UID of network to host the
    //  IP address.
    //

    hr = THR( pccs->GetNetworksEnum( &peccn ) );
    if ( FAILED( hr ) )
        goto Error;

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( peccn->Next( 1, &pccneti, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            //
            //  Somehow, there isn't a network that matches the UID of the
            //  network. How did we get this far?
            //
            hr = THR( E_UNEXPECTED );
            goto Error;
        }
        if ( FAILED( hr ) )
            goto Error;

        hr = THR( pccneti->GetUID( &bstrUID ) );
        if ( FAILED( hr ) )
            goto Error;

        TraceMemoryAddBSTR( bstrUID );

        if ( wcscmp( bstrUID, m_bstrNetworkUID ) == 0 )
        {
            //
            //  Found the network!
            //
            break;
        }

        TraceSysFreeString( bstrUID );
        bstrUID = NULL;

        pccneti->Release();
        pccneti = NULL;

    } // while: hr == S_OK

    hr = THR( pccci->SetNetworkInfo( pccneti ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Configure that node to create a cluster
    //

    hr = THR( pccci->SetCommitMode( cmCREATE_CLUSTER ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Update the UI layer telling it that we are making progress.
    //

    hr = THR( SendStatusReport( bstrName,
                                TASKID_Major_Configure_Cluster_Services,
                                TASKID_Minor_Forming_Node,
                                0,
                                2,
                                1,
                                hr,
                                NULL,    // don't need to update string
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Commit this node!
    //

    hr = THR( pccs->CommitChanges() );
    if ( FAILED( hr ) )
        goto Error;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );

    if ( pccneti != NULL )
    {
        pccneti->Release();
    }
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer about the failure.
    //

    THR( SendStatusReport( bstrName,
                           TASKID_Major_Configure_Cluster_Services,
                           TASKID_Minor_Forming_Node,
                           0,
                           2,
                           2,
                           hr,
                           NULL,    // don't need to update string
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} // HrFormFirstNode()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrAddJoiningNodes( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrAddJoiningNodes( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   cNodes;
    ULONG   celtDummy;

    OBJECTCOOKIE    cookie;

    BSTR    bstrName = NULL;

    IClusCfgNodeInfo * pccni = NULL;

    //
    //  Reset the enum to use again.
    //

    hr = THR( m_pen->Reset() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Loop thru the nodes, adding all joining nodes, skipping the forming node (if any).
    //

    Assert( hr == S_OK );
    for( cNodes = 0; hr == S_OK; cNodes ++ )
    {
        IUnknown *  punk;

        //
        //  Cleanup
        //

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        //
        //  Grab the next node.
        //

        hr = STHR( m_pen->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
            break;

        if ( FAILED( hr ) )
            goto Error;

        //
        //  Check to see if this is the forming node.
        //

        hr = THR( pccni->TypeSafeQI( IUnknown, &punk ) );
        if ( FAILED( hr ) )
            goto Error;

        punk->Release();       // release promptly.

        //
        //  Get the name.
        //

        Assert( bstrName == NULL );
        hr = THR( pccni->GetName( &bstrName ) );
        if ( FAILED( hr ) )
            goto Error;

        TraceMemoryAddBSTR( bstrName );

        //
        //  Check cluster membership.
        //

        hr = STHR( pccni->IsMemberOfCluster() );
        if ( FAILED( hr ) )
            goto Error;

        pccni->Release();
        pccni = NULL;

        if ( hr == S_OK )
            continue;   // already clustered - skip it.

        //
        //  KB: We only need the punk's address to see if the objects are the
        //      same COM object by comparing the IUnknown interfaces.
        //
        if ( m_punkFormingNode == punk )
            continue;   // skip it - we already "formed" above

        //
        //  Find the node's cookie.
        //

        //  This should be already cache! E_PENDING is not a good answer!
        hr = THR( m_pom->FindObject( CLSID_NodeType,
                                     m_cookieCluster,
                                     bstrName,
                                     IID_NULL,
                                     &cookie,
                                     &punk // dummy
                                     ) );
        Assert( punk == NULL );
        if ( FAILED( hr ) )
            goto Error;

        //
        //  Add the node to the cluster.
        //

        hr = THR( HrAddAJoiningNode( bstrName, cookie ) );
        if ( FAILED( hr ) )
            goto Cleanup;

    } // while: looping thru nodes a second time.

    Assert( cNodes == m_cNodes );

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrName );

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    HRETURN( hr );

Error:
    THR( SendStatusReport( bstrName,
                           TASKID_Major_Configure_Cluster_Services,
                           TASKID_Minor_Joining_Node,
                           0,
                           2,
                           2,
                           hr,
                           NULL,
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} // HrAddJoiningNodes()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskCommitClusterChanges::HrAddAJoiningNode(
//      BSTR            bstrNameIn,
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCommitClusterChanges::HrAddAJoiningNode(
    BSTR            bstrNameIn,
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   cNodes;

    OBJECTCOOKIE    cookie;

    BSTR    bstrNotification = NULL;

    IUnknown *                  punk  = NULL;
    IClusCfgCredentials *       piccc = NULL;
    IClusCfgNodeInfo *          pccni = NULL;
    IClusCfgClusterInfo *       pccci = NULL;
    IClusCfgServer *            pccs  = NULL;

    //
    //  Create the notification string
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_TASKID_MINOR_JOINING_NODE,
                                    &bstrNotification
                                    ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Tell UI layer we are about to start this.
    //

    hr = THR( SendStatusReport( bstrNameIn,
                                TASKID_Major_Configure_Cluster_Services,
                                TASKID_Minor_Joining_Node,
                                0,
                                2,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Connect to the node.
    //

    hr = THR( m_pcm->GetConnectionToObject( cookieIn,
                                            &punk
                                            ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Get the node info interface.
    //

    hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Retrieve the server's Cluster Configuration Object..
    //

    hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Put the properties into the remoted object.
    //

    hr = THR( pccci->SetName( m_bstrClusterName ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->SetBindingString( m_bstrClusterBindingString ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( piccc->SetCredentials( m_bstrAccountName, m_bstrAccountDomain, m_bstrAccountPassword ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->SetIPAddress( m_ulIPAddress ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( pccci->SetSubnetMask( m_ulSubnetMask ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Set this node to add itself to a cluster
    //

    hr = THR( pccci->SetCommitMode( cmADD_NODE_TO_CLUSTER ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Tell the UI layer we are making progess.... the server will then send messages
    //  indicating what it is doing.
    //

    hr = THR( SendStatusReport( bstrNameIn,
                                TASKID_Major_Configure_Cluster_Services,
                                TASKID_Minor_Joining_Node,
                                0,
                                2,
                                1,
                                S_OK,
                                NULL,    // don't need to update string
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Commit this node!
    //

    hr = THR( pccs->CommitChanges() );
    if ( FAILED( hr ) )
        goto Error;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    TraceSysFreeString( bstrNotification );

    if ( piccc != NULL )
    {
        piccc->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }

    HRETURN( hr );

Error:
    THR( SendStatusReport( bstrNameIn,
                           TASKID_Major_Configure_Cluster_Services,
                           TASKID_Minor_Joining_Node,
                           0,
                           2,
                           1,
                           hr,
                           NULL,    // don't need to update string
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} // HrAddAJoiningNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskgatherinformation.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherInformation.cpp
//
//  Description:
//      CTaskGatherInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskGatherInformation.h"
#include "ManagedDevice.h"
#include "ManagedNetwork.h"

DEFINE_THISCLASS("CTaskGatherInformation")

#define MINIMUM_STORAGE_SIZE    5

//
//  Failure code.
//

#define SSR_TGI_FAILED( _major, _minor, _hr ) \
    {   \
        HRESULT hrTemp; \
        BSTR    bstrNotification = NULL;    \
        hrTemp = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_ERR_TGI_FAILED_TRY_TO_REANALYZE, &bstrNotification ) ); \
        hrTemp = THR( SendStatusReport( m_bstrNodeName, _major, _minor, 0, 1, 1, _hr, bstrNotification ) );   \
        if ( bstrNotification != NULL ) \
        {   \
            TraceSysFreeString( bstrNotification ); \
        }   \
        if ( FAILED( hrTemp ) )\
        {   \
            _hr = hrTemp;   \
        }   \
    }


//////////////////////////////////////////////////////////////////////////////
//
//  Static function prototypes
//
//////////////////////////////////////////////////////////////////////////////

static HRESULT HrTotalManagedResourceCount( IEnumClusCfgManagedResources * pResourceEnumIn, IEnumClusCfgNetworks * pNetworkEnumIn, DWORD * pnCountOut );


//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherInformation::S_HrCreateInstance(
//      IUnknown ** punkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherInformation::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CTaskGatherInformation * ptgi = new CTaskGatherInformation;
    if ( ptgi != NULL )
    {
        hr = THR( ptgi->HrInit() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( ptgi->TypeSafeQI( IUnknown, ppunkOut ) );
            TraceMoveToMemoryList( *ppunkOut, g_GlobalMemoryList );
        }

        ptgi->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} //*** CTaskGatherInformation::S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherInformation::CTaskGatherInformation( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherInformation::CTaskGatherInformation( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherInformation::CTaskGatherInformation()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::HrInit( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 1 );

    // IDoTask / ITaskGatherInformation
    Assert( m_cookieCompletion == NULL );
    Assert( m_cookieNode == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_fJoining == FALSE );
    Assert( m_cResources == 0 );

    Assert( m_pom == NULL );
    Assert( m_pccs == NULL );
    Assert( m_bstrNodeName == NULL );

    Assert( m_ulQuorumDiskSize == 0 );
    Assert( m_pccmriQuorum == NULL );

    HRETURN( hr );

} //*** CTaskGatherInformation::HrInit()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherInformation::~CTaskGatherInformation()
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherInformation::~CTaskGatherInformation( void )
{
    TraceFunc( "" );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    if ( m_pccs != NULL )
    {
        m_pccs->Release();
    }

    if ( m_bstrNodeName != NULL )
    {
        TraceSysFreeString( m_bstrNodeName );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherInformation::~CTaskGatherInformation()


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGatherInformation * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskGatherInformation ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGatherInformation, this, 0 );
        hr = S_OK;
    } // else if: ITaskGatherInformation

    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr = S_OK;
    } // else if: IDoTask

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskGatherInformation::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CTaskGatherInformation::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGatherInformation::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CTaskGatherInformation::AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CTaskGatherInformation::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskGatherInformation::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CTaskGatherInformation::Release()


//****************************************************************************
//
//  ITaskGatherInformation
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::BeginTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;
    LPWSTR  psz;

    BSTR    bstrNotification = NULL;

    IServiceProvider *          psp   = NULL;
    IUnknown *                  punk  = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    INotifyUI *                 pnui  = NULL;
    IConnectionManager *        pcm   = NULL;
    IStandardInfo *             psi   = NULL;
    IClusCfgCapabilities *      pccc  = NULL;
    
    IEnumClusCfgManagedResources *  peccmr  = NULL;
    IEnumClusCfgNetworks *          pen     = NULL;

    DWORD   cTotalResources = 0;

    TraceInitializeThread( L"TaskGatherInformation" );

    //
    //  Make sure we weren't "reused"
    //

    Assert( m_cResources == 0 );

    //
    //  Gather the manager we need to complete our tasks.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_CoCreate_ServiceManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &m_pom
                               ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QS_ObjectManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               &pcpc
                               ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QS_NotificationManager, hr );
        goto Cleanup;
    }

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_FindConnectionPoint, hr );
        goto Cleanup;
    }

    pcp = TraceInterface( L"CTaskGatherInformation!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QI_pnui, hr );
        goto Cleanup;
    }

    pnui = TraceInterface( L"CTaskGatherInformation!INotifyUI", INotifyUI, pnui, 1 );

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager,
                               IConnectionManager,
                               &pcm
                               ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QS_ClusterConnectionManager, hr );
        goto Cleanup;
    }

    // release promptly
    psp->Release();
    psp = NULL;

    //
    //  Ask the object manager for the name of the node.
    //

    hr = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                m_cookieNode,
                                &punk
                                ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject_StandardInfo, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject_StandardInfo_QI, hr );
        goto Cleanup;
    }

    psi = TraceInterface( L"TaskGatherInformation!IStandardInfo", IStandardInfo, psi, 1 );

    punk->Release();
    punk = NULL;

    hr = THR( psi->GetName( &m_bstrNodeName ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetName, hr );
        goto Cleanup;
    }

    TraceMemoryAddBSTR( m_bstrNodeName );

    //////////////////////////////////////////////////////////////////////////
    //
    //  Create progress message and tell the UI layer our progress
    //  for checking the node's cluster feasibility.
    //
    //////////////////////////////////////////////////////////////////////////

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_TASKID_MINOR_CHECKING_NODE_CLUSTER_FEASIBILITY,
                                    &bstrNotification
                                    ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_LoadString, hr );
        goto Cleanup;
    }

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Check_Node_Feasibility,
                                TASKID_Minor_Checking_Node_Cluster_Feasibility,
                                0,
                                2,
                                0,
                                S_OK,
                                bstrNotification
                                ) );
    if ( FAILED( hr ) )
        goto ClusterFeasibilityError;

    //
    //  Ask the connection manager for a connection to the node.
    //

    hr = THRE( pcm->GetConnectionToObject( m_cookieNode, &punk ), HR_S_RPC_S_CLUSTER_NODE_DOWN );
    if ( hr != S_OK )
    {
        THR( HrLoadStringIntoBSTR( g_hInstance,
                                   IDS_TASKID_MINOR_FAILED_TO_CONNECT_TO_NODE,
                                   &bstrNotification
                                   ) );

        THR( SendStatusReport( m_bstrNodeName,
                               TASKID_Major_Check_Node_Feasibility,
                               TASKID_Minor_Checking_Node_Cluster_Feasibility,
                               0,
                               2,
                               2,
                               hr,
                               bstrNotification
                               ) );
        //  don't care about error from here - we are returning an error.

        //
        //  If we failed to get a connection to the node, we delete the
        //  node from the configuration.
        //
        THR( m_pom->RemoveObject( m_cookieNode ) );
        // don't care if there is an error because we can't fix it!

        goto ClusterFeasibilityError;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &m_pccs ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetConnectionToObject_QI_m_pccs, hr );
        goto ClusterFeasibilityError;
    }

    punk->Release();
    punk = NULL;

    //
    //  Tell the UI layer we're done connecting to the node.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Check_Node_Feasibility,
                                TASKID_Minor_Checking_Node_Cluster_Feasibility,
                                0, // min
                                2, // max
                                1, // current
                                S_OK,
                                NULL   // don't update string
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Ask the node if it can be clustered.
    //

    hr = THR( m_pccs->TypeSafeQI( IClusCfgCapabilities, &pccc ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_QI_pccc, hr );
        goto ClusterFeasibilityError;
    }

    hr = STHR( pccc->CanNodeBeClustered() );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_CanNodeBeClustered, hr );
        goto ClusterFeasibilityError;
    }

    if ( hr == S_FALSE )
    {
        //
        //  Tell the UI layer that this node doesn't want to be clustered. Note that
        //  we don't put anything in the UI, only to the log. It is the responsibility
        //  of the "blocking" component to tell the UI layer the reasons.
        //

        hr = THR( SendStatusReport( NULL,
                                    TASKID_Major_Client_And_Server_Log,
                                    TASKID_Minor_Can_Node_Be_Clustered_Failed,
                                    0, // min
                                    1, // max
                                    1, // current
                                    ERROR_NODE_CANNOT_BE_CLUSTERED,
                                    m_bstrNodeName
                                    ) );
        // don't care about the error.

        hr = THR( HRESULT_FROM_WIN32( ERROR_NODE_CANNOT_BE_CLUSTERED ) );
        goto ClusterFeasibilityError;
    }

    //
    //  Tell the UI layer we're done checking the node's cluster feasibility.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Check_Node_Feasibility,
                                TASKID_Minor_Checking_Node_Cluster_Feasibility,
                                0, // min
                                2, // max
                                2, // current
                                S_OK,
                                NULL   // don't update string
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    //  Create progress message and tell the UI layer our progress
    //  for gathering managed device info.
    //
    //////////////////////////////////////////////////////////////////////////

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_TASKID_MINOR_GATHERING_MANAGED_DEVICES,
                                    &bstrNotification
                                    ) );
    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_LoadString, hr );
        goto FindDevicesError;
    }

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Find_Devices,
                                TASKID_Minor_Gathering_Managed_Devices,
                                0,
                                2,
                                0,
                                S_OK,
                                bstrNotification
                                ) );
    if ( FAILED( hr ) )
        goto FindDevicesError;

    hr = THR( m_pccs->GetManagedResourcesEnum( &peccmr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pccs->GetNetworksEnum( &pen ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrTotalManagedResourceCount( peccmr, pen, &cTotalResources ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Start gathering the managed resources.
    //

    hr = THR( HrGatherResources( peccmr, cTotalResources ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Tell the UI layer we're done with gathering the resources.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Find_Devices,
                                TASKID_Minor_Gathering_Managed_Devices,
                                0, // min
                                2, // max
                                1, // current
                                S_OK,
                                NULL   // don't update string
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Now gather the networks from the node.
    //

    hr = THR( HrGatherNetworks( pen, cTotalResources ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Tell the UI layer we're done with gathering the networks.
    //

    hr = THR( SendStatusReport( m_bstrNodeName,
                                TASKID_Major_Find_Devices,
                                TASKID_Minor_Gathering_Managed_Devices,
                                0, // min
                                2, // max
                                2, // current
                                S_OK,
                                NULL   // don't update string
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    TraceSysFreeString( bstrNotification );

    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( m_pom != NULL )
    {
        HRESULT hr2;
        IUnknown * punk;

        hr2 = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                     m_cookieCompletion,
                                     &punk
                                     ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
            else
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject_QI_Failed, hr );
            }
        }
        else
        {
            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_BeginTask_GetObject_Failed, hr );
        }
    }
    if ( pnui != NULL )
    {
        THR( pnui->ObjectChanged( m_cookieCompletion ) );
        pnui->Release();
    }
    if ( pcm != NULL )
    {
        pcm->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( pccc != NULL )
    {
        pccc->Release();
    }

    if ( peccmr != NULL )
    {
        peccmr->Release();
    }

    if ( pen != NULL )
    {
        pen->Release();
    }

    HRETURN( hr );

ClusterFeasibilityError:
    THR( SendStatusReport( m_bstrNodeName,
                           TASKID_Major_Check_Node_Feasibility,
                           TASKID_Minor_Checking_Node_Cluster_Feasibility,
                           0,
                           2,
                           2,
                           hr,
                           NULL
                           ) );
    goto Cleanup;

FindDevicesError:
    THR( SendStatusReport( m_bstrNodeName,
                           TASKID_Major_Find_Devices,
                           TASKID_Minor_Gathering_Managed_Devices,
                           0,
                           2,
                           2,
                           hr,
                           NULL
                           ) );
    goto Cleanup;

} //*** CTaskGatherInformation::BeginTask()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CTaskGatherInformation::StopTask


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SetCompletionCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SetCompletionCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskGatherInformation]" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} //*** CTaskGatherInformation::SetCompletionCookie()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SetNodeCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SetNodeCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskGatherInformation]" );

    HRESULT hr = S_OK;

    m_cookieNode = cookieIn;

    HRETURN( hr );

} //*** CTaskGatherInformation::SetNodeCookie()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SetJoining( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SetJoining( void )
{
    TraceFunc( "[ITaskGatherInformation]" );

    HRESULT hr = S_OK;

    m_fJoining = TRUE;

    HRETURN( hr );

} //*** CTaskGatherInformation::SetJoining()


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherInformation::SendStatusReport(
//      BSTR bstrNodeNameIn,
//      CLSID clsidTaskMajorIn,
//      CLSID clsidTaskMinorIn,
//      ULONG ulMinIn,
//      ULONG ulMaxIn,
//      ULONG ulCurrentIn,
//      HRESULT hrStatusIn,
//      BSTR bstrDescriptionIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherInformation::SendStatusReport(
    BSTR bstrNodeNameIn,
    CLSID clsidTaskMajorIn,
    CLSID clsidTaskMinorIn,
    ULONG ulMinIn,
    ULONG ulMaxIn,
    ULONG ulCurrentIn,
    HRESULT hrStatusIn,
    BSTR bstrDescriptionIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                                   IConnectionPointContainer,
                                   &pcpc
                                   ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pcp = TraceInterface( L"CTaskGatherInformation!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pcccb = TraceInterface( L"CTaskGatherInformation!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    GetSystemTimeAsFileTime( &ft );

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport( bstrNodeNameIn,
                                         clsidTaskMajorIn,
                                         clsidTaskMinorIn,
                                         ulMinIn,
                                         ulMaxIn,
                                         ulCurrentIn,
                                         hrStatusIn,
                                         bstrDescriptionIn,
                                         &ft,
                                         NULL
                                         ) );

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} //*** CTaskGatherInformation::SendStatusReport()


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherInformation::HrGatherResources( IEnumClusCfgManagedResources * pResourceEnumIn, DWORD cTotalResourcesIn )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherInformation::HrGatherResources( IEnumClusCfgManagedResources * pResourceEnumIn, DWORD cTotalResourcesIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    ULONG   celt;

    OBJECTCOOKIE    cookieDummy;

    ULONG   celtFetched        = 0;
    BSTR    bstrName           = NULL;
    BSTR    bstrNotification   = NULL;
    BOOL    fFoundQuorumDevice = FALSE;
    BSTR    bstrQuorumDeviceName = NULL;

    IEnumClusCfgPartitions *       peccp  = NULL;
    IClusCfgManagedResourceInfo *  pccmriNew = NULL;
    IClusCfgManagedResourceInfo *  pccmri[ 10 ] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

    if ( pResourceEnumIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Error;
    }
    
    //
    //  Initialize some stuff.
    //

    m_ulQuorumDiskSize = ULONG_MAX;
    Assert( m_pccmriQuorum == NULL );

    //
    //  Enumerate the next 10 resources.
    //
    while ( hr == S_OK )
    {
        //
        //  KB: GPease  27-JUL-2000
        //      We decided to enumerate one at a time because WMI is
        //      taking so long on the server side that the UI needs
        //      some kind of feedback. Having the server send a
        //      message back seemed to be expensive especially
        //      since grabbing 10 at a time was supposed to save
        //      us bandwidth on the wire.
        //
        //hr = STHR( pResourceEnumIn->Next( 10, pccmri, &celtFetched ) );
        hr = STHR( pResourceEnumIn->Next( 1, pccmri, &celtFetched ) );
        if ( hr == S_FALSE && celtFetched == 0 )
            break;  // exit loop

        if ( FAILED( hr ) )
        {
            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_Next, hr );
            goto Error;
        }

        //
        //  Loop thru the resource gather information out of each of them
        //  and then release them.
        //
        for( celt = 0; celt < celtFetched; celt ++ )
        {
            UINT            uIdMessage = IDS_TASKID_MINOR_FOUND_DEVICE;
            IGatherData *   pgd;
            IUnknown *      punk;

            Assert( pccmri[ celt ] != NULL );

            //  get the name of the resource
            hr = THR( pccmri[ celt ]->GetUID( &bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_GetUID, hr );
                goto Error;
            }

            TraceMemoryAddBSTR( bstrName );

            //  make sure the object manager generates a cookie for it.
            hr = STHR( m_pom->FindObject( CLSID_ManagedResourceType,
                                          m_cookieNode,
                                          bstrName,
                                          DFGUID_ManagedResource,
                                          &cookieDummy,
                                          &punk
                                          ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_FindObject, hr );
                goto Error;
            }

            TraceSysFreeString( bstrName );
            bstrName = NULL;

            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccmriNew ) );
            punk->Release();       // release promptly
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_FindObject_QI_pccmriNew, hr );
                goto Error;
            }

            //
            //  The Object Manager created a new object. Initialize it.
            //

            //  find the IGatherData interface
            hr = THR( pccmriNew->TypeSafeQI( IGatherData, &pgd ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_FindObject_QI_pgd, hr );
                goto Error;
            }

            //  have the new object gather all information it needs
            hr = THR( pgd->Gather( m_cookieNode, pccmri[ celt ] ) );
            pgd->Release();        // release promptly
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_Gather, hr );
                goto Error;
            }

            //  figure out if the device is capable of being a quorum device.
            hr = STHR( pccmriNew->IsQuorumCapable() );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_IsQuorumCapable, hr );
                goto Error;
            }
            if ( hr == S_OK )
            {
                uIdMessage = IDS_TASKID_MINOR_FOUND_QUORUM_CAPABLE_DEVICE;

                //
                //  If we aren't joining, then figure out if this resource is a better
                //  quorum resource than one previously encountered.
                //

                if ( !m_fJoining )
                {
                    ULONG   ulMegaBytes;

                    //  don't wrap - this can fail with NO_INTERFACE
                    hr = pccmri[ celt ]->TypeSafeQI( IEnumClusCfgPartitions, &peccp );
                    if ( SUCCEEDED( hr ) )
                    {
                        while ( SUCCEEDED( hr ) )
                        {
                            ULONG   celtDummy;
                            IClusCfgPartitionInfo * pccpi;

                            hr = STHR( peccp->Next( 1, &pccpi, &celtDummy ) );
                            if ( FAILED( hr ) )
                            {
                                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_Next, hr );
                                goto Error;
                            }

                            if ( hr == S_FALSE )
                                break;  // exit condition

                            hr = THR( pccpi->GetSize( &ulMegaBytes ) );
                            pccpi->Release();      // release promptly
                            if ( FAILED( hr ) )
                            {
                                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_GetSize, hr );
                                goto Error;
                            }

                            //
                            //  Does this partition meet the minimum requirements for a quorum resource?
                            //  And is it smaller than the last selected quorum resource?
                            //

                            if ( ( ulMegaBytes >= MINIMUM_STORAGE_SIZE ) && ( ulMegaBytes <  m_ulQuorumDiskSize ) )
                            {
                                if ( m_pccmriQuorum != pccmriNew )
                                {
                                    //  Set the new device as quorum
                                    hr = THR( pccmriNew->SetQuorumedDevice( TRUE ) );
                                    if ( FAILED( hr ) )
                                    {
                                        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_SetNEWQuorumedDevice, hr );
                                        goto Error;
                                    }

                                    if ( m_pccmriQuorum != NULL )
                                    {
                                        // delete the old quorum device name
                                        TraceSysFreeString( bstrQuorumDeviceName );
                                        bstrQuorumDeviceName = NULL;

                                        //  Unset the old device
                                        hr = THR( m_pccmriQuorum->SetQuorumedDevice( FALSE ) );
                                        if ( FAILED( hr ) )
                                        {
                                            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_SetOLDQuorumedDevice, hr );
                                            goto Error;
                                        }

                                        //  Release the interface
                                        m_pccmriQuorum->Release();
                                    }

                                    hr = THR( pccmriNew->GetUID( &bstrQuorumDeviceName ) );
                                    if ( FAILED( hr ) )
                                    {
                                        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_EnumPartitions_GetUID, hr );
                                        goto Error;
                                    }

                                    TraceMemoryAddBSTR( bstrQuorumDeviceName );

                                    m_pccmriQuorum = pccmriNew;
                                    m_pccmriQuorum->AddRef();
                                }

                                m_ulQuorumDiskSize = ulMegaBytes;

                                fFoundQuorumDevice = TRUE;

                            } // if: partition meets requirements and is smaller.

                        } // while: success

                        peccp->Release();
                        peccp = NULL;

                    } // if: storage capabile
                    else
                    {
                        if ( hr != E_NOINTERFACE )
                        {
                            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_QI_peccp, hr );
                            THR( hr );
                            goto Error;
                        }

                        if ( uIdMessage == IDS_TASKID_MINOR_FOUND_QUORUM_CAPABLE_DEVICE )
                        {
                            //
                            //  If it doesn't support enumerating the partitions, then we don't
                            //  consider it a candidate for being a quorum resource.
                            //

                            uIdMessage = IDS_TASKID_MINOR_FOUND_DEVICE;
                        }

                    } // else: failed

                } // if: not joining
                else
                {
                    //
                    //  If we are joining, then a quorum device had to be found
                    //  already.
                    //

                    //
                    //  BUGBUG: 08-MAY-2001 GalenB
                    //
                    //  We are not setting bstrQuorumDeviceName to something if we are joining.  This causes the message
                    //  "Setting quorum device to '(NULL)' to appear in the logs and the UI.  Where is the quorum when
                    //  we are adding a node to the cluster?
                    //
                    //  A more complete fix is to find the current quorum device and get its name.
                    //
                    fFoundQuorumDevice = TRUE;

                } // else: joining
            } // if: quorum capable

            //  send the UI layer a report
            m_cResources ++;

            //  grab the name to display in the UI
            hr = THR( pccmriNew->GetName( &bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_GetName, hr );
                goto Error;
            }

            TraceMemoryAddBSTR( bstrName );

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance, uIdMessage, &bstrNotification, bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_EnumResources_FormatMessage, hr );
                goto Error;
            }

            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_Update_Progress,
                                        0,
                                        cTotalResourcesIn,
                                        m_cResources,
                                        S_OK,
                                        bstrNotification
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            //  Cleanup for the next resource.
            TraceSysFreeString( bstrName );
            bstrName = NULL;

            pccmriNew->Release();
            pccmriNew = NULL;

            //  release the interface
            pccmri[ celt ]->Release();
            pccmri[ celt ] = NULL;
        } // for: celt
    } // while: hr

    //
    //  Update UI layer about the quorum device.
    //

    //
    //  BUGUG:  08-MAY-2001 GalenB
    //
    //  Testing that bstrQuorumDeviceName has something in it before showing this in the UI.
    //  When adding nodes this variable is not being set and was causing a status report
    //  with a NULL name to be shown in the UI.
    //
    if ( fFoundQuorumDevice )
    {
        if ( bstrQuorumDeviceName != NULL )
        {
            Assert( m_fJoining == FALSE );

            THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_FOUND_QUORUM_CAPABLE_RESOURCE, &bstrNotification ) );
            THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_Found_Quorum_Capable_Resource,
                                        0,
                                        1,
                                        1,
                                        S_OK,
                                        bstrNotification
                                        ) );

            TraceSysFreeString( bstrNotification );
            bstrNotification = NULL;

            THR( HrFormatStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_MARKING_QUORUM_CAPABLE_RESOURCE, &bstrNotification, bstrQuorumDeviceName ) );
            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_Marking_Quorum_Capable_Resource,
                                        0,
                                        1,
                                        1,
                                        S_OK,
                                        bstrNotification
                                        ) );
        } // if: we have a quorum device to show
    }
    else
    {
        if ( m_fJoining )
        {
            //
            //  If joining, stop the user.
            //

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                               IDS_TASKID_MINOR_NO_QUORUM_CAPABLE_DEVICE_FOUND,
                                               &bstrNotification,
                                               m_bstrNodeName
                                               ) );

            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_No_Quorum_Capable_Device_Found,
                                        0,
                                        1,
                                        1,
                                        HRESULT_FROM_WIN32( TW32( ERROR_QUORUM_DISK_NOT_FOUND ) ),
                                        bstrNotification
                                        ) );
            // error checked below
        }
        else
        {
            //
            //  If forming, just warn the user.
            //

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                               IDS_TASKID_MINOR_FORCED_LOCAL_QUORUM,
                                               &bstrNotification
                                               ) );

            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_No_Quorum_Capable_Device_Found,
                                        0,
                                        1,
                                        1,
                                        MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_WIN32, ERROR_QUORUM_DISK_NOT_FOUND ),
                                        bstrNotification
                                        ) );
            // error checked below
        }
    } // else: no quorum detected.

    //
    //  Check error and do the appropriate thing.
    //

    if ( FAILED( hr ) )
    {
        SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherResources_Failed, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrQuorumDeviceName );

    if ( peccp != NULL )
    {
        peccp->Release();
    }
    if ( pccmriNew != NULL )
    {
        pccmriNew->Release();
    }
    for( celt = 0; celt < 10; celt ++ )
    {
        if ( pccmri[ celt ] != NULL )
        {
            pccmri[ celt ]->Release();
        }
    } // for: celt

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer we're done will gathering and what the resulting
    //  status was.
    //
    THR( SendStatusReport( m_bstrNodeName,
                           TASKID_Major_Find_Devices,
                           TASKID_Minor_Gathering_Managed_Devices,
                           0,
                           2,
                           2,
                           hr,
                           bstrNotification
                           ) );
    goto Cleanup;

} //*** CTaskGatherInformation::HrGatherResources()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherInformation::HrGatherNetworks( IEnumClusCfgNetworks * pNetworkEnumIn, DWORD cTotalResourcesIn )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherInformation::HrGatherNetworks( IEnumClusCfgNetworks * pNetworkEnumIn, DWORD cTotalResourcesIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    ULONG   celt;

    OBJECTCOOKIE    cookieDummy;

    ULONG   celtFetched      = 0;
    ULONG   celtFound        = 0;
    BSTR    bstrName         = NULL;
    BSTR    bstrNotification = NULL;

    IClusCfgNetworkInfo *  pccniLocal   = NULL;
    IClusCfgNetworkInfo *  pccni[ 10 ]  = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

    //
    //  Enumerate the next 10 networks.
    //
    while ( hr == S_OK )
    {
        //
        //  KB: GPease  27-JUL-2000
        //      We decided to enumerate one at a time because WMI is
        //      taking so long on the server side that the UI needs
        //      some kind of feedback. Having the server send a
        //      message back seemed to be expensive especially
        //      since grabbing 10 at a time was supposed to save
        //      us bandwidth on the wire.
        //
        //hr = STHR( pNetworkEnumIn->Next( 10, pccni, &celtFetched ) );
        hr = STHR( pNetworkEnumIn->Next( 1, pccni, &celtFetched ) );
        if ( hr == S_FALSE && celtFetched == 0 )
            break;  // exit loop

        if ( FAILED( hr ) )
        {
            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_Next, hr );
            goto Error;
        }

        //
        //  Loop thru the networks gather information out of each of them
        //  and then release them.
        //
        for( celt = 0; celt < celtFetched; celt ++ )
        {
            IGatherData * pgd;
            IUnknown * punk;

            Assert( pccni[ celt ] != NULL );

            //  get the name of the resource
            hr = THR( pccni[ celt ]->GetUID( &bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_GetUID, hr );
                goto Error;
            }

            TraceMemoryAddBSTR( bstrName );

            //  make sure the object manager generates a cookie for it.
            hr = STHR( m_pom->FindObject( CLSID_NetworkType,
                                          m_cookieNode,
                                          bstrName,
                                          DFGUID_NetworkResource,
                                          &cookieDummy,
                                          &punk
                                          ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FindObject, hr );
                goto Error;
            }

            //
            //  The Object Manager created a new object. Initialize it.
            //

            //  find the IGatherData interface
            hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, &pccniLocal ) );
            punk->Release();       // release promptly
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FindObject_QI_pccniLocal, hr );
                goto Error;
            }

            //  find the IGatherData interface
            hr = THR( pccniLocal->TypeSafeQI( IGatherData, &pgd ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FindObject_QI_pgd, hr );
                goto Error;
            }

            //  have the new object gather all information it needs
            hr = THR( pgd->Gather( m_cookieNode, pccni[ celt ] ) );
            pgd->Release();        // release promptly
            if ( hr == E_UNEXPECTED )
            {
                hr = THR( HrFormatStringIntoBSTR( g_hInstance,
                                                  IDS_TASKID_MINOR_DUPLICATE_NETWORKS_FOUND,
                                                  &bstrNotification,
                                                  bstrName
                                                  ) );

                hr = THR( SendStatusReport( m_bstrNodeName,
                                            TASKID_Major_Find_Devices,
                                            TASKID_Minor_Duplicate_Networks_Found,
                                            0,
                                            cTotalResourcesIn,
                                            m_cResources + 1, // the resource number it would have been
                                            HRESULT_FROM_WIN32( ERROR_CLUSTER_NETWORK_EXISTS ),
                                            bstrNotification
                                            ) );
                hr = THR( HRESULT_FROM_WIN32( ERROR_CLUSTER_NETWORK_EXISTS ) );
                goto Cleanup;
            }
            else if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_Gather, hr );
                goto Error;
            }

            TraceSysFreeString( bstrName );
            bstrName = NULL;

            //  send the UI layer a report
            m_cResources ++;

            hr = THR( pccniLocal->GetName( &bstrName ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_GetName, hr );
                goto Error;
            }

            TraceMemoryAddBSTR( bstrName );

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                               IDS_TASKID_MINOR_FOUND_DEVICE,
                                               &bstrNotification,
                                               bstrName
                                               ) );
            if ( FAILED( hr ) )
            {
                SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FormatMessage, hr );
                goto Error;
            }

            hr = THR( SendStatusReport( m_bstrNodeName,
                                        TASKID_Major_Find_Devices,
                                        TASKID_Minor_Update_Progress,
                                        0,
                                        cTotalResourcesIn,
                                        m_cResources,
                                        S_OK,
                                        bstrNotification
                                        ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            //  found a Network Interface, increment the counter
            celtFound++;

            //  clean up before next pass
            TraceSysFreeString( bstrName );
            bstrName = NULL;

            //  release the interface
            pccni[ celt ]->Release();
            pccni[ celt ] = NULL;

            pccniLocal->Release();
            pccniLocal = NULL;

        } // for: celt

    } // while: hr

    // Check how many interfaces have been found. Should be at
    // least 2 to avoid single point of failure. If not, warn.
    if ( celtFound < 2 )
    {
        hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                           IDS_TASKID_MINOR_ONLY_ONE_NETWORK,
                                           &bstrNotification
                                           ) );
        if ( FAILED( hr ) )
        {
            SSR_TGI_FAILED( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GatherNetworks_EnumNetworks_FormatMessage, hr );
            goto Error;
        }

        hr = THR( SendStatusReport( m_bstrNodeName,
                                    TASKID_Major_Find_Devices,
                                    TASKID_Minor_Only_One_Network,
                                    0,
                                    1,
                                    1,
                                    S_FALSE,
                                    bstrNotification
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    if ( bstrName != NULL )
    {
        TraceSysFreeString( bstrName );
    }
    if ( bstrNotification != NULL )
    {
        TraceSysFreeString( bstrNotification );
    }
    if ( pccniLocal != NULL )
    {
        pccniLocal->Release();
    }
    for( celt = 0; celt < 10; celt ++ )
    {
        if ( pccni[ celt ] != NULL )
        {
            pccni[ celt ]->Release();
        }
    } // for: celt

    HRETURN( hr );

Error:
    //
    //  Tell the UI layer we're done will gathering and what the resulting
    //  status was.
    //
    THR( SendStatusReport( m_bstrNodeName,
                           TASKID_Major_Find_Devices,
                           TASKID_Minor_Gathering_Managed_Devices,
                           0,
                           2,
                           2,
                           hr,
                           bstrNotification
                           ) );
    goto Cleanup;

} //*** CTaskGatherInformation::HrGatherNetworks()


//////////////////////////////////////////////////////////////////////////////
//
//  Static function implementations
//
//////////////////////////////////////////////////////////////////////////////

static HRESULT HrTotalManagedResourceCount( IEnumClusCfgManagedResources * pResourceEnumIn, IEnumClusCfgNetworks * pNetworkEnumIn, DWORD * pnCountOut )
{
    TraceFunc( "" );
    
    DWORD   cResources = 0;
    DWORD   cNetworks = 0;
    HRESULT hr = S_OK;

    if ( ( pResourceEnumIn == NULL ) || ( pNetworkEnumIn == NULL ) || ( pnCountOut == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
        
    //
    //  Ask the resource enumerator how many resources its collection has.
    //

    hr = THR(pResourceEnumIn->Count( &cResources ));
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //
    //  Ask the network enumerator how many networks its collection has.
    //

    hr = pNetworkEnumIn->Count( &cNetworks );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    *pnCountOut = cResources + cNetworks;

Cleanup:

    HRETURN( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskgatherclusterinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherClusterInfo.cpp
//
//  Description:
//      TaskGatherClusterInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 07-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskGatherClusterInfo.h"

DEFINE_THISCLASS("CTaskGatherClusterInfo")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherClusterInfo::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherClusterInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CTaskGatherClusterInfo * ptgci = new CTaskGatherClusterInfo;
    if ( ptgci != NULL )
    {
        hr = THR( ptgci->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( ptgci->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        ptgci->Release();

        // This gets passed to other threads.
        TraceMoveToMemoryList( ptgci, g_GlobalMemoryList );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherClusterInfo::CTaskGatherClusterInfo( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherClusterInfo::CTaskGatherClusterInfo( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CTaskGatherClusterInfo()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    // IDoTask / ITaskGatherClusterInfo
    Assert( m_cookie == NULL );

    HRETURN( hr );
} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherClusterInfo::~CTaskGatherClusterInfo()
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherClusterInfo::~CTaskGatherClusterInfo()
{
    TraceFunc( "" );

    //
    //  This keeps the per thread memory tracking from screaming.
    //
    TraceMoveFromMemoryList( this, g_GlobalMemoryList );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CTaskGatherClusterInfo()

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< ITaskGatherClusterInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IDoTask ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr   = S_OK;
    } // else if: IDoTask
    else if ( IsEqualIID( riid, IID_ITaskGatherClusterInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, ITaskGatherClusterInfo, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgManagedResourceInfo

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGatherClusterInfo::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskGatherClusterInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGatherClusterInfo::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskGatherClusterInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release()


// ************************************************************************
//
// IDoTask / ITaskGatherClusterInfo
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::BeginTask( void );
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;

    IServiceProvider *          psp   = NULL;
    IUnknown *                  punk  = NULL;
    IObjectManager *            pom   = NULL;
    IConnectionManager *        pcm   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    INotifyUI *                 pnui  = NULL;
    INotificationManager *      pnm   = NULL;
    IClusCfgNodeInfo *          pccni = NULL;
    IClusCfgServer *            pccs  = NULL;
    IGatherData *               pgd   = NULL;
    IClusCfgClusterInfo *       pccci = NULL;

    TraceInitializeThread( L"TaskGatherClusterInfo" );

    //
    //  Collect the manager we need to complete this task.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager,
                               IConnectionManager,
                               &pcm
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               &pcpc
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pcp = TraceInterface( L"CTaskGatherClusterInfo!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pnui = TraceInterface( L"CTaskGatherClusterInfo!INotifyUI", INotifyUI, pnui, 1 );

    psp->Release();
    psp = NULL;

    //
    //  Ask the Connection Manager for a connection to the object.
    //

    // don't wrap - this can fail.
    hr = pcm->GetConnectionToObject( m_cookie,
                                     &punk
                                     );
    //
    //  This means the cluster has not been created yet.
    //
    if ( hr == HR_S_RPC_S_SERVER_UNAVAILABLE )
    {
        goto ReportStatus;
    }
//  HR_S_RPC_S_CLUSTER_NODE_DOWN
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto ReportStatus;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release();
    punk = NULL;

    //
    //  Get the Node information.
    //

    hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
    if ( FAILED( hr ) )
        goto ReportStatus;

    //
    //  See if the node is a member of a cluster.
    //

    hr = STHR( pccni->IsMemberOfCluster() );
    if ( FAILED( hr ) )
        goto ReportStatus;

    //
    //  If it is not a cluster, then there is nothing to do the "default"
    //  configuration will do.
    //

    if ( hr == S_FALSE )
    {
        hr = S_OK;
        goto ReportStatus;
    }

    //
    //  Ask the Node for the Cluster Information.
    //

    hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
    if ( FAILED( hr ) )
        goto ReportStatus;

    //
    //  Ask the Object Manager to retrieve the data format to store the information.
    //

    Assert( punk == NULL );
    hr = THR( pom->GetObject( DFGUID_ClusterConfigurationInfo, m_cookie, &punk ) );
    if ( FAILED( hr ) )
        goto ReportStatus;

    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
        goto ReportStatus;

    //
    //  Start sucking.
    //

    hr = THR( pgd->Gather( NULL, pccci ) );

    //
    //  Update the status. Ignore the error (if any).
    //
ReportStatus:
    if ( pom != NULL )
    {
        HRESULT hr2;
        IUnknown * punk;

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo,
                                   m_cookie,
                                   &punk
                                   ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }
    }
    if ( pnui != NULL )
    {
        THR( pnui->ObjectChanged( m_cookie ) );
    }

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcm != NULL )
    {
        pcm->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pom != NULL )
    {
        HRESULT hr2;
        IUnknown * punk;

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo,
                                   m_cookieCompletion,
                                   &punk
                                   ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }

        pom->Release();
    }
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pnui !=NULL )
    {
        if ( m_cookieCompletion != 0 )
        {
            THR( pnui->ObjectChanged( m_cookieCompletion ) );
        }
        pnui->Release();
    }

    HRETURN( hr );

} // BeginTask()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::SetCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskGatherClusterInfo]" );

    HRESULT hr = S_OK;

    m_cookie = cookieIn;

    HRETURN( hr );

} //*** SetCookie

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherClusterInfo::SetCompletionCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherClusterInfo::SetCompletionCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} // SetGatherPunk()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskgatherclusterinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherClusterInfo.h
//
//  Description:
//      CTaskGatherClusterInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 07-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskGatherClusterInfo
class
CTaskGatherClusterInfo:
    public ITaskGatherClusterInfo
{
private:
    // IUnknown
    LONG                m_cRef;

    // IDoTask / ITaskGatherNodeInfo
    OBJECTCOOKIE        m_cookie;           //  Cookie to the Node
    OBJECTCOOKIE        m_cookieCompletion; //  Cookie to signal when task is completed

    CTaskGatherClusterInfo( void );
    ~CTaskGatherClusterInfo( void );
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskGatherNodeInfo
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieIn );

}; // class CTaskGatherClusterInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskgatherinformation.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherInformation.h
//
//  Description:
//      CTaskGatherInformation implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskGatherInformation
class
CTaskGatherInformation:
    public ITaskGatherInformation
{
private:
    // IUnknown
    LONG                            m_cRef;

    // IDoTask / ITaskGatherInformation
    OBJECTCOOKIE                    m_cookieCompletion;     //  Cookie to signal when task is completed.
    OBJECTCOOKIE                    m_cookieNode;           //  Cookie of the node to gather from.
    IClusCfgCallback *              m_pcccb;                //  Marshalled UI Layer callback
    BOOL                            m_fJoining:1;           //  If the node is to be joining a cluster...
    ULONG                           m_cResources;           //  Resource counter

    IObjectManager *                m_pom;                  //  Object manager
    IClusCfgServer *                m_pccs;                 //  ClusCfgServer
    BSTR                            m_bstrNodeName;         //  Hostname of the node

    ULONG                           m_ulQuorumDiskSize;     //  Size of the selected quorum resource
    IClusCfgManagedResourceInfo *   m_pccmriQuorum;         //  Punk to the MT quorum resource object

    CTaskGatherInformation( void );
    ~CTaskGatherInformation( void );
    STDMETHOD( HrInit )( void );

    HRESULT HrGatherResources( IEnumClusCfgManagedResources * pResourceEnumIn, DWORD cTotalResourcesIn );
    HRESULT HrGatherNetworks( IEnumClusCfgNetworks * pNetworkEnumIn, DWORD cTotalResourcesIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskGatherInformation
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetNodeCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetJoining )( void );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID clsidTaskMajorIn,
                                   CLSID clsidTaskMinorIn,
                                   ULONG ulMinIn,
                                   ULONG ulMaxIn,
                                   ULONG ulCurrentIn,
                                   HRESULT hrStatusIn,
                                   BSTR bstrDescriptionIn
                                   );

}; // class CTaskGatherInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskgathernodeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherNodeInfo.h
//
//  Description:
//      CTaskGatherNodeInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskGatherNodeInfo
class
CTaskGatherNodeInfo:
    public ITaskGatherNodeInfo,
    public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;

    //  IDoTask / ITaskGatherNodeInfo
    OBJECTCOOKIE        m_cookie;           //  Cookie to the Node
    OBJECTCOOKIE        m_cookieCompletion; //  Cookie to signal when task is completed
    BSTR                m_bstrName;         //  Name of the node

    //  IClusCfgCallback
    IClusCfgCallback *  m_pcccb;            //  Marshalled callback interface

    CTaskGatherNodeInfo( void );
    ~CTaskGatherNodeInfo( void );
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IDoTask / ITaskGatherNodeInfo
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );
    STDMETHOD( SetCompletionCookie )( OBJECTCOOKIE cookieIn );

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; // class CTaskGatherNodeInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskgathernodeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGatherNodeInfo.cpp
//
//  Description:
//      CTaskGatherNodeInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskGatherNodeInfo.h"

DEFINE_THISCLASS("CTaskGatherNodeInfo")

//
//  Failure code.
//

#define SSR_FAILURE( _minor, _hr )  THR( SendStatusReport( m_bstrName, TASKID_Major_Client_And_Server_Log, _minor, 0, 1, 1, _hr, NULL, NULL, NULL ) );

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGatherNodeInfo::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGatherNodeInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CTaskGatherNodeInfo * ptgni = new CTaskGatherNodeInfo;
    if ( ptgni != NULL )
    {
        hr = THR( ptgni->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( ptgni->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        ptgni->Release();

        // This gets passed to other threads.
        TraceMoveToMemoryList( ptgni, g_GlobalMemoryList );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherNodeInfo::CTaskGatherNodeInfo( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherNodeInfo::CTaskGatherNodeInfo( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CTaskGatherNodeInfo()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    //  IDoTask / ITaskGatherNodeInfo
    Assert( m_cookie == NULL );
    Assert( m_cookieCompletion == NULL );
    Assert( m_bstrName == NULL );

    //  IClusCfgCallback
    Assert( m_pcccb == NULL );

    HRETURN( hr );
} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGatherNodeInfo::~CTaskGatherNodeInfo()
//
//////////////////////////////////////////////////////////////////////////////
CTaskGatherNodeInfo::~CTaskGatherNodeInfo()
{
    TraceFunc( "" );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    TraceSysFreeString( m_bstrName );

    //
    //  This keeps the per thread memory tracking from screaming.
    //
    TraceMoveFromMemoryList( this, g_GlobalMemoryList );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CTaskGatherNodeInfo()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< ITaskGatherNodeInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IDoTask ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr   = S_OK;
    } // else if: IDoTask
    else if ( IsEqualIID( riid, IID_ITaskGatherNodeInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, ITaskGatherNodeInfo, this, 0 );
        hr   = S_OK;
    } // else if: ITaskGatherNodeInfo

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGatherNodeInfo::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskGatherNodeInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGatherNodeInfo::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskGatherNodeInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release()


// ************************************************************************
//
// IDoTask / ITaskGatherNodeInfo
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::BeginTask( void );
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;

    OBJECTCOOKIE    cookieParent;

    BSTR    bstrNotification = NULL;

    IServiceProvider *          psp   = NULL;
    IUnknown *                  punk  = NULL;
    IObjectManager *            pom   = NULL;
    IConnectionManager *        pcm   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    INotifyUI *                 pnui  = NULL;
    IClusCfgNodeInfo *          pccni = NULL;
    IClusCfgServer *            pccs  = NULL;
    IGatherData *               pgd   = NULL;
    IStandardInfo *             psi   = NULL;

    TraceInitializeThread( L"TaskGatherNodeInfo" );

    //
    //  Collect the manager we need to complete this task.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_CoCreate_ServiceManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_QS_ObjectManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_ClusterConnectionManager,
                               IConnectionManager,
                               &pcm
                               ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_QS_ConnectionManager, hr );
        goto Cleanup;
    }

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               &pcpc
                               ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_QS_NotificationManager, hr );
        goto Cleanup;
    }

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI,
                                         &pcp
                                         ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_FindConnectionPoint, hr );
        goto Cleanup;
    }

    pcp = TraceInterface( L"CTaskGatherNodeInfo!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_FindConnectionPoint_QI, hr );
        goto Cleanup;
    }

    pnui = TraceInterface( L"CTaskGatherNodeInfo!INotifyUI", INotifyUI, pnui, 1 );

    // release promptly
    psp->Release();
    psp = NULL;

    //
    //  Retrieve the node's standard info.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              m_cookie,
                              &punk
                              ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_GetObject_StandardInfo, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_GetObject_StandardInfo_QI_psi, hr );
        goto Cleanup;
    }

    psi = TraceInterface( L"TaskGatherNodeInfo!IStandardInfo", IStandardInfo, psi, 1 );

    //
    //  Get the node's name to display a status message.
    //

    hr = THR( psi->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_GatherNodeInfo_GetName, hr );
        goto Cleanup;
    }

    //
    //  Create a progress message.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_TASKID_MINOR_CONNECTING_TO_NODES,
                                    &bstrNotification
                                    ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_LoadString_Connecting, hr );
        goto Cleanup;
    }

    //
    //  Tell the UI layer what's going on.
    //

    hr = THR( SendStatusReport( m_bstrName,
                                TASKID_Major_Establish_Connection,
                                TASKID_Minor_Connecting,
                                0,
                                1,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Connection Manager for a connection to the object.
    //

    hr = pcm->GetConnectionToObject( m_cookie, &punk );
    if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
    {
        goto Cleanup;
    }
    else if ( FAILED( hr ) )
    {
        THR( hr );
        SSR_FAILURE( TASKID_Minor_BeginTask_GetConnectionToObject, hr );
        goto Cleanup;
    }

    //
    //  If this comes up from a Node, this is bad so change the error code
    //  back and bail.
    //

    if ( hr == HR_S_RPC_S_SERVER_UNAVAILABLE )
    {
        hr = THR( HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ) );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgServer, &pccs ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetConnectionToObject_QI_pccs, hr );
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    hr = THR( pccs->GetClusterNodeInfo( &pccni ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetClusterNodeInfo, hr );
        goto Cleanup;
    }

    //
    //  Ask the Object Manager to retrieve the data format to store the information.
    //

    hr = THR( pom->GetObject( DFGUID_NodeInformation,
                              m_cookie,
                              &punk
                              ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetObject_NodeInformation, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IGatherData, &pgd ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetObject_NodeInformation_QI_pgd, hr );
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    //
    //  Find out our parent.
    //

    hr = THR( psi->GetParent( &cookieParent ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_GetParent, hr );
        goto Cleanup;
    }

    //
    //  Start sucking.
    //

    hr = THR( pgd->Gather( cookieParent, pccni ) );
    if ( FAILED( hr ) )
    {
        SSR_FAILURE( TASKID_Minor_BeginTask_Gather, hr );
        //
        //  Don't goto cleanup - we need to single that the information possibly changed.
        //
    }

    //
    //  At this point, we don't care if the "Gather" succeeded or failed. We
    //  need to single that the object potentially changed.
    //
    THR( pnui->ObjectChanged( m_cookie ) );

Cleanup:
    //  Tell the UI layer we are done and the results of what was done.
    THR( SendStatusReport( m_bstrName,
                           TASKID_Major_Establish_Connection,
                           TASKID_Minor_Connecting,
                           0,
                           1,
                           1,
                           hr,
                           NULL,
                           NULL,
                           NULL
                           ) );
    //  don't care about errors from SSR at this point

    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcm != NULL )
    {
        pcm->Release();
    }
    if ( pccs != NULL )
    {
        pccs->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pom != NULL )
    {
        //
        //  Update the cookie's status indicating the result of our task.
        //

        IUnknown * punk;
        HRESULT hr2;

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo, m_cookie, &punk ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
//                if ( hr == HR_S_RPC_S_CLUSTER_NODE_DOWN )
//                {
//                    hr = HRESULT_FROM_WIN32( ERROR_CLUSTER_NODE_DOWN );
//                }

                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo, m_cookieCompletion, &punk ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }

        pom->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pnui != NULL )
    {
        if ( m_cookieCompletion != NULL )
        {
            //
            //  Signal the cookie to indicate that we are done.
            //
            THR( pnui->ObjectChanged( m_cookieCompletion ) );
        }

        pnui->Release();
    }
    if ( pgd != NULL )
    {
        pgd->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }

    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} // BeginTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::SetCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::SetCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "[ITaskGatherNodeInfo]" );

    HRESULT hr = S_OK;

    m_cookie = cookieIn;

    HRETURN( hr );

} //*** SetCookie

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::SetCompletionCookie(
//      OBJECTCOOKIE    cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::SetCompletionCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc( "..." );

    HRESULT hr = S_OK;

    m_cookieCompletion = cookieIn;

    HRETURN( hr );

} // SetGatherPunk()


//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGatherNodeInfo::SendStatusReport(
//       LPCWSTR    pcszNodeNameIn
//     , CLSID      clsidTaskMajorIn
//     , CLSID      clsidTaskMinorIn
//     , ULONG      ulMinIn
//     , ULONG      ulMaxIn
//     , ULONG      ulCurrentIn
//     , HRESULT    hrStatusIn
//     , LPCWSTR    pcszDescriptionIn
//     , FILETIME * pftTimeIn
//     , LPCWSTR    pcszReferenceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGatherNodeInfo::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    TypeSafeParams( IServiceProvider, &psp )
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                                   IConnectionPointContainer,
                                   &pcpc
                                   ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                         clsidTaskMajorIn,
                                         clsidTaskMinorIn,
                                         ulMinIn,
                                         ulMaxIn,
                                         ulCurrentIn,
                                         hrStatusIn,
                                         pcszDescriptionIn,
                                         pftTimeIn,
                                         pcszReferenceIn
                                         ) );

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} // SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskgetdomains.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGetDomains.h
//
//  Description:
//      CTaskGetDomains implementation.
//
//  Maintained By:
//      Galen Barbee    (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
// Class Declarations
//////////////////////////////////////////////////////////////////////////////

// CTaskGetDomains
class CTaskGetDomains
    : public ITaskGetDomains
{
private:
    // IUnknown
    LONG                        m_cRef;

    // ITaskGetDomains
    IStream *                   m_pStream;      // Interface marshalling stream
    ITaskGetDomainsCallback *   m_ptgdcb;       // Marshalled interface
    CRITICAL_SECTION            m_csCallback;   // Protects access to m_ptgdcb

    CTaskGetDomains( void );
    ~CTaskGetDomains( void );

    STDMETHOD( Init )(void);

    HRESULT HrReleaseCurrentCallback( void );
    HRESULT  HrUnMarshallCallback( void );

    STDMETHOD( ReceiveDomainResult )( HRESULT hrIn );
    STDMETHOD( ReceiveDomainName )( BSTR bstrDomainNameIn );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask / ITaskGetDomains
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCallback )( ITaskGetDomainsCallback * punkIn );

}; // class CTaskGetDomains
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskkeepmtaalive.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskKeepMTAAlive.cpp
//
//  Description:
//      Keep MTA Alive Task implementation.
//
//  Maintained By:
//      Galen Barbee  (GalenB) 17-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskKeepMTAAlive.h"

DEFINE_THISCLASS("CTaskKeepMTAAlive")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskKeepMTAAlive::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskKeepMTAAlive::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CTaskKeepMTAAlive * ptkmtaa = new CTaskKeepMTAAlive;

    //  Self terminating - no need to track
    TraceMemoryDelete( ptkmtaa, FALSE );

    if ( ptkmtaa != NULL )
    {
        hr = THR( ptkmtaa->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( ptkmtaa->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        ptkmtaa->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskKeepMTAAlive::CTaskKeepMTAAlive( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskKeepMTAAlive::CTaskKeepMTAAlive( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_fStop == false );

    TraceFuncExit();

} // CTaskKeepMTAAlive()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskKeepMTAAlive::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskKeepMTAAlive::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskKeepMTAAlive::~CTaskKeepMTAAlive()
//
//////////////////////////////////////////////////////////////////////////////
CTaskKeepMTAAlive::~CTaskKeepMTAAlive()
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CTaskKeepMTAAlive()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskKeepMTAAlive::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskKeepMTAAlive::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IDoTask * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IDoTask ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr   = S_OK;
    } // else if: IDoTask

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskKeepMTAAlive::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskKeepMTAAlive::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskKeepMTAAlive::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskKeepMTAAlive::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} // Release()



//****************************************************************************
//
//  IDoTask
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskKeepMTAAlive::BeginTask()
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskKeepMTAAlive::BeginTask()
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    MSG msg;

    while ( GetMessage( &msg, NULL, 0, 0 ) && !m_fStop )
    {
        DispatchMessage( &msg );
    }

    HRETURN( hr );

} //*** BeginTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskKeepMTAAlive::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskKeepMTAAlive::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = true;

    HRETURN( hr );

} //*** StopTask
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskkeepmtaalive.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskKeepMTAAlive.h
//
//  Description:
//      CTaskKeepMTAAlive implementation.
//
//  Maintained By:
//      Galen Barbee  (GalenB) 17-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskKeepMTAAlive
class
CTaskKeepMTAAlive:
    public IDoTask
{
private:
    // IUnknown
    LONG    m_cRef;

    bool    m_fStop;

    CTaskKeepMTAAlive( void );
    ~CTaskKeepMTAAlive( void );
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );

}; // class CTaskKeepMTAAlive
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskgetdomains.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskGetDomains.cpp
//
//  Description:
//      Get DNS/NetBIOS Domain Names for the list of domains.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ClusCfgClient.h"
#include "TaskGetDomains.h"

// ADSI support, to get domain names
#include <Lm.h>
#include <Dsgetdc.h>

DEFINE_THISCLASS("CTaskGetDomains")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGetDomains::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGetDomains::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CTaskGetDomains * ptgd = new CTaskGetDomains;
    if ( ptgd != NULL )
    {
        hr = THR( ptgd->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( ptgd->TypeSafeQI( IUnknown, ppunkOut ) );
            //TraceMoveToMemoryList( *ppunkOut, g_GlobalMemoryList );
        }

        ptgd->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGetDomains::CTaskGetDomains( void )
//
//////////////////////////////////////////////////////////////////////////////

CTaskGetDomains::CTaskGetDomains()
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CTaskGetDomains()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    // ITaskGetDomains
    Assert( m_pStream == NULL );
    Assert( m_ptgdcb == NULL );

    InitializeCriticalSection( &m_csCallback );

    HRETURN( hr );

} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskGetDomains::~CTaskGetDomains()
//
//////////////////////////////////////////////////////////////////////////////

CTaskGetDomains::~CTaskGetDomains()
{
    TraceFunc( "" );

    if ( m_pStream != NULL)
    {
        m_pStream->Release();
    }

    if ( m_ptgdcb != NULL )
    {
        m_ptgdcb->Release();
    }

    DeleteCriticalSection( &m_csCallback );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CTaskGetDomains()

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//     )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::QueryInterface(
    REFIID riid,
    LPVOID *ppv)
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if (IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< ITaskGetDomains * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_ITaskGetDomains ) )
    {
        *ppv = TraceInterface( __THISCLASS__, ITaskGetDomains, this, 0 );
        hr   = S_OK;
    } // else if: ITaskGetDomains
    else if ( IsEqualIID( riid, IID_IDoTask ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr = S_OK;
    } // else if: IDoTask

    if ( SUCCEEDED( hr ) )
    {
        ( (IUnknown *) *ppv )->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGetDomains::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CTaskGetDomains::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskGetDomains::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskGetDomains::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
    {
        RETURN(m_cRef);
    }

    TraceDo( delete this );

    RETURN( 0 );

} // Release()

// ************************************************************************
//
// IDoTask / ITaskGetDomains
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::BeginTask(void);
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr;
    ULONG   ulLen;
    DWORD   dwRes;
    ULONG   idx;

    PDS_DOMAIN_TRUSTS paDomains = NULL;

    hr = THR( HrUnMarshallCallback() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Enumerate the list of Domains
    //
    dwRes = TW32( DsEnumerateDomainTrusts( NULL,
                                           DS_DOMAIN_VALID_FLAGS,
                                           &paDomains,
                                           &ulLen
                                           ) );

    //
    // Might return ERROR_NOT_SUPPORTED if the DC is pre-W2k
    // In that case, retry in compatible mode
    //
    if ( dwRes == ERROR_NOT_SUPPORTED )
    {
        dwRes = TW32( DsEnumerateDomainTrusts( NULL,
                                               DS_DOMAIN_VALID_FLAGS & ( ~DS_DOMAIN_DIRECT_INBOUND),
                                               &paDomains,
                                               &ulLen
                                               ) );
    } // if:
    if ( dwRes != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( dwRes );
        goto Cleanup;
    }

    //
    //  Pass the information to the UI layer.
    //
    for ( idx = 0; idx < ulLen; idx++ )
    {
        if ( paDomains[ idx ].DnsDomainName != NULL )
        {
            if ( m_ptgdcb != NULL )
            {
                BSTR bstrDomainName = TraceSysAllocString( paDomains[ idx ].DnsDomainName );
                if ( bstrDomainName == NULL )
                    goto OutOfMemory;

                hr = THR( ReceiveDomainName( bstrDomainName ) );

                // check error after freeing string
                TraceSysFreeString( bstrDomainName );

                if ( FAILED( hr ) )
                    goto Cleanup;
            }
            else
            {
                break;
            }
        }
        else if ( paDomains[ idx ].NetbiosDomainName != NULL )
        {
            if ( m_ptgdcb != NULL )
            {
                BSTR bstrDomainName = TraceSysAllocString( paDomains[ idx ].NetbiosDomainName );
                if ( bstrDomainName == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                // send data
                hr = THR( ReceiveDomainName( bstrDomainName ) );

                TraceSysFreeString( bstrDomainName );

                if ( FAILED( hr ) )
                    goto Cleanup;
            }
        }
    }

    hr = S_OK;

Cleanup:
    if ( paDomains != NULL )
    {
        NetApiBufferFree( paDomains );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // BeginTask()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::SetCallback(
//      ITaskGetDomainsCallback * punkIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::SetCallback(
    ITaskGetDomainsCallback * punkIn
    )
{
    TraceFunc( "[ITaskGetDomains]" );

    HRESULT hr = E_UNEXPECTED;

    if ( punkIn != NULL )
    {
        EnterCriticalSection( &m_csCallback );

        hr = THR( CoMarshalInterThreadInterfaceInStream( IID_ITaskGetDomainsCallback,
                                                         punkIn,
                                                         &m_pStream
                                                         ) );

        LeaveCriticalSection( &m_csCallback );

    }
    else
    {
        hr = THR( HrReleaseCurrentCallback() );
    }

    HRETURN( hr );

} // SetCallback()


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGetDomains::HrReleaseCurrentCallback( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGetDomains::HrReleaseCurrentCallback( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    EnterCriticalSection( &m_csCallback );

    if ( m_pStream != NULL )
    {
        hr = THR( CoUnmarshalInterface( m_pStream,
                                        TypeSafeParams( ITaskGetDomainsCallback, &m_ptgdcb )
                                        ) );

        m_pStream->Release();
        m_pStream = NULL;
    }

    if ( m_ptgdcb != NULL )
    {
        m_ptgdcb->Release();
        m_ptgdcb = NULL;
    }

    LeaveCriticalSection( &m_csCallback );

    HRETURN( hr );

} // HrReleaseCurrentCallback()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskGetDomains::HrUnMarshallCallback( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskGetDomains::HrUnMarshallCallback( void )
{
    TraceFunc( "" );

    HRESULT hr;

    EnterCriticalSection( &m_csCallback );

    hr = THR( CoUnmarshalInterface( m_pStream,
                                    TypeSafeParams( ITaskGetDomainsCallback, &m_ptgdcb )
                                    ) );

    m_pStream->Release();
    m_pStream = NULL;

    LeaveCriticalSection( &m_csCallback );

    HRETURN( hr );

} // HrUnMarshallCallback()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CClusDomainPage::ReceiveDomainResult(
//      HRESULT hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::ReceiveDomainResult(
    HRESULT hrIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    EnterCriticalSection( &m_csCallback );

    if ( m_ptgdcb != NULL )
    {
        hr = THR( m_ptgdcb->ReceiveDomainResult( hrIn ) );
    }

    LeaveCriticalSection( &m_csCallback );

    HRETURN( hr );

} // ReceiveResult()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskGetDomains::ReceiveDomainName(
//      BSTR bstrDomainNameIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskGetDomains::ReceiveDomainName(
    BSTR bstrDomainNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    EnterCriticalSection( &m_csCallback );

    if ( m_ptgdcb != NULL )
    {
        hr = THR( m_ptgdcb->ReceiveDomainName( bstrDomainNameIn ) );
    }

    LeaveCriticalSection( &m_csCallback );

    HRETURN( hr );

} // ReceiveDomainName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ActionMgr.h
//
//  Description:
//      Action Manager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskManager
class
CTaskManager:
    public ITaskManager
{
private:
    // IUnknown
    LONG            m_cRef;

    CTaskManager( void );
    ~CTaskManager( void );
    STDMETHOD(Init)( void );

    static DWORD WINAPI S_BeginTask( LPVOID pParam );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // ITaskManager
    STDMETHOD(CreateTask)( REFIID clsidTaskIn, IUnknown** ppUnkOut );

    // ITaskManager
    STDMETHOD(SubmitTask)( IDoTask * pTask);

}; // class CTaskManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskManager.cpp
//
//  Description:
//      Task Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskManager.h"

DEFINE_THISCLASS( "CTaskManager" )
#define THISCLASS CTaskManager
#define LPTHISCLASS CTaskManager *

//
//  Define this to cause the Task Manager to do all tasks synchonously.
//
//#define SYNCHRONOUS_TASKING


//****************************************************************************
//
//  Constructor / Destructor
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT             hr;
    IServiceProvider *  psp;

    // Don't wrap - this can fail with E_POINTER.
    hr = CServiceManager::S_HrGetManagerPointer( &psp );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( psp->TypeSafeQS( CLSID_TaskManager, IUnknown, ppunkOut ) );
        psp->Release();

    } // if: service manager exists
    else if ( hr == E_POINTER )
    {
        //
        //  This happens when the Service Manager is first started.
        //
        CTaskManager * ptm = new CTaskManager();
        if ( ptm != NULL )
        {
            TraceMoveToMemoryList( ptm, g_GlobalMemoryList );

            hr = THR( ptm->Init() );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( ptm->TypeSafeQI( IUnknown, ppunkOut ) );
            } // if: success

            ptm->Release();

        } // if: got object
        else
        {
            hr = E_OUTOFMEMORY;
        }

    } // if: service manager doesn't exist
    else
    {
        THR( hr );
    } // else:

    HRETURN( hr );

} //*** S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::CTaskManager( void )
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskManager::CTaskManager( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskManager::CTaskManager()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskManager::Init( void )
//
//  Description:
//      Initialize the instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK        - Successful.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskManager::Init( void )
{
    TraceFunc( "" );

    HRETURN( S_OK );

} //*** CTaskManager::Init()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskManager::~CTaskManager( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskManager::~CTaskManager( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskManager::~CTaskManager()


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskManager::[IUnknown] QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//  Description:
//      Query for an interface on the object.
//
//  Arguments:
//      riidIn
//      ppvOut
//
//  Return Values:
//      S_OK            Interface returned successfully.
//      E_NOINTERFACE   Unknown interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskManager::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        //
        // Technically, we shouldn't do this. This is just for a demo.
        //
        *ppvOut = static_cast< ITaskManager * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskManager ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskManager, this , 0 );
//        TraceMoveToMemoryList( *ppvOut, g_GlobalMemoryList );
        hr   = S_OK;
    } // else if: ITaskManager

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskManager::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CTaskManager::[IUnknown] AddRef( void )
//
//  Description:
//      Add a reference to the object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Count of references.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CTaskManager::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CTaskManager::[IUnknown] Release( void )
//
//  Description:
//      Decrement the reference count on the object.
//
//  Arguments:
//      None.
//
//   Returns:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CTaskManager::Release()


//****************************************************************************
//
//  ITaskManager
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskManager::[ITaskManager] SubmitTask(
//      IDoTask *   pTask
//      )
//
//  Description:
//      Execute a task.
//
//  Arguments:
//      pTask       - The task to execute.
//
//  Return Values:
//      S_OK        - Successful.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskManager::SubmitTask(
    IDoTask *   pTask
    )
{
    TraceFunc1( "[ITaskManager] pTask = %#x", pTask );

    BOOL    fResult;
    HRESULT hr;

#if defined( SYNCHRONOUS_TASKING )
    //
    // Don't wrap. The "return value" is meaningless since it normally
    // would not make it back here. The "return value" of doing the task
    // should have been submitted thru the Notification Manager.
    //
    pTask->BeginTask();

    //
    // Fake it as if the task was submitted successfully.
    //
    hr = S_OK;

    goto Cleanup;
#else
    IStream * pstm; // don't free! (unless QueueUserWorkItem fails)

    TraceMemoryDelete( pTask, FALSE );  // About to be handed to another thread.

    hr = THR( CoMarshalInterThreadInterfaceInStream( IID_IDoTask, pTask, &pstm ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    fResult = QueueUserWorkItem( S_BeginTask, pstm, WT_EXECUTELONGFUNCTION );
    if ( fResult != FALSE )
    {
        hr = S_OK;
    } // if: success
    else
    {
        hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
        pstm->Release();
    } // else:

    //
    //  Don't free the stream. It will be freed by S_BeginTask.
    //
#endif

Cleanup:

    HRETURN( hr );

} //*** CTaskManager::SubmitTask()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskManager::[ITaskManager] CreateTask(
//      REFCLSID    clsidTaskIn,    // CLSID of the task to create
//      IUnknown ** ppUnkOut        // Pointer to interface specified by riidIn
//      )
//
//  Description:
//      The purpose of this is to create the task in our process and/or our
//      apartment.
//
//  Arguments:
//      clsidTaskIn     - CLSID of the task to create.
//      ppUnkOut        - IUnknown interface.
//
//  Return Values:
//
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskManager::CreateTask(
    REFIID      clsidTaskIn,    // CLSID of the task to create
    IUnknown ** ppUnkOut        // IUnknown interface
    )
{
    TraceFunc( "[ITaskManager] clsidTaskIn, ppvOut" );

    HRESULT hr;

    //
    // TODO:    gpease 27-NOV-1999
    //          Maybe implement a list of "spent" tasks in order to
    //          reuse tasks that have been completed and reduce heap
    //          thrashing.(????)
    //

    hr = THR( HrCoCreateInternalInstance(
                          clsidTaskIn
                        , NULL
                        ,  CLSCTX_INPROC_SERVER, IID_IUnknown
                        , reinterpret_cast< void ** >( ppUnkOut )
                        ) );

    HRETURN( hr );

} //*** CTaskManager::CreateTask()


//****************************************************************************
//
//  Private Methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  WINAPI
//  CTaskManager::S_BeginTask(
//      LPVOID pParam
//      )
//
//  Description:
//      Thread task to begin the task.
//
//  Arguments:
//      pParam      - Parameter for the task.
//
//  Return Values:
//      Ignored.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
CTaskManager::S_BeginTask(
    LPVOID pParam
    )
{
    TraceFunc1( "pParam = %#x", pParam );
    Assert( pParam != NULL );

    HRESULT hr;

    IDoTask * pTask = NULL;
    IStream * pstm  = reinterpret_cast< IStream * >( pParam );

    TraceMemoryAddPunk( pTask );

    hr = STHR( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE ) );
    if ( FAILED( hr ) )
        goto Bail;

    hr = THR( CoUnmarshalInterface( pstm, TypeSafeParams( IDoTask, &pTask ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pTask->BeginTask();

Cleanup:

    if ( pTask != NULL )
    {
        pTask->Release();  // AddRef'ed in SubmitTask
    }

    if ( pstm != NULL )
    {
        pstm->Release();
    }

    CoUninitialize();

Bail:

    FRETURN( hr );

    return hr;

} //*** CTaskManager::S_BeginTask()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\tasklogindomain.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskLoginDomain.h
//
//  Description:
//      CTaskLoginDomain implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 16-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskLoginDomain
class
CTaskLoginDomain
    : public ITaskLoginDomain
{
private:
    // IUnknown
    LONG                m_cRef;

    //  ITaskLoginDomain
    IStream *           m_pstream;          // Interface marshalling stream
    BSTR                m_bstrDomain;       // Domain to be checked

    IClusCfgCallback *  m_pcccb;            // Marshalled UI Layer callback
    BSTR                m_bstrLocalNode;    // Name of the local node for status reports

    CTaskLoginDomain( void );
    ~CTaskLoginDomain( void );
    STDMETHOD( HrInit )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      CLSID     clsidTaskMajorIn
                    , CLSID     clsidTaskMinorIn
                    , ULONG     ulMinIn
                    , ULONG     ulMaxIn
                    , ULONG     ulCurrentIn
                    , HRESULT   hrStatusIn
                    , LPCWSTR   pcwszDescriptionIn
                    );

    // IDoTask/ITaskLoginDomain
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetCallback )( ITaskLoginDomainCallback * punkIn );
    STDMETHOD( SetDomain )( LPCWSTR pcszDomainIn );

}; //*** class CTaskLoginDomain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\tasklogindomain.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskLoginDomain.cpp
//
//  Description:
//      CTaskLoginDomain implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 16-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskLoginDomain.h"

DEFINE_THISCLASS("CTaskLoginDomain")

//****************************************************************************
//
// Constructor / Destructor
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskLoginDomain::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskLoginDomain::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( ppunkOut != NULL );

    CTaskLoginDomain * pTaskLoginDomain = new CTaskLoginDomain;

    TraceMoveToMemoryList( pTaskLoginDomain, g_GlobalMemoryList );

    if ( pTaskLoginDomain != NULL )
    {
        hr = THR( pTaskLoginDomain->HrInit() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pTaskLoginDomain->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pTaskLoginDomain->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} //*** CTaskGatherInformation::S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskLoginDomain::CTaskLoginDomain( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskLoginDomain::CTaskLoginDomain( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherInformation::CTaskLoginDomain()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskLoginDomain::HrInit( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskLoginDomain::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IDoTask
    Assert( m_pstream == NULL );
    Assert( m_bstrDomain == NULL );

    Assert( m_bstrLocalNode == NULL );

    HRETURN( hr );

} //*** CTaskGatherInformation::HrInit()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskLoginDomain::~CTaskLoginDomain()
//
//////////////////////////////////////////////////////////////////////////////
CTaskLoginDomain::~CTaskLoginDomain( void )
{
    TraceFunc( "" );

    Assert( m_cRef == 0 );

//    TraceMoveFromMemoryList( m_bstrLocalNode, g_GlobalMemoryList );
    TraceSysFreeString( m_bstrLocalNode );

    if ( m_bstrDomain != NULL )
    {
        TraceMoveFromMemoryList( m_bstrDomain, g_GlobalMemoryList ); // [DavidP] 25-JAN-2001 Why is this here?
        TraceSysFreeString( m_bstrDomain );
    }

    if ( m_pstream != NULL )
    {
        m_pstream->Release();
    }

    if ( m_pcccb != NULL )
    {
        //TraceMoveFromMemoryList( m_pcccb, g_GlobalMemoryList );
        m_pcccb->Release();
    } // if:

    TraceMoveFromMemoryList( this, g_GlobalMemoryList );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskGatherInformation::~CTaskLoginDomain()


//****************************************************************************
//
// IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskLoginDomain::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskLoginDomain::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskLoginDomain * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskLoginDomain ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskLoginDomain, this, 0 );
        hr = S_OK;
    } // else if: ITaskLoginDomain
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr = S_OK;
    } // else if: IDoTask

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CTaskGatherInformation::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CTaskLoginDomain::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskLoginDomain::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CTaskGatherInformation::AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CTaskLoginDomain::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskLoginDomain::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CTaskGatherInformation::Release()



//****************************************************************************
//
//  ITaskLoginDomain
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskLoginDomain::BeginTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskLoginDomain::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    BOOL                    fRet;
    DWORD                   dwErr;
    DWORD                   cchName;
    DWORD                   cbSid;
    DWORD                   cbDomain;
    BSTR                    bstrName = NULL;
    SID_NAME_USE            snu;
    PDOMAIN_CONTROLLER_INFO pdcInfo = NULL;

    HRESULT hr     = S_OK;

    ITaskLoginDomainCallback * ptldcb = NULL;

    hr = THR( CoUnmarshalInterface( m_pstream, TypeSafeParams( ITaskLoginDomainCallback, &ptldcb ) ) );
    if ( FAILED( hr ) )
    {
        SendStatusReport(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_LoginDomain_BeginTask_Unmarshal_ITaskLoginDomainCallback
            , 0
            , 1
            , 1
            , hr
            , L"[MT] Error unmarshalling the ITaskLoginDomainCallback interface"
            );
        goto Cleanup;
    }

    m_pstream->Release();
    m_pstream = NULL;

    if ( ptldcb == NULL )
        goto Cleanup;

    Assert( m_bstrDomain != NULL );

    //
    //  Get the name of the currently logged in user.
    //

    cchName = 0;
    fRet = GetUserNameEx( NameSamCompatible, NULL, &cchName );
    Assert( ! fRet );
    dwErr = GetLastError();
    if ( dwErr != ERROR_MORE_DATA )
    {
        SendStatusReport(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_LoginDomain_BeginTask_Get_SAM_Compatible_Name
            , 0
            , 1
            , 1
            , dwErr
            , L"[MT] Error getting SAM compatible name"
            );
        hr = HRESULT_FROM_WIN32( TW32( dwErr ) );
        goto Cleanup;
    }

    bstrName = TraceSysAllocStringLen( NULL, cchName );
    if ( bstrName == NULL )
        goto OutOfMemory;
    cchName ++; // SysAllocStringLen alloc cchName + 1 characters.

    fRet = GetUserNameEx( NameSamCompatible, bstrName, &cchName );
    if ( ! fRet )
    {
        SendStatusReport(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_LoginDomain_BeginTask_Get_SAM_Compatible_Name_2
            , 0
            , 1
            , 1
            , dwErr
            , L"[MT] Error getting SAM compatible name (2)"
            );
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Cleanup;
    }

    //
    //  See if we can ask the domain for the current users name
    //

    dwErr = TW32( DsGetDcName(
                          NULL
                        , m_bstrDomain
                        , NULL
                        , NULL
                        , DS_DIRECTORY_SERVICE_PREFERRED
                        , &pdcInfo
                        ) );

    if ( dwErr != ERROR_SUCCESS )
    {
        BSTR bstrDescription = NULL;

        HrFormatStringIntoBSTR(
                  L"[MT] Error looking up a domain controller in the '%1!ws!' domain"
                , &bstrDescription
                , m_bstrDomain
                );
        SendStatusReport(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_LoginDomain_BeginTask_LookupAccountName
            , 0
            , 1
            , 1
            , dwErr
            , bstrDescription
            );
        TraceSysFreeString( bstrDescription );
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Cleanup;
    }

    cbSid = 0;
    cbDomain = 0;
    fRet = LookupAccountName( pdcInfo->DomainControllerName,
                              bstrName,
                              NULL,
                              &cbSid,
                              NULL,
                              &cbDomain,
                              &snu
                              );
    if ( fRet )
    {
        //  Success. Nothing more to do.
        hr = S_OK;
        goto Cleanup;
    }

    dwErr = GetLastError();

    if ( dwErr != ERROR_SUCCESS )
    {
        BSTR bstrDescription = NULL;

        HrFormatStringIntoBSTR(
                  L"[MT] Error looking up account name '%1!ws!' in the '%2!ws!' domain"
                , &bstrDescription
                , bstrName
                , m_bstrDomain
                );
        SendStatusReport(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_LoginDomain_BeginTask_LookupAccountName
            , 0
            , 1
            , 1
            , dwErr
            , bstrDescription
            );
        TraceSysFreeString( bstrDescription );
    }

    switch ( dwErr )
    {
        case ERROR_ACCESS_DENIED:
            hr = HRESULT_FROM_WIN32( dwErr );
            break;

        case ERROR_NONE_MAPPED:         // a SID from an untrusted domain can't be mapped.
        case ERROR_INSUFFICIENT_BUFFER: // this is the error we expect since we didn't give it any buffers.
            SendStatusReport(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_LoginDomain_BeginTask_LookupAccountName
                , 0
                , 1
                , 1
                , S_OK
                , L"[MT] Ignoring error"
                );
            hr = S_OK;
            break;

        default:
            TW32( dwErr );
            hr = HRESULT_FROM_WIN32( dwErr );
            break;
    }

Cleanup:

    TraceSysFreeString( bstrName );

    if ( ptldcb != NULL )
    {
        THR( ptldcb->ReceiveLoginResult( hr ) );

        ptldcb->Release();
    }

    if ( pdcInfo != NULL )
    {
        NetApiBufferFree( pdcInfo );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CTaskGatherInformation::BeginTask()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskLoginDomain::SetCallback(
//      ITaskLoginDomainCallback * punkIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskLoginDomain::SetCallback(
    ITaskLoginDomainCallback * punkIn
    )
{
    TraceFunc( "[ITaskLoginDomain]" );

    HRESULT hr = S_OK;

    if ( m_pstream != NULL )
    {
        ITaskLoginDomainCallback * ptldcb;

        hr = THR( CoUnmarshalInterface( m_pstream, TypeSafeParams( ITaskLoginDomainCallback, &ptldcb ) ) );
        m_pstream->Release();
        m_pstream = NULL;

        if ( SUCCEEDED( hr ) )
        {
            ptldcb->Release();
        }
    }

    if ( punkIn != NULL )
    {
        hr = THR( CoMarshalInterThreadInterfaceInStream( IID_ITaskLoginDomainCallback, punkIn, &m_pstream ) );
    }

    HRETURN( hr );

} //*** CTaskGatherInformation::SetCallback()


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskLoginDomain::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskLoginDomain::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CTaskGatherInformation::StopTask


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskLoginDomain::SetDomain(
//      LPCWSTR pcszDomainIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskLoginDomain::SetDomain(
    LPCWSTR pcszDomainIn
    )
{
    TraceFunc1( "[ITaskLoginDomain] pcszDomainIn = '%1!ws!'", pcszDomainIn );

    HRESULT hr = S_OK;

    BSTR    bstrNewDomain;

    if ( pcszDomainIn == NULL )
        goto InvalidArg;

    bstrNewDomain = TraceSysAllocString( pcszDomainIn );
    if ( bstrNewDomain == NULL )
        goto OutOfMemory;

    TraceMoveToMemoryList( bstrNewDomain, g_GlobalMemoryList );

    if ( m_bstrDomain != NULL )
    {
        TraceMoveFromMemoryList( m_bstrDomain, g_GlobalMemoryList );
        TraceSysFreeString( m_bstrDomain );
    }

    m_bstrDomain = bstrNewDomain;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CTaskGatherInformation::SetDomain()


//****************************************************************************
//
//  Private Functions
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskLoginDomain::SendStatusReport(
//        CLSID     clsidTaskMajorIn
//      , CLSID     clsidTaskMinorIn
//      , ULONG     ulMinIn
//      , ULONG     ulMaxIn
//      , ULONG     ulCurrentIn
//      , HRESULT   hrStatusIn
//      , LPCWSTR   pcwszDescriptionIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskLoginDomain::SendStatusReport(
      CLSID     clsidTaskMajorIn
    , CLSID     clsidTaskMinorIn
    , ULONG     ulMinIn
    , ULONG     ulMaxIn
    , ULONG     ulCurrentIn
    , HRESULT   hrStatusIn
    , LPCWSTR   pcwszDescriptionIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    IServiceProvider *          psp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    IConnectionPoint *          pcp   = NULL;
    FILETIME                    ft;

    if ( m_pcccb == NULL )
    {
        //
        //  Collect the manager we need to complete this task.
        //

        hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pcp = TraceInterface( L"CTaskLoginDomain!IConnectionPoint", IConnectionPoint, pcp, 1 );

        hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_pcccb = TraceInterface( L"CTaskLoginDomain!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );

        psp->Release();
        psp = NULL;
    }

    if ( m_bstrLocalNode == NULL )
    {
        // Ignore this error and just use a null node name
        THR( HrGetComputerName( ComputerNameDnsFullyQualified, &m_bstrLocalNode ) );
    } // if: no local node allocated yet

    GetSystemTimeAsFileTime( &ft );

    //
    //  Send the message!
    //

    hr = THR( m_pcccb->SendStatusReport(
                              m_bstrLocalNode
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , pcwszDescriptionIn
                            , &ft
                            , NULL
                            ) );

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }

    HRETURN( hr );

} //*** CTaskGatherInformation::SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CITrackerSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskpollingcallback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      TaskPollingCallback.h
//
//  Description:
//      CTaskPollingCallback implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskPollingCallback
class
CTaskPollingCallback:
    public ITaskPollingCallback
{
private:
    // IUnknown
    LONG                m_cRef;

    // IDoTask/ITaskPollingCallback
    bool                m_fStop;
    DWORD               m_dwServerGITCookie;

private: // Methods
    CTaskPollingCallback( );
    ~CTaskPollingCallback();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDoTask/ITaskPollingCallback
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetServerGITCookie )(  DWORD dwGITCookieIn );

}; // class CTaskPollingCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskpollingcallback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskPollingCallback.cpp
//
//  Description:
//      CTaskPollingCallback implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <ClusCfgPrivate.h>
#include "TaskPollingCallback.h"

DEFINE_THISCLASS("CTaskPollingCallback")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskPollingCallback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskPollingCallback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT                 hr = S_FALSE;
    CTaskPollingCallback *  pTaskPollingCallback = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pTaskPollingCallback = new CTaskPollingCallback;
    if ( pTaskPollingCallback == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

    TraceMoveToMemoryList( pTaskPollingCallback, g_GlobalMemoryList );

    hr = THR( pTaskPollingCallback->Init() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pTaskPollingCallback->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pTaskPollingCallback != NULL )
    {
        pTaskPollingCallback->Release();
    } // if:

    HRETURN( hr );

} //*** CTaskPollingCallback::S_HrCreateInstance

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskPollingCallback::CTaskPollingCallback( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskPollingCallback::CTaskPollingCallback( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_fStop == false );
    Assert( m_dwServerGITCookie == NULL );

    TraceFuncExit();

} //*** CTaskPollingCallback::CTaskPollingCallback

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::Init( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CTaskPollingCallback::Init

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskPollingCallback::~CTaskPollingCallback( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskPollingCallback::~CTaskPollingCallback( void )
{
    TraceFunc( "" );

    TraceMoveFromMemoryList( this, g_GlobalMemoryList );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CTaskPollingCallback::~CTaskPollingCallback


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskPollingCallback * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskPollingCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskPollingCallback, this, 0 );
        hr = S_OK;
    } // else if: ITaskPollingCallback
    else if ( IsEqualIID( riidIn, IID_IDoTask ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr = S_OK;
    } // else if: IDoTask

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} // QueryInterface

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CTaskPollingCallback::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskPollingCallback::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CTaskPollingCallback::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CTaskPollingCallback::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CTaskPollingCallback::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CTaskPollingCallback::Release


//****************************************************************************
//
//  ITaskPollingCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::BeginTask( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT                         hr = S_OK;
    BSTR                            bstrNodeName = NULL;
    BSTR                            bstrLastNodeName = NULL;
    BSTR                            bstrReference = NULL;
    BSTR                            bstrDescription = NULL;
    CLSID                           clsidTaskMajor;
    CLSID                           clsidTaskMinor;
    ULONG                           ulMin;
    ULONG                           ulMax;
    ULONG                           ulCurrent;
    HRESULT                         hrStatus;
    FILETIME                        ft;
    IGlobalInterfaceTable *         pgit = NULL;
    IClusCfgServer *                pccs = NULL;
    IClusCfgPollingCallback *       piccpc = NULL;
    IClusCfgPollingCallbackInfo *   piccpci = NULL;
    IServiceProvider *              psp = NULL;
    IConnectionPointContainer *     pcpc  = NULL;
    IConnectionPoint *              pcp   = NULL;
    IClusCfgCallback *              pcccb = NULL;

    //
    //  Collect the manager we need to complete this task.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager, NULL, CLSCTX_INPROC_SERVER, TypeSafeParams( IServiceProvider, &psp ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pcp = TraceInterface( L"CConfigurationConnection!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pcccb = TraceInterface( L"CConfigurationConnection!IClusCfgCallback", IClusCfgCallback, pcccb, 1 );

    psp->Release();
    psp = NULL;

    //
    //  Create the GIT.
    //

    hr = THR( CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IGlobalInterfaceTable,
                                reinterpret_cast< void ** >( &pgit )
                                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Get the ClusCfgServer interface from the GIT.
    //

    hr = THR( pgit->GetInterfaceFromGlobal( m_dwServerGITCookie, IID_IClusCfgServer, reinterpret_cast< void ** >( &pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Get the PollingCallback object from the server.
    //

    hr = THR( pccs->TypeSafeQI( IClusCfgPollingCallbackInfo, &piccpci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    hr = THR( piccpci->GetCallback( &piccpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if

    //
    //  Begin polling for SendStatusReports.
    //

    while ( !m_fStop )
    {
        if ( bstrNodeName != NULL )
        {
            TraceSysFreeString( bstrLastNodeName );
            bstrLastNodeName = NULL;

            //  Give up ownership
            bstrLastNodeName = bstrNodeName;
            bstrNodeName = NULL;
        } // if:

        TraceSysFreeString( bstrDescription );
        bstrDescription = NULL;

        TraceSysFreeString( bstrReference );
        bstrReference = NULL;

        hr = STHR( piccpc->GetStatusReport(
                                    &bstrNodeName,
                                    &clsidTaskMajor,
                                    &clsidTaskMinor,
                                    &ulMin,
                                    &ulMax,
                                    &ulCurrent,
                                    &hrStatus,
                                    &bstrDescription,
                                    &ft,
                                    &bstrReference
                                    ) );

        TraceMemoryAddBSTR( bstrNodeName );
        TraceMemoryAddBSTR( bstrDescription );
        TraceMemoryAddBSTR( bstrReference );

        if ( FAILED( hr ) )
        {
            HRESULT hr2;
            BSTR    bstrNotification = NULL;

            LogMsg( L"PollingCallback: GetStatusReport() failed.  hr = 0x%08x", hr );

            hr2 = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_POLLING_CONNECTION_FAILURE, &bstrNotification ) );

            hr2 = THR( pcccb->SendStatusReport(
                                      bstrLastNodeName
                                    , TASKID_Major_Establish_Connection
                                    , TASKID_Minor_Polling_Connection_Failure
                                    , 0
                                    , 1
                                    , 0
                                    , hr
                                    , bstrNotification
                                    , NULL
                                    , NULL
                                    ) );

            TraceSysFreeString( bstrNotification );

            switch ( hr )
            {
                case S_OK:
                case S_FALSE:
                    break;  // ignore

                case HRESULT_FROM_WIN32( RPC_E_DISCONNECTED ):
                    LogMsg( L"PollingCallback: GetStatusReport() failed.  hr = RPC_E_DISCONNECTED. Aborting polling.", hr );
                    goto Cleanup;

                case HRESULT_FROM_WIN32( RPC_S_SERVER_UNAVAILABLE ):
                    LogMsg( L"PollingCallback: GetStatusReport() failed.  hr = RPC_S_SERVER_UNAVAILABLE. Aborting polling.", hr );
                    goto Cleanup;

                case HRESULT_FROM_WIN32( RPC_S_CALL_FAILED ):
                    LogMsg( L"PollingCallback: GetStatusReport() failed.  hr = RPC_S_CALL_FAILED. Aborting polling.", hr );
                    goto Cleanup;

                default:
                    LogMsg( L"PollingCallback: GetStatusReport() failed.  hr = %#08x. Continuing to poll.", hr );
                    break;
            }

            if ( hr2 == E_ABORT )
            {
                LogMsg( L"PollingCallback: UI layer returned E_ABORT. Aborting polling." );
                break;
            }

        } // if:

        if ( hr == S_OK )
        {
            HRESULT hrTmp;

            hr = THR( pcccb->SendStatusReport(
                                            bstrNodeName,
                                            clsidTaskMajor,
                                            clsidTaskMinor,
                                            ulMin,
                                            ulMax,
                                            ulCurrent,
                                            hrStatus,
                                            bstrDescription,
                                            &ft,
                                            bstrReference
                                            ) );

            if ( hr == E_ABORT )
            {
                LogMsg( L"PollingCallback: UI layer returned E_ABORT. Aborting polling." );
            }

            hrTmp = hr;
            hr = THR( piccpc->SetHResult( hrTmp ) );
            if ( FAILED( hr ) )
            {
                LogMsg( L"PollingCallback: SetHResult() failed.  hr = 0x%08x", hr );
            } // if:

        } // if:
        else
        {
            Sleep( 1000 );

            //
            //  Check to see if we need to bail.
            //

            hr = THR( CServiceManager::S_HrGetManagerPointer( &psp ) );
            if ( FAILED( hr ) )
                break;

            psp->Release();
            psp = NULL;
        }

    } // while:

Cleanup:

    if ( psp != NULL )
    {
        psp->Release();
    } // if:

    if ( pgit != NULL )
    {
        pgit->Release();
    } // if:

    if ( pccs != NULL )
    {
        pccs->Release();
    } // if:

    if ( piccpc != NULL )
    {
        piccpc->Release();
    } // if:

    if ( piccpci != NULL )
    {
        piccpci->Release();
    } // if:

    if ( pcpc != NULL )
    {
        pcpc->Release();
    } // if:

    if ( pcp != NULL )
    {
        pcp->Release();
    } // if:

    if ( pcccb != NULL )
    {
        pcccb->Release();
    } // if:

    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrDescription );
    TraceSysFreeString( bstrReference );
    TraceSysFreeString( bstrLastNodeName );

    HRETURN( hr );

} //*** CTaskPollingCallback::BeginTask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::StopTask( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    m_fStop = true;

    HRETURN( hr );

} //*** CTaskPollingCallback::StopTask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CTaskPollingCallback::SetServerGITCookie(
//       DWORD dwGITCookieIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskPollingCallback::SetServerGITCookie(
     DWORD dwGITCookieIn
    )
{
    TraceFunc( "[ITaskPollingCallback]" );

    HRESULT hr = S_OK;

    m_dwServerGITCookie = dwGITCookieIn;

    HRETURN( hr );

} //*** CTaskPollingCallback::SetServerGITCookie
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskverifyipaddress.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskVerifyIPAddress.cpp
//
//  Description:
//      Object Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUL-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "TaskVerifyIPAddress.h"
#include <iphlpapi.h>

DEFINE_THISCLASS("CTaskVerifyIPAddress")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CTaskVerifyIPAddress::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskVerifyIPAddress::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( ppunkOut != NULL );

    CTaskVerifyIPAddress * pTaskVerifyIPAddress = new CTaskVerifyIPAddress;
    if ( pTaskVerifyIPAddress != NULL )
    {
        hr = THR( pTaskVerifyIPAddress->Init() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pTaskVerifyIPAddress->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pTaskVerifyIPAddress->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskVerifyIPAddress::CTaskVerifyIPAddress( void )
//
//////////////////////////////////////////////////////////////////////////////
CTaskVerifyIPAddress::CTaskVerifyIPAddress( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CTaskVerifyIPAddress()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    HRETURN( hr );

} // Init()

//////////////////////////////////////////////////////////////////////////////
//
//  CTaskVerifyIPAddress::~CTaskVerifyIPAddress()
//
//////////////////////////////////////////////////////////////////////////////
CTaskVerifyIPAddress::~CTaskVerifyIPAddress()
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CTaskVerifyIPAddress()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< ITaskVerifyIPAddress * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_ITaskVerifyIPAddress ) )
    {
        *ppv = TraceInterface( __THISCLASS__, ITaskVerifyIPAddress, this, 0 );
        hr   = S_OK;
    } // else if: ITaskVerifyIPAddress
    else if ( IsEqualIID( riid, IID_IDoTask ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IDoTask, this, 0 );
        hr   = S_OK;
    } // else if: IDoTask

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskVerifyIPAddress::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskVerifyIPAddress::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CTaskVerifyIPAddress::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CTaskVerifyIPAddress::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release()



//****************************************************************************
//
//  IDoTask / ITaskVerifyIPAddress
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::BeginTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::BeginTask( void )
{
    TraceFunc( "[IDoTask]" );

    ULONG   ulHopCountDummy;
    ULONG   ulRTTDummy;
    BOOL    fRet;

    HRESULT hr = S_OK;

    IServiceProvider *          psp  = NULL;
    IConnectionPointContainer * pcpc = NULL;
    IConnectionPoint *          pcp  = NULL;
    INotifyUI *                 pnui = NULL;
    IObjectManager *            pom  = NULL;

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IServiceProvider, &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_ObjectManager,
                               IObjectManager,
                               &pom
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->TypeSafeQS( CLSID_NotificationManager,
                               IConnectionPointContainer,
                               &pcpc
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI,
                                         &pcp
                                         ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pcp = TraceInterface( L"CTaskVerifyIPAddress!IConnectionPoint", IConnectionPoint, pcp, 1 );

    hr = THR( pcp->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pnui = TraceInterface( L"CTaskVerifyIPAddress!INotifyUI", INotifyUI, pnui, 1 );

    //   release promptly
    psp->Release();
    psp = NULL;

    fRet = GetRTTAndHopCount( m_dwIPAddress, &ulHopCountDummy, 20, &ulRTTDummy );
    if ( fRet )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    if ( psp != NULL )
    {
        psp->Release();
    }
    if ( pom != NULL )
    {
        //
        //  Update the cookie's status indicating the result of our task.
        //

        IUnknown * punk;
        HRESULT hr2;

        hr2 = THR( pom->GetObject( DFGUID_StandardInfo,
                                   m_cookie,
                                   &punk
                                   ) );
        if ( SUCCEEDED( hr2 ) )
        {
            IStandardInfo * psi;

            hr2 = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
            punk->Release();

            if ( SUCCEEDED( hr2 ) )
            {
                hr2 = THR( psi->SetStatus( hr ) );
                psi->Release();
            }
        }

        pom->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        pcp->Release();
    }
    if ( pnui != NULL )
    {
        //
        //  Signal the cookie to indicate that we are done.
        //

        THR( pnui->ObjectChanged( m_cookie ) );
        pnui->Release();
    }

    HRETURN( hr );

} // BeginTask()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::StopTask( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::StopTask( void )
{
    TraceFunc( "[IDoTask]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** StopTask

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::SetIPAddress(
//      DWORD dwIPAddressIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::SetIPAddress(
    DWORD dwIPAddressIn
    )
{
    TraceFunc( "[ITaskVerifyIPAddress]" );

    HRESULT hr = S_OK;

    m_dwIPAddress = dwIPAddressIn;

    HRETURN( hr );

} // SetIPAddress()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CTaskVerifyIPAddress::SetCookie(
//      OBJECTCOOKIE cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskVerifyIPAddress::SetCookie(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[ITaskVerifyIPAddress]" );

    HRESULT hr = S_OK;

    m_cookie = cookieIn;

    HRETURN( hr );

} // SetCookie()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\callback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Callback.h
//
//  Description:
//      CCallback implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CCallback
class
CCallback:
    public IClusCfgCallback
{
private:
    // IUnknown
    LONG                m_cRef;

private: // Methods
    CCallback( );
    ~CCallback();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID clsidTaskMajorIn,
                                   CLSID clsidTaskMinorIn,
                                   ULONG ulMinIn,
                                   ULONG ulMaxIn,
                                   ULONG ulCurrentIn,
                                   HRESULT hrStatusIn,
                                   BSTR bstrDescriptionIn
                                   );

}; // class CCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\taskverifyipaddress.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      TaskVerifyIPAddress.h
//
//  Description:
//      CTaskVerifyIPAddress implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUL-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CTaskVerifyIPAddress
class
CTaskVerifyIPAddress :
    public ITaskVerifyIPAddress
{
private:
    // IUnknown
    LONG                m_cRef;

    //  ITaskVerifyIPAddress
    OBJECTCOOKIE        m_cookie;       //  Cookie to signal when done.
    DWORD               m_dwIPAddress;  //  IP address to verify

    CTaskVerifyIPAddress( void );
    ~CTaskVerifyIPAddress( void );
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IDoTask / ITaskVerifyIPAddress
    STDMETHOD( BeginTask )( void );
    STDMETHOD( StopTask )( void );
    STDMETHOD( SetIPAddress )( DWORD dwIPAddressIn );
    STDMETHOD( SetCookie )( OBJECTCOOKIE cookieIn );

}; // class CTaskVerifyIPAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\callback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Callback.cpp
//
//  Description:
//      CCallback implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 02-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "Callback.h"

DEFINE_THISCLASS("CCallback")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCallback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCallback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CCallback * pc = new CCallback;
    if ( pc != NULL )
    {
        hr = THR( pc->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pc->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pc->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CCallback::CCallback( void )
//
//////////////////////////////////////////////////////////////////////////////
CCallback::CCallback( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CCallback( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCallback::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCallback::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    HRETURN( hr );
} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CCallback::~CCallback( )
//
//////////////////////////////////////////////////////////////////////////////
CCallback::~CCallback( )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CCallback( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCallback::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCallback::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgCallback * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCallback::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCallback::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCallback::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCallback::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )



//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCallback::SendStatusReport(
//      BSTR bstrNodeNameIn,
//      CLSID clsidTaskMajorIn,
//      CLSID clsidTaskMinorIn,
//      ULONG ulMinIn,
//      ULONG ulMaxIn,
//      ULONG ulCurrentIn,
//      HRESULT hrStatusIn,
//      BSTR bstrDescriptionIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCallback::SendStatusReport(
    BSTR bstrNodeNameIn,
    CLSID clsidTaskMajorIn,
    CLSID clsidTaskMinorIn,
    ULONG ulMinIn,
    ULONG ulMaxIn,
    ULONG ulCurrentIn,
    HRESULT hrStatusIn,
    BSTR bstrDescriptionIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr = S_OK;

    DebugMsg( "clsidTaskMajorIn: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
              clsidTaskMajorIn.Data1, clsidTaskMajorIn.Data2, clsidTaskMajorIn.Data3,
              clsidTaskMajorIn.Data4[ 0 ], clsidTaskMajorIn.Data4[ 1 ], clsidTaskMajorIn.Data4[ 2 ], clsidTaskMajorIn.Data4[ 3 ],
              clsidTaskMajorIn.Data4[ 4 ], clsidTaskMajorIn.Data4[ 5 ], clsidTaskMajorIn.Data4[ 6 ], clsidTaskMajorIn.Data4[ 7 ]
              );

    DebugMsg( "clsidTaskMinorIn: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
              clsidTaskMinorIn.Data1, clsidTaskMinorIn.Data2, clsidTaskMinorIn.Data3,
              clsidTaskMinorIn.Data4[ 0 ], clsidTaskMinorIn.Data4[ 1 ], clsidTaskMinorIn.Data4[ 2 ], clsidTaskMinorIn.Data4[ 3 ],
              clsidTaskMinorIn.Data4[ 4 ], clsidTaskMinorIn.Data4[ 5 ], clsidTaskMinorIn.Data4[ 6 ], clsidTaskMinorIn.Data4[ 7 ]
              );

    DebugMsg( "Progress:\tmin: %u\tcurrent: %u\tmax: %u",
              ulMinIn,
              ulCurrentIn,
              ulMaxIn
              );

    DebugMsg( "Status: hrStatusIn = %#x\t%ws", hrStatusIn, ( bstrDescriptionIn == NULL ? L"" : bstrDescriptionIn ) );

    Assert( ulCurrentIn >= ulMinIn && ulMaxIn >= ulCurrentIn );

    HRETURN( hr );

} // SendStatusReport( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
#define USES_SYSALLOCSTRING
#endif // DBG==1

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>

#include <common.h>
#include <debug.h>
#include <log.h>
#include <citracker.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\uinotification.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      UINotification.cpp
//
//  Description:
//      UINotification implementation.
//
//  Documentation:
//      Yes.
//
//  Notes:
//      The object implements a lightweight marshalling of data from the
//      free-threaded lower layers to the single-threaded, apartment model
//      UI layer.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "UINotification.h"

DEFINE_THISCLASS("CUINotification")

extern BOOL g_fWait;
extern IServiceProvider * g_psp;

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// HRESULT
// CUINotification::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CUINotification::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    CUINotification * puin = new CUINotification( );
    if ( puin != NULL )
    {
        hr = THR( puin->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( puin->TypeSafeQI( IUnknown, ppunkOut ) );
        } // if: success

        puin->Release( );

    } // if: got object
    else
    {
        hr = E_OUTOFMEMORY;

    } // else: out of memory

    HRETURN( hr );

} // CUINotification_CreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
//////////////////////////////////////////////////////////////////////////////
CUINotification::CUINotification( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CUINotification( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CUINotification::Init(
//      IConsole2 * pConsole
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUINotification::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown
    Assert( m_cRef == 0 );
    AddRef( );

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////
CUINotification::~CUINotification( )
{
    TraceFunc( "" );

    HRESULT hr;

    IConnectionPoint * pcp = NULL;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CUINotification( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CUINotification::[IUnknown] QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUINotification::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IUnknown * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_INotifyUI ) )
    {
        *ppv = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
        hr   = S_OK;
    } // else if: INotifyUI

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CUINotification::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CUINotification::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CUINotification::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CUINotification::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


// ************************************************************************
//
// INotifyUI
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CUINotification::ObjectChanged(
//      DWORD cookieIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUINotification::ObjectChanged(
    LPVOID cookieIn
    )
{
    TraceFunc1( "[INotifyUI] cookieIn = 0x%08x", cookieIn );

    HRESULT hr = S_OK;

    DebugMsg( "UINOTIFICATION: cookie %#x has changed.", cookieIn );

    if ( m_cookie == cookieIn )
    {
        //
        //  Done waiting...
        //
        g_fWait = FALSE;
    }

    HRETURN( hr );

} // ObjectChanged( )



//****************************************************************************
//
//  Semi-Public
//
//****************************************************************************

HRESULT
CUINotification::HrSetCompletionCookie(
    OBJECTCOOKIE    cookieIn
    )
{
    TraceFunc1( "cookieIn = %p", cookieIn );

    m_cookie = cookieIn;

    HRETURN( S_OK );

} // HrSetCompletionCookie( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\createservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CreateServices.h
//
//  Description:
//      CreateServices implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPrivatePostCfgResource.h"
#include "CreateServices.h"

DEFINE_THISCLASS("CCreateServices")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCreateServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    Assert( ppunkOut != NULL );

    CCreateServices * pdummy = new CCreateServices;
    if ( pdummy != NULL )
    {
        hr = THR( pdummy->HrInit( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pdummy->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pdummy->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CCreateServices::CCreateServices( void )
//
//////////////////////////////////////////////////////////////////////////////
CCreateServices::CCreateServices( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CCreateServices( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCreateServices::HrInit( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateServices::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // Resource
    Assert( m_presentry == NULL );

    HRETURN( hr );

} // HrInit( )

//////////////////////////////////////////////////////////////////////////////
//
//  CCreateServices::~CCreateServices( )
//
//////////////////////////////////////////////////////////////////////////////
CCreateServices::~CCreateServices( )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CCreateServices( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgResourceCreate * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgResourceCreate ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgResourceCreate, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgResourceCreate
    else if ( IsEqualIID( riid, IID_IPrivatePostCfgResource ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IPrivatePostCfgResource, this, 0 );
        hr   = S_OK;
    } // else if: IPrivatePostCfgResource

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCreateServices::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCreateServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef ++;  // apartment model

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CCreateServices::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCreateServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef --;  // apartment model

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


//****************************************************************************
//
//  IClusCfgResourceCreate
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyBinary(
//      LPCWSTR pcszNameIn,
//      const DWORD cbSizeIn,
//      const BYTE * pbyteIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyBinary(
    LPCWSTR pcszNameIn,
    const DWORD cbSizeIn,
    const BYTE * pbyteIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;
    DWORD   cbSize;
    DWORD   cbName;
    DWORD   cbProp;
    DWORD   cbValue;
    LPBYTE  pbBuf;

    CLUSPROP_LIST   * plist;
    CLUSPROP_BINARY * pbin;
    CLUSPROP_VALUE  * pvalue;

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL
      || pbyteIn == NULL
      || cbSizeIn == 0
       )
    {
        goto InvalidArg;
    }

    cbName = ( wcslen( pcszNameIn ) + 1 ) * sizeof(WCHAR);

    cbProp = sizeof(CLUSPROP_PROPERTY_NAME)     //  name property
           + ALIGN_CLUSPROP( cbName )           //  name
           ;

    cbValue = sizeof(CLUSPROP_BINARY)           //  binary property
            + ALIGN_CLUSPROP( cbSizeIn )        //  binary data
            ;

    cbSize = sizeof(DWORD)                      //  count
           + cbProp                             //  name property and name
           + cbValue                            //  data property and data
           + sizeof(CLUSPROP_VALUE)             //  endmark
           ;

    pbBuf = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbSize );
    if ( pbBuf == NULL )
        goto OutOfMemory;

    plist                         = (CLUSPROP_LIST *) pbBuf;
    plist->nPropertyCount         = 1;
    plist->PropertyName.cbLength  = cbName;
    plist->PropertyName.Syntax.dw = CLUSPROP_SYNTAX_NAME;
    CopyMemory( plist->PropertyName.sz, pcszNameIn, cbName );

    pbin            = (CLUSPROP_BINARY *)( pbBuf + cbProp + sizeof(DWORD) );
    pbin->cbLength  = cbSizeIn;
    pbin->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_BINARY;
    CopyMemory( pbin->rgb, pbyteIn, cbSizeIn );

    pvalue            = (CLUSPROP_VALUE *)( pbBuf + cbProp + cbValue );
    pvalue->Syntax.dw = CLUSPROP_SYNTAX_ENDMARK;

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                                        (LPVOID) pbBuf,
                                                        cbSize
                                                        ) );

    TraceFree( pbBuf );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetPropertyBinary( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyDWORD(
//      LPCWSTR     pcszNameIn,
//      const DWORD dwDWORDIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyDWORD(
    LPCWSTR     pcszNameIn,
    const DWORD dwDWORDIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;
    DWORD   cbSize;
    DWORD   cbName;
    DWORD   cbProp;
    DWORD   cbValue;
    LPBYTE  pbBuf;

    CLUSPROP_LIST  * plist;
    CLUSPROP_DWORD * pdword;
    CLUSPROP_VALUE * pvalue;

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL )
        goto InvalidArg;

    cbName = ( wcslen( pcszNameIn ) + 1 ) * sizeof(WCHAR);

    cbProp = sizeof(CLUSPROP_PROPERTY_NAME)     //  name property
           + ALIGN_CLUSPROP( cbName )           //  name
           ;

    cbValue = sizeof(CLUSPROP_DWORD)            //  dword property
            + ALIGN_CLUSPROP( sizeof(DWORD) )   //  dword data
            ;

    cbSize = sizeof(DWORD)                      //  count
           + cbProp                             //  name property and name
           + cbValue                            //  data property and data
           + sizeof(CLUSPROP_VALUE)             //  endmark
           ;

    pbBuf = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbSize );
    if ( pbBuf == NULL )
        goto OutOfMemory;

    plist                         = (CLUSPROP_LIST *) pbBuf;
    plist->nPropertyCount         = 1;
    plist->PropertyName.cbLength  = cbName;
    plist->PropertyName.Syntax.dw = CLUSPROP_SYNTAX_NAME;
    CopyMemory( plist->PropertyName.sz, pcszNameIn, cbName );

    pdword            = (CLUSPROP_DWORD *)( pbBuf + cbProp + sizeof(DWORD) );
    pdword->cbLength  = sizeof(DWORD);
    pdword->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_DWORD;
    pdword->dw        = dwDWORDIn;

    pvalue            = (CLUSPROP_VALUE *)( pbBuf + cbProp + cbValue );
    pvalue->Syntax.dw = CLUSPROP_SYNTAX_ENDMARK;

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                                        (LPVOID) pbBuf,
                                                        cbSize
                                                        ) );

    TraceFree( pbBuf );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetPropertyDWORD( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyString(
//      LPCWSTR     pcszNameIn,
//      LPCWSTR     pcszStringIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyString(
    LPCWSTR pcszNameIn,
    LPCWSTR pcszStringIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;
    DWORD   cbSize;
    DWORD   cbName;
    DWORD   cbProp;
    DWORD   cbValue;
    DWORD   cbValueSz;
    LPBYTE  pbBuf;

    CLUSPROP_LIST  * plist;
    CLUSPROP_SZ *    pSz;
    CLUSPROP_VALUE * pvalue;

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL
      || pcszStringIn == NULL
       )
    {
        goto InvalidArg;
    }

    cbName    = ( wcslen( pcszNameIn ) + 1 ) * sizeof(WCHAR);
    cbValueSz = ( wcslen( pcszStringIn ) + 1 ) * sizeof(WCHAR);

    cbProp = sizeof(CLUSPROP_PROPERTY_NAME)     //  name property
           + ALIGN_CLUSPROP( cbName )           //  name
           ;

    cbValue = sizeof(CLUSPROP_SZ)               //  string property
            + ALIGN_CLUSPROP( cbValueSz )       //  string data
            ;

    cbSize = sizeof(DWORD)                      //  count
           + cbProp                             //  name property and name
           + cbValue                            //  data property and data
           + sizeof(CLUSPROP_VALUE)             //  endmark
           ;

    pbBuf = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbSize );
    if ( pbBuf == NULL )
        goto OutOfMemory;

    plist                         = (CLUSPROP_LIST *) pbBuf;
    plist->nPropertyCount         = 1;
    plist->PropertyName.cbLength  = cbName;
    plist->PropertyName.Syntax.dw = CLUSPROP_SYNTAX_NAME;
    CopyMemory( plist->PropertyName.sz, pcszNameIn, cbName );

    pSz            = (CLUSPROP_SZ *)( pbBuf + cbProp + sizeof(DWORD) );
    pSz->cbLength  = cbValueSz;
    pSz->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_SZ;
    CopyMemory( pSz->sz, pcszStringIn, cbValueSz );

    pvalue            = (CLUSPROP_VALUE *)( pbBuf + cbProp + cbValue );
    pvalue->Syntax.dw = CLUSPROP_SYNTAX_ENDMARK;

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                                        (LPVOID) pbBuf,
                                                        cbSize
                                                        ) );

    TraceFree( pbBuf );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetPropertyString( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyExpandString(
//      LPCWSTR pcszNameIn,
//      LPCWSTR pcszStringIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyExpandString(
    LPCWSTR pcszNameIn,
    LPCWSTR pcszStringIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;
    DWORD   cbSize;
    DWORD   cbName;
    DWORD   cbProp;
    DWORD   cbValue;
    DWORD   cbValueSz;
    LPBYTE  pbBuf;

    CLUSPROP_LIST  * plist;
    CLUSPROP_SZ *    pSz;
    CLUSPROP_VALUE * pvalue;

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL
      || pcszStringIn == NULL
       )
    {
        goto InvalidArg;
    }

    cbName    = ( wcslen( pcszNameIn ) + 1 ) * sizeof(WCHAR);
    cbValueSz = ( wcslen( pcszStringIn ) + 1 ) * sizeof(WCHAR);

    cbProp = sizeof(CLUSPROP_PROPERTY_NAME)     //  name property
           + ALIGN_CLUSPROP( cbName )           //  name
           ;

    cbValue = sizeof(CLUSPROP_SZ)               //  string property
            + ALIGN_CLUSPROP( cbValueSz )       //  string data
            ;

    cbSize = sizeof(DWORD)                      //  count
           + cbProp                             //  name property and name
           + cbValue                            //  data property and data
           + sizeof(CLUSPROP_VALUE)             //  endmark
           ;

    pbBuf = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbSize );
    if ( pbBuf == NULL )
        goto OutOfMemory;

    plist                         = (CLUSPROP_LIST *) pbBuf;
    plist->nPropertyCount         = 1;
    plist->PropertyName.cbLength  = cbName;
    plist->PropertyName.Syntax.dw = CLUSPROP_SYNTAX_NAME;
    CopyMemory( plist->PropertyName.sz, pcszNameIn, cbName );

    pSz            = (CLUSPROP_SZ *)( pbBuf + cbProp + sizeof(DWORD) );
    pSz->cbLength  = cbValueSz;
    pSz->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPAND_SZ;
    CopyMemory( pSz->sz, pcszStringIn, cbValueSz );

    pvalue            = (CLUSPROP_VALUE *)( pbBuf + cbProp + cbValue );
    pvalue->Syntax.dw = CLUSPROP_SYNTAX_ENDMARK;

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                                        (LPVOID) pbBuf,
                                                        cbSize
                                                        ) );

    TraceFree( pbBuf );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetPropertyExpandString( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyMultiString(
//      LPCWSTR     pcszNameIn,
//      const DWORD cbSizeIn,
//      LPCWSTR     pcszStringIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyMultiString(
    LPCWSTR     pcszNameIn,
    const DWORD cbSizeIn,
    LPCWSTR     pcszStringIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;
    DWORD   cbSize;
    DWORD   cbName;
    DWORD   cbProp;
    DWORD   cbValue;
    LPBYTE  pbBuf;

    CLUSPROP_LIST  * plist;
    CLUSPROP_SZ *    pSz;
    CLUSPROP_VALUE * pvalue;

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL
      || pcszStringIn == NULL
       )
    {
        goto InvalidArg;
    }

    cbName    = ( wcslen( pcszNameIn ) + 1 ) * sizeof(WCHAR);

    cbProp = sizeof(CLUSPROP_PROPERTY_NAME)     //  name property
           + ALIGN_CLUSPROP( cbName )           //  name
           ;

    cbValue = sizeof(CLUSPROP_SZ)               //  string property
            + ALIGN_CLUSPROP( cbSizeIn )        //  string data
            ;

    cbSize = sizeof(DWORD)                      //  count
           + cbProp                             //  name property and name
           + cbValue                            //  data property and data
           + sizeof(CLUSPROP_VALUE)             //  endmark
           ;

    pbBuf = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbSize );
    if ( pbBuf == NULL )
        goto OutOfMemory;

    plist                         = (CLUSPROP_LIST *) pbBuf;
    plist->nPropertyCount         = 1;
    plist->PropertyName.cbLength  = cbName;
    plist->PropertyName.Syntax.dw = CLUSPROP_SYNTAX_NAME;
    CopyMemory( plist->PropertyName.sz, pcszNameIn, cbName );

    pSz            = (CLUSPROP_SZ *)( pbBuf + cbProp + sizeof(DWORD) );
    pSz->cbLength  = cbSizeIn;
    pSz->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_MULTI_SZ;
    CopyMemory( pSz->sz, pcszStringIn, cbSizeIn );

    pvalue            = (CLUSPROP_VALUE *)( pbBuf + cbProp + cbValue );
    pvalue->Syntax.dw = CLUSPROP_SYNTAX_ENDMARK;

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                                        (LPVOID) pbBuf,
                                                        cbSize
                                                        ) );

    TraceFree( pbBuf );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetPropertyMultiString( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyUnsignedLargeInt(
//      LPCWSTR pcszNameIn,
//      const ULARGE_INTEGER ulIntIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyUnsignedLargeInt(
    LPCWSTR pcszNameIn,
    const ULARGE_INTEGER ulIntIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;
    DWORD   cbSize;
    DWORD   cbName;
    DWORD   cbProp;
    DWORD   cbValue;
    LPBYTE  pbBuf;

    CLUSPROP_LIST  *          plist;
    CLUSPROP_ULARGE_INTEGER * pulint;
    CLUSPROP_VALUE *          pvalue;

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL )
        goto InvalidArg;

    cbName    = ( wcslen( pcszNameIn ) + 1 ) * sizeof(WCHAR);

    cbProp = sizeof(CLUSPROP_PROPERTY_NAME)     //  name property
           + ALIGN_CLUSPROP( cbName )           //  name
           ;

    cbValue = sizeof(CLUSPROP_ULARGE_INTEGER)           //  string property
            + ALIGN_CLUSPROP(sizeof(ULARGE_INTEGER))    //  string data
            ;

    cbSize = sizeof(DWORD)                      //  count
           + cbProp                             //  name property and name
           + cbValue                            //  data property and data
           + sizeof(CLUSPROP_VALUE)             //  endmark
           ;

    pbBuf = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbSize );
    if ( pbBuf == NULL )
        goto OutOfMemory;

    plist                         = (CLUSPROP_LIST *) pbBuf;
    plist->nPropertyCount         = 1;
    plist->PropertyName.cbLength  = cbName;
    plist->PropertyName.Syntax.dw = CLUSPROP_SYNTAX_NAME;
    CopyMemory( plist->PropertyName.sz, pcszNameIn, cbName );

    pulint            = (CLUSPROP_ULARGE_INTEGER *)( pbBuf + cbProp + sizeof(DWORD) );
    pulint->cbLength  = sizeof(ULARGE_INTEGER);
    pulint->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_LARGE_INTEGER;
    pulint->li        = ulIntIn;

    pvalue            = (CLUSPROP_VALUE *)( pbBuf + cbProp + cbValue );
    pvalue->Syntax.dw = CLUSPROP_SYNTAX_ENDMARK;

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                                        (LPVOID) pbBuf,
                                                        cbSize
                                                        ) );

    TraceFree( pbBuf );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetPropertyUnsignedLargeInt( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyLong(
//      LPCWSTR pcszNameIn,
//      const LONG lLongIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyLong(
    LPCWSTR pcszNameIn,
    const LONG lLongIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;
    DWORD   cbSize;
    DWORD   cbName;
    DWORD   cbProp;
    DWORD   cbValue;
    LPBYTE  pbBuf;

    CLUSPROP_LIST  * plist;
    CLUSPROP_DWORD * pdword;
    CLUSPROP_VALUE * pvalue;

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL )
        goto InvalidArg;

    cbName = ( wcslen( pcszNameIn ) + 1 ) * sizeof(WCHAR);

    cbProp = sizeof(CLUSPROP_PROPERTY_NAME)     //  name property
           + ALIGN_CLUSPROP( cbName )           //  name
           ;

    cbValue = sizeof(CLUSPROP_DWORD)            //  dword property
            + ALIGN_CLUSPROP( sizeof(DWORD) )   //  dword data
            ;

    cbSize = sizeof(DWORD)                      //  count
           + cbProp                             //  name property and name
           + cbValue                            //  data property and data
           + sizeof(CLUSPROP_VALUE)             //  endmark
           ;

    pbBuf = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbSize );
    if ( pbBuf == NULL )
        goto OutOfMemory;

    plist                         = (CLUSPROP_LIST *) pbBuf;
    plist->nPropertyCount         = 1;
    plist->PropertyName.cbLength  = cbName;
    plist->PropertyName.Syntax.dw = CLUSPROP_SYNTAX_NAME;
    CopyMemory( plist->PropertyName.sz, pcszNameIn, cbName );

    pdword            = (CLUSPROP_DWORD *)( pbBuf + cbProp + sizeof(DWORD) );
    pdword->cbLength  = sizeof(DWORD);
    pdword->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_LONG;
    pdword->dw        = lLongIn;

    pvalue            = (CLUSPROP_VALUE *)( pbBuf + cbProp + cbValue );
    pvalue->Syntax.dw = CLUSPROP_SYNTAX_ENDMARK;

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                                        (LPVOID) pbBuf,
                                                        cbSize
                                                        ) );

    TraceFree( pbBuf );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetPropertyLong( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertySecurityDescriptor(
//      LPCWSTR pcszNameIn,
//      const SECURITY_DESCRIPTOR * pcsdIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertySecurityDescriptor(
    LPCWSTR pcszNameIn,
    const SECURITY_DESCRIPTOR * pcsdIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // SetPropertySecurityDescriptor( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetPropertyLargeInt(
//      LPCWSTR pcszNameIn,
//      const LARGE_INTEGER lIntIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetPropertyLargeInt(
    LPCWSTR pcszNameIn,
    const LARGE_INTEGER lIntIn
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;
    DWORD   cbSize;
    DWORD   cbName;
    DWORD   cbProp;
    DWORD   cbValue;
    LPBYTE  pbBuf;

    CLUSPROP_LIST  *          plist;
    CLUSPROP_ULARGE_INTEGER * pulint;
    CLUSPROP_VALUE *          pvalue;

    //
    //  Parameter validation
    //
    if ( pcszNameIn == NULL )
        goto InvalidArg;

    cbName    = ( wcslen( pcszNameIn ) + 1 ) * sizeof(WCHAR);

    cbProp = sizeof(CLUSPROP_PROPERTY_NAME)     //  name property
           + ALIGN_CLUSPROP( cbName )           //  name
           ;

    cbValue = sizeof(CLUSPROP_ULARGE_INTEGER)           //  string property
            + ALIGN_CLUSPROP(sizeof(LARGE_INTEGER))     //  string data
            ;

    cbSize = sizeof(DWORD)                      //  count
           + cbProp                             //  name property and name
           + cbValue                            //  data property and data
           + sizeof(CLUSPROP_VALUE)             //  endmark
           ;

    pbBuf = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbSize );
    if ( pbBuf == NULL )
        goto OutOfMemory;

    plist                         = (CLUSPROP_LIST *) pbBuf;
    plist->nPropertyCount         = 1;
    plist->PropertyName.cbLength  = cbName;
    plist->PropertyName.Syntax.dw = CLUSPROP_SYNTAX_NAME;
    CopyMemory( plist->PropertyName.sz, pcszNameIn, cbName );

    pulint            = (CLUSPROP_ULARGE_INTEGER *)( pbBuf + cbProp + sizeof(DWORD) );
    pulint->cbLength  = sizeof(LARGE_INTEGER);
    pulint->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_LARGE_INTEGER;
    CopyMemory( &pulint->li, &lIntIn, sizeof(LARGE_INTEGER) );

    pvalue            = (CLUSPROP_VALUE *)( pbBuf + cbProp + cbValue );
    pvalue->Syntax.dw = CLUSPROP_SYNTAX_ENDMARK;

    hr = THR( m_presentry->StoreClusterResourceControl( CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                                        (LPVOID) pbBuf,
                                                        cbSize
                                                        ) );

    TraceFree( pbBuf );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // SetPropertyLargeInt( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SendResourceControl(
//      DWORD   dwControlCode,
//      LPVOID  lpInBuffer,
//      DWORD   cbInBufferSize
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SendResourceControl(
    DWORD   dwControlCode,
    LPVOID  lpInBuffer,
    DWORD   cbInBufferSize
    )
{
    TraceFunc( "[IClusCfgResourceCreate]" );

    HRESULT hr;

    hr = THR( m_presentry->StoreClusterResourceControl( dwControlCode,
                                                        lpInBuffer,
                                                        cbInBufferSize
                                                        ) );

    HRETURN( hr );

} // SendResourceControl( )


//****************************************************************************
//
//  IPrivatePostCfgResource
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CCreateServices::SetEntry(
//      CResourceEntry * presentryIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCreateServices::SetEntry(
    CResourceEntry * presentryIn
    )
{
    TraceFunc( "[IPrivatePostCfgResource]" );

    HRESULT hr = S_OK;

    Assert( presentryIn != NULL );

    m_presentry = presentryIn;

    HRETURN( hr );

} // SetEntry( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\uinotification.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      UINotification.h
//
//  Description:
//      UINotification implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 26-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CUINotification
class
CUINotification:
    public INotifyUI
{
private: // Data
    // IUnknown
    LONG                m_cRef;

    // INotifyUI
    DWORD               m_dwCookie;

    // Other
    OBJECTCOOKIE        m_cookie;

private: // Methods
    CUINotification( );
    ~CUINotification();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    HRESULT
        HrSetCompletionCookie( OBJECTCOOKIE cookieIn );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // INotifyUI
    STDMETHOD( ObjectChanged )( LPVOID cookieIn );

}; // class CUINotification
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\dummy.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Dummy.cpp
//
//  Description:
//      Object Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "Dummy.h"

DEFINE_THISCLASS("CDummy")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CDummy::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CDummy::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    CDummy * pdummy = new CDummy;
    if ( pdummy != NULL )
    {
        hr = THR( pdummy->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pdummy->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pdummy->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CDummy::CDummy( void )
//
//////////////////////////////////////////////////////////////////////////////
CDummy::CDummy( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CDummy( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CDummy::Init( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CDummy::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    HRETURN( hr );
} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CDummy::~CDummy( )
//
//////////////////////////////////////////////////////////////////////////////
CDummy::~CDummy( )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CDummy( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CDummy::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CDummy::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IDummy * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IDummy ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IDummy, this, 0 );
        hr   = S_OK;
    } // else if: IDummy

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CDummy::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CDummy::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CDummy::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CDummy::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\middletier\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>
#include "UINotification.h"
#include "Callback.h"
#include <winsock2.h>

// {F4A50885-A4B9-4c4d-B67C-9E4DD94A315E}
DEFINE_GUID( CLSID_TaskType,
0xf4a50885, 0xa4b9, 0x4c4d, 0xb6, 0x7c, 0x9e, 0x4d, 0xd9, 0x4a, 0x31, 0x5e);


//
//  KB: Turn this on to run all tests. Some of these might return errors, but none
//      of them should cause the program to crash.
//
//#define TURN_ON_ALL_TESTS

//
//  KB: Turn this on to run a regression pass.
//
#define REGRESSION_PASS


DEFINE_MODULE( "MIDDLETIERTEST" )

//
//  Declarations
//
typedef HRESULT (* PDLLREGISTERSERVER)( void );

//
//  Globals
//
HINSTANCE           g_hInstance = NULL;
LONG                g_cObjects  = 0;
IServiceProvider *  g_psp       = NULL;

BOOL                g_fWait     = FALSE;    // global synchronization

OBJECTCOOKIE        g_cookieCluster = NULL;


//
//  Register the DLL
//
HRESULT
HrRegisterTheDll( void )
{
    TraceFunc( "" );

    HRESULT hr;

    PDLLREGISTERSERVER  pDllRegisterServer;

    HMODULE hLib    = NULL;

    //
    //  Make sure the DLL is properly registered.
    //

    hLib = LoadLibrary( L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll" );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer = reinterpret_cast< PDLLREGISTERSERVER >( GetProcAddress( hLib, "DllRegisterServer" ) );
    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
    goto Cleanup;
}

//
//  This tests the Object Manager code path to retrieve information
//  from a soon-to-be or existing cluster node.
//
HRESULT
HrTestAddingNode(
    BSTR    bstrNodeNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   dwHigh;
    DWORD   dwLow;

    OBJECTCOOKIE cookie;

    SDriveLetterMapping dlmDriveLetterUsage;

    BSTR    bstrName = NULL;

    IUnknown *              punk    = NULL;
    IUnknown *              punk2   = NULL;
    IObjectManager *        pom     = NULL;
    IClusCfgNodeInfo *      pccni   = NULL;
    IClusCfgNodeInfo *      pccni2  = NULL;
    IClusCfgClusterInfo *   pccci   = NULL;

    // Get OS Version stuff
    DWORD   dwMajorVersionOut;
    DWORD   dwMinorVersionOut;
    WORD    wSuiteMaskOut;
    BYTE    bProductTypeOut;
    BSTR    bstrCSDVersionOut;

    //
    //  Contact the Object Manager
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Try to find my test machine.
    //

    hr = E_PENDING;
    while ( hr == E_PENDING )
    {
        DebugMsg( "Trying to FindObject( ... %s ... )", bstrNodeNameIn );

        hr = pom->FindObject( CLSID_NodeType,
                              g_cookieCluster,
                              bstrNodeNameIn,
                              DFGUID_NodeInformation,
                              &cookie,
                              &punk
                              );
        if ( hr == E_PENDING )
        {
            Assert( punk == NULL );
            Sleep( 1000 );  // 1 Second
            continue;
        }

        THR( hr );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  Interrogate the information retrieved.
    //

    hr = THR( pccni->GetName( &bstrName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "bstrName = %s", bstrName );

#if defined(TURN_ON_ALL_TESTS)
    hr = THR( pccni->SetName( L"gpease-wolf1.NTDEV.MICROSOFT.COM" ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Successfully called SetName( )." );
#endif

    hr = STHR( pccni->IsMemberOfCluster( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "IsMemberOfCluster == %s", BOOLTOSTRING( hr == S_OK ) );

    if ( hr == S_OK )
    {
        hr = THR( pccni->GetClusterConfigInfo( &pccci ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        DebugMsg( "Succesfully called GetClusterConfigInfo( )" );
    }

    hr = THR( pccni->GetOSVersion( &dwMajorVersionOut,
                                   &dwMinorVersionOut,
                                   &wSuiteMaskOut,
                                   &bProductTypeOut,
                                   &bstrCSDVersionOut
                                   ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Successfully called GetOSVersion( )" );

    hr = THR( pccni->GetClusterVersion( &dwHigh, &dwLow ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Version: dwHigh = %#x, dwLow = %#x", dwHigh, dwLow );

    hr = THR( pccni->GetDriveLetterMappings( &dlmDriveLetterUsage ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  TODO:   gpease  08-MAR-2000
    //          Make this dump the table.
    //
    DebugMsg( "Succesfully called GetDriveLetterMappings( )" );

    //
    //  Try getting the same object.
    //

    hr = THR( pom->GetObject( DFGUID_NodeInformation,
                              cookie,
                              &punk
                              ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, &pccni2 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    DebugMsg( "GetObject succeeded." );

    //
    //  They should be the same object.
    //

    hr = THR( pccni->TypeSafeQI( IUnknown, &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccni2->TypeSafeQI( IUnknown, &punk2 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    AssertMsg( punk == punk2, "These should be the same!" );

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( punk2 != NULL )
    {
        punk2->Release( );
    }
    if ( pccni != NULL )
    {
        pccni->Release( );
    }
    if ( bstrName != NULL )
    {
        TraceSysFreeString( bstrName );
    }
    if ( pccci != NULL )
    {
        pccci->Release( );
    }
    if ( pccni2 != NULL )
    {
        pccni2->Release( );
    }

    HRETURN( hr );
}


//
//  This tests the Analyze Cluster Tasks.
//
HRESULT
HrTestTaskAnalyzeCluster( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;
    DWORD           dwCookie;

    CUINotification *       puin;

    IUnknown *              punk = NULL;
    IObjectManager *        pom  = NULL;
    ITaskManager *          ptm  = NULL;
    ITaskAnalyzeCluster *   ptac = NULL;
    IConnectionPoint *      pcp  = NULL;
    INotifyUI *             pnui = NULL;
    IClusCfgCallback *      pcccb = NULL;

    //
    //  Gather the manager needed to complete this task.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_TaskManager,
                                 ITaskManager,
                                 &ptm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the object manager to create a cookie for the task
    //  to use as a completion cookie.
    //

    hr = THR( pom->FindObject( CLSID_TaskType,
                               g_cookieCluster,
                               L"AnalyzeTask",
                               IID_NULL,
                               &cookie,
                               NULL
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a notification object that will be called when
    //  the task is completed.
    //

    hr = THR( CUINotification::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    puin = reinterpret_cast< CUINotification * >( punk );
    THR( puin->HrSetCompletionCookie( cookie ) );

    hr = THR( punk->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  Register the notification object with the Notification Manager.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_NotificationManager,
                                 IConnectionPoint,
                                 &pcp
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcp->Advise( pnui, &dwCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Task Manager to create the Analyze Cluster Task.
    //

    hr = THR( ptm->CreateTask( TASK_AnalyzeCluster,
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( ITaskAnanlyzeCluster, &ptac ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  The the task what cookie to use for the notification.
    //

    hr = THR( ptac->SetCookie( cookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Tell the task which cluster to analyze.
    //

    hr = THR( ptac->SetClusterCookie( g_cookieCluster ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a callback object.
    //

    Assert( punk == NULL );
    hr = THR( CCallback::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk = TraceInterface( L"CCallback", IUnknown, punk, 1 );

    hr = THR( punk->TypeSafeQI( IClusCfgCallback, &pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  The the action where to call us back.
    //

    hr = THR( ptac->SetCallback( pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Reset g_fWait and submit the task.
    //

    g_fWait = TRUE;
    hr = THR( ptm->SubmitTask( ptac ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Wait for the task to complete.
    //
    while( g_fWait )
    {
        Sleep( 1 ); // sleep a millisecond
    }

    //
    //  Unregister the notification object.
    //

    hr = THR( pcp->Unadvise( dwCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pcp != NULL )
    {
        pcp->Release( );
    }
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( ptm != NULL )
    {
        ptm->Release( );
    }
    if ( ptac != NULL )
    {
        ptac->Release( );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( pnui != NULL )
    {
        pnui->Release( );
    }
    if ( pcccb != NULL )
    {
        pcccb->Release( );
    }

    HRETURN( hr );

}

//
//  This tests the Commit Cluster Changes Tasks.
//
HRESULT
HrTestTaskCommitClusterChanges( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;
    DWORD           dwCookie;

    CUINotification *           puin;

    IUnknown *                  punk  = NULL;
    IObjectManager *            pom   = NULL;
    ITaskManager *              ptm   = NULL;
    ITaskCommitClusterChanges * ptccc = NULL;
    IConnectionPoint *          pcp   = NULL;
    INotifyUI *                 pnui  = NULL;
    IClusCfgCallback *          pcccb = NULL;

    //
    //  Gather the manager needed to complete this task.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_TaskManager,
                                 ITaskManager,
                                 &ptm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the object manager to create a cookie for the task
    //  to use as a completion cookie.
    //

    hr = THR( pom->FindObject( CLSID_TaskType,
                               g_cookieCluster,
                               L"CommitClusterChanges",
                               IID_NULL,
                               &cookie,
                               NULL
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a notification object that will be called when
    //  the task is completed.
    //

    hr = THR( CUINotification::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    puin = reinterpret_cast< CUINotification * >( punk );
    THR( puin->HrSetCompletionCookie( cookie ) );

    hr = THR( punk->TypeSafeQI( INotifyUI, &pnui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  Register the notification object with the Notification Manager.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_NotificationManager,
                                 IConnectionPoint,
                                 &pcp
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcp->Advise( pnui, &dwCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Task Manager to create the Analyze Cluster Task.
    //

    hr = THR( ptm->CreateTask( TASK_CommitClusterChanges,
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( ITaskCommitClusterChanges, &ptccc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  The the task what cookie to use for the notification.
    //

    hr = THR( ptccc->SetCookie( cookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Tell the task which cluster to commit.
    //

    hr = THR( ptccc->SetClusterCookie( g_cookieCluster ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create a callback object.
    //

    Assert( punk == NULL );
    hr = THR( CCallback::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk = TraceInterface( L"CCallback", IUnknown, punk, 1 );

    hr = THR( punk->TypeSafeQI( IClusCfgCallback, &pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  The the action where to call us back.
    //

    hr = THR( ptccc->SetCallback( pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Reset g_fWait and submit the task.
    //

    g_fWait = TRUE;
    hr = THR( ptm->SubmitTask( ptccc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Wait for the task to complete.
    //
    while( g_fWait )
    {
        Sleep( 1 ); // sleep a millisecond
    }

    //
    //  Unregister the notification object.
    //

    hr = THR( pcp->Unadvise( dwCookie ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( pcp != NULL )
    {
        pcp->Release( );
    }
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( ptm != NULL )
    {
        ptm->Release( );
    }
    if ( ptccc != NULL )
    {
        ptccc->Release( );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( pnui != NULL )
    {
        pnui->Release( );
    }
    if ( pcccb != NULL )
    {
        pcccb->Release( );
    }

    HRETURN( hr );

}


//
//  This tests the object manager's node enumerator.
//
HRESULT
HrTestEnumNodes( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    ULONG           celtFetched;

    BSTR            bstrName = NULL;

    IUnknown *              punk  = NULL;
    IObjectManager *        pom   = NULL;
    IEnumNodes *            pen   = NULL;
    IClusCfgNodeInfo *      pccni = NULL;

    //
    //  Gather the manager needed to complete this task.
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the object manager to create a cookie for the task
    //  to use as a completion cookie.
    //

    hr = THR( pom->FindObject( CLSID_NodeType,
                               g_cookieCluster,
                               NULL,
                               DFGUID_EnumNodes,
                               &cookieDummy,    // not needed, but the proxy code wants something
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Enumerate the nodes.
    //

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( pen->Next( 1, &pccni, &celtFetched ) );
        if ( hr == S_FALSE )
            break;  // exit loop

        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pccni->GetName( &bstrName ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        DebugMsg( "Node Name: %s", bstrName );

        TraceSysFreeString( bstrName );

        pccni->Release( );
        pccni = NULL;
    }

    hr = S_OK;

Cleanup:
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( pen != NULL )
    {
        pen->Release( );
    }
    if ( pccni != NULL )
    {
        pccni->Release( );
    }
    if ( bstrName != NULL )
    {
        TraceSysFreeString( bstrName );
    }

    HRETURN( hr );
}

//
//  This tests all the object manager's enumerators. It should be executed
//  while the object cache is empty.
//
HRESULT
HrTestEmptyEnumerations( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookie;

    IUnknown *          punk  = NULL;
    IObjectManager *    pom   = NULL;
    IEnumNodes *        pen   = NULL;
    IClusCfgNodeInfo *  pccni = NULL;
    IEnumClusCfgManagedResources * peccmr = NULL;
    IEnumClusCfgNetworks *  peccn = NULL;
    IClusCfgManagedResourceInfo * pccmri = NULL;
    IClusCfgNetworkInfo * pccneti = NULL;

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  This should fail.
    //

    hr = pom->FindObject( CLSID_NodeType,
                          NULL,
                          NULL,
                          DFGUID_EnumNodes,
                          &cookie,
                          &punk
                          );
    if ( FAILED( hr ) )
    {
        hr = S_OK;      // ignore the failure.
        goto EnumResources;
    }

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  If it didn't fail, then this shouldn't AV.
    //

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( pen->Next( 1, &pccni, NULL ) );
        if ( hr == S_FALSE )
            break;

        if ( FAILED( hr ) )
            goto Cleanup;

        pccni->Release( );
        pccni = NULL;
    }

EnumResources:
    //
    //  This should fail.
    //

    hr = pom->FindObject( CLSID_NodeType,
                          NULL,
                          NULL,
                          DFGUID_EnumManageableResources,
                          &cookie,
                          &punk
                          );
    if ( FAILED( hr ) )
    {
        hr = S_OK;      // ignore the failure.
        goto EnumNetworks;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  If it didn't fail, then this shouldn't AV.
    //

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( peccmr->Next( 1, &pccmri, NULL ) );
        if ( hr == S_FALSE )
            break;

        if ( FAILED( hr ) )
            goto Cleanup;

        pccmri->Release( );
        pccmri = NULL;
    }

EnumNetworks:
    //
    //  This should fail.
    //

    hr = pom->FindObject( CLSID_NodeType,
                          NULL,
                          NULL,
                          DFGUID_EnumManageableNetworks,
                          &cookie,
                          &punk
                          );
    if ( FAILED( hr ) )
    {
        hr = S_OK;      // ignore the failure.
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  If it didn't fail, then this shouldn't AV.
    //

    Assert( hr == S_OK );
    while ( hr == S_OK )
    {
        hr = STHR( peccn->Next( 1, &pccneti, NULL ) );
        if ( hr == S_FALSE )
            break;

        if ( FAILED( hr ) )
            goto Cleanup;

        pccneti->Release( );
        pccneti = NULL;
    }

    hr = S_OK;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( peccmr != NULL )
    {
        peccmr->Release( );
    }
    if ( peccn != NULL )
    {
        peccn->Release( );
    }
    if ( pccni != NULL )
    {
        pccni->Release( );
    }
    if ( pccmri != NULL )
    {
        pccmri->Release( );
    }
    if ( pccneti != NULL )
    {
        pccneti->Release( );
    }
    if ( pen != NULL )
    {
        pen->Release( );
    }
    if ( pom != NULL )
    {
        pom->Release( );
    }

    HRETURN( hr );
}

//
//  This tests the Cluster Configuration object in the object manager.
//
HRESULT
HrTestClusterConfiguration(
    BSTR            bstrClusterNameIn,
    BSTR            bstrAccountNameIn,
    BSTR            bstrPasswordIn,
    BSTR            bstrDomainIn,
    ULONG           ulClusterIPIn,
    ULONG           ulClusterSubnetIn,
    OBJECTCOOKIE *  pcookieClusterOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    ULONG   ulClusterIP;
    ULONG   ulClusterSubnet;

    BSTR    bstrClusterName = NULL;
    BSTR    bstrAccountName = NULL;
    BSTR    bstrPassword    = NULL;
    BSTR    bstrDomain      = NULL;

    IUnknown *              punk   = NULL;
    IObjectManager *        pom    = NULL;
    IClusCfgClusterInfo *   pccci  = NULL;
    IClusCfgCredentials *   piccc  = NULL;

    //
    //  Retrieve the Object Manager
    //

    hr = THR( g_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Ask the Object Manager for the cluster configuration object.
    //

    hr = E_PENDING;
    while ( hr == E_PENDING )
    {
        //  Don't wrap. this can fail with E_PENDING.
        hr = pom->FindObject( CLSID_ClusterConfigurationType,
                              NULL,
                              bstrClusterNameIn,
                              DFGUID_ClusterConfigurationInfo,
                              pcookieClusterOut,
                              &punk
                              );
        if ( hr == E_PENDING )
        {
            Sleep( 1000 );  // 1 Second
            continue;
        }

        THR( hr );
        if ( FAILED( hr ) )
            goto Cleanup;
    } // while: pending

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    //  Exercise the forming and joining flags.
    //

    hr = THR( pccci->SetForming( TRUE ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if defined(TURN_ON_ALL_TESTS)
    //  This will fail.
    hr = pccci->SetJoining( TRUE );
    Assert( FAILED( hr ) );
#endif

    hr = THR( pccci->SetForming( FALSE ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->SetJoining( TRUE ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if defined(TURN_ON_ALL_TESTS)
    //  This will fail.
    hr = pccci->SetForming( TRUE );
    Assert( FAILED( hr ) );
#endif

    hr = THR( pccci->SetJoining( FALSE ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Test account info.
    //
    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( piccc->SetCredentials( bstrAccountNameIn, bstrDomainIn, bstrPasswordIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( piccc->GetCredentials( &bstrAccountName, &bstrDomain, &bstrPassword ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    Assert( StrCmp( bstrAccountNameIn, bstrAccountName ) == 0 );
    Assert( StrCmp( bstrPasswordIn, bstrPassword ) == 0 );
    Assert( StrCmp( bstrDomainIn, bstrDomain ) == 0 );

    piccc->Release();
    piccc = NULL;

    //
    //. Test cluster name.
    //

    hr = THR( pccci->SetName( bstrClusterNameIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->GetName( &bstrClusterName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    Assert( StrCmp( bstrClusterNameIn, bstrClusterName ) == 0 );

    //
    //  Test IP/subnet.
    //

    hr = THR( pccci->SetIPAddress( ulClusterIPIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->SetSubnetMask( ulClusterSubnetIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->GetIPAddress( &ulClusterIP ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccci->GetSubnetMask( &ulClusterSubnet ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    Assert( ulClusterIP == ulClusterIPIn );
    Assert( ulClusterSubnet == ulClusterSubnetIn );

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( bstrClusterName != NULL )
    {
        TraceSysFreeString( bstrClusterName );
    }
    if ( bstrAccountName != NULL )
    {
        TraceSysFreeString( bstrAccountName );
    }
    if ( bstrPassword != NULL )
    {
        TraceSysFreeString( bstrPassword );
    }
    if ( bstrDomain != NULL )
    {
        TraceSysFreeString( bstrDomain );
    }
    if ( pom != NULL )
    {
        pom->Release( );
    }
    if ( piccc != NULL )
    {
        piccc->Release( );
    }
    if ( pccci != NULL )
    {
        pccci->Release( );
    }

    HRETURN( hr );
}


//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int
_cdecl
main( void )
{
    TraceInitializeProcess( NULL, 0 );

    HRESULT hr;
    ULONG   ulClusterIP;
    ULONG   ulClusterSubnet;

    ulClusterIP = inet_addr( "10.1.1.10" );
    ulClusterSubnet = inet_addr( "255.255.0.0" );

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if 0
    hr = THR( HrRegisterTheDll( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

    //
    //  Start up the middle tier.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IServiceProvider, &g_psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if 0 || defined(TURN_ON_ALL_TESTS)
    hr = THR( HrTestEmptyEnumerations( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

#if 0 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    hr = THR( HrTestClusterConfiguration( L"GPEASEDEV-CLUS.NTDEV.MICROSOFT.COM",
                                          L"ntdev",
                                          L"ntdevntdev",
                                          L"ntdev",
                                          ulClusterIP,
                                          ulClusterSubnet,
                                          &g_cookieCluster
                                          ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

#if 1 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    hr = THR( HrTestAddingNode( L"GPEASE-WOLF1.NTDEV.MICROSOFT.COM" ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if 0 || defined(TURN_ON_ALL_TESTS)
    //
    //  KB: Since HrTestAddingNode( ) changes the name of the node when
    //      TURN_ON_ALL_TESTS is on, it doesn't make sense to try to
    //      connect to another node.
    //
    hr = THR( HrTestAddingNode( L"GALENB-CLUS.NTDEV.MICROSOFT.COM" ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

#endif // HrTestAddingNode

#if 1 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    //
    //  KB: HrTestAddingNode() must be run before this or the test
    //      will failed.
    //
    hr = THR( HrTestEnumNodes( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif // HrTestEnumNodes

#if 0 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    hr = THR( HrTestTaskAnalyzeCluster( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif // HrTestTaskAnalyzeCluster

#if 0 || defined(TURN_ON_ALL_TESTS) || defined(REGRESSION_PASS)
    hr = THR( HrTestTaskCommitClusterChanges( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif // HrTestTaskCommitClusterChanges

Cleanup:
    if ( g_psp != NULL )
    {
        g_psp->Release( );
    }

    CoUninitialize( );

    TraceTerminateProcess( NULL, 0 );

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\dummy.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Dummy.h
//
//  Description:
//      CDummy implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CDummy
class
CDummy:
    public IDummy
{
private:
    // IUnknown
    LONG                m_cRef;

private: // Methods
    CDummy( );
    ~CDummy();
    STDMETHOD( Init )( void );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

}; // class CDummy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\createservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CreateServices.h
//
//  Description:
//      CreateServices implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
CCreateServices
    : public IClusCfgResourceCreate
    , public IPrivatePostCfgResource
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IPrivatePostCfgResource
    CResourceEntry *    m_presentry;    //  List entry that the service is to modify.

private:    // methods
    CCreateServices( void );
    ~CCreateServices( void );

    HRESULT
        HrInit(void );

public:     // methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IClusCfgResourceCreate
    STDMETHOD( SetPropertyBinary )( LPCWSTR pcszNameIn, 
                                    const DWORD cbSizeIn, 
                                    const BYTE * pbyteIn 
                                    );        
    STDMETHOD( SetPropertyDWORD )( LPCWSTR pcszNameIn, 
                                   const DWORD dwDWORDIn
                                   );
    STDMETHOD( SetPropertyString )( LPCWSTR pcszNameIn,
                                    LPCWSTR pcszStringIn 
                                    );        
    STDMETHOD( SetPropertyExpandString )( LPCWSTR pcszNameIn,
                                          LPCWSTR pcszStringIn 
                                          );        
    STDMETHOD( SetPropertyMultiString )( LPCWSTR     pcszNameIn, 
                                         const DWORD cbSizeIn, 
                                         LPCWSTR     pcszStringIn 
                                         );        
    STDMETHOD( SetPropertyUnsignedLargeInt )( LPCWSTR pcszNameIn,
                                              const ULARGE_INTEGER ulIntIn 
                                              );        
    STDMETHOD( SetPropertyLong )( LPCWSTR pcszNameIn,
                                  const LONG lLongIn 
                                  );        
    STDMETHOD( SetPropertySecurityDescriptor )( LPCWSTR pcszNameIn,
                                                const SECURITY_DESCRIPTOR * pcsdIn 
                                                );        
    STDMETHOD( SetPropertyLargeInt )( LPCWSTR pcszNameIn,
                                      const LARGE_INTEGER lIntIn 
                                      );        
    STDMETHOD( SendResourceControl )( DWORD dwControlCode,
                                      LPVOID lpInBuffer,
                                      DWORD cbInBufferSize
                                      );

    //  IPrivatePostCfgResource
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn );

}; // class CCreateServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\evictservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      EvictServices.h
//
//  Description:
//      EvictServices implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPrivatePostCfgResource.h"
#include "EvictServices.h"

DEFINE_THISCLASS("CEvictServices")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEvictServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    Assert( ppunkOut != NULL );

    CEvictServices * pdummy = new CEvictServices;
    if ( pdummy != NULL )
    {
        hr = THR( pdummy->HrInit( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pdummy->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pdummy->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEvictServices::CEvictServices( void )
//
//////////////////////////////////////////////////////////////////////////////
CEvictServices::CEvictServices( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CEvictServices( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEvictServices::HrInit( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEvictServices::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // Resource
    Assert( m_presentry == NULL );

    HRETURN( hr );

} // HrInit( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEvictServices::~CEvictServices( )
//
//////////////////////////////////////////////////////////////////////////////
CEvictServices::~CEvictServices( )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CEvictServices( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEvictServices::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictServices::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgResourceEvict * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgResourceEvict ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgResourceEvict, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgResourceEvict
    else if ( IsEqualIID( riid, IID_IPrivatePostCfgResource ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IPrivatePostCfgResource, this, 0 );
        hr   = S_OK;
    } // else if: IPrivatePostCfgResource

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEvictServices::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEvictServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef ++;  // apartment model

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEvictServices::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEvictServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef --;  // apartment model

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


//****************************************************************************
//
//  IClusCfgResourceEvict
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEvictServices::DoSomethingCool( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEvictServices::DoSomethingCool( void )
{
    TraceFunc( "[IClusCfgResourceEvict]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // DoSomethingCool( )


//****************************************************************************
//
//  IPrivatePostCfgResource
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CEvictServices::SetEntry( 
//      CResourceEntry * presentryIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CEvictServices::SetEntry( 
    CResourceEntry * presentryIn
    )
{
    TraceFunc( "[IPrivatePostCfgResource]" );

    HRESULT hr = S_OK;
    
    m_presentry = presentryIn;

    HRETURN( hr );

} // SetEntry( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\evictservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      EvictServices.h
//
//  Description:
//      EvictServices implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
CEvictServices
    : public IClusCfgResourceEvict
    , public IPrivatePostCfgResource
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IPrivatePostCfgResource
    CResourceEntry *    m_presentry;    //  List entry that the service is to modify.

private:    // methods
    CEvictServices( void );
    ~CEvictServices( void );

    HRESULT
        HrInit(void );

public:     // methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgResourcePreCreate
    STDMETHOD( DoSomethingCool )( void );

    //  IPrivatePostCfgResource
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn );

}; // class CEvictServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\grouphandle.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      GroupHandle.cpp
//
//  Description:
//      Object Manager implementation.
//
//  Documentation:
//      Yes.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "GroupHandle.h"

DEFINE_THISCLASS("CGroupHandle")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CGroupHandle::S_HrCreateInstance(
//      CGroupHandle ** ppunkOut,
//      HGROUP      hGroupIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CGroupHandle::S_HrCreateInstance(
    CGroupHandle ** ppunkOut,
    HGROUP      hGroupIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( ppunkOut != NULL );

    CGroupHandle * pGroupHandle = new CGroupHandle;
    if ( pGroupHandle != NULL )
    {
        hr = THR( pGroupHandle->Init( hGroupIn ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppunkOut = pGroupHandle;
            (*ppunkOut)->AddRef( );
        }

        pGroupHandle->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CGroupHandle::CGroupHandle( void )
//
//////////////////////////////////////////////////////////////////////////////
CGroupHandle::CGroupHandle( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CGroupHandle( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CGroupHandle::Init( 
//      HGROUP hGroupIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CGroupHandle::Init( 
    HGROUP hGroupIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // IPrivateGroupHandle
    Assert( m_hGroup == NULL );

    m_hGroup = hGroupIn;

    HRETURN( hr );

} // Init( )

//////////////////////////////////////////////////////////////////////////////
//
//  CGroupHandle::~CGroupHandle( )
//
//////////////////////////////////////////////////////////////////////////////
CGroupHandle::~CGroupHandle( )
{
    TraceFunc( "" );

    if ( m_hGroup != NULL )
    {
        CloseClusterGroup( m_hGroup );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CGroupHandle( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CGroupHandle::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CGroupHandle::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IUnknown * >( this );
        hr   = S_OK;
    } // if: IUnknown
#if 0
    else if ( IsEqualIID( riid, IID_IGroupHandle ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IGroupHandle, this, 0 );
        hr   = S_OK;
    } // else if: IGroupHandle
#endif

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CGroupHandle::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CGroupHandle::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CGroupHandle::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CGroupHandle::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


//****************************************************************************
//
//  IPrivateGroupHandle
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CGroupHandle::SetHandle( 
//      HGROUP hGroupIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CGroupHandle::SetHandle( 
    HGROUP hGroupIn 
    )
{
    TraceFunc( "[IPrivateGroupHandle]" );

    HRESULT hr = S_OK;

    m_hGroup = hGroupIn;

    HRETURN( hr );

} // SetHandle( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CGroupHandle::GetHandle( 
//      HGROUP * phGroupOut 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CGroupHandle::GetHandle( 
    HGROUP * phGroupOut 
    )
{
    TraceFunc( "[IPrivateGroupHandle]" );

    HRESULT hr = S_OK;

    Assert( phGroupOut != NULL );

    *phGroupOut = m_hGroup;

    HRETURN( hr );

} // GetHandle( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\grouphandle.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      GroupHandle.h
//
//  Description:
//      CGroupHandle implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CGroupHandle
class
CGroupHandle:
    public IUnknown
{
private:
    // IUnknown
    LONG                m_cRef;

    //  IPrivateGroupHandle
    HGROUP              m_hGroup;       //  Cluster Group Handle

private: // Methods
    CGroupHandle( );
    ~CGroupHandle();
    STDMETHOD( Init )( HGROUP hGroupIn );

public: // Methods
    static HRESULT
        S_HrCreateInstance( CGroupHandle ** ppunkOut, HGROUP hGroupIn );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IPrivateGroupHandle
    STDMETHOD( SetHandle )( HGROUP hGroupIn );
    STDMETHOD( GetHandle )( HGROUP * phGroupOut );

}; // class CGroupHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\ipostcfgmanager.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      IPostCfgManager.h
//
//  Description:
//      IPostCfgManager interface definition.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 21-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
IPostCfgManager : public IUnknown
{
public:
    //////////////////////////////////////////////////////////////////////////
    //
    //  STDMETHOD
    //  IPostCfgManager::CommitChanges(
    //      IEnumClusCfgManagedResources    * peccmrIn,
    //      IClusCfgClusterInfo *             pccciIn
    //      )
    //
    //  Description:
    //      Tells the Post Configuration Manager to create the resource types,
    //      groups and managed resources.
    //
    //  Arguments:
    //      peccmrIn
    //          The enumerator of the managed resources to create.
    //
    //      pccciIn
    //          The cluster configuration information object.
    //
    //  Return Values:
    //      S_OK
    //          The call succeeded.
    //
    //      other HRESULTs
    //          The call failed.
    //
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( CommitChanges )( IEnumClusCfgManagedResources    * peccmrIn,
                                IClusCfgClusterInfo *             pccciIn
                                ) PURE;

}; // interface IPostCfgManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\iprivatepostcfgresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      IPrivatePostCfgResource.h
//
//  Description:
//      IPrivatePostCfgResource interface definition.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
IPrivatePostCfgResource
:   public  IUnknown
{
public:
    //////////////////////////////////////////////////////////////////////////
    //
    //  PRIVATE
    //  STDMETHOD
    //  IPrivatePostCfgResource::SetEntry(
    //      CResourceEntry * presentryIn 
    //      )
    //
    //  Description:
    //      Tells the resource service which entry it is to be modifying.
    //
    //  Arguments:
    //      presentryIn
    //          The entry in which the resource service is going to modifying.
    //
    //  Return Values:
    //      S_OK
    //          The call succeeded.
    //
    //      other HRESULTs
    //          The call failed.
    //
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn ) PURE;

}; // class IPrivatePostCfgResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\postcfgguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      PostCfgGuids.h
//
//  Description:
//      This file contains the guids used in ClusCfgServer.
//
//  Documentation:
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-FEB-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <InitGuid.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


// {EB14D973-5260-42c8-BDC5-2C463EFC3BFE}
DEFINE_GUID( TASKID_Minor_Init_MapResTypeGuidToName,
0xeb14d973, 0x5260, 0x42c8, 0xbd, 0xc5, 0x2c, 0x46, 0x3e, 0xfc, 0x3b, 0xfe);

// {E6B4712F-D3C5-4a23-A13E-82249CED7263}
DEFINE_GUID( TASKID_Minor_Init_OutOfMemory,
0xe6b4712f, 0xd3c5, 0x4a23, 0xa1, 0x3e, 0x82, 0x24, 0x9c, 0xed, 0x72, 0x63);

// {0B01B239-72AC-42cd-8083-616E1F79A852}
DEFINE_GUID( TASKID_Minor_Initialize_QI,
0xb01b239, 0x72ac, 0x42cd, 0x80, 0x83, 0x61, 0x6e, 0x1f, 0x79, 0xa8, 0x52);

// {145C7029-B56F-41d3-A667-7B1ADEE65C39}
DEFINE_GUID( TASKID_Minor_CommitChanges_QI_Resources,
0x145c7029, 0xb56f, 0x41d3, 0xa6, 0x67, 0x7b, 0x1a, 0xde, 0xe6, 0x5c, 0x39);

// {B3C49A4C-41F2-40bc-870D-30AA31C5D44E}
DEFINE_GUID( TASKID_Minor_CommitChanges_QI_ClusterInfo,
0xb3c49a4c, 0x41f2, 0x40bc, 0x87, 0xd, 0x30, 0xaa, 0x31, 0xc5, 0xd4, 0x4e);

// {770C99BD-2127-481a-A529-8E194CD206A6}
DEFINE_GUID( TASKID_Minor_CommitChanges_GetCommitMode,
0x770c99bd, 0x2127, 0x481a, 0xa5, 0x29, 0x8e, 0x19, 0x4c, 0xd2, 0x6, 0xa6);

// {F4367721-F216-4a1a-807E-A17EDE71B7F4}
DEFINE_GUID( TASKID_Minor_CommitChanges_CoCreate_ResTypeService,
0xf4367721, 0xf216, 0x4a1a, 0x80, 0x7e, 0xa1, 0x7e, 0xde, 0x71, 0xb7, 0xf4);

// {B057ACFF-74C6-4129-A2A8-942D55393FAF}
DEFINE_GUID( TASKID_Minor_CommitChanges_SetParameters,
0xb057acff, 0x74c6, 0x4129, 0xa2, 0xa8, 0x94, 0x2d, 0x55, 0x39, 0x3f, 0xaf);

// {83149573-151E-4bb6-8594-28EFDC058E48}
DEFINE_GUID( TASKID_Minor_CommitChanges_OpenCluster,
0x83149573, 0x151e, 0x4bb6, 0x85, 0x94, 0x28, 0xef, 0xdc, 0x5, 0x8e, 0x48);

// {1744FBF0-9B5D-4846-98B2-5B95C86B0D29}
DEFINE_GUID( TASKID_Minor_PreCreate_Reset,
0x1744fbf0, 0x9b5d, 0x4846, 0x98, 0xb2, 0x5b, 0x95, 0xc8, 0x6b, 0xd, 0x29);

// {A4D1F1EE-71C4-4a10-AA4E-DEC05F37A0F2}
DEFINE_GUID( TASKID_Minor_PreCreate_CPreCreateServices,
0xa4d1f1ee, 0x71c4, 0x4a10, 0xaa, 0x4e, 0xde, 0xc0, 0x5f, 0x37, 0xa0, 0xf2);

// {36A14852-D2B2-460d-A5F4-52A244E19ADE}
DEFINE_GUID( TASKID_Minor_PreCreate_CPreCreateServices_QI,
0x36a14852, 0xd2b2, 0x460d, 0xa5, 0xf4, 0x52, 0xa2, 0x44, 0xe1, 0x9a, 0xde);

// {D3C86111-25F2-49fe-A1F9-91622A120E9C}
DEFINE_GUID( TASKID_Minor_PreCreate_LoadString_Querying,
0xd3c86111, 0x25f2, 0x49fe, 0xa1, 0xf9, 0x91, 0x62, 0x2a, 0x12, 0xe, 0x9c);

// {C9EF05D3-235C-49ae-B237-0C83F69F125C}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_Next,
0xc9ef05d3, 0x235c, 0x49ae, 0xb2, 0x37, 0xc, 0x83, 0xf6, 0x9f, 0x12, 0x5c);

// {2C02D6FB-8847-4b78-B9A8-BA5BCB81A77E}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_GetName,
0x2c02d6fb, 0x8847, 0x4b78, 0xb9, 0xa8, 0xba, 0x5b, 0xcb, 0x81, 0xa7, 0x7e);

// {5BCE21E7-2FE0-4a52-986A-3CBA1B4A5895}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_IsManaged,
0x5bce21e7, 0x2fe0, 0x4a52, 0x98, 0x6a, 0x3c, 0xba, 0x1b, 0x4a, 0x58, 0x95);

// {9DAA8CDA-1004-4543-BCFF-4ECF774AA8A7}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_IsManaged_False,
0x9daa8cda, 0x1004, 0x4543, 0xbc, 0xff, 0x4e, 0xcf, 0x77, 0x4a, 0xa8, 0xa7);

// {A01A352F-1E7B-4bd8-B160-A273ECA8CE6E}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_QI_pccmrc,
0xa01a352f, 0x1e7b, 0x4bd8, 0xb1, 0x60, 0xa2, 0x73, 0xec, 0xa8, 0xce, 0x6e);

// {53F01DD7-99BB-46e7-9859-7E582E7AECEB}
DEFINE_GUID( TASKID_PreCreate_EnumResources_IsQuorumDevice_S_OK,
0x53f01dd7, 0x99bb, 0x46e7, 0x98, 0x59, 0x7e, 0x58, 0x2e, 0x7a, 0xec, 0xeb);

// {E632F148-25B3-4108-931B-DE6D1B990290}
DEFINE_GUID( TASKID_PreCreate_EnumResources_IsQuorumDevice_Failed,
0xe632f148, 0x25b3, 0x4108, 0x93, 0x1b, 0xde, 0x6d, 0x1b, 0x99, 0x2, 0x90);

// {E466C438-35C6-4d4b-A5ED-31E5AD12F7A7}
DEFINE_GUID( TASKID_PreCreate_EnumResources_SetAssociatedResouce,
0xe466c438, 0x35c6, 0x4d4b, 0xa5, 0xed, 0x31, 0xe5, 0xad, 0x12, 0xf7, 0xa7);

// {B54ED2B2-4762-4d33-A8D1-191DD3933758}
DEFINE_GUID( TASKID_PreCreate_EnumResources_SetName,
0xb54ed2b2, 0x4762, 0x4d33, 0xa8, 0xd1, 0x19, 0x1d, 0xd3, 0x93, 0x37, 0x58);

// {A7E8FD12-9B3F-44d0-82A9-2400164087EC}
DEFINE_GUID( TASKID_PreCreate_EnumResources_SetEntry,
0xa7e8fd12, 0x9b3f, 0x44d0, 0x82, 0xa9, 0x24, 0x0, 0x16, 0x40, 0x87, 0xec);

// {D2E0B087-CE86-4ceb-9295-DCA723994925}
DEFINE_GUID( TASKID_Minor_PreCreate_PreCreate_E_NOTIMPL,
0xd2e0b087, 0xce86, 0x4ceb, 0x92, 0x95, 0xdc, 0xa7, 0x23, 0x99, 0x49, 0x25);

// {05F1200D-2F10-435d-95E4-C45C81E186EF}
DEFINE_GUID( TASKID_Minor_PreCreate_PreCreate_Failed,
0x5f1200d, 0x2f10, 0x435d, 0x95, 0xe4, 0xc4, 0x5c, 0x81, 0xe1, 0x86, 0xef);

// {86E8D0D2-64F7-426d-9E96-C862A48BF319}
DEFINE_GUID( TASKID_Minor_PreCreate_LoadString_Resource_Failed,
0x86e8d0d2, 0x64f7, 0x426d, 0x9e, 0x96, 0xc8, 0x62, 0xa4, 0x8b, 0xf3, 0x19);

// {ADA0F04E-D162-4cb8-A1E1-6695C6A2D010}
DEFINE_GUID( TASKID_Minor_PreCreate_Succeeded,
0xada0f04e, 0xd162, 0x4cb8, 0xa1, 0xe1, 0x66, 0x95, 0xc6, 0xa2, 0xd0, 0x10);

// {389D9670-1408-4cca-A527-E5EAD5680B43}
DEFINE_GUID( TASKID_Minor_PreCreate_Finished,
0x389d9670, 0x1408, 0x4cca, 0xa5, 0x27, 0xe5, 0xea, 0xd5, 0x68, 0xb, 0x43);

// {3B387B9F-9D23-49ff-A010-5E1A2C618663}
DEFINE_GUID( TASKID_Minor_CreateGroups_Begin,
0x3b387b9f, 0x9d23, 0x49ff, 0xa0, 0x10, 0x5e, 0x1a, 0x2c, 0x61, 0x86, 0x63);

// {625DE61F-1678-4e97-A7E6-17578AD106B4}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetCountOfTypeDependencies,
0x625de61f, 0x1678, 0x4e97, 0xa7, 0xe6, 0x17, 0x57, 0x8a, 0xd1, 0x6, 0xb4);

// {26E49D7F-15EF-40c3-8792-537328FF9E1D}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetTypeDependencyPtr,
0x26e49d7f, 0x15ef, 0x40c3, 0x87, 0x92, 0x53, 0x73, 0x28, 0xff, 0x9e, 0x1d);

// {ECEFA23F-6A16-4fa4-83B7-B9EBE1566C66}
DEFINE_GUID( TASKID_Minor_CreateGroups_FormatString_NetName,
0xecefa23f, 0x6a16, 0x4fa4, 0x83, 0xb7, 0xb9, 0xeb, 0xe1, 0x56, 0x6c, 0x66);

// {4AE83FA3-CA8D-4997-97D0-2E8C43A68314}
DEFINE_GUID( TASKID_Minor_CreateGroups_AddTypeDependency,
0x4ae83fa3, 0xca8d, 0x4997, 0x97, 0xd0, 0x2e, 0x8c, 0x43, 0xa6, 0x83, 0x14);

// {0527E435-5B42-4a2c-9334-EA918C3892E0}
DEFINE_GUID( TASKID_Minor_CreateGroups_FormatString_IPAddress,
0x527e435, 0x5b42, 0x4a2c, 0x93, 0x34, 0xea, 0x91, 0x8c, 0x38, 0x92, 0xe0);

// {13F32529-0BA2-4ff6-84FE-7982D4002D64}
DEFINE_GUID( TASKID_Minor_CreateGroups_NetName_AddDependent,
0x13f32529, 0xba2, 0x4ff6, 0x84, 0xfe, 0x79, 0x82, 0xd4, 0x0, 0x2d, 0x64);

// {1C3A7C27-E6E7-4a39-B630-70B8B4D6E6D8}
DEFINE_GUID( TASKID_Minor_CreateGroups_IPAddress_AddDependent,
0x1c3a7c27, 0xe6e7, 0x4a39, 0xb6, 0x30, 0x70, 0xb8, 0xb4, 0xd6, 0xe6, 0xd8);

// {022D8BF0-93EB-4dc9-B11E-3772B8BE43B5}
DEFINE_GUID( TASKID_Minor_CreateGroups_QuorumDisk_AddDependent,
0x22d8bf0, 0x93eb, 0x4dc9, 0xb1, 0x1e, 0x37, 0x72, 0xb8, 0xbe, 0x43, 0xb5);

// {5B9958C4-DC00-474f-86CB-8B893F0FE8FB}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetTypePtr,
0x5b9958c4, 0xdc00, 0x474f, 0x86, 0xcb, 0x8b, 0x89, 0x3f, 0xf, 0xe8, 0xfb);

// {9B69E548-0334-4c4b-888E-12574174B99D}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetClassTypePtr,
0x9b69e548, 0x334, 0x4c4b, 0x88, 0x8e, 0x12, 0x57, 0x41, 0x74, 0xb9, 0x9d);

// {0AA1F2BD-CC88-4bf5-87B3-A1953C731AC1}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetFlags,
0xaa1f2bd, 0xcc88, 0x4bf5, 0x87, 0xb3, 0xa1, 0x95, 0x3c, 0x73, 0x1a, 0xc1);

// {7B64039A-79B2-4086-ABF2-5E1520DACE8C}
DEFINE_GUID( TASKID_Minor_CreateGroups_SetFlags,
0x7b64039a, 0x79b2, 0x4086, 0xab, 0xf2, 0x5e, 0x15, 0x20, 0xda, 0xce, 0x8c);

// {4FB598B1-D9EE-4f75-B274-B639941839A3}
DEFINE_GUID( TASKID_Minor_CreateGroups_Resource_AddDependent,
0x4fb598b1, 0xd9ee, 0x4f75, 0xb2, 0x74, 0xb6, 0x39, 0x94, 0x18, 0x39, 0xa3);

// {E7ECD079-1AC8-43c5-A577-0826500A4262}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetName,
0xe7ecd079, 0x1ac8, 0x43c5, 0xa5, 0x77, 0x8, 0x26, 0x50, 0xa, 0x42, 0x62);

// {04989473-AE35-4a5d-A35F-C502C1E87E8B}
DEFINE_GUID( TASKID_Minor_CreateGroups_MissingDependent,
0x4989473, 0xae35, 0x4a5d, 0xa3, 0x5f, 0xc5, 0x2, 0xc1, 0xe8, 0x7e, 0x8b);

// {CA40367F-04AB-44d1-86C9-7E28318AD868}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetAssociateResource,
0xca40367f, 0x4ab, 0x44d1, 0x86, 0xc9, 0x7e, 0x28, 0x31, 0x8a, 0xd8, 0x68);

// {0FE4B1B0-24C1-46c5-87E5-DE6DF8446895}
DEFINE_GUID( TASKID_Minor_CreateGroups_QI_pccmri,
0xfe4b1b0, 0x24c1, 0x46c5, 0x87, 0xe5, 0xde, 0x6d, 0xf8, 0x44, 0x68, 0x95);

// {677F301F-74A9-4176-9D89-7A505AD2DFE6}
DEFINE_GUID( TASKID_Minor_CreateGroups_SetManaged,
0x677f301f, 0x74a9, 0x4176, 0x9d, 0x89, 0x7a, 0x50, 0x5a, 0xd2, 0xdf, 0xe6);

// {CA048D82-325F-4566-904C-99FB67BE46B9}
DEFINE_GUID( TASKID_Minor_CreateGroups_Creating,
0xca048d82, 0x325f, 0x4566, 0x90, 0x4c, 0x99, 0xfb, 0x67, 0xbe, 0x46, 0xb9);

// {A4B491D2-DB89-461e-8423-59A9A6BFE327}
DEFINE_GUID( TASKID_Minor_CreateGroups_Open_ClusterGroup,
0xa4b491d2, 0xdb89, 0x461e, 0x84, 0x23, 0x59, 0xa9, 0xa6, 0xbf, 0xe3, 0x27);

// {6E6830D6-E2A4-4324-BE48-DE7874ABA52E}
DEFINE_GUID( TASKID_Minor_CreateGroups_OpenClusterGroup,
0x6e6830d6, 0xe2a4, 0x4324, 0xbe, 0x48, 0xde, 0x78, 0x74, 0xab, 0xa5, 0x2e);

// {413D510B-73BF-4230-AE1F-A5A8963B5401}
DEFINE_GUID( TASKID_Minor_CreateGroups_Create_CGroupHandle,
0x413d510b, 0x73bf, 0x4230, 0xae, 0x1f, 0xa5, 0xa8, 0x96, 0x3b, 0x54, 0x1);

// {7029A765-0ED6-49d3-952B-24974ACA3FA2}
DEFINE_GUID( TASKID_Minor_CreateGroups_GetCountOfTypeDependencies2,
0x7029a765, 0xed6, 0x49d3, 0x95, 0x2b, 0x24, 0x97, 0x4a, 0xca, 0x3f, 0xa2);

// {265219CA-B5C3-4978-A9C6-254C5EDF9654}
DEFINE_GUID( TASKID_Minor_CreateGroups_FormatString_Group,
0x265219ca, 0xb5c3, 0x4978, 0xa9, 0xc6, 0x25, 0x4c, 0x5e, 0xdf, 0x96, 0x54);

// {D302B68A-0743-4f66-9258-2DE440BB8092}
DEFINE_GUID( TASKID_Minor_CreateGroups_CreateClusterGroup,
0xd302b68a, 0x743, 0x4f66, 0x92, 0x58, 0x2d, 0xe4, 0x40, 0xbb, 0x80, 0x92);

// {E8CFA468-ED52-415c-A682-311648AA7026}
DEFINE_GUID( TASKID_Minor_CreateGroups_OnlineClusterGroup,
0xe8cfa468, 0xed52, 0x415c, 0xa6, 0x82, 0x31, 0x16, 0x48, 0xaa, 0x70, 0x26);

// {42F93B4E-0AB4-4851-983A-D792A5D24094}
DEFINE_GUID( TASKID_Minor_CreateGroups_Create_CGroupHandle2,
0x42f93b4e, 0xab4, 0x4851, 0x98, 0x3a, 0xd7, 0x92, 0xa5, 0xd2, 0x40, 0x94);

// {3122D49C-9FA4-44a1-8DC3-FFBF79AE630C}
DEFINE_GUID( TASKID_Minor_CreateGroups_Created,
0x3122d49c, 0x9fa4, 0x44a1, 0x8d, 0xc3, 0xff, 0xbf, 0x79, 0xae, 0x63, 0xc);

// {9AEA3DE8-220A-4a76-8A70-B3271EFF63BA}
DEFINE_GUID( TASKID_Minor_CreateGroups_Finished,
0x9aea3de8, 0x220a, 0x4a76, 0x8a, 0x70, 0xb3, 0x27, 0x1e, 0xff, 0x63, 0xba);

// {AF9FE752-2F27-473a-A7B0-86CEFDE922CA}
DEFINE_GUID( TASKID_Minor_CreateResources_LoadString_Creating,
0xaf9fe752, 0x2f27, 0x473a, 0xa7, 0xb0, 0x86, 0xce, 0xfd, 0xe9, 0x22, 0xca);

// {A9282CC8-F6C9-4b38-BADE-2F1CEE657E7B}
DEFINE_GUID( TASKID_Minor_CreateResources_Starting,
0xa9282cc8, 0xf6c9, 0x4b38, 0xba, 0xde, 0x2f, 0x1c, 0xee, 0x65, 0x7e, 0x7b);

// {3F08ABDA-13FD-4f02-B4B4-925FF239C206}
DEFINE_GUID( TASKID_Minor_CreateResources_Finished,
0x3f08abda, 0x13fd, 0x4f02, 0xb4, 0xb4, 0x92, 0x5f, 0xf2, 0x39, 0xc2, 0x6);

// {93779961-39A9-4cdf-BECC-04F1410640D5}
DEFINE_GUID( TASKID_Minor_PostCreateResources_LoadString_Starting,
0x93779961, 0x39a9, 0x4cdf, 0xbe, 0xcc, 0x4, 0xf1, 0x41, 0x6, 0x40, 0xd5);

// {997EEAB6-01F1-45b9-BC96-E2E728E32CCC}
DEFINE_GUID( TASKID_Minor_PostCreateResources_Starting,
0x997eeab6, 0x1f1, 0x45b9, 0xbc, 0x96, 0xe2, 0xe7, 0x28, 0xe3, 0x2c, 0xcc);

// {ABE9C1C8-13CC-44dc-B4D3-8B803DE38358}
DEFINE_GUID( TASKID_Minor_PostCreateResources_Finished,
0xabe9c1c8, 0x13cc, 0x44dc, 0xb4, 0xd3, 0x8b, 0x80, 0x3d, 0xe3, 0x83, 0x58);

// {4F5EAD56-5172-4b2a-97A8-6812ADAE2F9C}
DEFINE_GUID( TASKID_Minor_FindNextSharedStorage_GetClassTypePtr,
0x4f5ead56, 0x5172, 0x4b2a, 0x97, 0xa8, 0x68, 0x12, 0xad, 0xae, 0x2f, 0x9c);

// {EFB1E60B-2967-43ea-8309-41912038B7A7}
DEFINE_GUID( TASKID_Minor_FindNextSharedStorage_GetFlags,
0xefb1e60b, 0x2967, 0x43ea, 0x83, 0x9, 0x41, 0x91, 0x20, 0x38, 0xb7, 0xa7);

// {68984825-C701-4470-AD63-5BC2F336848E}
DEFINE_GUID( TASKID_Minor_HrAttemptToAssignStorageToResource_NoMoreStorage,
0x68984825, 0xc701, 0x4470, 0xad, 0x63, 0x5b, 0xc2, 0xf3, 0x36, 0x84, 0x8e);

// {EBCDD0EB-2073-4f14-BD27-90AB30A8E586}
DEFINE_GUID( TASKID_Minor_HrAttemptToAssignStorageToResource_SetFlags,
0xebcdd0eb, 0x2073, 0x4f14, 0xbd, 0x27, 0x90, 0xab, 0x30, 0xa8, 0xe5, 0x86);

// {2BCED0CA-CEFD-47c2-8740-AB02A6D3DBFB}
DEFINE_GUID( TASKID_Minor_HrAttemptToAssignStorageToResource_AddDependent,
0x2bced0ca, 0xcefd, 0x47c2, 0x87, 0x40, 0xab, 0x2, 0xa6, 0xd3, 0xdb, 0xfb);

// {FE025462-CFCE-4fed-ACB5-3DDBD9811AF0}
DEFINE_GUID( TASKID_Minor_HrMovedDependentsToAnotherResource_GetCountOfDependents,
0xfe025462, 0xcfce, 0x4fed, 0xac, 0xb5, 0x3d, 0xdb, 0xd9, 0x81, 0x1a, 0xf0);

// {A03679D1-5E6C-40d5-88D9-2B147DFFD000}
DEFINE_GUID( TASKID_Minor_HrMovedDependentsToAnotherResource_GetDependent,
0xa03679d1, 0x5e6c, 0x40d5, 0x88, 0xd9, 0x2b, 0x14, 0x7d, 0xff, 0xd0, 0x0);

// {741F73BA-8B43-464f-BBC3-C7AFB9E232A3}
DEFINE_GUID( TASKID_Minor_HrMovedDependentsToAnotherResource_AddDependent,
0x741f73ba, 0x8b43, 0x464f, 0xbb, 0xc3, 0xc7, 0xaf, 0xb9, 0xe2, 0x32, 0xa3);

// {31641A0B-AC8E-4856-AD83-811103EF4451}
DEFINE_GUID( TASKID_Minor_HrMovedDependentsToAnotherResource_ClearDependents,
0x31641a0b, 0xac8e, 0x4856, 0xad, 0x83, 0x81, 0x11, 0x3, 0xef, 0x44, 0x51);

// {401343DB-742F-493b-81C2-C272A01E9685}
DEFINE_GUID( TASKID_Minor_HrSetGroupOnResourceAndItsDependents_SetGroupHandle,
0x401343db, 0x742f, 0x493b, 0x81, 0xc2, 0xc2, 0x72, 0xa0, 0x1e, 0x96, 0x85);

// {CF60103B-2393-478e-82F0-BD1041097D9E}
DEFINE_GUID( TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetCountOfDependents,
0xcf60103b, 0x2393, 0x478e, 0x82, 0xf0, 0xbd, 0x10, 0x41, 0x9, 0x7d, 0x9e);

// {2179E00E-00AE-432b-8910-F9DF3B8C4701}
DEFINE_GUID( TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetDependent,
0x2179e00e, 0xae, 0x432b, 0x89, 0x10, 0xf9, 0xdf, 0x3b, 0x8c, 0x47, 0x1);

// {71C819A2-59D4-4a20-8A06-695BFC5A3B50}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetGroupHandle,
0x71c819a2, 0x59d4, 0x4a20, 0x8a, 0x6, 0x69, 0x5b, 0xfc, 0x5a, 0x3b, 0x50);

// {220CBC7E-F52C-4fb0-AC58-D6DAA7F3330E}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_Create_CGroupHandle,
0x220cbc7e, 0xf52c, 0x4fb0, 0xac, 0x58, 0xd6, 0xda, 0xa7, 0xf3, 0x33, 0xe);

// {F3E4E9A6-E114-4718-9EC7-1DB72154BA6B}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OpenClusterGroup,
0xf3e4e9a6, 0xe114, 0x4718, 0x9e, 0xc7, 0x1d, 0xb7, 0x21, 0x54, 0xba, 0x6b);

// {348C670F-06C7-41f8-8EFB-15C2F8DD4E11}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetClusterResourceState,
0x348c670f, 0x6c7, 0x41f8, 0x8e, 0xfb, 0x15, 0xc2, 0xf8, 0xdd, 0x4e, 0x11);

// {9961A93D-1112-4121-949D-7A43DAF77BD7}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetCountOfDependents,
0x9961a93d, 0x1112, 0x4121, 0x94, 0x9d, 0x7a, 0x43, 0xda, 0xf7, 0x7b, 0xd7);

// {84710A53-2DE0-49ac-8BA1-3202F3FAC6E8}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetDependent,
0x84710a53, 0x2de0, 0x49ac, 0x8b, 0xa1, 0x32, 0x2, 0xf3, 0xfa, 0xc6, 0xe8);

// {3590BB47-0B80-4a7a-A27A-F27728742FA1}
DEFINE_GUID( TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OutOfMemory,
0x3590bb47, 0xb80, 0x4a7a, 0xa2, 0x7a, 0xf2, 0x77, 0x28, 0x74, 0x2f, 0xa1);

// {D25F1C89-6452-42aa-93F9-93F0721CCF23}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices,
0xd25f1c89, 0x6452, 0x42aa, 0x93, 0xf9, 0x93, 0xf0, 0x72, 0x1c, 0xcf, 0x23);

// {9F3C4CA9-CFCB-4e19-886C-4569172D4D9F}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices_QI,
0x9f3c4ca9, 0xcfcb, 0x4e19, 0x88, 0x6c, 0x45, 0x69, 0x17, 0x2d, 0x4d, 0x9f);

// {A3555B22-732C-416a-BB51-51F21FD8DC09}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_SetEntry,
0xa3555b22, 0x732c, 0x416a, 0xbb, 0x51, 0x51, 0xf2, 0x1f, 0xd8, 0xdc, 0x9);

// {26699073-04DA-4b24-9138-B8FFA4CC25CA}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_IsConfigured,
0x26699073, 0x4da, 0x4b24, 0x91, 0x38, 0xb8, 0xff, 0xa4, 0xcc, 0x25, 0xca);

// {4BCEF420-01B6-4237-B0ED-E75F4E91C160}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_SetConfigured,
0x4bcef420, 0x1b6, 0x4237, 0xb0, 0xed, 0xe7, 0x5f, 0x4e, 0x91, 0xc1, 0x60);

// {C91BFB6C-5AF3-451b-886A-BC3C54B51F93}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetName,
0xc91bfb6c, 0x5af3, 0x451b, 0x88, 0x6a, 0xbc, 0x3c, 0x54, 0xb5, 0x1f, 0x93);

// {72058AEF-0B59-4eef-9EA0-37449B22636D}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetGroupHandle,
0x72058aef, 0xb59, 0x4eef, 0x9e, 0xa0, 0x37, 0x44, 0x9b, 0x22, 0x63, 0x6d);

// {D976AB04-40FD-4afb-A989-B52FE2EC1A45}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetHandle,
0xd976ab04, 0x40fd, 0x4afb, 0xa9, 0x89, 0xb5, 0x2f, 0xe2, 0xec, 0x1a, 0x45);

// {1F229FDE-D692-40bc-9DA9-C625033421D8}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetAssociatedResource,
0x1f229fde, 0xd692, 0x40bc, 0x9d, 0xa9, 0xc6, 0x25, 0x3, 0x34, 0x21, 0xd8);

// {3BB6DCD7-8BAC-4858-815E-F83D9625CE82}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Create_Failed,
0x3bb6dcd7, 0x8bac, 0x4858, 0x81, 0x5e, 0xf8, 0x3d, 0x96, 0x25, 0xce, 0x82);

// {64B25912-4472-41d0-8DF9-5ED3407C9D42}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_LoadString_CreateFailed,
0x64b25912, 0x4472, 0x41d0, 0x8d, 0xf9, 0x5e, 0xd3, 0x40, 0x7c, 0x9d, 0x42);

// {34731F38-4B93-426c-9188-3463693D302D}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_GetTypePtr,
0x34731f38, 0x4b93, 0x426c, 0x91, 0x88, 0x34, 0x63, 0x69, 0x3d, 0x30, 0x2d);

// {D00DDDF7-4B8F-48d2-B5FC-AA174FF43B46}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_PcszLookupTypeNameByGUID,
0xd00dddf7, 0x4b8f, 0x48d2, 0xb5, 0xfc, 0xaa, 0x17, 0x4f, 0xf4, 0x3b, 0x46);

// {EC8EB861-EFDA-4d0d-9420-0C4EA69536FA}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_InvalidData_GetTypePtr,
0xec8eb861, 0xefda, 0x4d0d, 0x94, 0x20, 0xc, 0x4e, 0xa6, 0x95, 0x36, 0xfa);

// {A2BB1F77-F8C8-4658-B849-9A2CCAC9642D}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_NetworkName_QI_pccrc,
0xa2bb1f77, 0xf8c8, 0x4658, 0xb8, 0x49, 0x9a, 0x2c, 0xca, 0xc9, 0x64, 0x2d);

// {3812CC1D-103D-4ca9-8AE6-ADA8804EFBA5}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_NetworkName_SetPropertyString,
0x3812cc1d, 0x103d, 0x4ca9, 0x8a, 0xe6, 0xad, 0xa8, 0x80, 0x4e, 0xfb, 0xa5);

// {9F64F1C0-6B4E-41fd-9995-4C7331B064EA}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_IPAddress_QI_pccrc,
0x9f64f1c0, 0x6b4e, 0x41fd, 0x99, 0x95, 0x4c, 0x73, 0x31, 0xb0, 0x64, 0xea);

// {45455DEB-2B1B-4834-86D9-2018D382CF25}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_NothingNew,
0x45455deb, 0x2b1b, 0x4834, 0x86, 0xd9, 0x20, 0x18, 0xd3, 0x82, 0xcf, 0x25);

// {6FF6610B-7EF1-4dbd-A1B9-9959FB590AE6}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetCountOfDependents,
0x6ff6610b, 0x7ef1, 0x4dbd, 0xa1, 0xb9, 0x99, 0x59, 0xfb, 0x59, 0xa, 0xe6);

// {1E32E142-10EC-4d17-ADF9-26B2826CE2E7}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetDependent,
0x1e32e142, 0x10ec, 0x4d17, 0xad, 0xf9, 0x26, 0xb2, 0x82, 0x6c, 0xe2, 0xe7);

// {4AD23667-65C4-42cc-82EA-E1A5137536FC}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetName,
0x4ad23667, 0x65c4, 0x42cc, 0x82, 0xea, 0xe1, 0xa5, 0x13, 0x75, 0x36, 0xfc);

// {43CE9A36-7CE7-4e22-87F7-D481F37867DB}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetHResource,
0x43ce9a36, 0x7ce7, 0x4e22, 0x87, 0xf7, 0xd4, 0x81, 0xf3, 0x78, 0x67, 0xdb);

// {B861DFAF-DB48-4f28-A84E-9510B8F3976F}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_AddClusterResourceDependency,
0xb861dfaf, 0xdb48, 0x4f28, 0xa8, 0x4e, 0x95, 0x10, 0xb8, 0xf3, 0x97, 0x6f);

// {111C9950-9E61-4733-80D5-06C58631D423}
DEFINE_GUID( TASKID_Minor_HrCreateResourceAndDependents_Dependents_Succeeded,
0x111c9950, 0x9e61, 0x4733, 0x80, 0xd5, 0x6, 0xc5, 0x86, 0x31, 0xd4, 0x23);

// {AFD6FEDC-BC4F-4cd6-8CFE-0D0458DF15DF}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_IsConfigured,
0xafd6fedc, 0xbc4f, 0x4cd6, 0x8c, 0xfe, 0xd, 0x4, 0x58, 0xdf, 0x15, 0xdf);

// {CA02A3CF-121A-4231-882F-CAF8DB761D25}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_SetConfigured,
0xca02a3cf, 0x121a, 0x4231, 0x88, 0x2f, 0xca, 0xf8, 0xdb, 0x76, 0x1d, 0x25);

// {079D7A3A-E23F-48d5-BF92-7D7A9FD273C6}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_GetName,
0x79d7a3a, 0xe23f, 0x48d5, 0xbf, 0x92, 0x7d, 0x7a, 0x9f, 0xd2, 0x73, 0xc6);

// {D7F92431-5E00-4f77-8A3F-70A7EF394127}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResource,
0xd7f92431, 0x5e00, 0x4f77, 0x8a, 0x3f, 0x70, 0xa7, 0xef, 0x39, 0x41, 0x27);

// {DC2961C2-E31C-486d-8349-962FD670B688}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResourcePending,
0xdc2961c2, 0xe31c, 0x486d, 0x83, 0x49, 0x96, 0x2f, 0xd6, 0x70, 0xb6, 0x88);

// {FA3957AC-F30C-4d67-8DBC-70D28C922A92}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceStateUnknown,
0xfa3957ac, 0xf30c, 0x4d67, 0x8d, 0xbc, 0x70, 0xd2, 0x8c, 0x92, 0x2a, 0x92);

// {C09CF48A-3D3D-4012-83DA-7191C9237BAE}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceOffline,
0xc09cf48a, 0x3d3d, 0x4012, 0x83, 0xda, 0x71, 0x91, 0xc9, 0x23, 0x7b, 0xae);

// {21A09A70-8EE2-4785-9DEC-97EDBEB45FE2}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceFailed,
0x21a09a70, 0x8ee2, 0x4785, 0x9d, 0xec, 0x97, 0xed, 0xbe, 0xb4, 0x5f, 0xe2);

// {DCD49407-576F-48f3-8458-D5B3A2C382A6}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_OnlineClusterResource_Failed,
0xdcd49407, 0x576f, 0x48f3, 0x84, 0x58, 0xd5, 0xb3, 0xa2, 0xc3, 0x82, 0xa6);

// {6CE388C2-A01C-4b5a-8AAD-F4FCF5EAAF06}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_SetClusterQuorumResource,
0x6ce388c2, 0xa01c, 0x4b5a, 0x8a, 0xad, 0xf4, 0xfc, 0xf5, 0xea, 0xaf, 0x6);

// {BB0551C3-CDA5-405f-A261-35B27FA5E0A7}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_SetClusterQuorumResource_Succeeded,
0xbb0551c3, 0xcda5, 0x405f, 0xa2, 0x61, 0x35, 0xb2, 0x7f, 0xa5, 0xe0, 0xa7);

// {058BFA08-E687-410b-BD86-E42E269E82ED}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_SetQuorum,
0x58bfa08, 0xe687, 0x410b, 0xbd, 0x86, 0xe4, 0x2e, 0x26, 0x9e, 0x82, 0xed);

// {E93C6B14-2F68-43c7-94DA-9543000F4D07}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_GetAssociatedResource,
0xe93c6b14, 0x2f68, 0x43c7, 0x94, 0xda, 0x95, 0x43, 0x0, 0xf, 0x4d, 0x7);

// {A771D973-E9BA-4266-BF49-7A6F8475CFAA}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_Create_CPostCreateServices,
0xa771d973, 0xe9ba, 0x4266, 0xbf, 0x49, 0x7a, 0x6f, 0x84, 0x75, 0xcf, 0xaa);

// {A991E33C-D8F6-4281-A1EF-BEFA5BDE0A07}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_Create_CPostCreateServices_QI_ppcr,
0xa991e33c, 0xd8f6, 0x4281, 0xa1, 0xef, 0xbe, 0xfa, 0x5b, 0xde, 0xa, 0x7);

// {2C9F4269-5FA0-4506-91EA-FD29224F0A09}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_SetEntry,
0x2c9f4269, 0x5fa0, 0x4506, 0x91, 0xea, 0xfd, 0x29, 0x22, 0x4f, 0xa, 0x9);

// {FD517153-B577-420d-A6E6-0B5DE9C4E351}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_E_NOTIMPL,
0xfd517153, 0xb577, 0x420d, 0xa6, 0xe6, 0xb, 0x5d, 0xe9, 0xc4, 0xe3, 0x51);

// {FAFA10F6-1DFD-46d8-BD64-A649B29BF411}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_Failed,
0xfafa10f6, 0x1dfd, 0x46d8, 0xbd, 0x64, 0xa6, 0x49, 0xb2, 0x9b, 0xf4, 0x11);

// {EDD4CEDC-89DA-4329-ADE8-705543137E14}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_PostCreate_Failed,
0xedd4cedc, 0x89da, 0x4329, 0xad, 0xe8, 0x70, 0x55, 0x43, 0x13, 0x7e, 0x14);

// {6C7E2678-883F-4890-8F89-BE4219DA813A}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_ResourcePostCreate_Failed,
0x6c7e2678, 0x883f, 0x4890, 0x8f, 0x89, 0xbe, 0x42, 0x19, 0xda, 0x81, 0x3a);

// {D45B9470-45BB-4add-B05C-4BB5DE303EE0}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_Succeeded,
0xd45b9470, 0x45bb, 0x4add, 0xb0, 0x5c, 0x4b, 0xb5, 0xde, 0x30, 0x3e, 0xe0);

// {0EFCF386-D992-4223-B87F-849F6F3C47BD}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_NotNeeded,
0xefcf386, 0xd992, 0x4223, 0xb8, 0x7f, 0x84, 0x9f, 0x6f, 0x3c, 0x47, 0xbd);

// {1733454E-5747-4831-BCA7-11E0671A4FBA}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_GetCountOfDependents,
0x1733454e, 0x5747, 0x4831, 0xbc, 0xa7, 0x11, 0xe0, 0x67, 0x1a, 0x4f, 0xba);

// {B0D040AB-7FB3-4404-AC3E-1B15C61B4D0F}
DEFINE_GUID( TASKID_Minor_HrPostCreateResourceAndDependents_GetDependent,
0xb0d040ab, 0x7fb3, 0x4404, 0xac, 0x3e, 0x1b, 0x15, 0xc6, 0x1b, 0x4d, 0xf);

// {FAFF1E59-9012-4143-AFCE-69B953FD4FDD}
DEFINE_GUID( TASKID_Minor_HrNotifyMemberSetChangeListeners_CoCreate_StdComponentCategoriesMgr,
0xfaff1e59, 0x9012, 0x4143, 0xaf, 0xce, 0x69, 0xb9, 0x53, 0xfd, 0x4f, 0xdd);

// {9A84E38B-52C1-4591-982E-D6515FCB90C9}
DEFINE_GUID( TASKID_Minor_HrNotifyMemberSetChangeListeners_EnumClassesOfCategories,
0x9a84e38b, 0x52c1, 0x4591, 0x98, 0x2e, 0xd6, 0x51, 0x5f, 0xcb, 0x90, 0xc9);

// {A93FE316-0894-4a80-83A3-880962450ADA}
DEFINE_GUID( TASKID_Minor_HrNotifyMemberSetChangeListeners_Next,
0xa93fe316, 0x894, 0x4a80, 0x83, 0xa3, 0x88, 0x9, 0x62, 0x45, 0xa, 0xda);

// {59ADF6E8-3EBC-463d-BABF-0D9F1B363D9F}
DEFINE_GUID( TASKID_Minor_HrNotifyMemberSetChangeListeners_HrProcessMemberSetChangeListener,
0x59adf6e8, 0x3ebc, 0x463d, 0xba, 0xbf, 0xd, 0x9f, 0x1b, 0x36, 0x3d, 0x9f);

// {6D8CF7D7-B09C-42dd-946F-0E7BBD702C35}
DEFINE_GUID( TASKID_Minor_HrProcessMemberSetChangeListener_CoCreate_Listener,
0x6d8cf7d7, 0xb09c, 0x42dd, 0x94, 0x6f, 0xe, 0x7b, 0xbd, 0x70, 0x2c, 0x35);

// {497FDB97-5A16-46e7-9A10-E8ABFDBD42D2}
DEFINE_GUID( TASKID_Minor_HrProcessMemberSetChangeListener_Notify,
0x497fdb97, 0x5a16, 0x46e7, 0x9a, 0x10, 0xe8, 0xab, 0xfd, 0xbd, 0x42, 0xd2);

// {085E2A1D-335E-46a8-9F71-B83998C59C77}
DEFINE_GUID( TASKID_Minor_HrConfigureResTypes_CoCreate_CategoriesMgr,
0x85e2a1d, 0x335e, 0x46a8, 0x9f, 0x71, 0xb8, 0x39, 0x98, 0xc5, 0x9c, 0x77);

// {BD3CA031-912E-430e-8B99-1E0E457EAA26}
DEFINE_GUID( TASKID_Minor_HrConfigureResTypes_Enum,
0xbd3ca031, 0x912e, 0x430e, 0x8b, 0x99, 0x1e, 0xe, 0x45, 0x7e, 0xaa, 0x26);

// {EF9DF26D-748A-4b89-87F8-760F6CC903C0}
DEFINE_GUID( TASKID_Minor_HrConfigureResTypes_Next,
0xef9df26d, 0x748a, 0x4b89, 0x87, 0xf8, 0x76, 0xf, 0x6c, 0xc9, 0x3, 0xc0);

// {A06BDBAA-CC10-4e04-8C45-646CFB55E56E}
DEFINE_GUID( TASKID_Minor_HrConfigureResTypes_HrProcessResType,
0xa06bdbaa, 0xcc10, 0x4e04, 0x8c, 0x45, 0x64, 0x6c, 0xfb, 0x55, 0xe5, 0x6e);

// {13915CAB-E9E3-4e2c-8AEA-2EDDB6FB0589}
DEFINE_GUID( TASKID_Minor_HrProcessResType_CoCreate_ResTypeClsid,
0x13915cab, 0xe9e3, 0x4e2c, 0x8a, 0xea, 0x2e, 0xdd, 0xb6, 0xfb, 0x5, 0x89);

// {5E3C6D32-2631-4b13-8BDF-C644DC73EE2C}
DEFINE_GUID( TASKID_Minor_HrProcessResType_QI_pcci,
0x5e3c6d32, 0x2631, 0x4b13, 0x8b, 0xdf, 0xc6, 0x44, 0xdc, 0x73, 0xee, 0x2c);

// {264074E3-65E1-4d44-9A14-C4593C816F1F}
DEFINE_GUID( TASKID_Minor_HrProcessResType_Initialize,
0x264074e3, 0x65e1, 0x4d44, 0x9a, 0x14, 0xc4, 0x59, 0x3c, 0x81, 0x6f, 0x1f);

// {E01E4DBD-336F-40aa-B25B-708BB5EB2E62}
DEFINE_GUID( TASKID_Minor_HrProcessResType_GetTypeName,
0xe01e4dbd, 0x336f, 0x40aa, 0xb2, 0x5b, 0x70, 0x8b, 0xb5, 0xeb, 0x2e, 0x62);

// {5DC20322-81F1-4112-A1E9-C21B29CE11DA}
DEFINE_GUID( TASKID_Minor_HrProcessResType_AboutToConfigureType,
0x5dc20322, 0x81f1, 0x4112, 0xa1, 0xe9, 0xc2, 0x1b, 0x29, 0xce, 0x11, 0xda);

// {EE6D7073-3DCE-47c1-B6BC-5A70D5C07F8E}
DEFINE_GUID( TASKID_Minor_HrProcessResType_CommitChanges,
0xee6d7073, 0x3dce, 0x47c1, 0xb6, 0xbc, 0x5a, 0x70, 0xd5, 0xc0, 0x7f, 0x8e);

// {20952BFB-1BA0-4fa9-A29A-5AD71B917836}
DEFINE_GUID( TASKID_Minor_HrProcessResType_GetTypeGUID,
0x20952bfb, 0x1ba0, 0x4fa9, 0xa2, 0x9a, 0x5a, 0xd7, 0x1b, 0x91, 0x78, 0x36);

// {ADF325A5-1B9C-42eb-B450-E0982C13C145}
DEFINE_GUID( TASKID_Minor_HrProcessResType_HrMapResTypeGUIDToName,
0xadf325a5, 0x1b9c, 0x42eb, 0xb4, 0x50, 0xe0, 0x98, 0x2c, 0x13, 0xc1, 0x45);

// {2AC4FA49-4CFC-4abc-A501-B98A3FDB8FAD}
DEFINE_GUID( TASKID_Minor_HrProcessResType_NoGuid,
0x2ac4fa49, 0x4cfc, 0x4abc, 0xa5, 0x1, 0xb9, 0x8a, 0x3f, 0xdb, 0x8f, 0xad);

// {E6C5CB87-DB90-4ac7-AE72-1D33C009F11A}
DEFINE_GUID( TASKID_HrMapResTypeGUIDToName_InvalidArg,
0xe6c5cb87, 0xdb90, 0x4ac7, 0xae, 0x72, 0x1d, 0x33, 0xc0, 0x9, 0xf1, 0x1a);

// {905FE364-0D87-4196-A6BC-C380EA2E7162}
DEFINE_GUID( TASKID_HrMapResTypeGUIDToName_OutOfMemory_NewMap,
0x905fe364, 0xd87, 0x4196, 0xa6, 0xbc, 0xc3, 0x80, 0xea, 0x2e, 0x71, 0x62);

// {1CD5A0E3-A2F9-4981-87A6-B65F35EEDF0B}
DEFINE_GUID( TASKID_HrMapResTypeGUIDToName_OutOfMemory_TypeName,
0x1cd5a0e3, 0xa2f9, 0x4981, 0x87, 0xa6, 0xb6, 0x5f, 0x35, 0xee, 0xdf, 0xb);

// {B4AEF793-57B0-4ad5-ADCB-8D4778B55697}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_LoadString_LocateExistingQuorum,
0xb4aef793, 0x57b0, 0x4ad5, 0xad, 0xcb, 0x8d, 0x47, 0x78, 0xb5, 0x56, 0x97);

// {81A54EB8-B4C3-4390-982A-E6739D4D8D84}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_OutOfMemory,
0x81a54eb8, 0xb4c3, 0x4390, 0x98, 0x2a, 0xe6, 0x73, 0x9d, 0x4d, 0x8d, 0x84);

// {A42EFFD3-D165-4d05-81C5-201C43235CF9}
DEFINE_GUID( TASKID_Minor_HrGetCoreClusterResourceNames_GetResourceName,
0xa42effd3, 0xd165, 0x4d05, 0x81, 0xc5, 0x20, 0x1c, 0x43, 0x23, 0x5c, 0xf9);

// {8BE2BCE1-D605-4c5c-8D23-9F7BB90AD3E8}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetName,
0x8be2bce1, 0xd605, 0x4c5c, 0x8d, 0x23, 0x9f, 0x7b, 0xb9, 0xa, 0xd3, 0xe8);

// {7EB2D7B4-6FE9-45e1-AB7E-D2A325C44068}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetType,
0x7eb2d7b4, 0x6fe9, 0x45e1, 0xab, 0x7e, 0xd2, 0xa3, 0x25, 0xc4, 0x40, 0x68);

// {8587CA58-B046-42a6-8EE3-E7D6E23AC41B}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetClassType,
0x8587ca58, 0xb046, 0x42a6, 0x8e, 0xe3, 0xe7, 0xd6, 0xe2, 0x3a, 0xc4, 0x1b);

// {1AA31CCC-12A4-409b-925B-67FDF399BD61}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetFlags,
0x1aa31ccc, 0x12a4, 0x409b, 0x92, 0x5b, 0x67, 0xfd, 0xf3, 0x99, 0xbd, 0x61);

// {45148990-9648-4be0-8122-5B6FF302C7B7}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_IP_SetHResource,
0x45148990, 0x9648, 0x4be0, 0x81, 0x22, 0x5b, 0x6f, 0xf3, 0x2, 0xc7, 0xb7);

// {2364D4FD-BFF5-4ccd-A127-3AAD778652EB}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_LoadString_ClusterName,
0x2364d4fd, 0xbff5, 0x4ccd, 0xa1, 0x27, 0x3a, 0xad, 0x77, 0x86, 0x52, 0xeb);

// {DB491103-3EE8-4d31-9F91-478548C9828E}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetName,
0xdb491103, 0x3ee8, 0x4d31, 0x9f, 0x91, 0x47, 0x85, 0x48, 0xc9, 0x82, 0x8e);

// {1A1EB096-74B3-4169-A14A-73FE0F710E7F}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetType,
0x1a1eb096, 0x74b3, 0x4169, 0xa1, 0x4a, 0x73, 0xfe, 0xf, 0x71, 0xe, 0x7f);

// {B5C400E7-0827-473b-B4B7-697976E7DA96}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetClassType,
0xb5c400e7, 0x827, 0x473b, 0xb4, 0xb7, 0x69, 0x79, 0x76, 0xe7, 0xda, 0x96);

// {C973FCA2-3E37-4a30-8B27-CBAABFDB5699}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetFlags,
0xc973fca2, 0x3e37, 0x4a30, 0x8b, 0x27, 0xcb, 0xaa, 0xbf, 0xdb, 0x56, 0x99);

// {4022DB05-0EC7-4bbf-B47F-BE6017529B2D}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_AddTypeDependency,
0x4022db05, 0xec7, 0x4bbf, 0xb4, 0x7f, 0xbe, 0x60, 0x17, 0x52, 0x9b, 0x2d);

// {F72888A8-AB7D-4e69-B602-84A1B3F850EC}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Name_SetHResource,
0xf72888a8, 0xab7d, 0x4e69, 0xb6, 0x2, 0x84, 0xa1, 0xb3, 0xf8, 0x50, 0xec);

// {1382A7B9-9E7F-49dd-99B1-7B71520E716C}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetName,
0x1382a7b9, 0x9e7f, 0x49dd, 0x99, 0xb1, 0x7b, 0x71, 0x52, 0xe, 0x71, 0x6c);

// {6859B087-B309-4b23-A9F7-89B201DCA838}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetType,
0x6859b087, 0xb309, 0x4b23, 0xa9, 0xf7, 0x89, 0xb2, 0x1, 0xdc, 0xa8, 0x38);

// {5C696EBC-E7F1-4386-9898-5EB5507D1BCD}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetClassType,
0x5c696ebc, 0xe7f1, 0x4386, 0x98, 0x98, 0x5e, 0xb5, 0x50, 0x7d, 0x1b, 0xcd);

// {34F4E188-A8C4-4148-9735-50EEA7D01CF7}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetFlags,
0x34f4e188, 0xa8c4, 0x4148, 0x97, 0x35, 0x50, 0xee, 0xa7, 0xd0, 0x1c, 0xf7);

// {072BD24E-AECF-4b6a-A5CE-CBE87D205FDC}
DEFINE_GUID( TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetHResource,
0x72bd24e, 0xaecf, 0x4b6a, 0xa5, 0xce, 0xcb, 0xe8, 0x7d, 0x20, 0x5f, 0xdc);

// {989E8A0F-8303-4f90-A86E-AE98F0EE3FF6}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_SetName,
0x989e8a0f, 0x8303, 0x4f90, 0xa8, 0x6e, 0xae, 0x98, 0xf0, 0xee, 0x3f, 0xf6);

// {58878B7E-E298-48de-A2E5-C369A3FA4916}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_SetType,
0x58878b7e, 0xe298, 0x48de, 0xa2, 0xe5, 0xc3, 0x69, 0xa3, 0xfa, 0x49, 0x16);

// {AA216E27-79AB-4d91-99B6-EBE8608E08A2}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_SetClassType,
0xaa216e27, 0x79ab, 0x4d91, 0x99, 0xb6, 0xeb, 0xe8, 0x60, 0x8e, 0x8, 0xa2);

// {A482F18F-E935-4173-B5BE-72A2260BA118}
DEFINE_GUID( TASKID_Minor_HrAddSpecialResource_OutOfMemory,
0xa482f18f, 0xe935, 0x4173, 0xb5, 0xbe, 0x72, 0xa2, 0x26, 0xb, 0xa1, 0x18);

// {E7524063-8582-4e3e-85DA-0870546FBA78}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_GetName,
0xe7524063, 0x8582, 0x4e3e, 0x85, 0xda, 0x8, 0x70, 0x54, 0x6f, 0xba, 0x78);

// {365E90E9-EE39-4c5c-8F05-5D2F55F60CB1}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_CreateClusterResource,
0x365e90e9, 0xee39, 0x4c5c, 0x8f, 0x5, 0x5d, 0x2f, 0x55, 0xf6, 0xc, 0xb1);

// {80232E1F-A383-49dc-BC6F-FB5EC78591B4}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_CreateClusterResource_Successful,
0x80232e1f, 0xa383, 0x49dc, 0xbc, 0x6f, 0xfb, 0x5e, 0xc7, 0x85, 0x91, 0xb4);

// {48189324-673A-4fb6-9171-9C5939515EE1}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_FoundExistingResource,
0x48189324, 0x673a, 0x4fb6, 0x91, 0x71, 0x9c, 0x59, 0x39, 0x51, 0x5e, 0xe1);

// {9379E242-E26B-40ee-A025-0D3D7B525FD6}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_ChangeClusterResourceGroup,
0x9379e242, 0xe26b, 0x40ee, 0xa0, 0x25, 0xd, 0x3d, 0x7b, 0x52, 0x5f, 0xd6);

// {0466DF38-0715-43cf-B74D-6D055F316B1A}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_SetHResource,
0x466df38, 0x715, 0x43cf, 0xb7, 0x4d, 0x6d, 0x5, 0x5f, 0x31, 0x6b, 0x1a);

// {04B5E793-3A69-43e1-9FE8-8443FEAC725E}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_Configure,
0x4b5e793, 0x3a69, 0x43e1, 0x9f, 0xe8, 0x84, 0x43, 0xfe, 0xac, 0x72, 0x5e);

// {AC28D932-39DC-4504-A9E5-F650A12AABC5}
DEFINE_GUID( TASKID_Minor_HrCreateResourceInstance_LoadString_CreatingResource,
0xac28d932, 0x39dc, 0x4504, 0xa9, 0xe5, 0xf6, 0x50, 0xa1, 0x2a, 0xab, 0xc5);

// {F4A50885-A4B9-4c4d-B67C-9E4DD94A315E}
DEFINE_GUID( CLSID_TaskType,
0xf4a50885, 0xa4b9, 0x4c4d, 0xb6, 0x7c, 0x9e, 0x4d, 0xd9, 0x4a, 0x31, 0x5e);

// {FF5C9A64-4B2F-4f66-B20C-E0D1A5F29E2A}
DEFINE_GUID( TASKID_Minor_CreateGroups_Get_ClusterNameGroup,
0xff5c9a64, 0x4b2f, 0x4f66, 0xb2, 0xc, 0xe0, 0xd1, 0xa5, 0xf2, 0x9e, 0x2a);

// {008B56BA-4AAD-4250-9041-FB990433196D}
DEFINE_GUID( TASKID_Minor_PreCreate_EnumResources_IsLocalQuorum,
0x8b56ba, 0x4aad, 0x4250, 0x90, 0x41, 0xfb, 0x99, 0x4, 0x33, 0x19, 0x6d);

// {D3B10E74-4862-47ea-ABA5-E5E9CBA22662}
//DEFINE_GUID(
//0xd3b10e74, 0x4862, 0x47ea, 0xab, 0xa5, 0xe5, 0xe9, 0xcb, 0xa2, 0x26, 0x62);

// {4836C986-C2E9-4b30-9DDD-3F05DF4EDDA2}
//DEFINE_GUID(
//0x4836c986, 0xc2e9, 0x4b30, 0x9d, 0xdd, 0x3f, 0x5, 0xdf, 0x4e, 0xdd, 0xa2);

// {A1825B45-7C6C-44c2-AF59-F79F92B776F3}
//DEFINE_GUID(
//0xa1825b45, 0x7c6c, 0x44c2, 0xaf, 0x59, 0xf7, 0x9f, 0x92, 0xb7, 0x76, 0xf3);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <shlwapi.h>
#include <ComCat.h>
#include <commctrl.h>
#include <clusapi.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>

#include <ClusCfgGuids.h>
#include <ClusCfgServer.h>
#include <LoadString.h>
#include "PostCfgGuids.h"

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\postcfgmgr.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      PostCfgManager.h
//
//  Description:
//      CPostCfgManager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 09-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CPostCfgManager
//
//  Description:
//      The class CPostCfgManager inplements the PostCfgManager
//      interface.
//
//  Interfaces:
//      IPostCfgManager
//      IClusCfgInitialize
//      IClusCfgCallback
//
//--
//////////////////////////////////////////////////////////////////////////////
class
CPostCfgManager
    : public IPostCfgManager        // private
    , public IClusCfgInitialize
    , public IClusCfgCallback
{
private:
    //
    // Private types
    //

    // Stucture for one entry in the resource type GUID to resource type name map.
    struct SResTypeGUIDAndName
    {
        GUID            m_guidTypeGUID;
        WCHAR *         m_pszTypeName;
    }; //*** SResTypeGUIDAndName

    // IUnknown
    LONG                            m_cRef;                     //  Reference counter

    // Pointer to the callback interface.
    IClusCfgCallback *              m_pcccb;                    //  Callback to the client

    // The locale id
    LCID                            m_lcid;                     //  Local ID of the client

    //  IPostCfgManager
    IEnumClusCfgManagedResources *  m_peccmr;                   //  Enumer of managed resources
    IClusCfgClusterInfo *           m_pccci;                    //  Cluster configuration list
    ULONG                           m_cResources;               //  Count of resources in list
    ULONG                           m_cAllocedResources;        //  Count of alloc'ed resources
    CResourceEntry **               m_rgpResources;             //  List of pointers to Resource Entries
    ULONG                           m_idxIPAddress;             //  Cluster IP Address resource index
    ULONG                           m_idxClusterName;           //  Cluster Name resource index
    ULONG                           m_idxQuorumResource;        //  Quorum resource index
    ULONG                           m_idxLastStorage;           //  Last storage resource examined
    HCLUSTER                        m_hCluster;                 //  Cluster handle
    ULONG                           m_cNetName;                 //  Net Name instance counter
    ULONG                           m_cIPAddress;               //  IP Address instance counter
    SResTypeGUIDAndName *           m_pgnResTypeGUIDNameMap;    //  Map between resource type GUID and its name
    ULONG                           m_idxNextMapEntry;          //  Index of the first free map entry
    ULONG                           m_cMapSize;                 //  Count of the number of elements in the map buffer.
    DWORD                           m_dwLocalQuorumStatusMax;   // The max of the status report range for local quorum deletion.
    ECommitMode                     m_ecmCommitChangesMode;     // What are we doing, create cluster, adding nodes, or cleaning up?
    BOOL                            m_isQuorumChanged:1;        // Set this flag if a better quorum resource has been found.
    BSTR                            m_bstrNodeName;

private: // Methods
    CPostCfgManager( void );
    ~CPostCfgManager( void );

    // Private copy constructor to prevent copying.
    CPostCfgManager( const CPostCfgManager & nodeSrc );

    // Private assignment operator to prevent copying.
    const CPostCfgManager & operator = ( const CPostCfgManager & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrPreCreateResources( void );
    HRESULT HrCreateGroups( void );
    HRESULT HrCreateResources( void );
    HRESULT HrPostCreateResources( void );
    HRESULT HrFindNextSharedStorage( ULONG * pidxInout );
    HRESULT HrAttemptToAssignStorageToResource( ULONG idxResourceIn, EDependencyFlags dfResourceFlagsIn );
    HRESULT HrMovedDependentsToAnotherResource( ULONG idxSourceIn, ULONG idxDestIn );
    HRESULT HrSetGroupOnResourceAndItsDependents( ULONG idxResourceIn, CGroupHandle * pghIn );
    HRESULT HrFindGroupFromResourceOrItsDependents( ULONG idxResourceIn, CGroupHandle ** pghOut );
    HRESULT HrCreateResourceAndDependents( ULONG idxResourceIn );
    HRESULT HrPostCreateResourceAndDependents( ULONG idxResourceIn );
    HRESULT HrPreInitializeExistingResources( void );
    HRESULT HrAddSpecialResource( BSTR  bstrNameIn, const CLSID * pclsidTypeIn, const CLSID * pclsidClassTypeIn );
    HRESULT HrCreateResourceInstance( ULONG idxResourceIn, HGROUP hGroupIn, LPCWSTR pszResTypeIn, HRESOURCE * phResourceOut );
    HRESULT HrGetCoreClusterResourceNames(
                                      BSTR *        pbstrClusterNameResourceNameOut
                                    , HRESOURCE *   phClusterNameResourceOut
                                    , BSTR *        pbstrClusterIPAddressNameOut
                                    , HRESOURCE *   phClusterIPAddressResourceOut
                                    , BSTR *        pbstrClusterQuorumResourceNameOut
                                    , HRESOURCE *   phClusterQuorumResourceOut
                                    );
    //HRESULT HrIsLocalQuorum( BSTR  bstrNameIn );

    // Enumerate all components on the local computer registered for resource type
    // configuration.
    HRESULT HrConfigureResTypes( IUnknown * punkResTypeServicesIn );

    // Instantiates a resource type configuration component and calls the appropriate methods.
    HRESULT HrProcessResType( const CLSID & rclsidResTypeCLSIDIn, IUnknown * punkResTypeServicesIn );

    // Notify all components on the local computer registered to get
    // notification of cluster member set change (create, add node or evict).
    HRESULT HrNotifyMemberSetChangeListeners( void );

    // Instantiates cluster member set change listener and notifies it.
    HRESULT HrProcessMemberSetChangeListener( const CLSID & rclsidListenerClsidIn );

    // Create a mapping between a resource type GUID and a resource type name.
    HRESULT HrMapResTypeGUIDToName( const GUID & rcguidTypeGuidIn, const WCHAR * pcszTypeNameIn );

    //  Given a resource type GUID this function finds the resource type name if any.
    const WCHAR * PcszLookupTypeNameByGUID( const GUID & rcguidTypeGuidIn );

    // Callback function used to delete the local quorum resource.
    static DWORD S_DwDeleteLocalQuorumResource( HCLUSTER hClusterIn , HRESOURCE hSelfIn, HRESOURCE hCurrentResourceIn, PVOID pvParamIn );

#if defined(DEBUG)
    void
        DebugDumpDepencyTree( void );
#endif // DEBUG

public: // Methods
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IPostCfgManager - private
    STDMETHOD( CommitChanges )( IEnumClusCfgManagedResources * peccmrIn, IClusCfgClusterInfo * pccciIn );

    //  IClusCfgInitialize
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** Class CPostCfgManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\postcfgmgr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      PostCfgManager.cpp
//
//  Description:
//      CPostCfgManager implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)     09-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "guids.h"
#include "clusudef.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPostCfgManager.h"
#include "IPrivatePostCfgResource.h"
#include "PostCfgMgr.h"
#include "CreateServices.h"
#include "PostCreateServices.h"
#include "PreCreateServices.h"
#include "ResTypeServices.h"
#include "..\Wizard\Resource.h"
#include "PostCfgResources.h"
#include "ClusCfgPrivate.h"
#include <ResApi.h>
#include <ClusterUtils.h>

DEFINE_THISCLASS("CPostCfgManager")

#define RESOURCE_INCREMENT  25

//
//  Failure code.
//

#define SSR_LOG_ERR( _major, _minor, _hr, _msg ) \
    {   \
        THR( SendStatusReport( m_bstrNodeName, _major, _minor, 0, 0, 0, _hr, _msg, NULL, NULL ) );   \
    }

#define SSR_LOG1( _major, _minor, _hr, _fmt, _bstr, _arg1 ) \
    {   \
        HRESULT hrTemp; \
        THR( HrFormatStringIntoBSTR( _fmt, &_bstr, _arg1 ) ); \
        hrTemp = THR( SendStatusReport( NULL, _major, _minor, 0, 1, 1, _hr, _bstr, NULL, NULL ) );   \
        if ( FAILED( hrTemp ) )\
        {   \
            _hr = hrTemp;   \
        }   \
    }

#define SSR_LOG2( _major, _minor, _hr, _fmt, _bstr, _arg1, _arg2 ) \
    {   \
        HRESULT hrTemp; \
        THR( HrFormatStringIntoBSTR( _fmt, &_bstr, _arg1, _arg2 ) ); \
        hrTemp = THR( SendStatusReport( NULL, _major, _minor, 0, 1, 1, _hr, _bstr, NULL, NULL ) );   \
        if ( FAILED( hrTemp ) )\
        {   \
            _hr = hrTemp;   \
        }   \
    }


//
// Structure that holds the mapping for well known resource types.
//

struct SResTypeGUIDPtrAndName
{
    const GUID *    m_pcguidTypeGUID;
    const WCHAR *   m_pszTypeName;
};


// Mapping of well known resource type GUIDs to the type names.
const SResTypeGUIDPtrAndName gc_rgWellKnownResTypeMap[] =
{
    {
        &RESTYPE_PhysicalDisk,
        CLUS_RESTYPE_NAME_PHYS_DISK
    },
    {
        &RESTYPE_IPAddress,
        CLUS_RESTYPE_NAME_IPADDR
    },
    {
        &RESTYPE_NetworkName,
        CLUS_RESTYPE_NAME_NETNAME
    },
    {
        &RESTYPE_LocalQuorum,
        CLUS_RESTYPE_NAME_LKQUORUM
    }
};

// Size of the above array.
const int gc_cWellKnownResTypeMapSize = sizeof( gc_rgWellKnownResTypeMap ) / sizeof( gc_rgWellKnownResTypeMap[ 0 ] );


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( ppunkOut != NULL );

    CPostCfgManager * pPostCfgManager = new CPostCfgManager;
    if ( pPostCfgManager != NULL )
    {
        hr = THR( pPostCfgManager->HrInit() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pPostCfgManager->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pPostCfgManager->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
//  CPostCfgManager::CPostCfgManager( void )
//
//////////////////////////////////////////////////////////////////////////////
CPostCfgManager::CPostCfgManager( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CPostCfgManager()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrInit( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrInit( void )
{
    TraceFunc( "" );

    ULONG idxMapEntry;

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef();    // Add one count

    Assert( m_pcccb == NULL );
    Assert( m_lcid == 0 );

    //  IPostCfgManager
    Assert( m_peccmr == NULL );
    Assert( m_pccci == NULL );

    Assert( m_cAllocedResources == 0 );
    Assert( m_cResources == 0 );
    Assert( m_rgpResources == NULL );

    Assert( m_idxIPAddress == 0 );
    Assert( m_idxClusterName == 0 );
    Assert( m_idxQuorumResource == 0 );
    Assert( m_idxLastStorage == 0 );

    Assert( m_hCluster == NULL );

    Assert( m_pgnResTypeGUIDNameMap == NULL );
    Assert( m_idxNextMapEntry == 0 );
    Assert( m_cMapSize == 0 );
    Assert( m_ecmCommitChangesMode == cmUNKNOWN );

    m_cNetName = 1;
    m_cIPAddress = 1;

    // Set the boolean flag, m_isQuorumChanged to false;
    m_isQuorumChanged = false;


    //  Default allocation for mappings
    m_cMapSize = 20;
    m_pgnResTypeGUIDNameMap = new SResTypeGUIDAndName[ m_cMapSize ];
    if ( m_pgnResTypeGUIDNameMap == NULL )
        goto OutOfMemory;

    // Prefill the resource type GUID to name map with well known entries.
    for ( idxMapEntry = 0; idxMapEntry < gc_cWellKnownResTypeMapSize; ++idxMapEntry )
    {
        hr = THR(
            HrMapResTypeGUIDToName(
                  *gc_rgWellKnownResTypeMap[ idxMapEntry ].m_pcguidTypeGUID
                , gc_rgWellKnownResTypeMap [ idxMapEntry ].m_pszTypeName
                )
            );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_Init_MapResTypeGuidToName
                , hr
                , L""
                );
            break;
        } // if: there was an error creating a mapping
    }

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName ) );

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_LOG_ERR(
          TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_Init_OutOfMemory
        , hr
        , L"Out of memory"
        );
    goto Cleanup;

} // HrInit()

//////////////////////////////////////////////////////////////////////////////
//
//  CPostCfgManager::~CPostCfgManager()
//
//////////////////////////////////////////////////////////////////////////////
CPostCfgManager::~CPostCfgManager( void )
{
    TraceFunc( "" );

    ULONG idxMapEntry;

    if ( m_peccmr != NULL )
    {
        m_peccmr->Release();
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_pccci != NULL )
    {
        m_pccci->Release();
    }

    if ( m_rgpResources != NULL )
    {
        while ( m_cAllocedResources  != 0 )
        {
            m_cAllocedResources --;

            if ( m_rgpResources[ m_cAllocedResources ] != NULL )
            {
                delete m_rgpResources[ m_cAllocedResources ];
            }
        }

        TraceFree( m_rgpResources );
    }

    if ( m_hCluster != NULL )
    {
        CloseCluster( m_hCluster );
    }

    // Free the resource type GUID to name map entries
    for ( idxMapEntry = 0; idxMapEntry < m_idxNextMapEntry; ++idxMapEntry )
    {
        delete m_pgnResTypeGUIDNameMap[ idxMapEntry ].m_pszTypeName;
    } // for: iterate through the map, freeing each entry

    // Free the map itself.
    delete [] m_pgnResTypeGUIDNameMap;

    TraceSysFreeString( m_bstrNodeName );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CPostCfgManager()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CPostCfgManager::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPostCfgManager::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IPostCfgManager * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IPostCfgManager ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IPostCfgManager, this, 0 );
        hr   = S_OK;
    } // else if: IPostCfgManager
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgInitialize
    else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgInitialize

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN( hr, riid );

} // QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPostCfgManager::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CPostCfgManager::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef++;   // apartment object

    RETURN( m_cRef );

} // AddRef()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPostCfgManager::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CPostCfgManager::Release( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef--;   // apartment object

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release()


//****************************************************************************
//
//  IClusCfgInitialize
//
//****************************************************************************


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPostCfgManager::Initialize()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPostCfgManager::Initialize(
      IUnknown *   punkCallbackIn
    , LCID         lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT hr = S_OK;

    IClusCfgCallback * pcccb = NULL;

    if ( punkCallbackIn != NULL )
    {
        hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &pcccb ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_Initialize_QI, hr, L"" );
            goto Cleanup;
        }
    }

    m_lcid = lcidIn;

    //  Release any previous callback.
    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    //  Give ownership away
    m_pcccb = pcccb;
    pcccb = NULL;

#if defined(DEBUG)
    if ( m_pcccb != NULL )
    {
        m_pcccb = TraceInterface( L"CPostCfgManager!IClusCfgCallback", IClusCfgCallback, m_pcccb, 1 );
    }
#endif // DEBUG

Cleanup:
    if ( pcccb != NULL )
    {
        pcccb->Release();
    }

    HRETURN( hr );

} //*** CPostCfgManager::Initialize()


//****************************************************************************
//
//  IPostCfgManager
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CPostCfgManager::CommitChanges(
//      IEnumClusCfgManagedResources    * peccmrIn,
//      IClusCfgClusterInfo *             pccciIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPostCfgManager::CommitChanges(
    IEnumClusCfgManagedResources    * peccmrIn,
    IClusCfgClusterInfo *             pccciIn
    )
{
    TraceFunc( "[IPostCfgManager]" );

    HRESULT                                 hr;
    DWORD                                   dw;
    IClusCfgResTypeServicesInitialize *     pccrtsiResTypeServicesInit = NULL;

    //  Validate parameters
    Assert( peccmrIn != NULL );
    Assert( pccciIn != NULL );

    //
    //  Grab our interfaces.
    //

    if ( m_peccmr != NULL )
    {
        m_peccmr->Release();
    }
    hr = THR( peccmrIn->TypeSafeQI( IEnumClusCfgManagedResources, &m_peccmr ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_CommitChanges_QI_Resources, hr, L"" );
        goto Cleanup;
    }

    if ( m_pccci != NULL )
    {
        m_pccci->Release();
    }
    hr = THR( pccciIn->TypeSafeQI( IClusCfgClusterInfo, &m_pccci ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_CommitChanges_QI_ClusterInfo, hr, L"" );
        goto Cleanup;
    }

    //
    // Are we creating, adding nodes, or have we been evicted?
    //

    hr = STHR( pccciIn->GetCommitMode( &m_ecmCommitChangesMode ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_CommitChanges_GetCommitMode, hr, L"" );
        goto Cleanup;
    }

    //
    // Create an instance of the resource type services component
    //
    hr = THR(
        CoCreateInstance(
              CLSID_ClusCfgResTypeServices
            , NULL
            , CLSCTX_INPROC_SERVER
            , __uuidof( pccrtsiResTypeServicesInit )
            , reinterpret_cast< void ** >( &pccrtsiResTypeServicesInit )
            )
        );

    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                     TASKID_Minor_CommitChanges_CoCreate_ResTypeService,
                     hr,
                     L"[PostCfg] Error occurred trying to create the resource type services component"
                     );
        goto Cleanup;
    } // if: we could not create the resource type services component

    // Initialize the resource type services component.
    hr = THR( pccrtsiResTypeServicesInit->SetParameters( m_pccci ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                     TASKID_Minor_CommitChanges_SetParameters,
                     hr,
                     L"[PostCfg] Error occurred trying to initialize the resource type services component."
                     );
        goto Cleanup;
    } // if: we could not initialize the resource type services component

    if ( ( m_ecmCommitChangesMode == cmCREATE_CLUSTER ) || ( m_ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER ) )
    {
        //
        //  Make sure we have all we need to be successful!
        //

        if ( m_hCluster == NULL )
        {
            m_hCluster = OpenCluster( NULL );
            if ( m_hCluster == NULL )
            {
                dw = GetLastError();
                hr = HRESULT_FROM_WIN32( TW32( dw ) );

                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                             TASKID_Minor_CommitChanges_OpenCluster,
                             hr,
                             L"[PostCfg] Failed to get cluster handle. Aborting."
                             );

                goto Cleanup;
            }
        }

        //
        // Configure resource types.
        //
        hr = THR( HrConfigureResTypes( pccrtsiResTypeServicesInit ) );
        if ( FAILED( hr ) )
           goto Cleanup;

        //
        //  Create the resource instances.
        //

        hr = THR( HrPreCreateResources() );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( HrCreateGroups() );
        if ( FAILED( hr ) )
        {
            //
            //  MUSTDO: gpease  28-SEP-2000
            //          For Beta1 will we ignore errors in group creation
            //          and abort the process.
            //
            hr = S_OK;
            goto Cleanup;
        }

        hr = THR( HrCreateResources() );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( HrPostCreateResources() );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        // Notify any components registered on this computer, of a cluster
        // member set change ( form, join or evict ).
        //
        hr = THR( HrNotifyMemberSetChangeListeners() );
        if ( FAILED( hr ) )
           goto Cleanup;

    } // if: we are forming or joining
    else if ( m_ecmCommitChangesMode == cmCLEANUP_NODE_AFTER_EVICT )
    {
        //
        // Notify any components registered on this computer, of a cluster
        // member set change ( form, join or evict ).
        //
        hr = THR( HrNotifyMemberSetChangeListeners() );
        if ( FAILED( hr ) )
           goto Cleanup;

        // ISSUE MUSTDO: Decide if we need to add evict processing for managed resources here. ( 03-AUG-2000 Vij Vasu )

        //
        // Configure resource types.
        //
        hr = THR( HrConfigureResTypes( pccrtsiResTypeServicesInit ) );
        if ( FAILED( hr ) )
           goto Cleanup;

    } // else if: we have just been evicted

Cleanup:

    if ( pccrtsiResTypeServicesInit != NULL )
    {
        pccrtsiResTypeServicesInit->Release();
    } // if: we had created the resource type services component

    HRETURN( hr );

} // CommitChanges()



//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************

STDMETHODIMP
CPostCfgManager::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;
    FILETIME    ft;

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    if ( m_pcccb != NULL )
    {
        hr = STHR( m_pcccb->SendStatusReport( pcszNodeNameIn != NULL ? pcszNodeNameIn : m_bstrNodeName,
                                              clsidTaskMajorIn,
                                              clsidTaskMinorIn,
                                              ulMinIn,
                                              ulMaxIn,
                                              ulCurrentIn,
                                              hrStatusIn,
                                              pcszDescriptionIn,
                                              pftTimeIn,
                                              pcszReferenceIn
                                              ) );
    }

    HRETURN( hr );

} // SendStatusReport()

//****************************************************************************
//
//  Private methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrPreCreateResources( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrPreCreateResources( void )
{
    TraceFunc( "" );

    CResourceEntry * presentry;

    HRESULT hr = E_UNEXPECTED;

    BSTR    bstrName         = NULL;
    BSTR    bstrNotification = NULL;

    IClusCfgManagedResourceInfo *   pccmri       = NULL;
    IClusCfgManagedResourceCfg *    pccmrc       = NULL;
    IUnknown *                      punkServices = NULL;
    IPrivatePostCfgResource *       ppcr         = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    LogMsg( "PostCfg: Starting pre-create..." );

    hr = THR( HrPreInitializeExistingResources() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Make sure the enumer is in the state we think it is.
    //

    hr = STHR( m_peccmr->Reset() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_PreCreate_Reset, hr, L"" );
        goto Cleanup;
    }

    hr = THR( CPreCreateServices::S_HrCreateInstance( &punkServices ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                     TASKID_Minor_PreCreate_CPreCreateServices,
                     hr,
                     L"[PreCreate] Failed to create services object. Aborting."
                     );
        goto Cleanup;
    }

    hr = THR( punkServices->TypeSafeQI( IPrivatePostCfgResource, &ppcr ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                     TASKID_Minor_PreCreate_CPreCreateServices_QI,
                     hr,
                     L"[PreCreate] Failed to create services object. Aborting."
                     );
        goto Cleanup;
    }

    //
    //  Update the UI layer.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_QUERYING_FOR_RESOURCE_DEPENDENCIES, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_PreCreate_LoadString_Querying, hr, L"" );
        goto Cleanup;
    }

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Querying_For_Resource_Dependencies,
                                0,
                                5,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
    // ignore failure

    //
    //  Loop thru the resources, requesting the resources to PreCreate()
    //  themselves. This will cause the resources to callback into the
    //  services object and store class type and resource type information
    //  as well as any required dependencies the resource might have.
    //

    for( ;; )
    {
        //
        //  Cleanup. We put this here because of error conditions below.
        //
        TraceSysFreeString( bstrName );
        bstrName = NULL;

        if ( pccmri != NULL )
        {
            pccmri->Release();
            pccmri = NULL;
        }
        if ( pccmrc != NULL )
        {
            pccmrc->Release();
            pccmrc = NULL;
        }

        //
        //  Ask to get the next resource.
        //

        hr = STHR( m_peccmr->Next( 1, &pccmri, NULL ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_PreCreate_EnumResources_Next,
                         hr,
                         L"[PreCreate] Getting next managed resource failed. Aborting."
                         );
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit loop
        }

        //
        //  Retrieve its name for logging, etc. We will ultimately store this in the
        //  resource entry to be reused (ownership will be transferred).
        //

        hr = THR( pccmri->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                     TASKID_Minor_PreCreate_EnumResources_GetName,
                     hr,
                     L"[PreCreate] Failed to retrieve a resource's name. Skipping."
                     );
            continue;
        }

        //
        //  Check to see if the resource wants to be managed or not.
        //

        hr = STHR( pccmri->IsManaged() );
        if ( FAILED( hr ) )
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_PreCreate_EnumResources_IsManaged,
                      hr,
                      L"[PreCreate] %1!ws!: Failed determine if it is to be managed. Skipping.",
                      bstrNotification,
                      bstrName
                      );
            continue;
        }

        if ( hr == S_FALSE )
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_PreCreate_EnumResources_IsManaged_False,
                      hr,
                      L"[PreCreate] %1!ws!: Resource does not want to be managed. Skipping.",
                      bstrNotification,
                      bstrName
                      );
            continue;
        }
/*
        hr = STHR( HrIsLocalQuorum( bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_PreCreate_EnumResources_IsLocalQuorum,
                      hr,
                      L"Error occured trying to determine if the resource was the local quorum resource.",
                      bstrNotification,
                      bstrName
                      );
            continue;
        } // if:

        //
        //  Ignore the local quorum resource since it is special and won't need its own group.
        //
        if ( hr == S_OK )
        {
            continue;
        } // if:
*/
        //
        //  Get the config interface for this resource (if any).
        //

        hr = THR( pccmri->TypeSafeQI( IClusCfgManagedResourceCfg, &pccmrc ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_PreCreate_EnumResources_QI_pccmrc,
                      hr,
                      L"[PreCreate] %1!ws!: Failed QI for IClusCfgManagedResourceCfg. Skipping.",
                      bstrNotification,
                      bstrName
                      );
            continue;
        }

        //
        //  Grow the resource list if nessecary.
        //

        if ( m_cResources == m_cAllocedResources )
        {
            ULONG   idxNewCount = m_cAllocedResources + RESOURCE_INCREMENT;
            CResourceEntry ** plistNew;

            plistNew = (CResourceEntry **) TraceAlloc( 0, sizeof( CResourceEntry *) * idxNewCount );
            if ( plistNew == NULL )
                goto OutOfMemory;

            CopyMemory( plistNew, m_rgpResources, sizeof(CResourceEntry *) * m_cAllocedResources );
            TraceFree( m_rgpResources );
            m_rgpResources = plistNew;

            for ( ; m_cAllocedResources < idxNewCount; m_cAllocedResources ++ )
            {
                m_rgpResources[ m_cAllocedResources ] = new CResourceEntry();
                if ( m_rgpResources[ m_cAllocedResources ] == NULL )
                    goto OutOfMemory;
            }
        }

        //
        //  Check to see if this resource is the quorum resource. If it is, point the services
        //  object to the quorum resource entry (m_idxQuorumResource).
        //

        hr = STHR( pccmri->IsQuorumDevice() );
        if ( hr == S_OK )
        {
            presentry = m_rgpResources[ m_idxQuorumResource ];

            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_PreCreate_EnumResources_IsQuorumDevice_S_OK,
                      hr,
                      L"[PreCreate] %1!ws!: Setting this resource to be the quorum device.",
                      bstrNotification,
                      bstrName
                      );

            //
            //  We need to release the previous quorum's resource handle.
            //

            THR( presentry->SetHResource( NULL ) );
            //  We don't care if this fails... we'll overwrite it later.

            // Set the quorum changed flag here.
            m_isQuorumChanged = true;
        }
        else
        {
            presentry = m_rgpResources[ m_cResources ];

            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_PreCreate_EnumResources_IsQuorumDevice_Failed
                    , hr
                    , L""
                    );
            }
        }

        //
        //  Setup the new entry.
        //

        hr = THR( presentry->SetAssociatedResource( pccmrc ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_PreCreate_EnumResources_SetAssociatedResouce
                , hr
                , L""
                );
            continue;
        }

        hr = THR( presentry->SetName( bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_PreCreate_EnumResources_SetName, hr, L"" );
            continue;
        }

        //  We gave ownership away when we called SetName() above.
        bstrName = NULL;

        //
        //  Point the PreCreate services to the resource entry.
        //

        hr = THR( ppcr->SetEntry( presentry ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_PreCreate_EnumResources_SetEntry, hr, L"" );
            continue;
        }

        //
        //  Ask the resource to configure itself. Every resource that wants to be
        //  created in the default cluster must implement PreCreate(). Those that
        //  return E_NOTIMPL will be ignored.
        //

        //  Don't wrap - this can fail with E_NOTIMPL.
        hr = pccmrc->PreCreate( punkServices );
        if ( FAILED( hr ) )
        {
            if ( hr == E_NOTIMPL )
            {
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_PreCreate_PreCreate_E_NOTIMPL,
                          hr,
                          L"[PreCreate] %1!ws!: Failed. Resource returned E_NOTIMPL. This resource will not be created. Skipping.",
                          bstrNotification,
                          bstrName
                          );
            }
            else
            {
                HRESULT hrStored = MAKE_HRESULT( 0, HRESULT_FACILITY( hr ), HRESULT_CODE( hr ) );

                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_Resource_Failed_PreCreate,
                          hr,
                          L"%1!ws! failed PreCreate( ).",
                          bstrNotification,
                          bstrName
                          );

                hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_RESOURCE_FAILED_PRECREATE, &bstrNotification ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_PreCreate_LoadString_Resource_Failed
                        , hr
                        , L""
                        );
                    goto Cleanup;
                }

                hr = THR( SendStatusReport( NULL,
                                            TASKID_Major_Configure_Resources,
                                            TASKID_Minor_Resource_Failed_PreCreate,
                                            0,
                                            1,
                                            1,
                                            hrStored,
                                            bstrNotification,
                                            NULL,
                                            NULL
                                            ) );
                if ( hr == E_ABORT )
                    goto Cleanup;
                    //  ignore failure
            }

            continue;
        }

        if ( presentry != m_rgpResources[ m_idxQuorumResource ] )
        {
            m_cResources ++;
        }

        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                  TASKID_Minor_PreCreate_Succeeded,
                  hr,
                  L"[PreCreate] %1!ws!: Succeeded.",
                  bstrNotification,
                  bstrName
                  );

    } // for: ever

    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
              TASKID_Minor_PreCreate_Finished,
              hr,
              L"[PreCreate] Finished.",
              bstrNotification,
              bstrName
              );

#if defined(DEBUG)
    // DebugDumpDepencyTree();
#endif

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Querying_For_Resource_Dependencies,
                                0,
                                5,
                                5,
                                S_OK,
                                NULL,    // don't need to update string
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
    //  ignore failure

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrName );

    if ( pccmri != NULL )
    {
        pccmri->Release();
    }
    if ( pccmrc != NULL )
    {
        pccmrc->Release();
    }
    if ( punkServices != NULL )
    {
        punkServices->Release();
    }
    if ( ppcr != NULL )
    {
        ppcr->Release();
    }

    HRETURN( hr );

OutOfMemory:
    LogMsg( "PostCfg: Out of memory. Aborting." );
    hr = THR( E_OUTOFMEMORY );
    goto Cleanup;

} // HrPreCreateResources()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrCreateGroups( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrCreateGroups( void )
{
    TraceFunc( "" );

    DWORD   dwTypeDummy;
    DWORD   dwStatus;

    WCHAR           szGroupName[ 128 ];
    ULONG           cchGroupName;
    ULONG           cGroup;
    HGROUP          hGroup = NULL;
    CGroupHandle *  pgh = NULL;

    ULONG           idxResource;
    ULONG           idxMatchDepedency;
    ULONG           idxMatchResource;

    const CLSID *       pclsidType;
    const CLSID *       pclsidClassType;
    EDependencyFlags    dfFlags;
    CResourceEntry *    presentry;

    HRESULT hr = E_UNEXPECTED;

    HCLUSENUM   hClusEnum = NULL;
    BSTR        bstrGroupName = NULL;
    BSTR        bstrNotification = NULL;
    BSTR        bstrClusterNameGroup = NULL;

    DWORD                   sc;
    HRESOURCE               hClusterNameResource = NULL;
    CLUSTER_RESOURCE_STATE  crs;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    Assert( m_idxLastStorage == 0 );

    m_idxLastStorage = m_idxQuorumResource;

    //
    //  Phase 1: Figure out the dependency tree.
    //

    hr = S_OK;
    SSR_LOG_ERR(
          TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_CreateGroups_Begin
        , hr
        , L"[Grouping] Figuring out dependency tree to determine grouping."
        );

    for ( idxResource = 0; idxResource < m_cResources; idxResource ++ )
    {
        CResourceEntry * presentryResource = m_rgpResources[ idxResource ];
        ULONG cDependencies;

        hr = THR( presentryResource->GetCountOfTypeDependencies( &cDependencies ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_CreateGroups_GetCountOfTypeDependencies
                , hr
                , L""
                );
            continue;
        }

        for ( idxMatchDepedency = 0; idxMatchDepedency < cDependencies; idxMatchDepedency ++ )
        {
            BOOL             fFoundMatch        = FALSE;
            const CLSID *    pclsidMatchType;
            EDependencyFlags dfMatchFlags;

            hr = THR( presentryResource->GetTypeDependencyPtr( idxMatchDepedency,
                                                               &pclsidMatchType,
                                                               &dfMatchFlags
                                                               ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log, TASKID_Minor_CreateGroups_GetTypeDependencyPtr, hr, L"" );
                continue;
            }

            //
            //  See if it is one of the "well known" types.
            //

            //
            //  We special case storage class device because we want to spread as many
            //  resources across as many storage devices as possible. This helps prevent
            //  the ganging of resources into one large group.
            //

            if ( *pclsidMatchType == RESCLASSTYPE_StorageDevice )
            {
                //
                //  The below THR may fire in certain configurations. Please validate
                //  the configuration before removing the THR.
                //
                //  If it returns E_FAIL, we should fall thru and attempt "normal"
                //  resource negociations.
                //
                hr = THR( HrAttemptToAssignStorageToResource( idxResource, dfMatchFlags ) );
                if ( SUCCEEDED( hr ) )
                {
                    fFoundMatch = TRUE;
                }
                else if ( FAILED( hr ) )
                {
                    if ( hr != E_FAIL )
                    {
                        goto Cleanup;
                    }
                }
            }
            else if ( *pclsidMatchType == RESCLASSTYPE_NetworkName )
            {
                BSTR    bstrName = NULL;

                hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_NETNAMEFORMAT, &bstrName, m_cNetName ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                                 TASKID_Minor_CreateGroups_FormatString_NetName,
                                 hr,
                                 L"[Grouping] Failed to create name for net name resource. Aborting."
                                 );
                    goto Cleanup;
                }

                hr = THR( HrAddSpecialResource( bstrName,
                                                &RESTYPE_NetworkName,
                                                &RESCLASSTYPE_NetworkName
                                                ) );
                if ( FAILED( hr ) )
                    continue;

                presentry = m_rgpResources[ m_cResources - 1 ];

                //  Net name depends on an IP address.
                hr = THR( presentry->AddTypeDependency( &RESCLASSTYPE_IPAddress, dfSHARED ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_AddTypeDependency
                        , hr
                        , L""
                        );
                    continue;
                }

                fFoundMatch = TRUE;

            }
            else if ( *pclsidMatchType == RESCLASSTYPE_IPAddress )
            {
                BSTR    bstrName = NULL;

                hr = THR( HrFormatStringIntoBSTR( g_hInstance,
                                                  IDS_IPADDRESSFORMAT,
                                                  &bstrName,
                                                  FIRST_IPADDRESS( m_cIPAddress ),
                                                  SECOND_IPADDRESS( m_cIPAddress ),
                                                  THIRD_IPADDRESS( m_cIPAddress ),
                                                  FOURTH_IPADDRESS( m_cIPAddress )
                                                  ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                                 TASKID_Minor_CreateGroups_FormatString_IPAddress,
                                 hr,
                                 L"[Grouping] Failed to create name for IP address resource. Aborting."
                                 );
                    goto Cleanup;
                }

                hr = THR( HrAddSpecialResource( bstrName, &RESTYPE_IPAddress, &RESCLASSTYPE_IPAddress ) );
                if ( FAILED( hr ) )
                    continue;

                m_cIPAddress ++;

                fFoundMatch = TRUE;
            }
            else if ( *pclsidMatchType == RESTYPE_ClusterNetName )
            {
                presentry = m_rgpResources[ m_idxClusterName ];

                hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_NetName_AddDependent
                        , hr
                        , L""
                        );
                    continue;
                }

                fFoundMatch = TRUE;
            }
            else if ( *pclsidMatchType == RESTYPE_ClusterIPAddress )
            {
                presentry = m_rgpResources[ m_idxIPAddress ];

                hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_IPAddress_AddDependent
                        , hr
                        , L""
                        );
                    continue;
                }

                fFoundMatch = TRUE;
            }
            else if ( *pclsidMatchType == RESTYPE_ClusterQuorumDisk )
            {
                presentry = m_rgpResources[ m_idxQuorumResource ];

                hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_QuorumDisk_AddDependent
                        , hr
                        , L""
                        );
                    continue;
                }

                fFoundMatch = TRUE;
            }

            //
            //  Check out the resources to see if it matches any of them.
            //

            if ( !fFoundMatch )
            {
                //
                //  We can always start at the quorum resource because the resource with indexes
                //  below that are handled in the special case code above.
                //

                for ( idxMatchResource = m_idxQuorumResource; idxMatchResource < m_cResources; idxMatchResource ++ )
                {
                    presentry = m_rgpResources[ idxMatchResource ];

                    hr = THR( presentry->GetTypePtr( &pclsidType ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_CreateGroups_GetTypePtr
                            , hr
                            , L""
                            );
                        continue;
                    }

                    hr = THR( presentry->GetClassTypePtr( &pclsidClassType ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_CreateGroups_GetClassTypePtr
                            , hr
                            , L""
                            );
                        continue;
                    }

                    hr = THR( presentry->GetFlags( &dfFlags ) );
                    if ( FAILED( hr ) )
                    {
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_CreateGroups_GetFlags
                            , hr
                            , L""
                            );
                        continue;
                    }

                    //
                    //  Try matching it to the resource type.
                    //

                    if ( *pclsidType      == *pclsidMatchType
                      || *pclsidClassType == *pclsidMatchType
                       )
                    {
                        if ( ! ( dfFlags & dfEXCLUSIVE )
                          ||     ( ( dfFlags & dfSHARED )
                                && ( dfMatchFlags & dfSHARED )
                                 )
                           )
                        {
                            hr = THR( presentry->SetFlags( dfMatchFlags ) );
                            if ( FAILED( hr ) )
                            {
                                SSR_LOG_ERR(
                                      TASKID_Major_Client_And_Server_Log
                                    , TASKID_Minor_CreateGroups_SetFlags
                                    , hr
                                    , L""
                                    );
                                continue;
                            }

                            hr = THR( presentry->AddDependent( idxResource, dfMatchFlags ) );
                            if ( FAILED( hr ) )
                            {
                                SSR_LOG_ERR(
                                      TASKID_Major_Client_And_Server_Log
                                    , TASKID_Minor_CreateGroups_Resource_AddDependent
                                    , hr
                                    , L""
                                    );
                                continue;
                            }

                            fFoundMatch = TRUE;

                            break;  // exit loop
                        }
                    }

                } // for: idxMatchResource

            } // if: not fFoundMatch

            //
            //  If we didn't match the dependency, unmark the resource from being managed.
            //

            if ( !fFoundMatch )
            {
                BSTR    bstrName;
                IClusCfgManagedResourceInfo * pccmri;
                IClusCfgManagedResourceCfg * pccmrc;

                //
                //  KB:     gpease  17-JUN-2000
                //          No need to free bstrName because the resource entry controls
                //          the lifetime - we're just borrowing it.
                //
                hr = THR( presentryResource->GetName( &bstrName ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_GetName
                        , hr
                        , L""
                        );
                    continue;
                }

                hr = S_FALSE;
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_CreateGroups_MissingDependent,
                          hr,
                          L"[Grouping] %1!ws!: Missing dependent resource. This resource will not be configured.",
                          bstrNotification,
                          bstrName
                          );

                hr = THR( presentryResource->GetAssociatedResource( &pccmrc ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_CreateGroups_GetAssociateResource
                        , hr
                        , L""
                        );
                    continue;
                }

                hr = THR( pccmrc->TypeSafeQI( IClusCfgManagedResourceInfo, &pccmri ) );
                pccmrc->Release();     //  release promptly.
                if ( FAILED( hr ) )
                {
                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_CreateGroups_QI_pccmri,
                              hr,
                              L"[Grouping] %1!ws!: Resource failed to QI for IClusCfgManagedResourceInfo.",
                              bstrNotification,
                              bstrName
                              );
                    continue;
                }

                hr = THR( pccmri->SetManaged( FALSE ) );
                pccmri->Release();     //  release promptly.
                if ( FAILED( hr ) )
                {
                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_CreateGroups_SetManaged,
                              hr,
                              L"[Grouping] %1!ws!: Resource failed SetManaged( FALSE ).",
                              bstrNotification,
                              bstrName
                              );
                }
            }

        } // for: idxDepedency

    } // for: idxResource

#if defined(DEBUG)
    // DebugDumpDepencyTree();
#endif

    hr = S_OK;
    SSR_LOG_ERR(
          TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_CreateGroups_Creating
        , hr
        , L"[Grouping] Creating groups."
        );

    sc = TW32( ResUtilGetCoreClusterResources( m_hCluster, &hClusterNameResource, NULL, NULL ) );
    if ( sc != ERROR_SUCCESS )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CreateGroups_Get_ClusterNameGroup
            , hr
            , L"[Grouping] Failed to get cluster name group handle. Aborting."
            );
        goto Cleanup;
    }

    hr = THR( HrGetClusterResourceState( hClusterNameResource, NULL, &bstrClusterNameGroup, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hGroup = OpenClusterGroup( m_hCluster, bstrClusterNameGroup );
    if ( hGroup == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                  TASKID_Minor_CreateGroups_OpenClusterGroup,
                  hr,
                  L"[Grouping] Failed OpenClusterGroup('%1!ws!'). Aborting.",
                  bstrNotification,
                  bstrClusterNameGroup
                  );
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CreateGroups_Open_ClusterGroup
            , hr
            , L"[Grouping] Failed to open cluster name group. Aborting."
            );
        goto Cleanup;
    }

    //
    //  Wrap it up and give ownership away.
    //

    hr = THR( CGroupHandle::S_HrCreateInstance( &pgh, hGroup ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CreateGroups_Create_CGroupHandle
            , hr
            , L""
            );
        goto Cleanup;
    }

    hGroup = NULL;

    //
    //  Set all the entries in the 'Cluster Name Group' to the group.
    //

    for ( idxResource = 0; idxResource <= m_idxQuorumResource; idxResource ++ )
    {
        hr = THR( HrSetGroupOnResourceAndItsDependents( idxResource, pgh ) );
        if ( FAILED( hr ) )
            continue;

    } // for: idxResource

    //
    //  Loop thru the resources looking for groups.
    //

    cGroup = 0;
    for ( idxResource = m_idxQuorumResource + 1; idxResource < m_cResources; idxResource ++ )
    {
        CResourceEntry * presentryResource = m_rgpResources[ idxResource ];
        ULONG   cDependencies;

        if ( pgh != NULL )
        {
            pgh->Release();
            pgh = NULL;
        }

        hr = THR( presentryResource->GetCountOfTypeDependencies( &cDependencies ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_CreateGroups_GetCountOfTypeDependencies2
                , hr
                , L""
                );
            continue;
        }

        //
        //  Don't consider resources that have indicated that the depend on
        //  somebody else.
        //

        if ( cDependencies != 0 )
            continue;

        //
        //  See if any of the dependent resource has already has a group assigned
        //  to it.  This allows for multiple roots to be combined into a single
        //  group due to lower dependencies.
        //

        // Don't create a group for the local quoum resource!
        hr = STHR( HrFindGroupFromResourceOrItsDependents( idxResource, &pgh ) );
        if ( FAILED( hr ) )
            continue;

        if ( hr == S_FALSE )
        {
            //
            //  We need to create a new group.
            //

            //
            //  Create a name for our group.
            //
            for( ;; )
            {
                hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_GROUP_X, &bstrGroupName, cGroup ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                                 TASKID_Minor_CreateGroups_FormatString_Group,
                                 hr,
                                 L"[Grouping] Failed to create group name. Aborting."
                                 );
                    goto Cleanup;
                }

                //
                //  Create the group in the cluster.
                //

                hGroup = CreateClusterGroup( m_hCluster, bstrGroupName );
                if ( hGroup == NULL )
                {
                    dwStatus = GetLastError();

                    switch ( dwStatus )
                    {
                    case ERROR_OBJECT_ALREADY_EXISTS:
                        cGroup ++;
                        break;  // keep looping

                    default:
                        hr = HRESULT_FROM_WIN32( TW32( dwStatus ) );
                        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                                  TASKID_Minor_CreateGroups_CreateClusterGroup,
                                  hr,
                                  L"[Grouping] %1!ws!: Failed to create group. Aborting.",
                                  bstrNotification,
                                  bstrGroupName
                                  );
                        goto Cleanup;
                    }
                }
                else
                {
                    break;
                }
            }

            //
            // Bring the group online to set its persistent state to Online.
            //

            dwStatus = TW32( OnlineClusterGroup( hGroup, NULL ) );
            if ( dwStatus != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( dwStatus );

                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_CreateGroups_OnlineClusterGroup,
                          hr,
                          L"[Grouping] %1!ws!: Failed to bring group online. Aborting.",
                          bstrNotification,
                          bstrGroupName
                          );

                goto Cleanup;
            }

            //
            //  Wrap the handle for ref counting.
            //

            hr = THR( CGroupHandle::S_HrCreateInstance( &pgh, hGroup ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_CreateGroups_Create_CGroupHandle2
                    , hr
                    , L""
                    );
                goto Cleanup;
            }

            hGroup = NULL;

            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_CreateGroups_Created,
                      hr,
                      L"[Grouping] %1!ws!: Group created.",
                      bstrNotification,
                      bstrGroupName
                      );

            cGroup ++;
        }

        hr = THR( HrSetGroupOnResourceAndItsDependents( idxResource, pgh ) );
        if ( FAILED( hr ) )
            continue;

    } // for: idxResource

    hr = S_OK;

    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_CreateGroups_Finished,
             hr,
             L"[Grouping] Finished."
             );

#if defined(DEBUG)
    // DebugDumpDepencyTree();
#endif

Cleanup:

    if ( hClusterNameResource != NULL )
    {
        CloseClusterResource( hClusterNameResource );
    } // if:

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrGroupName );
    TraceSysFreeString( bstrClusterNameGroup );

    if ( hClusEnum != NULL )
    {
        TW32( ClusterCloseEnum( hClusEnum ) );
    }

    if ( hGroup != NULL )
    {
        BOOL fRet = CloseClusterGroup( hGroup );
        Assert( fRet );
    }

    if ( pgh != NULL )
    {
        pgh->Release();
    }

    HRETURN( hr );

} // HrCreateGroups()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrCreateResources( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrCreateResources( void )
{
    TraceFunc( "" );

    BSTR    bstrName;   // don't free!
    ULONG   idxResource;

    HRESULT hr;

    BSTR    bstrNotification = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    //
    //  Make a message using the name.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_CREATING_RESOURCE, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_CreateResources_LoadString_Creating
            , hr
            , L""
            );
        goto Cleanup;
    }

    //
    //  Tell the UI what we are doing.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Creating_Resource,
                                0,
                                m_cResources, // KB: this was multiplied by 4; should it be?
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
    //  ignore failure

    //
    //  TODO:   gpease  24-AUG-2000
    //          What to do if we have a failure?? For now I think we should keep going!
    //

    hr = S_OK;
    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_CreateResources_Starting,
             hr,
             L"[Create] Starting..."
             );

    for ( idxResource = m_idxQuorumResource; idxResource < m_cResources; idxResource ++ )
    {

        hr = THR( HrCreateResourceAndDependents( idxResource ) );
        if ( FAILED( hr ) )
            continue;

    } // for: idxResource

    hr = S_OK;
    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_CreateResources_Finished,
             hr,
             L"[Create] Finished."
             );

    //
    //  Tell the UI what we are doing.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Creating_Resource,
                                0,
                                m_cResources, // KB: once these were multiplied by 4.  Should they be?
                                m_cResources,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );

    //
    //  TODO:   gpease  24-AUG-2000
    //          What to do if we have a failure?? For now I think we should keep going!
    //

Cleanup:
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} // HrCreateResources()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrPostCreateResources( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrPostCreateResources( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   idxResource;

    BSTR    bstrNotification = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    //
    //  Tell the UI what's going on.
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_STARTING_RESOURCES, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_PostCreateResources_LoadString_Starting
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Starting_Resources,
                                0,
                                m_cResources,
                                0,
                                S_OK,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
    //  ignore failure

    //
    //  TODO:   gpease  24-AUG-2000
    //          What to do if we have a failure?? For now I think we should keep going!
    //

    hr = S_OK;
    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_PostCreateResources_Starting,
             hr,
             L"[PostCreate] Starting..."
             );

    //
    //  Reset the configure flag on every resource.
    //

    for( idxResource = 0; idxResource < m_cResources ; idxResource ++ )
    {
        hr = THR( m_rgpResources[ idxResource ]->SetConfigured( FALSE ) );
        if ( FAILED( hr ) )
            continue;

    } // for: idxResource

    //
    //  Loop thru the resource calling PostCreate().
    //

    for( idxResource = 0; idxResource < m_cResources ; idxResource ++ )
    {
        hr = THR( HrPostCreateResourceAndDependents( idxResource ) );
        if ( FAILED( hr ) )
            continue;

    } // for: ever

    hr = S_OK;

    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_PostCreateResources_Finished,
             hr,
             L"[PostCreate] Finished."
             );

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Starting_Resources,
                                0,
                                m_cResources, // KB: once these were multiplied by 4; should they be?
                                m_cResources,
                                S_OK,
                                NULL,    // don't need to change text
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
    //  ignore failure

Cleanup:
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} // HrPostCreateResources()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrFindNextSharedStorage(
//      ULONG idxSeedIn,
//      ULONG * pidxOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrFindNextSharedStorage(
    ULONG * pidxInout
    )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   idxNextDiskResource;

    const CLSID *    pclsidClassType;
    CResourceEntry * presentry;
    EDependencyFlags dfFlags;

    BOOL    fFirstPass = TRUE;

    Assert( pidxInout != NULL );

    for( idxNextDiskResource = *pidxInout + 1
       ; fFirstPass && idxNextDiskResource != *pidxInout
       ; idxNextDiskResource ++
       )
    {
        if ( idxNextDiskResource >= m_cResources )
        {
            fFirstPass = FALSE;
            idxNextDiskResource = m_idxQuorumResource;
        }

        presentry = m_rgpResources[ idxNextDiskResource ];

        hr = THR( presentry->GetClassTypePtr( &pclsidClassType ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_FindNextSharedStorage_GetClassTypePtr
                , hr
                , L""
                );
            continue;
        }

        //  Skip non-storage class devices
        if ( *pclsidClassType != RESCLASSTYPE_StorageDevice )
            continue;

        hr = THR( presentry->GetFlags( &dfFlags ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_FindNextSharedStorage_GetFlags
                , hr
                , L""
                );
            continue;
        }

        if ( ! ( dfFlags & dfEXCLUSIVE ) )
        {
            *pidxInout = idxNextDiskResource;

            hr = S_OK;

            goto Cleanup;
        }

    } // for: fFirstPass && idxNextDiskResource

    hr = THR( E_FAIL );

Cleanup:
    HRETURN( hr );

} // HrFindNextSharedStorage()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrAttemptToAssignStorageToResource(
//      ULONG   idxResource
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrAttemptToAssignStorageToResource(
    ULONG            idxResourceIn,
    EDependencyFlags dfResourceFlagsIn
    )
{
    TraceFunc1( "idxResource = %u", idxResourceIn );

    HRESULT hr;

    ULONG   idxStorage;
    CResourceEntry * presentry;

    //
    //  Find the next available shared storage resource.
    //

    idxStorage = m_idxLastStorage;

    hr = THR( HrFindNextSharedStorage( &idxStorage ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  If the resource wants exclusive rights the the disk, then the quorum
    //  resource can not be used. The quorum device must always have SHARED
    //  access to it.
    //

    if ( ( dfResourceFlagsIn & dfEXCLUSIVE )
      && ( idxStorage == m_idxQuorumResource )
       )
    {
        hr = THR( HrFindNextSharedStorage( &idxStorage ) );
        if ( idxStorage == m_idxQuorumResource )
        {
            //
            //  There must not be anymore storage devices available for exclusive
            //  access. Return failure.
            //

            hr = THR( E_FAIL );

            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrAttemptToAssignStorageToResource_NoMoreStorage,
                         hr,
                         L"There must not be anymore storage devices available for exclusive access."
                         );
            goto Cleanup;
        }
    }

    presentry = m_rgpResources[ idxStorage ];

    //
    //  Set the dependency flags.
    //

    hr = THR( presentry->SetFlags( dfResourceFlagsIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAttemptToAssignStorageToResource_SetFlags
            , hr
            , L""
            );
        goto Cleanup;
    }

    //
    //  If the resource wants exclusive access to the storage resource, move
    //  any existing SHARED dependents to another resource. There will always
    //  be at least one SHARED resource because the quorum disk can't not be
    //  assigned to EXCLUSIVE access.
    //

    if ( dfResourceFlagsIn & dfEXCLUSIVE )
    {
        ULONG idxNewStorage = idxStorage;

        hr = THR( HrFindNextSharedStorage( &idxNewStorage ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( HrMovedDependentsToAnotherResource( idxStorage, idxNewStorage ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    //
    //  Add the resource as a dependent of this storage resource.
    //

    hr = THR( presentry->AddDependent( idxResourceIn, dfResourceFlagsIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAttemptToAssignStorageToResource_AddDependent
            , hr
            , L""
            );
        goto Cleanup;
    }

    m_idxLastStorage = idxStorage;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} // HrAttemptToAssignStorageToResource()


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrMovedDependentsToAnotherResource(
//      ULONG idxSourceIn,
//      ULONG idxDestIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrMovedDependentsToAnotherResource(
    ULONG idxSourceIn,
    ULONG idxDestIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    ULONG               cDependents;
    ULONG               idxDependent;
    EDependencyFlags    dfFlags;
    CResourceEntry  *   presentrySrc;
    CResourceEntry  *   presentryDst;

    //
    //  Move the shared resources to another shared disk.
    //

    presentrySrc = m_rgpResources[ idxSourceIn ];
    presentryDst = m_rgpResources[ idxDestIn ];

    hr = THR( presentrySrc->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrMovedDependentsToAnotherResource_GetCountOfDependents
            , hr
            , L""
            );
        goto Cleanup;
    }

    for ( ; cDependents != 0 ; )
    {
        cDependents --;

        hr = THR( presentrySrc->GetDependent( cDependents, &idxDependent, &dfFlags ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrMovedDependentsToAnotherResource_GetDependent
                , hr
                , L""
                );
            goto Cleanup;
        }

        hr = THR( presentryDst->AddDependent( idxDependent, dfFlags ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrMovedDependentsToAnotherResource_AddDependent
                , hr
                , L""
                );
            goto Cleanup;
        }

    } // for: cDependents

    hr = THR( presentrySrc->ClearDependents() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrMovedDependentsToAnotherResource_ClearDependents
            , hr
            , L""
            );
        goto Cleanup;
    }

Cleanup:
    HRETURN( hr );

} // HrMovedDependentsToAnotherResource()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrSetGroupOnResourceAndItsDependents(
//      ULONG           idxResourceIn,
//      CGroupHandle *  pghIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrSetGroupOnResourceAndItsDependents(
    ULONG   idxResourceIn,
    CGroupHandle * pghIn
    )
{
    TraceFunc1( "idxResourceIn = %u", idxResourceIn );

    HRESULT hr;
    ULONG   cDependents;
    ULONG   idxDependent;

    EDependencyFlags dfDependent;
    CResourceEntry * presentry;

    presentry = m_rgpResources[ idxResourceIn ];

    hr = THR( presentry->SetGroupHandle( pghIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrSetGroupOnResourceAndItsDependents_SetGroupHandle
            , hr
            , L""
            );
        goto Cleanup;
    }

    //
    //  Follow the depents list.
    //

    hr = THR( presentry->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetCountOfDependents
            , hr
            , L""
            );
        goto Cleanup;
    }

    for ( ; cDependents != 0 ; )
    {
        cDependents --;

        hr = THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrSetGroupOnResourceAndItsDependents_GetDependent
                , hr
                , L""
                );
            continue;
        }

        hr = THR( HrSetGroupOnResourceAndItsDependents( idxDependent, pghIn ) );
        if ( FAILED( hr ) )
            continue;

    } // for: cDependents

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} // HrSetGroupOnResourceAndItsDependents()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrFindGroupFromResourceOrItsDependents(
//      ULONG    idxResourceIn,
//      CGroupHandle ** ppghOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrFindGroupFromResourceOrItsDependents(
    ULONG    idxResourceIn,
    CGroupHandle ** ppghOut
    )
{
    TraceFunc1( "idxResourceIn = %u", idxResourceIn );

    HRESULT hr;
    ULONG   cDependents;
    ULONG   idxDependent;
    BSTR    bstrName;   // don't free
    BSTR    bstrGroup  = NULL;

    HRESOURCE   hResource;
    HRESOURCE   hResourceToClose = NULL;
    HGROUP      hGroup           = NULL;

    EDependencyFlags dfDependent;
    CResourceEntry * presentry;

    BSTR    bstrNotification = NULL;

    Assert( ppghOut != NULL );

    presentry = m_rgpResources[ idxResourceIn ];

    //
    //  See if we already have a cached version of the group handle.
    //

    hr = THR( presentry->GetGroupHandle( ppghOut) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                     TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetGroupHandle,
                     hr,
                     L"GetGroupHandle failed."
                     );
        goto Cleanup;
    }

    if ( hr == S_OK && *ppghOut != NULL )
        goto Cleanup;

    //
    //  Else, see if we can located an existing resource and group.
    //

    //   don't wrap - this can fail with H_R_W32( ERROR_INVALID_DATA )
    hr = presentry->GetHResource( &hResource );
    if ( FAILED( hr ) )
    {
        Assert( hr == HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) );
        Assert( hResource == NULL );

        //  Just borrowing it's name.... don't free
        hr = THR( presentry->GetName( &bstrName ) );
        if ( hr == S_OK )
        {
            hResourceToClose = OpenClusterResource( m_hCluster, bstrName );
            hResource = hResourceToClose;
        }
    }

    if ( hResource != NULL )
    {
        CLUSTER_RESOURCE_STATE crs;
        DWORD   cbGroup = 200;

ReAllocGroupName:
        bstrGroup = TraceSysAllocStringLen( NULL, cbGroup );
        if ( bstrGroup == NULL )
            goto OutOfMemory;

        crs = GetClusterResourceState( hResource, NULL, NULL, bstrGroup, &cbGroup );
        if ( crs != ClusterResourceStateUnknown )
        {
            hGroup = OpenClusterGroup( m_hCluster, bstrGroup );
            if ( hGroup != NULL )
            {
                hr = THR( CGroupHandle::S_HrCreateInstance( ppghOut, hGroup ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                                 TASKID_Minor_HrFindGroupFromResourceOrItsDependents_Create_CGroupHandle,
                                 hr,
                                 L""
                                 );
                    goto Cleanup;
                }

                hGroup = NULL;  // gave ownership away above
                goto Cleanup;
            }
            else
            {
                hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OpenClusterGroup,
                          hr,
                          L"[Grouping] %1!ws!: OpenClusterGroup() failed. Aborting.",
                          bstrNotification,
                          bstrGroup
                          );
                goto Cleanup;
            }
        }
        else
        {
            DWORD dwErr = GetLastError();
            switch ( dwErr )
            {
            case ERROR_MORE_DATA:
                cbGroup += sizeof(WCHAR); // add terminating NULL
                TraceSysFreeString( bstrGroup );
                goto ReAllocGroupName;

            default:
                hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetClusterResourceState,
                          hr,
                          L"[Grouping] %1!ws!: GetClusterResourceState( ) failed. Aborting.",
                          bstrNotification,
                          bstrName
                          );
                goto Cleanup;
            }
        }
    }
    //  else the resource might not exist... continue....

    //
    //  Follow the depents list.
    //

    hr = THR( presentry->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetCountOfDependents
            , hr
            , L""
            );
        goto Cleanup;
    }

    for ( ; cDependents != 0 ; )
    {
        cDependents --;

        hr = THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrFindGroupFromResourceOrItsDependents_GetDependent
                , hr
                , L""
                );
            goto Cleanup;
        }

        hr = STHR( HrFindGroupFromResourceOrItsDependents( idxDependent, ppghOut) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_OK && *ppghOut != NULL )
            goto Cleanup;

    } // for: cDependents

    //
    //  Failed to find an existing group.
    //

    hr = S_FALSE;
    *ppghOut = NULL;

Cleanup:
    if ( hResourceToClose != NULL )
    {
        CloseClusterResource( hResourceToClose );
    }
    if ( hGroup != NULL )
    {
        CloseClusterGroup( hGroup );
    }

    TraceSysFreeString( bstrGroup );
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
             TASKID_Minor_HrFindGroupFromResourceOrItsDependents_OutOfMemory,
             hr,
             L"Out of Memory."
             );
    goto Cleanup;

} // HrFindGroupFromResourceOrItsDependents()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrCreateResourceAndDependents(
//      ULONG       idxResourceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrCreateResourceAndDependents(
    ULONG       idxResourceIn
    )
{
    TraceFunc1( "idxResourceIn = %u", idxResourceIn );

    HRESULT     hr;
    BSTR        bstrName;   // don't free!
    ULONG       cDependents;
    ULONG       idxDependent;
    HGROUP      hGroup;     // don't close!
    HRESOURCE   hResource;
    const CLSID * pclsidResType;

    CGroupHandle * pgh;

    EDependencyFlags dfDependent;

    BSTR    bstrNotification = NULL;

    IClusCfgManagedResourceCfg *    pccmrc = NULL;

    CResourceEntry * presentry = m_rgpResources[ idxResourceIn ];

    IUnknown *                      punkServices = NULL;
    IPrivatePostCfgResource *       ppcr         = NULL;
    IClusCfgResourceCreate *        pccrc        = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    //
    //  Create a service object for this resource.
    //

    hr = THR( CCreateServices::S_HrCreateInstance( &punkServices ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                 TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices,
                 hr,
                 L"[Create] Failed to create services object. Aborting."
                 );
        goto Cleanup;
    }

    hr = THR( punkServices->TypeSafeQI( IPrivatePostCfgResource, &ppcr ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_Create_CCreateServices_QI
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( ppcr->SetEntry( presentry ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_SetEntry
            , hr
            , L""
            );
        goto Cleanup;
    }

    //
    //  See if it was configured in a previous pass.
    //

    hr = STHR( presentry->IsConfigured() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_IsConfigured
            , hr
            , L""
            );
        goto Cleanup;
    }

    if ( hr == S_FALSE )
    {
        //
        //  Make sure that Create() is not called again because of recursion.
        //

        hr = THR( presentry->SetConfigured( TRUE ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_SetConfigured
                , hr
                , L""
                );
            goto Cleanup;
        }

        //
        //  Grab some useful information: name, group handle, ...
        //

        hr = THR( presentry->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetName
                , hr
                , L""
                );
            goto Cleanup;
        }

        hr = THR( presentry->GetGroupHandle( &pgh) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetGroupHandle
                , hr
                , L""
                );
            goto Cleanup;
        }

        hr = THR( pgh->GetHandle( &hGroup ) );
        pgh->Release();    // release promptly
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetHandle
                , hr
                , L""
                );
            goto Cleanup;
        }

        //
        //  Some resource that we pre-create don't have an associated managed resource.
        //  Skip "creating" them but do create their dependents. Note that "special"
        //  resources are create below in the else statement.
        //

        //  Don't wrap - this can fail with Win32 ERROR_INVALID_DATA if the pointer is invalid.
        hr = presentry->GetAssociatedResource( &pccmrc );
        if ( FAILED( hr ) && hr != HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) )
        {
            THR( hr );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_GetAssociatedResource
                , hr
                , L""
                );
            goto Cleanup;
        }

        if ( SUCCEEDED( hr ) )
        {
            //  Don't wrap - this can fail with E_NOTIMPL.
            hr = pccmrc->Create( punkServices );
            if ( FAILED( hr ) )
            {
                if ( hr == E_NOTIMPL )
                {
                    hr = S_OK;  // ignore the error.

                } // if: E_NOTIMPL
                else
                {
                    HRESULT hr2;

                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_HrCreateResourceAndDependents_Create_Failed,
                              hr,
                              L"[Create] %1!ws!: Create() failed. Its dependents may not be created. Skipping.",
                              bstrNotification,
                              bstrName
                              );

                    hr2 = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_RESOURCE_FAILED_CREATE, &bstrNotification ) );
                    if ( FAILED( hr2 ) )
                    {
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_HrCreateResourceAndDependents_LoadString_CreateFailed
                            , hr
                            , L""
                            );
                        hr = hr2;
                        goto Cleanup;
                    }

                    hr = THR( SendStatusReport( NULL,
                                                TASKID_Major_Configure_Resources,
                                                TASKID_Minor_Resource_Failed_Create,
                                                0,
                                                1,
                                                1,
                                                MAKE_HRESULT( 0, HRESULT_FACILITY( hr ), HRESULT_CODE( hr ) ),
                                                bstrNotification,
                                                NULL,
                                                NULL
                                                ) );
                    if ( hr == E_ABORT )
                        goto Cleanup;
                        //  ignore failure

                } // else: other failure

            } // if: failure

            if ( SUCCEEDED( hr ) )
            {
                LPCWSTR pcszResType;    // don't free.

                hr = THR( presentry->GetTypePtr( &pclsidResType ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_GetTypePtr
                        , hr
                        , L""
                        );
                    goto Cleanup;
                }

                pcszResType = PcszLookupTypeNameByGUID( *pclsidResType );
                if ( pcszResType == NULL )
                {
                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_HrCreateResourceAndDependents_PcszLookupTypeNameByGUID,
                              hr,
                              L"[Create] %1!ws!: Resource cannot be created because the resource type is not registered. Its dependents may not be created. Skipping.",
                              bstrNotification,
                              bstrName
                              );
                }
                else
                {
                    hr = THR( HrCreateResourceInstance( idxResourceIn, hGroup, pcszResType, &hResource ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;
                }

            } // if: success

        } // if: interface
        else
        {
            //
            //  See if it is one of the "special" types that we can generate on the fly.
            //

            const CLSID * pclsidType;

            hr = THR( presentry->GetTypePtr( &pclsidType ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrCreateResourceAndDependents_InvalidData_GetTypePtr
                    , hr
                    , L""
                    );
                goto Cleanup;
            }

            if ( *pclsidType == RESTYPE_NetworkName )
            {
                //
                //  Create a new network name resource.
                //

                hr = THR( punkServices->TypeSafeQI( IClusCfgResourceCreate, &pccrc ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_NetworkName_QI_pccrc
                        , hr
                        , L""
                        );
                    goto Cleanup;
                }

                hr = THR( pccrc->SetPropertyString( L"Name", bstrName ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_NetworkName_SetPropertyString
                        , hr
                        , L""
                        );
                    goto Cleanup;
                }

                hr = THR( HrCreateResourceInstance( idxResourceIn, hGroup, L"Network Name", &hResource ) );
                if ( FAILED( hr ) )
                    goto Cleanup;
            }
            else if ( *pclsidType == RESTYPE_IPAddress )
            {
                //
                //  Create a new IP address resource.
                //

                hr = THR( punkServices->TypeSafeQI( IClusCfgResourceCreate, &pccrc ) );
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR(
                          TASKID_Major_Client_And_Server_Log
                        , TASKID_Minor_HrCreateResourceAndDependents_IPAddress_QI_pccrc
                        , hr
                        , L""
                        );
                    goto Cleanup;
                }

                //
                //  TODO:   gpease  21-JUN-2000
                //          Since we do not have a way to generate an appropriate IP address,
                //          we don't set any properties. This will cause it to fail to come
                //          online.
                //

                hr = THR( HrCreateResourceInstance( idxResourceIn, hGroup, L"IP Address", &hResource ) );
                if ( FAILED( hr ) )
                    goto Cleanup;
            }
            else
            {
                //
                //  else... the resource is one of the pre-created resources that BaseCluster
                //  created. Log and continue creating its dependents.
                //

                hr = S_OK;
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrCreateResourceAndDependents_NothingNew,
                          hr,
                          L"[Create] %1!ws!: Nothing new to create. Configuring dependents.",
                          bstrNotification,
                          bstrName
                          );
            }

        } // else: no interface

    } // if: not created

    //
    //  Now that we created the resource instance, we need to create its dependents.
    //

    hr = THR( presentry->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetCountOfDependents
            , hr
            , L""
            );
        goto Cleanup;
    }

    for( ; cDependents != 0; )
    {
        DWORD            dw;
        BSTR             bstrDependent;
        HRESOURCE        hResourceDependent;
        CResourceEntry * presentryDependent;

        cDependents --;

        hr = THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetDependent
                , hr
                , L""
                );
            continue;
        }

        hr = THR( HrCreateResourceAndDependents( idxDependent ) );
        if ( FAILED( hr ) )
            continue;

        //
        //  Add the dependencies on the resource.
        //

        presentryDependent = m_rgpResources[ idxDependent ];

        hr = THR( presentryDependent->GetName( &bstrDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetName
                , hr
                , L""
                );
            continue;
        }

        hr = THR( presentryDependent->GetHResource( &hResourceDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrCreateResourceAndDependents_Dependents_GetHResource
                , hr
                , L""
                );
            continue;
        }

        dw = TW32( AddClusterResourceDependency( hResourceDependent, hResource ) );
        if ( dw != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dw );
            SSR_LOG2( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrCreateResourceAndDependents_Dependents_AddClusterResourceDependency,
                      hr,
                      L"[Create] %1!ws!: Could not set dependency on %2!ws!.",
                      bstrNotification,
                      bstrDependent,
                      bstrName
                      );
        }
        else
        {
            hr = S_OK;
            SSR_LOG2( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrCreateResourceAndDependents_Dependents_Succeeded,
                      hr,
                      L"[Create] %1!ws!: Successfully set dependency set on %2!ws!.",
                      bstrNotification,
                      bstrDependent,
                      bstrName
                      );
        }

    } // for: cDependents

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrNotification );

    if ( pccmrc != NULL )
    {
        pccmrc->Release();
    }

    if ( punkServices != NULL )
    {
        punkServices->Release();
    }

    if ( ppcr != NULL )
    {
        ppcr->Release();
    }

    if ( pccrc != NULL )
    {
        pccrc->Release();
    }

    HRETURN( hr );

} // HrCreateResourceAndDependents()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrPostCreateResourceAndDependents(
//      ULONG       idxResourceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrPostCreateResourceAndDependents(
    ULONG       idxResourceIn
    )
{
    TraceFunc1( "idxResourceIn = %u", idxResourceIn );
    Assert( m_ecmCommitChangesMode != cmUNKNOWN );

    HRESULT hr;
    BSTR    bstrName;   // don't free
    ULONG   cDependents;
    ULONG   idxDependent;

    HRESOURCE   hResource;

    EDependencyFlags dfDependent;

    BSTR    bstrNotification = NULL;
    BSTR    bstrLocalQuorumNotification = NULL;

    IClusCfgManagedResourceCfg *    pccmrc = NULL;

    CResourceEntry * presentry = m_rgpResources[ idxResourceIn ];

    IUnknown *                      punkServices = NULL;
    IPrivatePostCfgResource *       ppcr         = NULL;

    //  Validate state
    Assert( m_peccmr != NULL );
    Assert( m_pccci != NULL );

    hr = STHR( presentry->IsConfigured() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPostCreateResourceAndDependents_IsConfigured
            , hr
            , L""
            );
        goto Cleanup;
    }

    if ( hr == S_FALSE )
    {
        //
        //  Make sure that PostCreate() is not called again because of recursion.
        //

        hr = THR( presentry->SetConfigured( TRUE ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPostCreateResourceAndDependents_SetConfigured
                , hr
                , L""
                );
            goto Cleanup;
        }

        //
        //  Grab the name of the resource for logging.
        //

        hr = THR( presentry->GetName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPostCreateResourceAndDependents_GetName
                , hr
                , L""
                );
            goto Cleanup;
        }

        //
        //  Bring the resource online.
        //

        hr = presentry->GetHResource( &hResource );
        if ( SUCCEEDED( hr ) )
        {
            DWORD dwErr;

            //  Don't wrap - can return ERROR_IO_PENDING.
            dwErr = OnlineClusterResource( hResource );
            switch ( dwErr )
            {
            case ERROR_SUCCESS:
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResource,
                          hr,
                          L"[PostCreate] %1!ws!: Resource brought online successfully.",
                          bstrNotification,
                          bstrName
                          );
                hr = S_OK;
                break;

            case ERROR_IO_PENDING:
                {
                    CLUSTER_RESOURCE_STATE crs = ClusterResourceOnlinePending;

                    hr = HRESULT_FROM_WIN32( dwErr );

                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_HrPostCreateResourceAndDependents_OpenClusterResourcePending,
                              hr,
                              L"[PostCreate] %1!ws!: Online pending...",
                              bstrNotification,
                              bstrName
                              );

                    for( ; crs == ClusterResourceOnlinePending ; )
                    {
                        crs = GetClusterResourceState( hResource,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       NULL
                                                       );

                        switch ( crs )
                        {
                        case ClusterResourceOnline:
                            //  no-op
                            hr = S_OK;
                            break;

                        case ClusterResourceInitializing:
                            crs = ClusterResourceOnlinePending;
                            // fall thru

                        case ClusterResourceOnlinePending:
                            Sleep( 500 );   // sleep a 1/2 second
                            break;

                        case ClusterResourceStateUnknown:
                            dwErr = GetLastError();
                            hr = HRESULT_FROM_WIN32( TW32( dwErr ) );
                            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                                      TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceStateUnknown,
                                      hr,
                                      L"[PostCreate] %1!ws!: Resource failed to come online. Dependent resources might fail too.",
                                      bstrNotification,
                                      bstrName
                                      );
                            break;

                        case ClusterResourceOfflinePending:
                        case ClusterResourceOffline:
                            hr = THR( E_FAIL );
                            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                                      TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceOffline,
                                      hr,
                                      L"[PostCreate] %1!ws!: Resource went offline. Dependent resources might fail too.",
                                      bstrNotification,
                                      bstrName
                                      );
                            break;

                        case ClusterResourceFailed:
                            hr = E_FAIL;
                            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                                      TASKID_Minor_HrPostCreateResourceAndDependents_ClusterResourceFailed,
                                      hr,
                                      L"[PostCreate] %1!ws!: Resource failed. Check Event Log. Dependent resources might fail too.",
                                      bstrNotification,
                                      bstrName
                                      );
                            break;

                        } // switch: crs

                    } // for: crs
                }
                break;

            default:
                hr = HRESULT_FROM_WIN32( TW32( dwErr ) );
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrPostCreateResourceAndDependents_OnlineClusterResource_Failed,
                          hr,
                          L"[PostCreate] %1!ws!: Resource failed to come online. Dependent resources might fail too.",
                          bstrNotification,
                          bstrName
                          );
                break;

            } // switch: dwErr

        } // if: hResource

        //
        //  Set it to the quorum resource if marked so.
        //

        if ( SUCCEEDED( hr )
          && idxResourceIn == m_idxQuorumResource
           )
        {
            DWORD dwErr;

            dwErr = TW32( SetClusterQuorumResource( hResource, NULL, CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE ) );
            if ( dwErr != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( dwErr );
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrPostCreateResourceAndDependents_SetClusterQuorumResource,
                          hr,
                          L"[PostCreate] %1!ws!: Failure setting resource to be the quorum resource.",
                          bstrNotification,
                          bstrName
                          );
            }
            else
            {
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrPostCreateResourceAndDependents_SetClusterQuorumResource_Succeeded,
                          hr,
                          L"[PostCreate] %1!ws!: Successfully set as quorum resource.",
                          bstrNotification,
                          bstrName
                          );
            }

            //
            //  Create a notification about setting the quorum resource.
            //

            hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                               IDS_TASKID_MINOR_SET_QUORUM_DEVICE,
                                               &bstrNotification,
                                               bstrName
                                               ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_SetQuorum
                    , hr
                    , L""
                    );
                //  ignore the failure.
            }

            //
            //  Send a status that we found the quorum device.
            //

            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Configure_Resources,
                                        TASKID_Minor_Set_Quorum_Device,
                                        0,
                                        5,
                                        5,
                                        HRESULT_FROM_WIN32( dwErr ),
                                        bstrNotification,
                                        NULL,
                                        NULL
                                        ) );
            if ( hr == E_ABORT )
                goto Cleanup;
                //  ignore failure

            // Do this only if the quorum has changed.
            if ( ( dwErr == ERROR_SUCCESS ) && ( m_ecmCommitChangesMode == cmCREATE_CLUSTER ) && m_isQuorumChanged)
            {
                TraceFlow( "We are forming a cluster and the quorum resouce has changed - trying to delete the local quorum resource." );

                m_dwLocalQuorumStatusMax = 0;

                //
                // If we are here, we are forming and we have successfully set a new quorum resource.
                // So, delete the local quorum resource.
                //

                // Create a notification about deleting the local quorum resource.
                hr = THR( HrFormatMessageIntoBSTR( g_hInstance, IDS_DELETING_LOCAL_QUORUM_RESOURCE, &bstrLocalQuorumNotification ) );
                //  ignore the failure.

                //  Send a status that we are deleting the quorum device.
                hr = THR( SendStatusReport( NULL,
                                            TASKID_Major_Configure_Resources,
                                            TASKID_Minor_Delete_LocalQuorum,
                                            0,
                                            m_dwLocalQuorumStatusMax,
                                            m_dwLocalQuorumStatusMax,
                                            HRESULT_FROM_WIN32( dwErr ),
                                            bstrLocalQuorumNotification,
                                            NULL,
                                            NULL
                                            ) );

                dwErr = TW32(
                    ResUtilEnumResourcesEx(
                          m_hCluster
                        , NULL
                        , CLUS_RESTYPE_NAME_LKQUORUM
                        , S_DwDeleteLocalQuorumResource
                        , this
                        )
                    );

                if ( dwErr != ERROR_SUCCESS )
                {
                    LogMsg( "PostCfg: An error occurred trying to enumerate localquorum resources (dwErr=%#08x).", dwErr );
                } // if: an error occurred trying to enumerate all local quorum resources
                else
                {
                    LogMsg( "PostCfg: Successfully deleted the local quorum resource." );
                } // if: we successfully deleted the localquorum resource

                //  Complete the status that we are deleting the quorum device.
                ++m_dwLocalQuorumStatusMax;
                hr = THR( SendStatusReport( NULL,
                                            TASKID_Major_Configure_Resources,
                                            TASKID_Minor_Delete_LocalQuorum,
                                            0,
                                            m_dwLocalQuorumStatusMax,
                                            m_dwLocalQuorumStatusMax,
                                            HRESULT_FROM_WIN32( dwErr ),
                                            NULL,    // don't update text
                                            NULL,
                                            NULL
                                            ) );

            } // if: we are forming a cluster and there have been no errors setting the quorum resource

            hr = THR( SendStatusReport( NULL,
                                        TASKID_Major_Configure_Resources,
                                        TASKID_Minor_Locate_Existing_Quorum_Device,
                                        0,
                                        10,
                                        10,
                                        hr,
                                        NULL,    // don't update text
                                        NULL,
                                        NULL
                                        ) );
            if ( hr == E_ABORT )
                goto Cleanup;
                //  ignore failure

        }

        //
        //  Some resource that we pre-create don't have an associated
        //  managed resource. Skip "creating" them but do create their
        //  dependents.
        //

        //  Don't wrap - this can fail with Win32 ERROR_INVALID_DATA if the pointer is invalid.
        hr = presentry->GetAssociatedResource( &pccmrc );
        if ( FAILED( hr ) && hr != HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) )
        {
            THR( hr );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPostCreateResourceAndDependents_GetAssociatedResource
                , hr
                , L""
                );
            goto Error;
        }

        if ( SUCCEEDED( hr ) )
        {
            //
            //  Create a service object for this resource.
            //

            hr = THR( CPostCreateServices::S_HrCreateInstance( &punkServices ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrPostCreateResourceAndDependents_Create_CPostCreateServices,
                         hr,
                         L"[PostCreate] Failed to create services object. Aborting."
                         );
                goto Error;
            }

            hr = THR( punkServices->TypeSafeQI( IPrivatePostCfgResource, &ppcr ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_Create_CPostCreateServices_QI_ppcr
                    , hr
                    , L""
                    );
                goto Error;
            }

            hr = THR( ppcr->SetEntry( presentry ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR(
                      TASKID_Major_Client_And_Server_Log
                    , TASKID_Minor_HrPostCreateResourceAndDependents_SetEntry
                    , hr
                    , L""
                    );
                goto Error;
            }

            //  Don't wrap - this can fail with E_NOTIMPL.
            hr = pccmrc->PostCreate( punkServices );
            if ( FAILED( hr ) )
            {
                if ( hr == E_NOTIMPL )
                {
                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_E_NOTIMPL,
                              hr,
                              L"[PostCreate] %1!ws!: PostCreate() returned E_NOTIMPL. Ignoring.",
                              bstrNotification,
                              bstrName
                              );

                } // if: E_NOTIMPL
                else
                {
                    HRESULT hr2;

                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_Failed,
                              hr,
                              L"[PostCreate] %1!ws!: PostCreate() failed. Ignoring.",
                              bstrNotification,
                              bstrName
                              );

                    hr2 = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                                        IDS_TASKID_MINOR_RESOURCE_FAILED_POSTCREATE_LOG,
                                                        &bstrNotification,
                                                        bstrName,
                                                        hr
                                                        ) );
                    if ( FAILED( hr2 ) )
                    {
                        hr = hr2;
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_PostCreate_Failed
                            , hr
                            , L""
                            );
                        goto Cleanup;
                    }

                    hr2 = THR( SendStatusReport( NULL,
                                                 TASKID_Major_Client_And_Server_Log,
                                                 TASKID_Minor_Resource_Failed_PostCreate,
                                                 0,
                                                 1,
                                                 1,
                                                 hr,
                                                 bstrNotification,
                                                 NULL,
                                                 NULL
                                                 ) );
                    if ( FAILED( hr2 ) )
                    {
                        hr = hr2;
                        goto Cleanup;
                    }

                    hr2 = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_RESOURCE_FAILED_POSTCREATE, &bstrNotification ) );
                    if ( FAILED( hr2 ) )
                    {
                        hr = hr2;
                        SSR_LOG_ERR(
                              TASKID_Major_Client_And_Server_Log
                            , TASKID_Minor_HrPostCreateResourceAndDependents_FormatMessage_ResourcePostCreate_Failed
                            , hr
                            , L""
                            );
                        goto Cleanup;
                    }

                    hr = THR( SendStatusReport( NULL,
                                                TASKID_Major_Configure_Resources,
                                                TASKID_Minor_Resource_Failed_PostCreate,
                                                0,
                                                1,
                                                1,
                                                MAKE_HRESULT( 0, HRESULT_FACILITY( hr ), HRESULT_CODE( hr ) ),
                                                bstrNotification,
                                                NULL,
                                                NULL
                                                ) );
                    if ( hr == E_ABORT )
                        goto Cleanup;
                        //  ignore failure

                } // else: other failure

            } // if: failure
            else
            {
                SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                          TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_Succeeded,
                          hr,
                          L"[PostCreate] %1!ws!: PostCreate() succeeded.",
                          bstrNotification,
                          bstrName
                          );

            } // else: success

        } // if: inteface
        else
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrPostCreateResourceAndDependents_PostCreate_NotNeeded,
                      hr,
                      L"[PostCreate] %1!ws!: No PostCreate() needed. Configuring dependents.",
                      bstrNotification,
                      bstrName
                      );

        } // else: no interface

    } // if: not created

    //
    //  Now that we created the resource instance, we need to create its dependents.
    //

    hr = THR( presentry->GetCountOfDependents( &cDependents ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPostCreateResourceAndDependents_GetCountOfDependents
            , hr
            , L""
            );
        goto Error;
    }

    for( ; cDependents != 0; )
    {
        cDependents --;

        hr = THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrPostCreateResourceAndDependents_GetDependent
                , hr
                , L""
                );
            continue;
        }

        hr = THR( HrPostCreateResourceAndDependents( idxDependent ) );
        if ( FAILED( hr ) )
            continue;

    } // for: cDependents

    //
    //  Update the UI layer.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Starting_Resources,
                                0,
                                m_cResources, // KB: once these were multiplied by 4; should they be?
                                idxResourceIn,
                                S_OK,
                                NULL,    // don't need to change text
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
        //  ignore failure

    hr = S_OK;

Cleanup:
    if ( pccmrc != NULL )
    {
        pccmrc->Release();
    }

    if ( punkServices != NULL )
    {
        punkServices->Release();
    }

    if ( ppcr != NULL )
    {
        ppcr->Release();
    }

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrLocalQuorumNotification );

    HRETURN( hr );

Error:
    THR( SendStatusReport( NULL,
                           TASKID_Major_Configure_Resources,
                           TASKID_Minor_Starting_Resources,
                           0,
                           m_cResources, // KB: once these were multiplied by 4; should they be?
                           idxResourceIn,
                           hr,
                           NULL,    // don't need to change text
                           NULL,
                           NULL
                           ) );
    goto Cleanup;

} // HrPostCreateResourceAndDependents()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrNotifyMemberSetChangeListeners
//
//  Description:
//      Notify all components on the local computer registered to get
//      notification of cluster member set change (form, join or evict).
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the notifications.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrNotifyMemberSetChangeListeners( void )
{
    TraceFunc( "" );

    const UINT          uiCHUNK_SIZE = 16;

    HRESULT             hr = S_OK;
    ICatInformation *   pciCatInfo = NULL;
    IEnumCLSID *        plceListenerClsidEnum = NULL;

    //  Validate state
    Assert( m_pccci != NULL );

    do
    {
        ULONG   cReturned = 0;
        CATID   rgCatIdsImplemented[ 1 ];

        rgCatIdsImplemented[ 0 ] = CATID_ClusCfgMemberSetChangeListeners;

        //
        // Enumerate all the enumerators registered in the
        // CATID_ClusCfgMemberSetChangeListeners category
        //
        hr = THR(
                CoCreateInstance(
                      CLSID_StdComponentCategoriesMgr
                    , NULL
                    , CLSCTX_SERVER
                    , IID_ICatInformation
                    , reinterpret_cast< void ** >( &pciCatInfo )
                    )
                );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrNotifyMemberSetChangeListeners_CoCreate_StdComponentCategoriesMgr,
                         hr,
                         L"Error occurred trying to get a pointer to the enumerator of the CATID_ClusCfgMemberSetChangeListeners category."
                         );
            break;
        } // if: we could not get a pointer to the ICatInformation interface

        // Get a pointer to the enumerator of the CLSIDs that belong to
        // the CATID_ClusCfgMemberSetChangeListeners category.
        hr = THR(
            pciCatInfo->EnumClassesOfCategories(
                  1
                , rgCatIdsImplemented
                , 0
                , NULL
                , &plceListenerClsidEnum
                )
            );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrNotifyMemberSetChangeListeners_EnumClassesOfCategories,
                         hr,
                         L"Error occurred trying to get a pointer to the enumerator of the CATID_ClusCfgMemberSetChangeListeners category."
                         );
            break;
        } // if: we could not get a pointer to the IEnumCLSID interface

        // Enumerate the CLSIDs of the registered enumerators
        do
        {
            CLSID   rgListenerClsidArray[ uiCHUNK_SIZE ];
            ULONG   idxCLSID;

            hr = STHR(
                plceListenerClsidEnum->Next(
                      uiCHUNK_SIZE
                    , rgListenerClsidArray
                    , &cReturned
                    )
                );

            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                             TASKID_Minor_HrNotifyMemberSetChangeListeners_Next,
                             hr,
                             L"Error occurred trying enumerate member set listener enumerators."
                             );
                break;
            } // if: we could not get a pointer to the IEnumCLSID interface

            // hr may be S_FALSE here, so reset it.
            hr = S_OK;

            for ( idxCLSID = 0; idxCLSID < cReturned; ++idxCLSID )
            {
                hr = THR( HrProcessMemberSetChangeListener( rgListenerClsidArray[ idxCLSID ] ) );
                if ( FAILED( hr ) )
                {
                    // The processing of one of the listeners failed.
                    // Log the error, but continue processing other listeners.
                    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                                 TASKID_Minor_HrNotifyMemberSetChangeListeners_HrProcessMemberSetChangeListener,
                                 hr,
                                 L"Error occurred trying to process a member set change listener. Ignoring. Other listeners will be processed."
                                 );
                    hr = S_OK;
                } // if: this listener failed
            } // for: iterate through the returned CLSIDs
        }
        while( cReturned > 0 ); // while: there are still CLSIDs to be enumerated

        if ( FAILED( hr ) )
        {
            break;
        } // if: something went wrong in the loop above
    }
    while( false ); // dummy do-while loop to avoid gotos.

    //
    // Cleanup code
    //

    if ( pciCatInfo != NULL )
    {
        pciCatInfo->Release();
    } // if: we had obtained a pointer to the ICatInformation interface

    if ( plceListenerClsidEnum != NULL )
    {
        plceListenerClsidEnum->Release();
    } // if: we had obtained a pointer to the enumerator of listener CLSIDs

    HRETURN( hr );

} //*** CPostCfgManager::HrNotifyMemberSetChangeListeners()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrProcessMemberSetChangeListener
//
//  Description:
//      This function notifies a listener of cluster member set changes.
//
//  Arguments:
//      rclsidListenerClsidIn
//          CLSID of the listener component.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the notification.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrProcessMemberSetChangeListener(
      const CLSID & rclsidListenerClsidIn
    )
{
    TraceFunc( "" );

    HRESULT                            hr = S_OK;
    IClusCfgMemberSetChangeListener *  pccmclListener = NULL;

    TraceMsgGUID( mtfFUNC, "The CLSID of this listener is ", rclsidListenerClsidIn );

    do
    {
        //
        // Create the listener represented by the CLSID passed in
        //
        hr = THR(
                CoCreateInstance(
                      rclsidListenerClsidIn
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , __uuidof( pccmclListener )
                    , reinterpret_cast< void ** >( &pccmclListener )
                    )
                );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrProcessMemberSetChangeListener_CoCreate_Listener,
                         hr,
                         L"Error occurred trying to get a pointer to the the member set change listener."
                         );
            break;
        } // if: we could not get a pointer to the IClusCfgMemberSetChangeListener interface

        hr = THR( pccmclListener->Notify( m_pccci ) );

        if ( FAILED( hr ) )
        {
            // The processing of this listeners failed.
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrProcessMemberSetChangeListener_Notify,
                         hr,
                         L"Error occurred trying to notify a listener."
                         );
            break;
        } // if: this listeners failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    //
    // Cleanup code
    //

    if ( pccmclListener != NULL )
    {
        pccmclListener->Release();
    } // if: we had obtained a pointer to the listener interface

    HRETURN( hr );

} //*** CPostCfgManager::HrProcessMemberSetChangeListener()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrConfigureResTypes
//
//  Description:
//      Enumerate all components on the local computer registered for resource
//      type configuration.
//
//  Arguments:
//      IUnknown * punkResTypeServicesIn
//          A pointer to the IUnknown interface on a component that provides
//          services that help configure resource types.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the enumeration.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrConfigureResTypes( IUnknown * punkResTypeServicesIn )
{
    TraceFunc( "" );

    const UINT          uiCHUNK_SIZE = 16;

    HRESULT             hr = S_OK;
    ICatInformation *   pciCatInfo = NULL;
    IEnumCLSID *        prceResTypeClsidEnum = NULL;


    //  Validate state
    Assert( m_pccci != NULL );

    do
    {
        ULONG   cReturned = 0;
        CATID   rgCatIdsImplemented[ 1 ];

        rgCatIdsImplemented[ 0 ] = CATID_ClusCfgResourceTypes;

        //
        // Enumerate all the enumerators registered in the
        // CATID_ClusCfgResourceTypes category
        //
        hr = THR(
                CoCreateInstance(
                      CLSID_StdComponentCategoriesMgr
                    , NULL
                    , CLSCTX_SERVER
                    , IID_ICatInformation
                    , reinterpret_cast< void ** >( &pciCatInfo )
                    )
                );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrConfigureResTypes_CoCreate_CategoriesMgr,
                         hr,
                         L"Error occurred trying to get a pointer to the enumerator of the CATID_ClusCfgResourceTypes category."
                         );
            break;
        } // if: we could not get a pointer to the ICatInformation interface

        // Get a pointer to the enumerator of the CLSIDs that belong to the CATID_ClusCfgResourceTypes category.
        hr = THR(
            pciCatInfo->EnumClassesOfCategories(
                  1
                , rgCatIdsImplemented
                , 0
                , NULL
                , &prceResTypeClsidEnum
                )
            );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrConfigureResTypes_Enum,
                         hr,
                         L"Error occurred trying to get a pointer to the enumerator of the CATID_ClusCfgResourceTypes category."
                         );
            break;
        } // if: we could not get a pointer to the IEnumCLSID interface

        // Enumerate the CLSIDs of the registered resource types
        do
        {
            CLSID   rgResTypeCLSIDArray[ uiCHUNK_SIZE ];
            ULONG   idxCLSID;

            cReturned = 0;
            hr = STHR(
                prceResTypeClsidEnum->Next(
                      uiCHUNK_SIZE
                    , rgResTypeCLSIDArray
                    , &cReturned
                    )
                );

            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                             TASKID_Minor_HrConfigureResTypes_Next,
                             hr,
                             L"Error occurred trying enumerate resource type configuration components."
                             );
                break;
            } // if: we could not get the next set of CLSIDs

            // hr may be S_FALSE here, so reset it.
            hr = S_OK;

            for ( idxCLSID = 0; idxCLSID < cReturned; ++idxCLSID )
            {
                hr = THR( HrProcessResType( rgResTypeCLSIDArray[ idxCLSID ], punkResTypeServicesIn ) );

                if ( FAILED( hr ) )
                {
                    BSTR    bstrCLSID = NULL;
                    BSTR    bstrNotification = NULL;

                    THR( StringFromCLSID( rgResTypeCLSIDArray[ idxCLSID ], &bstrCLSID ) );

                    // The processing of one of the resource types failed.
                    // Log the error, but continue processing other resource types.
                    SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                              TASKID_Minor_HrConfigureResTypes_HrProcessResType,
                              hr,
                              L"[ResType] Error occurred trying to process a resource type. Ignoring. Other resource types will be processed. The CLSID of the failed resource type is %1!ws!.",
                              bstrNotification,
                              bstrCLSID
                              );
                    TraceSysFreeString( bstrNotification );
                    SysFreeString( bstrCLSID );

                    hr = S_OK;
                } // if: this enumerator failed
            } // for: iterate through the returned CLSIDs
        }
        while( cReturned > 0 ); // while: there are still CLSIDs to be enumerated

        if ( FAILED( hr ) )
        {
            break;
        } // if: something went wrong in the loop above
    }
    while( false ); // dummy do-while loop to avoid gotos.

    //
    // Cleanup code
    //

    if ( pciCatInfo != NULL )
    {
        pciCatInfo->Release();
    } // if: we had obtained a pointer to the ICatInformation interface

    if ( prceResTypeClsidEnum != NULL )
    {
        prceResTypeClsidEnum->Release();
    } // if: we had obtained a pointer to the enumerator of resource type CLSIDs

    HRETURN( hr );

} //*** CPostCfgManager::HrConfigureResTypes()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrProcessResType
//
//  Description:
//      This function instantiates a resource type configuration component
//      and calls the appropriate methods.
//
//  Arguments:
//      rclsidResTypeCLSIDIn
//          CLSID of the resource type configuration component
//
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface on the resource type services
//          component. This interface provides methods that help configure
//          resource types.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the processing of the resource type.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrProcessResType(
        const CLSID &   rclsidResTypeCLSIDIn
      , IUnknown *      punkResTypeServicesIn
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    IClusCfgResourceTypeInfo *      pcrtiResTypeInfo = NULL;
    BSTR                            bstrResTypeName = NULL;
    GUID                            guidResTypeGUID;
    BSTR                            bstrNotification = NULL;

    TraceMsgGUID( mtfFUNC, "The CLSID of this resource type is ", rclsidResTypeCLSIDIn );

    do
    {
        //
        // Create the component represented by the CLSID passed in
        //
        hr = THR(
                CoCreateInstance(
                      rclsidResTypeCLSIDIn
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , __uuidof( pcrtiResTypeInfo )
                    , reinterpret_cast< void ** >( &pcrtiResTypeInfo )
                    )
                );

        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                     TASKID_Minor_HrProcessResType_CoCreate_ResTypeClsid,
                     hr,
                     L"[ResType] Error occurred trying to create the resource type configuration component."
                     );
            break;
        } // if: we could not create the resource type configuration component

        //
        // Initialize the newly created component
        //
        {
            IClusCfgInitialize * pcci = NULL;
            HRESULT hrTemp;

            // Check if this component supports the callback interface.
            hrTemp = THR( pcrtiResTypeInfo->QueryInterface< IClusCfgInitialize >( &pcci ) );

            if ( FAILED( hrTemp ) )
            {
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                             TASKID_Minor_HrProcessResType_QI_pcci,
                             hrTemp,
                             L"Error occurred trying to get a pointer to the IClusCfgInitialize interface. This resource type does not support initialization."
                             );
            } // if: the callback interface is not supported
            else
            {
                // Initialize this component.
                hr = THR(
                    pcci->Initialize(
                          TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 )
                        , m_lcid
                        )
                    );

                // This interface is no longer needed.
                pcci->Release();

                // Did initialization succeed?
                if ( FAILED( hr ) )
                {
                    SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                                 TASKID_Minor_HrProcessResType_Initialize,
                                 hr,
                                 L"Error occurred trying initialize a resource type configuration component."
                                 );
                    break;
                } // if: the initialization failed
            } // else: the callback interface is supported
        }


        // Get the name of the current resource type.
        hr = THR( pcrtiResTypeInfo->GetTypeName( &bstrResTypeName ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrProcessResType_GetTypeName,
                         hr,
                         L"Error occurred trying to get the name of a resource type."
                         );
            break;
        } // if: we could not get the resource type name

        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                  TASKID_Minor_HrProcessResType_AboutToConfigureType,
                  hr,
                  L"[ResType] %1!ws!: About to configure resource type...",
                  bstrNotification,
                  bstrResTypeName
                  );

        // Configure this resource type.
        hr = THR( pcrtiResTypeInfo->CommitChanges( m_pccci, punkResTypeServicesIn ) );

        if ( FAILED( hr ) )
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrProcessResType_CommitChanges,
                      hr,
                      L"[ResType] %1!ws!: Error occurred trying to configure the resource type.",
                      bstrNotification,
                      bstrResTypeName
                      );
            break;
        } // if: this resource type configuration failed

        // Get and store the resource type GUID
        hr = STHR( pcrtiResTypeInfo->GetTypeGUID( &guidResTypeGUID ) );
        if ( FAILED( hr ) )
        {
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrProcessResType_GetTypeGUID,
                      hr,
                      L"[ResType] %1!ws!: Error occurred trying to get the resource type GUID.",
                      bstrNotification,
                      bstrResTypeName
                      );
            break;
        } // if: this resource type configuration failed

        if ( hr == S_OK )
        {
            TraceMsgGUID( mtfFUNC, "The GUID of this resource type is", guidResTypeGUID );

            hr = THR( HrMapResTypeGUIDToName( guidResTypeGUID, bstrResTypeName ) );
            if ( FAILED( hr ) )
            {
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                             TASKID_Minor_HrProcessResType_HrMapResTypeGUIDToName,
                             hr,
                             L"Error occurred trying to create a mapping between a GUID and a name"
                             );

                // Something went wrong with our code - we cannot continue.
                break;
            } // if: we could not add the mapping
        } // if: this resource type has a GUID
        else
        {
            // Reset hr
            hr = S_OK;

            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_Minor_HrProcessResType_NoGuid,
                         hr,
                         L"This resource type does not have a GUID associated with it."
                         );

        } // else: this resource type does not have a GUID
    }
    while( false ); // dummy do-while loop to avoid gotos.

    //
    // Cleanup code
    //

    if ( pcrtiResTypeInfo != NULL )
    {
        pcrtiResTypeInfo->Release();
    } // if: we had obtained a pointer to the resource type info interface

    if ( bstrResTypeName != NULL )
    {
        SysFreeString( bstrResTypeName );
    } // if: a bstr was allocated for this resource type

    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CPostCfgManager::HrProcessResType()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CPostCfgManager::HrMapResTypeGUIDToName
//
//  Description:
//      Create a mapping between a resource type GUID and a resource type name.
//
//  Arguments:
//      rcguidTypeGuidIn
//          Resource type GUID which is to be mapped to a resource type name.
//
//      pcszTypeNameIn
//          The resource type name to map the above GUID to.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          If something went wrong
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrMapResTypeGUIDToName(
      const GUID & rcguidTypeGuidIn
    , const WCHAR * pcszTypeNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    do
    {
        ULONG           cchTypeNameSize;
        WCHAR *         pszTypeName;

        //
        // Validate the parameters
        //

        // Validate the parameters
        if ( ( pcszTypeNameIn == NULL ) || ( *pcszTypeNameIn == L'\0' ) )
        {
            hr = THR( E_INVALIDARG );
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_HrMapResTypeGUIDToName_InvalidArg,
                         hr,
                         L"An empty resource type name cannot be added to the map."
                         );
            break;
        } // if: the resource type name is empty


        // Check if the existing map buffer is big enough to hold another entry.
        if ( m_idxNextMapEntry >= m_cMapSize )
        {
            // Double the size of the map buffer
            ULONG                       cNewMapSize = m_cMapSize * 2;
            ULONG                       idxMapEntry;
            SResTypeGUIDAndName *       pgnNewMap = new SResTypeGUIDAndName[ cNewMapSize ];

            if ( pgnNewMap == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                             TASKID_HrMapResTypeGUIDToName_OutOfMemory_NewMap,
                             hr,
                             L"Memory allocation failed trying to add a new resource type GUID to name map entry."
                             );
                break;
            } // if: memory allocation failed

            // Copy the contents of the old buffer to the new one.
            for ( idxMapEntry = 0; idxMapEntry < m_idxNextMapEntry; ++idxMapEntry )
            {
                pgnNewMap[ idxMapEntry ] = m_pgnResTypeGUIDNameMap[ idxMapEntry ];
            } // for: iterate through the existing map

            // Update the member variables
            delete [] m_pgnResTypeGUIDNameMap;
            m_pgnResTypeGUIDNameMap = pgnNewMap;
            m_cMapSize = cNewMapSize;

        } // if: the map buffer is not big enough for another entry

        //
        // Add the new entry to the map
        //

        cchTypeNameSize = wcslen( pcszTypeNameIn ) + 1;
        pszTypeName = new WCHAR[ cchTypeNameSize ];
        if ( pszTypeName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            SSR_LOG_ERR( TASKID_Major_Client_And_Server_Log,
                         TASKID_HrMapResTypeGUIDToName_OutOfMemory_TypeName,
                         hr,
                         L"Memory allocation failed trying to add a new resource type GUID to name map entry."
                         );
            break;
        } // if: memory allocation failed

        wcsncpy( pszTypeName, pcszTypeNameIn, cchTypeNameSize );

        m_pgnResTypeGUIDNameMap[ m_idxNextMapEntry ].m_guidTypeGUID = rcguidTypeGuidIn;
        m_pgnResTypeGUIDNameMap[ m_idxNextMapEntry ].m_pszTypeName = pszTypeName;
        ++m_idxNextMapEntry;
    }
    while( false ); // dummy do-while loop to avoid gotos

    HRETURN( hr );

} //*** CPostCfgManager::HrMapResTypeGUIDToName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  CPostCfgManager::PcszLookupTypeNameByGUID
//
//  Description:
//      Given a resource type GUID this function finds the resource type name
//      if any.
//
//  Arguments:
//      rcguidTypeGuidIn
//          Resource type GUID which is to be mapped to a resource type name.
//
//  Return Values:
//      Pointer to the name of the resource type
//          If the type GUID maps to name
//
//      NULL
//          If there is no type name associated with the input GUID
//--
//////////////////////////////////////////////////////////////////////////////
const WCHAR *
CPostCfgManager::PcszLookupTypeNameByGUID(
      const GUID & rcguidTypeGuidIn
    )
{
    TraceFunc( "" );

    ULONG           idxCurrentMapEntry;
    const WCHAR *   pcszTypeName = NULL;

    TraceMsgGUID( mtfFUNC, "Trying to look up the the type name of resource type ", rcguidTypeGuidIn );

    for ( idxCurrentMapEntry = 0; idxCurrentMapEntry < m_idxNextMapEntry; ++idxCurrentMapEntry )
    {
        if ( IsEqualGUID( rcguidTypeGuidIn, m_pgnResTypeGUIDNameMap[ idxCurrentMapEntry ].m_guidTypeGUID ) != FALSE )
        {
            // A mapping has been found.
            pcszTypeName = m_pgnResTypeGUIDNameMap[ idxCurrentMapEntry ].m_pszTypeName;
            TraceMsg( mtfFUNC, "The name of the type is '%s'", pcszTypeName );
            break;
        } // if: this GUID has been found in the map
    } // for: iterate through the existing entries in the map

    if ( pcszTypeName == NULL )
    {
        TraceMsg( mtfFUNC, "The input GUID does not map to any resource type name." );
    } // if: this GUID does not exist in the map

    RETURN( pcszTypeName );
} //*** CPostCfgManager::PcszLookupTypeNameByGUID()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrPreInitializeExistingResources( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrPreInitializeExistingResources( void )
{
    TraceFunc( "" );

    HRESULT     hr;
    BSTR        bstrName;   // don't free
    HRESOURCE   hResource;

    CResourceEntry *   presentry;

    DWORD       dwMaxLogSize;
    DWORD       dw;

    BSTR        bstrNotification = NULL;
    BSTR        bstrClusterNameResourceName = NULL;
    BSTR        bstrClusterIPAddressResourceName = NULL;
    BSTR        bstrClusterQuorumResourceName = NULL;
    HRESOURCE   hClusterNameResource = NULL;
    HRESOURCE   hClusterIPAddressResource = NULL;
    HRESOURCE   hClusterQuorumResource = NULL;

    Assert( m_rgpResources == NULL );
    Assert( m_cAllocedResources == 0 );
    Assert( m_cResources == 0 );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_TASKID_MINOR_LOCATE_EXISTING_QUORUM_DEVICE, &bstrNotification ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_LoadString_LocateExistingQuorum
            , hr
            , L""
            );
        goto Cleanup;
    }

    m_rgpResources = (CResourceEntry **) TraceAlloc( 0, sizeof(CResourceEntry *) * RESOURCE_INCREMENT );
    if ( m_rgpResources == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( ; m_cAllocedResources < RESOURCE_INCREMENT; m_cAllocedResources ++ )
    {
        m_rgpResources[ m_cAllocedResources] = new CResourceEntry();
        if ( m_rgpResources[ m_cAllocedResources ] == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // for:

    Assert( m_cAllocedResources == RESOURCE_INCREMENT );

    //
    //  Create default resources such as Cluster IP, Cluster Name resource, and Quorum Device
    //

    Assert( m_cResources == 0 );

    //
    //  Get the core resources and their names.
    //
    hr = THR( HrGetCoreClusterResourceNames(
              &bstrClusterNameResourceName
            , &hClusterNameResource
            , &bstrClusterIPAddressResourceName
            , &hClusterIPAddressResource
            , &bstrClusterQuorumResourceName
            , &hClusterQuorumResource
            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
    //
    //  Add Cluster IP Address resource
    //

    m_idxIPAddress = m_cResources;

    presentry = m_rgpResources[ m_cResources ];

    //  This give ownership of bstrClusterIPAddressResourceName away
    hr = THR( presentry->SetName( bstrClusterIPAddressResourceName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetName
            , hr
            , L""
            );
        goto Cleanup;
    }

    bstrClusterIPAddressResourceName = NULL;

    hr = THR( presentry->SetType( &RESTYPE_ClusterIPAddress ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetType
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetClassType( &RESCLASSTYPE_IPAddress ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetClassType
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetFlags( dfSHARED ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetFlags
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetHResource( hClusterIPAddressResource ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_IP_SetHResource
            , hr
            , L""
            );
        goto Cleanup;
    }

    hClusterIPAddressResource = NULL;

    m_cResources ++;

    //
    //  Add Cluster Name resource
    //

    m_idxClusterName = m_cResources;

    presentry = m_rgpResources[ m_cResources ];

    //  This give ownership of bstrClusterNameResourceName away
    hr = THR( presentry->SetName( bstrClusterNameResourceName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetName
            , hr
            , L""
            );
        goto Cleanup;
    }

    bstrClusterNameResourceName = NULL;

    hr = THR( presentry->SetType( &RESTYPE_ClusterNetName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetType
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetClassType( &RESCLASSTYPE_NetworkName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetClassType
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetFlags( dfSHARED ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetFlags
            , hr
            , L""
            );
        goto Cleanup;
    }

    //  Add the dependency on the IP address.
    hr = THR( presentry->AddTypeDependency( &RESTYPE_ClusterIPAddress, dfSHARED ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_AddTypeDependency
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetHResource( hClusterNameResource ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Name_SetHResource
            , hr
            , L""
            );
        goto Cleanup;
    }

    hClusterNameResource = NULL;

    m_cResources ++;

    //
    //  Add Quorum resource
    //

    //
    //  KB:     gpease  19-JUN-2000
    //          Anything before the quorum device will be considered to be
    //          in the Cluster Group.
    //

    m_idxQuorumResource = m_cResources;

    presentry = m_rgpResources[ m_cResources ];

    //  This give ownership of bstrClusterQuorumResourceName away
    hr = THR( presentry->SetName( bstrClusterQuorumResourceName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetName
            , hr
            , L""
            );
        goto Cleanup;
    }

    bstrClusterQuorumResourceName = NULL;

    hr = THR( presentry->SetType( &RESTYPE_ClusterQuorumDisk ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetType
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetClassType( &RESCLASSTYPE_StorageDevice ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetClassType
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetFlags( dfSHARED ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetFlags
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetHResource( hClusterQuorumResource ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrPreInitializeExistingResources_Quorum_SetHResource
            , hr
            , L""
            );
        goto Cleanup;
    }

    hClusterQuorumResource = NULL;

    m_cResources ++;

    //
    //  Make sure that the default resource allocation can hold all the
    //  default resources.
    //

    AssertMsg( m_cResources <= m_cAllocedResources, "Default resource allocation needs to be bigger!" );

    goto Cleanup;

OutOfMemory:

    hr = E_OUTOFMEMORY;
    SSR_LOG_ERR(
          TASKID_Major_Client_And_Server_Log
        , TASKID_Minor_HrPreInitializeExistingResources_OutOfMemory
        , hr
        , L"Out of memory"
        );

Cleanup:

    //
    //  Send a status that we found the quorum device.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Locate_Existing_Quorum_Device,
                                0,
                                10,
                                10,
                                hr,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
        //  ignore failure

    TraceSysFreeString( bstrNotification );
    TraceSysFreeString( bstrClusterNameResourceName );
    TraceSysFreeString( bstrClusterIPAddressResourceName );
    TraceSysFreeString( bstrClusterQuorumResourceName );

    if ( hClusterNameResource != NULL )
    {
        CloseClusterResource( hClusterNameResource );
    } // if:

    if ( hClusterIPAddressResource != NULL )
    {
        CloseClusterResource( hClusterIPAddressResource );
    } // if:

    if ( hClusterQuorumResource != NULL )
    {
        CloseClusterResource( hClusterQuorumResource );
    } // if:

    HRETURN( hr );

} // HrPreInitializeExistingResources( void )


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrAddSpecialResource(
//      BSTR            bstrNameIn,
//      const CLSID *   pclsidTypeIn,
//      const CLSID *   pclsidClassTypeIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrAddSpecialResource(
    BSTR            bstrNameIn,
    const CLSID *   pclsidTypeIn,
    const CLSID *   pclsidClassTypeIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    CResourceEntry * presentry;

    //
    //  Grow the resource list if nessecary.
    //

    if ( m_cResources == m_cAllocedResources )
    {
        ULONG   idxNewCount = m_cAllocedResources + RESOURCE_INCREMENT;
        CResourceEntry ** pnewList;

        pnewList = (CResourceEntry **) TraceAlloc( 0, sizeof( CResourceEntry * ) * idxNewCount );
        if ( pnewList == NULL )
            goto OutOfMemory;

        CopyMemory( pnewList, m_rgpResources, sizeof(CResourceEntry *) * m_cAllocedResources );
        TraceFree( m_rgpResources );
        m_rgpResources = pnewList;

        for ( ; m_cAllocedResources < idxNewCount ; m_cAllocedResources ++ )
        {
            m_rgpResources[ m_cAllocedResources ] = new CResourceEntry();
            if ( m_rgpResources[ m_cAllocedResources ] == NULL )
                goto OutOfMemory;
        }
    }

    presentry = m_rgpResources[ m_cResources ];

    //
    //  Setup the new entry.
    //

    hr = THR( presentry->SetName( bstrNameIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAddSpecialResource_SetName
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetType( pclsidTypeIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAddSpecialResource_SetType
            , hr
            , L""
            );
        goto Cleanup;
    }

    hr = THR( presentry->SetClassType( pclsidClassTypeIn ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAddSpecialResource_SetClassType
            , hr
            , L""
            );
        goto Cleanup;
    }

    m_cResources ++;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    {
        hr = E_OUTOFMEMORY;
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrAddSpecialResource_OutOfMemory
            , hr
            , L"Out of memory"
            );
    }
    goto Cleanup;

} // HrAddSpecialResource()


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrCreateResourceInstance(
//      ULONG       idxResourceIn,
//      HGROUP      hGroupIn,
//      LPCWSTR     pszResTypeIn,
//      HRESOURCE * phResourceOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrCreateResourceInstance(
    ULONG       idxResourceIn,
    HGROUP      hGroupIn,
    LPCWSTR     pszResTypeIn,
    HRESOURCE * phResourceOut
    )
{
    TraceFunc3( "idxResourceIn = %u, hGroupIn = %p, pszResTypeIn = '%ws'",
                idxResourceIn, hGroupIn, pszResTypeIn );

    HRESULT     hr;
    DWORD       dw;
    BSTR        bstrName;   // don't free

    CResourceEntry * presentry;

    BSTR        bstrNotification = NULL;

    Assert( phResourceOut != NULL );
    Assert( idxResourceIn < m_cResources );
    Assert( hGroupIn != NULL );

    presentry = m_rgpResources[ idxResourceIn ];

    hr = THR( presentry->GetName( &bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceInstance_GetName
            , hr
            , L""
            );
        goto Cleanup;
    }

    //
    //  Tell the UI what we are doing.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Configure_Resources,
                                TASKID_Minor_Creating_Resource,
                                0,
                                m_cResources, // KB: once these were multiplied by 4.  Should they be?
                                idxResourceIn,
                                S_OK,
                                NULL,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
        //  ignore failure

    //
    //  TODO:   gpease  24-AUG-2000
    //          What to do if we have a failure?? For now I think we should keep going!
    //

    //
    //  See if the resource already exists. We need to do this because the user
    //  might have clicked "Retry" in the UI. We don't want to create another
    //  instance of existing resources.
    //

    *phResourceOut = OpenClusterResource( m_hCluster, bstrName );
    if ( *phResourceOut == NULL )
    {
        //
        //  Create a new resource instance.
        //

        *phResourceOut = CreateClusterResource( hGroupIn, bstrName, pszResTypeIn, 0 );
        if ( *phResourceOut == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );

            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrCreateResourceInstance_CreateClusterResource,
                      hr,
                      L"[Create] %1!ws!: CreateClusterResource failed. Its dependents may not be created. Skipping.",
                      bstrNotification,
                      bstrName
                      );
            goto Cleanup;

        } // if: failure

        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                  TASKID_Minor_HrCreateResourceInstance_CreateClusterResource_Successful,
                  hr,
                  L"[Create] %1!ws!: Resource created successfully.",
                  bstrNotification,
                  bstrName
                  );
    }
    else
    {
        SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                  TASKID_Minor_HrCreateResourceInstance_FoundExistingResource,
                  hr,
                  L"[Create] %1!ws!: Found existing resource.",
                  bstrNotification,
                  bstrName
                  );

        //
        //  Make sure the resource is in the group we think it is.
        //

        //  don't wrap - this can fail with ERROR_ALREADY_EXISTS.
        dw = ChangeClusterResourceGroup( *phResourceOut, hGroupIn );
        if ( dw == ERROR_ALREADY_EXISTS )
        {
            //  no-op. It's the way we want it.
        }
        else if ( dw != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dw );
            SSR_LOG1( TASKID_Major_Client_And_Server_Log,
                      TASKID_Minor_HrCreateResourceInstance_ChangeClusterResourceGroup,
                      hr,
                      L"[Create] %1!ws!: Can move existing resource to proper group. Configuration may not work.",
                      bstrNotification,
                      bstrName
                      );
        }
    }

    //
    //  Store off the resource handle.
    //

    hr = THR( presentry->SetHResource( *phResourceOut ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceInstance_SetHResource
            , hr
            , L""
            );
        goto Cleanup;
    }

    //
    //  Configure resource.
    //

    hr = THR( presentry->Configure() );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceInstance_Configure
            , hr
            , L""
            );
        //  ignore the error and continue.
    }

    //
    //  Make a message using the name.
    //

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_TASKID_MINOR_CREATING_RESOURCE,
                                       &bstrNotification,
                                       bstrName
                                       ) );
    if ( FAILED( hr ) )
    {
        SSR_LOG_ERR(
              TASKID_Major_Client_And_Server_Log
            , TASKID_Minor_HrCreateResourceInstance_LoadString_CreatingResource
            , hr
            , L""
            );
        goto Cleanup;
    }

    //
    //  Tell the UI what we are doing.
    //

    hr = THR( SendStatusReport( NULL,
                                TASKID_Major_Client_And_Server_Log,   // informative only
                                TASKID_Minor_Creating_Resource,
                                0,
                                2,
                                2,
                                hr, // log the error on the client side
                                bstrNotification,
                                NULL,
                                NULL
                                ) );
    if ( hr == E_ABORT )
        goto Cleanup;
        //  ignore failure

    //
    //  TODO:   gpease  24-AUG-2000
    //          What to do if we have a failure?? For now I think we should keep going!
    //

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} // HrCreateResourceInstance()


//////////////////////////////////////////////////////////////////////////////
//
//  DWORD
//  CPostCfgManager::S_DwDeleteLocalQuorumResource(
//      )
//
//////////////////////////////////////////////////////////////////////////////
DWORD
CPostCfgManager::S_DwDeleteLocalQuorumResource(
      HCLUSTER      hClusterIn
    , HRESOURCE     hSelfIn
    , HRESOURCE     hLQuorumIn
    , PVOID         pvParamIn
    )
{
    TraceFunc( "" );

    DWORD                   sc = ERROR_SUCCESS;
    signed long             slOfflineTimeOut = 60; // seconds
    CLUSTER_RESOURCE_STATE  crs;
    HCHANGE                 hc = reinterpret_cast< HCHANGE >( INVALID_HANDLE_VALUE );
    CPostCfgManager *       pcpcmThis = reinterpret_cast< CPostCfgManager * >( pvParamIn );
    DWORD                   dwStatusCurrent;

    //
    // Check if the this pointer is valid.
    //
    if ( pvParamIn == NULL )
    {
        // If the pointer is invalid, set it to a valid address and continue.
        TW32( ERROR_INVALID_PARAMETER );
        TraceFlow( "Error: The pointer to the CPostCfgManager object cannot be NULL." );
        LogMsg( "PostCfg: Error: An invalid parameter was received while trying to delete the local quorum resource." );
        goto Cleanup;
    }

    // Get the state of the resource.
    crs = GetClusterResourceState( hLQuorumIn, NULL, NULL, NULL, NULL );

    // Check if it is offline - if it is, then we can proceed to deleting it.
    if ( crs == ClusterResourceOffline )
    {
        TraceFlow( "The localquorum resource is already offline." );
        goto Cleanup;
    }

    TraceFlow( "Trying to take the localquorum resource offline." );

    // If we are here, the resource is not yet offline. Instruct it to go offline.
    sc = OfflineClusterResource( hLQuorumIn );
    if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_IO_PENDING ) )
    {
        TW32( sc );
        TraceFlow1( "Error %#08x occurred trying to take the local quorum resource offline.", sc );
        LogMsg( "PostCfg: Error %#08x occurred trying to take the local quorum resource offline.", sc );
        goto Cleanup;
    } // if: an error occurred trying to take the resource offline

    if ( sc == ERROR_IO_PENDING )
    {
        TraceFlow1( "Waiting %d seconds for the localquorum resource to go offline.", slOfflineTimeOut );

        // Create a notification port for resource state changes
        hc = CreateClusterNotifyPort(
              reinterpret_cast< HCHANGE >( INVALID_HANDLE_VALUE )
            , hClusterIn
            , CLUSTER_CHANGE_RESOURCE_STATE
            , NULL
            );

        if ( hc == NULL )
        {
            sc = TW32( GetLastError() );
            TraceFlow1( "Error %#08x occurred trying to create a cluster notification port.", sc );
            LogMsg( "PostCfg: Error %#08x occurred trying to create a cluster notification port.", sc );
            goto Cleanup;
        } // if: we could not create a notification port

        sc = TW32( RegisterClusterNotify( hc, CLUSTER_CHANGE_RESOURCE_STATE, hLQuorumIn, NULL ) );
        if ( sc != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#08x occurred trying to register for cluster notifications.", sc );
            LogMsg( "PostCfg: Error %#08x occurred trying to register for cluster notifications.", sc );
            goto Cleanup;
        } // if:

        // Change the status report range.
        dwStatusCurrent = pcpcmThis->m_dwLocalQuorumStatusMax;
        pcpcmThis->m_dwLocalQuorumStatusMax += slOfflineTimeOut;

        // Wait for slOfflineTimeOut seconds for the resource to go offline.
        for ( ; slOfflineTimeOut > 0; --slOfflineTimeOut )
        {
            DWORD   dwFilterType;

            crs = GetClusterResourceState( hLQuorumIn, NULL, NULL, NULL, NULL );
            if ( crs == ClusterResourceOffline )
            {
                TraceFlow1( "The local quorum resource has gone offline with %d seconds to spare.", slOfflineTimeOut );
                break;
            } // if: the resource is now offline

            sc = GetClusterNotify( hc, NULL, &dwFilterType, NULL, NULL, 1000 ); // wait for one second
            if ( ( sc != ERROR_SUCCESS ) && ( sc != WAIT_TIMEOUT ) )
            {
                TW32( sc );
                TraceFlow1( "Error %#08x occurred trying wait for a resource state change notification.", sc );
                LogMsg( "PostCfg: Error %#08x occurred trying wait for a resource state change notification.", sc );
                goto Cleanup;
            } // if: something went wrong

           // Reset sc, since it could be WAIT_TIMEOUT here
           sc = ERROR_SUCCESS;

           Assert( dwFilterType == CLUSTER_CHANGE_RESOURCE_STATE );

            //  Send a status report that we are deleting the quorum device.
            ++dwStatusCurrent;
            THR(
                pcpcmThis->SendStatusReport(
                      NULL
                    , TASKID_Major_Configure_Resources
                    , TASKID_Minor_Delete_LocalQuorum
                    , 0
                    , pcpcmThis->m_dwLocalQuorumStatusMax
                    , dwStatusCurrent
                    , HRESULT_FROM_WIN32( sc )
                    , NULL    // don't update text
                    , NULL
                    , NULL
                    )
                );
        } // for: loop while the timeout has not expired
    } // if:
    else
    {
        crs = ClusterResourceOffline;   // the resource went offline immediately.
    } // else:

    //
    // If we are here, then one of two things could have happened:
    // 1. The resource has gone offline
    // 2. The timeout has expired
    // Check to see which of the above is true.
    //

    if ( crs != ClusterResourceOffline )
    {
        // We cannot be here if the timeout has not expired.
        Assert( slOfflineTimeOut <= 0 );

        TraceFlow( "The local quorum resource could not be taken offline." );
        LogMsg( "PostCfg: Error: The local quorum resource could not be taken offline." );
        sc = TW32( WAIT_TIMEOUT );
        goto Cleanup;
    } // if: the timeout has expired

    // If we are here, the resource is offline.
    TraceFlow( "The local quorum resource is offline." );

    if ( pcpcmThis != NULL )
    {
        //  Send a status report that we are deleting the quorum device.
        ++pcpcmThis->m_dwLocalQuorumStatusMax;
        THR(
            pcpcmThis->SendStatusReport(
                  NULL
                , TASKID_Major_Configure_Resources
                , TASKID_Minor_Delete_LocalQuorum
                , 0
                , pcpcmThis->m_dwLocalQuorumStatusMax
                , pcpcmThis->m_dwLocalQuorumStatusMax
                , HRESULT_FROM_WIN32( sc )
                , NULL    // don't update text
                , NULL
                , NULL
                )
            );
    } // if: the this pointer is valid

    // If we are here, the resource is offline - now delete it.
    sc = TW32( DeleteClusterResource( hLQuorumIn ) );
    if ( sc != ERROR_SUCCESS )
    {
        TraceFlow1( "Error %#08x occurred trying to delete the localquorum resource.", sc );
        LogMsg( "PostCfg: Error %#08x occurred trying to delete the localquorum resource.", sc );
    } // if: we could not delete the resource
    else
    {
        TraceFlow( "The localquorum resource has been deleted." );
        LogMsg( "The localquorum resource has been deleted." );
    } // else: the resource has been deleted

    //  Send a status report that we are deleting the quorum device.
    ++pcpcmThis->m_dwLocalQuorumStatusMax;
    THR(
        pcpcmThis->SendStatusReport(
              NULL
            , TASKID_Major_Configure_Resources
            , TASKID_Minor_Delete_LocalQuorum
            , 0
            , pcpcmThis->m_dwLocalQuorumStatusMax
            , pcpcmThis->m_dwLocalQuorumStatusMax
            , HRESULT_FROM_WIN32( sc )
            , NULL    // don't update text
            , NULL
            , NULL
            )
        );

Cleanup:

    //
    // Cleanup
    //
    if ( hc != INVALID_HANDLE_VALUE )
    {
        CloseClusterNotifyPort( hc );
    } // if: we had created a cluster notification port

    RETURN( sc );

} // S_DwDeleteLocalQuorumResource()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrGetCoreClusterResourceNames(
//        BSTR *    pbstrClusterNameResourceOut
//      , BSTR *    pbstrClusterIPAddressNameOut
//      , BSTR *    pbstrClusterQuorumResourceNameOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrGetCoreClusterResourceNames(
      BSTR *        pbstrClusterNameResourceNameOut
    , HRESOURCE *   phClusterNameResourceOut
    , BSTR *        pbstrClusterIPAddressNameOut
    , HRESOURCE *   phClusterIPAddressResourceOut
    , BSTR *        pbstrClusterQuorumResourceNameOut
    , HRESOURCE *   phClusterQuorumResourceOut
    )
{
    TraceFunc( "" );
    Assert( pbstrClusterNameResourceNameOut != NULL );
    Assert( phClusterNameResourceOut != NULL );
    Assert( pbstrClusterIPAddressNameOut != NULL );
    Assert( phClusterIPAddressResourceOut != NULL );
    Assert( pbstrClusterQuorumResourceNameOut != NULL );
    Assert( phClusterQuorumResourceOut != NULL );

    HRESULT     hr = S_OK;
    WCHAR *     pszName = NULL;
    DWORD       cchName = 33;
    HRESOURCE   hClusterIPAddressResource = NULL;
    HRESOURCE   hClusterNameResource = NULL;
    HRESOURCE   hClusterQuorumResource = NULL;
    DWORD       sc;
    BSTR *      pbstr = NULL;
    HRESOURCE   hResource = NULL;
    int         idx;

    sc = TW32( ResUtilGetCoreClusterResources( m_hCluster, &hClusterNameResource, &hClusterIPAddressResource, &hClusterQuorumResource ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    pszName = new WCHAR[ cchName ];
    if ( pszName == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; idx < 3; )
    {
        switch ( idx )
        {
            case 0:
            {
                hResource = hClusterNameResource;
                pbstr = pbstrClusterNameResourceNameOut;
                break;
            } // case:

            case 1:
            {
                hResource = hClusterIPAddressResource;
                pbstr = pbstrClusterIPAddressNameOut;
                break;
            } // case:

            case 2:
            {
                hResource = hClusterQuorumResource;
                pbstr = pbstrClusterQuorumResourceNameOut;
                break;
            } // case:

        } // switch:

        sc = ResUtilGetResourceName( hResource, pszName, &cchName );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszName;
            pszName = NULL;
            cchName++;

            pszName = new WCHAR[ cchName ];
            if ( pszName == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            *pbstr = TraceSysAllocString( pszName );
            if ( *pbstr == NULL )
            {
                goto OutOfMemory;
            } // if:

            pbstr = NULL;
            idx++;
            continue;
        } // if:

        if ( sc != ERROR_SUCCESS )
        {
            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );
            SSR_LOG_ERR(
                  TASKID_Major_Client_And_Server_Log
                , TASKID_Minor_HrGetCoreClusterResourceNames_GetResourceName
                , hr
                , L""
                );
            goto Cleanup;
        } // if:
    } // for:

    //
    //  Give ownership to the caller
    //
    *phClusterNameResourceOut = hClusterNameResource;
    hClusterNameResource = NULL;

    *phClusterIPAddressResourceOut = hClusterIPAddressResource;
    hClusterIPAddressResource = NULL;

    *phClusterQuorumResourceOut = hClusterQuorumResource;
    hClusterQuorumResource = NULL;

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    if ( hClusterNameResource != NULL )
    {
        CloseClusterResource( hClusterNameResource );
    } // if:

    if ( hClusterIPAddressResource != NULL )
    {
        CloseClusterResource( hClusterIPAddressResource );
    } // if:

    if ( hClusterQuorumResource != NULL )
    {
        CloseClusterResource( hClusterQuorumResource );
    } // if:

    if ( pbstr != NULL )
    {
        TraceSysFreeString( *pbstr );
    } // if:

    delete [] pszName;

    HRETURN( hr );

} //***CPostCfgManager::HrGetCoreClusterResourceNames

/*
//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCfgManager::HrIsLocalQuorum( BSTR  bstrNameIn )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCfgManager::HrIsLocalQuorum( BSTR  bstrNameIn )
{
    TraceFunc( "" );
    Assert( bstrNameIn != NULL );

    HRESULT hr = S_FALSE;
    BSTR    bstrLocalQuorum = NULL;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_LOCAL_QUORUM_DISPLAY_NAME, &bstrLocalQuorum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( _wcsicmp( bstrNameIn, bstrLocalQuorum ) == 0 )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

Cleanup:

    TraceSysFreeString( bstrLocalQuorum );

    HRETURN( hr );

} //***CPostCfgManager::HrIsLocalQuorum
*/

#if defined(DEBUG)
//////////////////////////////////////////////////////////////////////////////
//
//  void
//  CPostCfgManager::DebugDumpDepencyTree( void )
//
//////////////////////////////////////////////////////////////////////////////
void
CPostCfgManager::DebugDumpDepencyTree( void )
{
    TraceFunc( "" );

    ULONG   idxResource;
    ULONG   cDependents;
    ULONG   idxDependent;
    BSTR    bstrName;   // don't free

    CResourceEntry * presentry;
    EDependencyFlags dfDependent;

    for ( idxResource = 0; idxResource < m_cResources ; idxResource ++ )
    {
        presentry = m_rgpResources[ idxResource ];

        THR( presentry->GetName( &bstrName ) );

        DebugMsgNoNewline( "%ws(#%u) -> ", bstrName, idxResource );

        THR( presentry->GetCountOfDependents( &cDependents ) );

        for ( ; cDependents != 0 ; )
        {
            cDependents --;

            THR( presentry->GetDependent( cDependents, &idxDependent, &dfDependent ) );

            THR( m_rgpResources[ idxDependent ]->GetName( &bstrName ) );

            DebugMsgNoNewline( "%ws(#%u) ", bstrName, idxDependent );

        } // for: cDependents

        DebugMsg( L"" );

    } // for: idxResource

    TraceFuncExit();

} // DebugDumpDepencyTree()

#endif // #if defined(DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\postcreateservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      PostCreateServices.h
//
//  Description:
//      PostCreateServices implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
CPostCreateServices
    : public IClusCfgResourcePostCreate
    , public IPrivatePostCfgResource
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IPrivatePostCfgResource
    CResourceEntry *    m_presentry;    //  List entry that the service is to modify.

private:    // methods
    CPostCreateServices( void );
    ~CPostCreateServices( void );

    HRESULT
        HrInit(void );

public:     // methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IClusCfgResourcePostCreate
    STDMETHOD( ChangeName )( LPCWSTR pcszNameIn );
    STDMETHOD( SendResourceControl )( DWORD dwControlCode,
                                      LPVOID lpInBuffer,
                                      DWORD cbInBufferSize,
                                      LPVOID lpOutBuffer,
                                      DWORD cbOutBufferSize,
                                      LPDWORD lpcbBytesReturned 
                                      );

    //  IPrivatePostCfgResource
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn );

}; // class CPostCreateServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\postcreateservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      PostCreateServices.h
//
//  Description:
//      PostCreateServices implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPrivatePostCfgResource.h"
#include "PostCreateServices.h"

DEFINE_THISCLASS("CPostCreateServices")

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCreateServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCreateServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    Assert( ppunkOut != NULL );

    CPostCreateServices * pdummy = new CPostCreateServices;
    if ( pdummy != NULL )
    {
        hr = THR( pdummy->HrInit( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pdummy->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pdummy->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CPostCreateServices::CPostCreateServices( void )
//
//////////////////////////////////////////////////////////////////////////////
CPostCreateServices::CPostCreateServices( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CPostCreateServices( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPostCreateServices::HrInit( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPostCreateServices::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // Resource
    Assert( m_presentry == NULL );

    HRETURN( hr );

} // HrInit( )

//////////////////////////////////////////////////////////////////////////////
//
//  CPostCreateServices::~CPostCreateServices( )
//
//////////////////////////////////////////////////////////////////////////////
CPostCreateServices::~CPostCreateServices( )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CPostCreateServices( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CPostCreateServices::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPostCreateServices::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgResourcePostCreate * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgResourcePostCreate ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgResourcePostCreate, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgResourcePostCreate
    else if ( IsEqualIID( riid, IID_IPrivatePostCfgResource ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IPrivatePostCfgResource, this, 0 );
        hr   = S_OK;
    } // else if: IPrivatePostCfgResource

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPostCreateServices::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CPostCreateServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef ++;  // apartment model

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPostCreateServices::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CPostCreateServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef --;  // apartment model

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


//****************************************************************************
//
//  IClusCfgResourcePostCreate
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPostCreateServices::ChangeName( 
//      LPCWSTR pcszNameIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPostCreateServices::ChangeName( 
    LPCWSTR pcszNameIn 
    )
{
    TraceFunc1( "[IClusCfgResourcePostCreate] pcszNameIn = '%s'", pcszNameIn );

    HRESULT hr = E_UNEXPECTED;

    HRETURN( hr );

} // ChangeName( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPostCreateServices::SendResourceControl( 
//      DWORD dwControlCode,
//      LPVOID lpInBuffer,
//      DWORD cbInBufferSize,
//      LPVOID lpOutBuffer,
//      DWORD cbOutBufferSize,
//      LPDWORD lpcbBytesReturned 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPostCreateServices::SendResourceControl( 
    DWORD dwControlCode,
    LPVOID lpInBuffer,
    DWORD cbInBufferSize,
    LPVOID lpOutBuffer,
    DWORD cbOutBufferSize,
    LPDWORD lpcbBytesReturned 
    )
{
    TraceFunc( "[IClusCfgResourcePostCreate]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // SendResourceControl( )

//****************************************************************************
//
//  IPrivatePostCfgResource
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPostCreateServices::SetEntry( 
//      CResourceEntry * presentryIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPostCreateServices::SetEntry( 
    CResourceEntry * presentryIn
    )
{
    TraceFunc( "[IPrivatePostCfgResource]" );

    HRESULT hr = S_OK;
    
    m_presentry = presentryIn;

    HRETURN( hr );

} // SetEntry( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\precreateservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      PreCreateServices.h
//
//  Description:
//      PreCreateServices implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"
#include "IPrivatePostCfgResource.h"
#include "PreCreateServices.h"

DEFINE_THISCLASS("CPreCreateServices")

#define DEPENDENCY_INCREMENT    5

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPreCreateServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPreCreateServices::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr = E_UNEXPECTED;

    Assert( ppunkOut != NULL );

    CPreCreateServices * pdummy = new CPreCreateServices;
    if ( pdummy != NULL )
    {
        hr = THR( pdummy->HrInit( ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pdummy->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pdummy->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} // S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CPreCreateServices::CPreCreateServices( void )
//
//////////////////////////////////////////////////////////////////////////////
CPreCreateServices::CPreCreateServices( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} // CPreCreateServices( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CPreCreateServices::HrInit( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPreCreateServices::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );    // Add one count

    // Resource
    Assert( m_presentry == NULL );

    HRETURN( hr );

} // HrInit( )

//////////////////////////////////////////////////////////////////////////////
//
//  CPreCreateServices::~CPreCreateServices( )
//
//////////////////////////////////////////////////////////////////////////////
CPreCreateServices::~CPreCreateServices( )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} // ~CPreCreateServices( )


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CPreCreateServices::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPreCreateServices::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgResourcePreCreate * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgResourcePreCreate ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgResourcePreCreate, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgResourcePreCreate
    else if ( IsEqualIID( riid, IID_IPrivatePostCfgResource ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IPrivatePostCfgResource, this, 0 );
        hr   = S_OK;
    } // else if: IPrivatePostCfgResource

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN( hr, riid );

} // QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPreCreateServices::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CPreCreateServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef ++;  // apartment model

    RETURN( m_cRef );

} // AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CPreCreateServices::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CPreCreateServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    m_cRef --;  // apartment model

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} // Release( )


//****************************************************************************
//
//  IClusCfgResourcePreCreate
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPreCreateServices::SetType( 
//      CLSID * pclsidIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPreCreateServices::SetType( 
    CLSID * pclsidIn
    )
{
    TraceFunc( "[IClusCfgResourcePreCreate]" );

    HRESULT hr;

    Assert( m_presentry != NULL );

    hr = THR( m_presentry->SetType( pclsidIn ) );

    HRETURN( hr );

} // SetType( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPreCreateServices::SetClassType( 
//      CLSID * pclsidIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPreCreateServices::SetClassType( 
    CLSID * pclsidIn
    )
{
    TraceFunc( "[IClusCfgResourcePreCreate]" );

    HRESULT hr;

    Assert( m_presentry != NULL );

    hr = THR( m_presentry->SetClassType( pclsidIn ) );

    HRETURN( hr );

} // SetClassType( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPreCreateServices::SetDependency( 
//      LPCLSID pclsidDepResTypeIn, 
//      DWORD dfIn 
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPreCreateServices::SetDependency( 
    LPCLSID pclsidDepResTypeIn, 
    DWORD dfIn 
    )
{
    TraceFunc( "[IClusCfgResourcePreCreate]" );

    HRESULT hr;

    Assert( m_presentry != NULL );

    hr = THR( m_presentry->AddTypeDependency( pclsidDepResTypeIn, (EDependencyFlags) dfIn ) );

    HRETURN( hr );

} // SetDependency( )


//****************************************************************************
//
//  IPrivatePostCfgResource
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CPreCreateServices::SetEntry( 
//      CResourceEntry * presentryIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CPreCreateServices::SetEntry( 
    CResourceEntry * presentryIn
    )
{
    TraceFunc( "[IPrivatePostCfgResource]" );

    HRESULT hr = S_OK;
    
    m_presentry = presentryIn;

    HRETURN( hr );

} // SetEntry( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\postcfgresources.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PostCfgResources.rc
//
#define ID_POSTCFG_START                                                                        600
#define IDS_GENSCRIPT_DISPLAY_NAME                                                              601
#define IDS_CONFIGURING_RESTYPE                                                                 602
#define IDS_TASKID_MINOR_CREATING_RESOURCE                                                      603
#define IDS_TASKID_MINOR_LOCATE_EXISTING_QUORUM_DEVICE                                          604
#define IDS_TASKID_MINOR_SET_QUORUM_DEVICE                                                      605
#define IDS_TASKID_MINOR_STARTING_RESOURCES                                                     606
#define IDS_TASKID_MINOR_RESOURCE_FAILED_POSTCREATE                                             607
#define IDS_TASKID_MINOR_RESOURCE_FAILED_CREATE                                                 608
#define IDS_TASKID_MINOR_RESOURCE_FAILED_PRECREATE                                              609
#define IDS_DELETING_LOCAL_QUORUM_RESOURCE                                                      610
#define IDS_TASKID_MINOR_RESOURCE_FAILED_CREATE_LOG                                             611
#define IDS_TASKID_MINOR_RESOURCE_FAILED_POSTCREATE_LOG                                         612
#define IDS_TASKID_MINOR_QUERYING_FOR_RESOURCE_DEPENDENCIES                                     613
#define IDS_TASKID_MINOR_INIT_MAPRESTYPEGUIDTONAME                                              614
#define IDS_MAJORITYNODESET_DISPLAY_NAME                                                        616
#define IDS_LOCAL_QUORUM_DISPLAY_NAME                                                           617
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\precreateservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      PreCreateServices.h
//
//  Description:
//      PreCreateServices implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
CPreCreateServices
    : public IClusCfgResourcePreCreate
    , public IPrivatePostCfgResource
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IPrivatePostCfgResource
    CResourceEntry *    m_presentry;    //  List entry that the service is to modify.

private:    // methods
    CPreCreateServices( void );
    ~CPreCreateServices( void );

    HRESULT
        HrInit(void );

public:     // methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgResourcePreCreate
    STDMETHOD( SetDependency )( LPCLSID pclsidDepResTypeIn, DWORD dfIn );
    STDMETHOD( SetType )( LPCLSID pclsidIn );
    STDMETHOD( SetClassType )( LPCLSID pclsidIn );

    //  IPrivatePostCfgResource
    STDMETHOD( SetEntry )( CResourceEntry * presentryIn );

}; // class CPreCreateServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\resourceentry.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResourceEntry.h
//
//  Description:
//      ResourceEntry implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "GroupHandle.h"
#include "ResourceEntry.h"

DEFINE_THISCLASS("CResourceEntry")

#define DEPENDENCY_INCREMENT    10
#define PROPLIST_INCREMENT      128

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  CResourceEntry::CResourceEntry( void )
//
//////////////////////////////////////////////////////////////////////////////
CResourceEntry::CResourceEntry( void )
{
    TraceFunc( "" );

    Assert( m_fConfigured == FALSE );

    Assert( m_bstrName == NULL );
    Assert( m_pccmrcResource == NULL );

    Assert( m_clsidType == IID_NULL );
    Assert( m_clsidClassType == IID_NULL );

    Assert( m_dfFlags == dfUNKNOWN );

    Assert( m_cAllocedDependencies == 0 );
    Assert( m_cDependencies == 0 );
    Assert( m_rgDependencies == NULL );

    Assert( m_cAllocedDependents == 0 );
    Assert( m_cDependents == 0 );
    Assert( m_rgDependents == NULL );

    Assert( m_groupHandle == NULL );
    Assert( m_hResource == NULL );

    Assert( m_cbAllocedPropList == 0 );
    Assert( m_cbPropList == 0 );
    Assert( m_pPropList == NULL );

    TraceFuncExit();

} // CResourceEntry( )

//////////////////////////////////////////////////////////////////////////////
//
//  CResourceEntry::~CResourceEntry( )
//
//////////////////////////////////////////////////////////////////////////////
CResourceEntry::~CResourceEntry( )
{
    TraceFunc( "" );

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    if ( m_rgDependencies != NULL )
    {
        TraceFree( m_rgDependencies );
    }

    if ( m_rgDependents != NULL )
    {
        THR( ClearDependents( ) );
    }

    if ( m_groupHandle != NULL )
    {
        m_groupHandle->Release( );
    }

    if ( m_hResource != NULL )
    {
        CloseClusterResource( m_hResource );
    }

    if ( m_pPropList != NULL )
    {
        TraceFree( m_pPropList );
    }

    TraceFuncExit();

} // ~CResourceEntry( )


//****************************************************************************
//
//  IResourceEntry
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetName(
//      BSTR bstrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetName(
    BSTR bstrIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( bstrIn != NULL );

    if ( m_bstrName != NULL )
    {
        TraceSysFreeString( m_bstrName );
    }

    m_bstrName = bstrIn;

    HRETURN( hr );

} // SetName( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetName(
//      BSTR * pbstrOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetName(
    BSTR * pbstrOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pbstrOut != NULL );

    *pbstrOut = m_bstrName;

    HRETURN( hr );

} // GetName( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetAssociatedResource(
//      IClusCfgManagedResourceCfg * pccmrcIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetAssociatedResource(
    IClusCfgManagedResourceCfg * pccmrcIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    if ( m_pccmrcResource != NULL )
    {
        m_pccmrcResource->Release( );
    }

    m_pccmrcResource = pccmrcIn;
    m_pccmrcResource->AddRef( );

    HRETURN( hr );

} // SetAssociatedResource( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetAssociatedResource(
//      IClusCfgManagedResourceCfg ** ppccmrcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetAssociatedResource(
    IClusCfgManagedResourceCfg ** ppccmrcOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr;

    if ( m_pccmrcResource != NULL )
    {
        *ppccmrcOut = m_pccmrcResource;
        (*ppccmrcOut)->AddRef( );

        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    HRETURN( hr );

} // GetAssociatedResource( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetType(
//      const CLSID * pclsidIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetType(
    const CLSID * pclsidIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    m_clsidType = * pclsidIn;

    HRETURN( hr );

} // SetType( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetType(
//      CLSID * pclsidOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetType(
    CLSID * pclsidOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    *pclsidOut = m_clsidType;

    HRETURN( hr );

} // GetType( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetTypePtr(
//      const CLSID ** ppclsidOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetTypePtr(
    const CLSID ** ppclsidOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( ppclsidOut != NULL );

    *ppclsidOut = &m_clsidType;

    HRETURN( hr );

} // GetTypePtr( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetClassType(
//      const CLSID * pclsidIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetClassType(
    const CLSID * pclsidIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    m_clsidClassType = *pclsidIn;

    HRETURN( hr );

} // SetClassType( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetClassType(
//      CLSID * pclsidOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetClassType(
    CLSID * pclsidOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    *pclsidOut = m_clsidClassType;

    HRETURN( hr );

} // GetClassType( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetClassTypePtr(
//      const CLSID ** ppclsidOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetClassTypePtr(
    const CLSID ** ppclsidOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( ppclsidOut != NULL );

    *ppclsidOut = &m_clsidClassType;

    HRETURN( hr );

} // GetClassTypePtr( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetFlags(
//      EDependencyFlags dfIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetFlags(
    EDependencyFlags dfIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    m_dfFlags = dfIn;

    HRETURN( hr );

} // SetFlags( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetFlags(
//      EDependencyFlags * pdfOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetFlags(
    EDependencyFlags * pdfOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pdfOut != NULL );

    *pdfOut = m_dfFlags;

    HRETURN( hr );

} // GetFlags( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::AddTypeDependency(
//      const CLSID * pclsidIn,
//      EDependencyFlags dfIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::AddTypeDependency(
    const CLSID * pclsidIn,
    EDependencyFlags dfIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    if ( m_cAllocedDependencies == 0 )
    {
        m_rgDependencies = (DependencyEntry *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DependencyEntry) * DEPENDENCY_INCREMENT );
        if ( m_rgDependencies == NULL )
            goto OutOfMemory;

        m_cAllocedDependencies = DEPENDENCY_INCREMENT;
        Assert( m_cDependencies == 0 );
    }
    else if ( m_cDependencies == m_cAllocedDependencies )
    {
        DependencyEntry * pdepends;

        pdepends = (DependencyEntry *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DependencyEntry) * ( m_cAllocedDependencies + DEPENDENCY_INCREMENT ) );
        if ( pdepends == NULL )
            goto OutOfMemory;

        CopyMemory( pdepends, m_rgDependencies, sizeof(DependencyEntry) * m_cAllocedDependencies );

        TraceFree( m_rgDependencies );

        m_rgDependencies = pdepends;
    }

    m_rgDependencies[ m_cDependencies ].clsidType = *pclsidIn;
    m_rgDependencies[ m_cDependencies ].dfFlags   = (EDependencyFlags) dfIn;

    m_cDependencies++;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // AddTypeDependency( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetCountOfTypeDependencies(
//      ULONG * pcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetCountOfTypeDependencies(
    ULONG * pcOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pcOut != NULL );

    *pcOut = m_cDependencies;

    HRETURN( hr );

} // GetCountOfTypeDependencies( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetTypeDependency(
//      ULONG idxIn,
//      const CLSID * pclsidOut,
//      EDependencyFlags * dfOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetTypeDependency(
    ULONG idxIn,
    CLSID * pclsidOut,
    EDependencyFlags * dfOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pclsidOut != NULL );
    Assert( dfOut != NULL );
    Assert( idxIn < m_cDependencies );

    *pclsidOut = m_rgDependencies[ idxIn ].clsidType;
    *dfOut     = m_rgDependencies[ idxIn ].dfFlags;

    HRETURN( hr );

} // GetTypeDependency( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetTypeDependencyPtr(
//      ULONG idxIn,
//      const CLSID ** ppclsidOut,
//      EDependencyFlags * dfOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetTypeDependencyPtr(
    ULONG idxIn,
    const CLSID ** ppclsidOut,
    EDependencyFlags * dfOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( ppclsidOut != NULL );
    Assert( dfOut != NULL );
    Assert( idxIn < m_cDependencies );

    *ppclsidOut = &m_rgDependencies[ idxIn ].clsidType;
    *dfOut      =  m_rgDependencies[ idxIn ].dfFlags;

    HRETURN( hr );

} // GetTypeDependencyPtr( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::AddDependent(
//      ULONG            idxIn,
//      EDependencyFlags dfFlagsIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::AddDependent(
    ULONG            idxIn,
    EDependencyFlags dfFlagsIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    if ( m_cAllocedDependents == 0 )
    {
        m_rgDependents = (DependentEntry *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DependentEntry) * DEPENDENCY_INCREMENT );
        if ( m_rgDependents == NULL )
            goto OutOfMemory;

        m_cAllocedDependents = DEPENDENCY_INCREMENT;
        Assert( m_cDependents == 0 );
    }
    else if ( m_cDependents == m_cAllocedDependents )
    {
        DependentEntry * pdepends;

        pdepends = (DependentEntry *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DependentEntry) * ( m_cAllocedDependents + DEPENDENCY_INCREMENT ) );
        if ( pdepends == NULL )
            goto OutOfMemory;

        CopyMemory( pdepends, m_rgDependents, sizeof(DependentEntry) * m_cAllocedDependents );

        TraceFree( m_rgDependents );

        m_rgDependents = pdepends;
    }

    m_rgDependents[ m_cDependents ].idxResource = idxIn;
    m_rgDependents[ m_cDependents ].dfFlags     = dfFlagsIn;

    m_cDependents++;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // AddDependent( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetCountOfDependents(
//      ULONG * pcOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetCountOfDependents(
    ULONG * pcOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pcOut != NULL );

    *pcOut = m_cDependents;

    HRETURN( hr );

} // GetCountOfDependents( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetDependent(
//      ULONG idxIn,
//      ULONG * pidxOut
//      EDependencyFlags * pdfOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetDependent(
    ULONG idxIn,
    ULONG * pidxOut,
    EDependencyFlags * pdfOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( idxIn < m_cDependents );
    Assert( pidxOut != NULL );
    Assert( pdfOut != NULL );

    *pidxOut = m_rgDependents[ idxIn ].idxResource;
    *pdfOut  = m_rgDependents[ idxIn ].dfFlags;

    HRETURN( hr );

} // GetDependent( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::ClearDependents( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::ClearDependents( void )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    TraceFree( m_rgDependents );

    m_cAllocedDependents = 0;
    m_cDependents = 0;

    HRETURN( hr );

} // ClearDependents( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetGroupHandle(
//      HGROUP hGroupIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetGroupHandle(
    CGroupHandle * pghIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pghIn != NULL );

    if ( m_groupHandle != NULL )
    {
        m_groupHandle->Release( );
    }

    m_groupHandle = pghIn;
    m_groupHandle->AddRef( );

    HRETURN( hr );

} // SetGroupHandle( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetGroupHandle(
//      CGroupHandle ** pghIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetGroupHandle(
    CGroupHandle ** pghOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( pghOut != NULL );

    *pghOut = m_groupHandle;
    if ( *pghOut != NULL )
    {
        (*pghOut)->AddRef( );
    }

    HRETURN( hr );

} // GetGroupHandle( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetHResource(
//      HRESOURCE hResourceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetHResource(
    HRESOURCE hResourceIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    if ( m_hResource != NULL )
    {
        BOOL bRet = CloseClusterResource( m_hResource );
        //  This shouldn't fail - and what would we do if it did?
        Assert( bRet );
    }

    m_hResource = hResourceIn;

    HRETURN( hr );

} // SetHResource( )


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::GetHResource(
//      HRESOURCE * phResourceOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::GetHResource(
    HRESOURCE * phResourceOut
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    Assert( phResourceOut != NULL );

    *phResourceOut = m_hResource;

    if ( *phResourceOut == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    HRETURN( hr );

} // GetHResource( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::SetConfigured(
//      BOOL fConfiguredIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::SetConfigured(
    BOOL fConfiguredIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr = S_OK;

    m_fConfigured = fConfiguredIn;

    HRETURN( hr );

} // SetConfigured( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::IsConfigured( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::IsConfigured( void )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr;

    if ( m_fConfigured )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );

} // IsConfigured( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::StoreClusterResourceControl(
//      DWORD  dwClusCtlIn,
//      LPVOID pvInBufferIn,
//      DWORD  cbInBufferIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::StoreClusterResourceControl(
    DWORD  dwClusCtlIn,
    LPVOID pvInBufferIn,
    DWORD  cbInBufferIn
    )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr;
    DWORD   cbNewSize;
    LPBYTE  pb;
    CLUSPROP_LIST  * plist;

    if ( dwClusCtlIn == CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES )
    {
        //
        //  Grow the buffer (if needed)
        //

        if ( ALIGN_CLUSPROP( cbInBufferIn - sizeof(plist->nPropertyCount) ) >= m_cbAllocedPropList - m_cbPropList )
        {
            if ( cbInBufferIn > PROPLIST_INCREMENT )
            {
                cbNewSize = m_cbAllocedPropList + ALIGN_CLUSPROP( cbInBufferIn - sizeof(plist->nPropertyCount) );
            }
            else
            {
                cbNewSize = m_cbAllocedPropList + PROPLIST_INCREMENT;
            }


            if ( m_cbAllocedPropList == 0 )
            {
                pb = (LPBYTE) TraceAlloc( HEAP_ZERO_MEMORY, cbNewSize );
                if ( pb == NULL )
                    goto OutOfMemory;

                m_cbPropList = sizeof(plist->nPropertyCount);
            }
            else
            {
                pb = (LPBYTE) TraceReAlloc( m_pPropList, cbNewSize, HEAP_ZERO_MEMORY );
                if ( pb == NULL )
                    goto OutOfMemory;
            }

            m_cbAllocedPropList = cbNewSize;
            m_pPropList         = (CLUSPROP_LIST * )pb;
        }

        //
        //  Copy the properties in to the list.
        //

        pb    = ((LPBYTE) m_pPropList) + m_cbPropList;
        plist = (CLUSPROP_LIST  * ) pvInBufferIn;

        CopyMemory( pb, &plist->PropertyName, cbInBufferIn - sizeof(plist->nPropertyCount) );

        //
        //  Increment the property count
        //

        m_pPropList->nPropertyCount += plist->nPropertyCount;

        //
        //  Adjust the list size allowing for entry padding.
        //
        m_cbPropList += ALIGN_CLUSPROP( cbInBufferIn - sizeof(plist->nPropertyCount) );
    }
    else
    {
        //
        //  TODO:   20-JUN-2000
        //          Implement buffering other/custom clusctls.
        //
        hr = THR( E_NOTIMPL );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // StoreClusterResourceControl( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceEntry::Configure( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceEntry::Configure( void )
{
    TraceFunc( "[IResourceEntry]" );

    HRESULT hr;
    DWORD   dw;

    Assert( m_hResource != NULL );

    //
    //  Send down the property list.
    //

    if ( m_pPropList != NULL )
    {
        dw = TW32( ClusterResourceControl( m_hResource,
                                           NULL,
                                           CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                           m_pPropList,
                                           m_cbPropList,
                                           NULL,
                                           NULL,
                                           NULL
                                           ) );
        if ( dw != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dw );
            goto Cleanup;
        }
    }

    //
    //  TODO:   20-JUN-2000
    //          Send down buffered other/custom clusctls.
    //

    hr = S_OK;

Cleanup:
    HRETURN( hr );


} // Configure( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\restypegenscript.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResTypeGenScript.h
//
//  Description:
//      This file contains the declaration of the CResTypeGenScript
//      class. This class handles the configuration of the generic script
//      resource type when the local computer forms or joins a cluster
//      or when it is evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CResTypeGenScript.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 14-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class of this class
#include "ResourceType.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResTypeGenScript
//
//  Description:
//      This class handles the configuration of the generic script resource type
//      when the local computer forms or joins a cluster or when it is
//      evicted from a cluster. Almost all the functionality of this class is
//      provided by the base class - all this class does is provide the right 
//      data to the base class.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResTypeGenScript
    : public CResourceType
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Public class methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // Registers this class with the categories that it belongs to.
    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructor and destructor
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CResTypeGenScript( void ) {}

    // Destructor.
    virtual ~CResTypeGenScript( void ) {}


private:

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CResourceType  BaseClass;

    //////////////////////////////////////////////////////////////////////////
    // Private class variables
    //////////////////////////////////////////////////////////////////////////

    // Information about this resource type
    static const SResourceTypeInfo   ms_rtiResTypeInfo;

}; //*** class CResTypeGenScript
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\restypemajoritynodeset.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ResTypeMajorityNodeSet.cpp
//
//  Description:
//      This file contains the implementation of the CResTypeMajorityNodeSet
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      CResTypeMajorityNodeSet.h
//
//  Maintained By:
//      Galen Barbee (Galen) 15-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// For CLUS_RESTYPE_NAME_MAJORITYNODESET
#include <clusudef.h>

// For NetShareDel()
#include <lmshare.h>

// For string ids
#include "PostCfgResources.h"

// The header file for this class
#include "ResTypeMajorityNodeSet.h"

// For DwRemoveDirectory()
#include "Common.h"

// For the smart resource handle and pointer templates
#include "SmartClasses.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CResTypeMajorityNodeSet" );

#define MAJORITY_NODE_SET_DIR_WILDCARD L"\\" MAJORITY_NODE_SET_DIRECTORY_PREFIX L"*"


//////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Clsid of the admin extension for the majority node set resource type
DEFINE_GUID( CLSID_CoCluAdmEx, 0x4EC90FB0, 0xD0BB, 0x11CF, 0xB5, 0xEF, 0x00, 0xA0, 0xC9, 0x0A, 0xB5, 0x05 );


//////////////////////////////////////////////////////////////////////////////
// Class Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Structure containing information about this resource type.
const SResourceTypeInfo CResTypeMajorityNodeSet::ms_rtiResTypeInfo =
{
      &CLSID_ClusCfgResTypeMajorityNodeSet
    , CLUS_RESTYPE_NAME_MAJORITYNODESET
    , IDS_MAJORITYNODESET_DISPLAY_NAME
    , L"ClusRes.dll"
    , 5000
    , 60000
    , NULL
    , 0
    , &RESTYPE_MajorityNodeSet
    , &TASKID_Minor_Configuring_Majority_Node_Set_Resource_Type
};


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResTypeMajorityNodeSet::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CResTypeMajorityNodeSet instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeMajorityNodeSet::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CResTypeMajorityNodeSet *     pMajorityNodeSet = NULL;

    // Allocate memory for the new object.
    pMajorityNodeSet = new CResTypeMajorityNodeSet();
    if ( pMajorityNodeSet == NULL )
    {
        LogMsg( "Could not allocate memory for the majority node set resource type object." );
        TraceFlow( "Could not allocate memory for the majority node set resource type object." );
        hr = THR( E_OUTOFMEMORY );
    } // if: out of memory
    else
    {
        hr = THR( BaseClass::S_HrCreateInstance( pMajorityNodeSet, &ms_rtiResTypeInfo, ppunkOut ) );
    } // else: memory for the new object was successfully allocated

    HRETURN( hr );

} //*** CResTypeMajorityNodeSet::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResTypeMajorityNodeSet::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      picrIn
//          Pointer to an ICatRegister interface to be used for the
//          registration.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeMajorityNodeSet::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr =  THR(
        BaseClass::S_RegisterCatIDSupport( 
              *( ms_rtiResTypeInfo.m_pcguidClassId )
            , picrIn
            , fCreateIn
            )
        );

    HRETURN( hr );

} //*** CResTypeMajorityNodeSet::S_RegisterCatIDSupport()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResTypeMajorityNodeSet::HrProcessCleanup
//
//  Description:
//      Cleans up the shares created by majority node set resource types on this node
//      during node eviction.
//
//  Arguments:
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface of a component that provides
//          methods that help configuring a resource type. For example,
//          during a join or a form, this punk can be queried for the
//          IClusCfgResourceTypeCreate interface, which provides methods
//          for resource type creation.
//
//  Return Values:
//      S_OK
//          Success
//
//      other HRESULTs
//          Cleanup failed
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeMajorityNodeSet::HrProcessCleanup( IUnknown * punkResTypeServicesIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    
    do
    {
        typedef CSmartResource<
            CHandleTrait<
                  HANDLE
                , BOOL
                , FindClose
                , INVALID_HANDLE_VALUE
                >
            > SmartFindFileHandle;

        typedef CSmartResource< CHandleTrait< HKEY, LONG, RegCloseKey, NULL > > SmartRegistryKey;

        typedef CSmartGenericPtr< CPtrTrait< WCHAR > > SmartSz;

        WIN32_FIND_DATA     wfdCurFile;
        SmartRegistryKey    srkNodeDataKey;
        SmartSz             sszNQDirsWildcard;
        DWORD               cbBufferSize    = 0;
        DWORD               dwType          = REG_SZ;
        DWORD               dwError = ERROR_SUCCESS;
        DWORD               cchClusterDirNameLen = 0;

        {
            HKEY hTempKey = NULL;

            // Open the node data registry key
            dwError = TW32(
                RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE
                    , CLUSREG_KEYNAME_NODE_DATA
                    , 0
                    , KEY_READ
                    , &hTempKey
                    )
                );

            if ( dwError != ERROR_SUCCESS )
            {
                TraceFlow1( "Error %#x occurred trying open the registry key where the cluster install path is stored.", dwError );
                LogMsg( "Error %#x occurred trying open the registry key where the cluster install path is stored.", dwError );
                break;
            } // if: RegOpenKeyEx() failed

            // Store the opened key in a smart pointer for automatic close.
            srkNodeDataKey.Assign( hTempKey );
        }

        // Get the required size of the buffer.
        dwError = TW32(
            RegQueryValueEx(
                  srkNodeDataKey.HHandle()          // handle to key to query
                , CLUSREG_INSTALL_DIR_VALUE_NAME    // name of value to query
                , 0                                 // reserved
                , NULL                              // address of buffer for value type
                , NULL                              // address of data buffer
                , &cbBufferSize                     // address of data buffer size
                )
            );

        if ( dwError != ERROR_SUCCESS )
        {
            TraceFlow2( "Error %#x occurred trying to read the registry value '%s'.", dwError, CLUSREG_INSTALL_DIR_VALUE_NAME );
            LogMsg( "Error %#x occurred trying to read the registry value '%s'.", dwError, CLUSREG_INSTALL_DIR_VALUE_NAME );
            break;
        } // if: an error occurred trying to read the CLUSREG_INSTALL_DIR_VALUE_NAME registry value

        // Account for the "\\QoN.*" 
        cbBufferSize += sizeof( MAJORITY_NODE_SET_DIR_WILDCARD );

        // Allocate the required buffer.
        sszNQDirsWildcard.Assign( reinterpret_cast< WCHAR * >( new BYTE[ cbBufferSize ] ) );
        if ( sszNQDirsWildcard.FIsEmpty() )
        {
            TraceFlow1( "An error occurred trying to allocate %d bytes of memory.", cbBufferSize );
            LogMsg( "An error occurred trying to allocate %d bytes of memory.", cbBufferSize );
            dwError = TW32( ERROR_NOT_ENOUGH_MEMORY );
            break;
        } // if: a memory allocation failure occurred

        // Read the value.
        dwError = TW32( 
            RegQueryValueEx(
                  srkNodeDataKey.HHandle()                              // handle to key to query
                , CLUSREG_INSTALL_DIR_VALUE_NAME                        // name of value to query
                , 0                                                     // reserved
                , &dwType                                               // address of buffer for value type
                , reinterpret_cast< LPBYTE >( sszNQDirsWildcard.PMem() )    // address of data buffer
                , &cbBufferSize                                         // address of data buffer size
                )
            );

        // Was the key read properly?
        if ( dwError != ERROR_SUCCESS )
        {
            TraceFlow2( "Error %#x occurred trying to read the registry value '%s'.", dwError, CLUSREG_INSTALL_DIR_VALUE_NAME );
            LogMsg( "Error %#x occurred trying to read the registry value '%s'.", dwError, CLUSREG_INSTALL_DIR_VALUE_NAME );
            break;
        } // if: RegQueryValueEx failed.

        // Store the length of the cluster install directory name for later use.
        cchClusterDirNameLen = wcslen( sszNQDirsWildcard.PMem() );

        // Append "\\QoN.*" to the cluster directory name to get the wildcard for the majority node set directories.
        wcsncat(
              sszNQDirsWildcard.PMem()
            , MAJORITY_NODE_SET_DIR_WILDCARD
            , sizeof( MAJORITY_NODE_SET_DIR_WILDCARD ) / sizeof( *MAJORITY_NODE_SET_DIR_WILDCARD )
            );

        TraceFlow1( "The wildcard for the majority node set directories is '%s'.\n", sszNQDirsWildcard.PMem() );

        SmartFindFileHandle sffhFindFileHandle( FindFirstFile( sszNQDirsWildcard.PMem(), &wfdCurFile ) );
        if ( sffhFindFileHandle.FIsInvalid() )
        {
            dwError = GetLastError();
            if ( dwError == ERROR_PATH_NOT_FOUND )
            {
                TraceFlow1( "No files or directories match the search criterion '%ws'.", sszNQDirsWildcard.PMem() );
                LogMsg( "No files or directories match the search criterion '%ws'.", sszNQDirsWildcard.PMem() );
                dwError = ERROR_SUCCESS;
            }
            else
            {
                TW32( dwError );
                TraceFlow2( "Error %#x. Find first file failed for '%ws'.", dwError, sszNQDirsWildcard.PMem() );
                LogMsg( "Error %#x. Find first file failed for '%ws'.", dwError, sszNQDirsWildcard.PMem() );
            } // else: something else went wrong

            break;
        }

        // We no longer need to have the wildcard string at the end of the cluster install directory.
        // So, remove it and reuse this buffer that contains the cluster install directory.
        sszNQDirsWildcard.PMem()[ cchClusterDirNameLen ] = L'\0';

        do
        {
            // If the current file is a directory, delete it.
            if ( ( wfdCurFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
                LPWSTR   pszDirName = NULL;

                TraceFlow1( "Trying to delete Majority Node Set directory '%s'.", wfdCurFile.cFileName );

                //
                // First, stop sharing this directory out.
                //

                // Get a pointer to just the directory name - this is the same as the share name.
                pszDirName =   wfdCurFile.cFileName
                             + sizeof( MAJORITY_NODE_SET_DIRECTORY_PREFIX ) / sizeof( *MAJORITY_NODE_SET_DIRECTORY_PREFIX )
                             - 1;
                
                dwError = NetShareDel( NULL, pszDirName, 0 );
                if ( dwError != ERROR_SUCCESS )
                {
                    TW32( dwError );

                    TraceFlow2( "Error %#x occurred trying to delete the share '%s'. This is not a fatal error.", dwError, pszDirName );
                    LogMsg( "Error %#x occurred trying to delete the share '%s'. This is not a fatal error.", dwError, pszDirName );

                    // Mask this error and continue with the next directory
                    dwError = ERROR_SUCCESS;

                } // if: we could not delete this share
                else
                {
                    SmartSz     sszNQDir;
                    DWORD       cchNQDirNameLen = wcslen( wfdCurFile.cFileName );
                    DWORD       cchNQDirPathLen = cchClusterDirNameLen + cchNQDirNameLen;

                    //
                    // Get the full path of the directory.
                    //

                    // The two extra characters are the backslash separator and the terminating NULL.
                    sszNQDir.Assign( new WCHAR[ cchNQDirPathLen + 2 ] );
                    if ( sszNQDir.FIsEmpty() )
                    {
                        TraceFlow1( "An error occurred trying to allocate memory for %d characters.", cchNQDirPathLen + 1 );
                        LogMsg( "An error occurred trying to allocate memory for %d characters.", cchNQDirPathLen + 1 );
                        dwError = TW32( ERROR_NOT_ENOUGH_MEMORY );
                        break;
                    } // if: a memory allocation failure occurred

                    wcsncpy( sszNQDir.PMem(), sszNQDirsWildcard.PMem(), cchClusterDirNameLen );
                    sszNQDir.PMem()[ cchClusterDirNameLen ] = L'\\';
                    wcsncpy( sszNQDir.PMem() + cchClusterDirNameLen + 1, wfdCurFile.cFileName, cchNQDirNameLen + 1 );

                    // Now delete the directory
                    dwError = DwRemoveDirectory( sszNQDir.PMem() );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        TW32( dwError );

                        TraceFlow2( "Error %#x occurred trying to delete the dirctory '%s'. This is not a fatal error.", dwError, sszNQDir.PMem() );
                        LogMsg( "Error %#x occurred trying to delete the dirctory '%s'. This is not a fatal error.", dwError, sszNQDir.PMem() );

                        // Mask this error and continue with the next directory
                        dwError = ERROR_SUCCESS;

                    } // if: we could not delete this share
                    else
                    {
                        TraceFlow1( "Successfully deleted directory '%s'.", sszNQDir.PMem() );
                        LogMsg( "Successfully deleted directory '%s'.", sszNQDir.PMem() );
                    } // else: success!
                } // else: we have deleted this share
                
            } // if: the current file is a directory

            if ( FindNextFile( sffhFindFileHandle.HHandle(), &wfdCurFile ) == FALSE )
            {
                dwError = GetLastError();
                if ( dwError == ERROR_NO_MORE_FILES )
                {
                    // We have deleted all the files in this directory.
                    dwError = ERROR_SUCCESS;
                }
                else
                {
                    TraceFlow2( "Error %#x. Find next file failed for '%ws'.", dwError, wfdCurFile.cFileName );
                    LogMsg( "Error %#x. Find next file failed for '%ws'.", dwError, wfdCurFile.cFileName );
                    TW32( dwError );
                    hr = HRESULT_FROM_WIN32( dwError );
                }

                // If FindNextFile has failed, we are done.
                break;
            } // if: FindNextFile fails.
        }
        while( true ); // loop infinitely.

        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError  );
            break;
        } // if: something has gone wrong up there

        // If what we wanted to do in this function was successful, call the base class function.
        hr = THR( BaseClass::HrProcessCleanup( punkResTypeServicesIn ) );
    }
    while( false ); // dummy do-while loop to avoid gotos

    HRETURN( hr );

} //*** CResTypeMajorityNodeSet::HrProcessCleanup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\resourceentry.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResourceEntry.h
//
//  Description:
//      ResourceEntry implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class
CResourceEntry
{
private:    // data
    // IUnknown
    LONG                m_cRef;         //  Reference counter

    //  IResourceEntry
    typedef struct _SDependencyEntry {
        CLSID               clsidType;
        EDependencyFlags    dfFlags;
        BOOL                fDependencyMet;

    } DependencyEntry;

    typedef struct _SDependentEntry {
        ULONG               idxResource;
        EDependencyFlags    dfFlags;

    } DependentEntry;

    BOOL                            m_fConfigured:1;            //  Configured flag

    BSTR                            m_bstrName;                 //  Name of the resource
    IClusCfgManagedResourceCfg *    m_pccmrcResource;           //  Config interface to resource instance

    CLSID                           m_clsidType;                //  Resource type
    CLSID                           m_clsidClassType;           //  Resource class type

    EDependencyFlags                m_dfFlags;                  //  Dependency flags set on resource

    ULONG                           m_cAllocedDependencies;     //  Alloced dependencies
    ULONG                           m_cDependencies;            //  Count of dependencies
    DependencyEntry *               m_rgDependencies;           //  Dependencies  list

    ULONG                           m_cAllocedDependents;       //  Alloced dependents
    ULONG                           m_cDependents;              //  Count of dependents
    DependentEntry *                m_rgDependents;             //  Dependents list

    CGroupHandle *                  m_groupHandle;              //  Group handle reference object
    HRESOURCE                       m_hResource;                //  Resource handle

    DWORD                           m_cbAllocedPropList;        //  Alloced property list count bytes
    DWORD                           m_cbPropList;               //  Count bytes of list
    CLUSPROP_LIST *                 m_pPropList;                //  Property list

public:     // methods
    CResourceEntry( void );
    ~CResourceEntry( void );

    // IUnknown
    //STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    //STDMETHOD_( ULONG, AddRef )( void );
    //STDMETHOD_( ULONG, Release )( void );

    //  IResourceEntry
    STDMETHOD( SetName )( BSTR bstrIn );
    STDMETHOD( GetName )( BSTR * pbstrOut );

    STDMETHOD( SetAssociatedResource )( IClusCfgManagedResourceCfg * pccmrcIn );
    STDMETHOD( GetAssociatedResource )( IClusCfgManagedResourceCfg ** ppccmrcOut );

    STDMETHOD( SetType )( const CLSID * pclsidIn );
    STDMETHOD( GetType )( CLSID * pclsidOut );
    STDMETHOD( GetTypePtr )( const CLSID ** ppclsidOut );

    STDMETHOD( SetClassType )( const CLSID * pclsidIn );
    STDMETHOD( GetClassType )( CLSID * pclsidOut );
    STDMETHOD( GetClassTypePtr )( const CLSID ** ppclsidOut );
    
    STDMETHOD( SetFlags )( EDependencyFlags dfIn );
    STDMETHOD( GetFlags )( EDependencyFlags * pdfOut );

    STDMETHOD( AddTypeDependency )( const CLSID * pclsidIn, EDependencyFlags dfIn );
    STDMETHOD( GetCountOfTypeDependencies )( ULONG * pcOut );
    STDMETHOD( GetTypeDependency )( ULONG idxIn, CLSID * pclsidOut, EDependencyFlags * dfOut );
    STDMETHOD( GetTypeDependencyPtr )( ULONG idxIn, const CLSID ** ppclsidOut, EDependencyFlags * dfOut );

    STDMETHOD( AddDependent )( ULONG idxIn, EDependencyFlags dfFlagsIn );
    STDMETHOD( GetCountOfDependents )( ULONG * pcOut );
    STDMETHOD( GetDependent )( ULONG idxIn, ULONG * pidxOut, EDependencyFlags * pdfOut );
    STDMETHOD( ClearDependents )( void );

    STDMETHOD( SetGroupHandle )( CGroupHandle * pghIn );
    STDMETHOD( GetGroupHandle )( CGroupHandle ** ppghOut );

    STDMETHOD( SetHResource )( HRESOURCE hResourceIn );
    STDMETHOD( GetHResource )( HRESOURCE * phResourceOut );

    STDMETHOD( SetConfigured )( BOOL fConfiguredIn );
    STDMETHOD( IsConfigured )( void );

    STDMETHOD( StoreClusterResourceControl )( DWORD  dwClusCtlIn,
                                              LPVOID pvInBufferIn,
                                              DWORD  cbInBufferIn
                                              );
    STDMETHOD( Configure )( void );

}; // class CResourceEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CITrackerSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\restypegenscript.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ResTypeGenScript.cpp
//
//  Description:
//      This file contains the implementation of the CResTypeGenScript
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      CResTypeGenScript.h
//
//  Maintained By:
//      Galen Barbee (Galen) 15-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// For CLUS_RESTYPE_NAME_GENSCRIPT
#include <clusudef.h>

// For string ids
#include "PostCfgResources.h"

// The header file for this class
#include "ResTypeGenScript.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CResTypeGenScript" );


//////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Clsid of the admin extension for the generic script resource type
DEFINE_GUID( CLSID_CoCluAdmEx, 0x4EC90FB0, 0xD0BB, 0x11CF, 0xB5, 0xEF, 0x00, 0xA0, 0xC9, 0x0A, 0xB5, 0x05 );


//////////////////////////////////////////////////////////////////////////////
// Class Variable Definitions
//////////////////////////////////////////////////////////////////////////////

// Structure containing information about this resource type.
const SResourceTypeInfo CResTypeGenScript::ms_rtiResTypeInfo =
{
      &CLSID_ClusCfgResTypeGenScript
    , CLUS_RESTYPE_NAME_GENSCRIPT
    , IDS_GENSCRIPT_DISPLAY_NAME
    , L"ClusRes.dll"
    , 5000
    , 60000
    , &CLSID_CoCluAdmEx
    , 1
    , &RESTYPE_GenericScript
    , &TASKID_Minor_Configuring_Generic_Script_Resource_Type
};


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResTypeGenScript::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CResTypeGenScript instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeGenScript::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CResTypeGenScript *     pGenScript = NULL;

    // Allocate memory for the new object.
    pGenScript = new CResTypeGenScript();
    if ( pGenScript == NULL )
    {
        LogMsg( "Could not allocate memory for the generic script resource type object." );
        TraceFlow( "Could not allocate memory for the generic script resource type object." );
        hr = THR( E_OUTOFMEMORY );
    } // if: out of memory
    else
    {
        hr = THR( BaseClass::S_HrCreateInstance( pGenScript, &ms_rtiResTypeInfo, ppunkOut ) );
    } // else: memory for the new object was successfully allocated

    HRETURN( hr );

} //*** CResTypeGenScript::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResTypeGenScript::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      picrIn
//          Pointer to an ICatRegister interface to be used for the
//          registration.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeGenScript::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr =  THR(
        BaseClass::S_RegisterCatIDSupport( 
              *( ms_rtiResTypeInfo.m_pcguidClassId )
            , picrIn
            , fCreateIn
            )
        );

    HRETURN( hr );

} //*** CResTypeGenScript::S_RegisterCatIDSupport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\restypemajoritynodeset.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResTypeMajorityNodeSet.h
//
//  Description:
//      This file contains the declaration of the CResTypeMajorityNodeSet
//      class. This class handles the configuration of the majority node set
//      resource type when the local computer forms or joins a cluster
//      or when it is evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CResTypeMajorityNodeSet.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 14-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class of this class
#include "ResourceType.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResTypeMajorityNodeSet
//
//  Description:
//      This class handles the configuration of the majority node set resource type
//      when the local computer forms or joins a cluster or when it is
//      evicted from a cluster. Almost all the functionality of this class is
//      provided by the base class - all this class does is provide the right 
//      data to the base class.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResTypeMajorityNodeSet
    : public CResourceType
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Public class methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // Registers this class with the categories that it belongs to.
    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructor and destructor
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CResTypeMajorityNodeSet( void ) {}

    // Destructor.
    virtual ~CResTypeMajorityNodeSet( void ) {}


    //////////////////////////////////////////////////////////////////////////
    //  Protected virtual functions
    //////////////////////////////////////////////////////////////////////////

    // The tasks that need to be performed after node eviction are done here.
    HRESULT HrProcessCleanup( IUnknown * punkResTypeServicesIn );

private:

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CResourceType  BaseClass;

    //////////////////////////////////////////////////////////////////////////
    // Private class variables
    //////////////////////////////////////////////////////////////////////////

    // Information about this resource type
    static const SResourceTypeInfo   ms_rtiResTypeInfo;

}; //*** class CResTypeMajorityNodeSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\resourcetype.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResourceType.cpp
//
//  Description:
//      This file contains the implementation of the CResourceType
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      CResourceType.h
//
//  Maintained By:
//      Vij Vasu (VVasu) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// For the resource ids
#include "PostCfgResources.h"

// The header file for this class
#include "ResourceType.h"

// For g_hInstance
#include "Dll.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CResourceType" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::CResourceType()
//
//  Description:
//      Constructor of the CResourceType class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourceType::CResourceType( void )
    : m_cRef( 1 )
    , m_pcccCallback( NULL )
    , m_lcid( LOCALE_SYSTEM_DEFAULT )
    , m_bstrResTypeDisplayName( NULL )
    , m_bstrStatusReportText( NULL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CResourceType::CResourceType


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::~CResourceType()
//
//  Description:
//      Destructor of the CResourceType class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourceType::~CResourceType( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    // Release the callback interface
    if ( m_pcccCallback != NULL )
    {
        m_pcccCallback->Release();
    } // if: the callback interface pointer is not NULL

    //
    // Free any memory allocated by this object.
    //

    if ( m_bstrResTypeDisplayName != NULL )
    {
        TraceSysFreeString( m_bstrResTypeDisplayName );
    } // if: we need to free the resource type display name string

    if ( m_bstrStatusReportText != NULL )
    {
        SysFreeString( m_bstrStatusReportText );
    } // if: we had allocated a status report string.

    TraceFuncExit();

} //*** CResourceType::~CResourceType


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResourceType::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CResourceType instance.
//
//  Arguments:
//      pcrtiResTypeInfoIn
//          Pointer to structure that contains information about this
//          resource type.
//
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::S_HrCreateInstance(
      CResourceType *               pResTypeObjectIn
    , const SResourceTypeInfo *     pcrtiResTypeInfoIn
    , IUnknown **                   ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = E_INVALIDARG;

    do
    {
        // Initialize the new object.
        hr = THR( pResTypeObjectIn->HrInit( pcrtiResTypeInfoIn ) );

        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred initializing a resource type object.", hr );
            TraceFlow1( "Error %#x occurred initializing a resource type object.", hr );
            break;
        } // if: the object could not be initialized

        hr = THR( pResTypeObjectIn->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );

        TraceFlow1( "*ppunkOut = %#X.", *ppunkOut );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( pResTypeObjectIn != NULL )
    {
        pResTypeObjectIn->Release();
    } // if: the pointer to the resource type object is not NULL

    HRETURN( hr );

} //*** CResourceType::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResourceType::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      rclsidCLSIDIn
//          CLSID of this class.
//
//      picrIn
//          Pointer to an ICatRegister interface to be used for the
//          registration.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::S_RegisterCatIDSupport(
      const GUID &    rclsidCLSIDIn
    , ICatRegister *  picrIn
    , BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
    } // if: the input pointer to the ICatRegister interface is invalid
    else
    {
        CATID   rgCatId[ 1 ];

        rgCatId[ 0 ] = CATID_ClusCfgResourceTypes;

        if ( fCreateIn )
        {
            hr = THR(
                picrIn->RegisterClassImplCategories(
                      rclsidCLSIDIn
                    , sizeof( rgCatId ) / sizeof( rgCatId[ 0 ] )
                    , rgCatId
                    )
                );
        } // if:
    } // else: the input pointer to the ICatRegister interface is valid

    HRETURN( hr );

} //*** CResourceType::S_RegisterCatIDSupport()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CResourceType::AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResourceType::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    TraceFlow1( "m_cRef = %d", m_cRef );

    RETURN( m_cRef );

} //*** CResourceType::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CResourceType::Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResourceType::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    TraceFlow1( "m_cRef = %d", m_cRef );

    if ( m_cRef == 0 )
    {
        TraceDo( delete this );
        RETURN( 0 );
    } // if: reference count decremented to zero

    RETURN( m_cRef );

} //*** CResourceType::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CResourceType::QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riid
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceType::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = S_OK;

    if ( ppv != NULL )
    {
        if ( IsEqualIID( riid, IID_IUnknown ) )
        {
            *ppv = static_cast< IClusCfgResourceTypeInfo * >( this );
        } // if: IUnknown
        else if ( IsEqualIID( riid, IID_IClusCfgResourceTypeInfo ) )
        {
            *ppv = TraceInterface( __THISCLASS__, IClusCfgResourceTypeInfo, this, 0 );
        } // else if:
        else if ( IsEqualIID( riid, IID_IClusCfgStartupListener ) )
        {
            *ppv = TraceInterface( __THISCLASS__, IClusCfgStartupListener, this, 0 );
        } // if: IUnknown
        else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
        {
            *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        } // else if:
        else
        {
            hr = E_NOINTERFACE;
        } // else

        if ( SUCCEEDED( hr ) )
        {
            ((IUnknown *) *ppv)->AddRef( );
        } // if: success
        else
        {
            *ppv = NULL;
        } // else: something failed

    } // if: the output pointer was valid
    else
    {
        hr = E_INVALIDARG;
    } // else: the output pointer is invalid


    QIRETURN( hr, riid );

} //*** CResourceType::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Initialize()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceType::Initialize(
      IUnknown *   punkCallbackIn
    , LCID         lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    // Release the callback interface
    if ( m_pcccCallback != NULL )
    {
        m_pcccCallback->Release();
        m_pcccCallback = NULL;
    } // if: the callback interface pointer is not NULL

    if ( punkCallbackIn != NULL )
    {
        // Query for the IClusCfgCallback interface.
        hr = THR( punkCallbackIn->QueryInterface< IClusCfgCallback >( &m_pcccCallback ) );
    } // if: the callback punk is not NULL

    HRETURN( hr );

} //*** CResourceType::Initialize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::HrInit()
//
//  Description:
//      Second phase of a two phase constructor.
//
//  Arguments:
//      pcrtiResTypeInfoIn
//          Pointer to a resource type info structure that contains information
//          about this resource type, like the type name, the dll name, etc.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::HrInit( const SResourceTypeInfo * pcrtiResTypeInfoIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR * pszStatusReportString = NULL;
    WCHAR * pszFormatString = NULL;

    //
    // Validate and store the parameters.
    //
    do
    {
        DWORD   cchOutputStringLen = 0;

        //
        // Validate and store the resource type info pointer.
        //
        if ( pcrtiResTypeInfoIn == NULL )
        {
            LogMsg( "The information about this resource type is invalid." );
            TraceFlow( "An NULL resource type info pointer is invalid." );
            hr = THR( E_POINTER );
            break;
        } // if: the resource type info pointer is invalid

        m_pcrtiResTypeInfo = pcrtiResTypeInfoIn;

        // Make sure that all the required data is present
        if (    ( m_pcrtiResTypeInfo->m_pcszResTypeName == NULL )
             || ( m_pcrtiResTypeInfo->m_pcszResDllName == NULL )
             || ( m_pcrtiResTypeInfo->m_pcguidMinorId == NULL )
           )
        {
            LogMsg( "The information about this resource type is invalid." );
            TraceFlow( "One or more members of the SResourceTypeInfo structure are invalid." );
            hr = THR( E_INVALIDARG );
            break;
        } // if: any of the members of m_pcrtiResTypeInfo are invalid

        //
        // Load and store the resource type display name string.
        // Note, the locale id of this string does not depend on the
        // locale id of the user, but on the default locale id of this computer.
        // For example, even if a Japanese administrator is configuring
        // this computer (whose default locale id is English), the resource
        // type display name should be stored in the cluster database in
        // English, not Japanese.
        //
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, pcrtiResTypeInfoIn->m_uiResTypeDisplayNameStringId, &m_bstrResTypeDisplayName ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to get the resource type display name.", hr );
            TraceFlow1( "Error %#x occurred trying to load the resource type display name string.", hr );
            break;
        } // if: an error occurred trying to load the resource type display name string


        //
        // Load and format the status message string
        //

        hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                           IDS_CONFIGURING_RESTYPE,
                                           &m_bstrStatusReportText,
                                           m_bstrResTypeDisplayName
                                           ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to get the status report text.", hr );
            TraceFlow1( "Error %#x occurred trying to load the status report format string.", hr );
            break;
        } // if: an error occurred trying to load the status report format string

    }
    while( false ); // dummy do-while loop to avoid gotos

    //
    // Cleanup
    //

    if ( pszStatusReportString != NULL )
    {
        LocalFree( pszStatusReportString );
    } // if: we had loaded the status report string

    if ( pszFormatString != NULL )
    {
        delete pszFormatString;
    } // if: we had loaded a format string

    HRETURN( hr );

} //*** CResourceType::HrInit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::CommitChanges()
//
//  Description:
//      This method is called to inform a component that this computer has
//      either joined or left a cluster. During this call, a component typically
//      performs operations that are required to configure this resource type.
//
//      If the node has just become part of a cluster, the cluster
//      service is guaranteed to be running when this method is called.
//      Querying the punkClusterInfoIn allows the resource type to get more
//      information about the event that caused this method to be called.
//
//  Arguments:
//      punkClusterInfoIn
//          The resource should QI this interface for services provided
//          by the caller of this function. Typically, the component that
//          this punk refers to also implements the IClusCfgClusterInfo
//          interface.
//
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface of a component that provides
//          methods that help configuring a resource type. For example,
//          during a join or a form, this punk can be queried for the
//          IClusCfgResourceTypeCreate interface, which provides methods
//          for resource type creation.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs.
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::CommitChanges(
      IUnknown * punkClusterInfoIn
    , IUnknown * punkResTypeServicesIn
    )
{
    TraceFunc( "[IClusCfgResourceTypeInfo]" );

    HRESULT                         hr = S_OK;
    IClusCfgClusterInfo *           pClusterInfo = NULL;
    ECommitMode                     ecmCommitChangesMode = cmUNKNOWN;

    LogMsg( "Configuring resource type '%s'.", m_pcrtiResTypeInfo->m_pcszResTypeName );
    TraceFlow1( "Configuring resource type '%s'.", m_pcrtiResTypeInfo->m_pcszResTypeName );

    do
    {
        //
        // Validate parameters
        //
        if ( punkClusterInfoIn == NULL )
        {
            LogMsg( "The information about this resource type is invalid." );
            TraceFlow( "An NULL argument is invalid." );
            hr = THR( E_POINTER );
            break;
        } // if: one of the arguments is NULL


        // Send a status report
        if ( m_pcccCallback != NULL )
        {
            hr = THR(
                m_pcccCallback->SendStatusReport(
                      NULL
                    , TASKID_Major_Configure_Resource_Types
                    , *m_pcrtiResTypeInfo->m_pcguidMinorId
                    , 0
                    , 1
                    , 0
                    , hr
                    , m_bstrStatusReportText
                    , NULL
                    , NULL
                    )
                );
        } // if: the callback pointer is not NULL

        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to send a status report.", hr );
            TraceFlow1( "Error %#x occurred trying to send a status report.", hr );
            break;
        } // if: we could not send a status report


        // Get a pointer to the IClusCfgClusterInfo interface.
        hr = THR( punkClusterInfoIn->QueryInterface< IClusCfgClusterInfo >( &pClusterInfo ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to get information about the cluster.", hr );
            TraceFlow1( "Error %#x occurred trying to get information about the cluster.", hr );
            break;
        } // if: we could not get a pointer to the IClusCfgClusterInfo interface


        // Find out what event caused this call.
        hr = STHR( pClusterInfo->GetCommitMode( &ecmCommitChangesMode ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to find out the commit mode.", hr );
            TraceFlow1( "Error %#x occurred trying to find out the commit mode.", hr );
            break;
        } // if: we could not get a pointer to the IClusCfgClusterInfo interface

        // Check what action is required.
        if ( ecmCommitChangesMode == cmCREATE_CLUSTER )
        {
            TraceFlow( "Commit Mode is cmCREATE_CLUSTER."  );
            
            // Perform the actions required during cluster creation.
            hr = THR( HrProcessCreate( punkResTypeServicesIn ) );
        } // if: a cluster has been created
        else if ( ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER )
        {
            TraceFlow( "Commit Mode is cmADD_NODE_TO_CLUSTER."  );
            
            // Perform the actions required during node addition.
            hr = THR( HrProcessAddNode( punkResTypeServicesIn ) );
        } // else if: a node has been added to the cluster
        else if ( ecmCommitChangesMode == cmCLEANUP_NODE_AFTER_EVICT )
        {
            TraceFlow( "Commit Mode is cmCLEANUP_NODE_AFTER_EVICT."  );
            
            // Perform the actions required after node eviction.
            hr = THR( HrProcessCleanup( punkResTypeServicesIn ) );
        } // else if: this node has been removed from the cluster
        else
        {
            // If we are here, then neither create cluster, add node, or cleanup are set.
            // There is nothing that need be done here.

            LogMsg( "We are neither creating a cluster, adding nodes nor cleanup up after evict. There is nothing to be done." );
            TraceFlow1( "CommitMode = %d. There is nothing to be done.", ecmCommitChangesMode );
        } // else: some other operation has been committed

        // Has something gone wrong?
        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to commit resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );
            TraceFlow2( "Error %#x occurred trying to to commit resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );
            break;
        } // if: an error occurred trying to commit this resource type
    }
    while( false ); // dummy do-while loop to avoid gotos


    // Complete the status report
    if ( m_pcccCallback != NULL )
    {
        HRESULT hrTemp = THR(
            m_pcccCallback->SendStatusReport(
                  NULL
                , TASKID_Major_Configure_Resource_Types
                , *m_pcrtiResTypeInfo->m_pcguidMinorId
                , 0
                , 1
                , 1
                , hr
                , m_bstrStatusReportText
                , NULL
                , NULL
                )
            );

        if ( FAILED( hrTemp ) )
        {
            if ( hr == S_OK )
            {
                hr = hrTemp;
            } // if: no error has occurred so far, consider this as an error.

            LogMsg( "Error %#x occurred trying to send a status report.", hrTemp );
            TraceFlow1( "Error %#x occurred trying to send a status report.", hrTemp );
        } // if: we could not send a status report
    } // if: the callback pointer is not NULL

    //
    // Free allocated resources
    //

    if ( pClusterInfo != NULL )
    {
        pClusterInfo->Release();
    } // if: we got a pointer to the IClusCfgClusterInfo interface

    HRETURN( hr );

} //*** CResourceType::CommitChanges()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::GetTypeName()
//
//  Description:
//      Get the resource type name of this resource type.
//
//  Arguments:
//      pbstrTypeNameOut
//          Pointer to the BSTR that holds the name of the resource type.
//          This BSTR has to be freed by the caller using the function
//          SysFreeString().
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::GetTypeName( BSTR * pbstrTypeNameOut )
{
    TraceFunc( "[IClusCfgResourceTypeInfo]" );

    HRESULT     hr = S_OK;

    TraceFlow1( "Getting the type name of resouce type '%s'.", m_pcrtiResTypeInfo->m_pcszResTypeName );

    do
    {
        if ( pbstrTypeNameOut == NULL )
        {
            LogMsg( "An invalid parameter was specified." );
            TraceFlow( "The output pointer is invalid." );
            hr = THR( E_INVALIDARG );
            break;
        } // if: the output pointer is NULL

        *pbstrTypeNameOut = SysAllocString( m_pcrtiResTypeInfo->m_pcszResTypeName );

        if ( *pbstrTypeNameOut == NULL )
        {
            LogMsg( "An error occurred trying to return the resource type name." );
            TraceFlow( "An error occurred trying to return the resource type name." );
            hr = THR( E_OUTOFMEMORY );
            break;
        } // if: the resource type name could not be copied to the outpu
    }
    while( false ); // dummy do-while loop to avoid gotos

    HRETURN( hr );

} //*** CResourceType::GetTypeName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::GetTypeGUID()
//
//  Description:
//       Get the globally unique identifier of this resource type.
//
//  Arguments:
//       pguidGUIDOut
//           Pointer to the GUID object which will receive the GUID of this
//           resource type.
//
//  Return Values:
//      S_OK
//          The call succeeded and the *pguidGUIDOut contains the type GUID.
//
//      S_FALSE
//          The call succeeded but this resource type does not have a GUID.
//          The value of *pguidGUIDOut is undefined after this call.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::GetTypeGUID( GUID * pguidGUIDOut )
{
    TraceFunc( "[IClusCfgResourceTypeInfo]" );

    HRESULT     hr = S_OK;

    TraceFlow1( "Getting the type GUID of resouce type '%s'.", m_pcrtiResTypeInfo->m_pcszResTypeName );

    if ( pguidGUIDOut == NULL )
    {
        LogMsg( "An invalid parameter was specified." );
        TraceFlow( "The output pointer is invalid." );
        hr = THR( E_INVALIDARG );
    } // if: the output pointer is NULL
    else
    {
        if ( m_pcrtiResTypeInfo->m_pcguidTypeGuid != NULL )
        {
            *pguidGUIDOut = *m_pcrtiResTypeInfo->m_pcguidTypeGuid;
            TraceMsgGUID( mtfALWAYS, "The GUID of this resource type is ", (*m_pcrtiResTypeInfo->m_pcguidTypeGuid) );
        } // if: this resource type has a type GUID
        else
        {
            memset( pguidGUIDOut, 0, sizeof( *pguidGUIDOut ) );
            hr = S_FALSE;
        } // else: this resource type does not have a type GUID
    } // else: the output pointer is valid

    HRETURN( hr );

} //*** CResourceType::GetTypeGUID()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::HrCreateResourceType()
//
//  Description:
//       Create the resource type represented by this object.
//
//  Arguments:
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface of a component that provides
//          methods that help configuring a resource type. For example,
//          during a join or a form, this punk can be queried for the
//          IClusCfgResourceTypeCreate interface, which provides methods
//          for resource type creation.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::HrCreateResourceType( IUnknown * punkResTypeServicesIn )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    IClusCfgResourceTypeCreate *    pResTypeCreate = NULL;

    do
    { 
        //
        // Validate parameters
        //
        if ( punkResTypeServicesIn == NULL )
        {
            LogMsg( "The information about this resource type is invalid." );
            TraceFlow( "An NULL argument is invalid." );
            hr = THR( E_POINTER );
            break;
        } // if: the arguments is NULL

        // Get a pointer to the IClusCfgResourceTypeCreate interface.
        hr = THR( punkResTypeServicesIn->QueryInterface< IClusCfgResourceTypeCreate >( &pResTypeCreate ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to configure the resource type.", hr );
            TraceFlow1( "Error %#x occurred trying to a pointer to the IClusCfgResourceTypeCreate interface.", hr );
            break;
        } // if: we could not get a pointer to the IClusCfgResourceTypeCreate interface

        // Create the resource type
        hr = THR(
            pResTypeCreate->Create(
                  m_pcrtiResTypeInfo->m_pcszResTypeName
                , m_bstrResTypeDisplayName
                , m_pcrtiResTypeInfo->m_pcszResDllName
                , m_pcrtiResTypeInfo->m_dwLooksAliveInterval
                , m_pcrtiResTypeInfo->m_dwIsAliveInterval
                )
            );

        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to create resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );
            TraceFlow2( "Error %#x occurred trying to to create resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );
            break;
        } // if: an error occurred trying to create this resource type

        LogMsg( "Resource type '%s' successfully created.", m_pcrtiResTypeInfo->m_pcszResTypeName  );
        TraceFlow1( "Resource type '%s' successfully created.", m_pcrtiResTypeInfo->m_pcszResTypeName );

        if ( m_pcrtiResTypeInfo->m_cclsidAdminExtCount != 0 )
        {
            hr = THR(
                pResTypeCreate->RegisterAdminExtensions(
                      m_pcrtiResTypeInfo->m_pcszResTypeName
                    , m_pcrtiResTypeInfo->m_cclsidAdminExtCount
                    , m_pcrtiResTypeInfo->m_rgclisdAdminExts
                )
            );

            if ( FAILED( hr ) )
            {
                // If we could not set the admin extenstions property,
                // we will consider the creation of the resource type
                // to be a success. So, we just log the error and continue.
                LogMsg( "Error %#x occurred trying to configure the admin extensions for the resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );
                TraceFlow2( "Error %#x occurred trying to configure the admin extensions for the resource type '%s'.", hr, m_pcrtiResTypeInfo->m_pcszResTypeName );
                hr = S_OK;
            } // if: RegisterAdminExtension() failed

        } // if: this resource type has admin extensions
        else
        {
            TraceFlow( "This resource type does not have admin extensions." );
        } // else: this resource type does not have admin extensions
    }
    while( false ); // dummy do-while loop to avoid gotos

    if ( pResTypeCreate != NULL )
    {
        pResTypeCreate->Release();
    } // if: we got a pointer to the IClusCfgResourceTypeCreate interface

    HRETURN( hr );

} //*** CResourceType::HrCreateResourceType()



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Notify()
//
//  Description:
//      This method is called to inform a component that the cluster service
//      has started on this computer.
//
//      This component is registered for the cluster service startup notification
//      as a part of the cluster service upgrade. This method creates the
//      required resource type and deregisters from this notification.
//
//  Arguments:
//      IUnknown * punkIn
//          The component that implements this Punk may also provide services
//          that are useful to the implementor of this method. For example,
//          this component usually implements the IClusCfgResourceTypeCreate
//          interface.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourceType::Notify( IUnknown * punkIn )
{
    TraceFunc( "[IClusCfgStartupListener]" );

    HRESULT                         hr = S_OK;
    ICatRegister *                  pcrCatReg = NULL;
    const SResourceTypeInfo *       pcrtiResourceTypeInfo = PcrtiGetResourceTypeInfoPtr();

    LogMsg( "Resoure type '%s' received notification of cluster service startup.", pcrtiResourceTypeInfo->m_pcszResTypeName );
    TraceFlow1( "Resoure type '%s' received notification of cluster service startup.", pcrtiResourceTypeInfo->m_pcszResTypeName );

    do
    {
        // Create this resource type
        hr = THR( HrCreateResourceType( punkIn ) );
        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to create resource type '%s'.", hr, pcrtiResourceTypeInfo->m_pcszResTypeName );
            TraceFlow2( "Error %#x occurred trying to gto create resource type '%s'.", hr, pcrtiResourceTypeInfo->m_pcszResTypeName );
            break;
        } // if: an error occurred trying to create this resource type

        LogMsg( "Configuration of resoure type '%s' successful. Trying to deregister from startup notifications.", pcrtiResourceTypeInfo->m_pcszResTypeName );
        TraceFlow1( "Configuration of resoure type '%s' successful. Trying to deregister from startup notifications.", pcrtiResourceTypeInfo->m_pcszResTypeName );

        hr = THR(
            CoCreateInstance(
                  CLSID_StdComponentCategoriesMgr
                , NULL
                , CLSCTX_INPROC_SERVER
                , __uuidof( pcrCatReg )
                , reinterpret_cast< void ** >( &pcrCatReg )
                )
            );

        if ( FAILED( hr ) )
        {
            LogMsg( "Error %#x occurred trying to deregister this component from any more cluster startup notifications.", hr );
            TraceFlow1( "Error %#x occurred trying to create the StdComponentCategoriesMgr component.", hr );
            break;
        } // if: we could not create the StdComponentCategoriesMgr component

        {
            CATID   rgCatId[ 1 ];

            rgCatId[ 0 ] = CATID_ClusCfgStartupListeners;

            hr = THR(
                pcrCatReg->UnRegisterClassImplCategories(
                      *( pcrtiResourceTypeInfo->m_pcguidClassId )
                    , sizeof( rgCatId ) / sizeof( rgCatId[ 0 ] )
                    , rgCatId
                    )
                );

            if ( FAILED( hr ) )
            {
                LogMsg( "Error %#x occurred trying to deregister this component from any more cluster startup notifications.", hr );
                TraceFlow1( "Error %#x occurred during the call to ICatRegister::UnRegisterClassImplCategories().", hr );
                break;
            } // if: we could not deregister this component from startup notifications
        }

        LogMsg( "Successfully deregistered from startup notifications." );
        TraceFlow( "Successfully deregistered from startup notifications." );
    }
    while( false ); // dummy do-while loop to avoid gotos


    //
    // Free allocated resources
    //

    if ( pcrCatReg != NULL )
    {
        pcrCatReg->Release();
    } // if: we got a pointer to the ICatRegister interface

    HRETURN( hr );

} //*** CResourceType::Notify()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\resourcetype.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResourceType.h
//
//  Description:
//      This file contains the declaration of the CResourceType
//      class. This class handles the configuration of a resource type
//      when the local computer forms or joins a cluster or when it is
//      evicted from a cluster. This class is the base class of other
//      resource type configuration classes.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CResourceType.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 14-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For the GUID structure
#include <guiddef.h>

// For IClusCfgResourceTypeInfo and IClusCfgInitialize
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

// A structure that holds information required to create a resource type.
struct SResourceTypeInfo
{
    const GUID *      m_pcguidClassId;                      // Class id of this component
    const WCHAR *     m_pcszResTypeName;                    // Pointer to the resource type name
    UINT              m_uiResTypeDisplayNameStringId;       // String id of the resource type display name
    const WCHAR *     m_pcszResDllName;                     // Pointer to the name or full path to the resource type DLL
    DWORD             m_dwLooksAliveInterval;               // The looks-alive poll interval
    DWORD             m_dwIsAliveInterval;                  // The is-alive poll interval
    const CLSID *     m_rgclisdAdminExts;                   // Pointer to an array of cluster admin extension class ids
    UINT              m_cclsidAdminExtCount;                // Number of elements in the above array
    const GUID *      m_pcguidTypeGuid;                     // The resource type GUID. This can be NULL.
    const GUID *      m_pcguidMinorId;                      // The minor id of the status report sent by this resource type
}; //*** SResourceTypeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResourceType
//
//  Description:
//      This class handles the configuration of a resource type
//      when the local computer forms or joins a cluster or when it is
//      evicted from a cluster. This class is the base class of other
//      resource type configuration classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResourceType
    : public IClusCfgResourceTypeInfo
    , public IClusCfgStartupListener
    , public IClusCfgInitialize
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgResourceTypeInfo methods
    //////////////////////////////////////////////////////////////////////////

    // Indicate that the resource type configuration needs to be performed.
    STDMETHOD( CommitChanges )(
          IUnknown * punkClusterInfoIn
        , IUnknown * punkResTypeServicesIn
        );

    // Get the resource type name of this resource type.
    STDMETHOD( GetTypeName )(
        BSTR *  pbstrTypeNameOut
        );

    // Get the globally unique identifier of this resource type.
    STDMETHOD( GetTypeGUID )(
        GUID * pguidGUIDOut
        );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgStartupListener methods
    //////////////////////////////////////////////////////////////////////////

    // Do the tasks that need to be done when the cluster service starts on this
    // computer.
    STDMETHOD( Notify )(
          IUnknown * punkIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Initialize this object.
    STDMETHOD( Initialize )(
          IUnknown *   punkCallbackIn
        , LCID         lcidIn
        );


protected:
    //////////////////////////////////////////////////////////////////////////
    //  Protected static functions
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance(
          CResourceType *               pResTypeObjectIn
        , const SResourceTypeInfo *     pcrtiResTypeInfoIn
        , IUnknown **                   ppunkOut
        );

    // Registers this class with the categories that it belongs to.
    static HRESULT S_RegisterCatIDSupport( 
          const GUID &      rclsidCLSIDIn
        , ICatRegister *    picrIn
        , BOOL              fCreateIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  Protected virtual functions
    //////////////////////////////////////////////////////////////////////////

    // The tasks that need to be performed after cluster creation are done here.
    // This method can be overridden by derived classes to change the behavior during
    // commit. In this class, the resource type is created during commit.
    virtual HRESULT HrProcessCreate( IUnknown * punkResTypeServicesIn )
    {
        return HrCreateResourceType( punkResTypeServicesIn );
    }

    // The tasks that need to be performed after node addition are done here.
    // This method can be overridden by derived classes to change the behavior during
    // commit. In this class, the resource type is created during commit.
    virtual HRESULT HrProcessAddNode( IUnknown * punkResTypeServicesIn )
    {
        return HrCreateResourceType( punkResTypeServicesIn );
    }

    // The tasks that need to be performed after node eviction are done here.
    // This method can be overridden by derived classes to change the behavior during
    // commit. In this class, nothing is done by this function.
    virtual HRESULT HrProcessCleanup( IUnknown * punkResTypeServicesIn )
    {
        // As of now, then there is nothing that need be done here.
        // If needed, code for evict processing may be added here in the future.
        return S_OK;
    }

    // This function creates the resource type represented by this object.
    virtual HRESULT HrCreateResourceType( IUnknown * punkResTypeServicesIn );


    //////////////////////////////////////////////////////////////////////////
    //  Protected accessor functions
    //////////////////////////////////////////////////////////////////////////
    
    // Get the pointer to the resource type info structure
    const SResourceTypeInfo * PcrtiGetResourceTypeInfoPtr( void )
    {
        return m_pcrtiResTypeInfo;
    } //*** RtiGetResourceTypeInfo()

    // Get the resource type display name
    const WCHAR * PcszGetTypeDisplayName( void )
    {
        return m_bstrResTypeDisplayName;
    } //*** PcszGetTypeDisplayName()


    //
    // Protected constructors, destructor and assignment operator.
    // All of these methods are protected for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CResourceType( void );

    // Destructor.
    virtual ~CResourceType( void );

    // Copy constructor.
    CResourceType( const CResourceType & );

    // Assignment operator.
    CResourceType & operator =( const CResourceType & );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Second phase of a two phase constructor.
    HRESULT HrInit(
        const SResourceTypeInfo *     pcrtiResTypeInfoIn
        );

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                        m_cRef;

    // Pointer to the callback interface.
    IClusCfgCallback *          m_pcccCallback;

    // The locale id
    LCID                        m_lcid;

    // The display name of this resource type.
    BSTR                        m_bstrResTypeDisplayName;

    // The text sent with the status report sent by this resource type
    BSTR                        m_bstrStatusReportText;

    // Pointer to structure that contains information about this resource type.
    const SResourceTypeInfo *   m_pcrtiResTypeInfo;

}; //*** class CResourceType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\restypeservices.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResTypeServices.cpp
//
//  Description:
//      This file contains the implementation of the CResTypeServices
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      CResTypeServices.h
//
//  Maintained By:
//      Vij Vasu (VVasu) 15-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// For UuidToString() and other functions
#include <RpcDce.h>

// The header file for this class
#include "ResTypeServices.h"

// For CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS
#include "clusudef.h"

//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CResTypeServices" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::CResTypeServices()
//
//  Description:
//      Constructor of the CResTypeServices class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResTypeServices::CResTypeServices( void )
    : m_cRef( 1 )
    , m_pccciClusterInfo( NULL )
    , m_hCluster( NULL )
    , m_fOpenClusterAttempted( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CResTypeServices::CResTypeServices


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::~CResTypeServices()
//
//  Description:
//      Destructor of the CResTypeServices class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResTypeServices::~CResTypeServices( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    // Release the cluster info interface
    if ( m_pccciClusterInfo != NULL )
    {
        m_pccciClusterInfo->Release();
    } // if: the cluster info interface pointer is not NULL

    if ( m_hCluster != NULL )
    {
        CloseCluster( m_hCluster );
    } // if: we had opened a handle to the cluster

    TraceFuncExit();

} //*** CResTypeServices::~CResTypeServices


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CResTypeServices::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CResTypeServices instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeServices::S_HrCreateInstance(
    IUnknown **                   ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = E_INVALIDARG;
    CResTypeServices *     pResTypeServices = NULL;

    do
    {
        // Allocate memory for the new object.
        pResTypeServices = new CResTypeServices();
        if ( pResTypeServices == NULL )
        {
            LogMsg( "Could not allocate memory for a resource type services object." );
            TraceFlow( "Could not allocate memory for a resource type services object." );
            hr = THR( E_OUTOFMEMORY );
            break;
        } // if: out of memory

        hr = THR( pResTypeServices->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );

        TraceFlow1( "*ppunkOut = %#X.", *ppunkOut );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( pResTypeServices != NULL )
    {
        pResTypeServices->Release();
    } // if: the pointer to the resource type object is not NULL

    HRETURN( hr );

} //*** CResTypeServices::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CResTypeServices::AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResTypeServices::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    TraceFlow1( "m_cRef = %d", m_cRef );

    RETURN( m_cRef );

} //*** CResTypeServices::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CResTypeServices::Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CResTypeServices::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    TraceFlow1( "m_cRef = %d", m_cRef );

    if ( m_cRef == 0 )
    {
        TraceDo( delete this );
        RETURN( 0 );
    } // if: reference count decremented to zero

    RETURN( m_cRef );

} //*** CResTypeServices::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CResTypeServices::QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riid
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResTypeServices::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = S_OK;

    if ( ppv != NULL )
    {
        if ( IsEqualIID( riid, IID_IUnknown ) )
        {
            *ppv = static_cast< IClusCfgResourceTypeCreate * >( this );
        } // if: IUnknown
        else if ( IsEqualIID( riid, IID_IClusCfgResourceTypeCreate ) )
        {
            *ppv = TraceInterface( __THISCLASS__, IClusCfgResourceTypeCreate, this, 0 );
        } // else if:
        else if ( IsEqualIID( riid, IID_IClusCfgResTypeServicesInitialize ) )
        {
            *ppv = TraceInterface( __THISCLASS__, IClusCfgResTypeServicesInitialize, this, 0 );
        } // else if:
        else
        {
            hr = E_NOINTERFACE;
        } // else

        if ( SUCCEEDED( hr ) )
        {
            ((IUnknown *) *ppv)->AddRef( );
        } // if: success
        else
        {
            *ppv = NULL;
        } // else: something failed

    } // if: the output pointer was valid
    else
    {
        hr = E_INVALIDARG;
    } // else: the output pointer is invalid


    QIRETURN( hr, riid );

} //*** CResTypeServices::QueryInterface()



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::SetParameters()
//
//  Description:
//      Set the parameters required by this component.
//
//  Arguments:
//      pccciIn
//          Pointer to an interface that provides information about the cluster
//          being configured.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeServices::SetParameters( IClusCfgClusterInfo * pccciIn )
{
    TraceFunc( "[IClusCfgResTypeServicesInitialize]" );

    HRESULT hr = S_OK;

    //
    // Validate and store the parameters.
    //
    do
    {
        //
        // Validate and store the cluster info pointer.
        //
        if ( pccciIn == NULL )
        {
            LogMsg( "The information about this cluster is invalid." );
            TraceFlow( "An NULL cluster info pointer is invalid." );
            hr = THR( E_POINTER );
            break;
        } // if: the cluster info pointer is invalid

        // If we already have a valid pointer, release it.
        if ( m_pccciClusterInfo != NULL )
        {
            m_pccciClusterInfo->Release();
        } // if: the pointer we have is not NULL

        // Store the input pointer and addref it.
        m_pccciClusterInfo = pccciIn;
        m_pccciClusterInfo->AddRef();
    }
    while( false ); // dummy do-while loop to avoid gotos

    HRETURN( hr );

} //*** CResTypeServices::SetParameters()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::Create()
//
//  Description:
//      This method creates a cluster resource type.
//
//  Arguments:
//      pcszResTypeNameIn
//          Name of the resource type
//
//      pcszResTypeDisplayNameIn
//          Display name of the resource type
//
//      pcszResDllNameIn
//          Name (with or without path information) of DLL of the resource type.
//
//      dwLooksAliveIntervalIn
//          Looks-alive interval for the resource type (in milliseconds).
//
//      dwIsAliveIntervalIn
//          Is-alive interval for the resource type (in milliseconds).
//
// Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs.
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeServices::Create(
      const WCHAR *     pcszResTypeNameIn
    , const WCHAR *     pcszResTypeDisplayNameIn
    , const WCHAR *     pcszResDllNameIn
    , DWORD             dwLooksAliveIntervalIn
    , DWORD             dwIsAliveIntervalIn
    )
{
    TraceFunc( "[IClusCfgResourceTypeCreate]" );

    HRESULT         hr = S_OK;
    DWORD           dwError = ERROR_SUCCESS;
    ECommitMode     ecmCommitChangesMode = cmUNKNOWN;

    do
    {
        // Check if we have tried to get the cluster handle. If not, try now.
        if ( !m_fOpenClusterAttempted )
        {
            m_fOpenClusterAttempted = true;
            m_hCluster = OpenCluster( NULL );
            if ( m_hCluster == NULL )
            {
                hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                LogMsg( "Error %#x occurred trying to open a handle to the cluster. Resource type creation cannot proceed.", hr );
                TraceFlow1( "Error %#x occurred trying to open a handle to the cluster. Resource type creation cannot proceed.", hr );
                break;
            } // if: OpenCluster() failed
        } // if: we have not tried to open the handle to the cluster before
        else
        {
            if ( m_hCluster == NULL )
            {
                hr = THR( E_HANDLE );
                LogMsg( "The cluster handle is NULL. Resource type creation cannot proceed." );
                TraceFlow( "The cluster handle is NULL. Resource type creation cannot proceed." );
                break;
            } // if: the cluster handle is NULL
        } // if: we have tried to open the handle to the cluster


        //
        // Validate the parameters
        //
        if (    ( pcszResTypeNameIn == NULL )
             || ( pcszResTypeDisplayNameIn == NULL )
             || ( pcszResDllNameIn == NULL )
           )
        {
            LogMsg( "The information about this resource type is invalid." );
            TraceFlow( "One or more parameters are invalid." );
            hr = THR( E_POINTER );
            break;
        } // if: the parameters are invalid

        LogMsg( "Configuring resource type '%ws'.", pcszResTypeNameIn );
        TraceFlow1( "Configuring resource type '%ws'.", pcszResTypeNameIn );

        if ( m_pccciClusterInfo != NULL )
        {
            hr = THR( m_pccciClusterInfo->GetCommitMode( &ecmCommitChangesMode ) );
            if ( FAILED( hr ) )
            {
                LogMsg( "Error %#x occurred trying to find out commit changes mode of the cluster.", hr );
                TraceFlow1( "Error %#x occurred trying to find out commit changes mode of the cluster.", hr );
                break;
            } // if: GetCommitMode() failed
        } // if: we have a configuration info interface pointer
        else
        {
            // If we do not have a pointer to the cluster info interface, assume that this is a add node to cluster
            // This way, if the resource type already exists, then we do not throw up an error.
            TraceFlow( "We do not have a cluster configuration info pointer. Assuming that this is a add node to cluster." );
            ecmCommitChangesMode = cmADD_NODE_TO_CLUSTER;
        } // else: we don't have a configuration info interface pointer

        // Create the resource type
        // Cannot wrap call with THR() because it can fail with ERROR_ALREADY_EXISTS.
        dwError =
            CreateClusterResourceType(
                  m_hCluster
                , pcszResTypeNameIn
                , pcszResTypeDisplayNameIn
                , pcszResDllNameIn
                , dwLooksAliveIntervalIn
                , dwIsAliveIntervalIn
                );

        if ( ( ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER ) && ( dwError == ERROR_ALREADY_EXISTS ) )
        {
            // If we are joining a cluster, it is ok for CreateClusterResourceType()
            // to fail with ERROR_ALREADY_EXISTS.
            TraceFlow1( "Resource type '%ws' already exists.", pcszResTypeNameIn );
            dwError = ERROR_SUCCESS;

        } // if: we are joining and ERROR_ALREADY_EXISTS was returned

        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            LogMsg( "Error %#x occurred trying to create resource type '%ws'.", dwError, pcszResTypeNameIn );
            TraceFlow2( "Error %#x occurred trying to to create resource type '%ws'.", dwError, pcszResTypeNameIn );
            break;
        } // if: an error occurred trying to create this resource type

        LogMsg( "Resource type '%ws' successfully created.", pcszResTypeNameIn  );
        TraceFlow1( "Resource type '%ws' successfully created.", pcszResTypeNameIn );
    }
    while( false ); // dummy do-while loop to avoid gotos

    HRETURN( hr );

} //*** CResTypeServices::Create()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeServices::RegisterAdminExtensions()
//
//  Description:
//      This method registers the cluster administrator extensions for
//      a resource type.
//
//  Arguments:
//      pcszResTypeNameIn
//          Name of the resource type against for the extensions are to be
//          registered.
//
//      cExtClsidCountIn
//          Number of extension class ids in the next parameter.
//
//      rgclsidExtClsidsIn
//          Pointer to an array of class ids of cluster administrator extensions.
//          This can be NULL if cExtClsidCountIn is 0.
//
// Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs.
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResTypeServices::RegisterAdminExtensions(
      const WCHAR *       pcszResTypeNameIn
    , ULONG               cExtClsidCountIn
    , const CLSID *       rgclsidExtClsidsIn
    )
{
    TraceFunc( "[IClusCfgResourceTypeCreate]" );

    HRESULT                 hr = S_OK;
    WCHAR **                rgpszClsidStrings = NULL;
    ULONG                   idxCurrentString = 0;
    BYTE *                  pbClusPropBuffer = NULL;

    do
    {
        ULONG   cchClsidMultiSzSize = 0;
        ULONG   cbAdmExtBufferSize = 0;

        // Check if we have tried to get the cluster handle. If not, try now.
        if ( !m_fOpenClusterAttempted )
        {
            m_fOpenClusterAttempted = true;
            m_hCluster = OpenCluster( NULL );
            if ( m_hCluster == NULL )
            {
                hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                LogMsg( "Error %#x occurred trying to open a handle to the cluster. Resource type creation cannot proceed.", hr );
                TraceFlow1( "Error %#x occurred trying to open a handle to the cluster. Resource type creation cannot proceed.", hr );
                break;
            } // if: OpenCluster() failed
        } // if: we have not tried to open the handle to the cluster before
        else
        {
            if ( m_hCluster == NULL )
            {
                hr = THR( E_HANDLE );
                LogMsg( "The cluster handle is NULL. Resource type creation cannot proceed." );
                TraceFlow( "The cluster handle is NULL. Resource type creation cannot proceed." );
                break;
            } // if: the cluster handle is NULL
        } // if: we have tried to open the handle to the cluster


        //
        // Validate the parameters
        //

        if ( cExtClsidCountIn == 0 )
        {
            // There is nothing to do
            TraceFlow( "There is nothing to do." );
            break;
        } // if: there are no extensions to register

        if (    ( pcszResTypeNameIn == NULL )
             || ( rgclsidExtClsidsIn == NULL )
           )
        {
            LogMsg( "The information about this resource type is invalid." );
            TraceFlow( "One or more parameters are invalid." );
            hr = THR( E_POINTER );
            break;
        } // if: the parameters are invalid

        LogMsg( "Registering %d cluster administrator extensions for resource type '%ws'.", cExtClsidCountIn, pcszResTypeNameIn );
        TraceFlow2( "Registering %d cluster administrator extensions for resource type '%ws'.", cExtClsidCountIn, pcszResTypeNameIn );

        // Allocate an array of pointers to store the string version of the class ids
        rgpszClsidStrings = new WCHAR *[ cExtClsidCountIn ];
        if ( rgpszClsidStrings == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            LogMsg( "Error: Memory for the string version of the cluster administrator extension class ids could not be allocated." );
            TraceFlow( "Error: Memory for the string version of the cluster administrator extension class ids could not be allocated." );
            break;
        } // if: a memory allocation failure occurred

        // Zero out the pointer array
        ZeroMemory( rgpszClsidStrings, sizeof( rgpszClsidStrings[ 0 ] ) * cExtClsidCountIn );

        //
        // Get the string versions of the input class ids
        //
        for( idxCurrentString = 0; idxCurrentString < cExtClsidCountIn; ++idxCurrentString )
        {
            hr = THR( UuidToString( const_cast< UUID * >( &rgclsidExtClsidsIn[ idxCurrentString ] ), &rgpszClsidStrings[ idxCurrentString ] ) );
            if ( hr != RPC_S_OK )
            {
                LogMsg( "Error %#x occurred trying to get the string version of an extension class id.", hr );
                TraceFlow1( "Error %#x occurred trying to get the string version of an extension class id.", hr );
                break;
            } // if: we could not convert the current clsid to a string

            // Add the size of the current string to the total size. Include two extra characters for the opening and
            // closing flower braces {} that need to be added to each clsid string.
            cchClsidMultiSzSize += ( ULONG ) wcslen( rgpszClsidStrings[ idxCurrentString ] ) + 2 + 1;
        } // for: get the string version of each input clsid

        if ( hr != S_OK )
        {
            break;
        } // if: something went wrong in the loop above

        // Account for the extra terminating L'\0' in a multi-sz string
        ++cchClsidMultiSzSize;

        //
        // Construct the property list required to set the admin extension property for this
        // resource type in the cluster database
        //
        {
            CLUSPROP_BUFFER_HELPER  cbhAdmExtPropList;
            ULONG                   cbAdminExtensionSize = cchClsidMultiSzSize * sizeof( *rgpszClsidStrings[ 0 ] );

            //
            // Create and store the property list that will be used to
            // register these admin extensions with the cluster.
            //

            // Determine the number of bytes in the propertly list that will be used to
            // set the admin extensions property for this resource type.
            cbAdmExtBufferSize =
                  sizeof( cbhAdmExtPropList.pList->nPropertyCount )
                + sizeof( *cbhAdmExtPropList.pName ) + ALIGN_CLUSPROP( sizeof( CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS ) )
                + sizeof( *cbhAdmExtPropList.pMultiSzValue ) + ALIGN_CLUSPROP( cbAdminExtensionSize )
                + sizeof( CLUSPROP_SYNTAX_ENDMARK );

            // Allocate the buffer for this property list.
            pbClusPropBuffer = new BYTE[ cbAdmExtBufferSize ];
            if ( pbClusPropBuffer == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                LogMsg( "Error: Memory for the property list of cluster administrator extensions could not be allocated." );
                TraceFlow( "Error: Memory for the property list of cluster administrator extensions could not be allocated." );
                break;
            } // if: memory allocation failed

            //
            // Initialize this property list.
            //

            // Pointer cbhAdmExtPropList to the newly allocated memory
            cbhAdmExtPropList.pb = pbClusPropBuffer;

            // There is only one property in this list.
            cbhAdmExtPropList.pList->nPropertyCount = 1;
            ++cbhAdmExtPropList.pdw;

            // Set the name of the property.
            cbhAdmExtPropList.pName->cbLength = sizeof( CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS );
            cbhAdmExtPropList.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
            memcpy( cbhAdmExtPropList.pName->sz, CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS, sizeof( CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS ) );
            cbhAdmExtPropList.pb += sizeof( *cbhAdmExtPropList.pName ) + ALIGN_CLUSPROP( sizeof( CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS ) );

            // Set the value of the property.
            cbhAdmExtPropList.pMultiSzValue->cbLength = cbAdminExtensionSize;
            cbhAdmExtPropList.pMultiSzValue->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_MULTI_SZ;
            {
                WCHAR * pszCurrentString = cbhAdmExtPropList.pMultiSzValue->sz;

                for( idxCurrentString = 0; idxCurrentString < cExtClsidCountIn; ++ idxCurrentString )
                {
                    ULONG cchCurrentStringSize = (ULONG) wcslen( rgpszClsidStrings[ idxCurrentString ] ) + 1;

                    // Prepend opening brace
                    *pszCurrentString = L'{';
                    ++pszCurrentString;

                    wcsncpy( pszCurrentString, rgpszClsidStrings[ idxCurrentString ], cchCurrentStringSize );
                    pszCurrentString += cchCurrentStringSize - 1;

                    // Overwrite the terminating '\0' with a closing brace
                    *pszCurrentString = L'}';
                    ++pszCurrentString;

                    // Terminate the current string
                    *pszCurrentString = L'\0';
                    ++pszCurrentString;

                } // for: copy each of the clsid strings into a contiguous buffer

                // Add the extra L'\0' required by multi-sz strings
                *pszCurrentString = L'\0';
            }
            cbhAdmExtPropList.pb += sizeof( *cbhAdmExtPropList.pMultiSzValue ) + ALIGN_CLUSPROP( cbAdminExtensionSize );

            // Set the end mark for this property list.
            cbhAdmExtPropList.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
        }

        // Set the AdminExtensions common property.
        {
            DWORD dwError = TW32(
                ClusterResourceTypeControl(
                      m_hCluster
                    , pcszResTypeNameIn
                    , NULL
                    , CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES
                    , pbClusPropBuffer
                    , cbAdmExtBufferSize
                    , NULL
                    , 0
                    , NULL
                    )
                );

            if ( dwError != ERROR_SUCCESS )
            {
                // We could not set the admin extenstions property,
                LogMsg( "Error %#x occurred trying to configure the admin extensions for the resource type '%ws'.", dwError, pcszResTypeNameIn );
                TraceFlow2( "Error %#x occurred trying to configure the admin extensions for the resource type '%ws'.", dwError, pcszResTypeNameIn );
                hr = HRESULT_FROM_WIN32( dwError );
                break;
            } // if: ClusterResourceTypeControl() failed
        }
    }
    while( false ); // dummy do-while loop to avoid gotos

    //
    // Cleanup
    //

    if ( rgpszClsidStrings != NULL )
    {
        // Free all the strings that were allocated
        for( idxCurrentString = 0; idxCurrentString < cExtClsidCountIn; ++idxCurrentString )
        {
            if ( rgpszClsidStrings[ idxCurrentString ] != NULL )
            {
                // Free the current string
                RpcStringFree( &rgpszClsidStrings[ idxCurrentString ] );
            } // if: this pointer points to a string
            else
            {
                // If we are here, it means all the strings were not allocated
                // due to some error. No need to free any more strings.
                break;
            } // else: the current string pointer is NULL
        } // for: iterate through the array of pointer and free them

        // Free the array of pointers
        delete [] rgpszClsidStrings;

    } // if: we had allocated the array of strings

    if ( pbClusPropBuffer != NULL )
    {
        delete pbClusPropBuffer;
    } // if: we had allocated a property list

    HRETURN( hr );

} //*** CResTypeServices::RegisterAdminExtensions()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     15-JUN-2000
//      Vijay Vasu (VVasu)          15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
#define USES_SYSALLOCSTRING
#endif // DBG==1

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>

#include <common.h>
#include <debug.h>
#include <Log.h>
#include <citracker.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgcapabilities.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCapabilities.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgCapabilities class.
//
//      The class CClusCfgCapabilities is the implementations of the
//      IClusCfgCapabilities interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgCapabilities.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusCfgCapabilities.h"
#include <ClusRtl.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgCapabilities" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgCapabilities instance.
//
//  Arguments:
//      ppunkOut    -
//
//  Return Values:
//      Pointer to CClusCfgCapabilities instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CClusCfgCapabilities *    pccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccs = new CClusCfgCapabilities();
    if ( pccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgCapabilities::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccs != NULL )
    {
        pccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgCapabilities::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CClusCfgCapabilities::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_ClusCfgCapabilities;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_ClusCfgCapabilities, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCapabilities::S_RegisterCatIDSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::CClusCfgCapabilities
//
//  Description:
//      Constructor of the CClusCfgCapabilities class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCapabilities::CClusCfgCapabilities( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );

    TraceFuncExit();

} //*** CClusCfgCapabilities::CClusCfgCapabilities


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::~CClusCfgCapabilities
//
//  Description:
//      Destructor of the CClusCfgCapabilities class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCapabilities::~CClusCfgCapabilities( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgCapabilities::~CClusCfgCapabilities


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgCapabilities:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCapabilities::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgCapabilities::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgCapabilities:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCapabilities::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CClusCfgCapabilities::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCapabilities::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgCapabilities * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgCapabilities ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCapabilities, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusCfgCapabilities::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The punkCallbackIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCapabilities::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCapabilities::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities class -- IClusCfgCapabilities interfaces.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::CanNodeBeClustered
//
//  Description:
//      Can this node be added to a cluster?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Node can be clustered.
//
//      S_FALSE
//          Node cannot be clustered.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCapabilities::CanNodeBeClustered( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    //
    //  Since this only displays a warning there is no need to abort the whole
    //  process if this call fails.
    //
    THR( HrCheckForSFM() );

    hr = STHR( HrIsOSVersionValid() );

    HRETURN( hr );

} //*** CClusCfgCapabilities::CanNodeBeClustered


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCapabilities class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::HrInit( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    HRETURN( hr );

} //*** CClusCfgCapabilities::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::HrCheckForSFM
//
//  Description:
//      Checks for Services for Macintosh (SFM) and displays a warning
//      in the UI if found.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::HrCheckForSFM( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BOOL    fSFMInstalled = FALSE;
    DWORD   sc;

    sc = TW32( ClRtlIsServicesForMacintoshInstalled( &fSFMInstalled ) );
    if ( sc == ERROR_SUCCESS )
    {
        if ( fSFMInstalled )
        {
            LogMsg( L"[SRV] Services for Macintosh was found on this node." );
            hr = S_FALSE;
            STATUS_REPORT( TASKID_Major_Check_Node_Feasibility, TASKID_Minor_ServicesForMac_Installed, IDS_WARNING_SERVICES_FOR_MAC_INSTALLED, hr );
        } // if:
    } // if:
    else
    {
        hr = HRESULT_FROM_WIN32( sc );
        STATUS_REPORT( TASKID_Major_Check_Node_Feasibility, TASKID_Minor_ServicesForMac_Installed, IDS_ERROR_SERICES_FROM_MAC_FAILED, hr );
    } // else:

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCapabilities::HrCheckForSFM


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCapabilities::HrIsOSVersionValid
//
//  Description:
//      Can this node be added to a cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Node can be clustered.
//
//      S_FALSE
//          Node cannot be clustered.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCapabilities::HrIsOSVersionValid( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HRESULT hrSSR;
    BOOL    fRet;
    BSTR    bstrMsg = NULL;

    //
    // Get the message to be displayed in the UI for status reports.
    //
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_VALIDATING_NODE_OS_VERSION, &bstrMsg ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Send the initial status report to be displayed in the UI.
    //
    hrSSR = THR( HrSendStatusReport(
                          m_picccCallback
                        , TASKID_Major_Check_Node_Feasibility
                        , TASKID_Minor_Validating_Node_OS_Version
                        , 0
                        , 1
                        , 0
                        , S_OK
                        , bstrMsg
                        ) );
    if ( FAILED( hrSSR ) )
    {
        hr = hrSSR;
        goto Cleanup;
    } // if:

    //
    // Find out if the OS is valid for clustering.
    //
    fRet = ClRtlIsOSValid();
    if ( ! fRet )
    {
        DWORD sc = TW32( GetLastError() );
        hrSSR = HRESULT_FROM_WIN32( sc );
        hr = S_FALSE;
    } // if:
    else
    {
        hrSSR = S_OK;
    } // else:

    //
    // Send the final status report.
    //
    hrSSR = THR( HrSendStatusReport(
                          m_picccCallback
                        , TASKID_Major_Check_Node_Feasibility
                        , TASKID_Minor_Validating_Node_OS_Version
                        , 0
                        , 1
                        , 1
                        , hrSSR
                        , bstrMsg
                        ) );
    if ( FAILED( hrSSR ) )
    {
        hr = hrSSR;
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrMsg );

    HRETURN( hr );

} //*** CClusCfgCapabilities::HrIsOSVersionValid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgcallback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgCallback
//       class.
//
//      The class CClusCfgCallback inplements the callback
//      interface between this server and its clients.  It implements the
//      IClusCfgCallback interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgCallback.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusCfgCallback.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgCallback" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback class
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgCallback instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the newly created object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CClusCfgCallback *  lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CClusCfgCallback();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() succeeded

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgCallback::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    HRETURN( hr );

} //*** CClusCfgCallback::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::CClusCfgCallback
//
//  Description:
//      Constructor of the CClusCfgCallback class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCallback::CClusCfgCallback( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_pccc == NULL );
    Assert( m_hEvent == NULL );

    Assert( m_pcszNodeName == NULL );
    Assert( m_pclsidTaskMajor == NULL );
    Assert( m_pclsidTaskMinor == NULL );
    Assert( m_pulMin == NULL );
    Assert( m_pulMax == NULL );
    Assert( m_pulCurrent == NULL );
    Assert( m_phrStatus == NULL );
    Assert( m_pcszDescription == NULL );
    Assert( m_pftTime == NULL );
    Assert( m_pcszReference == NULL );
    Assert( !m_fPollingMode );
    Assert( m_bstrNodeName == NULL );
    Assert( m_plLogger == NULL );

    TraceFuncExit();

} //*** CClusCfgCallback::CClusCfgCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::~CClusCfgCallback
//
//  Description:
//      Desstructor of the CClusCfgCallback class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgCallback::~CClusCfgCallback( void )
{
    TraceFunc( "" );

    if ( m_hEvent != NULL )
    {
        if ( CloseHandle( m_hEvent ) == false )
        {
            TW32( GetLastError() );
            LogMsg( L"[SRV] Cannot close event handle.  (sc = %#08x)", GetLastError() );
        }
    } // if:

    TraceSysFreeString( m_bstrNodeName );

    if ( m_pccc != NULL )
    {
        m_pccc->Release();
    } // if:

    if ( m_plLogger != NULL )
    {
        m_plLogger->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgCallback::~CClusCfgCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SendStatusReport(
    CLSID           clsidTaskMajorIn,
    CLSID           clsidTaskMinorIn,
    ULONG           ulMinIn,
    ULONG           ulMaxIn,
    ULONG           ulCurrentIn,
    HRESULT         hrStatusIn,
    const WCHAR *   pcszDescriptionIn
    )
{
    TraceFunc1( "pcszDescriptionIn = '%ls'", pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    FILETIME    ft;

    bstrDescription = TraceSysAllocString( pcszDescriptionIn );
    if ( bstrDescription == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    hr = THR( SendStatusReport(
                            NULL,
                            clsidTaskMajorIn,
                            clsidTaskMinorIn,
                            ulMinIn,
                            ulMaxIn,
                            ulCurrentIn,
                            hrStatusIn,
                            bstrDescription,
                            &ft,
                            NULL
                            ) );

Cleanup:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CClusCfgCallback::SendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SendStatusReport(
    CLSID           clsidTaskMajorIn,
    CLSID           clsidTaskMinorIn,
    ULONG           ulMinIn,
    ULONG           ulMaxIn,
    ULONG           ulCurrentIn,
    HRESULT         hrStatusIn,
    DWORD           dwDescriptionIn
    )
{
    TraceFunc1( "dwDescriptionIn = %d", dwDescriptionIn );

    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    FILETIME    ft;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, dwDescriptionIn, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    GetSystemTimeAsFileTime( &ft );

    hr = THR( SendStatusReport(
                            NULL,
                            clsidTaskMajorIn,
                            clsidTaskMinorIn,
                            ulMinIn,
                            ulMaxIn,
                            ulCurrentIn,
                            hrStatusIn,
                            bstrDescription,
                            &ft,
                            NULL
                            ) );

Cleanup:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CClusCfgCallback::SendStatusReport


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgCallback:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCallback::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgCallback::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgCallback:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgCallback::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef > 0 )
    {
        RETURN( m_cRef );
    } // if: reference count equal to zero

    TraceDo( delete this );

    RETURN( 0 );

} //*** CClusCfgCallback::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgCallback * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgPollingCallback ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgPollingCallback, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgSetPollingCallback ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgSetPollingCallback, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusCfgCallback::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IClusCfgCallback interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SendStatusReport(
    LPCWSTR     pcszNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    LPCWSTR     pcszDescriptionIn,
    FILETIME *  pftTimeIn,
    LPCWSTR     pcszReferenceIn
    )
{
    TraceFunc1( "[IClusCfgCallback] pcszDescriptionIn = '%s'", pcszDescriptionIn == NULL ? TEXT("<null>") : pcszDescriptionIn );

    HRESULT hr = S_OK;

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrNodeName;
    } // if:

    TraceMsg( mtfFUNC, L"pcszNodeNameIn = %s", pcszNodeNameIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMajorIn ", clsidTaskMajorIn );
    TraceMsgGUID( mtfFUNC, "clsidTaskMinorIn ", clsidTaskMinorIn );
    TraceMsg( mtfFUNC, L"ulMinIn = %u", ulMinIn );
    TraceMsg( mtfFUNC, L"ulMaxIn = %u", ulMaxIn );
    TraceMsg( mtfFUNC, L"ulCurrentIn = %u", ulCurrentIn );
    TraceMsg( mtfFUNC, L"hrStatusIn = %#x", hrStatusIn );
    TraceMsg( mtfFUNC, L"pcszDescriptionIn = '%ws'", ( pcszDescriptionIn ? pcszDescriptionIn : L"<null>" ) );
    //
    //  TODO:   21 NOV 2000 GalenB
    //
    //  How do we log pftTimeIn?
    //
    TraceMsg( mtfFUNC, L"pcszReferenceIn = '%ws'", ( pcszReferenceIn ? pcszReferenceIn : L"<null>" ) );

    hr = THR( CClCfgSrvLogger::S_HrLogStatusReport(
                      m_plLogger
                    , pcszNodeNameIn
                    , clsidTaskMajorIn
                    , clsidTaskMinorIn
                    , ulMinIn
                    , ulMaxIn
                    , ulCurrentIn
                    , hrStatusIn
                    , pcszDescriptionIn
                    , pftTimeIn
                    , pcszReferenceIn
                    ) );

    //  Local logging - don't send up
    if ( IsEqualIID( clsidTaskMajorIn, TASKID_Major_Server_Log ) )
    {
        goto Cleanup;
    } // if:

    if ( m_fPollingMode )
    {
        Assert( m_pccc == NULL );
        TraceMsg( mtfFUNC, L"[SRV] Sending the status message with polling." );

        hr = THR( HrQueueStatusReport(
                                pcszNodeNameIn,
                                clsidTaskMajorIn,
                                clsidTaskMinorIn,
                                ulMinIn,
                                ulMaxIn,
                                ulCurrentIn,
                                hrStatusIn,
                                pcszDescriptionIn,
                                pftTimeIn,
                                pcszReferenceIn
                                ) );
    } // if:
    else if ( m_pccc != NULL )
    {
        TraceMsg( mtfFUNC, L"[SRV] Sending the status message without polling." );

        hr = THR( m_pccc->SendStatusReport(
                                pcszNodeNameIn,
                                clsidTaskMajorIn,
                                clsidTaskMinorIn,
                                ulMinIn,
                                ulMaxIn,
                                ulCurrentIn,
                                hrStatusIn,
                                pcszDescriptionIn,
                                pftTimeIn,
                                pcszReferenceIn
                                ) );
    } // else if:
    else
    {
        LogMsg( L"[SRV] Neither a polling callback or a regular callback were found.  No messages are being sent to anyone!" );
    } // else:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCallback::SendStatusReport


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IClusCfgPollingCallback interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::GetStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::GetStatusReport(
    BSTR *      pbstrNodeNameOut,
    CLSID *     pclsidTaskMajorOut,
    CLSID *     pclsidTaskMinorOut,
    ULONG *     pulMinOut,
    ULONG *     pulMaxOut,
    ULONG *     pulCurrentOut,
    HRESULT *   phrStatusOut,
    BSTR *      pbstrDescriptionOut,
    FILETIME *  pftTimeOut,
    BSTR *      pbstrReferenceOut
    )
{
    TraceFunc( "[IClusCfgPollingCallback]" );

    HRESULT hr;
    DWORD   sc;

    sc = WaitForSingleObject( m_hEvent, 0 );
    if ( sc == WAIT_FAILED )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( sc == WAIT_TIMEOUT )
    {
        Assert( *m_pcszNodeName != NULL );
        *pbstrNodeNameOut = SysAllocString( m_pcszNodeName );
        if ( *pbstrNodeNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:

        *pclsidTaskMajorOut     = *m_pclsidTaskMajor;
        *pclsidTaskMinorOut     = *m_pclsidTaskMinor;
        *pulMinOut              = *m_pulMin;
        *pulMaxOut              = *m_pulMax;
        *pulCurrentOut          = *m_pulCurrent;
        *phrStatusOut           = *m_phrStatus;
        *pftTimeOut             = *m_pftTime;

        if ( m_pcszDescription != NULL )
        {
            *pbstrDescriptionOut = SysAllocString( m_pcszDescription );
            if ( *pbstrDescriptionOut == NULL )
            {
                goto OutOfMemory;
            } // if:
        } // if:
        else
        {
            *pbstrDescriptionOut = NULL;
        } // else:

        if ( m_pcszReference != NULL )
        {
            *pbstrReferenceOut = SysAllocString( m_pcszReference );
            if ( *pbstrReferenceOut == NULL )
            {
                goto OutOfMemory;
            } // if:
        } // if:
        else
        {
            *pbstrReferenceOut = NULL;
        } // else:

        hr = S_OK;
    } // if: event was not signaled
    else
    {
        hr = S_FALSE;
    } // else: event was signaled

    goto Cleanup;

OutOfMemory:

    hr = E_OUTOFMEMORY;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCallback::GetStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::SetHResult
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SetHResult( HRESULT hrIn )
{
    TraceFunc( "[IClusCfgPollingCallback]" );

    HRESULT hr = S_OK;
    DWORD   sc;

    m_hr = hrIn;

    if ( hrIn != S_OK )
    {
        LogMsg( L"[SRV] SetHResult(). (hrIn = %#08x)", hrIn );
    } // if:

    if ( !SetEvent( m_hEvent ) )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] Could not signal event. (hr = %#08x)", hr );
    } // if:

    HRETURN( hr );

} //*** CClusCfgCallback::SetHResult


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::Initialize
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::Initialize( IUnknown  * punkCallbackIn, LCID lcidIn )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_pccc == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    //
    //  KB: 13 DEC 2000 GalenB
    //
    //  If the passed in callback object is NULL then we had better be doing a polling
    //  callback!
    //
    if ( punkCallbackIn != NULL )
    {
        Assert( !m_fPollingMode );

        hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_pccc ) );
    } // if:
    else
    {
        Assert( m_fPollingMode );
    } // else:

    HRETURN( hr );

} //*** CClusCfgCallback::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback -- IClusCfgSetPollingCallback interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::SetPollingMode
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgCallback::SetPollingMode( BOOL fUsePollingModeIn )
{
    TraceFunc( "[IClusCfgPollingCallback]" );

    HRESULT hr = S_OK;

    m_fPollingMode = fUsePollingModeIn;

    HRETURN( hr );

} //*** CClusCfgCallback::SetPollingMode


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgCallback class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgCallback::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;

    //
    //  Create the event in a signaled state.  To prevent MT polling task from grabbing
    //  bad/empty data.
    //
    m_hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( m_hEvent == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] Could not create event. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    //
    // Save off the local computer name.
    //
    hr = THR( HrGetComputerName( ComputerNameDnsFullyQualified, &m_bstrNodeName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get a ClCfgSrv ILogger instance.
    //
    hr = CClCfgSrvLogger::S_HrGetLogger( &m_plLogger );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCallback::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterConfigurationInfo::HrQueueStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgCallback::HrQueueStatusReport(
    LPCWSTR     pcszNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    LPCWSTR     pcszDescriptionIn,
    FILETIME *  pftTimeIn,
    LPCWSTR     pcszReferenceIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    MSG     msg;

    m_pcszNodeName      = pcszNodeNameIn;
    m_pclsidTaskMajor   = &clsidTaskMajorIn;
    m_pclsidTaskMinor   = &clsidTaskMinorIn;
    m_pulMin            = &ulMinIn;
    m_pulMax            = &ulMaxIn;
    m_pulCurrent        = &ulCurrentIn;
    m_phrStatus         = &hrStatusIn;
    m_pcszDescription   = pcszDescriptionIn;
    m_pftTime           = pftTimeIn,
    m_pcszReference     = pcszReferenceIn;

    if ( !ResetEvent( m_hEvent ) )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] Could not reset event. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    for ( sc = (DWORD) -1; sc != WAIT_OBJECT_0; )
    {
        while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        } // while: PeekMessage

        sc = MsgWaitForMultipleObjects( 1, &m_hEvent, FALSE, INFINITE, QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE );
        if ( sc == -1 )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( L"[SRV] MsgWaitForMultipleObjects failed. (hr = %#08x)", hr );
            goto Cleanup;
        } // if:
    } // for:

    hr = m_hr;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgCallback::HrQueueStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\restypeservices.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ResTypeServices.h
//
//  Description:
//      This file contains the declaration of the CResTypeServices
//      class. This class provides functions that help components that
//      want to create resource types at the time of cluster configuration.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      CResTypeServices.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 14-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For the cluster API functions and types
#include <ClusApi.h>

// For IClusCfgResourceTypeCreate
#include "ClusCfgServer.h"

// For IClusCfgResTypeServicesInitialize
#include "ClusCfgPrivate.h"



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResTypeServices
//
//  Description:
//      This class provides functions that help components that want to
//      configure resource types at the time of cluster configuration.
//--
//////////////////////////////////////////////////////////////////////////////
class CResTypeServices
    : public IClusCfgResourceTypeCreate
    , public IClusCfgResTypeServicesInitialize
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgResourceTypeCreate methods
    //////////////////////////////////////////////////////////////////////////

    // Create a resource type
    STDMETHOD( Create )(
          const WCHAR *     pcszResTypeNameIn
        , const WCHAR *     pcszResTypeDisplayNameIn
        , const WCHAR *     pcszResDllNameIn
        , DWORD             dwLooksAliveIntervalIn
        , DWORD             dwIsAliveIntervalIn
        );

    // Register the cluster administrator extensions for a resource type.
    STDMETHOD( RegisterAdminExtensions )(
          const WCHAR *       pcszResTypeNameIn
        , ULONG               cExtClsidCountIn
        , const CLSID *       rgclsidExtClsidsIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgResTypeServicesInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Create a resource type
    STDMETHOD( SetParameters )( IClusCfgClusterInfo * pccciIn );


    //////////////////////////////////////////////////////////////////////////
    //  Other member functions
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CResTypeServices( void );

    // Destructor.
    ~CResTypeServices( void );

    // Copy constructor.
    CResTypeServices( const CResTypeServices & );

    // Assignment operator.
    CResTypeServices & operator =( const CResTypeServices & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                        m_cRef;

    // Pointer to the interface that provides information about the cluster
    // being configured.
    IClusCfgClusterInfo *       m_pccciClusterInfo;

    // Handle to cluster being configured.
    HCLUSTER                    m_hCluster;

    // Have we tried to open the handle to the cluster?
    bool                        m_fOpenClusterAttempted;

}; //*** class CResTypeServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\postcfg\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     15-JUN-2000
//      Vijay Vasu (VVasu)          15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>

// {F4A50885-A4B9-4c4d-B67C-9E4DD94A315E}
DEFINE_GUID( CLSID_TaskType,
0xf4a50885, 0xa4b9, 0x4c4d, 0xb6, 0x7c, 0x9e, 0x4d, 0xd9, 0x4a, 0x31, 0x5e);


//
//  KB: Turn this on to run all tests. Some of these might return errors, but none
//      of them should cause the program to crash.
//
//#define TURN_ON_ALL_TESTS

//
//  KB: Turn this on to run a regression pass.
//
#define REGRESSION_PASS


DEFINE_MODULE( "MIDDLETIERTEST" )

//
//  Declarations
//
typedef HRESULT (* PDLLREGISTERSERVER)( void );

//
//  Globals
//
HINSTANCE           g_hInstance = NULL;
LONG                g_cObjects  = 0;
IServiceProvider *  g_psp       = NULL;

BOOL                g_fWait     = FALSE;    // global synchronization

OBJECTCOOKIE        g_cookieCluster = NULL;


//
//  Register the DLL
//
HRESULT
HrRegisterTheDll( void )
{
    TraceFunc( "" );

    HRESULT hr;

    PDLLREGISTERSERVER  pDllRegisterServer;

    HMODULE hLib    = NULL;

    //
    //  Make sure the DLL is properly registered.
    //

    hLib = LoadLibrary( L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll" );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer = reinterpret_cast< PDLLREGISTERSERVER >( GetProcAddress( hLib, "DllRegisterServer" ) );
    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
    goto Cleanup;
}

//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int
_cdecl
main( void )
{
    TraceInitializeProcess();

    HRESULT hr;

    BOOL    fFirstTime = TRUE;

    IClusCfgServer * pccs = NULL;
    IEnumClusCfgManagedResources * peccmr = NULL;
    IClusCfgManagedResourceInfo *  pccmri = NULL;

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#if 0
    hr = THR( HrRegisterTheDll( ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

    hr = THR( CoCreateInstance( CLSID_ClusCfgServer,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                TypeSafeParams( IClusCfgServer, &pccs )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Succeeded in creating ClusCfgServer." );

    hr = THR( pccs->GetManagedResourcesEnum( &peccmr ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Loop thru making sure everything can be managed.
    //

    for( ;; )
    {
        if ( pccmri != NULL )
        {
            pccmri->Release( );
            pccmri = NULL;
        }

        hr = STHR( peccmr->Next( 1, &pccmri, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            break;

        hr = THR( pccmri->SetManaged( TRUE ) );
        if ( FAILED( hr ) )
            continue;

        if ( fFirstTime )
        {
            hr = THR( pccmri->SetQuorumedDevice( TRUE ) );
            if ( FAILED( hr ) )
                continue;

            fFirstTime = FALSE;
        }

    } // for: ever

    DebugMsg( "Succeeded in setting all devices to be managed." );

    hr = THR( pccs->CommitChanges( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    DebugMsg( "Successfully committed changes." );

Cleanup:
    if ( pccs != NULL )
    {
        pccs->Release( );
    }
    if ( peccmr != NULL )
    {
        peccmr->Release( );
    }
    if ( pccmri != NULL )
    {
        pccmri->Release( );
    }

    CoUninitialize( );

    TraceTerminateProcess();

    return 0;

} //*** main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgcallback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.h
//
//  Description:
//      This file contains the declaration of the CClusCfgCallback
//      class.
//
//      The class CClusCfgCallback inplements the callback
//      interface between this server and its clients.  It implements the
//      IClusCfgCallback interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgCallback.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <ClusCfgPrivate.h>
#include "PrivateInterfaces.h"
#include <Logger.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgCallback
//
//  Description:
//      The class CClusCfgCallback inplements the callback
//      interface between this server and its clients.
//
//  Interfaces:
//      IClusCfgCallback
//      IClusCfgInitialize
//      IClusCfgPollingCallback
//      IClusCfgSetPollingCallback
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgCallback
    : public IClusCfgCallback
    , public IClusCfgInitialize
    , public IClusCfgPollingCallback
    , public IClusCfgSetPollingCallback
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    IClusCfgCallback *  m_pccc;
    LCID                m_lcid;
    HANDLE              m_hEvent;
    HRESULT             m_hr;
    BOOL                m_fPollingMode:1;
    BSTR                m_bstrNodeName;

    LPCWSTR             m_pcszNodeName;
    CLSID *             m_pclsidTaskMajor;
    CLSID *             m_pclsidTaskMinor;
    ULONG *             m_pulMin;
    ULONG *             m_pulMax;
    ULONG *             m_pulCurrent;
    HRESULT *           m_phrStatus;
    LPCWSTR             m_pcszDescription;
    FILETIME *          m_pftTime;
    LPCWSTR             m_pcszReference;
    ILogger *           m_plLogger;             // ILogger for doing logging.

    // Private constructors and destructors
    CClusCfgCallback( void );
    ~CClusCfgCallback( void );

    // Private copy constructor to prevent copying.
    CClusCfgCallback( const CClusCfgCallback & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgCallback & operator = ( const CClusCfgCallback & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrQueueStatusReport(
                    LPCWSTR     pcszNodeNameIn,
                    CLSID       clsidTaskMajorIn,
                    CLSID       clsidTaskMinorIn,
                    ULONG       ulMinIn,
                    ULONG       ulMaxIn,
                    ULONG       ulCurrentIn,
                    HRESULT     hrStatusIn,
                    LPCWSTR     pcszDescriptionIn,
                    FILETIME *  pftTimeIn,
                    LPCWSTR     pcszReferenceIn
                    );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    STDMETHOD( SendStatusReport )(
                    CLSID           clsidTaskMajorIn,
                    CLSID           clsidTaskMinorIn,
                    ULONG           ulMinIn,
                    ULONG           ulMaxIn,
                    ULONG           ulCurrentIn,
                    HRESULT         hrStatusIn,
                    const WCHAR *   pcszDescriptionIn
                    );

    STDMETHOD( SendStatusReport )(
                    CLSID           clsidTaskMajorIn,
                    CLSID           clsidTaskMinorIn,
                    ULONG           ulMinIn,
                    ULONG           ulMaxIn,
                    ULONG           ulCurrentIn,
                    HRESULT         hrStatusIn,
                    DWORD           dwDescriptionIn
                    );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgCallback Interfaces.
    //

    STDMETHOD( SendStatusReport )(
                    LPCWSTR     pcszNodeNameIn,
                    CLSID       clsidTaskMajorIn,
                    CLSID       clsidTaskMinorIn,
                    ULONG       ulMinIn,
                    ULONG       ulMaxIn,
                    ULONG       ulCurrentIn,
                    HRESULT     hrStatusIn,
                    LPCWSTR     pcszDescriptionIn,
                    FILETIME *  pftTimeIn,
                    LPCWSTR     pcszReference
                    );

    //
    // IClusCfgPollingCallback Interfaces.
    //

    STDMETHOD( GetStatusReport )(
                    BSTR *      pbstrNodeNameOut,
                    CLSID *     pclsidTaskMajorOut,
                    CLSID *     pclsidTaskMinorOut,
                    ULONG *     pulMinOut,
                    ULONG *     pulMaxOut,
                    ULONG *     pulCurrentOut,
                    HRESULT *   phrStatusOut,
                    BSTR *      pbstrDescriptionOut,
                    FILETIME *  pftTimeOut,
                    BSTR *      pbstrReferenceOut
                    );

    STDMETHOD( SetHResult )( HRESULT hrIn );

    //
    // IClusCfgInitialize Interfaces.
    //

    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgSetPollingCallback Interfaces.
    //

    STDMETHOD( SetPollingMode )( BOOL fUsePollingModeIn );

}; //*** Class CClusCfgCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgcapabilities.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCapabilities.h
//
//  Description:
//      This file contains the declaration of the  CClusCfgCapabilities
//      class.
//
//      The class CClusCfgCapabilities is the implementations of the
//      IClusCfgCapabilities interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgCapabilities.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgCapabilities
//
//  Description:
//      The class CClusCfgCapabilities is the server that provides the
//      functionality to form a cluster and join additional nodes to a cluster.
//
//  Interfaces:
//      IClusCfgCapabilities
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgCapabilities
    : public IClusCfgInitialize
    , public IClusCfgCapabilities
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fCanBeClustered:1;

    // Private constructors and destructors
    CClusCfgCapabilities( void );
     ~CClusCfgCapabilities( void );

    // Private copy constructor to prevent copying.
    CClusCfgCapabilities( const CClusCfgCapabilities & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgCapabilities & operator = ( const CClusCfgCapabilities & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrCheckForSFM( void );
    HRESULT HrIsOSVersionValid( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    //  IClusCfgInitialize
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    //  IClusCfgCapabilities
    //

    STDMETHOD( CanNodeBeClustered )( void );

}; //*** Class CClusCfgCapabilities
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgclusterinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgClusterInfo.h
//
//  Description:
//      This file contains the declaration of the CClusCfgClusterInfo
//      class.
//
//      The class CClusCfgClusterInfo is the representation of a
//      computer that can be a cluster node. It implements the
//      IClusCfgClusterInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgClusterInfo.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgClusterInfo
//
//  Description:
//      The class CClusCfgClusterInfo is the representation of a
//      cluster.
//
//  Interfaces:
//      IClusCfgClusterInfo
//      IClusCfgInitialize
//      IClusCfgSetClusterNodeInfo
//      IClusCfgWbemServices
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgClusterInfo
    : public IClusCfgClusterInfo
    , public IClusCfgInitialize
    , public IClusCfgSetClusterNodeInfo
    , public IClusCfgWbemServices
{
private:

    //
    // Private member functions and data
    //

    LONG                    m_cRef;
    LCID                    m_lcid;
    IClusCfgCallback *      m_picccCallback;
    BSTR                    m_bstrName;
    ULONG                   m_ulIPDottedQuad;
    ULONG                   m_ulSubnetDottedQuad;
    IClusCfgNetworkInfo *   m_piccniNetwork;
    IUnknown *              m_punkServiceAccountCredentials;
    IWbemServices *         m_pIWbemServices;
    ECommitMode             m_ecmCommitChangesMode;
    BOOL                    m_fIsClusterNode:1;
    BSTR                    m_bstrBindingString;

    // Private constructors and destructors
    CClusCfgClusterInfo( void );
    ~CClusCfgClusterInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgClusterInfo( const CClusCfgClusterInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgClusterInfo & operator = ( const CClusCfgClusterInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrLoadNetworkInfo( HCLUSTER hClusterIn );
    HRESULT HrGetIPAddressInfo( HCLUSTER hClusterIn, HRESOURCE hResIn );
    HRESULT HrIsResourceOfType( HRESOURCE hResIn, const WCHAR * pszResourceTypeIn );
    HRESULT HrGetIPAddressInfo( HRESOURCE hResIn );
    HRESULT HrFindNetworkInfo( const WCHAR * pszNetworkName, const WCHAR * pszNetwork );
    HRESULT HrLoadCredentials( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgIntialize Interfaces.
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgClusterInfo Interfaces.
    //

    //
    // CommitChanges Mode
    //

    STDMETHOD( SetCommitMode )( ECommitMode ecmNewModeIn );

    STDMETHOD( GetCommitMode )( ECommitMode * pecmCurrentModeOut );

    //
    // Name (Fully Qualified Domain Name) e.g. cluster1.ntdev.microsoft.com
    //
    // In Forming the cluster, this is the resulting cluster name.
    // In Joining the cluster, this is the sponsers cluster name.
    //

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR bstrNameIn );

    //
    // Cluster IP Address
    //

    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetIPAddress )( ULONG ulDottedQuadIn );

    //
    // Cluster Subnet Mask
    //

    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuadIn );

    //
    // Cluster Network
    //

    STDMETHOD( GetNetworkInfo )( IClusCfgNetworkInfo ** ppiccniOut );

    STDMETHOD( SetNetworkInfo )( IClusCfgNetworkInfo * piccniIn );

    //
    // Cluster Service Account
    //

    STDMETHOD( GetClusterServiceAccountCredentials )( IClusCfgCredentials ** ppicccCredentialsOut );

    //
    // Cluster Binding String
    //

    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );

    STDMETHOD( SetBindingString )( LPCWSTR bstrBindingStringIn );

    //
    // IClusCfgSetClusterNodeInfo Interfaces.
    //

    STDMETHOD( SetClusterNodeInfo )( IClusCfgNodeInfo * pNodeInfoIn );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

}; //*** Class CClusCfgClusterInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgclusterinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgClusterInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgClusterInfo
//       class.
//
//      The class CClusCfgClusterInfo is the representation of a
//      cluster. It implements the IClusCfgClusterInfo interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgClusterInfo.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include <PropList.h>
#include <ClusRtl.h>
#include <windns.h>
#include <commctrl.h>
#include <ClusCfgPrivate.h>
#include <ClusterUtils.h>

#include "CClusCfgClusterInfo.h"
#include "CClusCfgCredentials.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgClusterInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgClusterInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CClusCfgClusterInfo *   lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CClusCfgClusterInfo();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgClusterInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::CClusCfgClusterInfo
//
//  Description:
//      Constructor of the CClusCfgClusterInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgClusterInfo::CClusCfgClusterInfo( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_piccniNetwork == NULL );
    Assert( m_ulIPDottedQuad == 0 );
    Assert( m_ulSubnetDottedQuad == 0 );
    Assert( m_punkServiceAccountCredentials == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_ecmCommitChangesMode == cmUNKNOWN );
    Assert( m_bstrBindingString == NULL );

    TraceFuncExit();

} //*** CClusCfgClusterInfo::CClusCfgClusterInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::~CClusCfgClusterInfo
//
//  Description:
//      Desstructor of the CClusCfgClusterInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgClusterInfo::~CClusCfgClusterInfo( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    if ( m_piccniNetwork != NULL )
    {
        m_piccniNetwork->Release();
    } // if:

    if ( m_punkServiceAccountCredentials != NULL )
    {
        m_punkServiceAccountCredentials->Release();
    } // if:

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrBindingString );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgClusterInfo::~CClusCfgClusterInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgClusterInfo:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgClusterInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgClusterInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgClusterInfo:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgClusterInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CClusCfgClusterInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgClusterInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgClusterInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgClusterInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgSetClusterNodeInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgSetClusterNodeInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusCfgClusterInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_SetWbemServices_Cluster, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo -- IClusCfgInitialze interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT     hr = S_OK;
    HRESULT     hrTemp = S_OK;
    HCLUSTER    hCluster = NULL;
    DWORD       sc;
    DWORD       dwState;
    BSTR        bstrDomain = NULL;
    BSTR        bstrClusterName = NULL;

    m_lcid = lcidIn;

    Assert( m_picccCallback == NULL );

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( m_fIsClusterNode )
    {
        sc = TW32( GetNodeClusterState( NULL, &dwState ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            LOG_STATUS_REPORT( L"CClusCfgClusterInfo::Initialize() GetNodeClusterState() failed.", hr );
            goto Cleanup;
        } // if:

        Assert( ( dwState == ClusterStateRunning ) || ( dwState == ClusterStateNotRunning ) );

        if ( dwState == ClusterStateNotRunning )
        {
            //
            //  Set hrTemp to S_FALSE so a warning is shown in the UI.
            //
            hrTemp = S_FALSE;
            STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_Node_Down, IDS_ERROR_NODE_DOWN, hrTemp );
            LogMsg( L"[SRV] The cluster service is down in this node." );

            //
            //  Set hrTemp to HR_S_RPC_S_CLUSTER_NODE_DOWN so we can return this later.
            //
            hrTemp = HR_S_RPC_S_CLUSTER_NODE_DOWN;
            goto ClusterNodeDown;
        } // if:

        hCluster = OpenCluster( NULL );
        if ( hCluster == NULL )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            LOG_STATUS_REPORT( L"CClusCfgClusterInfo::Initialize() OpenCluster() failed.", hr );
            goto Cleanup;
        } // if:

        hr = THR( HrGetClusterInformation( hCluster, &bstrClusterName, NULL ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetComputerName( ComputerNamePhysicalDnsDomain, &bstrDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceSysFreeString( m_bstrName );
        m_bstrName = TraceSysAllocStringLen( NULL, (UINT)( wcslen( bstrClusterName ) + wcslen( bstrDomain ) + 1 ) );
        if ( m_bstrName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_Initialize, IDS_ERROR_OUTOFMEMORY, hr );
            goto Cleanup;
        } // if:

        wcscpy( m_bstrName, bstrClusterName );
        wcscat( m_bstrName, L"." );
        wcscat( m_bstrName, bstrDomain );

        hr = THR( HrLoadNetworkInfo( hCluster ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

ClusterNodeDown:

        hr = THR( HrLoadCredentials() );
        if ( SUCCEEDED( hr ) )
        {
            //
            //  If successful then use hrTemp since it may contain a more important status code.
            //
            hr = hrTemp;
            LogMsg( L"[SRV] CClusCfgClusterInfo::Initialize() returning (hr=%#08x)", hr );
        } // if:
    } // if:

Cleanup:

    TraceSysFreeString( bstrDomain );
    TraceSysFreeString( bstrClusterName );

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo -- IClusCfgClusterInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetCommitMode
//
//  Description:
//      Get the mode of processing for this node when commit changes is
//      called.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success.
//
//      E_POINTER
//          pecmCurrentModeOut is NULL.
//
//      Other Win32 error as HRESULT if a failure occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetCommitMode( ECommitMode * pecmCurrentModeOut )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pecmCurrentModeOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pecmCurrentModeOut = m_ecmCommitChangesMode;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetCommitMode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetCommitMode
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetCommitMode( ECommitMode ecmCurrentModeIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ecmCommitChangesMode = ecmCurrentModeIn;

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetCommitMode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_ClusterInfo_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_bstrName == NULL )
    {
        hr = S_FALSE;
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Get_Cluster_Name, IDS_ERROR_CLUSTER_NAME_NOT_FOUND, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT     hr;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    m_bstrName = TraceSysAllocString( pcszNameIn );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetName_Cluster, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetIPAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetIPAddress( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetIPAddress, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_ulIPDottedQuad == 0 )
    {
        hr = S_FALSE;
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Get_Cluster_IP_Address, IDS_ERROR_CLUSTER_IP_ADDRESS_NOT_FOUND,  hr );
        goto Cleanup;
    } // if:

    *pulDottedQuadOut = m_ulIPDottedQuad;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetIPAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetIPAddress( ULONG ulDottedQuadIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ulIPDottedQuad = ulDottedQuadIn;

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetSubnetMask
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetSubnetMask( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_ClusterInfo_GetSubnetMask, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_ulSubnetDottedQuad == 0 )
    {
        hr = S_FALSE;
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Get_Cluster_IP_Subnet, IDS_ERROR_CLUSTER_IP_SUBNET_NOT_FOUND, hr );
        goto Cleanup;
    } // if:

    *pulDottedQuadOut = m_ulSubnetDottedQuad;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetSubnetMask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetSubnetMask
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetSubnetMask( ULONG ulDottedQuadIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    m_ulSubnetDottedQuad = ulDottedQuadIn;

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetSubnetMask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetNetworkInfo
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetNetworkInfo(
    IClusCfgNetworkInfo ** ppiccniOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );
    Assert( m_piccniNetwork != NULL );

    HRESULT hr = S_OK;

    if ( ppiccniOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetNetworkInfo, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_piccniNetwork == NULL )
    {
        hr = S_FALSE;
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Get_Cluster_Networks, IDS_ERROR_CLUSTER_NETWORKS_NOT_FOUND, hr );
        goto Cleanup;
    } // if:

    *ppiccniOut = TraceInterface( L"CClusCfgNetworkInfo", IClusCfgNetworkInfo, m_piccniNetwork, 0 );
    (*ppiccniOut)->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetNetworkInfo
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetNetworkInfo(
    IClusCfgNetworkInfo * piccniIn
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( m_piccniNetwork != NULL )
    {
        m_piccniNetwork->Release();
    } // if:

    Assert( piccniIn != NULL );

    m_piccniNetwork = piccniIn;
    m_piccniNetwork->AddRef();

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetClusterServiceAccountCredentials
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetClusterServiceAccountCredentials(
    IClusCfgCredentials ** ppicccCredentialsOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT     hr;

    if ( ppicccCredentialsOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetClusterServiceAccountCredentials, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_punkServiceAccountCredentials != NULL )
    {
        hr = S_OK;
        LOG_STATUS_REPORT( L"CClusCfgClusterInfo::GetClusterServiceAccountCredentials() skipping object creation.", hr );
        goto SkipCreate;
    } // if:

    hr = THR( CClusCfgCredentials::S_HrCreateInstance( &m_punkServiceAccountCredentials ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkServiceAccountCredentials = TraceInterface( L"CClusCfgCredentials", IUnknown, m_punkServiceAccountCredentials, 1 );

    hr = THR( HrSetInitialize( m_punkServiceAccountCredentials, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( m_punkServiceAccountCredentials, NULL ) );

SkipCreate:

    if ( SUCCEEDED( hr ) )
    {
        Assert( m_punkServiceAccountCredentials != NULL );
        hr = THR( m_punkServiceAccountCredentials->TypeSafeQI( IClusCfgCredentials, ppicccCredentialsOut ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetClusterServiceAccountCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::GetBindingString
//
//  Description:
//      Get the binding string for this cluster.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::GetBindingString( BSTR * pbstrBindingStringOut )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_ClusterInfo_GetBindingString_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_bstrBindingString == NULL )
    {
        hr = S_FALSE;
        LOG_STATUS_REPORT1(
              TASKID_Minor_GetBindingString_Binding_String_NULL
            , L"The cluster binding string is empty.  If we are adding nodes then this is not correct!"
            , hr );
        goto Cleanup;
    } // if:

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetBindingString_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::GetBindingString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetBindingString
//
//  Description:
//      Set the binding string of this cluster.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetBindingString( LPCWSTR pcszBindingStringIn )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszBindingStringIn = '%ls'", pcszBindingStringIn == NULL ? L"<null>" : pcszBindingStringIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    //
    //  When creating a cluster there is no cluster binding string.  Therefore it is reasonable
    //  to accept a NULL string as the passed in parameter.
    //
    if ( pcszBindingStringIn == NULL )
    {
        hr = S_FALSE;
        TraceSysFreeString( m_bstrBindingString );
        m_bstrBindingString = NULL;
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetBindingString_Cluster, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetBindingString


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo class -- IClusCfgSetClusterNodeInfo Interfaces.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::SetClusterNodeInfo
//
//  Description:
//      Suck some info off of the passed in node info object.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgClusterInfo::SetClusterNodeInfo( IClusCfgNodeInfo * pNodeInfoIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_FALSE;

    hr = STHR( pNodeInfoIn->IsMemberOfCluster() );
    if ( hr == S_OK )
    {
        m_fIsClusterNode = true;
    } // if:
    else if ( hr == S_FALSE )
    {
        m_fIsClusterNode = false;
        hr = S_OK;
    } // else if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::SetClusterNodeInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgClusterInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_bstrName = TraceSysAllocString( L"\0" );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrInit, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrLoadNetworkInfo
//
//  Description:
//      Load the cluster network info...
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrLoadNetworkInfo( HCLUSTER hClusterIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HRESOURCE   hIPAddress = NULL;

    sc = TW32( ResUtilGetCoreClusterResources( hClusterIn, NULL, &hIPAddress, NULL ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetIPAddressInfo( hIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    LOG_STATUS_REPORT1( TASKID_Minor_Server_LoadNetwork_Info, L"LoadNetworkInfo() completed.", hr );

    if ( hIPAddress != NULL )
    {
        CloseClusterResource( hIPAddress );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrLoadNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrGetIPAddressInfo
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrGetIPAddressInfo(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    DWORD       sc;
    HRESENUM    hEnum = NULL;
    DWORD       idx;
    WCHAR *     psz = NULL;
    DWORD       cchpsz = 33;
    DWORD       dwType;
    HRESOURCE   hRes = NULL;

    hEnum = ClusterResourceOpenEnum( hResIn, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    psz = new WCHAR [ cchpsz ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; )
    {
        sc = TW32( ClusterResourceEnum( hEnum, idx, &dwType, psz, &cchpsz ) );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cchpsz++;

            psz = new WCHAR [ cchpsz ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            hRes = OpenClusterResource( hClusterIn, psz );
            if ( hRes == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // if:

            hr = STHR( HrIsResourceOfType( hRes, L"IP Address" ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                hr = THR( HrGetIPAddressInfo( hRes ) );             // not recursive!
                break;
            } // if:

            CloseClusterResource( hRes );
            hRes = NULL;

            idx++;
            continue;
        } // if:

        hr = THR( HRESULT_FROM_WIN32( sc ) );       // must be an error!
        goto Cleanup;
    } // for:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetIPAddressInfo, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    LOG_STATUS_REPORT1( TASKID_Minor_Server_Get_ClusterIPAddress_Info_2, L"GetIPAddressInfo() completed.", hr );

    delete [] psz;

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterResourceCloseEnum( hEnum );
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrGetIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrIsResourceOfType
//
//  Description:
//      Is the resource of the type passed in?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The resource is of the type requested.
//
//      S_FALSE
//          The resource is not of the type requested.
//
//      Other HRESULT
//          Win32 error as HRESULT.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrIsResourceOfType(
    HRESOURCE       hResIn,
    const WCHAR *   pszResourceTypeIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DWORD       sc;
    WCHAR *     psz = NULL;
    DWORD       cbpsz = 33;
    DWORD       cb;
    int         idx;

    psz = new WCHAR [ cbpsz * sizeof( WCHAR ) ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        Assert( idx < 2 );

        sc = ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, NULL, 0, psz, cbpsz, &cb );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cbpsz = cb + 1;

            psz = new WCHAR [ cbpsz * sizeof( WCHAR ) ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        break;
    } // for:

    if ( wcscmp( psz, pszResourceTypeIn ) == 0 )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrIsResourceOfType, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    delete [] psz;

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrIsResourceOfType


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrGetIPAddressInfo
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrGetIPAddressInfo( HRESOURCE hResIn )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    CClusPropList           cpl;
    CLUSPROP_BUFFER_HELPER  cpbh;
    ULONG                   ulNetwork;
    WCHAR *                 psz = NULL;

    sc = TW32( cpl.ScGetResourceProperties( hResIn, CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, &m_ulIPDottedQuad );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    m_bstrBindingString = TraceSysAllocString( cpbh.pStringValue->sz );
    if ( m_bstrBindingString == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    LOG_STATUS_REPORT_STRING( L"Cluster binding string is '%1!ws!'.", m_bstrBindingString, hr );

    sc = TW32( cpl.ScMoveToPropertyByName( L"SubnetMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, &m_ulSubnetDottedQuad );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    ulNetwork = m_ulIPDottedQuad & m_ulSubnetDottedQuad;

    sc = ClRtlTcpipAddressToString( ulNetwork, &psz ); // KB: Allocates to lpsz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Network" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    hr = THR( HrFindNetworkInfo( cpbh.pStringValue->sz, psz ) );

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    LOG_STATUS_REPORT1( TASKID_Minor_Server_Get_ClusterIPAddress_Info, L"GetIPAddressInfo() completed.", hr );

    LocalFree( psz );                              // KB: Don't use TraceFree() here!

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrGetIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrFindNetworkInfo
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrFindNetworkInfo(
    const WCHAR * pszNetworkName,
    const WCHAR * pszNetwork
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IUnknown *              punk = NULL;
    IEnumClusCfgNetworks *  pieccn = NULL;
    ULONG                   cFetched;
    IClusCfgNetworkInfo *   piccni = NULL;
    BSTR                    bstrNetworkName = NULL;
    BSTR                    bstrNetwork = NULL;

    hr = THR( HrCreateNetworksEnum( m_picccCallback, m_lcid, m_pIWbemServices, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &pieccn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = pieccn->Next( 1, &piccni, &cFetched );
        if ( ( hr == S_OK ) && ( cFetched == 1 ) )
        {
            hr = THR( piccni->GetName( &bstrNetworkName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceMemoryAddBSTR( bstrNetworkName );

            hr = THR( piccni->GetUID( &bstrNetwork ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceMemoryAddBSTR( bstrNetwork );

            if ( ( wcscmp( pszNetworkName, bstrNetworkName ) == 0 ) && ( _wcsicmp( pszNetwork, bstrNetwork ) == 0 ) )
            {
                if ( m_piccniNetwork != NULL )
                {
                    m_piccniNetwork->Release();
                    m_piccniNetwork = NULL;
                } // if:

                m_piccniNetwork = piccni;
                m_piccniNetwork->AddRef();

                break;
            } // if:

            piccni->Release();
            piccni = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            goto Cleanup;
        } // else:
    } // for:

    //
    //  If we didn't find the cluster network in the WMI list of networks then we have a problem.
    //
    Assert( m_piccniNetwork != NULL );
    if ( m_piccniNetwork == NULL )
    {
        hr = THR( ERROR_NETWORK_NOT_AVAILABLE );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Cluster_Network_Not_Found, IDS_ERROR_CLUSTER_NETWORK_NOT_FOUND, hr );
    } // if:

Cleanup:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( pieccn != NULL )
    {
        pieccn->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrNetworkName );
    TraceSysFreeString( bstrNetwork );

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrFindNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgClusterInfo::HrLoadCredentials
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgClusterInfo::HrLoadCredentials( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    SC_HANDLE                   schSCM = NULL;
    SC_HANDLE                   schClusSvc = NULL;
    DWORD                       sc;
    DWORD                       cbpqsc = 128;
    DWORD                       cbRequired;
    QUERY_SERVICE_CONFIG *      pqsc = NULL;
    IClusCfgCredentials *       piccc = NULL;
    IClusCfgSetCredentials *    piccsc = NULL;

    schSCM = OpenSCManager( NULL, NULL, GENERIC_READ );
    if ( schSCM == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    } // if:

    schClusSvc = OpenService( schSCM, L"ClusSvc", GENERIC_READ );
    if ( schClusSvc == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    } // if:

    for ( ; ; )
    {
        pqsc = (QUERY_SERVICE_CONFIG *) TraceAlloc( 0, cbpqsc );
        if ( pqsc == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrLoadCredentials, IDS_ERROR_OUTOFMEMORY, hr );
            goto Cleanup;
        } // if:

        if ( !QueryServiceConfig( schClusSvc, pqsc, cbpqsc, &cbRequired ) )
        {
            sc = GetLastError();
            if ( sc == ERROR_INSUFFICIENT_BUFFER )
            {
                TraceFree( pqsc );
                pqsc = NULL;
                cbpqsc = cbRequired;
                continue;
            } // if:
            else
            {
                TW32( sc );
                goto Win32Error;
            } // else:
        } // if:
        else
        {
            break;
        } // else:
    } // for:

    Assert( m_punkServiceAccountCredentials == NULL );

    hr = THR( GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccc->TypeSafeQI( IClusCfgSetCredentials, &piccsc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccsc->SetDomainCredentials( pqsc->lpServiceStartName ) );

    goto Cleanup;

Win32Error:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if:

    if ( pqsc != NULL )
    {
        TraceFree( pqsc );
    } // if:

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( piccsc != NULL )
    {
        piccsc->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgClusterInfo::HrLoadCredentials
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgipaddressinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgIPAddressInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgIPAddressInfo
//       class.
//
//      The class CClusCfgIPAddressInfo represents a cluster manageable
//      network. It implements the IClusCfgIPAddressInfo interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgIPAddressInfo.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusCfgIPAddressInfo.h"
#include <ClusRtl.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgIPAddressInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgIPAddressInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgIPAddressInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgIPAddressInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT                 hr;
    CClusCfgIPAddressInfo * lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CClusCfgIPAddressInfo();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgIPAddressInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgIPAddressInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgIPAddressInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgIPAddressInfo::S_HrCreateInstance(
      ULONG         ulIPAddressIn
    , ULONG         ulIPSubnetIn
    , IUnknown **   ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );
    Assert( ulIPAddressIn != 0 );
    Assert( ulIPSubnetIn != 0 );

    HRESULT                     hr;
    CClusCfgIPAddressInfo *   pccsd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccsd = new CClusCfgIPAddressInfo();
    if ( pccsd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccsd->HrInit( ulIPAddressIn, ulIPSubnetIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccsd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgIPAddressInfo::S_HrCreateInstance( ULONG, ULONG ) failed. (hr = %#08x)", hr );
    } // if:

    if ( pccsd != NULL )
    {
        pccsd->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::CClusCfgIPAddressInfo
//
//  Description:
//      Constructor of the CClusCfgIPAddressInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgIPAddressInfo::CClusCfgIPAddressInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_ulIPAddress == 0 );
    Assert( m_ulIPSubnet == 0 );
    Assert( m_pIWbemServices == NULL );
    Assert( m_picccCallback == NULL );

    TraceFuncExit();

} //*** CClusCfgIPAddressInfo::CClusCfgIPAddressInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::~CClusCfgIPAddressInfo
//
//  Description:
//      Desstructor of the CClusCfgIPAddressInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgIPAddressInfo::~CClusCfgIPAddressInfo( void )
{
    TraceFunc( "" );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgIPAddressInfo::~CClusCfgIPAddressInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgIPAddressInfo:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgIPAddressInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgIPAddressInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgIPAddressInfo:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgIPAddressInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CClusCfgIPAddressInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::QueryInterface( REFIID riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgIPAddressInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgIPAddressInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgIPAddressInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusCfgIPAddressInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_IPAddress, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo class -- IClusCfgIPAddressInfo interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::GetUID
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );
    Assert( m_ulIPAddress != 0 );
    Assert( m_ulIPSubnet != 0 );

    HRESULT hr = S_OK;
    ULONG   ulNetwork = ( m_ulIPAddress & m_ulIPSubnet );
    LPWSTR  psz = NULL;
    DWORD   sc;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_IPAddressInfo_GetUID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    sc = ClRtlTcpipAddressToString( ulNetwork, &psz ); // KB: Allocates to psz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        LOG_STATUS_REPORT( L"CClusCfgIPAddressInfo::GetUID() ClRtlTcpipAddressToString() failed.", hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( psz );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_IPAddressInfo_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

Cleanup:

    if ( psz != NULL )
    {
        LocalFree( psz );                              // KB: Don't use TraceFree() here!
    } // if:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::GetIPAddress
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::GetIPAddress( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetNetworkGetIPAddress, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pulDottedQuadOut = m_ulIPAddress;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::GetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::SetIPAddress
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::SetIPAddress( ULONG ulDottedQuadIn )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( ulDottedQuadIn == 0  )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    m_ulIPAddress = ulDottedQuadIn;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::SetIPAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::GetSubnetMask
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::GetSubnetMask( ULONG * pulDottedQuadOut )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetSubnetMask, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pulDottedQuadOut = m_ulIPSubnet;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::GetSubnetMask


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::SetSubnetMask
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgIPAddressInfo::SetSubnetMask( ULONG ulDottedQuadIn )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = S_OK;

    if ( ulDottedQuadIn == 0  )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    m_ulIPSubnet = ulDottedQuadIn;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::SetSubnetMask

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgIPAddressInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgIPAddressInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgIPAddressInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgIPAddressInfo::HrInit( ULONG ulIPAddressIn, ULONG ulIPSubnetIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_ulIPAddress = ulIPAddressIn;
    m_ulIPSubnet = ulIPSubnetIn;

    HRETURN( hr );

} //*** CClusCfgIPAddressInfo::HrInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgipaddressinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgIPAddressInfo.h
//
//  Description:
//      This file contains the declaration of the CClusCfgIPAddressInfo
//      class.
//
//      The class CClusCfgIPAddressInfo is the representation of a
//      cluster manageable IP address. It implements the IClusCfgIPAddressInfo
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//  Remarks:
//      None.
//
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgIPAddressInfo
//
//  Description:
//      The class CClusCfgIPAddressInfo is the enumeration of
//      cluster manageable devices.
//
//  Interfaces:
//      IClusCfgIPAddressInfo
//      IClusCfgWbemServices
//      IEnumClusCfgIPAddresses
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgIPAddressInfo
    : public IClusCfgIPAddressInfo
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    IWbemServices *     m_pIWbemServices;
    ULONG               m_ulIPAddress;
    ULONG               m_ulIPSubnet;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;

    // Private constructors and destructors
    CClusCfgIPAddressInfo( void );
    ~CClusCfgIPAddressInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgIPAddressInfo( const CClusCfgIPAddressInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgIPAddressInfo & operator = ( const CClusCfgIPAddressInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrInit( ULONG ulIPAddressIn, ULONG IPSubnetIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance( ULONG ulIPAddressIn, ULONG IPSubnetIn, IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgIPAddressInfo Interfaces.
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetIPAddress )( ULONG ulDottedQuadIn );

    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );

    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuadIn );

}; //*** Class CClusCfgIPAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgnetworkinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgNetworkInfo.h
//
//  Description:
//      This file contains the declaration of the CClusCfgNetworkInfo
//      class.
//
//      The class CClusCfgNetworkInfo is the representation of a
//      cluster manageable network. It implements the IClusCfgNetworkInfo
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgNetworkInfo.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//  Remarks:
//      None.
//
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgNetworkInfo
//
//  Description:
//      The class CClusCfgNetworkInfo is the enumeration of
//      cluster manageable devices.
//
//  Interfaces:
//      IClusCfgNetworkInfo
//      IClusCfgNetworkAdapterInfo
//      IClusCfgWbemServices
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgNetworkInfo
    : public IClusCfgNetworkInfo
    , public IClusCfgSetWbemObject
    , public IClusCfgWbemServices
    , public IEnumClusCfgIPAddresses
    , public IClusCfgInitialize
    , public IClusCfgClusterNetworkInfo
{
private:

    enum EStates
    {
        eIsPrivate = 1,
        eIsPublic  = 2
    };

    //
    // Private member functions and data
    //

    LONG                    m_cRef;
    IWbemServices *         m_pIWbemServices;
    DWORD                   m_dwFlags;
    BSTR                    m_bstrName;
    BOOL                    m_fNameChanged:1;
    BSTR                    m_bstrDescription;
    BOOL                    m_fDescriptionChanged:1;
    BSTR                    m_bstrDeviceID;
    IUnknown *              m_punkAddresses;
    BSTR                    m_bstrConnectionName;
    LCID                    m_lcid;
    IClusCfgCallback *      m_picccCallback;
    BOOL                    m_fIsClusterNetwork:1;

    // Private constructors and destructors
    CClusCfgNetworkInfo( void );
    ~CClusCfgNetworkInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgNetworkInfo( const CClusCfgNetworkInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgNetworkInfo & operator = ( const CClusCfgNetworkInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrInit( HNETWORK hNetworkIn, HNETINTERFACE hNetInterfaceIn );
    HRESULT HrLoadEnum(  IWbemClassObject * pNetworkAdapterIn, bool * pfRetainObjectOut );
    HRESULT HrCreateEnum( void );
    HRESULT HrCreateEnumAndAddIPAddress( ULONG ulIPAddressIn, ULONG ulSubnetMaskIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance(
            HNETWORK        hNetworkIn
          , HNETINTERFACE   hNetInterfaceIn
          , IUnknown *      punkCallbackIn
          , LCID            lcidIn
          , IWbemServices * pIWbemServicesIn
          , IUnknown **     ppunkOut
          );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgNetworkInfo Interfaces.
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( GetDescription )( BSTR * pbstrDescriptionOut );

    STDMETHOD( SetDescription )( LPCWSTR pcszDescriptionIn );

    STDMETHOD( GetPrimaryNetworkAddress )( IClusCfgIPAddressInfo ** ppIPAddressOut );

    STDMETHOD( SetPrimaryNetworkAddress )( IClusCfgIPAddressInfo * pIPAddressIn );

    STDMETHOD( IsPublic )( void );

    STDMETHOD( SetPublic )( BOOL fIsPublicIn );

    STDMETHOD( IsPrivate )( void );

    STDMETHOD( SetPrivate )( BOOL fIsPrivateIn );

    //
    // IEnumClusCfgIPAddresses Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgIPAddressInfo ** rgpIPAddressInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // IClusCfgSetWbemObject
    //

    STDMETHOD( SetWbemObject )( IWbemClassObject * pNetworkAdapterIn, bool * pfRetainObjectOut );

    //
    // IClusCfgClusterNetworkInfo
    //

    STDMETHOD( HrIsClusterNetwork )( void );

}; //*** Class CClusCfgNetworkInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgnodeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgNodeInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgNodeInfo
//       class.
//
//      The class CClusCfgNodeInfo is the representation of a
//      computer that can be a cluster node. It implements the
//      IClusCfgNodeInfo interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgNodeInfo.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 21-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusCfgNodeInfo.h"
#include "CClusCfgClusterInfo.h"
#include <ClusApi.h>
#include <ClusVerp.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgNodeInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::S_HrCreateInstance()
//
//  Description:
//      Create a CClusCfgNodeInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgNodeInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CClusCfgNodeInfo *  lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CClusCfgNodeInfo();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgNodeInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::CClusCfgNodeInfo()
//
//  Description:
//      Constructor of the CClusCfgNodeInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgNodeInfo::CClusCfgNodeInfo( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fIsClusterNode( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_bstrFullDnsName == NULL );
    Assert( m_picccCallback == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_punkClusterInfo == NULL );

    TraceFuncExit();

} //*** CClusCfgNodeInfo::CClusCfgNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::~CClusCfgNodeInfo()
//
//  Description:
//      Desstructor of the CClusCfgNodeInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgNodeInfo::~CClusCfgNodeInfo( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrFullDnsName );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    if ( m_punkClusterInfo != NULL )
    {
        m_punkClusterInfo->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgNodeInfo::~CClusCfgNodeInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgNodeInfo:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgNodeInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgNodeInfo::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgNodeInfo:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgNodeInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CClusCfgNodeInfo::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgNodeInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgNodeInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgNodeInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusCfgNodeInfo::QueryInterface()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- IClusCfgWbemServices
//  interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::SetWbemServices()
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Node, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::SetWbemServices()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::Initialize()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::Initialize()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- IClusCfgNodeInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetName()
//
//  Description:
//      Return the name of this computer.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_NodeInfo_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrFullDnsName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::SetName()
//
//  Description:
//      Change the name of this computer.
//
//  Arguments:
//      IN  LPCWSTR  pcszNameIn
//          The new name for this computer.
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgNodeInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusCfgNodeInfo::SetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::IsMemberOfCluster()
//
//  Description:
//      Is this computer a member of a cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          This node is a member of a cluster.
//
//      S_FALSE
//          This node is not member of a cluster.
//
//      Other Win32 errors as HRESULT if GetNodeClusterState() fails.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::IsMemberOfCluster( void )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_FALSE;               // default to not a cluster node.

    if ( m_fIsClusterNode )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::IsMemberOfCluster()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetClusterConfigInfo()
//
//  Description:
//      Return the configuration information about the cluster that this
//      conputer belongs to.
//
//  Arguments:
//      OUT  IClusCfgClusterInfo ** ppClusCfgClusterInfoOut
//          Catches the CClusterConfigurationInfo object.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The out param was NULL.
//
//      E_OUTOFMEMORY
//          The CClusCfgNodeInfo object could not be allocated.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetClusterConfigInfo(
    IClusCfgClusterInfo ** ppClusCfgClusterInfoOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT                         hr = S_OK;
    HRESULT                         hrInit = S_OK;
    IClusCfgSetClusterNodeInfo *    pccsgni = NULL;

    if ( ppClusCfgClusterInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetClusterConfigInfo, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_punkClusterInfo != NULL )
    {
        hr = S_OK;
        LogMsg( L"[SRV] CClusCfgNodeInfo::GetClusterConfigInfo() skipped object creation." );
        goto SkipCreate;
    } // if:

    hr = THR( CClusCfgClusterInfo::S_HrCreateInstance( &m_punkClusterInfo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkClusterInfo = TraceInterface( L"CClusCfgClusterInfo", IUnknown, m_punkClusterInfo, 1 );

    //
    //  KB: 01-JUN-200  GalenB
    //
    //  This must be done before the CClusCfgClusterInfo class is initialized.
    //

    hr = THR( m_punkClusterInfo->TypeSafeQI( IClusCfgSetClusterNodeInfo, &pccsgni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccsgni->SetClusterNodeInfo( this ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  KB: 01-JUN-200  GalenB
    //
    //  This must be done after SetClusterNodeInfo() is called, but before Initialize.
    //

    hr = THR( HrSetWbemServices( m_punkClusterInfo, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] Could not set the WBEM services on a CClusCfgClusterInfo object. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    //
    //  KB: 01-JUN-200  GalenB
    //
    //  This must be done after SetClusterNodeInfo() and HrSetWbemServices are called.
    //

    hrInit = STHR( HrSetInitialize( m_punkClusterInfo, m_picccCallback, m_lcid ) );
    hr = hrInit;        // need hrInit later...
    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] Could not initialize CClusCfgClusterInfo object. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

SkipCreate:

    if ( SUCCEEDED( hr ) )
    {
        Assert( m_punkClusterInfo != NULL );
        hr = THR( m_punkClusterInfo->TypeSafeQI( IClusCfgClusterInfo, ppClusCfgClusterInfoOut ) );
    } // if:

Cleanup:

    //
    //  If hrInit is not S_OK then it is most likely HR_S_RPC_S_CLUSTER_NODE_DOWN which
    //  needs to get passed up...  Everything else must have succeeded an hr must be
    //  S_OK too.
    //
    if ( ( hr == S_OK ) && ( hrInit != S_OK ) )
    {
        hr = hrInit;
    } // if:

    LOG_STATUS_REPORT1( TASKID_Minor_Server_GetClusterInfo, L"GetClusterConfigInfo() completed.", hr );

    if ( pccsgni != NULL )
    {
        pccsgni->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetClusterConfigInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetOSVersion()
//
//  Description:
//      What is the OS version on this computer?
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetOSVersion(
    DWORD * pdwMajorVersionOut,
    DWORD * pdwMinorVersionOut,
    WORD *  pwSuiteMaskOut,
    BYTE *  pbProductTypeOut,
    BSTR *  pbstrCSDVersionOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    OSVERSIONINFOEX osv;
    HRESULT         hr = S_OK;

    osv.dwOSVersionInfoSize = sizeof( osv );

    if ( !GetVersionEx( (OSVERSIONINFO *) &osv ) )
    {
        DWORD   sc;

        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: GetVersionEx() failed

    if ( pdwMajorVersionOut != NULL )
    {
        *pdwMajorVersionOut = osv.dwMajorVersion;
    } // if:

    if ( pdwMinorVersionOut != NULL )
    {
        *pdwMinorVersionOut = osv.dwMinorVersion;
    } // if:

    if ( pwSuiteMaskOut != NULL )
    {
        *pwSuiteMaskOut = osv.wSuiteMask;
    } // if:

    if ( pbProductTypeOut != NULL )
    {
        *pbProductTypeOut = osv.wProductType;
    } // if:

    if ( pbstrCSDVersionOut != NULL )
    {
        *pbstrCSDVersionOut = SysAllocString( osv.szCSDVersion );
        if ( *pbstrCSDVersionOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetOSVersion, IDS_ERROR_OUTOFMEMORY, hr );
            goto Cleanup;
        } // if:
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetOSVersion()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetClusterVersion()
//
//  Description:
//      Return the cluster version information for the cluster this
//      computer belongs to.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetClusterVersion(
    DWORD * pdwNodeHighestVersion,
    DWORD * pdwNodeLowestVersion
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( ( pdwNodeHighestVersion == NULL ) || ( pdwNodeLowestVersion == NULL ) )
    {
        goto BadParams;
    } // if:

    *pdwNodeHighestVersion = CLUSTER_MAKE_VERSION( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION, VER_PRODUCTBUILD );
    *pdwNodeLowestVersion  = CLUSTER_INTERNAL_PREVIOUS_HIGHEST_VERSION;

    goto Cleanup;

BadParams:

    hr = THR( E_POINTER );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetClusterVersion, IDS_ERROR_NULL_POINTER, hr );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetClusterVersion()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::GetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNodeInfo::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   cchDrives = ( 4 * 26 ) + 1;                         // "C:\<null>" times 26 drive letters
    WCHAR * pszDrives = NULL;

    pszDrives = new WCHAR[ cchDrives ];
    if ( pszDrives == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = GetLogicalDriveStrings( cchDrives, pszDrives );
    if ( sc == 0 )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( sc > cchDrives )
    {
        delete [] pszDrives;
        pszDrives = NULL;

        cchDrives = sc + 1;

        pszDrives = new WCHAR[ cchDrives ];
        if ( pszDrives == NULL )
        {
            goto OutOfMemory;
        } // if:

        sc = GetLogicalDriveStrings( cchDrives, pszDrives );
        if ( sc == 0 )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:
    } // if:

    hr = THR( HrComputeDriveLetterUsageEnums( pszDrives, pdlmDriveLetterUsageOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrComputeSystemDriveLetterUsage( pdlmDriveLetterUsageOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetPageFileEnumIndex( pdlmDriveLetterUsageOut ) );

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetDriveLetterMappings_Node, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    delete [] pszDrives;

    HRETURN( hr );

} //*** CClusCfgNodeInfo::GetDriveLetterMappings()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNodeInfo -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrInit()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    DWORD   dwClusterState;

    hr = THR( HrGetComputerName( ComputerNameDnsFullyQualified, &m_bstrFullDnsName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    sc = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if : GetClusterState() failed

    //
    // If the current cluster node state is running or not running then this node is part of a cluster.
    //
    m_fIsClusterNode = ( dwClusterState == ClusterStateNotRunning ) || ( dwClusterState == ClusterStateRunning );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrInit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrComputeDriveLetterUsageEnums()
//
//  Description:
//      Fill the array with the enums that represent the drive letter usage.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrComputeDriveLetterUsageEnums(
    WCHAR *                 pszDrivesIn,
    SDriveLetterMapping *   pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "" );
    Assert( pszDrivesIn != NULL );
    Assert( pdlmDriveLetterUsageOut != NULL );

    HRESULT hr = S_OK;
    WCHAR * pszDrive = pszDrivesIn;
    UINT    uiType;
    int     idx;

    while ( *pszDrive != NULL )
    {
        uiType = GetDriveType( pszDrive );

        CharUpper( pszDrive );
        idx = pszDrive[ 0 ] - 'A';

        pdlmDriveLetterUsageOut->dluDrives[ idx ] = (EDriveLetterUsage) uiType;

        pszDrive += 4;
    } // while:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrComputeDriveLetterUsageEnums()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrComputeSystemDriveLetterUsage()
//
//  Description:
//      Fill the array with the enums that represent the drive letter usage.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrComputeSystemDriveLetterUsage(
    SDriveLetterMapping *   pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "" );
    Assert( pdlmDriveLetterUsageOut != NULL );

    HRESULT hr = S_OK;
    BSTR    bstrBootLogicalDisk = NULL;
    BSTR    bstrSystemDevice = NULL;
    BSTR    bstrSystemLogicalDisk = NULL;
    int     idx;

//    hr = THR( HrLoadOperatingSystemInfo( m_picccCallback, m_pIWbemServices, &bstrBootDevice, &bstrSystemDevice ) );
//    if ( FAILED( hr ) )
//    {
//        goto Cleanup;
//    } // if:

    hr = THR( HrGetSystemDevice( &bstrSystemDevice ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = HrConvertDeviceVolumeToLogicalDisk( bstrSystemDevice, &bstrSystemLogicalDisk );
    if ( HRESULT_CODE( hr ) == ERROR_INVALID_FUNCTION )
    {
        //
        //  system volume is an EFI volume on IA64 and won't have a logical disk anyway...
        //
        hr = S_OK;
    } // if:
    else if ( hr == S_OK )
    {
        idx = bstrSystemLogicalDisk[ 0 ] - 'A';
        pdlmDriveLetterUsageOut->dluDrives[ idx ] = dluSYSTEM;
    } // else if:

    if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    } // if:

    hr = THR( HrGetBootLogicalDisk( &bstrBootLogicalDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    idx = bstrBootLogicalDisk[ 0 ] - 'A';
    pdlmDriveLetterUsageOut->dluDrives[ idx ] = dluSYSTEM;

Cleanup:

    TraceSysFreeString( bstrBootLogicalDisk );
    TraceSysFreeString( bstrSystemDevice );
    TraceSysFreeString( bstrSystemLogicalDisk );

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrComputeSystemDriveLetterUsage()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNodeInfo::HrSetPageFileEnumIndex()
//
//  Description:
//      Mark the drives that have paging files on them.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNodeInfo::HrSetPageFileEnumIndex(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR   szLogicalDisks[ 26 ];
    int     cLogicalDisks = 0;
    int     idx;
    int     idxDrive;

    hr = THR( HrGetPageFileLogicalDisks( m_picccCallback, m_pIWbemServices, szLogicalDisks, &cLogicalDisks ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < cLogicalDisks; idx++ )
    {
        idxDrive = szLogicalDisks[ idx ] - L'A';
        pdlmDriveLetterUsageOut->dluDrives[ idxDrive ] = dluSYSTEM;
    } // for:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNodeInfo::HrSetPageFileEnumIndex()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgnetworkinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgNetworkInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgNetworkInfo
//       class.
//
//      The class CClusCfgNetworkInfo represents a cluster manageable
//      network. It implements the IClusCfgNetworkInfo interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgNetworkInfo.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include <PropList.h>
#include <ClusRtl.h>
#include "CClusCfgNetworkInfo.h"
#include "CEnumClusCfgIPAddresses.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgNetworkInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgNetworkInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgNetworkInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CClusCfgNetworkInfo *   lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CClusCfgNetworkInfo();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgNetworkInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgNetworkInfo instance.
//
//  Arguments:
//
//
//  Return Values:
//      Pointer to CClusCfgNetworkInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::S_HrCreateInstance(
      HNETWORK          hNetworkIn
    , HNETINTERFACE     hNetInterfaceIn
    , IUnknown *        punkCallbackIn
    , LCID              lcidIn
    , IWbemServices *   pIWbemServicesIn
    , IUnknown **       ppunkOut
    )
{
    TraceFunc( "" );
    Assert( hNetworkIn != NULL );
    Assert( ppunkOut != NULL );

    HRESULT                 hr;
    CClusCfgNetworkInfo *   lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    LogMsg( L"[SRV] Creating NetworkInfo object from a cluster network." );

    lpccs = new CClusCfgNetworkInfo();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->Initialize( punkCallbackIn, lcidIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( lpccs->SetWbemServices( pIWbemServicesIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( lpccs->HrInit( hNetworkIn, hNetInterfaceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgNetworkInfo::S_HrCreateInstance( HRESOURCE ) failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::CClusCfgNetworkInfo
//
//  Description:
//      Constructor of the CClusCfgNetworkInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgNetworkInfo::CClusCfgNetworkInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_pIWbemServices == NULL );
    Assert( m_dwFlags  == 0 );
    Assert( m_bstrName == NULL );
    Assert( m_bstrDescription == NULL );
    Assert( m_bstrDeviceID == NULL );
    Assert( m_punkAddresses == NULL );
    Assert( m_bstrConnectionName == NULL );
    Assert( m_picccCallback == NULL );
    Assert( !m_fIsClusterNetwork );

    TraceFuncExit();

} //*** CClusCfgNetworkInfo::CClusCfgNetworkInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::~CClusCfgNetworkInfo
//
//  Description:
//      Desstructor of the CClusCfgNetworkInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgNetworkInfo::~CClusCfgNetworkInfo( void )
{
    TraceFunc( "" );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_punkAddresses != NULL )
    {
        m_punkAddresses->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrDescription );
    TraceSysFreeString( m_bstrDeviceID );
    TraceSysFreeString( m_bstrConnectionName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgNetworkInfo::~CClusCfgNetworkInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgNetworkInfo:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgNetworkInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgNetworkInfo::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgNetworkInfo:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgNetworkInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CClusCfgNetworkInfo::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgNetworkInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgNetworkInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgNetworkInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgSetWbemObject ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgSetWbemObject, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
        hr = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgClusterNetworkInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgClusterNetworkInfo, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusCfgNetworkInfo::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Network, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IClusCfgSetWbemObject interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetWbemObject
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetWbemObject(
      IWbemClassObject *    pNetworkAdapterIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "[IClusCfgSetWbemObject]" );
    Assert( pNetworkAdapterIn != NULL );
    Assert( pfRetainObjectOut != NULL );

    HRESULT hr = S_OK;
    VARIANT var;

    VariantInit( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"Description", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDescription = TraceSysAllocString( var.bstrVal );
    if ( m_bstrDescription == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"Name", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrName = TraceSysAllocString( var.bstrVal );
    if ( m_bstrName == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDeviceID = TraceSysAllocString( var.bstrVal );
    if ( m_bstrDeviceID == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"NetConnectionID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrConnectionName = TraceSysAllocString( var.bstrVal );
    if ( m_bstrConnectionName == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = STHR( HrLoadEnum( pNetworkAdapterIn, pfRetainObjectOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemObject_Network, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    LOG_STATUS_REPORT_STRING( L"Created network adapter '%1!ws!'", ( m_bstrConnectionName != NULL ) ? m_bstrConnectionName : L"<Unknown>", hr );

    VariantClear( &var );

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetWbemObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IClusCfgNetworkInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                 hr;
    IClusCfgIPAddressInfo * piccipi = NULL;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetUID, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( GetPrimaryNetworkAddress( &piccipi ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccipi->GetUID( pbstrUIDOut ) );

Cleanup:

    if ( piccipi != NULL )
    {
        piccipi->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_bstrConnectionName != NULL );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_NetworkInfo_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrConnectionName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::GetDescription
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::GetDescription( BSTR * pbstrDescriptionOut )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_bstrDescription != NULL );

    HRESULT hr = S_OK;

    if ( pbstrDescriptionOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_NetworkInfo_GetDescription_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrDescriptionOut = SysAllocString( m_bstrDescription );
    if ( *pbstrDescriptionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_NetworkInfo_GetDescription_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::GetDescription


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetDescription
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetDescription( LPCWSTR pcszDescriptionIn )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszDescriptionIn = '%ls'", pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetDescription


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::GetPrimaryNetworkAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::GetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo ** ppIPAddressOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    ULONG                       cFetched;
    IEnumClusCfgIPAddresses *   pccipa = NULL;

    if ( ppIPAddressOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetPrimaryNetworkAddress, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccipa->Reset() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( pccipa->Next( 1, ppIPAddressOut, &cFetched ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
    {
        hr = S_FALSE;
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Primary_IP_Address, IDS_ERROR_PRIMARY_IP_NOT_FOUND, hr );
    } // if:

Cleanup:

    if ( pccipa != NULL )
    {
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::GetPrimaryNetworkAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetPrimaryNetworkAddress
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo * pIPAddressIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetPrimaryNetworkAddress


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::IsPublic
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The network is public -- client traffic only.
//
//      S_FALSE
//          The network is not public -- has cluster and client traffic.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::IsPublic( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsPublic )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::IsPublic


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetPublic
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetPublic( BOOL fIsPublicIn )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_OK;

    if ( fIsPublicIn )
    {
        m_dwFlags |= eIsPublic;
    } // if:
    else
    {
        m_dwFlags &= ~eIsPublic;
    } // else:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetPublic


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::IsPrivate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The network is private -- no client traffic.
//
//      S_FALSE
//          The network is not private -- has client traffic.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::IsPrivate( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsPrivate )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::IsPrivate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::SetPrivate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::SetPrivate( BOOL fIsPrivateIn )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_OK;

    if ( fIsPrivateIn )
    {
        m_dwFlags |= eIsPrivate;
    } // if:
    else
    {
        m_dwFlags &= ~eIsPrivate;
    } // else:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::SetPrivate


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo -- IEnumClusCfgIPAddresses interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Next(
    ULONG                       cNumberRequestedIn,
    IClusCfgIPAddressInfo **   rgpIPAddresseInfoOut,
    ULONG *                     pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pccipa;

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = STHR( pccipa->Next( cNumberRequestedIn, rgpIPAddresseInfoOut, pcNumberFetchedOut ) );
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pccipa;

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pccipa->Skip( cNumberToSkipIn ) );
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pccipa;

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pccipa->Reset() );
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Clone(
    IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr;
    IEnumClusCfgIPAddresses *   pccipa;

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pccipa->Clone( ppEnumClusCfgIPAddressesOut ) );
        pccipa->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgNetworkInfo::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );
    Assert( m_punkAddresses != NULL );

    HRESULT                     hr = S_OK;
    IEnumClusCfgIPAddresses *   pccipa = NULL;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( m_punkAddresses->TypeSafeQI( IEnumClusCfgIPAddresses, &pccipa ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccipa->Count( pnCountOut ) );

Cleanup:

    if ( pccipa != NULL )
    {
       pccipa->Release();
    }

    HRETURN( hr );

} //** CClusCfgNetworkInfo::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo class -- IClusCfgClusterNetworkInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrIsClusterNetwork
//
//  Description:
//      Is this network already a cluster network.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          This network is already a cluster network.
//
//      S_FALSE
//          This network is not already a cluster network.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrIsClusterNetwork( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    if ( m_fIsClusterNetwork )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrIsClusterNetwork


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgNetworkInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_dwFlags = ( eIsPrivate | eIsPublic );

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrInit(
      HNETWORK      hNetworkIn
    , HNETINTERFACE hNetInterfaceIn
    )
{
    TraceFunc( "[HNETWORK]" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    CClusPropList           cplNetworkCommon;
    CClusPropList           cplNetworkROCommon;
    CClusPropList           cplNetInterfaceROCommon;
    CLUSPROP_BUFFER_HELPER  cpbh;
    ULONG                   ulIPAddress;
    ULONG                   ulSubnetMask;

    //
    //  Get the network common read only properties
    //
    sc = TW32( cplNetworkROCommon.ScGetNetworkProperties( hNetworkIn, CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    //
    //  Get the network common properties
    //
    sc = TW32( cplNetworkCommon.ScGetNetworkProperties( hNetworkIn, CLUSCTL_NETWORK_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    //
    //  Get the netinterface common read only properties
    //
    sc = TW32( cplNetInterfaceROCommon.ScGetNetInterfaceProperties( hNetInterfaceIn, CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    //
    //  Find the RO property "name" and save it.
    //
    sc = TW32( cplNetworkROCommon.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetworkROCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    //
    //  If the name is empty tell the user and leave.
    //
    if ( ( cpbh.pStringValue->sz != NULL ) && ( wcscmp( cpbh.pStringValue->sz, L"" ) != 0 ) )
    {
        m_bstrConnectionName = TraceSysAllocString( cpbh.pStringValue->sz );
        if ( m_bstrConnectionName == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:
    else
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DATA ) );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrInit_No_Network_Name, IDS_ERROR_NO_NETWORK_NAME, hr );
        goto Cleanup;
    } // else:

    //
    //  Find the property "description" and save it.
    //
    sc = TW32( cplNetworkCommon.ScMoveToPropertyByName( L"Description" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetworkCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    //
    //  If the description is empty then alloc a space and continue.
    //
    if ( ( cpbh.pStringValue->sz != NULL ) && ( wcscmp( cpbh.pStringValue->sz, L"" ) != 0 ) )
    {
        m_bstrDescription = TraceSysAllocString( cpbh.pStringValue->sz );
        if ( m_bstrDescription == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // if:
    else
    {
        m_bstrDescription = TraceSysAllocString( L" " );
        if ( m_bstrDescription == NULL )
        {
            goto OutOfMemory;
        } // if:
    } // else:

    //
    //  Find the property "role".
    //
    sc = TW32( cplNetworkCommon.ScMoveToPropertyByName( L"Role" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetworkCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );

    //
    //  Switch on the role value and set the "private" or "public" bits.
    //
    switch ( cpbh.pDwordValue->dw )
    {
        case ClusterNetworkRoleNone :
            m_dwFlags = 0;
            break;

        case ClusterNetworkRoleInternalUse :
            m_dwFlags = eIsPrivate;
            break;

        case ClusterNetworkRoleClientAccess :
            m_dwFlags = eIsPublic;
            break;

        case ClusterNetworkRoleInternalAndClient :
            m_dwFlags = ( eIsPrivate | eIsPublic );
            break;

        //
        //  Should never get here!
        //
        default:
            hr = HRESULT_FROM_WIN32( TW32( ERROR_INVALID_DATA ) );
            STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrInit_Unknown_Network_Role, IDS_ERROR_INVALID_NETWORK_ROLE, hr );
            goto Cleanup;
    } // switch:

    //
    //  Find the RO property address and save it.
    //
    sc = TW32( cplNetInterfaceROCommon.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetInterfaceROCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, &ulIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    //
    //  Find the RO property AddressMask and save it.
    //
    sc = TW32( cplNetworkROCommon.ScMoveToPropertyByName( L"AddressMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cplNetworkROCommon.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( cpbh.pStringValue->sz, &ulSubnetMask ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    hr = THR( HrCreateEnumAndAddIPAddress( ulIPAddress, ulSubnetMask ) );

    m_fIsClusterNetwork = TRUE;

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrInit_Win32Error, IDS_ERROR_WIN32, hr );
    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrInit_OutOfMemory, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrLoadEnum
//
//  Description:
//      Load the contained enumerator
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrLoadEnum(
      IWbemClassObject * pNetworkAdapterIn
    , bool *            pfRetainObjectOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IClusCfgSetWbemObject * piccswo = NULL;

    hr = THR( HrCreateEnum() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_punkAddresses->TypeSafeQI( IClusCfgSetWbemObject, &piccswo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( piccswo->SetWbemObject( pNetworkAdapterIn, pfRetainObjectOut ) );

Cleanup:

    if ( piccswo != NULL )
    {
        piccswo->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrLoadEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrCreateEnum
//
//  Description:
//      Create the contained enumerator
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrCreateEnum( void )
{
    TraceFunc( "" );
    Assert( m_punkAddresses == NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;

    hr = THR( CEnumClusCfgIPAddresses::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CEnumClusCfgIPAddresses", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ))
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkAddresses = punk;
    m_punkAddresses->AddRef();

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrCreateEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgNetworkInfo::HrCreateEnumAndAddIPAddress
//
//  Description:
//      Add an IPAddress to the contained enumerator.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgNetworkInfo::HrCreateEnumAndAddIPAddress(
      ULONG ulIPAddressIn
    , ULONG ulSubnetMaskIn
    )
{
    TraceFunc( "" );
    Assert( m_punkAddresses == NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;
    IUnknown *  punkCallback = NULL;

    hr = THR( m_picccCallback->TypeSafeQI( IUnknown, &punkCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Have to pass the Initialize interface arguments since new objects will
    //  be created when this call is made.
    //
    hr = THR( CEnumClusCfgIPAddresses::S_HrCreateInstance( ulIPAddressIn, ulSubnetMaskIn, punkCallback, m_lcid, m_pIWbemServices, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CEnumClusCfgIPAddresses", IUnknown, punk, 1 );

    //
    //  This is special -- do not initialize this again.
    //
    //hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    //if ( FAILED( hr ))
    //{
    //    goto Cleanup;
    //} // if:

    //hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    //if ( FAILED( hr ) )
    //{
    //    goto Cleanup;
    //} // if:

    m_punkAddresses = punk;
    m_punkAddresses->AddRef();

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgNetworkInfo::HrCreateEnumAndAddIPAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgnodeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgNodeInfo.h
//
//  Description:
//      This file contains the declaration of the
//      CClusCfgNodeInfo class.
//
//      The class CClusCfgNodeInfo is the representation of a
//      computer that can be a cluster node. It implements the
//      IClusCfgNodeInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgNodeInfo.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 21-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgNodeInfo
//
//  Description:
//      The class CClusCfgNodeInfo is the representation of a
//      computer that can be a cluster node.
//
//  Interfaces:
//      IClusCfgNodeInfo
//      IClusCfgWbemServices
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgNodeInfo
    : public IClusCfgNodeInfo
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    BSTR                m_bstrFullDnsName;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    DWORD               m_fIsClusterNode;
    IUnknown *          m_punkClusterInfo;

    // Private constructors and destructors
    CClusCfgNodeInfo( void );
    ~CClusCfgNodeInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgNodeInfo( const CClusCfgNodeInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgNodeInfo & operator = ( const CClusCfgNodeInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrComputeDriveLetterUsageEnums( WCHAR * pszDrivesIn, SDriveLetterMapping * pdlmDriveLetterUsageOut );
    HRESULT HrComputeSystemDriveLetterUsage( SDriveLetterMapping * pdlmDriveLetterUsageOut );
    HRESULT HrSetPageFileEnumIndex( SDriveLetterMapping * pdlmDriveLetterUsageOut );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgNodeInfo Interfaces
    //

    //
    //  Name (Fully Qualified Domain Name)  e.g. cluster1.ntdev.microsoft.com
    //
    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    //  Membership?
    STDMETHOD( IsMemberOfCluster )( void );

    //  If it is a member, use this method to obtain an interface to
    //  IClusterConfigurationInfo.
    STDMETHOD( GetClusterConfigInfo )( IClusCfgClusterInfo ** ppClusCfgClusterInfoOut );

    STDMETHOD( GetOSVersion )( DWORD * pdwMajorVersionOut, DWORD * pdwMinorVersionOut, WORD * pwSuiteMaskOut, BYTE * pbProductTypeOut, BSTR * pbstrCSDVersionOut );

    //  Cluster Version
    STDMETHOD( GetClusterVersion )( DWORD * pdwNodeHighestVersion, DWORD * pdwNodeLowestVersion );

    //  Drive Letter Mappings
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );

}; //*** Class CClusCfgNodeInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cclusproplist.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusPropList.cpp
//
//  Description:
//      Sucks in the CClusPropList library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-JUN-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <ClusApi.h>
#include <PropList.h>

#include "PropListSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgpartitioninfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgPartitionInfo.h
//
//  Description:
//      This file contains the declaration of the CClusCfgPartitionInfo
//      class.
//
//      The class CClusCfgPartitionInfo represents a disk partition.
//      It implements the IClusCfgPartitionInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgPartitionInfo.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgPartitionInfo
//
//  Description:
//      The class CClusCfgPartitionInfo represents a disk partition.
//
//  Interfaces:
//      IClusCfgPartitionInfo
//      IClusCfgWbemServices
//      IClusCfgSetWbemObject
//      IClusCfgInitialize
//      IClusCfgPartitionProperties
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgPartitionInfo
    : public IClusCfgPartitionInfo
    , public IClusCfgWbemServices
    , public IClusCfgSetWbemObject
    , public IClusCfgInitialize
    , public IClusCfgPartitionProperties
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    BSTR                m_bstrName;
    BSTR                m_bstrUID;
    BSTR                m_bstrDescription;
    IUnknown *          ((*m_prgLogicalDisks)[]);
    ULONG               m_idxNextLogicalDisk;
    ULONG               m_ulPartitionSize;

    // Private constructors and destructors
    CClusCfgPartitionInfo( void );
    ~CClusCfgPartitionInfo( void );

    // Private copy constructor to prevent copying.
    CClusCfgPartitionInfo( const CClusCfgPartitionInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgPartitionInfo & operator = ( const CClusCfgPartitionInfo & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrAddLogicalDiskToArray( IWbemClassObject * pDiskIn );
    HRESULT HrGetLogicalDisks( IWbemClassObject * pPartitionIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interface
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgSetWbemObject Interfaces
    //

    STDMETHOD( SetWbemObject )( IWbemClassObject * pPartitionIn, bool * pfRetainObjectOut );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR bstrNameIn );

    STDMETHOD( GetDescription )( BSTR * pbstrDescriptionOut );

    STDMETHOD( SetDescription )( LPCWSTR bstrDescriptionIn );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappingIn );

    STDMETHOD( GetSize )( ULONG * pcMegaBytes );

    //
    // IClusCfgPartitionProperties Interface
    //

    STDMETHOD( IsThisLogicalDisk )( WCHAR cLogicalDisk );

    STDMETHOD( IsNTFS )( void );

    STDMETHOD( GetFriendlyName )( BSTR * pbstrNameOut );

}; //*** Class CClusCfgPartitionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgserver.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgServer.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgServer class.
//
//      The class CClusCfgServer is the implementations of the
//      IClusCfgServer interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgServer.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 03-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusCfgServer.h"
#include "PrivateInterfaces.h"
#include "CClusCfgNodeInfo.h"
#include "CEnumClusCfgManagedResources.h"
#include "CClusCfgCallback.h"
#include "EventName.h"
#include <ClusRtl.h>
#include <windns.h>
#include <ClusterUtils.h>
#include <clusudef.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgServer" );

#define CLEANUP_LOCK_NAME L"Global\\Microsoft Cluster Configuration Cleanup Lock"


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgServer instance.
//
//  Arguments:
//      ppunkOut    -
//
//  Return Values:
//      Pointer to CClusCfgServer instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CClusCfgServer *    pccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    //
    //  KB: Since this is usually the start of the "server" thread,
    //      we will cause it to read its thread settings here.
    //
    TraceInitializeThread( L"ServerThread" );

    pccs = new CClusCfgServer();
    if ( pccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgServer::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccs != NULL )
    {
        pccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::CClusCfgServer
//
//  Description:
//      Constructor of the CClusCfgServer class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgServer::CClusCfgServer( void )
    : m_cRef( 1 )
    , m_pIWbemServices( NULL )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fCanBeClustered( TRUE )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_punkNodeInfo == NULL );
    Assert( m_punkEnumResources == NULL );
    Assert( m_punkNetworksEnum == NULL );
    Assert( m_bstrNodeName == NULL );
    Assert( !m_fUsePolling );
    Assert( m_bstrBindingString == NULL );

    TraceFuncExit();

} //*** CClusCfgServer::CClusCfgServer


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::~CClusCfgServer
//
//  Description:
//      Destructor of the CClusCfgServer class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgServer::~CClusCfgServer( void )
{
    TraceFunc( "" );

    TraceSysFreeString( m_bstrNodeName );
    TraceSysFreeString( m_bstrBindingString );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_punkNodeInfo != NULL )
    {
        m_punkNodeInfo->Release();
    } // if:

    if ( m_punkEnumResources != NULL )
    {
        m_punkEnumResources->Release();
    } // if:

    if ( m_punkNetworksEnum != NULL )
    {
        m_punkNetworksEnum->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgServer::~CClusCfgServer


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgServer:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgServer::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgServer::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgServer:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgServer::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CClusCfgServer::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgServer * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgServer ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgServer, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgCapabilities ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCapabilities, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgPollingCallbackInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgPollingCallbackInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgVerify ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgVerify, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusCfgServer::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The punkCallbackIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback != NULL );

    TraceInitializeThread( L"ClusCfgServerFlags" );

    HRESULT                 hr = S_OK;
    IUnknown *              punk = NULL;
    IClusCfgCallback *      piccc = NULL;       // this is NULL when we are polling callback
    IClusCfgNodeInfo *      piccni = NULL;
    IClusCfgClusterInfo *   piccci = NULL;

//    hr = STHR( HrCheckSecurity() );
//    if ( FAILED( hr ) )
//    {
//        goto Cleanup;
//    } // if:

    m_lcid = lcidIn;

    //
    //  If we are passed a callback object then we need to get its IClusCfgCallback
    //  interface so we can pass it into our callback object when it's initialized
    //  below.
    //
    if ( punkCallbackIn != NULL )
    {
        Assert( !m_fUsePolling );

        hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &piccc ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else
    {
        Assert( m_fUsePolling );

        if ( m_fUsePolling == FALSE )
        {
            hr = THR( E_INVALIDARG );
            goto Cleanup;
        } // if:
    } // else:

    //
    //  Initialize our internal callback object passing it either the passed in
    //  callback object's callback interface or NULL if we are polling.
    //
    hr = THR( m_picccCallback->TypeSafeQI( IUnknown, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, piccc, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  KB: 24-JUL-2000 GalenB
    //
    //  If we are being initialized on this interface then we are going to run this server local
    //  to the node.
    //
    hr = THR( HrInitializeForLocalServer() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Precreate the node info so we can get the cluster info object and determine if the cluster service
    //  is running on this node or not.
    //
    hr = THR( HrCreateClusterNodeInfo() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_punkNodeInfo->TypeSafeQI( IClusCfgNodeInfo, &piccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  This could return HRESUTL_FROM_WIN32( ERROR_CLUSTER_NODE_DOWN ) and that
    //  tells us that the cluster service is not running on this node.  The
    //  middletier needs to know this so it doesn't call us on this node
    //  anymore.
    //
    hr = THR( piccni->GetClusterConfigInfo( &piccci ) );

Cleanup:

    if ( m_picccCallback != NULL )
    {
        STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_Server_Initialized, IDS_NOTIFY_SERVER_INITIALIZED, hr );
    } // if:

    if ( piccci != NULL )
    {
        piccci->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer -- IClusCfgServer interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetClusterNodeInfo
//
//  Description:
//      Get information about the computer on which this object is present.
//
//  Arguments:
//      OUT  IClusCfgNodeInfo ** ppClusterNodeInfoOut
//          Catches the node info object.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The out param was NULL.
//
//      E_OUTOFMEMORY
//          The IClusCfgNodeInfo object could not be allocated.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetClusterNodeInfo(
    IClusCfgNodeInfo ** ppClusterNodeInfoOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    if ( ppClusterNodeInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Check_Node_Feasibility, TASKID_Minor_GetClusterNodeInfo, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_punkNodeInfo != NULL )
    {
        hr = S_OK;
        goto SkipCreate;
    } // if:

    hr = THR( HrCreateClusterNodeInfo() );

SkipCreate:

    if ( SUCCEEDED( hr ) )
    {
        Assert( m_punkNodeInfo != NULL );
        hr = THR( m_punkNodeInfo->TypeSafeQI( IClusCfgNodeInfo, ppClusterNodeInfoOut ) );
    } // if:

Cleanup:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Check_Node_Feasibility, TASKID_Minor_Server_GetClusterNodeInfo, IDS_ERROR_NODE_INFO_CREATE, hr );
    } // if:
    else
    {
        STATUS_REPORT( TASKID_Major_Check_Node_Feasibility, TASKID_Minor_Server_GetClusterNodeInfo, IDS_NODE_INFO_CREATE, hr );
    } // else:

    HRETURN( hr );

} //*** CClusCfgServer::GetClusterNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetManagedResourcesEnum
//
//  Description:
//      Get an enumeration of the devices on this computer that can be
//      managed by the cluster service.
//
//  Arguments:
//      OUT  IEnumClusCfgManagedResources **  ppEnumManagedResourcesOut
//          Catches the CEnumClusCfgManagedResources object.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The out param was NULL.
//
//      E_OUTOFMEMORY
//          The CEnumClusCfgManagedResources object could not be allocated.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetManagedResourcesEnum(
    IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    if ( ppEnumManagedResourcesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetManagedResourcesEnum, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_punkEnumResources != NULL )
    {
        m_punkEnumResources->Release();
        m_punkEnumResources = NULL;
    } // if:

    hr = THR( CEnumClusCfgManagedResources::S_HrCreateInstance( &m_punkEnumResources ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkEnumResources = TraceInterface( L"CEnumClusCfgManagedResources", IUnknown, m_punkEnumResources, 1 );

    hr = THR( HrSetInitialize( m_punkEnumResources, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( m_punkEnumResources, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_punkEnumResources->TypeSafeQI( IEnumClusCfgManagedResources, ppEnumManagedResourcesOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Server_GetManagedResourcesEnum, IDS_ERROR_MANAGED_RESOURCE_ENUM_CREATE, hr );
    } // if:
    else
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Server_GetManagedResourcesEnum, IDS_MANAGED_RESOURCE_ENUM_CREATE, hr );
    } // else:

    HRETURN( hr );

} //*** CClusCfgServer::GetManagedResourcesEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetNetworksEnum
//
//  Description:
//      Get an enumeration of all the networks on this computer.
//
//  Arguments:
//      OUT  IEnumClusCfgNetworks ** ppEnumNetworksOut
//          Catches the CEnumClusCfgNetworks object.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The out param was NULL.
//
//      E_OUTOFMEMORY
//          The CEnumClusCfgNetworks object could not be allocated.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetNetworksEnum(
    IEnumClusCfgNetworks ** ppEnumNetworksOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    if ( ppEnumNetworksOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetNetworksEnum, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_punkNetworksEnum != NULL )
    {
        m_punkNetworksEnum->Release();
        m_punkNetworksEnum = NULL;
    } // if:

    hr = THR( HrCreateNetworksEnum( m_picccCallback, m_lcid, m_pIWbemServices, &m_punkNetworksEnum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( m_punkNetworksEnum->TypeSafeQI( IEnumClusCfgNetworks, ppEnumNetworksOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Server_GetNetworksEnum, IDS_ERROR_NETWORKS_ENUM_CREATE, hr );
    } // if:
    else
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Server_GetNetworksEnum, IDS_NETWORKS_ENUM_CREATE, hr );
    } // else:

    HRETURN( hr );

} //*** CClusCfgServer::GetNetworksEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::CommitChanges
//
//  Description:
//      Commit the changes to the node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::CommitChanges( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT                 hr = S_OK;
    HRESULT                 hrTemp = S_OK;
    IClusCfgInitialize *    pcci = NULL;
    IClusCfgClusterInfo *   pClusCfgClusterInfo = NULL;
    ECommitMode             ecmCommitChangesMode = cmUNKNOWN;
    IClusCfgNodeInfo *      piccni = NULL;
    IPostCfgManager *       ppcm = NULL;
    IUnknown *              punkCallback = NULL;
    HANDLE                  heventPostCfgCompletion = NULL;
    IEnumClusCfgManagedResources * peccmr = NULL;

    MULTI_QI                mqiInterfaces[] =
    {
        { &IID_IClusCfgBaseCluster, NULL, S_OK },
        { &IID_IClusCfgInitialize, NULL, S_OK }
    };

    hr = THR( m_picccCallback->TypeSafeQI( IUnknown, &punkCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // KB:  First, get a pointer to the IClusCfgNodeInfo interface. Use this to get
    // a pointer to the IClusCfgClusterInfo interface to see what action needs
    // to be committed.
    //
    if ( m_punkNodeInfo == NULL )
    {
        hr = THR( GetClusterNodeInfo( &piccni ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else
    {
        hr = THR( m_punkNodeInfo->TypeSafeQI( IClusCfgNodeInfo, &piccni ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: we could not get the pointer to the IClusCfgNodeInfo interface
    } // else:

    hr = THR( piccni->GetClusterConfigInfo( &pClusCfgClusterInfo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the pointer to the IClusCfgClusterInfo interface

    hr = STHR( pClusCfgClusterInfo->GetCommitMode( &ecmCommitChangesMode ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    Assert( ecmCommitChangesMode != cmUNKNOWN );

    //
    // Create and initialize the BaseClusterAction component
    //

    hr = THR( CoCreateInstanceEx( CLSID_ClusCfgBaseCluster, NULL, CLSCTX_SERVER, NULL, ARRAYSIZE( mqiInterfaces ), mqiInterfaces ) );
    if ( FAILED( hr ) && ( hr != CO_S_NOTALLINTERFACES ) )
    {
        LOG_STATUS_REPORT( L"Failed to CoCreate Base Cluster Actions", hr );
        goto Cleanup;
    } // if: CoCreateInstanceEx() failed

    hr = THR( mqiInterfaces[ 0 ].hr );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the IClusCfgBaseCluster interface

    //
    // Check if we got a pointer to the IClusCfgInitialize interface
    hr = mqiInterfaces[ 1 ].hr;
    if ( hr == S_OK )
    {
        hr = THR( ((IClusCfgInitialize *) mqiInterfaces[ 1 ].pItf)->Initialize( punkCallback, m_lcid ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: something went wrong during initialization

    } // if: we got a pointer to the IClusCfgInitialize interface
    else
    {
        if ( hr != E_NOINTERFACE )
        {
            goto Cleanup;
        } // if: the interface is supported, but something else went wrong.

    } // if: we did not get a pointer to the IClusCfgInitialize interface

    //
    //  Create and initialize the Post configuration manager
    //

    hr = THR( CoCreateInstance( CLSID_ClusCfgPostConfigManager, NULL, CLSCTX_SERVER, TypeSafeParams( IPostCfgManager, &ppcm ) ) );
    if ( FAILED( hr ) )
    {
        //
        //  TODO:   gpease  11-JUN-2000
        //          Notify the UI layer.  What are the major and minor task ids?
        //
        LOG_STATUS_REPORT( L"Failed to CoCreate the Post Configuration Manager", hr );
        goto Cleanup;
    }

    // Check if this component supports the callback interface.
    hrTemp = THR( ppcm->TypeSafeQI( IClusCfgInitialize, &pcci ) );
    if ( FAILED( hrTemp ) )
    {
        LOG_STATUS_REPORT( L"Could not get a pointer to the IClusCfgInitialize interface. This post configuration manager does not support initialization", hr );
    } // if: the callback interface is not supported
    else
    {
        // Initialize this component.
        hr = THR( pcci->Initialize( punkCallback, m_lcid ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"Could not initialize the post configuration manager", hr );
            goto Cleanup;
        } // if: the initialization failed
    } // else: the callback interface is supported

    if ( m_punkEnumResources != NULL )
    {
        hr = THR( m_punkEnumResources->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    } // if:
    else
    {
        Assert( ( ecmCommitChangesMode != cmCREATE_CLUSTER ) && ( ecmCommitChangesMode != cmADD_NODE_TO_CLUSTER) );
        hr = THR( GetManagedResourcesEnum( &peccmr ) );
    } // else:


    //
    // If we are here, then the BaseCluster and Post configuration components were successfully
    // created and initialized. Now perform the desired action.
    //

    if ( ( ecmCommitChangesMode == cmCREATE_CLUSTER ) || ( ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER ) )
    {
        if ( !m_fCanBeClustered )
        {
            //
            //  TODO:   01-JUN-2000 GalenB
            //
            //  Need better error code...  What is the major and minor taskids?
            //
            hr = S_FALSE;
            LOG_STATUS_REPORT( L"It was previously determined that this node cannot be clustered.", hr );
            goto Cleanup;
        } // if: this node cannot be part of a cluster

        //
        // If the cluster service is being started for the first time, as a part
        // of adding this node to a cluster (forming or joining), then we have
        // to wait till the post-configuration steps are completed before we
        // can send out notifications. Create an event that indicates that post configuration
        // has completed.
        //

        TraceFlow1( "Trying to create an event named '%s'.", POSTCONFIG_COMPLETE_EVENT_NAME );

        // Create an event in the unsignalled state.
        heventPostCfgCompletion = CreateEvent(
              NULL                                  // event security attributes
            , TRUE                                  // manual-reset event
            , FALSE                                 // create in unsignaled state
            , POSTCONFIG_COMPLETE_EVENT_NAME
            );

        if ( heventPostCfgCompletion == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( L"[SRV] Error %#08x occurred trying to create an event named '%ls'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            TraceFlow2( "Error %#08x occurred trying to create an event named '%ls'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            goto Cleanup;
        } // if: we could not get a handle to the event

        // Reset the event, just as a safetly measure, in case the event already existed before the call above.
        if ( ResetEvent( heventPostCfgCompletion ) == 0 )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( L"[SRV] Error %#08x occurred trying to unsignal an event named '%ls'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            TraceFlow2( "Error %#08x occurred trying to unsignal an event named '%ls'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            goto Cleanup;
        } // if: ResetEvent() failed()

    } // if: we are forming or joining

    if ( ecmCommitChangesMode == cmCREATE_CLUSTER )
    {
        // Commit the base cluster
        hr = THR( HrFormCluster( pClusCfgClusterInfo, (( IClusCfgBaseCluster * ) mqiInterfaces[ 0 ].pItf) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        // Commit the post configuration steps
        hr = THR( ppcm->CommitChanges( peccmr, pClusCfgClusterInfo ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        // Signal the event to indicate that post configuration is complete.
        if ( SetEvent( heventPostCfgCompletion ) == 0 )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( L"[SRV] Error %#08x occurred trying to signal an event named '%ls'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            TraceFlow2( "Error %#08x occurred trying to signal an event named '%ls'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            goto Cleanup;
        } // if: SetEvent() failed()

    } // if: we are forming a cluster.
    else if ( ecmCommitChangesMode == cmADD_NODE_TO_CLUSTER )
    {
        // Commit the base cluster
        hr = THR( HrJoinToCluster( pClusCfgClusterInfo, (( IClusCfgBaseCluster * ) mqiInterfaces[ 0 ].pItf) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        // Commit the post configuration steps
        hr = THR( ppcm->CommitChanges( peccmr, pClusCfgClusterInfo ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        // Signal the event to indicate that post configuration is complete.
        if ( SetEvent( heventPostCfgCompletion ) == 0 )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( L"[SRV] Error %#08x occurred trying to signal an event named '%ls'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            TraceFlow2( "Error %#08x occurred trying to signal an event named '%ls'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            goto Cleanup;
        } // if: SetEvent() failed()

    } // else if: we are joining a cluster
    else if ( ecmCommitChangesMode == cmCLEANUP_NODE_AFTER_EVICT )
    {
        // This node has been evicted - clean it up.
        hr = THR( HrEvictedFromCluster( ppcm, peccmr, pClusCfgClusterInfo, (( IClusCfgBaseCluster * ) mqiInterfaces[ 0 ].pItf) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

    } // else if: we have just been evicted from a cluster


Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    if ( pcci != NULL )
    {
        pcci->Release();
    } // if:

    if ( ppcm != NULL )
    {
        ppcm->Release( );
    } // if:

    if ( peccmr != NULL )
    {
        peccmr->Release( );
    } // if:

    if ( mqiInterfaces[ 0 ].pItf != NULL )
    {
        mqiInterfaces[ 0 ].pItf->Release();
    } // if:

    if ( mqiInterfaces[ 1 ].pItf != NULL )
    {
        mqiInterfaces[ 1 ].pItf->Release();
    } // if:

    if ( pClusCfgClusterInfo != NULL )
    {
        pClusCfgClusterInfo->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( heventPostCfgCompletion != NULL )
    {
        // If we had created this event, then signal this event to let the
        // startup notification thread proceed.
        SetEvent( heventPostCfgCompletion );
        CloseHandle( heventPostCfgCompletion );
    } // if:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Server_CommitChanges, IDS_ERROR_COMMIT_CHANGES, hr );
    } // if:
    else
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Server_CommitChanges, IDS_COMMIT_CHANGES, hr );
    } // else:

    HRETURN( hr );

} //*** CClusCfgServer::CommitChanges


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetBindingString
//
//  Description:
//      Get the binding string for this server.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetBindingString( BSTR * pbstrBindingStringOut )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;

    if ( pbstrBindingStringOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Server_GetBindingString_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( m_bstrBindingString == NULL )
    {
        hr = S_FALSE;
        LOG_STATUS_REPORT1( TASKID_Minor_Server_GetBindingString_NULL, L"Binding string is NULL.  Must be a local connection.", hr );
        goto Cleanup;
    } // if:

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Server_GetBindingString_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::GetBindingString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::SetBindingString
//
//  Description:
//      Set the binding string of this server.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::SetBindingString( LPCWSTR pcszBindingStringIn )
{
    TraceFunc1( "[IClusCfgServer] pcszBindingStringIn = '%ls'", pcszBindingStringIn == NULL ? L"<null>" : pcszBindingStringIn );

    HRESULT     hr = S_OK;
    BSTR        bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetBindingString_Server, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::SetBindingString


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class -- IClusCfgCapabilities interfaces.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::CanNodeBeClustered
//
//  Description:
//      Can this node be added to a cluster?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Node can be clustered.
//
//      S_FALSE
//          Node cannot be clustered.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::CanNodeBeClustered( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT                 hr;
    ICatInformation *       pici = NULL;
    CATID                   rgCatIds[ 1 ];
    IEnumCLSID *            pieclsids = NULL;
    IClusCfgCapabilities *  piccc = NULL;
    CLSID                   clsid;
    ULONG                   cFetched;
    IUnknown *              punk = NULL;

    //
    //  KB: 10-SEP-2000 GalenB
    //
    //  Last ditch effort to clean up a node that is in a bad state before trying
    //  to add it into a cluster.
    //
    hr = STHR( HrHasNodeBeenEvicted() );
    if ( hr == S_OK )
    {
        hr = THR( HrCleanUpNode() ) ;
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // else if:

    rgCatIds[ 0 ] = CATID_ClusCfgCapabilities;

    hr = THR( CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICatInformation, (void **) &pici ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"Failed to CoCreate CLSID_StdComponentCategoriesMgr component", hr );
        goto Cleanup;
    }

    hr = THR( pici->EnumClassesOfCategories( 1, rgCatIds, 0, NULL, &pieclsids ) );
    if ( FAILED( hr ) )
    {
        LOG_STATUS_REPORT( L"Failed to get enumerator for the IClusCfgClusterCapabilites components", hr );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = STHR( pieclsids->Next( 1, &clsid, &cFetched ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"IClusCfgClusterCapabilites component enumerator failed", hr );
            break;
        } // if:

        if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
        {
            hr = S_OK;
            break;
        } // if:

        hr = THR( HrCoCreateInternalInstance( clsid, NULL, CLSCTX_ALL, IID_IClusCfgCapabilities, (void **) &piccc ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"Failed to CoCreate IClusCfgClusterCapabilites component", hr );
            continue;
        } // if:

        hr = THR( piccc->TypeSafeQI( IUnknown, &punk ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"Failed to QI IClusCfgClusterCapabilites component for IUnknown", hr );
            piccc->Release();
            piccc = NULL;
            continue;
        } // if:

        hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"Failed to initialize IClusCfgClusterCapabilites component", hr );
            piccc->Release();
            piccc = NULL;
            punk->Release();
            punk = NULL;
            continue;
        } // if:

        punk->Release();
        punk = NULL;

        hr = STHR( piccc->CanNodeBeClustered() );
        if ( FAILED( hr ) )
        {
            LOG_STATUS_REPORT( L"IClusCfgClusterCapabilites component failed in CanNodeBeClustered()", hr );
            piccc->Release();
            piccc = NULL;
            continue;
        } // if:

        if ( hr == S_FALSE )
        {
            m_fCanBeClustered = false;
        } // if:

        piccc->Release();
        piccc = NULL;
    } // for:

    if ( !m_fCanBeClustered )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( pieclsids != NULL )
    {
        pieclsids->Release();
    } // if:

    if ( pici != NULL )
    {
        pici->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::CanNodeBeClustered


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class -- IClusCfgPollingCallbackInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::GetCallback
//
//  Description:
//      Return the pointer to the embedded polling callback object.
//
//  Arguments:
//      ppiccpcOut
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::GetCallback( IClusCfgPollingCallback ** ppiccpcOut )
{
    TraceFunc( "[IClusCfgServer]" );
    Assert( m_picccCallback != NULL );

    HRESULT hr = S_OK;

    if ( ppiccpcOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetCallback, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( m_picccCallback->TypeSafeQI( IClusCfgPollingCallback, ppiccpcOut ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::GetCallback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::SetPollingMode
//
//  Description:
//      Set the polling mode of the callback.
//
//  Arguments:
//      fPollingModeIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::SetPollingMode( BOOL fPollingModeIn )
{
    TraceFunc( "[IClusCfgServer]" );
    Assert( m_picccCallback != NULL );

    HRESULT                         hr = S_OK;
    IClusCfgSetPollingCallback *    piccspc = NULL;

    m_fUsePolling = fPollingModeIn;

    hr = THR( m_picccCallback->TypeSafeQI( IClusCfgSetPollingCallback, &piccspc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccspc->SetPollingMode( m_fUsePolling ) );

Cleanup:

    if ( piccspc != NULL )
    {
        piccspc->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::SetPollingMode


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class -- IClusCfgVerify interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::VerifyCredentials
//
//  Description:
//      Validate the passed in credentials.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The credentials are valid.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::VerifyCredentials(
    LPCWSTR pcszNameIn,
    LPCWSTR pcszDomainIn,
    LPCWSTR pcszPasswordIn
    )
{
    TraceFunc( "[IClusCfgVerify]" );

    HRESULT hr = S_OK;
    HANDLE  hToken = NULL;

    //
    //  Logon the passed in user to ensure that it is valid.
    //
    //
    //  KB: 04 May 2000 GalenB
    //
    //  New for Whistler...  You no longer have to grant your processes TCB privilege. But it doesn't seem to work!
    //
    if ( !LogonUserW(
              const_cast< LPWSTR >( pcszNameIn )
            , const_cast< LPWSTR >( pcszDomainIn )
            , const_cast< LPWSTR >( pcszPasswordIn )
            , LOGON32_LOGON_NETWORK
            , LOGON32_PROVIDER_DEFAULT
            , &hToken
            ) )
    {
        DWORD   sc;

        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
    } // if:

    if ( hToken != NULL )
    {
        CloseHandle( hToken );
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::VerifyCredentials


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::VerifyConnectionToCluster
//
//  Description:
//      Verify that that this server is the same as the passed in server.
//
//  Arguments:
//      pcszClusterNameIn
//
//  Return Value:
//      S_OK
//          This is the server.
//
//      S_FALSE
//          This is not the server.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::VerifyConnectionToCluster(
    LPCWSTR pcszClusterNameIn
    )
{
    TraceFunc1( "[IClusCfgVerify] pcszClusterNameIn = '%ls'", pcszClusterNameIn );

    DWORD       sc;
    DWORD       dwClusterState;
    HRESULT     hr = S_FALSE;
    HCLUSTER    hCluster = NULL;
    BSTR        bstrClusterName = NULL;
    BSTR        bstrDomainName = NULL;
    WCHAR *     psz = NULL;
    size_t      cch;

    //
    //  Test arguments
    //
    if ( pcszClusterNameIn == NULL )
    {
        goto InvalidArg;
    } // if:

    //
    //  See if we are clustered.
    //
    sc = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if : GetClusterState() failed

    //
    // If the current cluster node state is running or not running then this node is part of a cluster.
    //
    if ( ( dwClusterState != ClusterStateNotRunning ) && ( dwClusterState != ClusterStateRunning ) )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    //
    //  Open the cluster to get the cluster's name.
    //
    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_VerifyConnection_OpenCluster, IDS_ERROR_OPEN_CLUSTER_FAILED, hr );
        goto Cleanup;
    } // if:

    //
    //  Try to get the cluster's name.
    //
    hr = THR( HrGetClusterInformation( hCluster, &bstrClusterName, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    cch = wcslen( bstrClusterName );

    //
    //  See if the domain name was given.
    //
    psz = wcschr( pcszClusterNameIn, L'.' );
    if ( psz == NULL )
    {
        //
        //  If no domain was given, see if it matches the cluster's name.
        //
        if ( _wcsicmp( bstrClusterName, pcszClusterNameIn ) == 0 )
        {
            hr = S_OK;
            goto Cleanup;
        } // if:

        goto Cleanup;
    } // if:

    //
    //  If if the cluster name matches.
    //
    if ( (size_t) ( psz - pcszClusterNameIn ) != cch )
    {
        goto Cleanup;   // nope
    } // if:

    if ( ( wcslen( pcszClusterNameIn ) < cch ) || ( memcmp( bstrClusterName, pcszClusterNameIn, cch ) != 0 ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Make sure we are in the same domain.
    //
    hr = THR( HrGetComputerName( ComputerNameDnsDomain, &bstrDomainName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    psz++;

    if ( _wcsicmp( bstrDomainName, psz ) == 0 )
    {
        hr = S_OK;
        goto Cleanup;
    } // if:

    Assert( hr == S_FALSE );

    goto Cleanup;

InvalidArg:

    hr = THR( E_INVALIDARG );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_VerifyConnection_InvalidArg, IDS_ERROR_INVALIDARG, hr );
    goto Cleanup;

Cleanup:

    if ( hr == S_FALSE )
    {
        LOG_STATUS_REPORT( L"Server name does not match what client is expecting.", hr );
    } // if:
    else if ( hr == S_OK )
    {
        LOG_STATUS_REPORT( L"Server name matches what client is expecting.", hr );
    } // else if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrDomainName );

    HRETURN( hr );

} // ClusCfgServer::VerifyConnection


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::VerifyConnectionToNode
//
//  Description:
//      Verify that that this server is the same as the passed in server.
//
//  Arguments:
//      pcszNodeNameIn
//
//  Return Value:
//      S_OK
//          This is the server.
//
//      S_FALSE
//          This is not the server.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgServer::VerifyConnectionToNode(
    LPCWSTR pcszNodeNameIn
    )
{
    TraceFunc1( "[IClusCfgVerify] pcszNodeNameIn = '%ls'", pcszNodeNameIn );

    HRESULT     hr = S_FALSE;
    LPWSTR      psz;

    //
    //  Test arguments
    //

    if ( pcszNodeNameIn == NULL )
    {
        goto InvalidArg;
    } // if:

    //
    //  Test state.
    //

    if ( m_bstrNodeName == NULL )
    {
        goto OutOfMemory;
    } // if:

    //
    //  See if it matches the nodes name.
    //

    if ( _wcsicmp( pcszNodeNameIn, m_bstrNodeName ) == 0 )
    {
        hr = S_OK;
        goto Cleanup;
    } // if:

    //
    //  If there isn't a domain attached to the node name, then check only
    //  the hostname.
    //

    psz = wcschr( pcszNodeNameIn, L'.' );
    if ( psz == NULL )
    {
        if ( _wcsnicmp( pcszNodeNameIn, m_bstrNodeName, wcslen( pcszNodeNameIn ) ) == 0 )
        {
            hr = S_OK;
            goto Cleanup;
        } // if:
    } // if:

    Assert( hr == S_FALSE );

    goto Cleanup;

InvalidArg:

    LogMsg( L"[SRV] VerifyConnection - Invalid argument." );
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:

    LogMsg( L"[SRV] VerifyConnection - out of memory." );
    hr = E_OUTOFMEMORY;

Cleanup:

    if ( hr == S_FALSE )
    {
        LogMsg( L"[SRV] VerifyConnection - Server name does not match what client is expecting." );
    } // if:
    else if ( hr == S_OK )
    {
        LogMsg( L"[SRV] VerifyConnection - Server name matches what client is expecting." );
    } // else if:

    HRETURN( hr );

} // ClusCfgServer::VerifyConnection


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgServer class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrInit( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    IUnknown *  punk = NULL;

    hr = THR( CClusCfgCallback::S_HrCreateInstance( &punk ) );
    if ( FAILED ( hr ) )
    {
        LogMsg( L"[SRV] Could not create CClusCfgCallback. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] Could not QI callback for a punk. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName( ComputerNameDnsFullyQualified, &m_bstrNodeName ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrInitializeForLocalServer
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrInitializeForLocalServer( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    IWbemLocator *  pIWbemLocator = NULL;
    BSTR            bstrNameSpace = NULL;

    hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pIWbemLocator );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_HrInitializeForLocalServer_WbemLocator, IDS_ERROR_WBEM_LOCATOR_CREATE_FAILED, hr );
        goto Cleanup;
    } // if:

    bstrNameSpace = TraceSysAllocString( L"\\\\.\\root\\cimv2" );
    if ( bstrNameSpace == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_HrInitializeForLocalServer_Memory, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    hr = THR( pIWbemLocator->ConnectServer(
                            bstrNameSpace,
                            NULL,                   // using current account for simplicity
                            NULL,                   // using current password for simplicity
                            NULL,                   // locale
                            0L,                     // securityFlags, reserved must be 0
                            NULL,                   // authority (domain for NTLM)
                            NULL,                   // context
                            &m_pIWbemServices
                            ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_WBEM_Connection_Failure, IDS_ERROR_WBEM_CONNECTION_FAILURE, hr );
        goto Cleanup;
    } // if:

    hr = THR( HrSetBlanket() );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Establish_Connection, TASKID_Minor_HrInitializeForLocalServer_Blanket, IDS_ERROR_WBEM_BLANKET_FAILURE, hr );
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrNameSpace );

    if ( pIWbemLocator != NULL )
    {
        pIWbemLocator->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrInitializeForLocalServer


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrSetBlanket
//
//  Description:
//      Adjusts the security blanket on the IWbemServices pointer.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrSetBlanket( void )
{
    TraceFunc( "" );
    Assert( m_pIWbemServices != NULL );

    HRESULT hr = S_FALSE;

    if ( m_pIWbemServices )
    {
        IClientSecurity *   pCliSec;

        hr = THR( m_pIWbemServices->TypeSafeQI( IClientSecurity, &pCliSec ) );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pCliSec->SetBlanket(
                            m_pIWbemServices,
                            RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE,
                            NULL,
                            RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            NULL,
                            EOAC_NONE
                            ) );

            pCliSec->Release();
        } // if:
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrSetBlanket


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrFormCluster
//
//  Description:
//      Form a new cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrFormCluster(
    IClusCfgClusterInfo *   piccciIn,
    IClusCfgBaseCluster *   piccbcaIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    BSTR                    bstrClusterName = NULL;
    BSTR                    bstrClusterBindingString = NULL;
    BSTR                    bstrClusterAccountName = NULL;
    BSTR                    bstrClusterAccountPwd = NULL;
    BSTR                    bstrClusterAccountDomain = NULL;
    BSTR                    bstrClusterIPNetwork = NULL;
    ULONG                   ulClusterIPAddress = 0;
    ULONG                   ulClusterIPSubnetMask = 0;
    IClusCfgCredentials *   picccServiceAccount = NULL;
    IClusCfgNetworkInfo *   piccni = NULL;

    //
    // Get the parameters required to form a cluster.
    //

    hr = THR( piccciIn->GetName( &bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the name of the cluster

    TraceMemoryAddBSTR( bstrClusterName );

    hr = STHR( piccciIn->GetBindingString( &bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the binding string of the cluster.

    TraceMemoryAddBSTR( bstrClusterBindingString );

    hr = THR( piccciIn->GetClusterServiceAccountCredentials( &picccServiceAccount ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster service account credentials

    hr = THR( picccServiceAccount->GetCredentials( &bstrClusterAccountName, &bstrClusterAccountDomain, &bstrClusterAccountPwd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the service account name. domain and password.

    TraceMemoryAddBSTR( bstrClusterAccountName );
    TraceMemoryAddBSTR( bstrClusterAccountDomain );
    TraceMemoryAddBSTR( bstrClusterAccountPwd );

    hr = THR( piccciIn->GetIPAddress( &ulClusterIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster IP address

    hr = THR( piccciIn->GetSubnetMask( &ulClusterIPSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster subnet mask

    hr = THR( piccciIn->GetNetworkInfo( &piccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the network info of the network the cluster name should be on.

    hr = THR( piccni->GetName( &bstrClusterIPNetwork ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the name of the cluster name network.

    TraceMemoryAddBSTR( bstrClusterIPNetwork );

    //
    // Indicate that a cluster should be formed when Commit() is called.
    //
    hr = THR( piccbcaIn->SetForm(
                          bstrClusterName
                        , bstrClusterBindingString
                        , bstrClusterAccountName
                        , bstrClusterAccountPwd
                        , bstrClusterAccountDomain
                        , ulClusterIPAddress
                        , ulClusterIPSubnetMask
                        , bstrClusterIPNetwork
                        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: SetForm() failed.

    // Initiate cluster formation.
    hr = THR( piccbcaIn->Commit() );

Cleanup:

    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrClusterBindingString );
    TraceSysFreeString( bstrClusterAccountName );
    TraceSysFreeString( bstrClusterAccountPwd );
    TraceSysFreeString( bstrClusterAccountDomain );
    TraceSysFreeString( bstrClusterIPNetwork );

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    if ( picccServiceAccount != NULL )
    {
        picccServiceAccount->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrFormCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrJoinToCluster
//
//  Description:
//      Join a node to a cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrJoinToCluster(
    IClusCfgClusterInfo *   piccciIn,
    IClusCfgBaseCluster *   piccbcaIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    BSTR                    bstrClusterName = NULL;
    BSTR                    bstrClusterBindingString = NULL;
    BSTR                    bstrClusterAccountName = NULL;
    BSTR                    bstrClusterAccountPwd = NULL;
    BSTR                    bstrClusterAccountDomain = NULL;
    IClusCfgCredentials *   picccServiceAccount = NULL;

    //
    // Get the parameters required to form a cluster.
    //

    hr = THR( piccciIn->GetName( &bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the name of the cluster

    TraceMemoryAddBSTR( bstrClusterName );

    hr = THR( piccciIn->GetBindingString( &bstrClusterBindingString ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster binding string.

    TraceMemoryAddBSTR( bstrClusterBindingString );

    hr = THR( piccciIn->GetClusterServiceAccountCredentials( &picccServiceAccount ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the cluster service account credentials

    hr = THR( picccServiceAccount->GetCredentials( &bstrClusterAccountName, &bstrClusterAccountDomain, &bstrClusterAccountPwd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get the service account name. domain and password.

    TraceMemoryAddBSTR( bstrClusterAccountName );
    TraceMemoryAddBSTR( bstrClusterAccountDomain );
    TraceMemoryAddBSTR( bstrClusterAccountPwd );

    //
    // Indicate that a cluster should be formed when Commit() is called.
    //
    hr = THR( piccbcaIn->SetJoin( bstrClusterName, bstrClusterBindingString, bstrClusterAccountName, bstrClusterAccountPwd, bstrClusterAccountDomain ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: SetJoin() failed.

    // Initiate joining of the node to the cluster.
    hr = THR( piccbcaIn->Commit() );

Cleanup:

    TraceSysFreeString( bstrClusterName );
    TraceSysFreeString( bstrClusterBindingString );
    TraceSysFreeString( bstrClusterAccountName );
    TraceSysFreeString( bstrClusterAccountPwd );
    TraceSysFreeString( bstrClusterAccountDomain );

    if ( picccServiceAccount != NULL )
    {
        picccServiceAccount->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrJoinToCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrEvictedFromCluster
//
//  Description:
//      Cleanup after a node has been evicted from a cluster. If another cleanup
//      session is in progress, wait for it to complete and then attempt cleanup.
//      In this way, if the other cleanup failed, this will retry it. If it had
//      suceeded, this will do nothing.
//
//      This function first calls the CommitChanges() method of the PostConfigManager
//      (which will inform resource types and memberset listeners that this node
//      has been evicted). It then cleans up the base cluster.
//
//  Arguments:
//      IPostCfgManager *               ppcmIn
//          Pointer to the IPostCfgManager interface
//
//      IEnumClusCfgManagedResources *  peccmrIn
//          Argument needed by the IPostCfgManager::CommitChanges()
//
//      IClusCfgClusterInfo *           piccciIn
//          Pointer to the cluster info
//
//      IClusCfgBaseCluster *           piccbcaIn
//          Pointer to the IClusCfgBaseCluster interface that is used to clean up
//          the base cluster.
//
//  Return Value:
//      S_OK
//          If everything went well
//
//      other HRESULTs
//          If the call failed
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrEvictedFromCluster(
    IPostCfgManager *               ppcmIn,
    IEnumClusCfgManagedResources *  peccmrIn,
    IClusCfgClusterInfo *           piccciIn,
    IClusCfgBaseCluster *           piccbcaIn
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    DWORD           dwStatus = ERROR_SUCCESS;
    HANDLE          hsCleanupLock = NULL;
    HANDLE          heventCleanupComplete = NULL;
    bool            fLockAcquired = false;
    DWORD           dwClusterState;
    HKEY            hNodeStateKey = NULL;
    DWORD           dwEvictState = 1;

    TraceFlow( "Trying to create cleanup lock." );

    // First, try and acquire a lock, so that two cleanup operations cannot overlap.
    hsCleanupLock = CreateSemaphore( NULL, 1, 1, CLEANUP_LOCK_NAME );
    if ( hsCleanupLock == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        TraceFlow1( "Error %#x occurred trying to create the cleanup lock.", hr );
        LogMsg( "Error %#08x occurred trying to create the cleanup lock.", hr );
        goto Cleanup;
    } // CreateSemaphore() failed

    TraceFlow( "Created cleanup lock. Now, trying to acquire it." );
    LogMsg( "Trying to acquire cleanup lock." );

    do
    {
        // Wait for any message sent or posted to this queue
        // or for our lock to be released.
        dwStatus = MsgWaitForMultipleObjects(
              1
            , &hsCleanupLock
            , FALSE
            , 300000                    // If this lock has not been released in 5 minutes, abort.
            , QS_ALLINPUT
            );

        // The result tells us the type of event we have.
        if ( dwStatus == ( WAIT_OBJECT_0 + 1 ) )
        {
            MSG msg;

            // Read all of the messages in this next loop,
            // removing each message as we read it.
            while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )
            {
                // If it is a quit message, we are done pumping messages.
                if ( msg.message == WM_QUIT)
                {
                    TraceFlow( "Get a WM_QUIT message. Cleanup message pump loop." );
                    break;
                } // if: we got a WM_QUIT message

                // Otherwise, dispatch the message.
                DispatchMessage( &msg );
            } // while: there are still messages in the window message queue

        } // if: we have a message in the window message queue
        else
        {
            if ( dwStatus == WAIT_OBJECT_0 )
            {
                fLockAcquired = true;
                LogMsg( "Cleanup lock acquired." );
                TraceFlow( "Our lock has been granted. Exiting wait loop." );
                break;
            } // else if: our lock is signaled
            else
            {
                if ( dwStatus == -1 )
                {
                    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                    LogMsg( "Error %#x occurred trying to wait for our lock to be granted.", hr );
                    TraceFlow1( "Error %#x occurred trying to wait for our lock to be granted.", hr );
                } // if: MsgWaitForMultipleObjects() returned an error
                else
                {
                    hr = THR( HRESULT_FROM_WIN32( dwStatus ) );
                    LogMsg( "An error occurred trying to wait for our lock to be granted. Status code is %#x.", dwStatus );
                    TraceFlow1( "An error occurred trying to wait for our lock to be granted. Status code is %#x.", dwStatus );
                } // else: an unexpected value was returned by MsgWaitForMultipleObjects()

                break;
            } // else: an unexpected result
        } // else: MsgWaitForMultipleObjects() exited for a reason other than a waiting message
    }
    while( true ); // do-while: loop infinitely

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not acquire the cleanup lock


    // Check if the install state is correct before invoking post configuration manager.
    dwStatus = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( dwStatus != ERROR_SUCCESS )
    {
        TraceFlow1( "Error %#x occurred trying to determine the installation state of this node.", dwStatus );
        LogMsg( "Error %#x occurred trying to determine the installation state of this node.", dwStatus );
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto Cleanup;
    } // if : GetClusterState() failed

    // Check if this node is part of a cluster.
    if ( ( dwClusterState != ClusterStateNotRunning ) && ( dwClusterState != ClusterStateRunning ) )
    {
        TraceFlow( "This node is not part of a cluster - no cleanup is necessary." );
        LogMsg( "This node is not part of a cluster - no cleanup is necessary." );
        goto Cleanup;
    } // if: this node is not part of a cluster


    //
    // Set a registry value indicating that this node has been evicted.
    // If, for some reason, the cleanup could not be completed, the cluster
    // service will check this flag the next time it comes up and restarts
    // cleanup.
    //

    dwStatus = TW32(
        RegOpenKeyEx(
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_NODE_DATA
            , 0
            , KEY_ALL_ACCESS
            , &hNodeStateKey
            )
        );

    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        LogMsg( "Error %#08x occurred trying to open a registry key to set a value indicating that this node has been evicted.", hr );
        TraceFlow1( "Error %#08x occurred trying to open a registry key to set a value indicating that this node has been evicted.", hr );
        goto Cleanup;
    } // if: RegOpenKeyEx() has failed

    dwStatus = TW32(
        RegSetValueEx(
              hNodeStateKey
            , CLUSREG_NAME_EVICTION_STATE
            , 0
            , REG_DWORD
            , reinterpret_cast< const BYTE * >( &dwEvictState )
            , sizeof( dwEvictState )
            )
        );

    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        LogMsg( "Error %#08x occurred trying to set a registry value indicating that this node has been evicted.", hr );
        TraceFlow1( "Error %#08x occurred trying to set a registry value indicating that this node has been evicted.", hr );
        goto Cleanup;
    } // if: RegSetValueEx() has failed

    // Commit the post configuration steps first
    hr = THR( ppcmIn->CommitChanges( peccmrIn, piccciIn ) );
    if ( FAILED( hr ) )
    {
        TraceFlow1( "Error %#x occurred calling IPostCfgManager::CommitChanges().", hr );
        LogMsg( "Error %#x occurred during the post configuration step of cleanup.", hr);
        goto Cleanup;
    } // if: post configuration failed

    TraceFlow( "IPostCfgManager::CommitChanges() completed successfully during cleanup." );

    hr = THR( piccbcaIn->SetCleanup() );
    if ( FAILED( hr ) )
    {
        TraceFlow1( "Error %#x occurred calling IClusCfgBaseCluster::SetCleanup().", hr );
        LogMsg( "Error %#x occurred initiating cleanup of the base cluster.", hr);
        goto Cleanup;
    } // if: SetCleanup() failed

    // Initiate the cleanup
    hr = THR( piccbcaIn->Commit() );
    if ( FAILED( hr ) )
    {
        TraceFlow1( "Error %#x occurred calling IClusCfgBaseCluster::CommitChanges().", hr );
        LogMsg( "Error %#x occurred trying to cleanup the base cluster.", hr);
        goto Cleanup;
    } // if: base cluster cleanup failed

    TraceFlow( "Base cluster successfully cleaned up." );

    // If we are here, then cleanup has completed successfully. If some other process is waiting
    // for cleanup to complete, release that process by signaling an event.
    {
        // Open the event. Note, if this event does not already exist, then it means that nobody is
        // waiting on this event. So, it is ok for OpenEvent to fail.
        heventCleanupComplete = OpenEvent( EVENT_ALL_ACCESS, FALSE, SUCCESSFUL_CLEANUP_EVENT_NAME );
        if ( heventCleanupComplete == NULL )
        {
            dwStatus = GetLastError();
            TraceFlow1( "Status %#x was returned trying to open the cleanup completion event. This just means that no process is waiting on this event.", dwStatus );
            LogMsg( "Status %#x was returned trying to open the cleanup completion event. This just means that no process is waiting on this event.", dwStatus );
            goto Cleanup;
        } // if: OpenEvent() failed

        if ( PulseEvent( heventCleanupComplete ) == FALSE )
        {
            // Error, but not fatal. hr should still be S_OK.
            dwStatus = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to pulse the cleanup completion event. This is not a fatal error.", dwStatus );
            LogMsg( "Error %#x occurred trying to pulse the cleanup completion event. This is not a fatal error.", dwStatus );
            goto Cleanup;
        } // if: PulseEvent() failed

        TraceFlow( "Cleanup completion event has been set." );
    }

Cleanup:

    if ( heventCleanupComplete == NULL )
    {
        CloseHandle( heventCleanupComplete );
    } // if: we had opened the cleanup complete event

    if ( hsCleanupLock != NULL )
    {
        if ( fLockAcquired )
        {
            ReleaseSemaphore( hsCleanupLock, 1, NULL );

            LogMsg( "Cleanup lock released." );
            TraceFlow( "Cleanup lock released." );
        } // if: we have acquired the semaphore but not released it yet

        CloseHandle( hsCleanupLock );
    } // if: we had created a cleanup lock

    if ( hNodeStateKey != NULL )
    {
        RegCloseKey( hNodeStateKey );
    } // if: we had opened the node state registry key

    HRETURN( hr );

} //*** CClusCfgServer::HrEvictedFromCluster


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrHasNodeBeenEvicted
//
//  Description:
//      Has this node been evicted?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The node needs to be cleanedup.
//
//      S_FALSE
//          The node does not need to be cleanup.
//
//      Win32 error as HRESULT.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrHasNodeBeenEvicted( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwClusterState;
    BOOL    fEvicted = false;

    sc = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if : GetClusterState() failed

    //
    //  If the cluster service is not running then we need to check if we should
    //  clean it up or not.
    //
    if ( dwClusterState == ClusterStateNotRunning )
    {
        sc = TW32( ClRtlHasNodeBeenEvicted( &fEvicted ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        if ( fEvicted )
        {
            hr = S_OK;
        } // if:
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::HrHasNodeBeenEvicted

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrCleanUpNode
//
//  Description:
//      Cleanup this node because it was evicted.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrCleanUpNode( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IClusCfgEvictCleanup *  pcceEvict = NULL;

    hr = THR(
        CoCreateInstance(
              CLSID_ClusCfgEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , __uuidof( pcceEvict )
            , reinterpret_cast< void ** >( &pcceEvict )
            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: the ClusCfgEvictCleanup object could not be created

    hr = THR( pcceEvict->CleanupLocalNode( 0 ) );   // 0 means "cleanup immediately"
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: an error occurred during cleanup

Cleanup:

    if ( pcceEvict != NULL )
    {
        pcceEvict->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgServer::HrCleanUpNode


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgServer::HrCreateClusterNodeInfo
//
//  Description:
//      Create the cluster node info object and store it in the member
//      variable.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgServer::HrCreateClusterNodeInfo( void )
{
    TraceFunc( "" );
    Assert( m_punkNodeInfo == NULL );

    HRESULT hr = S_OK;

    hr = THR( CClusCfgNodeInfo::S_HrCreateInstance( &m_punkNodeInfo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_punkNodeInfo = TraceInterface( L"CClusCfgNodeInfo", IUnknown, m_punkNodeInfo, 1 );

    hr = THR( HrSetInitialize( m_punkNodeInfo, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( m_punkNodeInfo, m_pIWbemServices ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgServer::HrCreateClusterNodeInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgserver.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgServer.h
//
//  Description:
//      This file contains the declaration of the  CClusCfgServer
//      class.
//
//      The class CClusCfgServer is the implementations of the
//      IClusCfgServer interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusCfgServer.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 03-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <ClusCfgPrivate.h>
#include "..\PostCfg\IPostCfgManager.h"

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgServer
//
//  Description:
//      The class CClusCfgServer is the server that provides the
//      functionality to form a cluster and join additional nodes to a cluster.
//
//  Interfaces:
//      IClusCfgServer
//      IClusCfgInitialize
//      IClusCfgCapabilities
//      IClusCfgPollingCallbackInfo
//      IClusCfgVerify
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgServer
    : public IClusCfgServer
    , public IClusCfgInitialize
    , public IClusCfgCapabilities
    , public IClusCfgPollingCallbackInfo
    , public IClusCfgVerify
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    IWbemServices *     m_pIWbemServices;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IUnknown *          m_punkNodeInfo;
    IUnknown *          m_punkEnumResources;
    IUnknown *          m_punkNetworksEnum;
    BOOL                m_fCanBeClustered:1;
    BOOL                m_fUsePolling:1;
    BSTR                m_bstrNodeName;
    BSTR                m_bstrBindingString;

    // Private constructors and destructors
    CClusCfgServer( void );
    ~CClusCfgServer( void );

    // Private copy constructor to prevent copying.
    CClusCfgServer( const CClusCfgServer & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusCfgServer & operator = ( const CClusCfgServer & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrInitializeForLocalServer( void );
    HRESULT HrSetBlanket( void );
    HRESULT HrFormCluster( IClusCfgClusterInfo * piccciIn, IClusCfgBaseCluster * piccbcaIn );
    HRESULT HrJoinToCluster( IClusCfgClusterInfo * piccciIn, IClusCfgBaseCluster * piccbcaIn );
    HRESULT HrEvictedFromCluster(
        IPostCfgManager *               ppcmIn,
        IEnumClusCfgManagedResources *  peccmrIn,
        IClusCfgClusterInfo *           piccciIn,
        IClusCfgBaseCluster *           piccbcaIn
        );
    HRESULT HrHasNodeBeenEvicted( void );
    HRESULT HrCleanUpNode( void );
    HRESULT HrCreateClusterNodeInfo( void );

public:
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    //  IClusCfgInitialize
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgServer Interfaces
    //

    // Get information about the computer on which this object is present.
    STDMETHOD( GetClusterNodeInfo )( IClusCfgNodeInfo ** ppClusterNodeInfoOut );

    // Get an enumeration of the devices on this computer that can be managed by the cluster service.
    STDMETHOD( GetManagedResourcesEnum )( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut );

    // Get an enumeration of all the networks on this computer.
    STDMETHOD( GetNetworksEnum )( IEnumClusCfgNetworks ** ppEnumNetworksOut );

    // Commit the changes to the node
    STDMETHOD( CommitChanges )( void );

    // Binding String
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );
    STDMETHOD( SetBindingString )( LPCWSTR pcszBindingStringIn );

    //
    //  IClusCfgCapabilities
    //

    STDMETHOD( CanNodeBeClustered )( void );

    //
    //  IClusCfgPollingCallbackInfo
    //

    STDMETHOD( GetCallback )( IClusCfgPollingCallback ** ppiccpcOut );

    STDMETHOD( SetPollingMode )( BOOL fPollingModeIn );

    //
    //  IClusCfgVerify
    //

    STDMETHOD( VerifyCredentials )( LPCWSTR pcszUserIn, LPCWSTR pcszDomainIn, LPCWSTR pcszPasswordIn );

    STDMETHOD( VerifyConnectionToCluster )( LPCWSTR pcszClusterNameIn );

    STDMETHOD( VerifyConnectionToNode )( LPCWSTR pcszNodeNameIn );

}; //*** Class CClusCfgServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\ccluscfgpartitioninfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusCfgPartitionInfo.cpp
//
//  Description:
//      This file contains the definition of the CClusCfgPartitionInfo
//       class.
//
//      The class CClusCfgPartitionInfo represents a disk partition.
//      It implements the IClusCfgPartitionInfo interface.
//
//  Documentation:
//
//  Header File:
//      CClusCfgPartitionInfo.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusCfgPartitionInfo.h"
#include <StdIo.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusCfgPartitionInfo" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::S_HrCreateInstance()
//
//  Description:
//      Create a CClusCfgPartitionInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgPartitionInfo instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CClusCfgPartitionInfo *     lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CClusCfgPartitionInfo();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusCfgPartitionInfo::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::CClusCfgPartitionInfo()
//
//  Description:
//      Constructor of the CClusCfgPartitionInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgPartitionInfo::CClusCfgPartitionInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_pIWbemServices == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_bstrDescription == NULL );
    Assert( m_bstrUID == NULL );
    Assert( m_prgLogicalDisks == NULL );
    Assert( m_idxNextLogicalDisk == 0 );
    Assert( m_ulPartitionSize == 0 );
    Assert( m_picccCallback == NULL );

    TraceFuncExit();

} //*** CClusCfgPartitionInfo::CClusCfgPartitionInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::~CClusCfgPartitionInfo()
//
//  Description:
//      Desstructor of the CClusCfgPartitionInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgPartitionInfo::~CClusCfgPartitionInfo( void )
{
    TraceFunc( "" );

    ULONG   idx;

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrDescription );
    TraceSysFreeString( m_bstrUID );

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        ((*m_prgLogicalDisks)[ idx ])->Release();
    } // for:

    TraceFree( m_prgLogicalDisks );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusCfgPartitionInfo::~CClusCfgPartitionInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgPartitionInfo:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgPartitionInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusCfgPartitionInfo::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusCfgPartitionInfo:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgPartitionInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CClusCfgPartitionInfo::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgPartitionInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgPartitionInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgPartitionInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgPartitionProperties ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgPartitionProperties, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgSetWbemObject ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgSetWbemObject, this, 0 );
        hr   = S_OK;
    } // else if:


    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusCfgPartitionInfo::QueryInterface()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetWbemServices()
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Partition, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetWbemServices()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IClusCfgPartitionInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetUID()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetUID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( m_bstrUID );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetUID()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetName()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if (*pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetName()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgPartitionInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetDescription()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetDescription( BSTR * pbstrDescriptionOut )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrDescriptionOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetDescription_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrDescriptionOut = SysAllocString( m_bstrDescription );
    if (*pbstrDescriptionOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PartitionInfo_GetDescription_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetDescription()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetDescription()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::SetDescription( LPCWSTR pcszDescriptionIn )
{
    TraceFunc1( "[IClusCfgPartitionInfo] pcszDescriptionIn = '%ls'", pcszDescriptionIn == NULL ? L"<null>" : pcszDescriptionIn );

    HRESULT hr;

    if ( pcszDescriptionIn == NULL )
    {
        hr = THR( E_INVALIDARG );
    } // if:
    else
    {
        hr = THR( E_NOTIMPL );
    } // else:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetDescription()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT             hr = S_FALSE;
    IWbemClassObject *  pLogicalDisk = NULL;
    VARIANT             var;
    ULONG               idx;
    int                 idxDrive;

    if ( pdlmDriveLetterMappingOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetDriveLetterMappings_Partition, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    VariantInit( & var );

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        hr = THR( ((*m_prgLogicalDisks)[ idx ])->TypeSafeQI( IWbemClassObject, &pLogicalDisk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        VariantClear( &var );

        hr = THR( HrGetWMIProperty( pLogicalDisk, L"Name", VT_BSTR, &var ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        CharUpper( var.bstrVal );

        idxDrive = var.bstrVal[ 0 ] - 'A';

        VariantClear( &var );

        hr = THR( HrGetWMIProperty( pLogicalDisk, L"DriveType", VT_I4, &var ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        pdlmDriveLetterMappingOut->dluDrives[ idx ] = (EDriveLetterUsage) var.iVal;

        pLogicalDisk->Release();
        pLogicalDisk = NULL;
    } // for:

Cleanup:

    VariantClear( &var );

    if ( pLogicalDisk != NULL )
    {
        pLogicalDisk->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetDriveLetterMappings()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetDriveLetterMappings()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetSize()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetSize( ULONG * pcMegaBytes )
{
    TraceFunc( "[IClusCfgPartitionInfo]" );

    HRESULT hr = S_OK;

    if ( pcMegaBytes == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetSize, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pcMegaBytes = m_ulPartitionSize;

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetSize()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::SetWbemObject()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::SetWbemObject(
      IWbemClassObject *    pPartitionIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "" );
    Assert( pPartitionIn != NULL );
    Assert( pfRetainObjectOut != NULL );

    HRESULT     hr = S_OK;
    VARIANT     var;
    ULONGLONG   ull;

    VariantInit( &var );

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Description", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDescription = TraceSysAllocString( var.bstrVal );
    if ( m_bstrDescription == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Size", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    swscanf( var.bstrVal, L"%I64u", &ull );

    m_ulPartitionSize = (ULONG) ( ull / ( 1024 * 1024 ) );

    hr = THR( HrGetLogicalDisks( pPartitionIn ) );

    *pfRetainObjectOut = true;
    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemObject_Partition, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::SetWbemObject()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::Initialize()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::Initialize()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo -- IClusCfgPartitionProperties interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::IsThisLogicalDisk()
//
//  Description:
//      Does this partition have the passed in logical disk?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success, the partition has the logical disk.
//
//      S_FALSE
//          Success, the partition does not have the logical disk.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::IsThisLogicalDisk( WCHAR cLogicalDiskIn )
{
    TraceFunc( "[IClusCfgPartitionProperties]" );

    HRESULT             hr = S_FALSE;
    DWORD               idx;
    IWbemClassObject *  piwco = NULL;
    VARIANT             var;
    bool                fFoundIt = false;

    if ( m_idxNextLogicalDisk == 0 )
    {
        goto Cleanup;
    } // if:

    VariantInit( &var );

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        hr = THR( ((*m_prgLogicalDisks)[ idx ])->TypeSafeQI( IWbemClassObject, &piwco ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( piwco, L"DeviceID", VT_BSTR, &var ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( cLogicalDiskIn == var.bstrVal[ 0 ] )
        {
            fFoundIt = true;
            break;
        } // if:

        VariantClear( &var );

        piwco->Release();
        piwco = NULL;
    } // for:

    if ( !fFoundIt )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    VariantClear( &var );

    if ( piwco != NULL )
    {
        piwco->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::IsThisLogicalDisk()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::IsNTFS()
//
//  Description:
//      Is this an NTFS partition?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success, the partition is NTFS.
//
//      S_FALSE
//          Success, the partition is not NTFS.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::IsNTFS( void )
{
    TraceFunc( "[IClusCfgPartitionProperties]" );

    HRESULT             hr = S_FALSE;
    VARIANT             var;
    ULONG               idx;
    IWbemClassObject *  piwco = NULL;

    VariantInit( &var );

    for ( idx = 0, hr = S_OK; idx < m_idxNextLogicalDisk; idx++ )
    {
        hr = THR( ((*m_prgLogicalDisks)[ idx ])->TypeSafeQI( IWbemClassObject, &piwco ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        VariantClear( &var );

        hr = HrGetWMIProperty( piwco, L"FileSystem", VT_BSTR, &var );
        if ( ( hr == E_PROPTYPEMISMATCH ) && ( var.vt == VT_NULL ) )
        {
            VariantClear( &var );

            hr = S_FALSE;
            THR( HrGetWMIProperty( piwco, L"DeviceID", VT_BSTR, &var ) );
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Phys_Disk_No_File_System, IDS_ERROR_PHYSDISK_NO_FILE_SYSTEM, var.bstrVal, hr );
            break;
        } // if:
        else if ( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        } // else if:

        if ( wcscmp( var.bstrVal, L"NTFS" ) != 0 )
        {
            VariantClear( &var );

            hr = S_FALSE;
            THR( HrGetWMIProperty( piwco, L"DeviceID", VT_BSTR, &var ) );
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Phys_Disk_Not_NTFS, IDS_ERROR_PHYSDISK_NOT_NTFS, var.bstrVal, hr );
            break;
        } // if:

        piwco->Release();
        piwco = NULL;
    } // for:

Cleanup:

    VariantClear( &var );

    if ( piwco != NULL )
    {
        piwco->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::IsNTFS()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::GetFriendlyName()
//
//  Description:
//      Get the friendly name of this partition.  This name will be the
//      logical disk names of all logical disks on this partition.
//
//  Arguments:
//      BSTR * pbstrNameOut
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgPartitionInfo::GetFriendlyName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgPartitionProperties]" );

    HRESULT             hr = S_FALSE;
    DWORD               idx;
    IWbemClassObject *  piwco = NULL;
    WCHAR *             psz = NULL;
    WCHAR *             pszTmp = NULL;
    DWORD               cch = 0;
    VARIANT             var;

    if ( m_idxNextLogicalDisk == 0 )
    {
        goto Cleanup;
    } // if:

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetFriendlyName, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    VariantInit( &var );

    for ( idx = 0; idx < m_idxNextLogicalDisk; idx++ )
    {
        hr = THR( ((*m_prgLogicalDisks)[ idx ])->TypeSafeQI( IWbemClassObject, &piwco ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( piwco, L"DeviceID", VT_BSTR, &var ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        cch += ( UINT ) wcslen( var.bstrVal ) + 2;                      // a space and the '\0'

        pszTmp = (WCHAR *) TraceReAlloc( psz, sizeof( WCHAR ) * cch, HEAP_ZERO_MEMORY );
        if ( pszTmp == NULL  )
        {
            goto OutOfMemory;
        } // if:

        psz = pszTmp;
        pszTmp = NULL;

        wcscat( psz, L" " );
        wcscat( psz, var.bstrVal );

        VariantClear( &var );

        piwco->Release();
        piwco = NULL;
    } // for:

    *pbstrNameOut = TraceSysAllocString( psz );
    if ( *pbstrNameOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetFriendlyName, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    if ( piwco != NULL )
    {
        piwco->Release();
    } // if:

    if ( psz != NULL )
    {
        TraceFree( psz );
    } // if:

    if ( pszTmp != NULL )
    {
        free( pszTmp );
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::GetFriendlyName()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusCfgPartitionInfo class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo::HrInit()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::HrInit()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo:HrAddLogicalDiskToArray()
//
//  Description:
//      Add the passed in logical disk to the array of punks that holds the
//      logical disks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::HrAddLogicalDiskToArray( IWbemClassObject * pLogicalDiskIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgLogicalDisks, sizeof( IUnknown * ) * ( m_idxNextLogicalDisk + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddLogicalDiskToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // else:

    m_prgLogicalDisks = prgpunks;

    hr = THR( pLogicalDiskIn->TypeSafeQI( IUnknown, &punk ) );
    if ( SUCCEEDED( hr ) )
    {
        (*m_prgLogicalDisks)[ m_idxNextLogicalDisk++ ] = punk;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::HrAddLogicalDiskToArray()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgPartitionInfo:HrGetLogicalDisks()
//
//  Description:
//      Get the logical disks for the passed in partition.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          The file system was not NTFS.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgPartitionInfo::HrGetLogicalDisks(
    IWbemClassObject * pPartitionIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    VARIANT                 var;
    WCHAR                   szBuf[ 256 ];
    IEnumWbemClassObject *  pLogicalDisks = NULL;
    IWbemClassObject *      pLogicalDisk = NULL;
    ULONG                   ulReturned;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantInit( &var );

    //
    //  Need to enum the logical disk(s) of this partition to determine if it is booted
    //  bootable.
    //
    hr = THR( HrGetWMIProperty( pPartitionIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    _snwprintf( szBuf, ARRAYSIZE( szBuf ), L"Associators of {Win32_DiskPartition.DeviceID='%s'} where AssocClass=Win32_LogicalDiskToPartition", var.bstrVal );

    bstrQuery = TraceSysAllocString( szBuf );
    if ( bstrQuery == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pLogicalDisks ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_WMI_Logical_Disks_Qry_Failed, IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED, hr );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = pLogicalDisks->Next( WBEM_INFINITE, 1, &pLogicalDisk, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            hr = THR( HrAddLogicalDiskToArray( pLogicalDisk ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            pLogicalDisk->Release();
            pLogicalDisk = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_HrGetLogicalDisks_Next, IDS_ERROR_WQL_QRY_NEXT_FAILED, bstrQuery, hr );
            goto Cleanup;
        } // else:
    } // for:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetLogicalDisks, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );

    if ( pLogicalDisk != NULL )
    {
        pLogicalDisk->Release();
    } // if:

    if ( pLogicalDisks != NULL )
    {
        pLogicalDisks->Release();
    } // if:

    HRETURN( hr );

} //*** CClusCfgPartitionInfo::HrGetLogicalDisks()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cclusterresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusterResource.h
//
//  Description:
//      This file contains the declaration of the CClusterResource
//      class.
//
//      The class CClusterResource represents a cluster resource.
//      It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CClusterResource.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResource
//
//  Description:
//      The class CClusterResource represents a cluster storage
//      device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//      IClusCfgLoadResource
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResource
    : public IClusCfgManagedResourceInfo
    , public IClusCfgInitialize
    , public IClusCfgLoadResource
{
private:

    enum EStates
    {
        eIsQuorumDevice     = 1,
        eIsQuorumCapable    = 2,
        eIsQuorumJoinable   = 4
    };

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    DWORD               m_dwFlags;
    BSTR                m_bstrName;
    BSTR                m_bstrDescription;
    BSTR                m_bstrType;

    // Private constructors and destructors
    CClusterResource( void );
    ~CClusterResource( void );

    // Private copy constructor to prevent copying.
    CClusterResource( const CClusterResource & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusterResource & operator = ( const CClusterResource & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrIsResourceQuorumCapabile( HRESOURCE hResourceIn );
    HRESULT HrDetermineQuorumJoinable( HRESOURCE hResourceIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgLoadResoruce Interfaces
    //

    STDMETHOD( LoadResource )( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( BSTR bstrNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumDevice )( void );

    STDMETHOD( SetQuorumedDevice )( BOOL fIsQuorumDeviceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsDeviceJoinable )( void );

    STDMETHOD( SetDeviceJoinable )( BOOL fIsJoinableIn );

}; //*** Class CClusterResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cclusterresource.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusterResource.cpp
//
//  Description:
//      This file contains the definition of the CClusterResource
//       class.
//
//      The class CClusterResource represents a cluster manageable
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Documentation:
//
//  Header File:
//      CClusterResource.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusterResource.h"
#include <PropList.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusterResource" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::S_HrCreateInstance()
//
//  Description:
//      Create a CClusterResource instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusterResource instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterResource::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CClusterResource *     lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CClusterResource();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CClusterResource::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CClusterResource::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::CClusterResource()
//
//  Description:
//      Constructor of the CClusterResource class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResource::CClusterResource( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_dwFlags == 0 );
    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_bstrDescription == NULL );
    Assert( m_bstrType == NULL );

    TraceFuncExit();

} //*** CClusterResource::CClusterResource


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::~CClusterResource()
//
//  Description:
//      Desstructor of the CClusterResource class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResource::~CClusterResource( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrDescription );
    TraceSysFreeString( m_bstrType );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CClusterResource::~CClusterResource


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusterResource:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusterResource::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CClusterResource::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CClusterResource:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusterResource::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CClusterResource::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgManagedResourceInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgLoadResource ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgLoadResource, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CClusterResource::QueryInterface()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::Initialize()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::Initialize()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource -- IClusCfgLoadResource interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::LoadResource()
//
//  Description:
//      Initialize this component from the cluster resource.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::LoadResource(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "[IClusCfgLoadResource]" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    CClusPropList           cpl;
    CLUSPROP_BUFFER_HELPER  cpbh;

    sc = TW32( cpl.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Description" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    m_bstrDescription = TraceSysAllocString( cpbh.pStringValue->sz );
    if ( m_bstrDescription == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    m_bstrName = TraceSysAllocString( cpbh.pStringValue->sz );
    if ( m_bstrName == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Type" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    m_bstrType = TraceSysAllocString( cpbh.pStringValue->sz );
    if ( m_bstrType == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( HrIsResourceQuorumCapabile( hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
    else if ( hr == S_OK )
    {
        m_dwFlags |= eIsQuorumCapable;
    }

    // Do this only if the above is true i.e. Device quorum capable...
    if( hr == S_OK )
    {
        hr = THR( HrDetermineQuorumJoinable( hResourceIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
        else if ( hr == S_OK )
        {
            m_dwFlags |= eIsQuorumJoinable;
        }
    }

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LoadResource, IDS_ERROR_OUTOFMEMORY, hr );
    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::LoadResource()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////

#if 0 // DEAD CODE: GPease  27-JUL-2000 Method Removed
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::TransferInformation()
//
//  Description:
//      Transfer node information from another source.
//
//  Arguments:
//      IN IClusCfgManagedResourceInfo * pccmriIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//  Remarks:
//      none
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::TransferInformation(
    IClusCfgManagedResourceInfo * pccmriIn
    )
{
    TraceFunc( "" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //***  CClusterResource::TransferInformation()
*/
#endif // End Dead Code


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::GetUID()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_ClusterResource_GetUID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( m_bstrName );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_ClusterResource_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::GetUID()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::GetName()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut != NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::GetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetName()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetName( BSTR bstrNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] bstrNameIn = '%ls'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;

    if ( bstrNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    m_bstrName = TraceSysAllocString( bstrNameIn );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetName_Cluster_Resource, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::SetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::IsManaged()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_OK );

} //*** CClusterResource::IsManaged()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetManaged()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetManaged( BOOL fIsManagedIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::SetManaged()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::IsQuorumDevice()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::IsQuorumDevice( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsQuorumDevice )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusterResource::IsQuorumDevice()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetQuorumedDevice()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetQuorumedDevice( BOOL fIsQuorumDeviceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::SetQuorumedDevice()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::IsDeviceJoinable()
//
//  Description:
//      Does the Quorumable device allow other nodes to join.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is joinable.
//
//      S_FALSE
//          The device is not joinable.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::IsDeviceJoinable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsQuorumJoinable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusterResource::IsDeviceJoijnable()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetDeviceJoinable()
//
//  Description:
//      Set the joinable flag.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is joinable.
//
//      S_FALSE
//          The device is not joinable.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This method should never be called.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetDeviceJoinable( BOOL fIsJoinableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CClusterResource::SetDeviceJoijnable()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::IsQuorumCapable()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_dwFlags & eIsQuorumCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CClusterResource::IsQuorumCapable()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::GetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::GetDriveLetterMappings()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::SetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterResource::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CClusterResource::SetDriveLetterMappings()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterResource class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::HrInit()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterResource::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CClusterResource::HrInit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::HrIsResourceQuorumCapabile()
//
//  Description:
//      Is this resource quorum capable?
//
//  Arguments:
//      None.
//
//  Return Value:
//
//      S_OK
//          The resource is quorum capable.
//
//      S_FALSE
//          The resource is not quorum capable.
//
//      Other Win32 error as HRESULT.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterResource::HrIsResourceQuorumCapabile( HRESOURCE hResourceIn )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwFlags;
    DWORD   cbReturned;

    sc = TW32( ClusterResourceControl(
                        hResourceIn,
                        NULL,
                        CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                        &dwFlags,
                        sizeof( dwFlags ),
                        NULL,
                        NULL,
                        &cbReturned
                        ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwFlags & ( CLUS_CHAR_QUORUM | CLUS_CHAR_LOCAL_QUORUM | CLUS_CHAR_LOCAL_QUORUM_DEBUG ) )
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterResource::HrIsResourceQuorumCapabile()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::HrDetermineQuorumJoinable()
//
//  Description:
//      Is this quorumable resource joinable?
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterResource::HrDetermineQuorumJoinable( HRESOURCE hResourceIn )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwFlags;
    DWORD   cbReturned;

    sc = TW32( ClusterResourceControl(
                        hResourceIn,
                        NULL,
                        CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                        &dwFlags,
                        sizeof( dwFlags ),
                        NULL,
                        NULL,
                        &cbReturned
                        ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwFlags & (CLUS_CHAR_QUORUM|CLUS_CHAR_LOCAL_QUORUM_DEBUG))
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgipaddresses.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgIPAddresses.cpp
//
//  Description:
//      This file contains the definition of the CEnumClusCfgIPAddresses
//       class.
//
//      The class CEnumClusCfgIPAddresses is the enumeration of IP addresses.
//      It implements the IEnumClusCfgIPAddresses interface.
//
//  Documentation:
//
//  Header File:
//      CEnumClusCfgIPAddresses.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CEnumClusCfgIPAddresses.h"
#include "CClusCfgIPAddressInfo.h"
#include <ClusRtl.h>
#include <commctrl.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumClusCfgIPAddresses" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusCfgIPAddresses instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusCfgIPAddresses instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                     hr;
    CEnumClusCfgIPAddresses *   pccsd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccsd = new CEnumClusCfgIPAddresses();
    if ( pccsd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccsd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccsd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusCfgIPAddresses::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccsd != NULL )
    {
        pccsd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusCfgIPAddresses instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusCfgIPAddresses instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::S_HrCreateInstance(
      ULONG             ulIPAddressIn
    , ULONG             ulIPSubnetIn
    , IUnknown *        punkCallbackIn
    , LCID              lcidIn
    , IWbemServices *   pIWbemServicesIn
    , IUnknown **       ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );
    Assert( ulIPAddressIn != 0 );
    Assert( ulIPSubnetIn != 0 );

    HRESULT                     hr;
    CEnumClusCfgIPAddresses *   pccsd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccsd = new CEnumClusCfgIPAddresses();
    if ( pccsd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccsd->Initialize( punkCallbackIn, lcidIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccsd->SetWbemServices( pIWbemServicesIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccsd->HrInit( ulIPAddressIn, ulIPSubnetIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccsd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusCfgIPAddresses::S_HrCreateInstance( ULONG, ULONG ) failed. (hr = %#08x)", hr );
    } // if:

    if ( pccsd != NULL )
    {
        pccsd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::CEnumClusCfgIPAddresses
//
//  Description:
//      Constructor of the CEnumClusCfgIPAddresses class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgIPAddresses::CEnumClusCfgIPAddresses( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_prgAddresses == NULL );
    Assert( m_cAddresses == 0 );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgIPAddresses::CEnumClusCfgIPAddresses


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::~CEnumClusCfgIPAddresses
//
//  Description:
//      Desstructor of the CEnumClusCfgIPAddresses class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgIPAddresses::~CEnumClusCfgIPAddresses( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        ((*m_prgAddresses)[ idx ])->Release();
    } // for:

    TraceFree( m_prgAddresses );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgIPAddresses::~CEnumClusCfgIPAddresses


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumClusCfgIPAddresses:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgIPAddresses::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CEnumClusCfgIPAddresses::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumClusCfgIPAddresses:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgIPAddresses::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CEnumClusCfgIPAddresses::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IEnumClusCfgIPAddresses * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgSetWbemObject ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgSetWbemObject, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN( hr, riid );

} //*** CEnumClusCfgIPAddresses::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Enum_IPAddresses, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses -- IEnumClusCfgIPAddresses interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Next(
    ULONG                       cNumberRequestedIn,
    IClusCfgIPAddressInfo **    rgpIPAddressInfoOut,
    ULONG *                     pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT                 hr = S_FALSE;
    ULONG                   cFetched = 0;
    ULONG                   idx;
    IClusCfgIPAddressInfo * pccipai;

    if ( rgpIPAddressInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_IPAddresses, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    cFetched = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( idx = 0; idx < cFetched; idx++, m_idxEnumNext++ )
    {
        hr = THR( ((*m_prgAddresses)[ m_idxEnumNext ])->TypeSafeQI( IClusCfgIPAddressInfo, &pccipai ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        rgpIPAddressInfoOut[ idx ] = pccipai;
    } // for:

    if ( FAILED( hr ) )
    {
        ULONG   idxStop = idx;

        m_idxEnumNext -= idx;

        for ( idx = 0; idx < idxStop; idx++ )
        {
            (rgpIPAddressInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;
        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr S_OK;

    m_idxEnumNext = 0;

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Clone(
    IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut
    )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgIPAddressesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_IPAddresses, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pnCountOut = m_cAddresses;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddress::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses class -- IClusCfgNetworkAdapterInfo Interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::SetWbemObject
//
//  Description:
//      Get the configuration from the passed in adapter and load this
//      enumerator.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgIPAddresses::SetWbemObject(
      IWbemClassObject *    pNetworkAdapterIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "[IClusCfgNetworkAdapterInfo]" );
    Assert( pfRetainObjectOut != NULL );

    HRESULT hr = E_INVALIDARG;

    if ( pNetworkAdapterIn != NULL )
    {
        hr = STHR( HrGetAdapterConfiguration( pNetworkAdapterIn ) );
        *pfRetainObjectOut = true;
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::SetWbemObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgIPAddresses class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrInit( ULONG ulIPAddressIn, ULONG ulIPSubnetIn )
{
    TraceFunc( "" );

    HRESULT     hr;
    IUnknown *  punk = NULL;

    hr = THR( HrCreateIPAddress( ulIPAddressIn, ulIPSubnetIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddIPAddressToArray( punk ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrGetAdapterConfiguration
//
//  Description:
//      Get the configuration of the passed in adapter.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrGetAdapterConfiguration(
    IWbemClassObject * pNetworkAdapterIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;
    VARIANT                 var;
    WCHAR                   sz[ 256 ];
    IEnumWbemClassObject *  pConfigurations = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pConfiguration = NULL;
    int                     cFound = 0;
    BSTR                    bstrAdapterName = NULL;
    int                     idx;

    VariantInit( &var );

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    _snwprintf( sz, ARRAYSIZE( sz ), L"Associators of {Win32_NetworkAdapter.DeviceID='%s'} where AssocClass=Win32_NetworkAdapterSetting", var.bstrVal );

    bstrQuery = TraceSysAllocString( sz );
    if ( bstrQuery == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"NetConnectionID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrAdapterName = TraceSysAllocString( var.bstrVal );
    if ( bstrAdapterName == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pConfigurations ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING(
                TASKID_Major_Find_Devices,
                TASKID_Minor_WMI_NetworkAdapterSetting_Qry_Failed,
                IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED,
                bstrAdapterName,
                hr
                );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        hr = pConfigurations->Next( WBEM_INFINITE, 1, &pConfiguration, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            //
            //  KB: 25-AUG-2000 GalenB
            //
            //  WMI only supports one configuration per adapter!
            //
            Assert( idx < 1 );

            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pConfiguration, L"IPEnabled", VT_BOOL, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If this configuration is not for TCP/IP then skip it.
            //
            if ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) )
            {
                hr = S_FALSE;
                STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Non_Tcp_Config, IDS_WARNING__NON_TCP_CONFIG, bstrAdapterName, hr );
                continue;
            } // if:

            hr = STHR( HrSaveIPAddresses( bstrAdapterName, pConfiguration ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  KB: 24-AUG-2000 GalenB
            //
            //  If any configuration returns S_FALSE then we skip.
            //
            if ( hr == S_FALSE )
            {
                pConfiguration->Release();
                pConfiguration = NULL;
                continue;
            } // if:

            cFound++;
            pConfiguration->Release();
            pConfiguration = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WQL_Qry_Next_Failed, IDS_ERROR_WQL_QRY_NEXT_FAILED, bstrQuery, hr );
            goto Cleanup;
        } // else:
    } // for:

    //
    //  If we didn't find any valid configurations then we should return S_FALSE
    //  to tell the caller to ingore that adpater.
    //
    if ( cFound == 0 )
    {
        hr = S_FALSE;
        STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_No_Valid_TCP_Configs, IDS_WARNING_NO_VALID_TCP_CONFIGS, bstrAdapterName, hr );
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetAdapterConfiguration, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );
    TraceSysFreeString( bstrAdapterName );

    if ( pConfiguration != NULL )
    {
        pConfiguration->Release();
    } // if:

    if ( pConfigurations != NULL )
    {
        pConfigurations->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrGetAdapterConfiguration


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses:HrAddIPAddressToArray
//
//  Description:
//      Add the passed in address to the array of address.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrAddIPAddressToArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgAddresses, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddIPAddressToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgAddresses = prgpunks;

    (*m_prgAddresses)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cAddresses += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrAddIPAddressToArray

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrMakeDottedQuad
//
//  Description:
//      Take the passed in IP address and convert it into a dotted quad.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      Internet Addresses
//      Values specified using the ".'' notation take one of the following forms:
//
//          a.b.c.d a.b.c a.b a
//
//      When four parts are specified, each is interpreted as a byte of data and
//      assigned, from left to right, to the 4 bytes of an Internet address. When
//      an Internet address is viewed as a 32-bit integer quantity on the
//      Intel architecture, the bytes referred to above appear as "d.c.b.a''.
//      That is, the bytes on an Intel processor are ordered from right to left.
//
//      The parts that make up an address in "." notation can be decimal, octal
//      or hexadecimal as specified in the C language. Numbers that start
//      with "0x" or "0X" imply hexadecimal. Numbers that start with "0" imply
//      octal. All other numbers are interpreted as decimal.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrMakeDottedQuad(
    BSTR    bstrDottedQuadIn,
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;

    if ( pulDottedQuadOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrMakeDottedQuad, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( bstrDottedQuadIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        LOG_STATUS_REPORT( L"CEnumClusCfgIPAddresses::HrMakeDottedQuad() was given an invalid argument.", hr );
        goto Cleanup;
    } // if:

    sc = TW32( ClRtlTcpipStringToAddress( bstrDottedQuadIn, pulDottedQuadOut ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Dotted_Quad_Failed, IDS_ERROR_CONVERT_TO_DOTTED_QUAD_FAILED, bstrDottedQuadIn, hr );
        goto Cleanup;
    } // if:

Cleanup:

    RETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrMakeDottedQuad


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses::HrSaveIPAddresses
//
//  Description:
//      Add the IP addresses to the array.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrSaveIPAddresses(
    BSTR                bstrAdapterNameIn,
    IWbemClassObject *  pConfigurationIn
    )
{
    TraceFunc( "" );
    Assert( bstrAdapterNameIn != NULL );
    Assert( pConfigurationIn != NULL );

    HRESULT                 hr;
    VARIANT                 varIPAddress;
    VARIANT                 varIPSubnet;
    long                    lIPAddressesUpperBound;
    long                    lIPAddressesLowerBound;
    long                    lIPSubnetsUpperBound;
    long                    lIPSubnetsLowerBound;
    long                    idx;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;
    BSTR                    bstrIPAddress = NULL;
    BSTR                    bstrIPSubnet = NULL;
    IUnknown *              punk = NULL;
    IClusCfgIPAddressInfo * piccipai = NULL;

    VariantInit( &varIPAddress );
    VariantInit( &varIPSubnet );

    hr = THR( HrGetWMIProperty( pConfigurationIn, L"IPAddress", ( VT_ARRAY | VT_BSTR ), &varIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pConfigurationIn, L"IPSubnet", ( VT_ARRAY | VT_BSTR ), &varIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SafeArrayGetUBound( varIPAddress.parray, 1, &lIPAddressesUpperBound ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SafeArrayGetUBound( varIPSubnet.parray, 1, &lIPSubnetsUpperBound ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    Assert( lIPAddressesUpperBound == lIPSubnetsUpperBound );
    if ( lIPAddressesUpperBound != lIPSubnetsUpperBound )
    {
        hr = S_FALSE;
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_IP_Address_Subnet_Count_Unequal, IDS_ERROR_IP_ADDRESS_SUBNET_COUNT_UNEQUAL, hr );
        goto Cleanup;
    } // if:

    hr = THR( SafeArrayGetLBound( varIPAddress.parray, 1, &lIPAddressesLowerBound ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( SafeArrayGetLBound( varIPSubnet.parray, 1, &lIPSubnetsLowerBound ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    Assert( lIPAddressesLowerBound == lIPSubnetsLowerBound );
    if ( lIPAddressesLowerBound != lIPSubnetsLowerBound )
    {
        hr = S_FALSE;
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_IP_Address_Subnet_Count_Unequal, IDS_ERROR_IP_ADDRESS_SUBNET_COUNT_UNEQUAL, hr );
        goto Cleanup;
    } // if:

    for ( idx = lIPAddressesLowerBound; idx <= lIPAddressesUpperBound; idx++ )
    {
        hr = THR( SafeArrayGetElement( varIPAddress.parray, &idx, &bstrIPAddress ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceMemoryAddBSTR( bstrIPAddress );

        if ( wcscmp( bstrIPAddress, L"" ) == 0 )
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Warning_No_IP_Addresses, IDS_WARNING_NO_IP_ADDRESSES, bstrAdapterNameIn, hr );
            goto Cleanup;
        } // end if:

        hr = THR( SafeArrayGetElement( varIPSubnet.parray, &idx, &bstrIPSubnet ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        Assert( bstrIPAddress != NULL );
        Assert( wcslen( bstrIPAddress ) > 0 );

        TraceMemoryAddBSTR( bstrIPSubnet );

        LOG_STATUS_REPORT_STRING2( L"Found IP Address '%1!ws!' with subnet mask '%2!ws!'." , bstrIPAddress, bstrIPSubnet, hr );

        hr = THR( HrMakeDottedQuad( bstrIPAddress, &ulIPAddress ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrMakeDottedQuad( bstrIPSubnet, &ulIPSubnet ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceSysFreeString( bstrIPAddress );
        bstrIPAddress = NULL;

        TraceSysFreeString( bstrIPSubnet );
        bstrIPSubnet  = NULL;

        hr = THR( HrCreateIPAddress( &punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( punk->TypeSafeQI( IClusCfgIPAddressInfo, &piccipai ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( piccipai->SetIPAddress( ulIPAddress ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( piccipai->SetSubnetMask( ulIPSubnet ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        piccipai->Release();
        piccipai = NULL;

        hr = THR( HrAddIPAddressToArray( punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        punk->Release();
        punk = NULL;
    } // for:

Cleanup:

    if ( piccipai != NULL )
    {
        piccipai->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrIPAddress );
    TraceSysFreeString( bstrIPSubnet );

    VariantClear( &varIPAddress );
    VariantClear( &varIPSubnet );

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrSaveIPAddresses


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses:HrCreateIPAddress
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrCreateIPAddress( IUnknown ** ppunkOut )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;

    hr = THR( CClusCfgIPAddressInfo::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CClusCfgIPAddressInfo", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *ppunkOut = punk;
    (*ppunkOut)->AddRef();

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrCreateIPAddress


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgIPAddresses:HrCreateIPAddress
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgIPAddresses::HrCreateIPAddress(
      ULONG         ulIPAddressIn
    , ULONG         ulIPSubnetIn
    , IUnknown **   ppunkOut
    )
{
    TraceFunc( "" );
    Assert( ppunkOut != NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;

    hr = THR( CClusCfgIPAddressInfo::S_HrCreateInstance( ulIPAddressIn, ulIPSubnetIn, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CClusCfgIPAddressInfo", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    *ppunkOut = punk;
    (*ppunkOut)->AddRef();

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrCreateIPAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cclusterutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusterUtils.cpp
//
//  Description:
//      This file contains the definition of the CClusterUtils
//       class.
//
//  Documentation:
//
//  Header File:
//      CClusterUtils.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CClusterUtils" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterUtils class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils::CClusterUtils()
//
//  Description:
//      Constructor of the CClusterUtils class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterUtils::CClusterUtils( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CClusterUtils::CClusterUtils


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils::~CClusterUtils()
//
//  Description:
//      Desstructor of the CClusterUtils class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterUtils::~CClusterUtils( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CClusterUtils::~CClusterUtils


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils::HrIsGroupOwnedByThisNode()
//
//  Description:
//      Is the passed in group owned by the passes in node name?
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The group is owned by the node.
//
//      S_FALSE
//          The group is not owned by the node.
//
//      Win32 Error
//          An error occurred.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrIsGroupOwnedByThisNode(
    HGROUP  hGroupIn,
    BSTR    bstrNodeNameIn
    )
{
    TraceFunc1( "bstrNodeNameIn = '%ls'", bstrNodeNameIn == NULL ? L"<null>" : bstrNodeNameIn );
    Assert( bstrNodeNameIn != NULL );

    HRESULT             hr;
    DWORD               sc;
    WCHAR *             pszNodeName = NULL;
    DWORD               cchNodeName = 33;
    CLUSTER_GROUP_STATE cgs;
    int                 idx;

    pszNodeName = new WCHAR[ cchNodeName ];
    if ( pszNodeName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        Assert( idx < 2 );

        cgs = GetClusterGroupState( hGroupIn, pszNodeName, &cchNodeName );
        sc = GetLastError();
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszNodeName;
            pszNodeName = NULL;
            cchNodeName++;

            pszNodeName = new WCHAR[ cchNodeName ];
            if ( pszNodeName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            continue;
        } // if:

        if ( cgs == ClusterGroupStateUnknown )
        {
            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if:

        if ( _wcsicmp( bstrNodeNameIn, pszNodeName ) == 0 )
        {
            hr = S_OK;
        } // if:
        else
        {
            hr = S_FALSE;
        } // else:

        break;
    } // for:

Cleanup:

    delete [] pszNodeName;

    HRETURN( hr );

} //*** CClusterUtils::HrIsGroupOwnedByThisNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils:HrIsNodeClustered
//
//  Description:
//      Is this node a member of a cluster?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The node is clustered.
//
//      S_FALSE
//          The node is not clustered.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrIsNodeClustered( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwClusterState;

    sc = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        goto Cleanup;
    } // if : GetClusterState() failed

    if ( ( dwClusterState == ClusterStateRunning ) || ( dwClusterState == ClusterStateNotRunning ) )
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CClusterUtils::HrIsNodeClustered()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils:HrEnumNodeResources
//
//  Description:
//      Enumerate the resources owned by this node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrEnumNodeResources( BSTR bstrNodeNameIn )
{
    TraceFunc1( "bstrNodeNameIn = '%ls'", bstrNodeNameIn == NULL ? L"<null>" : bstrNodeNameIn );

    HRESULT     hr = S_FALSE;
    DWORD       sc;
    DWORD       idx;
    HCLUSTER    hCluster = NULL;
    HCLUSENUM   hEnum = NULL;
    DWORD       dwType;
    WCHAR *     pszGroupName = NULL;
    DWORD       cchGroupName = 33;
    HGROUP      hGroup = NULL;

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( hr );
        goto Cleanup;
    } // if:

    hEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_GROUP );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( hr );
        goto Cleanup;
    } // if:

    pszGroupName = new WCHAR[ cchGroupName ];
    if ( pszGroupName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterEnum( hEnum, idx, &dwType, pszGroupName, &cchGroupName );
        if ( sc == ERROR_SUCCESS )
        {
            hGroup = OpenClusterGroup( hCluster, pszGroupName );
            if ( hGroup == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // if:

            hr = STHR( HrIsGroupOwnedByThisNode( hGroup, bstrNodeNameIn ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                hr = THR( HrLoadGroupResources( hCluster, hGroup ) );
            } // if:

            CloseClusterGroup( hGroup );
            hGroup = NULL;

            idx++;
            continue;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszGroupName;
            pszGroupName = NULL;
            cchGroupName++;

            pszGroupName = new WCHAR[ cchGroupName ];
            if ( pszGroupName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            hr = S_OK;
            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        break;
    } // for:

Cleanup:

    if ( hGroup != NULL )
    {
        CloseClusterGroup( hGroup );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    delete [] pszGroupName;

    HRETURN( hr );

} //*** CClusterUtils::HrEnumNodeResources()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils::HrLoadGroupResources()
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrLoadGroupResources(
    HCLUSTER    hClusterIn,
    HGROUP      hGroupIn
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HGROUPENUM  hEnum = NULL;
    WCHAR *     pszResourceName = NULL;
    DWORD       cchResourceName = 33;
    DWORD       dwType;
    DWORD       idx;
    HRESOURCE   hResource = NULL;

    hEnum = ClusterGroupOpenEnum( hGroupIn, CLUSTER_GROUP_ENUM_CONTAINS );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    pszResourceName = new WCHAR[ cchResourceName ];
    if ( pszResourceName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterGroupEnum( hEnum, idx, &dwType, pszResourceName, &cchResourceName );
        if ( sc == ERROR_SUCCESS )
        {
            hResource = OpenClusterResource( hClusterIn, pszResourceName );
            if ( hResource == NULL )
            {
                sc = TW32( GetLastError() );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            } // if:

            hr = STHR( HrNodeResourceCallback( hClusterIn, hResource ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            CloseClusterResource( hResource );
            hResource = NULL;

            idx++;
            continue;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszResourceName;
            pszResourceName = NULL;
            cchResourceName++;

            pszResourceName = new WCHAR[ cchResourceName ];
            if ( pszResourceName == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            hr = S_OK;
            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        break;
    } // for:

Cleanup:

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterGroupCloseEnum( hEnum );
    } // if:

    delete [] pszResourceName;

    HRETURN( hr );

} //*** CClusterUtils::HrLoadGroupResources()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterUtils:HrGetQuorumResourceName()
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterUtils::HrGetQuorumResourceName(
    BSTR * pbstrQuorumResourceNameOut
    )
{
    TraceFunc( "" );
    Assert( pbstrQuorumResourceNameOut != NULL );

    HRESULT     hr = S_OK;
    HCLUSTER    hCluster = NULL;
    DWORD       sc;
    WCHAR *     pszResourceName = NULL;
    DWORD       cchResourceName = 33;
    WCHAR *     pszDeviceName = NULL;
    DWORD       cchDeviceName = 33;
    DWORD       cbQuorumLog;
    int         idx;

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    pszResourceName = new WCHAR[ cchResourceName ];
    if ( pszResourceName == NULL )
    {
        goto OutOfMemory;
    } // if:

    pszDeviceName = new WCHAR[ cchDeviceName ];
    if ( pszDeviceName == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        Assert( idx < 2 );

        sc = GetClusterQuorumResource( hCluster, pszResourceName, &cchResourceName, pszDeviceName, &cchDeviceName, &cbQuorumLog );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] pszResourceName;
            pszResourceName = NULL;
            cchResourceName++;

            delete [] pszDeviceName;
            pszDeviceName = NULL;
            cchDeviceName++;

            pszResourceName = new WCHAR[ cchResourceName ];
            if ( pszResourceName == NULL )
            {
                goto OutOfMemory;
            } // if:

            pszDeviceName = new WCHAR[ cchDeviceName ];
            if ( pszDeviceName == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            *pbstrQuorumResourceNameOut = TraceSysAllocString( pszResourceName );
            if ( *pbstrQuorumResourceNameOut == NULL )
            {
                goto OutOfMemory;
            } // if:

            break;
        } // if:

        TW32( sc );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // for:

    hr = S_OK;
    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    delete [] pszResourceName;
    delete [] pszDeviceName;

    HRETURN( hr );

} //*** CClusterUtils::HrGetQuorumResourceName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgmanagedresources.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgManagedResources.cpp
//
//  Description:
//      This file contains the definition of the CEnumClusCfgManagedResources
//       class.
//
//      The class CEnumClusCfgManagedResources is the enumeration of cluster
//      managed devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Header File:
//      CEnumClusCfgManagedResources.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CEnumClusCfgManagedResources.h"
#include "CEnumUnknownQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumClusCfgManagedResources" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusCfgManagedResources instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusCfgManagedResources instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                         hr;
    CEnumClusCfgManagedResources *  pccsd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccsd = new CEnumClusCfgManagedResources();
    if ( pccsd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccsd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccsd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusCfgManagedResources::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccsd != NULL )
    {
        pccsd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::CEnumClusCfgManagedResources
//
//  Description:
//      Constructor of the CEnumClusCfgManagedResources class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgManagedResources::CEnumClusCfgManagedResources( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    Assert( m_idxNextProvider == 0 );
    Assert( m_idxCurrentProvider == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_rgpProviders == NULL );
    Assert( m_cTotalResources == 0);
    Assert( !m_fLoadedDevices );
    Assert( m_bstrNodeName == NULL );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgManagedResources::CEnumClusCfgManagedResources


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::~CEnumClusCfgManagedResources
//
//  Description:
//      Desstructor of the CEnumClusCfgManagedResources class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgManagedResources::~CEnumClusCfgManagedResources( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNextProvider; idx++ )
    {
        ((*m_rgpProviders)[ idx ])->Release();
    } // for:

    TraceFree( m_rgpProviders );

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgManagedResources::~CEnumClusCfgManagedResources


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumClusCfgManagedResources:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgManagedResources::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CEnumClusCfgManagedResources::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumClusCfgManagedResources:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgManagedResources::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CEnumClusCfgManagedResources::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IEnumClusCfgManagedResources * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgManagedResources ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:

    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CEnumClusCfgManagedResources::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Enum_Resources, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr;
    ULONG   cFetched = 0;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_Resources, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedDevices )
    {
        hr = THR( HrLoadEnum() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    hr = STHR( HrDoNext( cNumberRequestedIn, rgpManagedResourceInfoOut, &cFetched ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_FALSE;

    if ( cNumberToSkipIn > 0 )
    {
        hr = STHR( HrDoSkip( cNumberToSkipIn ) );
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr;

    hr = THR( HrDoReset() );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgManagedResourcesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgManagedResourcesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_Resources, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // else:

    hr = THR( HrDoClone( ppEnumClusCfgManagedResourcesOut ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgManagedResources::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedDevices )
    {
        hr = THR( HrLoadEnum() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    *pnCountOut = m_cTotalResources;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgManagedResources class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName ) );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrLoadEnum
//
//  Description:
//      Load this enumerator.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrLoadEnum( void )
{
    TraceFunc( "" );

    HRESULT                         hr;
    IUnknown *                      punk = NULL;
    ICatInformation *               pici = NULL;
    CATID                           rgCatIds[ 1 ];
    IEnumCLSID *                    pieclsids = NULL;
    IEnumClusCfgManagedResources *  pieccmr = NULL;
    CLSID                           clsid;
    ULONG                           cFetched;

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    hr = THR( CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICatInformation, (void **) &pici ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pici->EnumClassesOfCategories( 1, rgCatIds, 0, NULL, &pieclsids ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = STHR( pieclsids->Next( 1, &clsid, &cFetched ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
        {
            hr = S_OK;
            break;
        } // if:

        hr = THR( HrCoCreateInternalInstance( clsid, NULL, CLSCTX_SERVER, IID_IEnumClusCfgManagedResources, (void **) &pieccmr ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        hr = THR( pieccmr->TypeSafeQI( IUnknown, &punk ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        punk = TraceInterface( L"IEnumClusCfgManagedResources", IUnknown, punk, 1 );

        pieccmr->Release();
        pieccmr = NULL;

        hr = STHR( HrInitializeAndSaveProvider( punk ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            m_fLoadedDevices = TRUE;    // there is at least one provider loaded.
        } // if:

        punk->Release();
        punk = NULL;
    } // for:

    hr = STHR( HrLoadUnknownQuorumProvider() );

Cleanup:

    if ( pieclsids != NULL )
    {
        pieclsids->Release();
    } // if:

    if ( pici != NULL )
    {
        pici->Release();
    } // if:

    if ( pieccmr != NULL )
    {
        pieccmr->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrLoadEnum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrDoNext
//
//  Description:
//      Gets the required number of elements from the contained physical disk
//      and optional 3rd party device enumerations.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrDoNext(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_FALSE;
    IEnumClusCfgManagedResources *  peccsd = NULL;
    ULONG                           cRequested = cNumberRequestedIn;
    ULONG                           cFetched;
    ULONG                           cTotal = 0;
    IClusCfgManagedResourceInfo **  ppccmriTemp = rgpManagedResourceInfoOut;

    while ( m_idxCurrentProvider < m_idxNextProvider )
    {
        hr = THR( ((*m_rgpProviders)[ m_idxCurrentProvider ])->TypeSafeQI( IEnumClusCfgManagedResources, &peccsd ) );
        if ( FAILED( hr ) )
        {
            //
            //  KB: 06 Apr 2000 GalenB
            //
            //  This failure and the one below are a little trickery in action.  If something
            //  fails and we have already retrieved some elements from one, or more, of the enums
            //  it makes sense to change the failure to S_FALSE and return what we have.
            //  This makes cleanup easier since we don't have to reset the enums that have
            //  already given us some elements.  Then, if we're called again we should get
            //  the same failure, with no retrieved elements and can simply return the
            //  failure.
            //
            if ( cTotal > 0 )
            {
                hr = STHR( S_FALSE );
            } // if:

            goto Cleanup;
        } // if:

        hr = STHR( peccsd->Next( cRequested, ppccmriTemp, &cFetched ) );

        //
        //  KB: 06 Apr 2000 GalenB
        //
        //  Release the enum now to make things much easier.  It is true that we will most
        //  likely QI twice for each enum, but the effort to optimize this just doesn't
        //  seem worth it.
        //
        peccsd->Release();
        peccsd = NULL;

        if ( FAILED( hr ) )
        {
            if ( cTotal > 0 )
            {
                hr = STHR( S_FALSE );
            } // if: See KB above...

            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            cTotal += cFetched;

            //
            // KB:  06 Apr 2000 GalenB
            //
            //  We can only return S_OK if the number of elements returned is equal to
            //  the number of elements requested.  If the number request is greater than
            //  the number returned then we must return S_FALSE.
            //
            Assert( cNumberRequestedIn == cTotal );
            *pcNumberFetchedOut = cTotal;
            break;
        } // if:

        if ( hr == S_FALSE )
        {
            //
            // KB:  06 Apr 2000 GalenB
            //
            //  The only time that we can be certain that an enumerator is empty is to get S_FALSE
            //  and no elements returned.
            //
            if ( cFetched == 0 )
            {
                m_idxCurrentProvider++;
                continue;
            } // if:

            cTotal += cFetched;
            *pcNumberFetchedOut = cTotal;
            cRequested -= cFetched;
            if ( cRequested > 0 )
            {
                ppccmriTemp += cFetched;
                continue;
            } // if: Safety check...  Ensure that we still need more elements...
            else
            {
                hr = S_FALSE;
                LOG_STATUS_REPORT1( TASKID_Minor_MREnum_Negative_Item_Count, L"The managed resources enumerator tried to return more items than asked for.", hr );
                goto Cleanup;
            } // else: Should not get here...
        } // if:

        // should not get here...
        hr = S_FALSE;
        LOG_STATUS_REPORT1( TASKID_Minor_MREnum_Unknown_State, L"The mana b bged resources enumerator encountered an unknown state.", hr );
        goto Cleanup;
    } // while: more providers

Cleanup:

    if ( peccsd != NULL )
    {
        peccsd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrDoNext


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrDoSkip
//
//  Description:
//      Skips the required number of elements in the contained physical disk
//      and optional 3rd party device enumerations.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrDoSkip( ULONG cNumberToSkipIn )
{
    TraceFunc( "" );

    HRESULT                         hr = S_FALSE;
    IEnumClusCfgManagedResources *  peccsd = NULL;
    ULONG                           cSkipped = 0;

    for ( ; m_idxCurrentProvider < m_idxNextProvider; )
    {
        hr = THR( ((*m_rgpProviders)[ m_idxCurrentProvider ])->TypeSafeQI( IEnumClusCfgManagedResources, &peccsd ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        do
        {
            hr = STHR( peccsd->Skip( 1 ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_FALSE )
            {
                m_idxCurrentProvider++;
                break;
            } // if:
        }
        while( cNumberToSkipIn >= (++cSkipped) );

        peccsd->Release();
        peccsd = NULL;

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( cNumberToSkipIn == cSkipped )
        {
            break;
        } // if:
    } // for:

Cleanup:

    if ( peccsd != NULL )
    {
        peccsd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrDoSkip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrDoReset
//
//  Description:
//      Resets the elements in the contained physical disk and optional 3rd
//      party device enumerations.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrDoReset( void )
{
    TraceFunc( "" );

    HRESULT                         hr = S_FALSE;
    IEnumClusCfgManagedResources *  peccsd;
    ULONG                           idx;

    m_idxCurrentProvider = 0;

    for ( idx = m_idxCurrentProvider; idx < m_idxNextProvider; idx++ )
    {
        hr = THR( ((*m_rgpProviders)[ idx ])->TypeSafeQI( IEnumClusCfgManagedResources, &peccsd ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        hr = STHR( peccsd->Reset() );
        peccsd->Release();

        if ( FAILED( hr ) )
        {
            break;
        } // if:
    } // for:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrDoReset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources::HrDoClone
//
//  Description:
//      Clones the elements in the contained physical disk and optional 3rd
//      party device enumerations.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrDoClone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgManagedResourcesOut
    )
{
    TraceFunc( "" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrDoClone


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrAddToProvidersArray
//
//  Description:
//      Add the passed in punk to the array of punks that holds the enums.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrAddToProvidersArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    IUnknown *                      ((*rgpunks)[]) = NULL;
    IEnumClusCfgManagedResources *  pieccmr = NULL;
    DWORD                           nAmountToAdd = 0;

    hr = punkIn->TypeSafeQI( IEnumClusCfgManagedResources, &pieccmr );
    if ( FAILED (hr) )
    {
        goto Cleanup;
    } // if:

    hr = pieccmr->Count( &nAmountToAdd );
    if ( FAILED (hr) )
    {
        goto Cleanup;
    } // if:

    rgpunks = (IUnknown *((*)[])) TraceReAlloc( m_rgpProviders, sizeof( IUnknown * ) * ( m_idxNextProvider + 1 ), HEAP_ZERO_MEMORY );
    if ( rgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddToProvidersArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_rgpProviders = rgpunks;

    (*m_rgpProviders)[ m_idxNextProvider++ ] = punkIn;
    punkIn->AddRef();

    m_cTotalResources += nAmountToAdd;

Cleanup:

    if ( pieccmr != NULL )
    {
        pieccmr->Release();
    }

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrAddToProvidersArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrLoadUnknownQuorumProvider
//
//  Description:
//      Since we cannot resonable expect every 3rd party quorum vender
//      to write a "provider" for their device for this setup wizard
//      we need a proxy to represent that quorum device.  The "unknown"
//      is just such a proxy.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      If this node is clustered and we do not find a device that is
//      already the quorum then we need to make the "unknown" quorum
//      the quorum device.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrLoadUnknownQuorumProvider( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk = NULL;
    BOOL        fNeedQuorum = FALSE;
    BOOL        fQuormIsOwnedByThisNode = FALSE;
    BSTR        bstrQuorumResourceName = NULL;

    hr = STHR( HrIsClusterServiceRunning() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( HrIsThereAQuorumDevice() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_FALSE )
        {
            fNeedQuorum = TRUE;
        } // if:

        hr = THR( HrGetQuorumResourceName( &bstrQuorumResourceName, &fQuormIsOwnedByThisNode ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    //
    //  If there was not already a quorum, and if this node owns the quorum resource
    //  then we need the unknown quorum proxy to be set as default to the quorum device.
    //
    //  If we are not running on a cluster node then both are false and the unknown
    //  quorum proxy will not be set by default to be the quorum.
    //
    hr = THR( CEnumUnknownQuorum::S_HrCreateInstance( bstrQuorumResourceName, ( fNeedQuorum && fQuormIsOwnedByThisNode ), &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrInitializeAndSaveProvider( punk ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    TraceSysFreeString( bstrQuorumResourceName );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrLoadUnknownQuorumProvider


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrIsClusterServiceRunning
//
//  Description:
//      Is this node a member of a cluster and is the serice running?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The node is clustered and the serivce is running.
//
//      S_FALSE
//          The node is not clustered, or the serivce is not running.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrIsClusterServiceRunning( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    DWORD   dwClusterState;

    sc = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        goto Cleanup;
    } // if : GetClusterState() failed

    if ( dwClusterState == ClusterStateRunning )
    {
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgMana9gedResources::HrIsClusterServiceRunning


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrIsThereAQuorumDevice
//
//  Description:
//      Is there a quorum device in an enum somewhere?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          There is a quorum device.
//
//      S_FALSE
//          There is not a quorum device.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrIsThereAQuorumDevice( void )
{
    TraceFunc( "" );
    Assert( m_idxCurrentProvider == 0 );

    HRESULT                         hr = S_OK;
    IClusCfgManagedResourceInfo *   piccmri = NULL;
    DWORD                           cFetched;
    bool                            fFoundQuorum = false;

    for ( ; ; )
    {
        hr = STHR( Next( 1, &piccmri, &cFetched ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( ( hr == S_FALSE ) && ( cFetched == 0 ) )
        {
            hr = S_OK;
            break;
        } // if:

        hr = THR( piccmri->IsQuorumDevice() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            fFoundQuorum = true;
            break;
        } // if:

        piccmri->Release();
        piccmri = NULL;
    } // for:

    hr = THR( Reset() );

Cleanup:

    if ( piccmri != NULL )
    {
        piccmri->Release();
    } // if:

    if ( SUCCEEDED( hr ) )
    {
        if ( fFoundQuorum )
        {
            hr = S_OK;
        } // if:
        else
        {
            hr = S_FALSE;
        } // else:
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrIsThereAQuorumDevice


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrInitializeAndSaveProvider
//
//  Description:
//      Initialize the passed in enum and add it to the array of enums.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success.
//
//      S_FALSE
//          The provider was not saved.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrInitializeAndSaveProvider( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    //  KB: 13-JUN-2000 GalenB
    //
    //  If S_FALSE is returned don't add this to the array.  S_FALSE
    //  indicates that this enumerator should not be run now.
    //
    hr = STHR( HrSetInitialize( punkIn, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = HrSetWbemServices( punkIn, m_pIWbemServices );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddToProvidersArray( punkIn ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrInitializeAndSaveProvider


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgManagedResources:HrGetQuorumResourceName
//
//  Description:
//      Get the quorum resource name and return whether or not this node
//      owns the quorum.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgManagedResources::HrGetQuorumResourceName(
      BSTR *  pbstrQuorumResourceNameOut
    , BOOL * pfQuormIsOwnedByThisNodeOut
    )
{
    TraceFunc( "" );
    Assert( pbstrQuorumResourceNameOut != NULL );
    Assert( pfQuormIsOwnedByThisNodeOut != NULL );

    HRESULT     hr = S_OK;
    DWORD       sc;
    HCLUSTER    hCluster = NULL;
    BSTR        bstrQuorumResourceName = NULL;
    BSTR        bstrNodeName = NULL;
    HRESOURCE   hQuorumResource = NULL;

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( HrGetClusterQuorumResource( hCluster, &bstrQuorumResourceName, NULL, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hQuorumResource = OpenClusterResource( hCluster, bstrQuorumResourceName );
    if ( hQuorumResource == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    hr = THR( HrGetClusterResourceState( hQuorumResource, &bstrNodeName, NULL, NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Give ownership away.
    //
    Assert( bstrQuorumResourceName != NULL );
    *pbstrQuorumResourceNameOut = bstrQuorumResourceName;
    bstrQuorumResourceName = NULL;

    *pfQuormIsOwnedByThisNodeOut = ( _wcsicmp( m_bstrNodeName, bstrNodeName ) == 0 );

Cleanup:

    if ( hQuorumResource != NULL )
    {
        CloseClusterResource( hQuorumResource );
    } // if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    TraceSysFreeString( bstrQuorumResourceName );
    TraceSysFreeString( bstrNodeName );

    HRETURN( hr );

} //*** CEnumClusCfgManagedResources::HrGetQuorumResourceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cclusterutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusterUtils.h
//
//  Description:
//      This file contains the declaration of the CClusterUtils class.
//
//  Documentation:
//
//  Implementation Files:
//      CClusterUtils.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterUtils
//
//  Description:
//      The class CClusterUtils are cluster utilities.
//
//  Interfaces:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterUtils
{
private:

    //
    // Private member functions and data
    //

    // Private copy constructor to prevent copying.
    CClusterUtils( const CClusterUtils & nodeSrc );

    // Private assignment operator to prevent copying.
    const CClusterUtils & operator = ( const CClusterUtils & nodeSrc );

protected:

    // constructors and destructors
    CClusterUtils( void );
    ~CClusterUtils( void );

public:

    HRESULT HrIsGroupOwnedByThisNode( HGROUP hGroupIn, BSTR bstrNodeNameIn );
    HRESULT HrIsNodeClustered( void );
    HRESULT HrEnumNodeResources( BSTR bstrNodeNameIn );
    HRESULT HrLoadGroupResources( HCLUSTER hClusterIn, HGROUP hGroupIn );
    HRESULT HrGetQuorumResourceName( BSTR * pbstrQuorumResourceNameOut );

    virtual HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn ) = 0;

}; //*** Class CClusterUtils
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgipaddresses.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgIPAddresses.h
//
//  Description:
//      This file contains the declaration of the CEnumClusCfgIPAddresses
//      class.
//
//      The class CEnumClusCfgIPAddresses is the enumeration of IP
//      addresses. It implements the CEnumClusCfgIPAddresses
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumClusCfgIPAddresses.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumClusCfgIPAddresses
//
//  Description:
//      The class CEnumClusCfgIPAddresses is the enumeration of
//      IP addresses.
//
//  Interfaces:
//      CEnumClusCfgIPAddresses
//      IClusCfgWbemServices
//      IClusCfgInitialize
//      IClusCfgNetworkAdapterInfo
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumClusCfgIPAddresses
    : public IEnumClusCfgIPAddresses
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
    , public IClusCfgSetWbemObject
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    ULONG               m_idxEnumNext;
    IUnknown *          ((*m_prgAddresses)[]);
    ULONG               m_idxNext;
    DWORD               m_cAddresses;

    // Private constructors and destructors
    CEnumClusCfgIPAddresses( void );
    ~CEnumClusCfgIPAddresses( void );

    // Private copy constructor to prevent copying.
    CEnumClusCfgIPAddresses( const CEnumClusCfgIPAddresses & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumClusCfgIPAddresses & operator = ( const CEnumClusCfgIPAddresses & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrInit( ULONG ulIPAddressIn, ULONG IPSubnetIn );
    HRESULT HrGetAdapterConfiguration(  IWbemClassObject * pNetworkAdapterIn );
    HRESULT HrSaveIPAddresses( BSTR bstrAdapterNameIn, IWbemClassObject * pConfigurationIn );
    HRESULT HrAddIPAddressToArray( IUnknown * punkIn );
    HRESULT HrCreateIPAddress( IUnknown ** ppunkOut );
    HRESULT HrCreateIPAddress( ULONG ulIPAddressIn, ULONG ulIPSubnetIn, IUnknown ** ppunkOut );
    HRESULT HrMakeDottedQuad( BSTR bstrDottedQuadIn, ULONG * pulDottedQuadOut );
    HRESULT HrSaveAddressInfo( BSTR bstrAdapterNameIn, SAFEARRAY * pIPAddresses, SAFEARRAY * pIPSubnets );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance(
                ULONG           ulIPAddressIn
              , ULONG           IPSubnetIn
              , IUnknown *      punkCallbackIn
              , LCID            lcidIn
              , IWbemServices * pIWbemServicesIn
              , IUnknown **     ppunkOut
              );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgIPAddresses Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgIPAddressInfo ** rgpIPAddressInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppEnumClusCfgIPAddressesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // IClusCfgSetWbemObject Interfaces
    //

    STDMETHOD( SetWbemObject )( IWbemClassObject * pNetworkAdapterIn, bool * pfRetainObjectOut );

}; //*** Class CEnumClusCfgIPAddresses
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgmanagedresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgManagedResources.h
//
//  Description:
//      This file contains the declaration of the CEnumClusCfgManagedResources
//      class.
//
//      The class CEnumClusCfgManagedResources is the enumeration of cluster
//      managed devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumClusCfgManagedResources.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumClusCfgManagedResources
//
//  Description:
//      The class CEnumClusCfgManagedResources is the enumeration of
//      cluster managed devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgWbemServices
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumClusCfgManagedResources
    : public IEnumClusCfgManagedResources
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    IUnknown *          ((*m_rgpProviders)[]);
    BOOL                m_fLoadedDevices:1;
    ULONG               m_idxNextProvider;
    ULONG               m_idxCurrentProvider;
    DWORD               m_cTotalResources;
    BSTR                m_bstrNodeName;

    // Private constructors and destructors
    CEnumClusCfgManagedResources( void );
    ~CEnumClusCfgManagedResources( void );

    // Private copy constructor to prevent copying.
    CEnumClusCfgManagedResources( const CEnumClusCfgManagedResources & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumClusCfgManagedResources & operator = ( const CEnumClusCfgManagedResources & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrLoadEnum( void );
    HRESULT HrDoNext( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );
    HRESULT HrAddToProvidersArray( IUnknown * punkIn );
    HRESULT HrDoSkip( ULONG cNumberToSkipIn );
    HRESULT HrDoReset( void );
    HRESULT HrDoClone(  IEnumClusCfgManagedResources ** ppEnumClusCfgManagedResourcesOut );
    HRESULT HrLoadUnknownQuorumProvider( void );
    HRESULT HrIsClusterServiceRunning( void );
    HRESULT HrIsThereAQuorumDevice( void );
    HRESULT HrInitializeAndSaveProvider( IUnknown * punkIn );
    HRESULT HrGetQuorumResourceName( BSTR * pbstrQuorumResourceNameOut , BOOL * pfQuormIsOwnedByThisNodeOut );


public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgManagedResourcesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

}; //*** Class CEnumClusCfgManagedResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgnetworks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgNetworks.cpp
//
//  Description:
//      This file contains the definition of the CEnumClusCfgNetworks
//       class.
//
//      The class CEnumClusCfgNetworks is the enumeration of cluster
//      networks. It implements the IEnumClusCfgNetworks interface.
//
//  Documentation:
//
//  Header File:
//      CEnumClusCfgNetworks.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include <PropList.h>
#include "CEnumClusCfgNetworks.h"
#include "CClusCfgNetworkInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumClusCfgNetworks" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::S_HrCreateInstance
//
//  Description:
//      Create a CEnumClusCfgNetworks instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusCfgNetworks instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CEnumClusCfgNetworks *  lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CEnumClusCfgNetworks();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusCfgNetworks::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::CEnumClusCfgNetworks
//
//  Description:
//      Constructor of the CEnumClusCfgNetworks class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgNetworks::CEnumClusCfgNetworks( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fLoadedNetworks( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback ==  NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_prgNetworks == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( m_cNetworks == 0 );

    TraceFuncExit();

} //*** CEnumClusCfgNetworks::CEnumClusCfgNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::~CEnumClusCfgNetworks
//
//  Description:
//      Desstructor of the CEnumClusCfgNetworks class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusCfgNetworks::~CEnumClusCfgNetworks( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        ((*m_prgNetworks)[ idx ])->Release();
    } // for:

    TraceFree( m_prgNetworks );
    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusCfgNetworks::~CEnumClusCfgNetworks


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumClusCfgNetworks:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgNetworks::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN(  m_cRef );

} //*** CEnumClusCfgNetworks::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumClusCfgNetworks:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusCfgNetworks::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CEnumClusCfgNetworks::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IEnumClusCfgNetworks * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgNetworks ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgNetworks, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CEnumClusCfgNetworks::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Enum_Networks, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks -- IEnumClusCfgNetworks interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Next(
    ULONG                   cNumberRequestedIn,
    IClusCfgNetworkInfo **  rgpNetworkInfoOut,
    ULONG *                 pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT                 hr = S_FALSE;
    ULONG                   cFetched = 0;
    ULONG                   idx;
    IClusCfgNetworkInfo *   pccni;

    if ( rgpNetworkInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_Networks, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedNetworks )
    {
        hr = THR( HrGetNetworks() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    Assert( m_prgNetworks != NULL );
    Assert( m_idxNext > 0 );

    cFetched = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( idx = 0; idx < cFetched; idx++, m_idxEnumNext++ )
    {
        hr = THR( ((*m_prgNetworks)[ m_idxEnumNext ])->TypeSafeQI( IClusCfgNetworkInfo, &pccni ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if:

        rgpNetworkInfoOut[ idx ] = pccni;

    } // for:

    if ( FAILED( hr ) )
    {
        ULONG   idxStop = idx;

        m_idxEnumNext -= idx;

        for ( idx = 0; idx < idxStop; idx++ )
        {
            (rgpNetworkInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;

        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Failed, IDS_ERROR_NETWORK_ENUM, hr );

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Reset( void )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    m_idxEnumNext = 0;

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Clone(
    IEnumClusCfgNetworks ** ppEnumNetworksOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    if ( ppEnumNetworksOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_Networks, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusCfgNetworks::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedNetworks )
    {
        hr = THR( HrGetNetworks() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    *pnCountOut = m_cNetworks;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusCfgNetworks class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrInit


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::HrGetNetworks
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrGetNetworks( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;
    BSTR                    bstrAdapterQuery = NULL;
    IEnumWbemClassObject *  pNetworks = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pNetwork = NULL;
    IWbemClassObject *      pAdapterInfo = NULL;
    VARIANT                 varConnectionStatus;
    VARIANT                 varConnectionID;
    VARIANT                 varName;
    VARIANT                 varIndex;
    VARIANT                 varDHCPEnabled;
    DWORD                   sc;
    DWORD                   dwState;

    sc = TW32( GetNodeClusterState( NULL, &dwState ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwState == ClusterStateRunning )
    {
        hr = THR( HrLoadClusterNetworks() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    VariantInit( &varConnectionStatus );
    VariantInit( &varConnectionID );
    VariantInit( &varName );
    VariantInit( &varIndex );
    VariantInit( &varDHCPEnabled );

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        goto OutOfMemory;
    } // if:

    bstrQuery = TraceSysAllocString( L"Select * from Win32_NetworkAdapter where AdapterTypeID=0 or AdapterTypeID=1 or AdapterTypeID=5" );
    if ( bstrQuery == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pNetworks ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_WMI_NetworkAdapter_Qry_Failed, IDS_ERROR_WMI_NETWORKADAPTER_QRY_FAILED, hr );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = pNetworks->Next( WBEM_INFINITE, 1, &pNetwork, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            //
            //  Get the adapter name.  We will need this for checking for NLBS and in the warning for when
            //  we are skipping an adapter.
            //
            hr = THR( HrGetWMIProperty( pNetwork, L"Name", VT_BSTR, &varName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  Is this adapter the soft NLBS adapter?  If it is then skip it.
            //
            hr = STHR( HrIsNLBS( varName.bstrVal, pNetwork ) );
            if ( hr == S_OK )
            {
                continue;
            } // if:
            else if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // else if:

            //
            //  Get the NetConnectionID.  Only "real" hardware adapters will have this as a non-NULL property.
            //
            hr = HrGetWMIProperty( pNetwork, L"NetConnectionID", VT_BSTR, &varConnectionID );
            if ( ( hr == E_PROPTYPEMISMATCH ) && ( varConnectionID.vt == VT_NULL ) )
            {
                hr = S_FALSE;
                STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_HrGetNetworks_Skipped, IDS_WARNING_NETWORK_SKIPPED, varName.bstrVal, hr );

                continue;       // skip this adapter
            } // if:
            else if ( FAILED( hr ) )
            {
                THR( hr );
                goto Cleanup;
            } // else if:

            //
            //  Check the connection status of this adapter and skip it if it is not connected.
            //
            hr = THR( HrGetWMIProperty( pNetwork, L"NetConnectionStatus", VT_I4, &varConnectionStatus ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If the network adapter is not connected then skip it.
            //
            if ( varConnectionStatus.iVal != STATUS_CONNECTED )
            {
                hr = S_FALSE;
                STATUS_REPORT_STRING2(
                    TASKID_Major_Find_Devices,
                    TASKID_Minor_HrGetNetworks_NotConnected,
                    IDS_WARNING_NETWORK_NOT_CONNECTED,
                    varConnectionID.bstrVal,
                    varConnectionStatus.iVal,
                    hr
                    );

                pNetwork->Release();
                pNetwork = NULL;
                continue;
            } // if:

            //
            // Get the Index No. of this adapter
            //
            hr = THR( HrGetWMIProperty( pNetwork, L"Index", VT_I4, &varIndex ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            // Get the associated NetworkAdapterConfiguration WMI object. First, format the Query string
            //
            hr = HrFormatStringIntoBSTR(
                L"Win32_NetworkAdapterConfiguration.Index=%1!u!",
                &bstrAdapterQuery,
                varIndex.iVal
                );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            //
            // Then, get the Object
            //
            hr = THR( m_pIWbemServices->GetObject( 
                bstrAdapterQuery,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pAdapterInfo,
                NULL
                ) );
            if ( FAILED ( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceSysFreeString( bstrAdapterQuery );
            bstrAdapterQuery = NULL;

            //
            // Find out if this adapter is DHCP enabled. If it is, send out a warning.
            //
            hr = THR( HrGetWMIProperty( pAdapterInfo, L"DHCPEnabled", VT_BOOL, &varDHCPEnabled ) );
            if ( FAILED ( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( ( varDHCPEnabled.vt == VT_BOOL ) && ( varDHCPEnabled.boolVal == VARIANT_TRUE ) )
            {
                hr = S_FALSE;
                STATUS_REPORT_STRING(
                    TASKID_Major_Find_Devices,
                    TASKID_Minor_HrGetNetworks_DHCP_Enabled,
                    IDS_WARNING_DHCP_ENABLED,
                    varConnectionID.bstrVal,
                    hr
                    );
                if ( FAILED ( hr ) )
                {
                    goto Cleanup;
                }
            } // if:

            pAdapterInfo->Release();
            pAdapterInfo = NULL;

            hr = STHR( HrCreateAndAddNetworkToArray( pNetwork ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            pNetwork->Release();
            pNetwork = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WQL_Network_Qry_Next_Failed, IDS_ERROR_WQL_QRY_NEXT_FAILED, bstrQuery, hr );
            goto Cleanup;
        } // else:
    } // for:

    m_idxEnumNext = 0;
    m_fLoadedNetworks = TRUE;

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetNetworks, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &varConnectionStatus );
    VariantClear( &varConnectionID );
    VariantClear( &varName );
    VariantClear( &varIndex );
    VariantClear( &varDHCPEnabled );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );
    TraceSysFreeString( bstrAdapterQuery );

    if ( pNetwork != NULL )
    {
        pNetwork->Release();
    } // if:

    if ( pNetworks != NULL )
    {
        pNetworks->Release();
    } // if:

    if ( pAdapterInfo != NULL )
    {
        pAdapterInfo->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrGetNetworks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrAddNetworkToArray
//
//  Description:
//      Add the passed in Network to the array of punks that holds the Networks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrAddNetworkToArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgNetworks, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddNetworkToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgNetworks = prgpunks;

    (*m_prgNetworks)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cNetworks += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrAddNetworkToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::HrCreateAndAddNetworkToArray
//
//  Description:
//      Create a IClusCfgStorageDevice object and add the passed in Network to
//      the array of punks that holds the Networks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrCreateAndAddNetworkToArray(
    IWbemClassObject * pNetworkIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    IUnknown *              punk = NULL;
    IClusCfgSetWbemObject * piccswo = NULL;
    bool                    fRetainObject = true;

    hr = THR( CClusCfgNetworkInfo::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CClusCfgNetworkInfo", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ))
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgSetWbemObject, &piccswo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( piccswo->SetWbemObject( pNetworkIn, &fRetainObject ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( ( hr == S_OK ) && ( fRetainObject ) )
    {
        hr = STHR( HrIsThisNetworkUnique( punk, pNetworkIn ) );
        if ( hr == S_OK )
        {
            hr = THR( HrAddNetworkToArray( punk ) );
        } // if:
    } // if:

Cleanup:

    if ( piccswo != NULL )
    {
        piccswo->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrCreateAndAddNetworkToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrIsThisNetworkUnique
//
//  Description:
//      Does a network for this IP Address and subnet already exist?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          This network is a duplicate.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrIsThisNetworkUnique(
    IUnknown *          punkIn,
    IWbemClassObject *  pNetworkIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT                         hr = S_OK;
    ULONG                           idx;
    IClusCfgNetworkInfo *           piccni = NULL;
    IClusCfgNetworkInfo *           piccniSource = NULL;
    BSTR                            bstr = NULL;
    BSTR                            bstrSource = NULL;
    BSTR                            bstrAdapterName = NULL;
    BSTR                            bstrConnectionName = NULL;
    BSTR                            bstrMessage = NULL;
    VARIANT                         var;
    IClusCfgClusterNetworkInfo *    picccni = NULL;

    VariantInit( &var );

    hr = THR( punkIn->TypeSafeQI( IClusCfgNetworkInfo, &piccniSource ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccniSource->GetUID( &bstrSource ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    TraceMemoryAddBSTR( bstrSource );

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        hr = THR( ((*m_prgNetworks)[ idx ])->TypeSafeQI( IClusCfgNetworkInfo, &piccni ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( piccni->GetUID( &bstr ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        TraceMemoryAddBSTR( bstr );

        if ( wcscmp( bstr, bstrSource ) == 0 )
        {
            hr = THR( piccni->TypeSafeQI( IClusCfgClusterNetworkInfo, &picccni ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = STHR( picccni->HrIsClusterNetwork() );
            picccni->Release();
            picccni = NULL;

            //
            //  If the network in the enum was already a cluster network then we do not need
            //  to warn the user.
            //
            if ( hr == S_OK )
            {
                hr = S_FALSE;       // tell the caller that this is a duplicate network
            } // if:
            else if ( hr == S_FALSE )       // warn the user
            {
                HRESULT hrTemp;

                hr = THR( HrGetWMIProperty( pNetworkIn, L"Name", VT_BSTR, &var ) );
                if ( FAILED( hr ) )
                {
                    bstrAdapterName = NULL;
                } // if:
                else
                {
                    bstrAdapterName = TraceSysAllocString( var.bstrVal );
                } // else:

                VariantClear( &var );

                hr = THR( HrGetWMIProperty( pNetworkIn, L"NetConnectionID", VT_BSTR, &var ) );
                if ( FAILED( hr ) )
                {
                    bstrConnectionName = NULL;
                } // if:
                else
                {
                    bstrConnectionName = TraceSysAllocString( var.bstrVal );
                } // else:

                hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                                   IDS_ERROR_WMI_NETWORKADAPTER_DUPE_FOUND,
                                                   &bstrMessage,
                                                   bstrAdapterName != NULL ? bstrAdapterName : L"Unknown",
                                                   bstrConnectionName != NULL ? bstrConnectionName : L"Unknown"
                                                   ) );
                if ( FAILED( hr ) )
                {
                    bstrMessage = NULL;
                } // if:

                hr = S_FALSE;

                hrTemp = THR( HrSendStatusReport(
                                m_picccCallback,
                                TASKID_Major_Find_Devices,
                                TASKID_Minor_WMI_NetworkAdapter_Dupe_Found,
                                0,
                                1,
                                1,
                                hr,
                                bstrMessage != NULL ? bstrMessage : L"An adapter with a duplicate IP address and subnet was found."
                                ) );
                if ( FAILED( hrTemp ) )
                {
                    hr = hrTemp;
                    goto Cleanup;
                } // if:

            } // else if:

            break;
        } // if:

        piccni->Release();
        piccni = NULL;
    } // for:

Cleanup:

    if ( picccni != NULL )
    {
        picccni->Release();
    } // if:

    if ( piccniSource != NULL )
    {
        piccniSource->Release();
    } // if:

    if ( piccni != NULL )
    {
        piccni->Release();
    } // if:

    VariantClear( &var );

    TraceSysFreeString( bstrAdapterName );
    TraceSysFreeString( bstrConnectionName );
    TraceSysFreeString( bstrMessage );
    TraceSysFreeString( bstrSource );
    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrIsThisNetworkUnique


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrIsNLBS
//
//  Description:
//      Is the passed in adapter the NLBS soft adapter?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The adapter is the NLBS soft adapter.
//
//      S_FALSE
//          The adapter is not the NLBS soft adapter.
//
//      Other HRESULT errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrIsNLBS(
    BSTR                bstrNameIn,
    IWbemClassObject *  pNetworkIn
    )
{
    TraceFunc( "" );
    Assert( bstrNameIn != NULL );
    Assert( pNetworkIn != NULL );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    //
    //  For now doing a simple string compare on the names...
    //
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_NLBS_SOFT_ADAPTER_NAME, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( _wcsicmp( bstrNameIn, bstr ) == 0 )
    {
        hr = S_FALSE;
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Warning_NLBS_Detected, IDS_WARNING_NLBS_DETECTED, hr );
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

Cleanup:

    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrIsNLBS


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrLoadClusterNetworks
//
//  Description:
//      Load the cluster networks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrLoadClusterNetworks( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    HCLUSTER        hCluster = NULL;
    HCLUSENUM       hEnum = NULL;
    DWORD           sc;
    DWORD           idx;
    DWORD           cch = 33;
    WCHAR *         psz = NULL;
    DWORD           dwType;
    HNETWORK        hNetwork = NULL;
    BSTR            bstrNetInterfaceName = NULL;
    HNETINTERFACE   hNetInterface = NULL;

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL )
    {
        sc = TW32( GetLastError() );
        goto MakeHr;
    } // if:

    hEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_NETWORK );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        goto MakeHr;
    } // if:

    psz = new WCHAR [ cch ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterEnum( hEnum, idx, &dwType, psz, &cch );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cch++;
            psz = new WCHAR [ cch ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            hNetwork = OpenClusterNetwork( hCluster, psz );
            if ( hNetwork == NULL )
            {
                sc = TW32( GetLastError() );
                goto MakeHr;
            } // if:

            hr = THR( HrFindNetInterface( hNetwork, &bstrNetInterfaceName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hNetInterface = OpenClusterNetInterface( hCluster, bstrNetInterfaceName );
            if ( hNetInterface == NULL )
            {
                sc = TW32( GetLastError() );
                goto MakeHr;
            } // if:

            hr = THR( HrLoadClusterNetwork( hNetwork, hNetInterface ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            CloseClusterNetInterface( hNetInterface );
            hNetInterface = NULL;

            CloseClusterNetwork( hNetwork );
            hNetwork = NULL;

            TraceSysFreeString( bstrNetInterfaceName );
            bstrNetInterfaceName = NULL;

            idx++;
            continue;
        } // if:

        TW32( sc );
        goto MakeHr;

    } // for:

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    if ( hNetInterface != NULL )
    {
        CloseClusterNetInterface( hNetInterface );
    } // if:

    if ( hNetwork != NULL )
    {
        CloseClusterNetwork( hNetwork );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    } // if:

    delete [] psz;

    TraceSysFreeString( bstrNetInterfaceName );

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrLoadClusterNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks:HrLoadClusterNetwork
//
//  Description:
//      Load the cluster network and put it into the array of networks.
//
//  Arguments:
//      pszNetworkNameIn
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrLoadClusterNetwork(
      HNETWORK      hNetworkIn
    , HNETINTERFACE hNetInterfaceIn
    )
{
    TraceFunc( "" );
    Assert( hNetworkIn != NULL );

    HRESULT     hr;
    IUnknown *  punk = NULL;
    IUnknown *  punkCallback = NULL;

    hr = THR( m_picccCallback->TypeSafeQI( IUnknown, &punkCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Have to pass the Initialize interface arguments since new objects will
    //  be created when this call is made.
    //
    hr = THR( CClusCfgNetworkInfo::S_HrCreateInstance( hNetworkIn, hNetInterfaceIn, punkCallback, m_lcid, m_pIWbemServices, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  This is special -- do not initialize this again.
    //
    //hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    //if ( FAILED( hr ))
    //{
    //    goto Cleanup;
    //} // if:

    //hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    //if ( FAILED( hr ) )
    //{
    //    goto Cleanup;
    //} // if:

    hr = THR( HrAddNetworkToArray( punk ) );

    goto Cleanup;

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrLoadClusterNetwork


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusCfgNetworks::HrFindNetInterface
//
//  Description:
//      Find the netinterface for the passed in network.
//
//  Arguments:
//      pszNetworkNameIn
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusCfgNetworks::HrFindNetInterface(
      HNETWORK      hNetworkIn
    , BSTR *        pbstrNetInterfaceNameOut
    )
{
    TraceFunc( "" );
    Assert( hNetworkIn != NULL );
    Assert( pbstrNetInterfaceNameOut != NULL );

    HRESULT         hr = S_OK;
    DWORD           sc;
    HNETWORKENUM    hEnum = NULL;
    WCHAR *         psz = NULL;
    DWORD           cch = 33;
    DWORD           idx;
    DWORD           dwType;

    hEnum = ClusterNetworkOpenEnum( hNetworkIn, CLUSTER_NETWORK_ENUM_NETINTERFACES );
    if ( hEnum == NULL )
    {
        sc = TW32( GetLastError() );
        goto MakeHr;
    } // if:

    psz = new WCHAR [ cch ];
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; ; )
    {
        sc = ClusterNetworkEnum( hEnum, idx, &dwType, psz, &cch );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if:

        if ( sc == ERROR_MORE_DATA )
        {
            delete [] psz;
            psz = NULL;

            cch++;
            psz = new WCHAR [ cch ];
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc == ERROR_SUCCESS )
        {
            Assert( idx < 1 );      // only expect one netinterface per network

            *pbstrNetInterfaceNameOut = TraceSysAllocString( psz );
            if ( *pbstrNetInterfaceNameOut == NULL )
            {
                goto OutOfMemory;
            } // if:

            idx++;
            continue;
        } // if:

        TW32( sc );
        goto MakeHr;
    } // for:

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    if ( hEnum != NULL )
    {
        ClusterNetworkCloseEnum( hEnum );
    } // if:

    delete [] psz;

    HRETURN( hr );

} //*** CEnumClusCfgNetworks::HrFindNetInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumcluscfgnetworks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CEnumClusCfgNetworks.h
//
//  Description:
//      This file contains the declaration of the CEnumClusCfgNetworks
//      class.
//
//      The class CEnumClusCfgNetworks is the enumeration of
//      cluster networks. It implements the IEnumClusCfgNetworks interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumClusCfgNetworks.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumClusCfgNetworks
//
//  Description:
//      The class CEnumClusCfgNetworks is the enumeration of cluster networks.
//
//  Interfaces:
//      IEnumClusCfgNetworks
//      IClusCfgWbemServices
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumClusCfgNetworks
    : public IEnumClusCfgNetworks
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    IUnknown *          ((*m_prgNetworks)[]);
    BOOL                m_fLoadedNetworks:1;
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    DWORD               m_cNetworks;

    // Private constructors and destructors
    CEnumClusCfgNetworks( void );
    ~CEnumClusCfgNetworks( void );

    // Private copy constructor to prevent copying.
    CEnumClusCfgNetworks( const CEnumClusCfgNetworks & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumClusCfgNetworks & operator = ( const CEnumClusCfgNetworks & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrGetNetworks( void );
    HRESULT HrAddNetworkToArray( IUnknown * punkIn );
    HRESULT HrCreateAndAddNetworkToArray( IWbemClassObject * pNetworkIn );
    HRESULT HrIsThisNetworkUnique( IUnknown * punkIn, IWbemClassObject * pNetworkIn );
    HRESULT HrIsNLBS( BSTR bstrNameIn, IWbemClassObject * pNetworkIn );
    HRESULT HrLoadClusterNetworks( void );
    HRESULT HrLoadClusterNetwork( HNETWORK hNetworkResourceIn, HNETINTERFACE hNetInterfaceIn );
    HRESULT HrFindNetInterface( HNETWORK hNetworkIn, BSTR * pbstrNetInterfaceNameOut );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgNetworks Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgNetworkInfo ** rgpNetworkInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgNetworks ** ppEnumNetworksOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

}; //*** Class CEnumClusCfgNetworks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumclusterresources.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumClusterResources.cpp
//
//  Description:
//      This file contains the definition of the CEnumClusterResources
//       class.
//
//      The class CEnumClusterResources is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Header File:
//      CEnumClusterResources.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CEnumClusterResources.h"
#include "CClusterResource.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumClusterResources" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::S_HrCreateInstance()
//
//  Description:
//      Create a CEnumClusterResources instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CEnumClusterResources instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CEnumClusterResources *    pccpd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccpd = new CEnumClusterResources();
    if ( pccpd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccpd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccpd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumClusterResources::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccpd != NULL )
    {
        pccpd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusterResources::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumClusterResources::S_RegisterCatIDSupport()
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumPhysicalDisks, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::S_RegisterCatIDSupport()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::CEnumClusterResources()
//
//  Description:
//      Constructor of the CEnumClusterResources class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusterResources::CEnumClusterResources( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fLoadedResources( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_prgResources == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( m_cTotalResources == 0 );

    TraceFuncExit();

} //*** CEnumClusterResources::CEnumClusterResources


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::~CEnumClusterResources()
//
//  Description:
//      Desstructor of the CEnumClusterResources class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumClusterResources::~CEnumClusterResources( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgResources)[ idx ] != NULL )
        {
            ((*m_prgResources)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgResources );

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumClusterResources::~CEnumClusterResources


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumClusterResources:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusterResources::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CEnumClusterResources::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumClusterResources:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumClusterResources::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CEnumClusterResources::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IEnumClusCfgManagedResources * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgManagedResources ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CEnumClusterResources::QueryInterface()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Initialize()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::Initialize()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Next()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    ULONG                           idx;
    ULONG                           idxOutBuf;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_Cluster_Resources, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedResources )
    {
        hr = THR( HrGetResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    cFetched = ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( idx = 0, idxOutBuf = 0; idx < ulStop; idx++, m_idxEnumNext++ )
    {
        punk = (*m_prgResources)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ idxOutBuf++ ] = pccsdi;
        } // if:
        else
        {
            cFetched--;
        } // else:
    } // for:

    if ( FAILED( hr ) )
    {
        ULONG   idxStop = idxOutBuf - 1;

        m_idxEnumNext -= idx;

        for ( idx = 0; idx < idxStop; idx++ )
        {
            (rgpManagedResourceInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;
        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumClusterResources::Next()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Skip()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumClusterResources::Skip()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Reset()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumClusterResources::Reset()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Clone()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_Cluster_Resources, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::Clone()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumClusterResources::Count( DWORD * pnCountOut )
{
    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedResources )
    {
        hr = THR( HrGetResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    *pnCountOut = m_cTotalResources;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumClusterResources class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::HrInit()
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CEnumClusterResources::HrInit()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::HrGetResources()
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrGetResources( void )
{
    TraceFunc( "" );

    HRESULT hr = THR( HrEnumNodeResources( m_bstrNodeName ) );

    if ( FAILED( hr ) )
        goto Cleanup;

    m_fLoadedResources = true;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::HrGetResources()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources::HrCreateResourceAndAddToArray()
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrCreateResourceAndAddToArray(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IUnknown *              punk = NULL;
    IClusCfgLoadResource *  picclr = NULL;

    hr = THR( CClusterResource::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ))
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgLoadResource, &picclr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( picclr->LoadResource( hClusterIn, hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddResourceToArray( punk ) );

Cleanup:

    if ( picclr != NULL )
    {
        picclr->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusterResources::HrCreateResourceAndAddToArray()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources:HrAddResourceToArray()
//
//  Description:
//      Add the passed in disk to the array of punks that holds the disks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrAddResourceToArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]);

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgResources, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResourceToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgResources = prgpunks;

    (*m_prgResources)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cTotalResources += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumClusterResources::HrAddResourceToArray()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumClusterResources:HrNodeResourceCallback()
//
//  Description:
//      Called by CClusterUtils::HrEnumNodeResources() when it finds a
//      resource for this node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumClusterResources::HrNodeResourceCallback(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRETURN( HrCreateResourceAndAddToArray( hClusterIn, hResourceIn ) );

} //*** CEnumClusterResources::HrNodeResourceCallback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumclusterresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CEnumClusterResources.h
//
//  Description:
//      This file contains the declaration of the CEnumClusterResources class.
//
//      The class CEnumClusterResources is the enumeration of cluster
//      resources. It implements the IEnumClusCfgMangedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumClusterResources.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumClusterResources
//
//  Description:
//      The class CEnumClusterResources is the enumeration of cluster
//      resources.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgInitialize
//      CClusterUtils
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumClusterResources
    : public IEnumClusCfgManagedResources
    , public IClusCfgInitialize
    , public CClusterUtils
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fLoadedResources:1;
    IUnknown *          ((*m_prgResources)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    DWORD               m_cTotalResources;

    // Private constructors and destructors
    CEnumClusterResources( void );
    ~CEnumClusterResources( void );

    // Private copy constructor to prevent copying.
    CEnumClusterResources( const CEnumClusterResources & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumClusterResources & operator = ( const CEnumClusterResources & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrGetResources( void );
    HRESULT HrCreateResourceAndAddToArray( HCLUSTER hClusterIn, HRESOURCE hResourceIn );
    HRESULT HrAddResourceToArray( IUnknown * punkIn );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // CClusterUtils
    //

    HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );
    
}; //*** Class CEnumClusterResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumlocalquorum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumLocalQuorum.cpp
//
//  Description:
//      This file contains the definition of the CEnumLocalQuorum
//       class.
//
//      The class CEnumLocalQuorum is the enumeration of cluster
//      local quorum devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Header File:
//      CEnumLocalQuorum.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include <PropList.h>
#include "CEnumLocalQuorum.h"
#include "CLocalQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumLocalQuorum" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CEnumLocalQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CEnumLocalQuorum *    pccpd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccpd = new CEnumLocalQuorum();
    if ( pccpd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccpd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccpd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumLocalQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccpd != NULL )
    {
        pccpd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumLocalQuorum::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumLocalQuorum, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::S_RegisterCatIDSupport


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum:HrNodeResourceCallback
//
//  Description:
//      Called by CClusterUtils::HrEnumNodeResources when it finds a
//      resource for this node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrNodeResourceCallback(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    DWORD                           sc;
    CClusPropList                   cplPriv;
    CClusPropList                   cplCommonRO;
    CLUSPROP_BUFFER_HELPER          cpbh;
    BOOL                            fIsQuorum;
    IUnknown *                      punk = NULL;
    IClusCfgManagedResourceInfo *   pcccmri = NULL;

    hr = STHR( HrIsResourceOfType( hResourceIn, L"Local Quorum" ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If this resource is not a local quorum then we simply want to
    //  skip it.
    //
    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsCoreResource( hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    fIsQuorum = ( hr == S_OK );

    LOG_STATUS_REPORT_STRING( L"This node owns a local quorum resource.  It '%1!ws!' the quorum.", fIsQuorum ? L"is" : L"is not", hr );

    hr = THR( CLocalQuorum::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pcccmri ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcccmri->SetQuorumedDevice( fIsQuorum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Find out if the Debug flag is set....
    sc = TW32( cplPriv.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = cplPriv.ScMoveToPropertyByName( L"Debug" );
    if ( sc == ERROR_NO_MORE_ITEMS )
    {
        hr = THR( pcccmri->SetDeviceJoinable( false ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

    } // if:
    else if ( sc == ERROR_SUCCESS )
    {
        cpbh = cplPriv.CbhCurrentValue();
        Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );

        hr = THR( pcccmri->SetDeviceJoinable( !( cpbh.pDwordValue->dw == 0 ) ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // else if:
    else
    {
       TW32( sc );
       goto MakeHr;
    } // else:

    // get the name of this resource.
    sc = TW32( cplCommonRO.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = cplCommonRO.ScMoveToPropertyByName( L"Name" );
    if ( sc == ERROR_SUCCESS )
    {
        cpbh = cplCommonRO.CbhCurrentValue();
        Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

        hr = THR( pcccmri->SetName( cpbh.pStringValue->sz ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else
    {
       TW32( sc );
       goto MakeHr;
    } // else:

    hr = THR( HrAddResourceToArray( punk ) );

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    if ( pcccmri != NULL )
    {
        pcccmri->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::HrNodeResourceCallback


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::CEnumLocalQuorum
//
//  Description:
//      Constructor of the CEnumLocalQuorum class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumLocalQuorum::CEnumLocalQuorum( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_prgQuorums == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( !m_fEnumLoaded );
    Assert( m_cQuorumCount == 0 );

    TraceFuncExit();

} //*** CEnumLocalQuorum::CEnumLocalQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::~CEnumLocalQuorum
//
//  Description:
//      Desstructor of the CEnumLocalQuorum class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumLocalQuorum::~CEnumLocalQuorum( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgQuorums)[ idx ] != NULL )
        {
            ((*m_prgQuorums)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgQuorums );

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumLocalQuorum::~CEnumLocalQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrInit( void )
{
    TraceFunc( "" );

    HRETURN( S_OK );

} //*** CEnumLocalQuorum::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::HrLoadResources
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrLoadResources( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    //  If the node is clustered then load any local quorum resources
    //  that we own.
    //
    hr = STHR( HrIsNodeClustered() );
    if ( hr == S_OK )
    {
        hr = THR( HrEnumNodeResources( m_bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If this node doesn't own an instance of this resource then we need
        //  to create a dummy resource for MiddleTier analysis.
        //
        if ( m_idxNext == 0 )
        {
            LogMsg( L"[SRV] This node does not own a local quorum resource.  Creating a dummy resource." );
            hr = THR( HrCreateDummyObject() );
        } // if:
    } // if:
    else if ( hr == S_FALSE )
    {
        //
        //  If this node isn't clustered then we need to create a dummy resource
        //  for MiddleTier analysis.
        //
        LogMsg( L"[SRV] This node is not clustered.  Creating a dummy local quorum resource." );
        hr = THR( HrCreateDummyObject() );
    } // else if:

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::HrLoadResources


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum:HrAddResourceToArray
//
//  Description:
//      Add the passed in local quorum to the array of punks that holds the
//      list of local quorums.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrAddResourceToArray( IUnknown * punkIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgQuorums, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResourceToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgQuorums = prgpunks;

    (*m_prgQuorums)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cQuorumCount += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::HrAddResourceToArray


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::HrCreateDummyObject
//
//  Description:
//      Create a dummy object so the MiddleTier will be happy.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumLocalQuorum::HrCreateDummyObject( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk = NULL;

    hr = THR( CLocalQuorum::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddResourceToArray( punk ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::HrCreateDummyObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumLocalQuorum:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumLocalQuorum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CEnumLocalQuorum::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumLocalQuorum:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumLocalQuorum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CEnumLocalQuorum::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IEnumClusCfgManagedResources * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgManagedResources ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING1( hr, riid, IID_IClusCfgWbemServices );

} //*** CEnumLocalQuorum::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumLocalQuorum -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_LocalQuorum, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = STHR( HrLoadResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_fEnumLoaded = true;
    } // if:

    ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( hr = S_OK; ( cFetched < ulStop ) && ( m_idxEnumNext < m_idxNext ); m_idxEnumNext++ )
    {
        punk = (*m_prgQuorums)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ cFetched++ ] = pccsdi;
        } // if:
    } // for:

    if ( FAILED( hr ) )
    {
        m_idxEnumNext -= cFetched;

        while ( cFetched != 0 )
        {
            (rgpManagedResourceInfoOut[ --cFetched ])->Release();
        } // for:

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumLocalQuorum::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_LocalQuorum, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumLocalQuorum::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumLocalQuorum::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = STHR( HrLoadResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_fEnumLoaded = true;
    } // if:

    *pnCountOut = m_cQuorumCount;

Cleanup:

    HRETURN( hr );

} //*** CEnumLocalQuorum::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenummajoritynodeset.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CEnumMajorityNodeSet.cpp
//
//  Description:
//      This file contains the definition of the CEnumMajorityNodeSet
//       class.
//
//      The class CEnumMajorityNodeSet is the enumeration of cluster
//      majority node set devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Header File:
//      CEnumMajorityNodeSet.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include <PropList.h>
#include "CEnumMajorityNodeSet.h"
#include "CMajorityNodeSet.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumMajorityNodeSet" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::S_HrCreateInstance
//
//  Description:
//      Create a CEnumMajorityNodeSet instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CEnumMajorityNodeSet *    pccpd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccpd = new CEnumMajorityNodeSet();
    if ( pccpd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccpd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccpd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumMajorityNodeSet::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccpd != NULL )
    {
        pccpd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumMajorityNodeSet::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumMajorityNodeSet, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::S_RegisterCatIDSupport


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet:HrNodeResourceCallback
//
//  Description:
//      Called by CClusterUtils::HrEnumNodeResources() when it finds a
//      resource for this node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrNodeResourceCallback(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    BOOL                            fIsQuorum;
    IUnknown *                      punk = NULL;
    IClusCfgManagedResourceInfo *   pcccmri = NULL;
    CClusPropList                   cplCommonRO;
    CLUSPROP_BUFFER_HELPER          cpbh;
    DWORD                           sc = ERROR_SUCCESS;

    hr = STHR( HrIsResourceOfType( hResourceIn, L"Node Quorum" ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If this resource is not a majority node set then we simply want to
    //  skip it.
    //
    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsCoreResource( hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    fIsQuorum = ( hr == S_OK );

    hr = THR( CMajorityNodeSet::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pcccmri ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcccmri->SetQuorumedDevice( fIsQuorum ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // get the name of this resource.
    sc = TW32( cplCommonRO.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = cplCommonRO.ScMoveToPropertyByName( L"Name" );
    if ( sc == ERROR_SUCCESS )
    {
        cpbh = cplCommonRO.CbhCurrentValue();
        Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

        hr = THR( pcccmri->SetName( cpbh.pStringValue->sz ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:
    else
    {
       TW32( sc );
       goto MakeHr;
    } // else:

    hr = THR( HrAddResourceToArray( punk ) );

    goto Cleanup;

MakeHr:

       hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    if ( pcccmri != NULL )
    {
        pcccmri->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::HrNodeResourceCallback


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::CEnumMajorityNodeSet
//
//  Description:
//      Constructor of the CEnumMajorityNodeSet class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumMajorityNodeSet::CEnumMajorityNodeSet( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_prgQuorums == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( !m_fEnumLoaded );

    TraceFuncExit();

} //*** CEnumMajorityNodeSet::CEnumMajorityNodeSet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::~CEnumMajorityNodeSet
//
//  Description:
//      Desstructor of the CEnumMajorityNodeSet class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumMajorityNodeSet::~CEnumMajorityNodeSet( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgQuorums)[ idx ] != NULL )
        {
            ((*m_prgQuorums)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgQuorums );

    TraceSysFreeString( m_bstrNodeName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumMajorityNodeSet::~CEnumMajorityNodeSet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrInit( void )
{
    TraceFunc( "" );

    HRETURN( S_OK );

} //*** CEnumMajorityNodeSet::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::HrLoadResources
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrLoadResources( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    //  If the node is clustered then load any majority node set resources
    //  that might exist.
    //
    hr = STHR( HrIsNodeClustered() );
    if ( hr == S_OK )
    {
        hr = THR( HrEnumNodeResources( m_bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If this node doesn't own an instance of this resource then we need
        //  to create a dummy resource for MiddleTier analysis.
        //
        if ( m_idxNext == 0 )
        {
            hr = THR( HrCreateDummyObject() );
        } // if:
    } // if:
    else if ( hr == S_FALSE )
    {
        //
        //  If this node isn't clustered then we need to create a dummy resource
        //  for MiddleTier analysis.
        //
        hr = THR( HrCreateDummyObject() );
    } // else if:

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::HrLoadResources


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet:HrAddResourceToArray
//
//  Description:
//      Add the passed in majority node set to the array of punks that holds the
//      list of majority node sets.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrAddResourceToArray( IUnknown * punkIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgQuorums, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResourceToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgQuorums = prgpunks;

    (*m_prgQuorums)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cQuorumCount += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::HrAddResourceToArray


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::HrCreateDummyObject
//
//  Description:
//      Create a dummy object so the MiddleTier will be happy.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumMajorityNodeSet::HrCreateDummyObject( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk = NULL;

    hr = THR( CMajorityNodeSet::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddResourceToArray( punk ) );

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::HrCreateDummyObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumMajorityNodeSet:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumMajorityNodeSet::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CEnumMajorityNodeSet::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumMajorityNodeSet:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumMajorityNodeSet::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CEnumMajorityNodeSet::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IEnumClusCfgManagedResources * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgManagedResources ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING1( hr, riid, IID_IClusCfgWbemServices );

} //*** CEnumMajorityNodeSet::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumMajorityNodeSet -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_MajorityNodeSet, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = THR( HrLoadResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_fEnumLoaded = true;
    } // if:

    ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( hr = S_OK; ( cFetched < ulStop ) && ( m_idxEnumNext < m_idxNext ); m_idxEnumNext++ )
    {
        punk = (*m_prgQuorums)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ cFetched++ ] = pccsdi;
        } // if:
    } // for:

    if ( FAILED( hr ) )
    {
        m_idxEnumNext -= cFetched;

        while ( cFetched != 0 )
        {
            (rgpManagedResourceInfoOut[ --cFetched ])->Release();
        } // for:

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumMajorityNodeSet::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_MajorityNodeSet, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumMajorityNodeSet::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumMajorityNodeSet::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = THR( HrLoadResources() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        m_fEnumLoaded = true;
    } // if:

    *pnCountOut = m_cQuorumCount;

Cleanup:

    HRETURN( hr );

} //*** CEnumMajorityNodeSet::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumlocalquorum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumLocalQuorum.h
//
//  Description:
//      This file contains the declaration of the CEnumLocalQuorum class.
//
//      The class CEnumLocalQuorum is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumLocalQuorum.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumLocalQuorum
//
//  Description:
//      The class CEnumLocalQuorum is the enumeration of cluster local
//      quorum devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumLocalQuorum
    : public IEnumClusCfgManagedResources
    , public IClusCfgInitialize
    , public CClusterUtils
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fEnumLoaded:1;
    IUnknown *          ((*m_prgQuorums)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    DWORD               m_cQuorumCount;

    // Private constructors and destructors
    CEnumLocalQuorum( void );
    ~CEnumLocalQuorum( void );

    // Private copy constructor to prevent copying.
    CEnumLocalQuorum( const CEnumLocalQuorum & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumLocalQuorum & operator = ( const CEnumLocalQuorum & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrLoadResources( void );
    HRESULT HrAddResourceToArray( IUnknown * punkIn );
    HRESULT HrCreateDummyObject( void );

public:
    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );
    
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    //  CClusterUtils
    //
    virtual HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

}; //*** Class CEnumLocalQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumunknownquorum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CEnumUnknownQuorum.cpp
//
//  Description:
//      This file contains the definition of the CEnumUnknownQuorum
//       class.
//
//      The class CEnumUnknownQuorum is the enumeration of unknown cluster
//      node quorum devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Header File:
//      CEnumUnknownQuorum.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-MAY-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include <PropList.h>
#include "CEnumUnknownQuorum.h"
#include "CUnknownQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumUnknownQuorum" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CEnumUnknownQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CEnumUnknownQuorum *    pccpd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccpd = new CEnumUnknownQuorum();
    if ( pccpd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccpd->HrInit( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccpd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumUnknownQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccpd != NULL )
    {
        pccpd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CEnumUnknownQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::S_HrCreateInstance(
      BSTR          bstrNameIn
    , BOOL          fMakeQuorumIn
    , IUnknown **   ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CEnumUnknownQuorum *    pccpd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccpd = new CEnumUnknownQuorum();
    if ( pccpd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccpd->HrInit( bstrNameIn, fMakeQuorumIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccpd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumUnknownQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccpd != NULL )
    {
        pccpd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::S_HrCreateInstance

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumUnknownQuorum::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumNodeQuorum, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::S_RegisterCatIDSupport
*/

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::CEnumUnknownQuorum
//
//  Description:
//      Constructor of the CEnumUnknownQuorum class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumUnknownQuorum::CEnumUnknownQuorum( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_prgQuorums == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( !m_fEnumLoaded );
    Assert( !m_fDefaultDeviceToQuorum );
    Assert( m_bstrQuorumResourceName == NULL );

    TraceFuncExit();

} //*** CEnumUnknownQuorum::CEnumUnknownQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::~CEnumUnknownQuorum
//
//  Description:
//      Desstructor of the CEnumUnknownQuorum class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumUnknownQuorum::~CEnumUnknownQuorum( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgQuorums)[ idx ] != NULL )
        {
            ((*m_prgQuorums)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgQuorums );

    TraceSysFreeString( m_bstrNodeName );
    TraceSysFreeString( m_bstrQuorumResourceName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumUnknownQuorum::~CEnumUnknownQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::HrInit( BSTR bstrNameIn, BOOL fMakeQuorumIn /* = FALSE */ )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_fDefaultDeviceToQuorum = fMakeQuorumIn;

    //
    //  Were we given a name?
    //
    if ( bstrNameIn != NULL )
    {
        m_bstrQuorumResourceName = TraceSysAllocString( bstrNameIn );
        if ( m_bstrQuorumResourceName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
        } // if:
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::HrInit


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum:HrAddResourceToArray
//
//  Description:
//      Add the passed in node quorum to the array of punks that holds the
//      list of node quorums.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::HrAddResourceToArray( IUnknown * punkIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgQuorums, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddResourceToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgQuorums = prgpunks;

    (*m_prgQuorums)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::HrAddResourceToArray


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::HrCreateDummyObject
//
//  Description:
//      Create a dummy object so the MiddleTier will be happy.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumUnknownQuorum::HrCreateDummyObject( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  punk = NULL;

    hr = THR( CUnknownQuorum::S_HrCreateInstance(
                                      m_bstrQuorumResourceName
                                    , m_fDefaultDeviceToQuorum
                                    , &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrAddResourceToArray( punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_fEnumLoaded = true;

Cleanup:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::HrCreateDummyObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumUnknownQuorum:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumUnknownQuorum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CEnumUnknownQuorum::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumUnknownQuorum:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumUnknownQuorum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CEnumUnknownQuorum::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IEnumClusCfgManagedResources * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgManagedResources ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING1( hr, riid, IID_IClusCfgWbemServices );

} //*** CEnumUnknownQuorum::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumUnknownQuorum -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_MajorityNodeSet, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = THR( HrCreateDummyObject() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( hr = S_OK; ( cFetched < ulStop ) && ( m_idxEnumNext < m_idxNext ); m_idxEnumNext++ )
    {
        punk = (*m_prgQuorums)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ cFetched++ ] = pccsdi;
        } // if:
    } // for:

    if ( FAILED( hr ) )
    {
        m_idxEnumNext -= cFetched;

        while ( cFetched != 0 )
        {
            (rgpManagedResourceInfoOut[ --cFetched ])->Release();
        } // for:

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumUnknownQuorum::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_MajorityNodeSet, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumUnknownQuorum::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumUnknownQuorum::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fEnumLoaded )
    {
        hr = THR( HrCreateDummyObject() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    Assert( m_idxNext == 1 );   // don't expect to ever have more than one.

    *pnCountOut = m_idxNext;

Cleanup:

    HRETURN( hr );

} //*** CEnumUnknownQuorum::Count
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumphysicaldisks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CEnumPhysicalDisks.h
//
//  Description:
//      This file contains the declaration of the CEnumPhysicalDisks class.
//
//      The class CEnumPhysicalDisks is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumPhysicalDisks.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumPhysicalDisks
//
//  Description:
//      The class CEnumPhysicalDisks is the enumeration of cluster storage
//      devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgWbemServices
//      IClusCfgInitialize
//      CClusterUtils
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumPhysicalDisks
    : public IEnumClusCfgManagedResources
    , public IClusCfgWbemServices
    , public IClusCfgInitialize
    , public CClusterUtils
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    BOOL                m_fLoadedDevices:1;
    IUnknown *          ((*m_prgDisks)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    BSTR                m_bstrBootDevice;
    BSTR                m_bstrSystemDevice;
    BSTR                m_bstrBootLogicalDisk;
    BSTR                m_bstrSystemLogicalDisk;
    BSTR                m_bstrSystemWMIDeviceID;
    DWORD               m_cDiskCount;

    // Private constructors and destructors
    CEnumPhysicalDisks( void );
    ~CEnumPhysicalDisks( void );

    // Private copy constructor to prevent copying.
    CEnumPhysicalDisks( const CEnumPhysicalDisks & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumPhysicalDisks & operator = ( const CEnumPhysicalDisks & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrGetDisks( void );
    HRESULT HrCreateAndAddDiskToArray( IWbemClassObject * pDiskIn );
    HRESULT HrAddDiskToArray( IUnknown * punkIn );
    HRESULT HrPruneSystemDisks( void );
    HRESULT IsDiskSCSI( IWbemClassObject * pDiskIn );
    HRESULT HrFixupDisks( void );
    HRESULT HrGetClusterDiskInfo( HCLUSTER hClusterIn, HRESOURCE hResourceIn, CLUS_SCSI_ADDRESS * pcsaOut, DWORD * pdwSignatureOut );
    HRESULT HrSetThisDiskToBeManaged( ULONG ulSCSITidIn, ULONG ulSCSILunIn, BOOL fIsQuorumIn, BSTR bstrResourceNameIn, DWORD dwSignatureIn );
    HRESULT HrFindDiskWithLogicalDisk( WCHAR cLogicalDiskIn, ULONG * pidxDiskOut );
    HRESULT HrGetSCSIInfo( ULONG idxDiskIn, ULONG * pulSCSIBusOut, ULONG * pulSCSIPortOut );
    HRESULT HrPruneDisks( ULONG ulSCSIBusIn, ULONG ulSCSIPortIn, ULONG * pulRemovedOut, int nMsgId );
    void    LogPrunedDisk( IUnknown * punkIn, ULONG ulSCSIBusIn, ULONG ulSCSIPortIn );
    HRESULT HrIsLogicalDiskNTFS( BSTR bstrLogicalDiskIn );
    HRESULT HrLogDiskInfo( IWbemClassObject * pDiskIn );
    HRESULT HrFindDiskWithWMIDeviceID( BSTR bstrWMIDeviceIDIn, ULONG * pidxDiskOut );
    HRESULT HrIsSystemBusManaged( void );
    HRESULT HrGetClusterProperties( HRESOURCE hResourceIn, BSTR * pbstrResourceNameOut );
    void    RemoveDiskFromArray( ULONG idxDiskIn );
    HRESULT HrLoadEnum( void );

public:
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interfaces
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // CClusterUtils
    //

    HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

}; //*** Class CEnumPhysicalDisks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenummajoritynodeset.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CEnumMajorityNodeSet.h
//
//  Description:
//      This file contains the declaration of the CEnumMajorityNodeSet class.
//
//      The class CEnumMajorityNodeSet is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumMajorityNodeSet.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumMajorityNodeSet
//
//  Description:
//      The class CEnumMajorityNodeSet is the enumeration of cluster local
//      quorum devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumMajorityNodeSet
    : public IEnumClusCfgManagedResources
    , public IClusCfgInitialize
    , public CClusterUtils
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fEnumLoaded:1;
    IUnknown *          ((*m_prgQuorums)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    DWORD               m_cQuorumCount;

    // Private constructors and destructors
    CEnumMajorityNodeSet( void );
    ~CEnumMajorityNodeSet( void );

    // Private copy constructor to prevent copying.
    CEnumMajorityNodeSet( const CEnumMajorityNodeSet & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumMajorityNodeSet & operator = ( const CEnumMajorityNodeSet & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrLoadResources( void );
    HRESULT HrAddResourceToArray( IUnknown * punkIn );
    HRESULT HrCreateDummyObject( void );

public:
    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );
    
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

    //
    //  CClusterUtils
    //
    virtual HRESULT HrNodeResourceCallback( HCLUSTER hClusterIn, HRESOURCE hResourceIn );

}; //*** Class CEnumMajorityNodeSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumphysicaldisks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumPhysicalDisks.cpp
//
//  Description:
//      This file contains the definition of the CEnumPhysicalDisks
//       class.
//
//      The class CEnumPhysicalDisks is the enumeration of cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//  Documentation:
//
//  Header File:
//      CEnumPhysicalDisks.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CEnumPhysicalDisks.h"
#include "CPhysicalDisk.h"
#include <PropList.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CEnumPhysicalDisks" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::S_HrCreateInstance
//
//  Description:
//      Create a CEnumPhysicalDisks instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          The passed in ppunk is NULL.
//
//      other HRESULTs
//          Object creation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT                 hr;
    CEnumPhysicalDisks *    pccpd = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pccpd = new CEnumPhysicalDisks();
    if ( pccpd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( pccpd->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( pccpd->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CEnumPhysicalDisks::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( pccpd != NULL )
    {
        pccpd->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IUnknown *
//  CEnumPhysicalDisks::S_RegisterCatIDSupport
//
//  Description:
//      Registers/unregisters this class with the categories that it belongs
//      to.
//
//  Arguments:
//      IN  ICatRegister * picrIn
//          Used to register/unregister our CATID support.
//
//      IN  BOOL fCreateIn
//          When true we are registering the server.  When false we are
//          un-registering the server.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_INVALIDARG
//          The passed in ICatRgister pointer was NULL.
//
//      other HRESULTs
//          Registration/Unregistration failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::S_RegisterCatIDSupport(
    ICatRegister *  picrIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CATID   rgCatIds[ 1 ];

    if ( picrIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    rgCatIds[ 0 ] = CATID_EnumClusCfgManagedResources;

    if ( fCreateIn )
    {
        hr = THR( picrIn->RegisterClassImplCategories( CLSID_EnumPhysicalDisks, 1, rgCatIds ) );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::S_RegisterCatIDSupport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::CEnumPhysicalDisks
//
//  Description:
//      Constructor of the CEnumPhysicalDisks class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumPhysicalDisks::CEnumPhysicalDisks( void )
    : m_cRef( 1 )
    , m_lcid( LOCALE_NEUTRAL )
    , m_fLoadedDevices( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_picccCallback == NULL );
    Assert( m_pIWbemServices == NULL );
    Assert( m_prgDisks == NULL );
    Assert( m_idxNext == 0 );
    Assert( m_idxEnumNext == 0 );
    Assert( m_bstrNodeName == NULL );
    Assert( m_bstrBootDevice == NULL );
    Assert( m_bstrSystemDevice == NULL );
    Assert( m_bstrBootLogicalDisk == NULL );
    Assert( m_bstrSystemLogicalDisk == NULL );
    Assert( m_bstrSystemWMIDeviceID == NULL );
    Assert( m_cDiskCount == 0 );

    TraceFuncExit();

} //*** CEnumPhysicalDisks::CEnumPhysicalDisks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::~CEnumPhysicalDisks
//
//  Description:
//      Desstructor of the CEnumPhysicalDisks class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumPhysicalDisks::~CEnumPhysicalDisks( void )
{
    TraceFunc( "" );

    ULONG   idx;

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        if ( (*m_prgDisks)[ idx ] != NULL )
        {
            ((*m_prgDisks)[ idx ])->Release();
        } // end if:
    } // for:

    TraceFree( m_prgDisks );

    TraceSysFreeString( m_bstrNodeName );
    TraceSysFreeString( m_bstrBootDevice );
    TraceSysFreeString( m_bstrSystemDevice );
    TraceSysFreeString( m_bstrBootLogicalDisk );
    TraceSysFreeString( m_bstrSystemLogicalDisk );
    TraceSysFreeString( m_bstrSystemWMIDeviceID );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumPhysicalDisks::~CEnumPhysicalDisks


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumPhysicalDisks:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumPhysicalDisks::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CEnumPhysicalDisks::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumPhysicalDisks:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEnumPhysicalDisks::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CEnumPhysicalDisks::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IEnumClusCfgManagedResources * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgManagedResources ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CEnumPhysicalDisks::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_Enum_PhysDisk, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

    hr = THR( HrGetSystemDevice( &m_bstrSystemDevice ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrConvertDeviceVolumeToLogicalDisk( m_bstrSystemDevice, &m_bstrSystemLogicalDisk ) );
    //
    //  system volume is an EFI volume on IA64 and won't have a logical disk.
    //
    if ( HRESULT_CODE( hr ) == ERROR_INVALID_FUNCTION )
    {
        hr = THR( HrConvertDeviceVolumeToWMIDeviceID( m_bstrSystemDevice, &m_bstrSystemWMIDeviceID ) );
        Assert( m_bstrSystemLogicalDisk == NULL );
        Assert( m_bstrSystemWMIDeviceID != NULL );
    } // if:

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetBootLogicalDisk( &m_bstrBootLogicalDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsLogicalDiskNTFS( m_bstrBootLogicalDisk ) );
    if ( hr == S_FALSE )
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Boot_Partition_Not_NTFS, IDS_WARNING_BOOT_PARTITION_NOT_NTFS, hr );
        hr = S_OK;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetComputerName( ComputerNameNetBIOS, &m_bstrNodeName ) );

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks -- IEnumClusCfgManagedResources interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           cFetched = 0;
    IClusCfgManagedResourceInfo *   pccsdi;
    IUnknown *                      punk;
    ULONG                           ulStop;

    if ( rgpManagedResourceInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_Enum_PhysDisk, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedDevices )
    {
        hr = THR( HrLoadEnum() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    ulStop = min( cNumberRequestedIn, ( m_idxNext - m_idxEnumNext ) );

    for ( hr = S_OK; ( cFetched < ulStop ) && ( m_idxEnumNext < m_idxNext ); m_idxEnumNext++ )
    {
        punk = (*m_prgDisks)[ m_idxEnumNext ];
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &pccsdi ) );
            if ( FAILED( hr ) )
            {
                break;
            } // if:

            rgpManagedResourceInfoOut[ cFetched++ ] = pccsdi;
        } // if:
    } // for:

    if ( FAILED( hr ) )
    {
        m_idxEnumNext -= cFetched;

        while ( cFetched != 0 )
        {
            (rgpManagedResourceInfoOut[ --cFetched ])->Release();
        } // for:

        goto Cleanup;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_idxEnumNext += cNumberToSkipIn;
    if ( m_idxEnumNext >= m_idxNext )
    {
        m_idxEnumNext = m_idxNext;
        hr = STHR( S_FALSE );
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    m_idxEnumNext = 0;

    HRETURN( S_OK );

} //*** CEnumPhysicalDisks::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Clone(
    IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgStorageDevicesOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_Enum_PhysDisk, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::Count
//
//  Description:
//      Return the count of items in the Enum.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumPhysicalDisks::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( !m_fLoadedDevices )
    {
        hr = THR( HrLoadEnum() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    *pnCountOut = m_cDiskCount;

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumPhysicalDisks class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrInit


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrGetDisks
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetDisks( void )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    BSTR                    bstrClass;
    IEnumWbemClassObject *  pDisks = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pDisk = NULL;

    bstrClass = TraceSysAllocString( L"Win32_DiskDrive" );
    if ( bstrClass == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->CreateInstanceEnum( bstrClass, WBEM_FLAG_SHALLOW, NULL, &pDisks ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_WMI_Phys_Disks_Qry_Failed, IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED, hr );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        hr = pDisks->Next( WBEM_INFINITE, 1, &pDisk, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            hr = STHR( HrLogDiskInfo( pDisk ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = STHR( IsDiskSCSI( pDisk ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                hr = STHR( HrCreateAndAddDiskToArray( pDisk ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:
            } // if:

            pDisk->Release();
            pDisk = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WQL_Disk_Qry_Next_Failed, IDS_ERROR_WQL_QRY_NEXT_FAILED, bstrClass, hr );
            goto Cleanup;
        } // else:
    } // for:

    m_idxEnumNext = 0;
    m_fLoadedDevices = TRUE;

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetDisks, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    if ( pDisk != NULL )
    {
        pDisk->Release();
    } // if:

    if ( pDisks != NULL )
    {
        pDisks->Release();
    } // if:

    TraceSysFreeString( bstrClass );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrCreateAndAddDiskToArray
//
//  Description:
//      Create a IClusCfgStorageDevice object and add the passed in disk to
//      the array of punks that holds the disks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrCreateAndAddDiskToArray( IWbemClassObject * pDiskIn )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    IUnknown *              punk = NULL;
    IClusCfgSetWbemObject * piccswo = NULL;
    bool                    fRetainObject = true;


    hr = THR( CPhysicalDisk::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

    punk = TraceInterface( L"CPhysicalDisk", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgSetWbemObject, &piccswo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( piccswo->SetWbemObject( pDiskIn, &fRetainObject ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( fRetainObject )
    {
        hr = THR( HrAddDiskToArray( punk ) );
    } // if:

Cleanup:

    if ( piccswo != NULL )
    {
        piccswo->Release();
    } // if:

    punk->Release();

Exit:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrCreateAndAddDiskToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrPruneSystemDisks
//
//  Description:
//      Prune all system disks from the list.  System disks are disks that
//      are booted, are running the OS, or have page files.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrPruneSystemDisks( void )
{
    TraceFunc( "" );

    HRESULT                             hr = S_OK;
    ULONG                               idx;
    ULONG                               ulSCSIBus;
    ULONG                               ulSCSIPort;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    IUnknown *                          punk;
    ULONG                               cRemoved = 0;
    ULONG                               cTemp = 0;
    bool                                fSystemAndBootTheSame = ( m_bstrSystemLogicalDisk != NULL ) ? ( m_bstrBootLogicalDisk[ 0 ] == m_bstrSystemLogicalDisk[ 0 ] ) : false;
    WCHAR                               szPageFileDisks[ 26 ];
    int                                 cPageFileDisks = 0;
    int                                 idxPageFileDisk;
    bool                                fPruneBus = false;


    hr = STHR( HrIsSystemBusManaged() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If the system bus is not managed then we need to prune the disks on those buses
    //  that contain system, boot, and pagefile disks.
    //
    if ( hr == S_FALSE )
    {
        fPruneBus = true;
    } // if:

    //
    //  Prune the disks on the system buses.  If the system disks are IDE they won't
    //  be in the list.
    //

    //
    //  Find the boot disk
    //
    hr = STHR( HrFindDiskWithLogicalDisk( m_bstrBootLogicalDisk[ 0 ], &idx ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        //
        //  Should we prune the whole bus, or just the boot disk itself?
        //
        if ( fPruneBus )
        {
            hr = THR( HrGetSCSIInfo( idx, &ulSCSIBus, &ulSCSIPort ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Pruning_Boot_Disk_Bus, IDS_INFO_PRUNING_BOOTDISK_BUS, hr );
            hr = THR( HrPruneDisks( ulSCSIBus, ulSCSIPort, &cTemp, IDS_INFO_BOOTDISK_PRUNED ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            cRemoved += cTemp;
        } // if:
        else
        {
            RemoveDiskFromArray( idx );
            cRemoved++;
        } // else:
    } // if:

    //
    //  Prune the system disk bus if it is not the same as the boot disk bus.
    //
    if ( !fSystemAndBootTheSame )
    {
        if ( m_bstrSystemLogicalDisk != NULL )
        {
            Assert( m_bstrSystemWMIDeviceID == NULL );
            hr = STHR( HrFindDiskWithLogicalDisk( m_bstrSystemLogicalDisk[ 0 ], &idx ) );
        } // if:
        else
        {
            Assert( m_bstrSystemLogicalDisk == NULL );
            hr = STHR( HrFindDiskWithWMIDeviceID( m_bstrSystemWMIDeviceID, &idx ) );
        } // else:

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            //
            //  Should we prune the whole bus, or just the system disk itself?
            //
            if ( fPruneBus )
            {
                hr = THR( HrGetSCSIInfo( idx, &ulSCSIBus, &ulSCSIPort ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Pruning_System_Disk_Bus, IDS_INFO_PRUNING_SYSTEMDISK_BUS, hr );
                hr = THR( HrPruneDisks( ulSCSIBus, ulSCSIPort, &cTemp, IDS_INFO_SYSTEMDISK_PRUNED ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                cRemoved += cTemp;
            } // if:
            else
            {
                RemoveDiskFromArray( idx );
                cRemoved++;
            } // else:
        } // if:
    } // if:

    //
    //  Prune the bus with disks that have paging files.
    //
    hr = THR( HrGetPageFileLogicalDisks( m_picccCallback, m_pIWbemServices, szPageFileDisks, &cPageFileDisks ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( cPageFileDisks > 0 )
    {
        for ( idxPageFileDisk = 0; idxPageFileDisk < cPageFileDisks; idxPageFileDisk++ )
        {
            hr = STHR( HrFindDiskWithLogicalDisk( szPageFileDisks[ idxPageFileDisk ], &idx ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                //
                //  Should we prune the whole bus, or just the system disk itself?
                //
                if ( fPruneBus )
                {
                    hr = THR( HrGetSCSIInfo( idx, &ulSCSIBus, &ulSCSIPort ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Pruning_PageFile_Disk_Bus, IDS_INFO_PRUNING_PAGEFILEDISK_BUS, hr );
                    hr = THR( HrPruneDisks( ulSCSIBus, ulSCSIPort, &cTemp, IDS_INFO_PAGEFILEDISK_PRUNED ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    cRemoved += cTemp;
                } // if:
                else
                {
                    RemoveDiskFromArray( idx );
                    cRemoved++;
                } // else:
            } // if:
        } // for:
    } // if:

    //
    //  Last ditch effort to properly set the managed state of the remaining disks.
    //
    for ( idx = 0; ( cRemoved < m_idxNext ) && ( idx < m_idxNext ); idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                LOG_STATUS_REPORT( L"Could not query for the IClusCfgPhysicalDiskProperties interface.", hr );
                goto Cleanup;
            } // if:

            //
            //  Give the disk a chance to figure out for itself if it should be managed.
            //
            hr = STHR( piccpdp->CanBeManaged() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            piccpdp->Release();
            piccpdp = NULL;
        } // if:
    } // for:

    //
    //  Minor optimization.  If we removed all of the elements reset the enum next to 0.
    //
    if ( cRemoved == m_idxNext )
    {
        m_idxNext = 0;
    } // if:

    hr = S_OK;

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrPruneSystemDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::IsDiskSCSI
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Disk is SCSI.
//
//      S_FALSE
//          Disk is not SCSI.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::IsDiskSCSI( IWbemClassObject * pDiskIn )
{
    TraceFunc( "" );
    Assert( pDiskIn != NULL );

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"InterfaceType", VT_BSTR, &var ) );
    if ( SUCCEEDED( hr ) )
    {
        if ( ( wcscmp( L"SCSI", var.bstrVal ) == 0 ) )
        {
            hr = S_OK;
        } // if:
        else
        {
            hr = S_FALSE;
        } // else:
    } // if:

    VariantClear( &var );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::IsDiskSCSI


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrAddDiskToArray
//
//  Description:
//      Add the passed in disk to the array of punks that holds the disks.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrAddDiskToArray( IUnknown * punkIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgDisks, sizeof( IUnknown * ) * ( m_idxNext + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddDiskToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgDisks = prgpunks;

    (*m_prgDisks)[ m_idxNext++ ] = punkIn;
    punkIn->AddRef();
    m_cDiskCount += 1;

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrAddDiskToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrFixupDisks
//
//  Description:
//      Tweak the disks to better reflect how they are managed by this node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrFixupDisks( void )
{
    TraceFunc( "" );

    HRESULT                         hr;
    ULONG                           idx;
    IUnknown *                      punk = NULL;
    IClusCfgManagedResourceInfo *   piccmri = NULL;

    //
    //  KB: 14-JUN-2000 GalenB
    //
    //  Clear the managed bit on all remaing disks.  These bits will be turned
    //  back on for the disks this node owns.  That happens in
    //  HrNodeResourceCallback().
    //

    //
    //  BUGBUG: 02-MAY-2001 GalenB
    //
    //  Hmmm...  Maybe clearing the managed state from all disks is a mistake.  What if we
    //  have new disks that are not already in the cluster for this clustered node?
    //
    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &piccmri ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = THR( piccmri->SetManaged( false ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            piccmri->Release();
            piccmri = NULL;
        } // if:
    } // for:

    hr = THR( HrEnumNodeResources( m_bstrNodeName ) );

Cleanup:

    if ( piccmri != NULL )
    {
        piccmri->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrFixupDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrNodeResourceCallback
//
//  Description:
//      Called by CClusterUtils::HrEnumNodeResources() when it finds a
//      resource for this node.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrNodeResourceCallback(
    HCLUSTER    hClusterIn,
    HRESOURCE   hResourceIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CLUS_SCSI_ADDRESS       csa;
    DWORD                   dwSignature;
    BOOL                    fIsQuorum;
    BSTR                    bstrResourceName = NULL;

    hr = STHR( HrIsResourceOfType( hResourceIn, L"Physical Disk" ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  If this resource is not a physical disk then we simply want to
    //  skip it.
    //
    if ( hr == S_FALSE )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsCoreResource( hResourceIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    fIsQuorum = ( hr == S_OK );

    hr = THR( HrGetClusterDiskInfo( hClusterIn, hResourceIn, &csa, &dwSignature ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetClusterProperties( hResourceIn, &bstrResourceName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetThisDiskToBeManaged( csa.TargetId, csa.Lun, fIsQuorum, bstrResourceName, dwSignature ) );

Cleanup:

    TraceSysFreeString( bstrResourceName );

    HRETURN( hr );


} //*** CEnumPhysicalDisks::HrNodeResourceCallback


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrGetClusterDiskInfo
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetClusterDiskInfo(
    HCLUSTER            hClusterIn,
    HRESOURCE           hResourceIn,
    CLUS_SCSI_ADDRESS * pcsaOut,
    DWORD *             pdwSignatureOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    CClusPropValueList      cpvl;
    CLUSPROP_BUFFER_HELPER  cbhValue = { NULL };

    sc = TW32( cpvl.ScGetResourceValueList( hResourceIn, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = TW32( cpvl.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:


    for ( ; ; )
    {
        cbhValue = cpvl;

        switch ( cbhValue.pSyntax->dw )
        {
            case CLUSPROP_SYNTAX_PARTITION_INFO :
            {
                break;
            } // case: CLUSPROP_SYNTAX_PARTITION_INFO

            case CLUSPROP_SYNTAX_DISK_SIGNATURE :
            {
                *pdwSignatureOut = cbhValue.pDiskSignatureValue->dw;
                break;
            } // case: CLUSPROP_SYNTAX_DISK_SIGNATURE

            case CLUSPROP_SYNTAX_SCSI_ADDRESS :
            {
                pcsaOut->dw = cbhValue.pScsiAddressValue->dw;
                break;
            } // case: CLUSPROP_SYNTAXscSI_ADDRESS

            case CLUSPROP_SYNTAX_DISK_NUMBER :
            {
                break;
            } // case: CLUSPROP_SYNTAX_DISK_NUMBER

        } // switch:

        sc = cpvl.ScMoveToNextValue();
        if ( sc == ERROR_SUCCESS )
        {
            continue;
        } // if:

        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            break;
        } // if: error occurred moving to the next value

        TW32( sc );
        goto MakeHr;
    } // for:

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetClusterDiskInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrSetThisDiskToBeManaged
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrSetThisDiskToBeManaged(
      ULONG ulSCSITidIn
    , ULONG ulSCSILunIn
    , BOOL  fIsQuorumIn
    , BSTR  bstrResourceNameIn
    , DWORD dwSignatureIn
    )
{
    TraceFunc( "" );

    HRESULT                             hr = S_OK;
    ULONG                               idx;
    IUnknown *                          punk = NULL;
    IClusCfgManagedResourceInfo *       piccmri = NULL;
    WCHAR                               sz[ 64 ];
    BSTR                                bstrUID = NULL;
    DWORD                               dwSignature;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;

    _snwprintf( sz, ARRAYSIZE( sz ), L"SCSI Tid %ld, SCSI Lun %ld", ulSCSITidIn, ulSCSILunIn );

    //
    //  KB: 15-JUN-2000 GalenB
    //
    //  Find the disk that has the passes in TID and Lun and set it
    //  to be managed.
    //

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, &piccmri ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = THR( piccmri->GetUID( &bstrUID ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            TraceMemoryAddBSTR( bstrUID );

            if ( _wcsicmp( bstrUID, sz ) == 0 )
            {
                hr = THR( piccmri->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = THR( piccpdp->HrGetSignature( &dwSignature ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = THR( piccpdp->HrSetFriendlyName( bstrResourceNameIn ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                piccpdp->Release();
                piccpdp = NULL;

                //
                //  May want to do more with this later...
                //
                Assert( dwSignatureIn == dwSignature );

                hr = THR( piccmri->SetManaged( TRUE ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = THR( piccmri->SetQuorumedDevice( fIsQuorumIn ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                break;
            } // if:

            TraceSysFreeString( bstrUID );
            bstrUID = NULL;
            piccmri->Release();
            piccmri = NULL;
        } // if:
    } // for:

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    if ( piccmri != NULL )
    {
        piccmri->Release();
    } // if:

    TraceSysFreeString( bstrUID );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrSetThisDiskToBeManaged


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrFindDiskWithLogicalDisk
//
//  Description:
//      Find the disk with the passed in logical disk ID.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.  Found the disk.
//
//      S_FALSE
//          Success.  Did not find the disk.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrFindDiskWithLogicalDisk(
    WCHAR   cLogicalDiskIn,
    ULONG * pidxDiskOut
    )
{
    TraceFunc( "" );
    Assert( pidxDiskOut != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    ULONG                               idx;
    bool                                fFoundIt = false;
    IUnknown *                          punk;

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = STHR( piccpdp->IsThisLogicalDisk( cLogicalDiskIn ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( hr == S_OK )
            {
                fFoundIt = true;
                break;
            } // if:

            piccpdp->Release();
            piccpdp = NULL;
        } // if:
    } // for:

    if ( !fFoundIt )
    {
        hr = S_FALSE;
    } // if:

    if ( pidxDiskOut != NULL )
    {
        *pidxDiskOut = idx;
    } // if:

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrFindDiskWithLogicalDisk


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrGetSCSIInfo
//
//  Description:
//      Get the SCSI info for the disk at the passed in index.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetSCSIInfo(
    ULONG   idxDiskIn,
    ULONG * pulSCSIBusOut,
    ULONG * pulSCSIPortOut
    )
{
    TraceFunc( "" );
    Assert( pulSCSIBusOut != NULL );
    Assert( pulSCSIPortOut != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;

    hr = THR( ((*m_prgDisks)[ idxDiskIn ])->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccpdp->HrGetSCSIBus( pulSCSIBusOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccpdp->HrGetSCSIPort( pulSCSIPortOut ) );

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetSCSIInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrPruneDisks
//
//  Description:
//      Get the SCSI info for the disk at the passed in index.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrPruneDisks(
      ULONG     ulSCSIBusIn
    , ULONG     ulSCSIPortIn
    , ULONG *   pulRemovedOut
    , int       nMsgId
    )
{
    TraceFunc( "" );
    Assert( pulRemovedOut != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    ULONG                               idx;
    IUnknown *                          punk;
    ULONG                               ulSCSIBus;
    ULONG                               ulSCSIPort;
    ULONG                               cRemoved = 0;

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = THR( piccpdp->HrGetSCSIBus( &ulSCSIBus ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = THR( piccpdp->HrGetSCSIPort( &ulSCSIPort ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( ( ulSCSIBusIn == ulSCSIBus ) && ( ulSCSIPortIn == ulSCSIPort ) )
            {
                BSTR                            bstr = NULL;
                IClusCfgManagedResourceInfo *   piccmri = NULL;

                LogPrunedDisk( punk, ulSCSIBusIn, ulSCSIPortIn );

                THR( ((*m_prgDisks)[ idx ])->TypeSafeQI( IClusCfgManagedResourceInfo, &piccmri ) );
                THR( piccmri->GetName( &bstr ) );
                if ( piccmri != NULL )
                {
                    piccmri->Release();
                } // if:

                TraceMemoryAddBSTR( bstr );

                STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Pruned_Disk_From_Bus, nMsgId, bstr != NULL ? bstr : L"????", hr );
                RemoveDiskFromArray( idx );
                cRemoved++;
                TraceSysFreeString( bstr );
            } // if:

            piccpdp->Release();
            piccpdp = NULL;
        } // if:
    } // for:

    if ( pulRemovedOut != NULL )
    {
        *pulRemovedOut = cRemoved;
    } // if:

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrPruneDisks


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:LogPrunedDisk
//
//  Description:
//      Get the SCSI info for the disk at the passed in index.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEnumPhysicalDisks::LogPrunedDisk(
    IUnknown *  punkIn,
    ULONG       ulSCSIBusIn,
    ULONG       ulSCSIPortIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgManagedResourceInfo *       piccmri = NULL;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    BSTR                                bstrName = NULL;
    BSTR                                bstrUID = NULL;
    BSTR                                bstr = NULL;

    hr = THR( punkIn->TypeSafeQI( IClusCfgManagedResourceInfo, &piccmri ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( piccmri->GetUID( &bstrUID ) );
        piccmri->Release();
    } // if:

    if ( FAILED( hr ) )
    {
        bstrUID = TraceSysAllocString( L"<Unknown>" );
    } // if:
    else
    {
        TraceMemoryAddBSTR( bstrUID );
    } // else:

    hr = THR( punkIn->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( piccpdp->HrGetDeviceID( &bstrName ) );
        piccpdp->Release();
    } // if:

    if ( FAILED( hr ) )
    {
        bstrName = TraceSysAllocString( L"<Unknown>" );
    } // if:

    hr = THR( HrFormatStringIntoBSTR(
                  L"Pruning SCSI disk '%1!ws!', on Bus '%2!d!' and Port '%3!d!'; at '%4!ws!'"
                , &bstr
                , bstrName
                , ulSCSIBusIn
                , ulSCSIPortIn
                , bstrUID
                ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    LOG_STATUS_REPORT( bstr, hr );

Cleanup:

    TraceSysFreeString( bstrName );
    TraceSysFreeString( bstrUID );
    TraceSysFreeString( bstr );

    TraceFuncExit();

} //*** CEnumPhysicalDisks::LogPrunedDisk


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrIsLogicalDiskNTFS
//
//  Description:
//      Is the passed in logical disk NTFS?
//
//  Arguments:
//      bstrLogicalDiskIn
//
//  Return Value:
//      S_OK
//          The disk is NTFS.
//
//      S_FALSE
//          The disk is not NTFS.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrIsLogicalDiskNTFS( BSTR bstrLogicalDiskIn )
{
    TraceFunc1( "bstrLogicalDiskIn = '%ls'", bstrLogicalDiskIn == NULL ? L"<null>" : bstrLogicalDiskIn );
    Assert( bstrLogicalDiskIn != NULL );

    HRESULT             hr = S_OK;
    IWbemClassObject *  pLogicalDisk = NULL;
    BSTR                bstrPath = NULL;
    WCHAR               sz[ 64 ];
    VARIANT             var;
    size_t              cch;

    VariantInit( &var );

    cch = wcslen( bstrLogicalDiskIn );
    if ( cch > 3 )
    {
        hr = THR( E_INVALIDARG );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrIsLogicalDiskNTFS_InvalidArg, IDS_ERROR_INVALIDARG, hr );
        goto Cleanup;
    } // if:

    //
    //  truncate off any trailing \'s
    //
    if ( bstrLogicalDiskIn[ cch - 1 ] == L'\\' )
    {
        bstrLogicalDiskIn[ cch - 1 ] = '\0';
    } // if:

    //
    //  If we got just the logical disk without the trailing colon...
    //
    if ( wcslen( bstrLogicalDiskIn ) == 1 )
    {
        _snwprintf( sz, ARRAYSIZE( sz ), L"Win32_LogicalDisk.DeviceID=\"%s:\"", bstrLogicalDiskIn );
    } // if:
    else
    {
        _snwprintf( sz, ARRAYSIZE( sz ), L"Win32_LogicalDisk.DeviceID=\"%s\"", bstrLogicalDiskIn );
    } // else:

    bstrPath = TraceSysAllocString( sz );
    if ( bstrPath == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrIsLogicalDiskNTFS, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

    hr = THR( m_pIWbemServices->GetObject( bstrPath, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pLogicalDisk, NULL ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WMI_Get_LogicalDisk_Failed, IDS_ERROR_WMI_GET_LOGICALDISK_FAILED, bstrLogicalDiskIn, hr );
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pLogicalDisk, L"FileSystem", VT_BSTR, &var ) );
    if (FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    CharUpper( var.bstrVal );

    if ( wcscmp( var.bstrVal, L"NTFS" ) != 0 )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    if ( pLogicalDisk != NULL )
    {
        pLogicalDisk->Release();
    } // if:

    VariantClear( &var );

    TraceSysFreeString( bstrPath );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrIsLogicalDiskNTFS


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrLogDiskInfo
//
//  Description:
//      Write the info about this disk into the log.
//
//  Arguments:
//      pDiskIn
//
//  Return Value:
//      S_OK
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrLogDiskInfo( IWbemClassObject * pDiskIn )
{
    TraceFunc( "" );
    Assert( pDiskIn != NULL );

    HRESULT hr = S_OK;
    VARIANT varDeviceID;
    VARIANT varSCSIBus;
    VARIANT varSCSIPort;
    VARIANT varSCSILun;
    VARIANT varSCSITid;
    BSTR    bstr = NULL;

    VariantInit( &varDeviceID );
    VariantInit( &varSCSIBus );
    VariantInit( &varSCSIPort );
    VariantInit( &varSCSILun );
    VariantInit( &varSCSITid );

    hr = THR( HrGetWMIProperty( pDiskIn, L"DeviceID", VT_BSTR, &varDeviceID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( IsDiskSCSI( pDiskIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Disk is SCSI...
    //
    if ( hr == S_OK )
    {
        hr = THR( HrGetWMIProperty( pDiskIn, L"SCSIBus", VT_I4, &varSCSIBus ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( pDiskIn, L"SCSITargetId", VT_I4, &varSCSITid ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( pDiskIn, L"SCSILogicalUnit", VT_I4, &varSCSILun ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrGetWMIProperty( pDiskIn, L"SCSIPort", VT_I4, &varSCSIPort ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = THR( HrFormatStringIntoBSTR(
                      L"Found SCSI disk '%1!ws!' on Bus '%2!d!' and Port '%3!d!'; at TID '%4!d!' and LUN '%5!d!'"
                    , &bstr
                    , varDeviceID.bstrVal
                    , varSCSIBus.iVal
                    , varSCSIPort.iVal
                    , varSCSITid.iVal
                    , varSCSILun.iVal
                    ) );

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        LOG_STATUS_REPORT( bstr, hr );
    } // if:
    else
    {
        STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Found_Non_SCSI_Disk, IDS_ERROR_FOUND_NON_SCSI_DISK, varDeviceID.bstrVal, hr );
    } // else:

Cleanup:

    VariantClear( &varDeviceID );
    VariantClear( &varSCSIBus );
    VariantClear( &varSCSIPort );
    VariantClear( &varSCSILun );
    VariantClear( &varSCSITid );

    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrLogDiskInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrFindDiskWithWMIDeviceID
//
//  Description:
//      Find the disk with the passed in WMI device ID.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.  Found the disk.
//
//      S_FALSE
//          Success.  Did not find the disk.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrFindDiskWithWMIDeviceID(
    BSTR    bstrWMIDeviceIDIn,
    ULONG * pidxDiskOut
    )
{
    TraceFunc( "" );
    Assert( pidxDiskOut != NULL );

    HRESULT                             hr = S_OK;
    IClusCfgPhysicalDiskProperties *    piccpdp = NULL;
    ULONG                               idx;
    bool                                fFoundIt = false;
    IUnknown *                          punk;
    BSTR                                bstrDeviceID = NULL;

    for ( idx = 0; idx < m_idxNext; idx++ )
    {
        punk = (*m_prgDisks)[ idx ];                                                        // don't ref
        if ( punk != NULL )
        {
            hr = THR( punk->TypeSafeQI( IClusCfgPhysicalDiskProperties, &piccpdp ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            hr = STHR( piccpdp->HrGetDeviceID( &bstrDeviceID ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            if ( wcscmp( bstrWMIDeviceIDIn, bstrDeviceID ) == 0 )
            {
                fFoundIt = true;
                break;
            } // if:

            piccpdp->Release();
            piccpdp = NULL;

            TraceSysFreeString( bstrDeviceID );
            bstrDeviceID = NULL;
        } // if:
    } // for:

    if ( !fFoundIt )
    {
        hr = S_FALSE;
    } // if:

    if ( pidxDiskOut != NULL )
    {
        *pidxDiskOut = idx;
    } // if:

Cleanup:

    if ( piccpdp != NULL )
    {
        piccpdp->Release();
    } // if:

    TraceSysFreeString( bstrDeviceID );

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrFindDiskWithWMIDeviceID


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrIsSystemBusManaged
//
//  Description:
//      Is the system bus managed by the cluster service?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.  The system bus is managed.
//
//      S_FALSE
//          Success.  The system bus is not managed.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrIsSystemBusManaged( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    DWORD   sc;
    HKEY    hKey = NULL;
    DWORD   dwData;
    DWORD   cbData = sizeof( dwData );

    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SYSTEM\\CURRENTCONTROLSET\\SERVICES\\ClusSvc\\Parameters", 0, KEY_READ, &hKey );
    if ( sc == ERROR_FILE_NOT_FOUND )
    {
        goto Cleanup;       // not yet a cluster node.  Return S_FALSE.
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        TW32( sc );
        LogMsg( L"[SRV] RegOpenKeyEx() failed. (hr = %#08x)", hr );
        goto Win32Error;
    } // if:

    sc = RegQueryValueEx( hKey, L"ManageDisksOnSystemBuses", NULL, NULL, (LPBYTE) &dwData, &cbData );
    if ( sc == ERROR_FILE_NOT_FOUND )
    {
        goto Cleanup;       // value not found.  Return S_FALSE.
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        TW32( sc );
        LogMsg( L"[SRV] RegQueryValueEx() failed. (hr = %#08x)", hr );
        goto Win32Error;
    } // if:

    if ( dwData > 0 )
    {
        hr = S_OK;
    } // if:

    goto Cleanup;

Win32Error:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    } // if:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrIsSystemBusManaged


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks:HrGetClusterProperties
//
//  Description:
//      Return the asked for cluster properties.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrGetClusterProperties(
      HRESOURCE hResourceIn
    , BSTR *    pbstrResourceNameOut
    )
{
    TraceFunc( "" );
    Assert( pbstrResourceNameOut != NULL );

    HRESULT                 hr = S_OK;
    CClusPropList           cpl;
    CLUSPROP_BUFFER_HELPER  cpbh;
    DWORD                   sc;

    sc = TW32( cpl.ScGetResourceProperties( hResourceIn, CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    sc = TW32( cpl.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // if:

    cpbh = cpl.CbhCurrentValue();
    Assert( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    if ( ( cpbh.pStringValue->sz != NULL ) && ( wcscmp( cpbh.pStringValue->sz, L"" ) != 0 ) )
    {
        *pbstrResourceNameOut = TraceSysAllocString( cpbh.pStringValue->sz );
        if ( *pbstrResourceNameOut == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if:
    } // if:
    else
    {
        hr = THR( E_UNEXPECTED );
        LOG_STATUS_REPORT( L"The name of a physical disk resource was empty!", hr );
    } // else:

    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( sc );

Cleanup:

    HRETURN( hr );

} //*** CEnumPhysicalDisks::HrGetClusterProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::RemoveDiskFromArray
//
//  Description:
//      Release the disk at the specified index in the array and decrease the disk count.
//
//  Arguments:
//      idxDiskIn - the index of the disk to remove; must be less than the array size.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEnumPhysicalDisks::RemoveDiskFromArray( ULONG idxDiskIn )
{
    TraceFunc( "" );

    Assert( idxDiskIn < m_idxNext );

    ((*m_prgDisks)[ idxDiskIn ])->Release();
    (*m_prgDisks)[ idxDiskIn ] = NULL;

    m_cDiskCount -= 1;

    TraceFuncExit();

} //*** CEnumPhysicalDisks::RemoveDiskFromArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumPhysicalDisks::HrLoadEnum
//
//  Description:
//      Load the enum and filter out any devices that don't belong.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Other HRESULT errors.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumPhysicalDisks::HrLoadEnum( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    hr = THR( HrGetDisks() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrPruneSystemDisks() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = STHR( HrIsNodeClustered() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( HrFixupDisks() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    hr = S_OK;  // could have been S_FALSE

Cleanup:

    HRETURN( hr );

} //*** CEnumPysicalDisks::HrLoadEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cenumunknownquorum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CEnumUnknownQuorum.h
//
//  Description:
//      This file contains the declaration of the CEnumUnknownQuorum class.
//
//      The class CEnumUnknownQuorum is the enumeration of unknown cluster
//      storage devices. It implements the IEnumClusCfgManagedResources
//      interface.
//
//      Unknown quorum resources are "proxy" objects for quorum capable
//      devices that are not known to this setup wizard.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumUnknownQuorum.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 10-MAY-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "CClusterUtils.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumUnknownQuorum
//
//  Description:
//      The class CEnumUnknownQuorum is the enumeration of unknown cluster
//      quorum devices.
//
//  Interfaces:
//      IEnumClusCfgManagedResources
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumUnknownQuorum
    : public IEnumClusCfgManagedResources
    , public IClusCfgInitialize
{
private:
    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fEnumLoaded:1;
    IUnknown *          ((*m_prgQuorums)[]);
    ULONG               m_idxNext;
    ULONG               m_idxEnumNext;
    BSTR                m_bstrNodeName;
    BOOL                m_fDefaultDeviceToQuorum;
    BSTR                m_bstrQuorumResourceName;

    // Private constructors and destructors
    CEnumUnknownQuorum( void );
    ~CEnumUnknownQuorum( void );

    // Private copy constructor to prevent copying.
    CEnumUnknownQuorum( const CEnumUnknownQuorum & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumUnknownQuorum & operator = ( const CEnumUnknownQuorum & nodeSrc );

    HRESULT HrInit( BSTR bstrNameIn, BOOL fMakeQuorumIn = FALSE );
    HRESULT HrAddResourceToArray( IUnknown * punkIn );
    HRESULT HrCreateDummyObject( void );

public:
    //
    // IUnknown Interfaces
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IEnumClusCfgManagedResources Interfaces
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgManagedResourceInfo ** rgpManagedResourceInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumClusCfgStorageDevicesOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance( BSTR bstrNameIn, BOOL fMakeQuorumIn, IUnknown ** ppunkOut );

    //static HRESULT S_RegisterCatIDSupport( ICatRegister * picrIn, BOOL fCreateIn );

}; //*** Class CEnumUnknownQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cluscfgserverguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusCfgServerGuids.h
//
//  Description:
//      This file contains the guids used in ClusCfgServer.
//
//  Documentation:
//
//  Maintained By:
//      Galen Barbee (GalenB) 17-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <InitGuid.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


// {39371CBA-A47B-4a4f-9042-6BECD321E9E2}
DEFINE_GUID( TASKID_Minor_Server_Initialized,
0x39371cba, 0xa47b, 0x4a4f, 0x90, 0x42, 0x6b, 0xec, 0xd3, 0x21, 0xe9, 0xe2 );

// {77566663-68F1-4b47-9F2C-74D3680F1F4D}
DEFINE_GUID( TASKID_Minor_Get_Cluster_Name,
0x77566663, 0x68f1, 0x4b47, 0x9f, 0x2c, 0x74, 0xd3, 0x68, 0xf, 0x1f, 0x4d );

// {51DE9439-C518-4932-83DD-BEA50A0539E5}
DEFINE_GUID( TASKID_Minor_Get_Cluster_IP_Address,
0x51de9439, 0xc518, 0x4932, 0x83, 0xdd, 0xbe, 0xa5, 0xa, 0x5, 0x39, 0xe5 );

// {44F2EB6A-F6BC-44da-A7A6-5D43E1883861}
DEFINE_GUID( TASKID_Minor_Get_Cluster_IP_Subnet,
0x44f2eb6a, 0xf6bc, 0x44da, 0xa7, 0xa6, 0x5d, 0x43, 0xe1, 0x88, 0x38, 0x61 );

// {08FFC4AA-AA98-40b1-8606-5EB444E5B232}
DEFINE_GUID( TASKID_Minor_Get_Cluster_Networks,
0x8ffc4aa, 0xaa98, 0x40b1, 0x86, 0x6, 0x5e, 0xb4, 0x44, 0xe5, 0xb2, 0x32 );

// {9C751C40-DA64-45ea-9C96-1A50EA03A8E7}
DEFINE_GUID( TASKID_Minor_IP_Address_Subnet_Count_Unequal,
0x9c751c40, 0xda64, 0x45ea, 0x9c, 0x96, 0x1a, 0x50, 0xea, 0x3, 0xa8, 0xe7 );

// {9321731F-62D4-4730-9A9D-52D148F34367}
DEFINE_GUID( TASKID_Minor_Primary_IP_Address,
0x9321731f, 0x62d4, 0x4730, 0x9a, 0x9d, 0x52, 0xd1, 0x48, 0xf3, 0x43, 0x67 );

// {29A0C6AD-476D-4464-9A6D-4784982EC504}
DEFINE_GUID( TASKID_Minor_Set_Credentials,
0x29a0c6ad, 0x476d, 0x4464, 0x9a, 0x6d, 0x47, 0x84, 0x98, 0x2e, 0xc5, 0x4 );

// {DE5F2F90-A0C6-4f88-BB86-A351A1808797}
DEFINE_GUID( TASKID_Minor_WMI_OS_Qry_Failed,
0xde5f2f90, 0xa0c6, 0x4f88, 0xbb, 0x86, 0xa3, 0x51, 0xa1, 0x80, 0x87, 0x97 );

// {D2094BA7-E41E-44be-AE2B-5F8A177FA31C}
DEFINE_GUID( TASKID_Minor_WMI_Logical_Disks_Qry_Failed,
0xd2094ba7, 0xe41e, 0x44be, 0xae, 0x2b, 0x5f, 0x8a, 0x17, 0x7f, 0xa3, 0x1c );

// {5622150D-ADC3-4371-926C-29B2533B50B7}
DEFINE_GUID( TASKID_Minor_WMI_PageFile_Qry_Failed,
0x5622150d, 0xadc3, 0x4371, 0x92, 0x6c, 0x29, 0xb2, 0x53, 0x3b, 0x50, 0xb7 );

// {81EF1C38-1C1C-4e60-A816-D91E0E631FC9}
DEFINE_GUID( TASKID_Minor_WMI_Phys_Disks_Qry_Failed,
0x81ef1c38, 0x1c1c, 0x4e60, 0xa8, 0x16, 0xd9, 0x1e, 0xe, 0x63, 0x1f, 0xc9 );

// {8D4696F2-5855-46d5-9F70-F5E62E5CF9B9}
DEFINE_GUID( TASKID_Minor_Phys_Disk_No_File_System,
0x8d4696f2, 0x5855, 0x46d5, 0x9f, 0x70, 0xf5, 0xe6, 0x2e, 0x5c, 0xf9, 0xb9 );

// {B19E1F71-E040-49c8-AAE7-E89C3812823C8}
DEFINE_GUID( TASKID_Minor_Connection_Verification_Failed,
0xb19e1f71, 0xe040, 0x49c8, 0xaa, 0xe7, 0xe8, 0x9c, 0x38, 0x12, 0x82, 0x3c );

// {74A42186-C180-4260-82B7-18A702115562}
DEFINE_GUID( TASKID_Minor_Phys_Disk_Not_NTFS,
0x74a42186, 0xc180, 0x4260, 0x82, 0xb7, 0x18, 0xa7, 0x2, 0x11, 0x55, 0x62 );

// {C525FFFC-F613-4b6a-88D2-600F30134E56}
DEFINE_GUID( TASKID_Minor_WMI_NetworkAdapterSetting_Qry_Failed,
0xc525fffc, 0xf613, 0x4b6a, 0x88, 0xd2, 0x60, 0xf, 0x30, 0x13, 0x4e, 0x56 );

// {088D6F8B-CCD4-4d0c-9BBD-9C2C730B00FB}
DEFINE_GUID( TASKID_Minor_WMI_NetworkAdapter_Qry_Failed,
0x88d6f8b, 0xccd4, 0x4d0c, 0x9b, 0xbd, 0x9c, 0x2c, 0x73, 0xb, 0x0, 0xfb );

// {9DE3F291-6C9A-4a88-860B-0FE383EAF871}
DEFINE_GUID( TASKID_Minor_WMI_DiskDrivePartitions_Qry_Failed,
0x9de3f291, 0x6c9a, 0x4a88, 0x86, 0xb, 0xf, 0xe3, 0x83, 0xea, 0xf8, 0x71 );

// {182D2408-3605-4092-9C18-EC3944F75FB7}
DEFINE_GUID( TASKID_Minor_WBEM_Connection_Failure,
0x182d2408, 0x3605, 0x4092, 0x9c, 0x18, 0xec, 0x39, 0x44, 0xf7, 0x5f, 0xb7 );

// {F6B12EAF-E085-49d0-9976-DAC721DC5421}
DEFINE_GUID( TASKID_Minor_Boot_Partition_Not_NTFS,
0xf6b12eaf, 0xe085, 0x49d0, 0x99, 0x76, 0xda, 0xc7, 0x21, 0xdc, 0x54, 0x21 );

// {0A94106C-BA56-48d9-9C46-302F8A05ED68}
DEFINE_GUID( TASKID_Minor_WMI_Get_LogicalDisk_Failed,
0xa94106c, 0xba56, 0x48d9, 0x9c, 0x46, 0x30, 0x2f, 0x8a, 0x5, 0xed, 0x68 );

// {6FFDCC63-4C9E-41cb-B8BA-0939266751F2}
DEFINE_GUID( TASKID_Minor_WMI_NetworkAdapter_Dupe_Found,
0x6ffdcc63, 0x4c9e, 0x41cb, 0xb8, 0xba, 0x9, 0x39, 0x26, 0x67, 0x51, 0xf2 );

// {2FAB8C32-5A40-4453-838F-1AF740200F90}
DEFINE_GUID( TASKID_Minor_Server_GetClusterNodeInfo,
0x2fab8c32, 0x5a40, 0x4453, 0x83, 0x8f, 0x1a, 0xf7, 0x40, 0x20, 0xf, 0x90 );

// {B460EA73-6223-44fa-84E0-DE7EC069DDD4}
DEFINE_GUID( TASKID_Minor_Server_GetClusterInfo,
0xb460ea73, 0x6223, 0x44fa, 0x84, 0xe0, 0xde, 0x7e, 0xc0, 0x69, 0xdd, 0xd4 );

// {C9C1154E-067D-45f5-B348-42B9B395C864}
DEFINE_GUID( TASKID_Minor_Server_GetManagedResourcesEnum,
0xc9c1154e, 0x67d, 0x45f5, 0xb3, 0x48, 0x42, 0xb9, 0xb3, 0x95, 0xc8, 0x64 );

// {7D7F8A19-FE6E-4cb2-93C9-213A933BA0FF}
DEFINE_GUID( TASKID_Minor_Server_GetNetworksEnum,
0x7d7f8a19, 0xfe6e, 0x4cb2, 0x93, 0xc9, 0x21, 0x3a, 0x93, 0x3b, 0xa0, 0xff );

// {03D177A6-2AE5-429e-B7FE-1A7D1C98A44B}
DEFINE_GUID( TASKID_Minor_Server_CommitChanges,
0x3d177a6, 0x2ae5, 0x429e, 0xb7, 0xfe, 0x1a, 0x7d, 0x1c, 0x98, 0xa4, 0x4b );

// {8028BF97-2D57-4628-845D-C4BEFFEB531A}
DEFINE_GUID( TASKID_Minor_Node_Down,
0x8028bf97, 0x2d57, 0x4628, 0x84, 0x5d, 0xc4, 0xbe, 0xff, 0xeb, 0x53, 0x1a );

// {2131E2D7-E683-43ba-B220-48ADA80EE0DA}
DEFINE_GUID( TASKID_Minor_MREnum_Negative_Item_Count,
0x2131e2d7, 0xe683, 0x43ba, 0xb2, 0x20, 0x48, 0xad, 0xa8, 0xe, 0xe0, 0xda );

// {2243D619-9869-4f3e-A989-CE476198FC20}
DEFINE_GUID( TASKID_Minor_MREnum_Unknown_State,
0x2243d619, 0x9869, 0x4f3e, 0xa9, 0x89, 0xce, 0x47, 0x61, 0x98, 0xfc, 0x20 );

// {4B3892D7-7459-491e-A92E-376701494B65}
DEFINE_GUID( TASKID_Minor_PhysDisk_No_Partitions,
0x4b3892d7, 0x7459, 0x491e, 0xa9, 0x2e, 0x37, 0x67, 0x1, 0x49, 0x4b, 0x65 );

// {65FFF9F6-3555-4c58-A1FE-917F3A62EBEC}
DEFINE_GUID( TASKID_Minor_PhysDisk_Signature,
0x65fff9f6, 0x3555, 0x4c58, 0xa1, 0xfe, 0x91, 0x7f, 0x3a, 0x62, 0xeb, 0xec );

// {65383B52-FD86-4ca3-96BB-B7E4E09F0C27}
DEFINE_GUID( TASKID_Minor_GetClusterServiceAccountCredentials,
0x65383b52, 0xfd86, 0x4ca3, 0x96, 0xbb, 0xb7, 0xe4, 0xe0, 0x9f, 0xc, 0x27 );

// {BC8E26E5-B499-4aba-AD64-291A286EE5EA}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Cluster,
0xbc8e26e5, 0xb499, 0x4aba, 0xad, 0x64, 0x29, 0x1a, 0x28, 0x6e, 0xe5, 0xea );

// {E7D3F142-D928-4b8d-B6D3-3ABA805DD3E3}
DEFINE_GUID( TASKID_Minor_ClusterInfo_GetName_Pointer,
0xe7d3f142, 0xd928, 0x4b8d, 0xb6, 0xd3, 0x3a, 0xba, 0x80, 0x5d, 0xd3, 0xe3 );

// {45BF7AAA-812F-4a09-83E5-A0B654DB03D7}
DEFINE_GUID( TASKID_Minor_GetName_Memory,
0x45bf7aaa, 0x812f, 0x4a09, 0x83, 0xe5, 0xa0, 0xb6, 0x54, 0xdb, 0x3, 0xd7 );

// {6091A69B-9327-4bb6-AE54-25042BEB124C}
DEFINE_GUID( TASKID_Minor_GetIPAddress,
0x6091a69b, 0x9327, 0x4bb6, 0xae, 0x54, 0x25, 0x4, 0x2b, 0xeb, 0x12, 0x4c );

// {E46F5916-28A6-4aaf-B323-F7194ED4B13C}
DEFINE_GUID( TASKID_Minor_ClusterInfo_GetSubnetMask,
0xe46f5916, 0x28a6, 0x4aaf, 0xb3, 0x23, 0xf7, 0x19, 0x4e, 0xd4, 0xb1, 0x3c );

// {C822E5F8-D703-4726-87A3-C31242DE6DAE}
DEFINE_GUID(TASKID_Minor_GetNetworkInfo,
0xc822e5f8, 0xd703, 0x4726, 0x87, 0xa3, 0xc3, 0x12, 0x42, 0xde, 0x6d, 0xae );

// {CB418AD6-2A16-4b96-88C8-D6F1CAC5D760}
DEFINE_GUID(TASKID_Minor_Initialize,
0xcb418ad6, 0x2a16, 0x4b96, 0x88, 0xc8, 0xd6, 0xf1, 0xca, 0xc5, 0xd7, 0x60 );

// {746D5BBE-1BF2-48f5-9A5F-069C90937435}
DEFINE_GUID( TASKID_Minor_SetName_Cluster,
0x746d5bbe, 0x1bf2, 0x48f5, 0x9a, 0x5f, 0x6, 0x9c, 0x90, 0x93, 0x74, 0x35 );

// {8FFF1861-CC27-4be6-9024-FA90F5559593}
DEFINE_GUID( TASKID_Minor_HrInit,
0x8fff1861, 0xcc27, 0x4be6, 0x90, 0x24, 0xfa, 0x90, 0xf5, 0x55, 0x95, 0x93 );

// {13CF2484-3997-496a-B8AB-E6E135AAC54F}
DEFINE_GUID( TASKID_Minor_Cluster_Network_Not_Found,
0x13cf2484, 0x3997, 0x496a, 0xb8, 0xab, 0xe6, 0xe1, 0x35, 0xaa, 0xc5, 0x4f );

// {BC37101F-AF06-4dcc-AFF4-CDA6EA103641}
DEFINE_GUID( TASKID_Minor_HrGetIPAddressInfo,
0xbc37101f, 0xaf06, 0x4dcc, 0xaf, 0xf4, 0xcd, 0xa6, 0xea, 0x10, 0x36, 0x41 );

// {6338E0C3-ECAB-4a4e-9ED1-3EE53B30AF8E}
DEFINE_GUID( TASKID_Minor_HrIsResourceOfType,
0x6338e0c3, 0xecab, 0x4a4e, 0x9e, 0xd1, 0x3e, 0xe5, 0x3b, 0x30, 0xaf, 0x8e );

// {F0BDA809-6250-4e85-A0C1-5A70334AA791}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials,
0xf0bda809, 0x6250, 0x4e85, 0xa0, 0xc1, 0x5a, 0x70, 0x33, 0x4a, 0xa7, 0x91 );

// {147D8FBD-73EA-4d3e-8F0E-ADE480B27691}
DEFINE_GUID( TASKID_Minor_Dotted_Quad_Failed,
0x147d8fbd, 0x73ea, 0x4d3e, 0x8f, 0xe, 0xad, 0xe4, 0x80, 0xb2, 0x76, 0x91 );

// {BDBE3962-E687-466a-99D9-00CF43B71C3F}
DEFINE_GUID( TASKID_Minor_SetWbemServices_IPAddress,
0xbdbe3962, 0xe687, 0x466a, 0x99, 0xd9, 0x0, 0xcf, 0x43, 0xb7, 0x1c, 0x3f );

// {40A8D255-75A9-4034-B821-26AD8F83F1C3}
DEFINE_GUID( TASKID_Minor_IPAddressInfo_GetUID_Pointer,
0x40a8d255, 0x75a9, 0x4034, 0xb8, 0x21, 0x26, 0xad, 0x8f, 0x83, 0xf1, 0xc3 );

// {26125CAB-DCBD-4da1-9D27-EB2433761DB4}
DEFINE_GUID( TASKID_Minor_IPAddressInfo_GetUID_Memory,
0x26125cab, 0xdcbd, 0x4da1, 0x9d, 0x27, 0xeb, 0x24, 0x33, 0x76, 0x1d, 0xb4 );

// {B04D9500-7FC1-40a3-B89E-80E4049E4276}
DEFINE_GUID( TASKID_Minor_GetNetworkGetIPAddress,
0xb04d9500, 0x7fc1, 0x40a3, 0xb8, 0x9e, 0x80, 0xe4, 0x4, 0x9e, 0x42, 0x76 );

// {96C933C5-FBE3-4bdc-B733-55CB692B173D}
DEFINE_GUID( TASKID_Minor_GetSubnetMask,
0x96c933c5, 0xfbe3, 0x4bdc, 0xb7, 0x33, 0x55, 0xcb, 0x69, 0x2b, 0x17, 0x3d );

// {BECE32B7-42BC-4abf-AA1B-4BADFAA1D0FA}
DEFINE_GUID( TASKID_Minor_HrMakeDottedQuad,
0xbece32b7, 0x42bc, 0x4abf, 0xaa, 0x1b, 0x4b, 0xad, 0xfa, 0xa1, 0xd0, 0xfa );

// {91E0CD89-ED0B-4192-AED2-71F1479AA15A}
DEFINE_GUID( TASKID_Minor_HrGetUID,
0x91e0cd89, 0xed0b, 0x4192, 0xae, 0xd2, 0x71, 0xf1, 0x47, 0x9a, 0xa1, 0x5a );

// {C1ABE5C8-CF87-4178-AFF6-15456E242FD0}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Network,
0xc1abe5c8, 0xcf87, 0x4178, 0xaf, 0xf6, 0x15, 0x45, 0x6e, 0x24, 0x2f, 0xd0 );

// {A9D606CD-F87C-4183-939B-54BB9B5B9EB1}
DEFINE_GUID( TASKID_Minor_GetUID,
0xa9d606cd, 0xf87c, 0x4183, 0x93, 0x9b, 0x54, 0xbb, 0x9b, 0x5b, 0x9e, 0xb1 );

// {29A3E6CA-9838-4519-AABD-B16FE063A8BC}
DEFINE_GUID( TASKID_Minor_NetworkInfo_GetName_Pointer,
0x29a3e6ca, 0x9838, 0x4519, 0xaa, 0xbd, 0xb1, 0x6f, 0xe0, 0x63, 0xa8, 0xbc );

// {8EB6CA47-666F-4a41-9AF4-8A5465B68A8D}
DEFINE_GUID( TASKID_Minor_ClusterInfo_GetName_Memory,
0x8eb6ca47, 0x666f, 0x4a41, 0x9a, 0xf4, 0x8a, 0x54, 0x65, 0xb6, 0x8a, 0x8d );

// {4A4CC86D-58A9-4b95-8C79-5A4334E536C0}
DEFINE_GUID( TASKID_Minor_NetworkInfo_GetDescription_Pointer,
0x4a4cc86d, 0x58a9, 0x4b95, 0x8c, 0x79, 0x5a, 0x43, 0x34, 0xe5, 0x36, 0xc0 );

// {2D233574-D980-4b0d-B035-CA74938C4D3E}
DEFINE_GUID( TASKID_Minor_NetworkInfo_GetDescription_Memory,
0x2d233574, 0xd980, 0x4b0d, 0xb0, 0x35, 0xca, 0x74, 0x93, 0x8c, 0x4d, 0x3e );

// {10FFDFA2-B540-4116-BD93-BBE77D3657F0}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress,
0x10ffdfa2, 0xb540, 0x4116, 0xbd, 0x93, 0xbb, 0xe7, 0x7d, 0x36, 0x57, 0xf0 );

// {F5704679-2329-4304-A628-66678D9FE154}
DEFINE_GUID( TASKID_Minor_SetWbemObject_Network,
0xf5704679, 0x2329, 0x4304, 0xa6, 0x28, 0x66, 0x67, 0x8d, 0x9f, 0xe1, 0x54 );

// {C1ABE5C8-CF87-4178-AFF6-15456E242FD1}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Node,
0xc1abe5c8, 0xcf87, 0x4178, 0xaf, 0xf6, 0x15, 0x45, 0x6e, 0x24, 0x2f, 0xd1 );

// {29A3E6CA-9838-4519-AABD-B16FE063A8BD}
DEFINE_GUID( TASKID_Minor_NodeInfo_GetName_Pointer,
0x29a3e6ca, 0x9838, 0x4519, 0xaa, 0xbd, 0xb1, 0x6f, 0xe0, 0x63, 0xa8, 0xbd );

// {9F035786-7EA1-486f-A6C6-3FAF2E0B7717}
DEFINE_GUID( TASKID_Minor_NetworkInfo_GetName_Memory,
0x9f035786, 0x7ea1, 0x486f, 0xa6, 0xc6, 0x3f, 0xaf, 0x2e, 0xb, 0x77, 0x17 );

// {008D9491-6D33-43f6-B4E5-09AA3E88920A}
DEFINE_GUID( TASKID_Minor_GetClusterConfigInfo,
0x8d9491, 0x6d33, 0x43f6, 0xb4, 0xe5, 0x9, 0xaa, 0x3e, 0x88, 0x92, 0xa );

// {3131B7BA-91BC-424d-BE88-053A0855255F}
DEFINE_GUID( TASKID_Minor_GetClusterVersion,
0x3131b7ba, 0x91bc, 0x424d, 0xbe, 0x88, 0x5, 0x3a, 0x8, 0x55, 0x25, 0x5f );

// {C6AC35F0-E19E-4caf-83FC-148A6D73E8BC}
DEFINE_GUID( TASKID_Minor_GetOSVersion,
0xc6ac35f0, 0xe19e, 0x4caf, 0x83, 0xfc, 0x14, 0x8a, 0x6d, 0x73, 0xe8, 0xbc );

// {36826AEC-2259-4dd5-8142-429A6CA09C6E}
DEFINE_GUID( TASKID_Minor_GetDriveLetterMappings_Node,
0x36826aec, 0x2259, 0x4dd5, 0x81, 0x42, 0x42, 0x9a, 0x6c, 0xa0, 0x9c, 0x6e );

// {C1ABE5C8-CF87-4178-AFF6-15456E242FD2}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Partition,
0xc1abe5c8, 0xcf87, 0x4178, 0xaf, 0xf6, 0x15, 0x45, 0x6e, 0x24, 0x2f, 0xd2 );

// {A9D606CD-F87C-4183-939B-54BB9B5B9EB2}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetUID_Pointer,
0xa9d606cd, 0xf87c, 0x4183, 0x93, 0x9b, 0x54, 0xbb, 0x9b, 0x5b, 0x9e, 0xb2 );

// {918FAB6C-FD35-4cd3-95AB-01FBFF0089D8}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetUID_Memory,
0x918fab6c, 0xfd35, 0x4cd3, 0x95, 0xab, 0x1, 0xfb, 0xff, 0x0, 0x89, 0xd8 );

// {656C7BCE-E1B0-4a1f-8F34-6726AAF16A64}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetName_Pointer,
0x656c7bce, 0xe1b0, 0x4a1f, 0x8f, 0x34, 0x67, 0x26, 0xaa, 0xf1, 0x6a, 0x64 );

// {337CF23A-5592-4658-A029-42EFDD3817F1}
DEFINE_GUID( TASKID_Minor_Node_Info_GetName_Memory,
0x337cf23a, 0x5592, 0x4658, 0xa0, 0x29, 0x42, 0xef, 0xdd, 0x38, 0x17, 0xf1 );

// {F45E0464-5DCB-45f0-9937-599AF9B9651A}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetDescription_Pointer,
0xf45e0464, 0x5dcb, 0x45f0, 0x99, 0x37, 0x59, 0x9a, 0xf9, 0xb9, 0x65, 0x1a );

// {4BC98FAF-C050-4c0f-8FC5-BA91A861DCD2}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetDescription_Memory,
0x4bc98faf, 0xc050, 0x4c0f, 0x8f, 0xc5, 0xba, 0x91, 0xa8, 0x61, 0xdc, 0xd2 );

// {D00C1BB1-D028-411e-8A0E-05E3B6880BFA}
DEFINE_GUID( TASKID_Minor_GetDriveLetterMappings_Partition,
0xd00c1bb1, 0xd028, 0x411e, 0x8a, 0xe, 0x5, 0xe3, 0xb6, 0x88, 0xb, 0xfa );

// {86C56A21-94D1-4e63-833F-65FA6BAE9A0A}
DEFINE_GUID( TASKID_Minor_GetSize,
0x86c56a21, 0x94d1, 0x4e63, 0x83, 0x3f, 0x65, 0xfa, 0x6b, 0xae, 0x9a, 0xa );

// {CD1F6FD1-6B40-4b28-AE51-A872837FA966}
DEFINE_GUID( TASKID_Minor_GetFriendlyName,
0xcd1f6fd1, 0x6b40, 0x4b28, 0xae, 0x51, 0xa8, 0x72, 0x83, 0x7f, 0xa9, 0x66 );

// {D88AE9D6-FF82-4836-8949-7AAD1D364E2A}
DEFINE_GUID( TASKID_Minor_SetWbemObject_Partition,
0xd88ae9d6, 0xff82, 0x4836, 0x89, 0x49, 0x7a, 0xad, 0x1d, 0x36, 0x4e, 0x2a );

// {123A6334-CB39-4a6d-9250-6F81D5DC91F7}
DEFINE_GUID( TASKID_Minor_HrAddLogicalDiskToArray,
0x123a6334, 0xcb39, 0x4a6d, 0x92, 0x50, 0x6f, 0x81, 0xd5, 0xdc, 0x91, 0xf7 );

// {12BC9977-5682-4e1d-94E8-7EA2FD396C39}
DEFINE_GUID( TASKID_Minor_HrGetLogicalDisks,
0x12bc9977, 0x5682, 0x4e1d, 0x94, 0xe8, 0x7e, 0xa2, 0xfd, 0x39, 0x6c, 0x39 );

// {4EA6D4FA-F3EF-467d-8666-581E0DCFCA5B}
DEFINE_GUID( TASKID_Minor_HrGetLogicalDisks_Next,
0x4ea6d4fa, 0xf3ef, 0x467d, 0x86, 0x66, 0x58, 0x1e, 0xd, 0xcf, 0xca, 0x5b );

// {7BC914C6-2373-48c4-A6C0-44F99B2712E7}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo,
0x7bc914c6, 0x2373, 0x48c4, 0xa6, 0xc0, 0x44, 0xf9, 0x9b, 0x27, 0x12, 0xe7 );

// {5DE6DDA4-5A3B-4fec-8C15-2AB3078DE738}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum,
0x5de6dda4, 0x5a3b, 0x4fec, 0x8c, 0x15, 0x2a, 0xb3, 0x7, 0x8d, 0xe7, 0x38 );

// {A4CDC2C6-ED7E-4cec-AF8C-0E8C079E7152}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum,
0xa4cdc2c6, 0xed7e, 0x4cec, 0xaf, 0x8c, 0xe, 0x8c, 0x7, 0x9e, 0x71, 0x52 );

// {966B1F9E-EB52-493e-870D-2639C4DE8457}
DEFINE_GUID( TASKID_Minor_GetCallback,
0x966b1f9e, 0xeb52, 0x493e, 0x87, 0xd, 0x26, 0x39, 0xc4, 0xde, 0x84, 0x57 );

// {E7BB178B-02F3-4837-9BAA-1CEED04DC42A}
DEFINE_GUID( TASKID_Minor_VerifyConnection_Memory,
0xe7bb178b, 0x2f3, 0x4837, 0x9b, 0xaa, 0x1c, 0xee, 0xd0, 0x4d, 0xc4, 0x2a );

// {4CB71CC5-16F3-47fb-A1FC-60A4C09BAA58}
DEFINE_GUID( TASKID_Minor_VerifyConnection_OpenCluster,
0x4cb71cc5, 0x16f3, 0x47fb, 0xa1, 0xfc, 0x60, 0xa4, 0xc0, 0x9b, 0xaa, 0x58 );

// {A3A57A39-24DD-4ab6-B1AB-2E71BD396C7B}
DEFINE_GUID( TASKID_Minor_VerifyConnection_InvalidArg,
0xa3a57a39, 0x24dd, 0x4ab6, 0xb1, 0xab, 0x2e, 0x71, 0xbd, 0x39, 0x6c, 0x7b );

// {EEEF01F8-3D6B-42f9-8763-1FA881C9959D}
DEFINE_GUID( TASKID_Minor_HrInitializeForLocalServer_Memory,
0xeeef01f8, 0x3d6b, 0x42f9, 0x87, 0x63, 0x1f, 0xa8, 0x81, 0xc9, 0x95, 0x9d );

// {597670A6-D96E-4d95-BB8F-97A88ECFC953}
DEFINE_GUID( TASKID_Minor_HrInitializeForLocalServer_WbemLocator,
0x597670a6, 0xd96e, 0x4d95, 0xbb, 0x8f, 0x97, 0xa8, 0x8e, 0xcf, 0xc9, 0x53 );

// {A6BC72B1-7317-40b0-A612-471F7551B5A1}
DEFINE_GUID( TASKID_Minor_HrInitializeForLocalServer_Blanket,
0xa6bc72b1, 0x7317, 0x40b0, 0xa6, 0x12, 0x47, 0x1f, 0x75, 0x51, 0xb5, 0xa1 );

// {9C8BA2D8-2713-4850-9A0B-4CCD809009F7}
DEFINE_GUID( TASKID_Minor_Non_Tcp_Config,
0x9c8ba2d8, 0x2713, 0x4850, 0x9a, 0xb, 0x4c, 0xcd, 0x80, 0x90, 0x9, 0xf7 );

// {35C1FB29-7D40-476a-9D97-ABB84D3DBF11}
DEFINE_GUID( TASKID_Minor_WQL_Qry_Next_Failed,
0x35c1fb29, 0x7d40, 0x476a, 0x9d, 0x97, 0xab, 0xb8, 0x4d, 0x3d, 0xbf, 0x11 );

// {33EEE6E0-58A7-498f-8321-59B6B6ABDB81}
DEFINE_GUID( TASKID_Minor_No_Valid_TCP_Configs,
0x33eee6e0, 0x58a7, 0x498f, 0x83, 0x21, 0x59, 0xb6, 0xb6, 0xab, 0xdb, 0x81 );

// {B69B25B7-081E-470a-BB2A-63C7B7980EA1}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Enum_IPAddresses,
0xb69b25b7, 0x81e, 0x470a, 0xbb, 0x2a, 0x63, 0xc7, 0xb7, 0x98, 0xe, 0xa1 );

// {30909859-D9FC-4dac-8B97-B66551F5587E}
DEFINE_GUID( TASKID_Minor_Next_Enum_IPAddresses,
0x30909859, 0xd9fc, 0x4dac, 0x8b, 0x97, 0xb6, 0x65, 0x51, 0xf5, 0x58, 0x7e );

// {4F4E0DDA-AA44-43bf-9846-DAF244D9AA9C}
DEFINE_GUID( TASKID_Minor_Clone_Enum_IPAddresses,
0x4f4e0dda, 0xaa44, 0x43bf, 0x98, 0x46, 0xda, 0xf2, 0x44, 0xd9, 0xaa, 0x9c );

// {7A1DC74B-3C66-44d8-939E-78FD780B31CF}
DEFINE_GUID( TASKID_Minor_HrGetAdapterConfiguration,
0x7a1dc74b, 0x3c66, 0x44d8, 0x93, 0x9e, 0x78, 0xfd, 0x78, 0xb, 0x31, 0xcf );

// {08CA442E-A437-4c58-8ABD-2FBC09B5B575}
DEFINE_GUID( TASKID_Minor_HrAddIPAddressToArray,
0x8ca442e, 0xa437, 0x4c58, 0x8a, 0xbd, 0x2f, 0xbc, 0x9, 0xb5, 0xb5, 0x75 );

// {34F97A27-F0CE-4525-8298-18BADFEF58ED}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Enum_Resources,
0x34f97a27, 0xf0ce, 0x4525, 0x82, 0x98, 0x18, 0xba, 0xdf, 0xef, 0x58, 0xed );

// {AFAEA77E-FE81-452e-8D01-96323ACF86B8}
DEFINE_GUID( TASKID_Minor_Next_Enum_Resources,
0xafaea77e, 0xfe81, 0x452e, 0x8d, 0x1, 0x96, 0x32, 0x3a, 0xcf, 0x86, 0xb8 );

// {419DCE7E-A369-494d-AD66-93F2318BAE2D}
DEFINE_GUID( TASKID_Minor_Clone_Enum_Resources,
0x419dce7e, 0xa369, 0x494d, 0xad, 0x66, 0x93, 0xf2, 0x31, 0x8b, 0xae, 0x2d );

// {AD0F7066-3193-4956-AB29-FD1A679974C5}
DEFINE_GUID( TASKID_Minor_HrAddToProvidersArray,
0xad0f7066, 0x3193, 0x4956, 0xab, 0x29, 0xfd, 0x1a, 0x67, 0x99, 0x74, 0xc5 );

// {462DBC4C-4FC6-41ef-88CC-2DCE39F51EA2}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Enum_Networks,
0x462dbc4c, 0x4fc6, 0x41ef, 0x88, 0xcc, 0x2d, 0xce, 0x39, 0xf5, 0x1e, 0xa2 );

// {1E5B21BC-386B-4937-9C78-B07311115975}
DEFINE_GUID( TASKID_Minor_Next_Enum_Networks,
0x1e5b21bc, 0x386b, 0x4937, 0x9c, 0x78, 0xb0, 0x73, 0x11, 0x11, 0x59, 0x75 );

// {E707F47D-0C17-4e48-BC6B-41954CB2AD5F}
DEFINE_GUID( TASKID_Minor_Next_Failed,
0xe707f47d, 0xc17, 0x4e48, 0xbc, 0x6b, 0x41, 0x95, 0x4c, 0xb2, 0xad, 0x5f );

// {E8FB8701-E11B-4d6b-915C-AA6419D1B168}
DEFINE_GUID( TASKID_Minor_Clone_Enum_Networks,
0xe8fb8701, 0xe11b, 0x4d6b, 0x91, 0x5c, 0xaa, 0x64, 0x19, 0xd1, 0xb1, 0x68 );

// {46554D86-113D-4ca3-8DC4-91D0071053D5}
DEFINE_GUID( TASKID_Minor_HrAddNetworkToArray,
0x46554d86, 0x113d, 0x4ca3, 0x8d, 0xc4, 0x91, 0xd0, 0x7, 0x10, 0x53, 0xd5 );

// {96C68A63-5029-4f31-8E92-6314C4FD3541}
DEFINE_GUID( TASKID_Minor_HrGetNetworks,
0x96c68a63, 0x5029, 0x4f31, 0x8e, 0x92, 0x63, 0x14, 0xc4, 0xfd, 0x35, 0x41 );

// {BC0DE6D0-72EF-4162-BEA0-E0D9DD064F93}
DEFINE_GUID( TASKID_Minor_HrGetNetworks_NotConnected,
0xbc0de6d0, 0x72ef, 0x4162, 0xbe, 0xa0, 0xe0, 0xd9, 0xdd, 0x6, 0x4f, 0x93 );

// {ADB5F707-16F3-4b52-B00D-862F3D5BEADA}
DEFINE_GUID( TASKID_Minor_HrGetNetworks_Skipped,
0xadb5f707, 0x16f3, 0x4b52, 0xb0, 0xd, 0x86, 0x2f, 0x3d, 0x5b, 0xea, 0xda );

// {50A0FFC1-3036-4398-9C43-314E832A8829}
DEFINE_GUID( TASKID_Minor_HrGetNetworks_DHCP_Enabled, 
0x50a0ffc1, 0x3036, 0x4398, 0x9c, 0x43, 0x31, 0x4e, 0x83, 0x2a, 0x88, 0x29 );

// {AC0A480A-16C6-439c-B4F1-7A4D612BF3F5}
DEFINE_GUID( TASKID_Minor_WQL_Network_Qry_Next_Failed,
0xac0a480a, 0x16c6, 0x439c, 0xb4, 0xf1, 0x7a, 0x4d, 0x61, 0x2b, 0xf3, 0xf5 );

// {7E313740-CB90-4f66-B646-23BC9FDD7D72}
DEFINE_GUID( TASKID_Minor_Next_Enum_Cluster_Resources,
0x7e313740, 0xcb90, 0x4f66, 0xb6, 0x46, 0x23, 0xbc, 0x9f, 0xdd, 0x7d, 0x72 );

// {B619CFE1-F5AA-4de3-A22F-8BE1B5D6D302}
DEFINE_GUID( TASKID_Minor_Clone_Enum_Cluster_Resources,
0xb619cfe1, 0xf5aa, 0x4de3, 0xa2, 0x2f, 0x8b, 0xe1, 0xb5, 0xd6, 0xd3, 0x2 );

// {10C04223-A0C6-4baf-82A0-59574E0ED277}
DEFINE_GUID( TASKID_Minor_HrAddResourceToArray,
0x10c04223, 0xa0c6, 0x4baf, 0x82, 0xa0, 0x59, 0x57, 0x4e, 0xe, 0xd2, 0x77 );

// {629582D3-4CB7-4b2d-9D61-3EDD6090A17E}
DEFINE_GUID( TASKID_Minor_SetWbemServices_Enum_PhysDisk,
0x629582d3, 0x4cb7, 0x4b2d, 0x9d, 0x61, 0x3e, 0xdd, 0x60, 0x90, 0xa1, 0x7e );

// {2C10D58F-A354-456d-8B2F-8622893A0284}
DEFINE_GUID( TASKID_Minor_Next_Enum_PhysDisk,
0x2c10d58f, 0xa354, 0x456d, 0x8b, 0x2f, 0x86, 0x22, 0x89, 0x3a, 0x2, 0x84 );

// {A4E0873B-9FA4-4805-BC80-A1982F3FC861}
DEFINE_GUID( TASKID_Minor_Clone_Enum_PhysDisk,
0xa4e0873b, 0x9fa4, 0x4805, 0xbc, 0x80, 0xa1, 0x98, 0x2f, 0x3f, 0xc8, 0x61 );

// {888EDC6F-EDC9-4fde-B6C0-80A951D7816C}
DEFINE_GUID( TASKID_Minor_HrGetDisks,
0x888edc6f, 0xedc9, 0x4fde, 0xb6, 0xc0, 0x80, 0xa9, 0x51, 0xd7, 0x81, 0x6c );

// {482996DE-E635-4e3f-AD48-9BD43F2275DC}
DEFINE_GUID( TASKID_Minor_HrAddDiskToArray,
0x482996de, 0xe635, 0x4e3f, 0xad, 0x48, 0x9b, 0xd4, 0x3f, 0x22, 0x75, 0xdc );

// {4956B4F1-D6E8-496c-8852-E07BEB155DBA}
DEFINE_GUID( TASKID_Minor_HrIsLogicalDiskNTFS,
0x4956b4f1, 0xd6e8, 0x496c, 0x88, 0x52, 0xe0, 0x7b, 0xeb, 0x15, 0x5d, 0xba );

// {AED97D3F-FA6A-4234-86D1-84899EF85371}
DEFINE_GUID( TASKID_Minor_WQL_Disk_Qry_Next_Failed,
0xaed97d3f, 0xfa6a, 0x4234, 0x86, 0xd1, 0x84, 0x89, 0x9e, 0xf8, 0x53, 0x71 );

// {97E9FCEE-78BA-4a52-9F75-2B0D13F1B126}
DEFINE_GUID( TASKID_Minor_HrIsLogicalDiskNTFS_InvalidArg,
0x97e9fcee, 0x78ba, 0x4a52, 0x9f, 0x75, 0x2b, 0xd, 0x13, 0xf1, 0xb1, 0x26 );

// {AD7ED679-B5C9-4c83-9C4C-DA538BFF3FF9}
DEFINE_GUID( TASKID_Minor_SetWbemServices_PhysDisk,
0xad7ed679, 0xb5c9, 0x4c83, 0x9c, 0x4c, 0xda, 0x53, 0x8b, 0xff, 0x3f, 0xf9 );

// {092E4850-AAB4-4e5d-A4CE-F176F789098D}
DEFINE_GUID( TASKID_Minor_Next_PhysDisk,
0x92e4850, 0xaab4, 0x4e5d, 0xa4, 0xce, 0xf1, 0x76, 0xf7, 0x89, 0x9, 0x8d );

// {AD3E8683-571D-4103-9ECC-3DB5489CB9F6}
DEFINE_GUID( TASKID_Minor_Clone_PhysDisk,
0xad3e8683, 0x571d, 0x4103, 0x9e, 0xcc, 0x3d, 0xb5, 0x48, 0x9c, 0xb9, 0xf6 );

// {F4ECC965-DF3F-47b8-B26D-BE5AFA146728}
DEFINE_GUID( TASKID_Minor_ClusterResource_GetName_Pointer,
0xf4ecc965, 0xdf3f, 0x47b8, 0xb2, 0x6d, 0xbe, 0x5a, 0xfa, 0x14, 0x67, 0x28 );

// {A6CC2876-DDDE-4be7-B426-3F74D8F31B7F}
DEFINE_GUID( TASKID_Minor_PartitionInfo_GetName_Memory,
0xa6cc2876, 0xddde, 0x4be7, 0xb4, 0x26, 0x3f, 0x74, 0xd8, 0xf3, 0x1b, 0x7f );

// {DD58545C-B3A4-4754-B51D-2C5A2CD5221D}
DEFINE_GUID( TASKID_Minor_GetDriveLetterMappings_PhysDisk,
0xdd58545c, 0xb3a4, 0x4754, 0xb5, 0x1d, 0x2c, 0x5a, 0x2c, 0xd5, 0x22, 0x1d );

// {D81C8511-2C05-4e31-872C-BF0D3B8CCF21}
DEFINE_GUID( TASKID_Minor_HrGetSCSIBus,
0xd81c8511, 0x2c05, 0x4e31, 0x87, 0x2c, 0xbf, 0xd, 0x3b, 0x8c, 0xcf, 0x21 );

// {1427BB1B-D5E5-49e0-B1EC-9ADE2F56E168}
DEFINE_GUID( TASKID_Minor_HrGetSCSIPort,
0x1427bb1b, 0xd5e5, 0x49e0, 0xb1, 0xec, 0x9a, 0xde, 0x2f, 0x56, 0xe1, 0x68 );

// {7FB74F1A-7C37-4f99-9603-6C4FBD5DEA46}
DEFINE_GUID( TASKID_Minor_HrGetDeviceID_Pointer,
0x7fb74f1a, 0x7c37, 0x4f99, 0x96, 0x3, 0x6c, 0x4f, 0xbd, 0x5d, 0xea, 0x46 );

// {BFC4FD0B-C45E-4c57-A547-5D5DABCC15E5}
DEFINE_GUID( TASKID_Minor_HrGetDeviceID_Memory,
0xbfc4fd0b, 0xc45e, 0x4c57, 0xa5, 0x47, 0x5d, 0x5d, 0xab, 0xcc, 0x15, 0xe5 );

// {5CD9E507-7054-4072-A76F-ED5364BF7E54}
DEFINE_GUID( TASKID_Minor_SetWbemObject_PhysDisk,
0x5cd9e507, 0x7054, 0x4072, 0xa7, 0x6f, 0xed, 0x53, 0x64, 0xbf, 0x7e, 0x54 );

// {4631DF4F-B40A-47d5-9087-95FCA29727C6}
DEFINE_GUID( TASKID_Minor_SetName_PhysDisk,
0x4631df4f, 0xb40a, 0x47d5, 0x90, 0x87, 0x95, 0xfc, 0xa2, 0x97, 0x27, 0xc6 );

// {4631DF4F-B40A-47d5-9087-95FCA29727C6}
DEFINE_GUID( TASKID_Minor_HrGetPartitionInfo,
0x4631df4f, 0xb40a, 0x47d5, 0x90, 0x87, 0x95, 0xfc, 0xa2, 0x97, 0x27, 0xc6 );

// {EF5AD4D5-0CC3-4026-B968-DBC244C5AC07}
DEFINE_GUID( TASKID_Minor_HrAddPartitionToArray,
0xef5ad4d5, 0xcc3, 0x4026, 0xb9, 0x68, 0xdb, 0xc2, 0x44, 0xc5, 0xac, 0x7 );

// {BF8CF687-6066-43af-99AD-2B778028B9E3}
DEFINE_GUID( TASKID_Minor_HrCreateFriendlyName_VOID,
0xbf8cf687, 0x6066, 0x43af, 0x99, 0xad, 0x2b, 0x77, 0x80, 0x28, 0xb9, 0xe3 );

// {44749035-31A1-48ab-932C-A393EA28631D}
DEFINE_GUID( TASKID_Minor_HrCreateFriendlyName_BSTR,
0x44749035, 0x31a1, 0x48ab, 0x93, 0x2c, 0xa3, 0x93, 0xea, 0x28, 0x63, 0x1d );

// {E988F59E-7BAF-4364-99D0-E8A78279FF08}
DEFINE_GUID( TASKID_Minor_WQL_Partition_Qry_Next_Failed,
0xe988f59e, 0x7baf, 0x4364, 0x99, 0xd0, 0xe8, 0xa7, 0x82, 0x79, 0xff, 0x8 );

// {96F37AE0-DEB2-4378-8830-090392478188}
DEFINE_GUID( TASKID_Minor_ClusterResource_GetUID_Pointer,
0x96f37ae0, 0xdeb2, 0x4378, 0x88, 0x30, 0x9, 0x3, 0x92, 0x47, 0x81, 0x88 );

// {7950A141-82C4-42d3-9471-21EFFE51B8FE}
DEFINE_GUID( TASKID_Minor_ClusterResource_GetUID_Memory,
0x7950a141, 0x82c4, 0x42d3, 0x94, 0x71, 0x21, 0xef, 0xfe, 0x51, 0xb8, 0xfe );

// {63945EA5-68BF-460e-84BA-F54B4057B4D6}
DEFINE_GUID( TASKID_Minor_GetName_Pointer,
0x63945ea5, 0x68bf, 0x460e, 0x84, 0xba, 0xf5, 0x4b, 0x40, 0x57, 0xb4, 0xd6 );

// {EC0DF1B1-195D-45bd-AF42-8DA99CFF0E2E}
DEFINE_GUID( TASKID_Minor_ClusterResources_GetName_Memory,
0xec0df1b1, 0x195d, 0x45bd, 0xaf, 0x42, 0x8d, 0xa9, 0x9c, 0xff, 0xe, 0x2e );

// {479E7453-F593-41e7-9C58-90190B51F199}
DEFINE_GUID( TASKID_Minor_LoadResource,
0x479e7453, 0xf593, 0x41e7, 0x9c, 0x58, 0x90, 0x19, 0xb, 0x51, 0xf1, 0x99 );

// {7F7FDF6C-7F68-46bc-BA26-D52320342DBB}
DEFINE_GUID( TASKID_Minor_SetName_Cluster_Resource,
0x7f7fdf6c, 0x7f68, 0x46bc, 0xba, 0x26, 0xd5, 0x23, 0x20, 0x34, 0x2d, 0xbb );

// {52436DAE-9837-4fcc-8F66-57646138E71B}
DEFINE_GUID( TASKID_Minor_PhysDisk_GetUID_Pointer,
0x52436dae, 0x9837, 0x4fcc, 0x8f, 0x66, 0x57, 0x64, 0x61, 0x38, 0xe7, 0x1b );

// {70CB0281-0FE7-47d8-B578-7335D17DC3DC}
DEFINE_GUID( TASKID_Minor_PhysDisk_GetUID_Memory,
0x70cb0281, 0xfe7, 0x47d8, 0xb5, 0x78, 0x73, 0x35, 0xd1, 0x7d, 0xc3, 0xdc );

// {5B18AB3B-F132-4a90-8664-195AF375DA21}
DEFINE_GUID( TASKID_Minor_Warning_No_IP_Addresses,
0x5b18ab3b, 0xf132, 0x4a90, 0x86, 0x64, 0x19, 0x5a, 0xf3, 0x75, 0xda, 0x21 );

// {47ACE51F-7D82-4807-90FF-0EC19460CDD8}
DEFINE_GUID( TASKID_Minor_WMI_OS_Qry_Next_Failed,
0x47ace51f, 0x7d82, 0x4807, 0x90, 0xff, 0xe, 0xc1, 0x94, 0x60, 0xcd, 0xd8 );

// {7C8D38EB-6478-4ada-8EF3-08A4D1D45BCA}
DEFINE_GUID( TASKID_Minor_WMI_PageFile_Qry_Next_Failed,
0x7c8d38eb, 0x6478, 0x4ada, 0x8e, 0xf3, 0x8, 0xa4, 0xd1, 0xd4, 0x5b, 0xca );

// {A3CD319B-6365-4c0f-A407-63356D9F750A}
DEFINE_GUID( TASKID_Minor_Warning_NLBS_Detected,
0xa3cd319b, 0x6365, 0x4c0f, 0xa4, 0x7, 0x63, 0x35, 0x6d, 0x9f, 0x75, 0xa );

// {AFAE5AED-F023-4f88-8132-E48B5852139F}
DEFINE_GUID( TASKID_Minor_Validating_Node_OS_Version,
0xafae5aed, 0xf023, 0x4f88, 0x81, 0x32, 0xe4, 0x8b, 0x58, 0x52, 0x13, 0x9f );

// {E90771CD-5FB5-42b1-9BEF-AD88482FC70A}
DEFINE_GUID( TASKID_Minor_LocalQuorum_GetUID_Pointer,
0xe90771cd, 0x5fb5, 0x42b1, 0x9b, 0xef, 0xad, 0x88, 0x48, 0x2f, 0xc7, 0xa );

// {FD5ACD31-B3F6-4025-8C36-9F2F2F4632AB}
DEFINE_GUID( TASKID_Minor_LocalQuorum_GetUID_Memory,
0xfd5acd31, 0xb3f6, 0x4025, 0x8c, 0x36, 0x9f, 0x2f, 0x2f, 0x46, 0x32, 0xab );

// {44E18661-5274-4ba9-8499-1CB30846063D}
DEFINE_GUID( TASKID_Minor_LocalQuorum_GetName_Pointer,
0x44e18661, 0x5274, 0x4ba9, 0x84, 0x99, 0x1c, 0xb3, 0x8, 0x46, 0x6, 0x3d );

// {7F35E707-E4B8-48ee-95AB-573A23688C29}
DEFINE_GUID( TASKID_Minor_LocalQuorum_GetName_Memory,
0x7f35e707, 0xe4b8, 0x48ee, 0x95, 0xab, 0x57, 0x3a, 0x23, 0x68, 0x8c, 0x29 );

// {6BBBE956-2789-4ac0-AE42-4DFA97721960}
DEFINE_GUID( TASKID_Minor_Next_Enum_LocalQuorum,
0x6bbbe956, 0x2789, 0x4ac0, 0xae, 0x42, 0x4d, 0xfa, 0x97, 0x72, 0x19, 0x60 );

// {35EFBE5E-1663-47c7-ADCF-6437D18A8FC3}
DEFINE_GUID( TASKID_Minor_Clone_Enum_LocalQuorum,
0x35efbe5e, 0x1663, 0x47c7, 0xad, 0xcf, 0x64, 0x37, 0xd1, 0x8a, 0x8f, 0xc3 );

// {9401068C-C717-43bc-837B-29602B49466D}
DEFINE_GUID( TASKID_Minor_HrAddLocalQuorumToArray,
0x9401068c, 0xc717, 0x43bc, 0x83, 0x7b, 0x29, 0x60, 0x2b, 0x49, 0x46, 0x6d );

// {BB6A4DD7-BC8F-4d76-9FAE-CEC30DE03403}
DEFINE_GUID( TASKID_Minor_PhysDisk_PreCreate,
0xbb6a4dd7, 0xbc8f, 0x4d76, 0x9f, 0xae, 0xce, 0xc3, 0xd, 0xe0, 0x34, 0x3 );

// {A4E827B3-67AF-4642-B0C4-7DF1B66CBE3A}
DEFINE_GUID( TASKID_Minor_PhysDisk_Create,
0xa4e827b3, 0x67af, 0x4642, 0xb0, 0xc4, 0x7d, 0xf1, 0xb6, 0x6c, 0xbe, 0x3a );

// {FA3930F4-B00E-4b12-BCE2-5C8E661EE037}
DEFINE_GUID( TASKID_Minor_Partition_GPT_Disk,
0xfa3930f4, 0xb00e, 0x4b12, 0xbc, 0xe2, 0x5c, 0x8e, 0x66, 0x1e, 0xe0, 0x37 );

// {D6B40DC2-4D5A-42e0-8339-FB6716ACA5CB}
DEFINE_GUID( TASKID_Minor_Server_Get_ClusterIPAddress_Info,
0xd6b40dc2, 0x4d5a, 0x42e0, 0x83, 0x39, 0xfb, 0x67, 0x16, 0xac, 0xa5, 0xcb );

// {AD5DD1EA-960B-4bea-9A40-0809238D9BCF}
DEFINE_GUID(TASKID_Minor_Server_LoadNetwork_Info,
0xad5dd1ea, 0x960b, 0x4bea, 0x9a, 0x40, 0x8, 0x9, 0x23, 0x8d, 0x9b, 0xcf );

// {FADB5F0C-6DDA-47c6-91DE-A5E67C687E23}
DEFINE_GUID( TASKID_Minor_Server_Get_ClusterIPAddress_Info_2,
0xfadb5f0c, 0x6dda, 0x47c6, 0x91, 0xde, 0xa5, 0xe6, 0x7c, 0x68, 0x7e, 0x23 );

// {8F1157D7-2F65-4344-B020-D9D7142D083F}
DEFINE_GUID( TASKID_Minor_Server_GetBindingString_Pointer,
0x8f1157d7, 0x2f65, 0x4344, 0xb0, 0x20, 0xd9, 0xd7, 0x14, 0x2d, 0x8, 0x3f );

// {74C364D1-2A05-4127-A3E0-A900F8D28231}
DEFINE_GUID( TASKID_Minor_Server_GetBindingString_Memory,
0x74c364d1, 0x2a05, 0x4127, 0xa3, 0xe0, 0xa9, 0x0, 0xf8, 0xd2, 0x82, 0x31 );

// {44C5E3BD-CE33-4792-8B51-E2A4DE0AD637}
DEFINE_GUID( TASKID_Minor_SetBindingString_Server,
0x44c5e3bd, 0xce33, 0x4792, 0x8b, 0x51, 0xe2, 0xa4, 0xde, 0xa, 0xd6, 0x37 );

// {F1B0DA3D-B454-437d-BA3C-37F92C6401BE}
DEFINE_GUID( TASKID_Minor_NodeInfo_GetBindingString_Pointer,
0xf1b0da3d, 0xb454, 0x437d, 0xba, 0x3c, 0x37, 0xf9, 0x2c, 0x64, 0x1, 0xbe );

// {EE35061D-C8B0-4afe-8E42-D81E60062DAE}
DEFINE_GUID(TASKID_Minor_ClusterInfo_GetBindingString_Pointer,
0xee35061d, 0xc8b0, 0x4afe, 0x8e, 0x42, 0xd8, 0x1e, 0x60, 0x6, 0x2d, 0xae );

// {9990A0E2-A2A4-4c73-A10B-6D2610B564FE}
DEFINE_GUID( TASKID_Minor_GetBindingString_Binding_String_NULL,
0x9990a0e2, 0xa2a4, 0x4c73, 0xa1, 0xb, 0x6d, 0x26, 0x10, 0xb5, 0x64, 0xfe );

// {D776757B-1457-4851-94E4-DC73F4F7E888}
DEFINE_GUID( TASKID_Minor_GetBindingString_Memory,
0xd776757b, 0x1457, 0x4851, 0x94, 0xe4, 0xdc, 0x73, 0xf4, 0xf7, 0xe8, 0x88 );

// {751E68B3-176B-4d7a-95FC-1CA5F501177A}
DEFINE_GUID( TASKID_Minor_SetBindingString_Cluster,
0x751e68b3, 0x176b, 0x4d7a, 0x95, 0xfc, 0x1c, 0xa5, 0xf5, 0x1, 0x17, 0x7a );

// {51414234-AEB5-4713-AE12-2074D3DDD5BF}
DEFINE_GUID( TASKID_Minor_Server_GetBindingString_NULL,
0x51414234, 0xaeb5, 0x4713, 0xae, 0x12, 0x20, 0x74, 0xd3, 0xdd, 0xd5, 0xbf );

// {EEF4611E-86CD-4372-A2FB-01721D1E4994}
DEFINE_GUID( TASKID_Minor_Pruning_PageFile_Disk_Bus,
0xeef4611e, 0x86cd, 0x4372, 0xa2, 0xfb, 0x1, 0x72, 0x1d, 0x1e, 0x49, 0x94 );

// {13E84779-125E-4b76-8C0D-1F5DB92EFE0F}
DEFINE_GUID( TASKID_Minor_Pruning_Boot_Disk_Bus,
0x13e84779, 0x125e, 0x4b76, 0x8c, 0xd, 0x1f, 0x5d, 0xb9, 0x2e, 0xfe, 0xf );

// {56791EE6-CBFC-46b0-B2FB-3DC26958A525}
DEFINE_GUID( TASKID_Minor_Pruning_System_Disk_Bus,
0x56791ee6, 0xcbfc, 0x46b0, 0xb2, 0xfb, 0x3d, 0xc2, 0x69, 0x58, 0xa5, 0x25 );

// {00AF4C3F-47D5-4e6a-9EF0-6D719A32EE5C}
DEFINE_GUID( TASKID_Minor_Pruned_Disk_From_Bus,
0xaf4c3f, 0x47d5, 0x4e6a, 0x9e, 0xf0, 0x6d, 0x71, 0x9a, 0x32, 0xee, 0x5c );

// {31B1E6B2-A600-48b9-9A28-6D5D52D3AE4C}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_GetUID_Pointer,
0x31b1e6b2, 0xa600, 0x48b9, 0x9a, 0x28, 0x6d, 0x5d, 0x52, 0xd3, 0xae, 0x4c );

// {F7BD9D91-4E55-46b7-A7E5-E6A97E2ADF47}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_GetUID_Memory,
0xf7bd9d91, 0x4e55, 0x46b7, 0xa7, 0xe5, 0xe6, 0xa9, 0x7e, 0x2a, 0xdf, 0x47 );

// {2EF03B9F-FBF7-4207-A831-403F888EE8B7}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_GetName_Pointer,
0x2ef03b9f, 0xfbf7, 0x4207, 0xa8, 0x31, 0x40, 0x3f, 0x88, 0x8e, 0xe8, 0xb7 );

// {1831238B-DA1D-4fad-88F6-244EA1A013E9}
DEFINE_GUID( TASKID_Minor_MajorityNodeSet_GetName_Memory,
0x1831238b, 0xda1d, 0x4fad, 0x88, 0xf6, 0x24, 0x4e, 0xa1, 0xa0, 0x13, 0xe9 );

// {564BFF7B-25E2-4ffe-BD88-01437EE92750}
DEFINE_GUID( TASKID_Minor_ServicesForMac_Installed,
0x564bff7b, 0x25e2, 0x4ffe, 0xbd, 0x88, 0x1, 0x43, 0x7e, 0xe9, 0x27, 0x50 );

// {457DB343-5BD7-4c40-BCFF-83A2355B488B}
DEFINE_GUID(TASKID_Minor_HrInit_Unknown_Network_Role,
0x457db343, 0x5bd7, 0x4c40, 0xbc, 0xff, 0x83, 0xa2, 0x35, 0x5b, 0x48, 0x8b );

// {E729FB8C-FD50-4653-B816-81EC0B752431}
DEFINE_GUID( TASKID_Minor_HrInit_OutOfMemory,
0xe729fb8c, 0xfd50, 0x4653, 0xb8, 0x16, 0x81, 0xec, 0xb, 0x75, 0x24, 0x31 );

// {EF32FFDD-EE89-4e5e-A9D6-EC65C4D2037E}
DEFINE_GUID( TASKID_Minor_HrInit_No_Network_Name,
0xef32ffdd, 0xee89, 0x4e5e, 0xa9, 0xd6, 0xec, 0x65, 0xc4, 0xd2, 0x3, 0x7e );

// {DE52EE4A-7793-4c88-8BF0-32B5BD8F43D6}
DEFINE_GUID( TASKID_Minor_HrInit_Win32Error,
0xde52ee4a, 0x7793, 0x4c88, 0x8b, 0xf0, 0x32, 0xb5, 0xbd, 0x8f, 0x43, 0xd6 );

// {2B389256-859E-470b-A958-961C7787182D}
DEFINE_GUID( TASKID_Minor_Partition_LDM_Disk,
0x2b389256, 0x859e, 0x470b, 0xa9, 0x58, 0x96, 0x1c, 0x77, 0x87, 0x18, 0x2d );

// {A47DF4EE-2700-41f9-B586-87A9A7B38BCF}
DEFINE_GUID( TASKID_Minor_Next_Enum_MajorityNodeSet,
0xa47df4ee, 0x2700, 0x41f9, 0xb5, 0x86, 0x87, 0xa9, 0xa7, 0xb3, 0x8b, 0xcf );

// {1CC44272-E513-432b-A90A-2F07EF3DF43C}
DEFINE_GUID( TASKID_Minor_Clone_Enum_MajorityNodeSet,
0x1cc44272, 0xe513, 0x432b, 0xa9, 0xa, 0x2f, 0x7, 0xef, 0x3d, 0xf4, 0x3c );

// {567E8360-B1BB-4689-871A-6DC09B34A1DD}
DEFINE_GUID( TASKID_Minor_PhysDisk_Not_Cluster_Capable,
0x567e8360, 0xb1bb, 0x4689, 0x87, 0x1a, 0x6d, 0xc0, 0x9b, 0x34, 0xa1, 0xdd );

// {BD205A62-9563-4797-BD26-279806EC1793}
DEFINE_GUID( TASKID_Minor_Found_Non_SCSI_Disk,
0xbd205a62, 0x9563, 0x4797, 0xbd, 0x26, 0x27, 0x98, 0x6, 0xec, 0x17, 0x93 );

// {2778E165-98D2-4ab4-9E05-AE35070E7E3A}
DEFINE_GUID( TASKID_Minor_HrGetSignature_Pointer,
0x2778e165, 0x98d2, 0x4ab4, 0x9e, 0x5, 0xae, 0x35, 0x7, 0xe, 0x7e, 0x3a );

// {E8CBF170-75B0-473a-AED4-31802D79A7D5}
DEFINE_GUID( TASKID_Minor_HrSetFriendlyName_PhysDisk,
0xe8cbf170, 0x75b0, 0x473a, 0xae, 0xd4, 0x31, 0x80, 0x2d, 0x79, 0xa7, 0xd5 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\clocalquorum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CLocalQuorum.cpp
//
//  Description:
//      This file contains the definition of the CLocalQuorum class.
//
//      The class CLocalQuorum represents a cluster manageable
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Documentation:
//
//  Header File:
//      CLocalQuorum.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CLocalQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CLocalQuorum" );

#define LOCAL_QUORUM    L"Local Quorum"


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CLocalQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CLocalQuorum instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CLocalQuorum::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CLocalQuorum *     lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CLocalQuorum();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CLocalQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::S_HrCreateInstance


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::CLocalQuorum
//
//  Description:
//      Constructor of the CLocalQuorum class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CLocalQuorum::CLocalQuorum( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( !m_fIsQuorum );
    Assert( !m_fIsJoinable );
    Assert( !m_fIsManaged );
    Assert( m_bstrName == NULL );

    TraceFuncExit();

} //*** CLocalQuorum::CLocalQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::~CLocalQuorum
//
//  Description:
//      Desstructor of the CLocalQuorum class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CLocalQuorum::~CLocalQuorum( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CLocalQuorum::~CLocalQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CLocalQuorum::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    m_bstrName = TraceSysAllocString( LOCAL_QUORUM );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CLocalQuorum:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CLocalQuorum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CLocalQuorum::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CLocalQuorum:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CLocalQuorum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CLocalQuorum::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgManagedResourceInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceCfg ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceCfg, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING1( hr, riid, IID_IEnumClusCfgPartitions );

} //*** CLocalQuorum::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetUID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( LOCAL_QUORUM );
    if ( *pbstrUIDOut == NULL  )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL  )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetManaged( BOOL fIsManagedIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManaged = fIsManagedIn;

    HRETURN( S_OK );

} //*** CLocalQuorum::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsQuorumDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsQuorumDevice( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorum )
    {
        hr = S_OK;
    } // if:

    LOG_STATUS_REPORT_STRING(
                          L"Local quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"is" : L"is not"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::IsQuorumDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetQuorumedDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetQuorumedDevice( BOOL fIsQuorumDeviceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorum = fIsQuorumDeviceIn;

    LOG_STATUS_REPORT_STRING(
                          L"Setting local quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"to be" : L"to not be"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CLocalQuorum::SetQuorumedDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::IsQuorumCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_FALSE
//          There are not drive letters on this device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_FALSE );

} //*** CLocalQuorum::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CLocalQuorum::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::IsDeviceJoinable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::IsDeviceJoinable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsJoinable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CLocalQuorum::IsDeviceJoinable

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::SetDeviceJoinable
//
//  Description:
//      Sets the joinable flag
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::SetDeviceJoinable( BOOL fIsJoinableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsJoinable = fIsJoinableIn;

    HRETURN( S_OK );

} //*** CLocalQuorum::IsDeviceJoinable


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CLocalQuorum class -- IClusCfgManagedResourceCfg
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::PreCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::PreCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::PreCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::Create
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::Create( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::PostCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::PostCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::PostCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalQuorum::Evict
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CLocalQuorum::Evict( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CLocalQuorum::Evict
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\clocalquorum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CLocalQuorum.h
//
//  Description:
//      This file contains the declaration of the CLocalQuorum
//      class.
//
//      The class CLocalQuorum represents a cluster storage
//      device. It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CLocalQuorum.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CLocalQuorum
//
//  Description:
//      The class CLocalQuorum represents a cluster storage
//      device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//--
//////////////////////////////////////////////////////////////////////////////
class CLocalQuorum
    : public IClusCfgManagedResourceInfo
    , public IClusCfgInitialize
    , public IClusCfgManagedResourceCfg
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fIsQuorum:1;
    BOOL                m_fIsJoinable:1;
    BOOL                m_fIsManaged:1;
    BSTR                m_bstrName;

    // Private constructors and destructors
    CLocalQuorum( void );
    ~CLocalQuorum( void );

    // Private copy constructor to prevent copying.
    CLocalQuorum( const CLocalQuorum & nodeSrc );

    // Private assignment operator to prevent copying.
    const CLocalQuorum & operator = ( const CLocalQuorum & nodeSrc );

    HRESULT HrInit( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR bstrNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumDevice )( void );

    STDMETHOD( SetQuorumedDevice )( BOOL fIsQuorumDeviceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsDeviceJoinable )( void );

    STDMETHOD( SetDeviceJoinable )( BOOL fIsJoinableIn );

    //
    //  IClusCfgManagedResourceCfg
    //

    STDMETHOD( PreCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Create )( IUnknown * punkServicesIn );

    STDMETHOD( PostCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Evict )( IUnknown * punkServicesIn );

}; //*** Class CLocalQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cunknownquorum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CUnknownQuorum.cpp
//
//  Description:
//      This file contains the definition of the CUnknownQuorum class.
//
//      The class CUnknownQuorum represents a cluster quorum
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Documentation:
//
//  Header File:
//      CUnknownQuorum.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CUnknownQuorum.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CUnknownQuorum" );

#define UNKNOWN_QUORUM    L"Unknown Quorum"


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CUnknownQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CUnknownQuorum instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CUnknownQuorum::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CUnknownQuorum *     lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CUnknownQuorum();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CUnknownQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::S_HrCreateInstance
//
//  Description:
//      Create a CUnknownQuorum instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CUnknownQuorum instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CUnknownQuorum::S_HrCreateInstance(
      LPCWSTR       pcszNameIn
    , BOOL          fMakeQuorumIn
    , IUnknown **   ppunkOut
     )
{
    TraceFunc( "" );

    HRESULT             hr;
    CUnknownQuorum *     lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CUnknownQuorum();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit( pcszNameIn, fMakeQuorumIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CUnknownQuorum::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::S_HrCreateInstance


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::CUnknownQuorum
//
//  Description:
//      Constructor of the CUnknownQuorum class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CUnknownQuorum::CUnknownQuorum( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( !m_fIsQuorum );
    Assert( !m_fIsJoinable );
    Assert( !m_fIsManaged );
    Assert( m_bstrName == NULL );

    TraceFuncExit();

} //*** CUnknownQuorum::CUnknownQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::~CUnknownQuorum
//
//  Description:
//      Desstructor of the CUnknownQuorum class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CUnknownQuorum::~CUnknownQuorum( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CUnknownQuorum::~CUnknownQuorum


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CUnknownQuorum::HrInit( LPCWSTR pcszNameIn, BOOL fMakeQuorumIn /* = FALSE */ )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    //  If we were handed a name then use it.
    //
    if ( pcszNameIn != NULL )
    {
        m_bstrName = TraceSysAllocString( pcszNameIn );
    } // if:
    else
    {
        m_bstrName = TraceSysAllocString( UNKNOWN_QUORUM );
    } // else:

    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

    //
    //  Default to being joinable.
    //
    m_fIsJoinable = TRUE;
    m_fIsQuorum = fMakeQuorumIn;

    HRETURN( hr );

} //*** CUnknownQuorum::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CUnknownQuorum:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CUnknownQuorum::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CUnknownQuorum::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CUnknownQuorum:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CUnknownQuorum::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CUnknownQuorum::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgManagedResourceInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceCfg ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceCfg, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING1( hr, riid, IID_IEnumClusCfgPartitions );

} //*** CUnknownQuorum::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetUID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( UNKNOWN_QUORUM );
    if ( *pbstrUIDOut == NULL  )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL  )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_LocalQuorum_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetManaged( BOOL fIsManagedIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManaged = fIsManagedIn;

    HRETURN( S_OK );

} //*** CUnknownQuorum::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsQuorumDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsQuorumDevice( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorum )
    {
        hr = S_OK;
    } // if:

    LOG_STATUS_REPORT_STRING(
                          L"Local quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"is" : L"is not"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::IsQuorumDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetQuorumedDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetQuorumedDevice( BOOL fIsQuorumDeviceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorum = fIsQuorumDeviceIn;

    LOG_STATUS_REPORT_STRING(
                          L"Setting local quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"to be" : L"to not be"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CUnknownQuorum::SetQuorumedDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::IsQuorumCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_FALSE
//          There are not drive letters on this device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_FALSE );

} //*** CUnknownQuorum::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CUnknownQuorum::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::IsDeviceJoinable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::IsDeviceJoinable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsJoinable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CUnknownQuorum::IsDeviceJoinable

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::SetDeviceJoinable
//
//  Description:
//      Sets the joinable flag
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::SetDeviceJoinable( BOOL fIsJoinableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsJoinable = fIsJoinableIn;

    HRETURN( S_OK );

} //*** CUnknownQuorum::IsDeviceJoinable


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CUnknownQuorum class -- IClusCfgManagedResourceCfg
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::PreCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::PreCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::PreCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::Create
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::Create( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::PostCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::PostCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::PostCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CUnknownQuorum::Evict
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CUnknownQuorum::Evict( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CUnknownQuorum::Evict
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cmajoritynodeset.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CMajorityNodeSet.h
//
//  Description:
//      This file contains the declaration of the CMajorityNodeSet
//      class.
//
//      The class CMajorityNodeSet represents a cluster storage
//      device. It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CMajorityNodeSet.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CMajorityNodeSet
//
//  Description:
//      The class CMajorityNodeSet represents a cluster storage device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//--
//////////////////////////////////////////////////////////////////////////////
class CMajorityNodeSet
    : public IClusCfgManagedResourceInfo
    , public IClusCfgInitialize
    , public IClusCfgManagedResourceCfg
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fIsQuorum:1;
    BOOL                m_fIsJoinable:1;
    BOOL                m_fIsManaged:1;
    BSTR                m_bstrName;

    // Private constructors and destructors
    CMajorityNodeSet( void );
    ~CMajorityNodeSet( void );

    // Private copy constructor to prevent copying.
    CMajorityNodeSet( const CMajorityNodeSet & nodeSrc );

    // Private assignment operator to prevent copying.
    const CMajorityNodeSet & operator = ( const CMajorityNodeSet & nodeSrc );

    HRESULT HrInit( void );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumDevice )( void );

    STDMETHOD( SetQuorumedDevice )( BOOL fIsQuorumDeviceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsDeviceJoinable )( void );

    STDMETHOD( SetDeviceJoinable )( BOOL fIsJoinableIn );

    //
    //  IClusCfgManagedResourceCfg
    //

    STDMETHOD( PreCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Create )( IUnknown * punkServicesIn );

    STDMETHOD( PostCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Evict )( IUnknown * punkServicesIn );

}; //*** Class CMajorityNodeSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cphysicaldisk.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CPhysicalDisk.cpp
//
//  Description:
//      This file contains the definition of the CPhysicalDisk
//       class.
//
//      The class CPhysicalDisk represents a cluster manageable
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Documentation:
//
//  Header File:
//      CPhysicalDisk.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CPhysicalDisk.h"
#include "CClusCfgPartitionInfo.h"
#include <devioctl.h>
#include <ntddstor.h>
#include <ntddscsi.h>
#include <ClusDisk.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CPhysicalDisk" );


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::S_HrCreateInstance
//
//  Description:
//      Create a CPhysicalDisk instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CPhysicalDisk instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CPhysicalDisk *     lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CPhysicalDisk();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CPhysicalDisk::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::CPhysicalDisk
//
//  Description:
//      Constructor of the CPhysicalDisk class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CPhysicalDisk::CPhysicalDisk( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_pIWbemServices == NULL );
    Assert( m_bstrName == NULL );
    Assert( m_bstrDeviceID == NULL );
    Assert( m_bstrDescription == NULL );
    Assert( m_idxNextPartition == 0 );
    Assert( m_ulSCSIBus == 0 );
    Assert( m_ulSCSITid == 0 );
    Assert( m_ulSCSIPort == 0 );
    Assert( m_ulSCSILun == 0 );
    Assert( m_idxEnumPartitionNext == 0 );
    Assert( m_prgPartitions == NULL );
    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( m_dwSignature == 0 );
    Assert( m_bstrFriendlyName == NULL );
    Assert( m_bstrFirmwareSerialNumber == NULL );
    Assert( !m_fIsManaged );
    Assert( m_cPartitions == 0 );

    TraceFuncExit();

} //*** CPhysicalDisk::CPhysicalDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::~CPhysicalDisk
//
//  Description:
//      Desstructor of the CPhysicalDisk class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CPhysicalDisk::~CPhysicalDisk( void )
{
    TraceFunc( "" );

    ULONG   idx;

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrDeviceID );
    TraceSysFreeString( m_bstrDescription );
    TraceSysFreeString( m_bstrFriendlyName );
    TraceSysFreeString( m_bstrFirmwareSerialNumber );

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        ((*m_prgPartitions)[ idx ])->Release();
    } // for:

    TraceFree( m_prgPartitions );

    if ( m_pIWbemServices != NULL )
    {
        m_pIWbemServices->Release();
    } // if:

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CPhysicalDisk::~CPhysicalDisk


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CPhysicalDisk:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPhysicalDisk::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CPhysicalDisk::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CPhysicalDisk:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CPhysicalDisk::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CPhysicalDisk::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgManagedResourceInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgWbemServices ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgWbemServices, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgSetWbemObject ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgSetWbemObject, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IEnumClusCfgPartitions ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgPartitions, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgPhysicalDiskProperties ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgPhysicalDiskProperties, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceCfg ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceCfg, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CPhysicalDisk::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgWbemServices interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetWbemServices
//
//  Description:
//      Set the WBEM services provider.
//
//  Arguments:
//    IN  IWbemServices  pIWbemServicesIn
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pIWbemServicesIn param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetWbemServices( IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "[IClusCfgWbemServices]" );

    HRESULT hr = S_OK;

    if ( pIWbemServicesIn == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemServices_PhysDisk, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    m_pIWbemServices = pIWbemServicesIn;
    m_pIWbemServices->AddRef();

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::SetWbemServices


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IEnumClusCfgPartitions interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Next
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The rgpPartitionInfoOut param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Next(
    ULONG                       cNumberRequestedIn,
    IClusCfgPartitionInfo **    rgpPartitionInfoOut,
    ULONG *                     pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT                 hr = S_FALSE;
    ULONG                   cFetched = 0;
    ULONG                   idx;
    IClusCfgPartitionInfo * pccpi;

    if ( rgpPartitionInfoOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Next_PhysDisk, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = 0;
    } // if:

    if ( m_prgPartitions == NULL )
    {
        LOG_STATUS_REPORT1( TASKID_Minor_PhysDisk_No_Partitions, L"A physical disk does not have a partitions enumerator", hr );
        goto Cleanup;
    } // if:

    cFetched = min( cNumberRequestedIn, ( m_idxNextPartition - m_idxEnumPartitionNext ) );

    for ( idx = 0; idx < cFetched; idx++, m_idxEnumPartitionNext++ )
    {
        hr = THR( ((*m_prgPartitions)[ m_idxEnumPartitionNext ])->TypeSafeQI( IClusCfgPartitionInfo, &pccpi ) );
        if ( FAILED( hr ) )
        {
            LogMsg( L"[SRV] CPhysicalDisk::Next() could not query for IClusCfgPartitionInfo. (hr = %#08x)", hr );
            break;
        } // if:

        rgpPartitionInfoOut[ idx ] = pccpi;
    } // for:

    if ( FAILED( hr ) )
    {
        ULONG   idxStop = idx;

        m_idxEnumPartitionNext -= idx;

        for ( idx = 0; idx < idxStop; idx++ )
        {
            (rgpPartitionInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;
        goto Cleanup;
    } // if:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Skip
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    m_idxEnumPartitionNext += cNumberToSkipIn;
    if ( m_idxEnumPartitionNext > m_idxNextPartition )
    {
        m_idxEnumPartitionNext = m_idxNextPartition;
        hr = S_FALSE;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::Skip


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Reset
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Reset( void )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    m_idxEnumPartitionNext = 0;

    HRETURN( hr );

} //*** CPhysicalDisk::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Clone
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The ppEnumClusCfgPartitionsOut param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Clone( IEnumClusCfgPartitions ** ppEnumClusCfgPartitionsOut )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    if ( ppEnumClusCfgPartitionsOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_Clone_PhysDisk, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    hr = THR( E_NOTIMPL );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Count
//
//  Description:
//
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The pnCountOut param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = THR( S_OK );

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    *pnCountOut = m_cPartitions;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::Count


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgSetWbemObject interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetWbemObject
//
//  Description:
//      Set the disk information information provider.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetWbemObject(
      IWbemClassObject *    pDiskIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "[IClusCfgSetWbemObject]" );
    Assert( pDiskIn != NULL );
    Assert( pfRetainObjectOut != NULL );

    HRESULT hr = S_FALSE;
    VARIANT var;

    m_fIsQuorumCapable = TRUE;
    m_fIsQuorumJoinable = TRUE;

    VariantInit( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"Name", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrCreateFriendlyName( var.bstrVal ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDeviceID = TraceSysAllocString( var.bstrVal );
    if (m_bstrDeviceID == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"Description", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_bstrDescription = TraceSysAllocString( var.bstrVal );
    if ( m_bstrDescription == NULL  )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"SCSIBus", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_ulSCSIBus = var.lVal;

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"SCSITargetId", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_ulSCSITid = var.lVal;

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"SCSIPort", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_ulSCSIPort = var.lVal;

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pDiskIn, L"SCSILogicalUnit", VT_I4, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    m_ulSCSILun = var.lVal;

    VariantClear( &var );

    //
    //  KB: 23-JUN-2000 GalenB
    //
    //  Yucky code.  Since we cannot read the signature for a clustered disk we have to handle the
    //  empty property case properly.
    //

    hr = HrGetWMIProperty( pDiskIn, L"Signature", VT_I4, &var );
    if ( ( hr == E_PROPTYPEMISMATCH ) && ( var.vt == VT_NULL ) )
    {
        hr = S_OK;
    } // if: property is empty
    else if ( SUCCEEDED( hr ) )
    {
        m_dwSignature = (DWORD) var.lVal;
    } // else if:

    if ( FAILED( hr ) )
    {
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PhysDisk_Signature, IDS_ERROR_PHYSDISK_SIGNATURE, hr );
        THR( hr );
        goto Cleanup;
    } // if:

    VariantClear( &var );

    hr = STHR( HrGetPartitionInfo( pDiskIn, pfRetainObjectOut ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  KB: 28-JUL-2000 GalenB
    //
    //  HrGetPartitionInfo() returns S_FALSE when it cannot get the partition info for a disk.
    //  This is usually caused by the disk already being under ClusDisk control.  This is not
    //  and error, it just means we cannot query the partition or logical drive info.
    //
    if ( hr == S_OK )
    {
        hr = THR( HrCreateFriendlyName() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  Since we have partition info we also have a signature and need to see if this
        //  disk is cluster capable.
        hr = STHR( HrIsClusterCapable() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        //
        //  If the disk is not cluster capable then we don't want the enumerator
        //  to keep it.
        //
        if ( hr == S_FALSE )
        {
            *pfRetainObjectOut = false;
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_PhysDisk_Not_Cluster_Capable, IDS_INFO_PHYSDISK_NOT_CLUSTER_CAPABLE, m_bstrFriendlyName, hr );
        } // if:
    } // if:

    //
    //  TODO:   15-MAR-2001 GalenB
    //
    //  Need to check this error code when this feature is complete!
    //
    /*hr = */THR( HrGetDiskFirmwareSerialNumber() );

//    THR( HrGetDiskFirmwareVitalData() );

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetWbemObject_PhysDisk, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    HRETURN( hr );

} //*** CPhysicalDisk::SetWbemObject


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::GetUID
//
//  Description:
//
//  Arguments:
//      pbstrUIDOut
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;
    WCHAR   sz[ 256 ];

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PhysDisk_GetUID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    _snwprintf( sz, ARRAYSIZE( sz ), L"SCSI Tid %ld, SCSI Lun %ld", m_ulSCSITid, m_ulSCSILun );
    *pbstrUIDOut = SysAllocString( sz );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_PhysDisk_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    //
    //  Prefer the "friendly" name over the WMI name -- if we have it...
    //
    if ( m_bstrFriendlyName != NULL )
    {
        *pbstrNameOut = SysAllocString( m_bstrFriendlyName );
    } // if:
    else
    {
        *pbstrNameOut = SysAllocString( m_bstrName );
    } // else:

    if (*pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ws'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_SetName_PhysDisk, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

    //
    // Since we got asked from the outside to set a new name, this should actually be reflected in
    // the friendly name, too, since that, ultimately, gets preference over the real name
    //
    hr = HrSetFriendlyName( pcszNameIn );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetManaged
//
//  Description:
//
//  Arguments:
//      fIsManagedIn
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetManaged( BOOL fIsManagedIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsManaged = fIsManagedIn;

    LOG_STATUS_REPORT_STRING2(
                          L"Physical disk '%1!ws!' '%2!ws!"
                        , ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrName
                        , fIsManagedIn ? L"is managed" : L"is not managed"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsQuorumDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsQuorumDevice( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumDevice )
    {
        hr = S_OK;
    } // if:

    LOG_STATUS_REPORT_STRING2(
                          L"Physical disk '%1!ws!' '%2!ws!' the quorum device."
                        , ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrDeviceID
                        , m_fIsQuorumDevice ? L"is" : L"is not"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::IsQuorumDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetQuorumedDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetQuorumedDevice( BOOL fIsQuorumDeviceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorumDevice = fIsQuorumDeviceIn;

    LOG_STATUS_REPORT_STRING2(
                          L"Setting physical disk '%1!ws!' '%2!ws!' the quorum device."
                        , ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrDeviceID
                        , m_fIsQuorumDevice ? L"to be" : L"to not be"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::SetQuorumedDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumCapable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsQuorumCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT                 hr = S_FALSE;
    IClusCfgPartitionInfo * piccpi = NULL;
    ULONG                   idx;

    if ( pdlmDriveLetterMappingOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_GetDriveLetterMappings_PhysDisk, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        hr = ( ((*m_prgPartitions)[ idx ])->TypeSafeQI( IClusCfgPartitionInfo, &piccpi ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( piccpi->GetDriveLetterMappings( pdlmDriveLetterMappingOut ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        piccpi->Release();
        piccpi = NULL;
    } // for:

Cleanup:

    if ( piccpi != NULL )
    {
        piccpi->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CPhysicalDisk::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsDeviceJoinable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The quorumable device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsDeviceJoinable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorumJoinable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsDeviceJoinable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::SetDeviceJoinable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The quorumable device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This function should never be called
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::SetDeviceJoinable( BOOL fIsJoinableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CPhysicalDisk::IsDeviceJoinable


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class -- IClusCfgPhysicalDiskProperties Interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::IsThisLogicalDisk
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::IsThisLogicalDisk( WCHAR cLogicalDiskIn )
{
    TraceFunc( "[IClusCfgPhysicalDiskProperties]" );

    HRESULT                         hr = S_FALSE;
    ULONG                           idx;
    IClusCfgPartitionProperties *   piccpp = NULL;

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        hr = ( ((*m_prgPartitions)[ idx ])->TypeSafeQI( IClusCfgPartitionProperties, &piccpp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( piccpp->IsThisLogicalDisk( cLogicalDiskIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_OK )
        {
            break;
        } // if:

        piccpp->Release();
        piccpp = NULL;
    } // for:

Cleanup:

    if ( piccpp != NULL )
    {
        piccpp->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::IsThisLogicalDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetSCSIBus
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetSCSIBus( ULONG * pulSCSIBusOut )
{
    TraceFunc( "[IClusCfgPhysicalDiskProperties]" );

    HRESULT hr = S_OK;

    if ( pulSCSIBusOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetSCSIBus, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pulSCSIBusOut = m_ulSCSIBus;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetSCSIBus


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetSCSIPort
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetSCSIPort( ULONG * pulSCSIPortOut )
{
    TraceFunc( "[IClusCfgPhysicalDiskProperties]" );

    HRESULT hr = S_OK;

    if ( pulSCSIPortOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetSCSIPort, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pulSCSIPortOut = m_ulSCSIPort;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetSCSIPort


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetDeviceID
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetDeviceID( BSTR * pbstrDeviceIDOut )
{
    TraceFunc( "" );
    Assert( m_bstrDeviceID != NULL );

    HRESULT hr = S_OK;

    if ( pbstrDeviceIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetDeviceID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrDeviceIDOut = TraceSysAllocString( m_bstrDeviceID );
    if ( *pbstrDeviceIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetDeviceID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetDeviceID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetSignature
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrGetSignature( DWORD * pdwSignatureOut )
{
    TraceFunc( "" );
    Assert( m_dwSignature != 0 );

    HRESULT hr = S_OK;

    if ( pdwSignatureOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetSignature_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pdwSignatureOut = m_dwSignature;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetSignature


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrSetFriendlyName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::HrSetFriendlyName( LPCWSTR pcszFriendlyNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszFriendlyNameIn = '%ws'", pcszFriendlyNameIn == NULL ? L"<null>" : pcszFriendlyNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszFriendlyNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszFriendlyNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrSetFriendlyName_PhysDisk, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

    TraceSysFreeString( m_bstrFriendlyName );
    m_bstrFriendlyName = bstr;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrSetFriendlyName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::CanBeManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::CanBeManaged( void )
{
    TraceFunc( "[IClusCfgPhysicalDiskProperties]" );

    HRESULT                         hr = S_OK;
    ULONG                           idx;
    IClusCfgPartitionProperties *   piccpp = NULL;

    //
    //  KB: 12-JUN-2000 GalenB
    //
    //  Turn off the managed state because this disk may already be managed by
    //  another node, or it may be RAW.
    //
    m_fIsManaged = FALSE;

    //
    //  If this disk has no partitions then it may already be managed by
    //  a